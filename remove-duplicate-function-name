# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0bc001f799df5ab6d050dfd7b0bb1ec61b5e66a3
Bug xxx - remove duplicate function names

diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -57,17 +57,17 @@ const gXPInstallObserver = {
         buttons = [];
       }
       else {
         messageString = gNavigatorBundle.getString("xpinstallDisabledMessage");
 
         action = {
           label: gNavigatorBundle.getString("xpinstallDisabledButton"),
           accessKey: gNavigatorBundle.getString("xpinstallDisabledButton.accesskey"),
-          callback: function editPrefs() {
+          callback: function() {
             gPrefService.setBoolPref("xpinstall.enabled", true);
           }
         };
       }
 
       PopupNotifications.show(browser, notificationID, messageString, anchorID,
                               action, null, options);
       break;
diff --git a/browser/base/content/browser-ctrlTab.js b/browser/base/content/browser-ctrlTab.js
--- a/browser/base/content/browser-ctrlTab.js
+++ b/browser/base/content/browser-ctrlTab.js
@@ -5,32 +5,32 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 #endif
  */
 
 /**
  * Tab previews utility, produces thumbnails
  */
 var tabPreviews = {
-  init: function tabPreviews_init() {
+  init: function() {
     if (this._selectedTab)
       return;
     this._selectedTab = gBrowser.selectedTab;
 
     gBrowser.tabContainer.addEventListener("TabSelect", this, false);
     gBrowser.tabContainer.addEventListener("SSTabRestored", this, false);
 
     let screenManager = Cc["@mozilla.org/gfx/screenmanager;1"]
                           .getService(Ci.nsIScreenManager);
     let left = {}, top = {}, width = {}, height = {};
     screenManager.primaryScreen.GetRectDisplayPix(left, top, width, height);
     this.aspectRatio = height.value / width.value;
   },
 
-  get: function tabPreviews_get(aTab) {
+  get: function(aTab) {
     let uri = aTab.linkedBrowser.currentURI.spec;
 
     if (aTab.__thumbnail_lastURI &&
         aTab.__thumbnail_lastURI != uri) {
       aTab.__thumbnail = null;
       aTab.__thumbnail_lastURI = null;
     }
 
@@ -41,17 +41,17 @@ var tabPreviews = {
       let img = new Image;
       img.src = PageThumbs.getThumbnailURL(uri);
       return img;
     }
 
     return this.capture(aTab, !aTab.hasAttribute("busy"));
   },
 
-  capture: function tabPreviews_capture(aTab, aShouldCache) {
+  capture: function(aTab, aShouldCache) {
     let browser = aTab.linkedBrowser;
     let uri = browser.currentURI.spec;
     let canvas = PageThumbs.createCanvas(window);
     PageThumbs.shouldStoreThumbnail(browser, (aDoStore) => {
       if (aDoStore && aShouldCache) {
         PageThumbs.captureAndStore(browser, function () {
           let img = new Image;
           img.src = PageThumbs.getThumbnailURL(uri);
@@ -66,17 +66,17 @@ var tabPreviews = {
             aTab.__thumbnail_lastURI = uri;
           }
         });
       }
     });
     return canvas;
   },
 
-  handleEvent: function tabPreviews_handleEvent(event) {
+  handleEvent: function(event) {
     switch (event.type) {
       case "TabSelect":
         if (this._selectedTab &&
             this._selectedTab.parentNode &&
             !this._pendingUpdate) {
           // Generate a thumbnail for the tab that was selected.
           // The timeout keeps the UI snappy and prevents us from generating thumbnails
           // for tabs that will be closed. During that timeout, don't generate other
@@ -192,57 +192,57 @@ var ctrlTab = {
   get tabPreviewCount () {
     return Math.min(this.maxTabPreviews, this.tabCount);
   },
 
   get tabList () {
     return this._recentlyUsedTabs;
   },
 
-  init: function ctrlTab_init() {
+  init: function() {
     if (!this._recentlyUsedTabs) {
       tabPreviews.init();
 
       this._initRecentlyUsedTabs();
       this._init(true);
     }
   },
 
-  uninit: function ctrlTab_uninit() {
+  uninit: function() {
     this._recentlyUsedTabs = null;
     this._init(false);
   },
 
   prefName: "browser.ctrlTab.previews",
-  readPref: function ctrlTab_readPref() {
+  readPref: function() {
     var enable =
       gPrefService.getBoolPref(this.prefName) &&
       (!gPrefService.prefHasUserValue("browser.ctrlTab.disallowForScreenReaders") ||
        !gPrefService.getBoolPref("browser.ctrlTab.disallowForScreenReaders"));
 
     if (enable)
       this.init();
     else
       this.uninit();
   },
   observe: function (aSubject, aTopic, aPrefName) {
     this.readPref();
   },
 
-  updatePreviews: function ctrlTab_updatePreviews() {
+  updatePreviews: function() {
     for (let i = 0; i < this.previews.length; i++)
       this.updatePreview(this.previews[i], this.tabList[i]);
 
     var showAllLabel = gNavigatorBundle.getString("ctrlTab.listAllTabs.label");
     this.showAllButton.label =
       PluralForm.get(this.tabCount, showAllLabel).replace("#1", this.tabCount);
     this.showAllButton.hidden = !allTabs.canOpen;
   },
 
-  updatePreview: function ctrlTab_updatePreview(aPreview, aTab) {
+  updatePreview: function(aPreview, aTab) {
     if (aPreview == this.showAllButton)
       return;
 
     aPreview._tab = aTab;
 
     if (aPreview.firstChild)
       aPreview.removeChild(aPreview.firstChild);
     if (aTab) {
@@ -266,17 +266,17 @@ var ctrlTab = {
     } else {
       aPreview.hidden = true;
       aPreview.removeAttribute("label");
       aPreview.removeAttribute("tooltiptext");
       aPreview.removeAttribute("image");
     }
   },
 
-  advanceFocus: function ctrlTab_advanceFocus(aForward) {
+  advanceFocus: function(aForward) {
     let selectedIndex = Array.indexOf(this.previews, this.selected);
     do {
       selectedIndex += aForward ? 1 : -1;
       if (selectedIndex < 0)
         selectedIndex = this.previews.length - 1;
       else if (selectedIndex >= this.previews.length)
         selectedIndex = 0;
     } while (this.previews[selectedIndex].hidden);
@@ -290,128 +290,128 @@ var ctrlTab = {
 
     if (this._timer) {
       clearTimeout(this._timer);
       this._timer = null;
       this._openPanel();
     }
   },
 
-  _mouseOverFocus: function ctrlTab_mouseOverFocus(aPreview) {
+  _mouseOverFocus: function(aPreview) {
     if (this._trackMouseOver)
       aPreview.focus();
   },
 
-  pick: function ctrlTab_pick(aPreview) {
+  pick: function(aPreview) {
     if (!this.tabCount)
       return;
 
     var select = (aPreview || this.selected);
 
     if (select == this.showAllButton)
       this.showAllTabs();
     else
       this.close(select._tab);
   },
 
-  showAllTabs: function ctrlTab_showAllTabs(aPreview) {
+  showAllTabs: function(aPreview) {
     this.close();
     document.getElementById("Browser:ShowAllTabs").doCommand();
   },
 
-  remove: function ctrlTab_remove(aPreview) {
+  remove: function(aPreview) {
     if (aPreview._tab)
       gBrowser.removeTab(aPreview._tab);
   },
 
-  attachTab: function ctrlTab_attachTab(aTab, aPos) {
+  attachTab: function(aTab, aPos) {
     if (aTab.closing)
       return;
 
     if (aPos == 0)
       this._recentlyUsedTabs.unshift(aTab);
     else if (aPos)
       this._recentlyUsedTabs.splice(aPos, 0, aTab);
     else
       this._recentlyUsedTabs.push(aTab);
   },
 
-  detachTab: function ctrlTab_detachTab(aTab) {
+  detachTab: function(aTab) {
     var i = this._recentlyUsedTabs.indexOf(aTab);
     if (i >= 0)
       this._recentlyUsedTabs.splice(i, 1);
   },
 
-  open: function ctrlTab_open() {
+  open: function() {
     if (this.isOpen)
       return;
 
     document.addEventListener("keyup", this, true);
 
     this.updatePreviews();
     this._selectedIndex = 1;
 
     // Add a slight delay before showing the UI, so that a quick
     // "ctrl-tab" keypress just flips back to the MRU tab.
     this._timer = setTimeout(function (self) {
       self._timer = null;
       self._openPanel();
     }, 200, this);
   },
 
-  _openPanel: function ctrlTab_openPanel() {
+  _openPanel: function() {
     tabPreviewPanelHelper.opening(this);
 
     this.panel.width = Math.min(screen.availWidth * .99,
                                 this.canvasWidth * 1.25 * this.tabPreviewCount);
     var estimateHeight = this.canvasHeight * 1.25 + 75;
     this.panel.openPopupAtScreen(screen.availLeft + (screen.availWidth - this.panel.width) / 2,
                                  screen.availTop + (screen.availHeight - estimateHeight) / 2,
                                  false);
   },
 
-  close: function ctrlTab_close(aTabToSelect) {
+  close: function(aTabToSelect) {
     if (!this.isOpen)
       return;
 
     if (this._timer) {
       clearTimeout(this._timer);
       this._timer = null;
       this.suspendGUI();
       if (aTabToSelect)
         gBrowser.selectedTab = aTabToSelect;
       return;
     }
 
     this.tabToSelect = aTabToSelect;
     this.panel.hidePopup();
   },
 
-  setupGUI: function ctrlTab_setupGUI() {
+  setupGUI: function() {
     this.selected.focus();
     this._selectedIndex = -1;
 
     // Track mouse movement after a brief delay so that the item that happens
     // to be under the mouse pointer initially won't be selected unintentionally.
     this._trackMouseOver = false;
     setTimeout(function (self) {
       if (self.isOpen)
         self._trackMouseOver = true;
     }, 0, this);
   },
 
-  suspendGUI: function ctrlTab_suspendGUI() {
+  suspendGUI: function() {
     document.removeEventListener("keyup", this, true);
 
     for (let preview of this.previews) {
       this.updatePreview(preview, null);
     }
   },
 
-  onKeyPress: function ctrlTab_onKeyPress(event) {
+  onKeyPress: function(event) {
     var isOpen = this.isOpen;
 
     if (isOpen) {
       event.preventDefault();
       event.stopPropagation();
     }
 
     switch (event.keyCode) {
@@ -446,17 +446,17 @@ var ctrlTab = {
             case this.keys.selectAll:
               this.showAllTabs();
               break;
           }
         }
     }
   },
 
-  removeClosingTabFromUI: function ctrlTab_removeClosingTabFromUI(aTab) {
+  removeClosingTabFromUI: function(aTab) {
     if (this.tabCount == 2) {
       this.close();
       return;
     }
 
     this.updatePreviews();
 
     if (this.selected.hidden)
@@ -467,17 +467,17 @@ var ctrlTab = {
     // If the current tab is removed, another tab can steal our focus.
     if (aTab.selected && this.panel.state == "open") {
       setTimeout(function (selected) {
         selected.focus();
       }, 0, this.selected);
     }
   },
 
-  handleEvent: function ctrlTab_handleEvent(event) {
+  handleEvent: function(event) {
     switch (event.type) {
       case "SSWindowStateReady":
         this._initRecentlyUsedTabs();
         break;
       case "TabAttrModified":
         // tab attribute modified (e.g. label, crop, busy, image, selected)
         for (let i = this.previews.length - 1; i >= 0; i--) {
           if (this.previews[i]._tab && this.previews[i]._tab == event.target) {
@@ -527,17 +527,17 @@ var ctrlTab = {
   },
 
   _initRecentlyUsedTabs: function () {
     this._recentlyUsedTabs =
       Array.filter(gBrowser.tabs, tab => !tab.closing)
            .sort((tab1, tab2) => tab2.lastAccessed - tab1.lastAccessed);
   },
 
-  _init: function ctrlTab__init(enable) {
+  _init: function(enable) {
     var toggleEventListener = enable ? "addEventListener" : "removeEventListener";
 
     window[toggleEventListener]("SSWindowStateReady", this, false);
 
     var tabContainer = gBrowser.tabContainer;
     tabContainer[toggleEventListener]("TabOpen", this, false);
     tabContainer[toggleEventListener]("TabAttrModified", this, false);
     tabContainer[toggleEventListener]("TabSelect", this, false);
@@ -569,17 +569,17 @@ var ctrlTab = {
 
 /**
  * All Tabs menu
  */
 var allTabs = {
   get toolbarButton() document.getElementById("alltabs-button"),
   get canOpen() isElementVisible(this.toolbarButton),
 
-  open: function allTabs_open() {
+  open: function() {
     if (this.canOpen) {
       // Without setTimeout, the menupopup won't stay open when invoking
       // "View > Show All Tabs" and the menu bar auto-hides.
       setTimeout(() => {
         this.toolbarButton.open = true;
       }, 0);
     }
   }
diff --git a/browser/base/content/browser-fullZoom.js b/browser/base/content/browser-fullZoom.js
--- a/browser/base/content/browser-fullZoom.js
+++ b/browser/base/content/browser-fullZoom.js
@@ -39,17 +39,17 @@ var FullZoom = {
                                          Ci.nsIObserver,
                                          Ci.nsIContentPrefObserver,
                                          Ci.nsISupportsWeakReference,
                                          Ci.nsISupports]),
 
   //**************************************************************************//
   // Initialization & Destruction
 
-  init: function FullZoom_init() {
+  init: function() {
     gBrowser.addEventListener("ZoomChangeUsingMouseWheel", this);
 
     // Register ourselves with the service so we know when our pref changes.
     this._cps2 = Cc["@mozilla.org/content-pref/service;1"].
                  getService(Ci.nsIContentPrefService2);
     this._cps2.addObserverForName(this.name, this);
 
     this._siteSpecificPref =
@@ -68,29 +68,29 @@ var FullZoom = {
       }
     }
 
     // This should be nulled after initialization.
     this._initialLocations.clear();
     this._initialLocations = null;
   },
 
-  destroy: function FullZoom_destroy() {
+  destroy: function() {
     gPrefService.removeObserver("browser.zoom.", this);
     this._cps2.removeObserverForName(this.name, this);
     gBrowser.removeEventListener("ZoomChangeUsingMouseWheel", this);
   },
 
 
   //**************************************************************************//
   // Event Handlers
 
   // nsIDOMEventListener
 
-  handleEvent: function FullZoom_handleEvent(event) {
+  handleEvent: function(event) {
     switch (event.type) {
       case "ZoomChangeUsingMouseWheel":
         let browser = this._getTargetedBrowser(event);
         this._ignorePendingZoomAccesses(browser);
         this._applyZoomToPref(browser);
         break;
     }
   },
@@ -111,33 +111,33 @@ var FullZoom = {
             break;
         }
         break;
     }
   },
 
   // nsIContentPrefObserver
 
-  onContentPrefSet: function FullZoom_onContentPrefSet(aGroup, aName, aValue) {
+  onContentPrefSet: function(aGroup, aName, aValue) {
     this._onContentPrefChanged(aGroup, aValue);
   },
 
-  onContentPrefRemoved: function FullZoom_onContentPrefRemoved(aGroup, aName) {
+  onContentPrefRemoved: function(aGroup, aName) {
     this._onContentPrefChanged(aGroup, undefined);
   },
 
   /**
    * Appropriately updates the zoom level after a content preference has
    * changed.
    *
    * @param aGroup  The group of the changed preference.
    * @param aValue  The new value of the changed preference.  Pass undefined to
    *                indicate the preference's removal.
    */
-  _onContentPrefChanged: function FullZoom__onContentPrefChanged(aGroup, aValue) {
+  _onContentPrefChanged: function(aGroup, aValue) {
     if (this._isNextContentPrefChangeInternal) {
       // Ignore changes that FullZoom itself makes.  This works because the
       // content pref service calls callbacks before notifying observers, and it
       // does both in the same turn of the event loop.
       delete this._isNextContentPrefChangeInternal;
       return;
     }
 
@@ -178,17 +178,17 @@ var FullZoom = {
    *
    * @param aURI
    *        A URI object representing the new location.
    * @param aIsTabSwitch
    *        Whether this location change has happened because of a tab switch.
    * @param aBrowser
    *        (optional) browser object displaying the document
    */
-  onLocationChange: function FullZoom_onLocationChange(aURI, aIsTabSwitch, aBrowser) {
+  onLocationChange: function(aURI, aIsTabSwitch, aBrowser) {
     let browser = aBrowser || gBrowser.selectedBrowser;
 
     // If we haven't been initialized yet but receive an onLocationChange
     // notification then let's store and replay it upon initialization.
     if (this._initialLocations) {
       this._initialLocations.set(browser, [aURI, aIsTabSwitch]);
       return;
     }
@@ -240,50 +240,50 @@ var FullZoom = {
         this._applyPrefToZoom(value, browser,
                               this._notifyOnLocationChange.bind(this));
       }.bind(this)
     });
   },
 
   // update state of zoom type menu item
 
-  updateMenu: function FullZoom_updateMenu() {
+  updateMenu: function() {
     var menuItem = document.getElementById("toggle_zoom");
 
     menuItem.setAttribute("checked", !ZoomManager.useFullZoom);
   },
 
   //**************************************************************************//
   // Setting & Pref Manipulation
 
   /**
    * Reduces the zoom level of the page in the current browser.
    */
-  reduce: function FullZoom_reduce() {
+  reduce: function() {
     ZoomManager.reduce();
     let browser = gBrowser.selectedBrowser;
     this._ignorePendingZoomAccesses(browser);
     this._applyZoomToPref(browser);
   },
 
   /**
    * Enlarges the zoom level of the page in the current browser.
    */
-  enlarge: function FullZoom_enlarge() {
+  enlarge: function() {
     ZoomManager.enlarge();
     let browser = gBrowser.selectedBrowser;
     this._ignorePendingZoomAccesses(browser);
     this._applyZoomToPref(browser);
   },
 
   /**
    * Sets the zoom level of the page in the current browser to the global zoom
    * level.
    */
-  reset: function FullZoom_reset() {
+  reset: function() {
     let browser = gBrowser.selectedBrowser;
     let token = this._getBrowserToken(browser);
     this._getGlobalValue(browser, function (value) {
       if (token.isCurrent) {
         ZoomManager.setZoomForBrowser(browser, value === undefined ? 1 : value);
         this._ignorePendingZoomAccesses(browser);
         this._executeSoon(function () {
           // _getGlobalValue may be either sync or async, so notify asyncly so
@@ -313,17 +313,17 @@ var FullZoom = {
    * So when we apply new zoom values to the browser, we simply set the zoom.
    * We don't check first to see if the new value is the same as the current
    * one.
    *
    * @param aValue     The zoom level value.
    * @param aBrowser   The zoom is set in this browser.  Required.
    * @param aCallback  If given, it's asynchronously called when complete.
    */
-  _applyPrefToZoom: function FullZoom__applyPrefToZoom(aValue, aBrowser, aCallback) {
+  _applyPrefToZoom: function(aValue, aBrowser, aCallback) {
     if (!this.siteSpecific || gInPrintPreviewMode) {
       this._executeSoon(aCallback);
       return;
     }
 
     // The browser is sometimes half-destroyed because this method is called
     // by content pref service callbacks, which themselves can be called at any
     // time, even after browsers are closed.
@@ -350,17 +350,17 @@ var FullZoom = {
   },
 
   /**
    * Saves the zoom level of the page in the given browser to the content
    * prefs store.
    *
    * @param browser  The zoom of this browser will be saved.  Required.
    */
-  _applyZoomToPref: function FullZoom__applyZoomToPref(browser) {
+  _applyZoomToPref: function(browser) {
     Services.obs.notifyObservers(null, "browser-fullZoom:zoomChange", "");
     if (!this.siteSpecific ||
         gInPrintPreviewMode ||
         browser.isSyntheticDocument)
       return;
 
     this._cps2.set(browser.currentURI.spec, this.name,
                    ZoomManager.getZoomForBrowser(browser),
@@ -371,17 +371,17 @@ var FullZoom = {
     });
   },
 
   /**
    * Removes from the content prefs store the zoom level of the given browser.
    *
    * @param browser  The zoom of this browser will be removed.  Required.
    */
-  _removePref: function FullZoom__removePref(browser) {
+  _removePref: function(browser) {
     Services.obs.notifyObservers(null, "browser-fullZoom:zoomReset", "");
     if (browser.isSyntheticDocument)
       return;
     let ctxt = this._loadContextFromBrowser(browser);
     this._cps2.removeByDomainAndName(browser.currentURI.spec, this.name, ctxt, {
       handleCompletion: function () {
         this._isNextContentPrefChangeInternal = true;
       }.bind(this),
@@ -398,17 +398,17 @@ var FullZoom = {
    * it's safe to access the zoom when done.  If token.isCurrent is false, then
    * after the async operation started, either the browser's zoom was changed or
    * the browser was destroyed, and depending on what the operation is doing, it
    * may no longer be safe to set and get its zoom.
    *
    * @param browser  The token of this browser will be returned.
    * @return  An object with an "isCurrent" getter.
    */
-  _getBrowserToken: function FullZoom__getBrowserToken(browser) {
+  _getBrowserToken: function(browser) {
     let map = this._browserTokenMap;
     if (!map.has(browser))
       map.set(browser, 0);
     return {
       token: map.get(browser),
       get isCurrent() {
         // At this point, the browser may have been destructed and unbound but
         // its outer ID not removed from the map because outer-window-destroyed
@@ -420,17 +420,17 @@ var FullZoom = {
     };
   },
 
   /**
    * Returns the browser that the supplied zoom event is associated with.
    * @param event  The ZoomChangeUsingMouseWheel event.
    * @return  The associated browser element, if one exists, otherwise null.
    */
-  _getTargetedBrowser: function FullZoom__getTargetedBrowser(event) {
+  _getTargetedBrowser: function(event) {
     let target = event.originalTarget;
 
     // With remote content browsers, the event's target is the browser
     // we're looking for.
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
     if (target instanceof window.XULElement &&
         target.localName == "browser" &&
         target.namespaceURI == XUL_NS)
@@ -446,22 +446,22 @@ var FullZoom = {
 
   /**
    * Increments the zoom change token for the given browser so that pending
    * async operations know that it may be unsafe to access they zoom when they
    * finish.
    *
    * @param browser  Pending accesses in this browser will be ignored.
    */
-  _ignorePendingZoomAccesses: function FullZoom__ignorePendingZoomAccesses(browser) {
+  _ignorePendingZoomAccesses: function(browser) {
     let map = this._browserTokenMap;
     map.set(browser, (map.get(browser) || 0) + 1);
   },
 
-  _ensureValid: function FullZoom__ensureValid(aValue) {
+  _ensureValid: function(aValue) {
     // Note that undefined is a valid value for aValue that indicates a known-
     // not-to-exist value.
     if (isNaN(aValue))
       return 1;
 
     if (aValue < ZoomManager.MIN)
       return ZoomManager.MIN;
 
@@ -480,17 +480,17 @@ var FullZoom = {
    * level.  It's not always possible to avoid them, though.  As a convenience,
    * then, this method takes a callback and returns nothing.
    *
    * @param browser   The browser pertaining to the zoom.
    * @param callback  Synchronously or asynchronously called when done.  It's
    *                  bound to this object (FullZoom) and called as:
    *                    callback(prefValue)
    */
-  _getGlobalValue: function FullZoom__getGlobalValue(browser, callback) {
+  _getGlobalValue: function(browser, callback) {
     // * !("_globalValue" in this) => global value not yet cached.
     // * this._globalValue === undefined => global value known not to exist.
     // * Otherwise, this._globalValue is a number, the global value.
     if ("_globalValue" in this) {
       callback.call(this, this._globalValue, true);
       return;
     }
     let value = undefined;
@@ -504,30 +504,30 @@ var FullZoom = {
   },
 
   /**
    * Gets the load context from the given Browser.
    *
    * @param Browser  The Browser whose load context will be returned.
    * @return        The nsILoadContext of the given Browser.
    */
-  _loadContextFromBrowser: function FullZoom__loadContextFromBrowser(browser) {
+  _loadContextFromBrowser: function(browser) {
     return browser.loadContext;
   },
 
   /**
    * Asynchronously broadcasts "browser-fullZoom:location-change" so that
    * listeners can be notified when the zoom levels on those pages change.
    * The notification is always asynchronous so that observers are guaranteed a
    * consistent behavior.
    */
-  _notifyOnLocationChange: function FullZoom__notifyOnLocationChange() {
+  _notifyOnLocationChange: function() {
     this._executeSoon(function () {
       Services.obs.notifyObservers(null, "browser-fullZoom:location-change", "");
     });
   },
 
-  _executeSoon: function FullZoom__executeSoon(callback) {
+  _executeSoon: function(callback) {
     if (!callback)
       return;
     Services.tm.mainThread.dispatch(callback, Ci.nsIThread.DISPATCH_NORMAL);
   },
 };
diff --git a/browser/base/content/browser-gestureSupport.js b/browser/base/content/browser-gestureSupport.js
--- a/browser/base/content/browser-gestureSupport.js
+++ b/browser/base/content/browser-gestureSupport.js
@@ -19,17 +19,17 @@ let gGestureSupport = {
   _rotateMomentumThreshold: .75,
 
   /**
    * Add or remove mouse gesture event listeners
    *
    * @param aAddListener
    *        True to add/init listeners and false to remove/uninit
    */
-  init: function GS_init(aAddListener) {
+  init: function(aAddListener) {
     const gestureEvents = ["SwipeGestureStart",
       "SwipeGestureUpdate", "SwipeGestureEnd", "SwipeGesture",
       "MagnifyGestureStart", "MagnifyGestureUpdate", "MagnifyGesture",
       "RotateGestureStart", "RotateGestureUpdate", "RotateGesture",
       "TapGesture", "PressTapGesture"];
 
     let addRemove = aAddListener ? window.addEventListener :
       window.removeEventListener;
@@ -42,17 +42,17 @@ let gGestureSupport = {
   /**
    * Dispatch events based on the type of mouse gesture event. For now, make
    * sure to stop propagation of every gesture event so that web content cannot
    * receive gesture events.
    *
    * @param aEvent
    *        The gesture event to handle
    */
-  handleEvent: function GS_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (!Services.prefs.getBoolPref(
            "dom.debug.propagate_gesture_events_through_content")) {
       aEvent.stopPropagation();
     }
 
     // Create a preference object with some defaults
     let def = function(aThreshold, aLatched)
       ({ threshold: aThreshold, latched: !!aLatched });
@@ -115,17 +115,17 @@ let gGestureSupport = {
    *        Name of the gesture to handle
    * @param aPref
    *        Preference object with the names of preferences and defaults
    * @param aInc
    *        Command to trigger for increasing motion (without gesture name)
    * @param aDec
    *        Command to trigger for decreasing motion (without gesture name)
    */
-  _setupGesture: function GS__setupGesture(aEvent, aGesture, aPref, aInc, aDec) {
+  _setupGesture: function(aEvent, aGesture, aPref, aInc, aDec) {
     // Try to load user-set values from preferences
     for (let [pref, def] in Iterator(aPref))
       aPref[pref] = this._getPref(aGesture + "." + pref, def);
 
     // Keep track of the total deltas and latching behavior
     let offset = 0;
     let latchDir = aEvent.delta > 0 ? 1 : -1;
     let isLatched = false;
@@ -160,33 +160,33 @@ let gGestureSupport = {
   /**
    * Checks whether a swipe gesture event can navigate the browser history or
    * not.
    *
    * @param aEvent
    *        The swipe gesture event.
    * @return true if the swipe event may navigate the history, false othwerwise.
    */
-  _swipeNavigatesHistory: function GS__swipeNavigatesHistory(aEvent) {
+  _swipeNavigatesHistory: function(aEvent) {
     return this._getCommand(aEvent, ["swipe", "left"])
               == "Browser:BackOrBackDuplicate" &&
            this._getCommand(aEvent, ["swipe", "right"])
               == "Browser:ForwardOrForwardDuplicate";
   },
 
   /**
    * Sets up swipe gestures. This includes setting up swipe animations for the
    * gesture, if enabled.
    *
    * @param aEvent
    *        The swipe gesture start event.
    * @return true if swipe gestures could successfully be set up, false
    *         othwerwise.
    */
-  _setupSwipeGesture: function GS__setupSwipeGesture(aEvent) {
+  _setupSwipeGesture: function(aEvent) {
     if (!this._swipeNavigatesHistory(aEvent)) {
       return false;
     }
 
     let isVerticalSwipe = false;
     if (aEvent.direction == aEvent.DIRECTION_UP) {
       if (gMultiProcessBrowser || content.pageYOffset > 0) {
         return false;
@@ -236,17 +236,17 @@ let gGestureSupport = {
   /**
    * Generator producing the powerset of the input array where the first result
    * is the complete set and the last result (before StopIteration) is empty.
    *
    * @param aArray
    *        Source array containing any number of elements
    * @yield Array that is a subset of the input array from full set to empty
    */
-  _power: function GS__power(aArray) {
+  _power: function(aArray) {
     // Create a bitmask based on the length of the array
     let num = 1 << aArray.length;
     while (--num >= 0) {
       // Only select array elements where the current bit is set
       yield aArray.reduce(function (aPrev, aCurr, aIndex) {
         if (num & 1 << aIndex)
           aPrev.push(aCurr);
         return aPrev;
@@ -260,31 +260,31 @@ let gGestureSupport = {
    *
    * @param aEvent
    *        The original gesture event to convert into a fake click event
    * @param aGesture
    *        Array of gesture name parts (to be joined by periods)
    * @return Name of the executed command. Returns null if no command is
    *         found.
    */
-  _doAction: function GS__doAction(aEvent, aGesture) {
+  _doAction: function(aEvent, aGesture) {
     let command = this._getCommand(aEvent, aGesture);
     return command && this._doCommand(aEvent, command);
   },
 
   /**
    * Determine what action to do for the gesture based on which keys are
    * pressed and which commands are set
    *
    * @param aEvent
    *        The original gesture event to convert into a fake click event
    * @param aGesture
    *        Array of gesture name parts (to be joined by periods)
    */
-  _getCommand: function GS__getCommand(aEvent, aGesture) {
+  _getCommand: function(aEvent, aGesture) {
     // Create an array of pressed keys in a fixed order so that a command for
     // "meta" is preferred over "ctrl" when both buttons are pressed (and a
     // command for both don't exist)
     let keyCombos = [];
     for (let key of ["shift", "alt", "ctrl", "meta"]) {
       if (aEvent[key + "Key"])
         keyCombos.push(key);
     }
@@ -308,17 +308,17 @@ let gGestureSupport = {
   /**
    * Execute the specified command.
    *
    * @param aEvent
    *        The original gesture event to convert into a fake click event
    * @param aCommand
    *        Name of the command found for the event's keys and gesture.
    */
-  _doCommand: function GS__doCommand(aEvent, aCommand) {
+  _doCommand: function(aEvent, aCommand) {
     let node = document.getElementById(aCommand);
     if (node) {
       if (node.getAttribute("disabled") != "true") {
         let cmdEvent = document.createEvent("xulcommandevent");
         cmdEvent.initCommandEvent("command", true, true, window, 0,
                                   aEvent.ctrlKey, aEvent.altKey,
                                   aEvent.shiftKey, aEvent.metaKey, aEvent);
         node.dispatchEvent(cmdEvent);
@@ -348,17 +348,17 @@ let gGestureSupport = {
   _doEnd: function(aEvent) {},
 
   /**
    * Convert the swipe gesture into a browser action based on the direction.
    *
    * @param aEvent
    *        The swipe event to handle
    */
-  onSwipe: function GS_onSwipe(aEvent) {
+  onSwipe: function(aEvent) {
     // Figure out which one (and only one) direction was triggered
     for (let dir of ["UP", "RIGHT", "DOWN", "LEFT"]) {
       if (aEvent.direction == aEvent["DIRECTION_" + dir]) {
         this._coordinateSwipeEventWithAnimation(aEvent, dir);
         break;
       }
     }
   },
@@ -366,17 +366,17 @@ let gGestureSupport = {
   /**
    * Process a swipe event based on the given direction.
    *
    * @param aEvent
    *        The swipe event to handle
    * @param aDir
    *        The direction for the swipe event
    */
-  processSwipeEvent: function GS_processSwipeEvent(aEvent, aDir) {
+  processSwipeEvent: function(aEvent, aDir) {
     this._doAction(aEvent, ["swipe", aDir.toLowerCase()]);
   },
 
   /**
    * Coordinates the swipe event with the swipe animation, if any.
    * If an animation is currently running, the swipe event will be
    * processed once the animation stops. This will guarantee a fluid
    * motion of the animation.
@@ -400,17 +400,17 @@ let gGestureSupport = {
   /**
    * Get a gesture preference or use a default if it doesn't exist
    *
    * @param aPref
    *        Name of the preference to load under the gesture branch
    * @param aDef
    *        Default value if the preference doesn't exist
    */
-  _getPref: function GS__getPref(aPref, aDef) {
+  _getPref: function(aPref, aDef) {
     // Preferences branch under which all gestures preferences are stored
     const branch = "browser.gesture.";
 
     try {
       // Determine what type of data to load based on default value's type
       let type = typeof aDef;
       let getFunc = "get" + (type == "boolean" ? "Bool" :
                              type == "number" ? "Int" : "Char") + "Pref";
@@ -560,17 +560,17 @@ let gHistorySwipeAnimation = {
 
   active: false,
   isLTR: false,
 
   /**
    * Initializes the support for history swipe animations, if it is supported
    * by the platform/configuration.
    */
-  init: function HSA_init() {
+  init: function() {
     if (!this._isSupported())
       return;
 
     this.active = false;
     this.isLTR = document.documentElement.matches(":-moz-locale-dir(ltr)");
     this._trackedSnapshots = [];
     this._startingIndex = -1;
     this._historyIndex = -1;
@@ -590,17 +590,17 @@ let gHistorySwipeAnimation = {
       gBrowser.addEventListener("DOMModalDialogClosed", this, false);
       gBrowser.tabContainer.addEventListener("TabClose", this, false);
     }
   },
 
   /**
    * Uninitializes the support for history swipe animations.
    */
-  uninit: function HSA_uninit() {
+  uninit: function() {
     gBrowser.removeEventListener("pagehide", this, false);
     gBrowser.removeEventListener("pageshow", this, false);
     gBrowser.removeEventListener("popstate", this, false);
     gBrowser.removeEventListener("DOMModalDialogClosed", this, false);
     gBrowser.tabContainer.removeEventListener("TabClose", this, false);
 
     this.active = false;
     this.isLTR = false;
@@ -608,17 +608,17 @@ let gHistorySwipeAnimation = {
 
   /**
    * Starts the swipe animation and handles fast swiping (i.e. a swipe animation
    * is already in progress when a new one is initiated).
    *
    * @param aIsVerticalSwipe
    *        Whether we're dealing with a vertical swipe or not.
    */
-  startAnimation: function HSA_startAnimation(aIsVerticalSwipe) {
+  startAnimation: function(aIsVerticalSwipe) {
     this._direction = aIsVerticalSwipe ? "vertical" : "horizontal";
 
     if (this.isAnimationRunning()) {
       // If this is a horizontal scroll, or if this is a vertical scroll that
       // was started while a horizontal scroll was still running, handle it as
       // as a fast swipe. In the case of the latter scenario, this allows us to
       // start the vertical animation without first loading the final page, or
       // taking another snapshot. If vertical scrolls are initiated repeatedly
@@ -645,29 +645,29 @@ let gHistorySwipeAnimation = {
       }
     }
     this.updateAnimation(0);
   },
 
   /**
    * Stops the swipe animation.
    */
-  stopAnimation: function HSA_stopAnimation() {
+  stopAnimation: function() {
     gHistorySwipeAnimation._removeBoxes();
     this._historyIndex = gBrowser.webNavigation.sessionHistory.index;
   },
 
   /**
    * Updates the animation between two pages in history.
    *
    * @param aVal
    *        A floating point value that represents the progress of the
    *        swipe gesture.
    */
-  updateAnimation: function HSA_updateAnimation(aVal) {
+  updateAnimation: function(aVal) {
     if (!this.isAnimationRunning()) {
       return;
     }
 
     // We use the following value to decrease the bounce effect when scrolling
     // to the top or bottom of the page, or when swiping back/forward past the
     // browsing history. This value was determined experimentally.
     let dampValue = 4;
@@ -712,17 +712,17 @@ let gHistorySwipeAnimation = {
   },
 
   /**
    * Event handler for events relevant to the history swipe animation.
    *
    * @param aEvent
    *        An event to process.
    */
-  handleEvent: function HSA_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     let browser = gBrowser.selectedBrowser;
     switch (aEvent.type) {
       case "TabClose":
         let browserForTab = gBrowser.getBrowserForTab(aEvent.target);
         this._removeTrackedSnapshot(-1, browserForTab);
         break;
       case "DOMModalDialogClosed":
         this.stopAnimation();
@@ -751,124 +751,124 @@ let gHistorySwipeAnimation = {
     }
   },
 
   /**
    * Checks whether the history swipe animation is currently running or not.
    *
    * @return true if the animation is currently running, false otherwise.
    */
-  isAnimationRunning: function HSA_isAnimationRunning() {
+  isAnimationRunning: function() {
     return !!this._container;
   },
 
   /**
    * Process a swipe event based on the given direction.
    *
    * @param aEvent
    *        The swipe event to handle
    * @param aDir
    *        The direction for the swipe event
    */
-  processSwipeEvent: function HSA_processSwipeEvent(aEvent, aDir) {
+  processSwipeEvent: function(aEvent, aDir) {
     if (aDir == "RIGHT")
       this._historyIndex += this.isLTR ? 1 : -1;
     else if (aDir == "LEFT")
       this._historyIndex += this.isLTR ? -1 : 1;
     else
       return;
     this._lastSwipeDir = aDir;
   },
 
   /**
    * Checks if there is a page in the browser history to go back to.
    *
    * @return true if there is a previous page in history, false otherwise.
    */
-  canGoBack: function HSA_canGoBack() {
+  canGoBack: function() {
     if (this.isAnimationRunning())
       return this._doesIndexExistInHistory(this._historyIndex - 1);
     return gBrowser.webNavigation.canGoBack;
   },
 
   /**
    * Checks if there is a page in the browser history to go forward to.
    *
    * @return true if there is a next page in history, false otherwise.
    */
-  canGoForward: function HSA_canGoForward() {
+  canGoForward: function() {
     if (this.isAnimationRunning())
       return this._doesIndexExistInHistory(this._historyIndex + 1);
     return gBrowser.webNavigation.canGoForward;
   },
 
   /**
    * Used to notify the history swipe animation that the OS sent a swipe end
    * event and that we should navigate to the page that the user swiped to, if
    * any. This will also result in the animation overlay to be torn down.
    */
-  swipeEndEventReceived: function HSA_swipeEndEventReceived() {
+  swipeEndEventReceived: function() {
     if (this._lastSwipeDir != "" && this._historyIndex != this._startingIndex)
       this._navigateToHistoryIndex();
     else
       this.stopAnimation();
   },
 
   /**
    * Checks whether a particular index exists in the browser history or not.
    *
    * @param aIndex
    *        The index to check for availability for in the history.
    * @return true if the index exists in the browser history, false otherwise.
    */
-  _doesIndexExistInHistory: function HSA__doesIndexExistInHistory(aIndex) {
+  _doesIndexExistInHistory: function(aIndex) {
     try {
       gBrowser.webNavigation.sessionHistory.getEntryAtIndex(aIndex, false);
     }
     catch(ex) {
       return false;
     }
     return true;
   },
 
   /**
    * Navigates to the index in history that is currently being tracked by
    * |this|.
    */
-  _navigateToHistoryIndex: function HSA__navigateToHistoryIndex() {
+  _navigateToHistoryIndex: function() {
     if (this._doesIndexExistInHistory(this._historyIndex))
       gBrowser.webNavigation.gotoIndex(this._historyIndex);
     else
       this.stopAnimation();
   },
 
   /**
    * Checks to see if history swipe animations are supported by this
    * platform/configuration.
    *
    * return true if supported, false otherwise.
    */
-  _isSupported: function HSA__isSupported() {
+  _isSupported: function() {
     return window.matchMedia("(-moz-swipe-animation-enabled)").matches;
   },
 
   /**
    * Handle fast swiping (i.e. a swipe animation is already in
    * progress when a new one is initiated). This will swap out the snapshots
    * used in the previous animation with the appropriate new ones.
    */
-  _handleFastSwiping: function HSA__handleFastSwiping() {
+  _handleFastSwiping: function() {
     this._installCurrentPageSnapshot(null);
     this._installPrevAndNextSnapshots();
   },
 
   /**
    * Adds the boxes that contain the snapshots used during the swipe animation.
    */
-  _addBoxes: function HSA__addBoxes() {
+  _addBoxes: function() {
     let browserStack =
       document.getAnonymousElementByAttribute(gBrowser.getNotificationBox(),
                                               "class", "browserStack");
     this._container = this._createElement("historySwipeAnimationContainer",
                                           "stack");
     browserStack.appendChild(this._container);
 
     this._prevBox = this._createElement("historySwipeAnimationPreviousPage",
@@ -886,17 +886,17 @@ let gHistorySwipeAnimation = {
     // Cache width and height.
     this._boxWidth = this._curBox.getBoundingClientRect().width;
     this._boxHeight = this._curBox.getBoundingClientRect().height;
   },
 
   /**
    * Removes the boxes.
    */
-  _removeBoxes: function HSA__removeBoxes() {
+  _removeBoxes: function() {
     this._curBox = null;
     this._prevBox = null;
     this._nextBox = null;
     if (this._container)
       this._container.parentNode.removeChild(this._container);
     this._container = null;
     this._boxWidth = -1;
     this._boxHeight = -1;
@@ -906,60 +906,60 @@ let gHistorySwipeAnimation = {
    * Creates an element with a given identifier and tag name.
    *
    * @param aID
    *        An identifier to create the element with.
    * @param aTagName
    *        The name of the tag to create the element for.
    * @return the newly created element.
    */
-  _createElement: function HSA__createElement(aID, aTagName) {
+  _createElement: function(aID, aTagName) {
     let XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
     let element = document.createElementNS(XULNS, aTagName);
     element.id = aID;
     return element;
   },
 
   /**
    * Moves a given box to a given X coordinate position.
    *
    * @param aBox
    *        The box element to position.
    * @param aPosition
    *        The position (in X coordinates) to move the box element to.
    */
-  _positionBox: function HSA__positionBox(aBox, aPosition) {
+  _positionBox: function(aBox, aPosition) {
     let transform = "";
 
     if (this._direction == "vertical")
       transform = "translateY(" + this._boxHeight * aPosition + "px)";
     else
       transform = "translateX(" + this._boxWidth * aPosition + "px)";
 
     aBox.style.transform = transform;
   },
 
   /**
    * Verifies that we're ready to take snapshots based on the global pref and
    * the current index in history.
    *
    * @return true if we're ready to take snapshots, false otherwise.
    */
-  _readyToTakeSnapshots: function HSA__readyToTakeSnapshots() {
+  _readyToTakeSnapshots: function() {
     if ((this._maxSnapshots < 1) ||
         (gBrowser.webNavigation.sessionHistory.index < 0)) {
       return false;
     }
     return true;
   },
 
   /**
    * Takes a snapshot of the page the browser is currently on.
    */
-  _takeSnapshot: function HSA__takeSnapshot() {
+  _takeSnapshot: function() {
     if (!this._readyToTakeSnapshots()) {
       return;
     }
 
     let canvas = null;
 
     TelemetryStopwatch.start("FX_GESTURE_TAKE_SNAPSHOT_OF_PAGE");
     try {
@@ -991,17 +991,17 @@ let gHistorySwipeAnimation = {
       TelemetryStopwatch.finish("FX_GESTURE_INSTALL_SNAPSHOT_OF_PAGE");
     }
   },
 
   /**
    * Retrieves the maximum number of snapshots that should be kept in memory.
    * This limit is a global limit and is valid across all open tabs.
    */
-  _getMaxSnapshots: function HSA__getMaxSnapshots() {
+  _getMaxSnapshots: function() {
     return gPrefService.getIntPref("browser.snapshots.limit");
   },
 
   /**
    * Adds a snapshot to the list and initiates the compression of said snapshot.
    * Once the compression is completed, it will replace the uncompressed
    * snapshot in the list.
    *
@@ -1066,17 +1066,17 @@ let gHistorySwipeAnimation = {
    * all snapshots for a particular browser will be removed.
    *
    * @param aIndex
    *        The index in history of the new snapshot, or negative value if all
    *        snapshots for a browser should be removed.
    * @param aBrowser
    *        The browser the new snapshot was taken in.
    */
-  _removeTrackedSnapshot: function HSA__removeTrackedSnapshot(aIndex, aBrowser) {
+  _removeTrackedSnapshot: function(aIndex, aBrowser) {
     let arr = this._trackedSnapshots;
     let requiresExactIndexMatch = aIndex >= 0;
     for (let i = 0; i < arr.length; i++) {
       if ((arr[i].browser == aBrowser) &&
           (aIndex < 0 || aIndex == arr[i].index)) {
         delete aBrowser.snapshots[arr[i].index];
         arr.splice(i, 1);
         if (requiresExactIndexMatch)
@@ -1116,17 +1116,17 @@ let gHistorySwipeAnimation = {
    * (especially during fast swiping) aBlob may still be a canvas, not a
    * compressed blob. In this case, we simply return the canvas.
    *
    * @param aBlob
    *        The compressed blob to convert, or a canvas if a blob compression
    *        couldn't complete before this method was called.
    * @return A new Image object representing the converted blob.
    */
-  _convertToImg: function HSA__convertToImg(aBlob) {
+  _convertToImg: function(aBlob) {
     if (!aBlob)
       return null;
 
     // Return aBlob if it's still a canvas and not a compressed blob yet.
     if (aBlob instanceof HTMLCanvasElement)
       return aBlob;
 
     let img = new Image();
@@ -1148,17 +1148,17 @@ let gHistorySwipeAnimation = {
    * as background) based on a given scale factor.
    * @param aSnapshot
    *        The snapshot that is used as background of aBox.
    * @param aScale
    *        The scale factor to use.
    * @param aBox
    *        The box element that uses aSnapshot as background.
    */
-  _scaleSnapshot: function HSA__scaleSnapshot(aSnapshot, aScale, aBox) {
+  _scaleSnapshot: function(aSnapshot, aScale, aBox) {
     if (aSnapshot && aScale != 1 && aBox) {
       if (aSnapshot instanceof HTMLCanvasElement) {
         aBox.style.backgroundSize =
           aSnapshot.width / aScale + "px " + aSnapshot.height / aScale + "px";
       } else {
         // snapshot is instanceof HTMLImageElement
         aSnapshot.addEventListener("load", function() {
           aBox.style.backgroundSize =
diff --git a/browser/base/content/browser-places.js b/browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js
+++ b/browser/base/content/browser-places.js
@@ -28,40 +28,40 @@ var StarUI = {
 
   // Array of command elements to disable when the panel is opened.
   get _blockedCommands() {
     delete this._blockedCommands;
     return this._blockedCommands =
       ["cmd_close", "cmd_closeWindow"].map(function (id) this._element(id), this);
   },
 
-  _blockCommands: function SU__blockCommands() {
+  _blockCommands: function() {
     this._blockedCommands.forEach(function (elt) {
       // make sure not to permanently disable this item (see bug 409155)
       if (elt.hasAttribute("wasDisabled"))
         return;
       if (elt.getAttribute("disabled") == "true") {
         elt.setAttribute("wasDisabled", "true");
       } else {
         elt.setAttribute("wasDisabled", "false");
         elt.setAttribute("disabled", "true");
       }
     });
   },
 
-  _restoreCommandsState: function SU__restoreCommandsState() {
+  _restoreCommandsState: function() {
     this._blockedCommands.forEach(function (elt) {
       if (elt.getAttribute("wasDisabled") != "true")
         elt.removeAttribute("disabled");
       elt.removeAttribute("wasDisabled");
     });
   },
 
   // nsIDOMEventListener
-  handleEvent: function SU_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "popuphidden":
         if (aEvent.originalTarget == this.panel) {
           if (!this._element("editBookmarkPanelContent").hidden)
             this.quitEditMode();
 
           if (this._anchorToolbarButton) {
             this._anchorToolbarButton.removeAttribute("open");
@@ -225,34 +225,34 @@ var StarUI = {
       else {
         // Note this isn't actually used anymore, we should remove this
         // once we decide not to bring back the page bookmarked notification
         this.panel.focus();
       }
     }
   },
 
-  quitEditMode: function SU_quitEditMode() {
+  quitEditMode: function() {
     this._element("editBookmarkPanelContent").hidden = true;
     this._element("editBookmarkPanelBottomButtons").hidden = true;
     gEditItemOverlay.uninitPanel(true);
   },
 
-  cancelButtonOnCommand: function SU_cancelButtonOnCommand() {
+  cancelButtonOnCommand: function() {
     this._actionOnHide = "cancel";
     this.panel.hidePopup(true);
   },
 
-  removeBookmarkButtonCommand: function SU_removeBookmarkButtonCommand() {
+  removeBookmarkButtonCommand: function() {
     this._uriForRemoval = PlacesUtils.bookmarks.getBookmarkURI(this._itemId);
     this._actionOnHide = "remove";
     this.panel.hidePopup();
   },
 
-  beginBatch: function SU_beginBatch() {
+  beginBatch: function() {
     if (!this._batching) {
       PlacesUtils.transactionManager.beginBatch(null);
       this._batching = true;
     }
   }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -265,17 +265,17 @@ var PlacesCommandHook = {
    * @param aBrowser
    *        a <browser> element.
    * @param [optional] aParent
    *        The folder in which to create a new bookmark if the page loaded in
    *        aBrowser isn't bookmarked yet, defaults to the unfiled root.
    * @param [optional] aShowEditUI
    *        whether or not to show the edit-bookmark UI for the bookmark item
    */  
-  bookmarkPage: function PCH_bookmarkPage(aBrowser, aParent, aShowEditUI) {
+  bookmarkPage: function(aBrowser, aParent, aShowEditUI) {
     var uri = aBrowser.currentURI;
     var itemId = PlacesUtils.getMostRecentBookmarkForURI(uri);
     if (itemId == -1) {
       // Copied over from addBookmarkForBrowser:
       // Bug 52536: We obtain the URL and title from the nsIWebNavigation
       // associated with a <browser/> rather than from a DOMWindow.
       // This is because when a full page plugin is loaded, there is
       // no DOMWindow (?) but information about the loaded document
@@ -341,31 +341,31 @@ var PlacesCommandHook = {
     } else {
       StarUI.showEditBookmarkPopup(itemId, aBrowser, "overlap");
     }
   },
 
   /**
    * Adds a bookmark to the page loaded in the current tab. 
    */
-  bookmarkCurrentPage: function PCH_bookmarkCurrentPage(aShowEditUI, aParent) {
+  bookmarkCurrentPage: function(aShowEditUI, aParent) {
     this.bookmarkPage(gBrowser.selectedBrowser, aParent, aShowEditUI);
   },
 
   /**
    * Adds a bookmark to the page targeted by a link.
    * @param aParent
    *        The folder in which to create a new bookmark if aURL isn't
    *        bookmarked.
    * @param aURL (string)
    *        the address of the link target
    * @param aTitle
    *        The link text
    */
-  bookmarkLink: function PCH_bookmarkLink(aParent, aURL, aTitle) {
+  bookmarkLink: function(aParent, aURL, aTitle) {
     var linkURI = makeURI(aURL);
     var itemId = PlacesUtils.getMostRecentBookmarkForURI(linkURI);
     if (itemId == -1) {
       PlacesUIUtils.showBookmarkDialog({ action: "add"
                                        , type: "bookmark"
                                        , uri: linkURI
                                        , title: aTitle
                                        , hiddenRows: [ "description"
@@ -399,17 +399,17 @@ var PlacesCommandHook = {
     });
     return URIs;
   },
 
   /**
    * Adds a folder with bookmarks to all of the currently open tabs in this 
    * window.
    */
-  bookmarkCurrentPages: function PCH_bookmarkCurrentPages() {
+  bookmarkCurrentPages: function() {
     let pages = this.uniqueCurrentPages;
     if (pages.length > 1) {
     PlacesUIUtils.showBookmarkDialog({ action: "add"
                                      , type: "folder"
                                      , URIList: pages
                                      , hiddenRows: [ "description" ]
                                      }, window);
     }
@@ -434,17 +434,17 @@ var PlacesCommandHook = {
    * Adds a Live Bookmark to a feed associated with the current page. 
    * @param     url
    *            The nsIURI of the page the feed was attached to
    * @title     title
    *            The title of the feed. Optional.
    * @subtitle  subtitle
    *            A short description of the feed. Optional.
    */
-  addLiveBookmark: function PCH_addLiveBookmark(url, feedTitle, feedSubtitle) {
+  addLiveBookmark: function(url, feedTitle, feedSubtitle) {
     var feedURI = makeURI(url);
     
     var doc = gBrowser.contentDocument;
     var title = (arguments.length > 1) ? feedTitle : doc.title;
  
     var description;
     if (arguments.length > 2)
       description = feedSubtitle;
@@ -467,17 +467,17 @@ var PlacesCommandHook = {
 
   /**
    * Opens the Places Organizer. 
    * @param   aLeftPaneRoot
    *          The query to select in the organizer window - options
    *          are: History, AllBookmarks, BookmarksMenu, BookmarksToolbar,
    *          UnfiledBookmarks, Tags and Downloads.
    */
-  showPlacesOrganizer: function PCH_showPlacesOrganizer(aLeftPaneRoot) {
+  showPlacesOrganizer: function(aLeftPaneRoot) {
     var organizer = Services.wm.getMostRecentWindow("Places:Organizer");
     // Due to bug 528706, getMostRecentWindow can return closed windows.
     if (!organizer || organizer.closed) {
       // No currently open places window, so open one with the specified mode.
       openDialog("chrome://browser/content/places/places.xul", 
                  "", "chrome,toolbar=yes,dialog=no,resizable", aLeftPaneRoot);
     }
     else {
@@ -509,31 +509,31 @@ HistoryMenu.prototype = {
     // SessionStore doesn't track the hidden window, so just return zero then.
     if (window == Services.appShell.hiddenDOMWindow) {
       return 0;
     }
 
     return SessionStore.getClosedTabCount(window);
   },
 
-  toggleRecentlyClosedTabs: function HM_toggleRecentlyClosedTabs() {
+  toggleRecentlyClosedTabs: function() {
     // enable/disable the Recently Closed Tabs sub menu
     var undoMenu = this._rootElt.getElementsByClassName("recentlyClosedTabsMenu")[0];
 
     // no restorable tabs, so disable menu
     if (this._getClosedTabCount() == 0)
       undoMenu.setAttribute("disabled", true);
     else
       undoMenu.removeAttribute("disabled");
   },
 
   /**
    * Populate when the history menu is opened
    */
-  populateUndoSubmenu: function PHM_populateUndoSubmenu() {
+  populateUndoSubmenu: function() {
     var undoMenu = this._rootElt.getElementsByClassName("recentlyClosedTabsMenu")[0];
     var undoPopup = undoMenu.firstChild;
 
     // remove existing menu items
     while (undoPopup.hasChildNodes())
       undoPopup.removeChild(undoPopup.firstChild);
 
     // no restorable tabs, so make sure menu is disabled, and return
@@ -545,31 +545,31 @@ HistoryMenu.prototype = {
     // enable menu
     undoMenu.removeAttribute("disabled");
 
     // populate menu
     let tabsFragment = RecentlyClosedTabsAndWindowsMenuUtils.getTabsFragment(window, "menuitem");
     undoPopup.appendChild(tabsFragment);
   },
 
-  toggleRecentlyClosedWindows: function PHM_toggleRecentlyClosedWindows() {
+  toggleRecentlyClosedWindows: function() {
     // enable/disable the Recently Closed Windows sub menu
     var undoMenu = this._rootElt.getElementsByClassName("recentlyClosedWindowsMenu")[0];
 
     // no restorable windows, so disable menu
     if (SessionStore.getClosedWindowCount() == 0)
       undoMenu.setAttribute("disabled", true);
     else
       undoMenu.removeAttribute("disabled");
   },
 
   /**
    * Populate when the history menu is opened
    */
-  populateUndoWindowSubmenu: function PHM_populateUndoWindowSubmenu() {
+  populateUndoWindowSubmenu: function() {
     let undoMenu = this._rootElt.getElementsByClassName("recentlyClosedWindowsMenu")[0];
     let undoPopup = undoMenu.firstChild;
     let menuLabelString = gNavigatorBundle.getString("menuUndoCloseWindowLabel");
     let menuLabelStringSingleTab =
       gNavigatorBundle.getString("menuUndoCloseWindowSingleTabLabel");
 
     // remove existing menu items
     while (undoPopup.hasChildNodes())
@@ -584,17 +584,17 @@ HistoryMenu.prototype = {
     // enable menu
     undoMenu.removeAttribute("disabled");
 
     // populate menu
     let windowsFragment = RecentlyClosedTabsAndWindowsMenuUtils.getWindowsFragment(window, "menuitem");
     undoPopup.appendChild(windowsFragment);
   },
 
-  toggleTabsFromOtherComputers: function PHM_toggleTabsFromOtherComputers() {
+  toggleTabsFromOtherComputers: function() {
     // This is a no-op if MOZ_SERVICES_SYNC isn't defined
 #ifdef MOZ_SERVICES_SYNC
     // Enable/disable the Tabs From Other Computers menu. Some of the menus handled
     // by HistoryMenu do not have this menuitem.
     let menuitem = this._rootElt.getElementsByClassName("syncTabsMenuItem")[0];
     if (!menuitem)
       return;
 
@@ -604,29 +604,29 @@ HistoryMenu.prototype = {
     }
 
     let enabled = PlacesUIUtils.shouldEnableTabsFromOtherComputersMenuitem();
     menuitem.setAttribute("disabled", !enabled);
     menuitem.setAttribute("hidden", false);
 #endif
   },
 
-  _onPopupShowing: function HM__onPopupShowing(aEvent) {
+  _onPopupShowing: function(aEvent) {
     PlacesMenu.prototype._onPopupShowing.apply(this, arguments);
 
     // Don't handle events for submenus.
     if (aEvent.target != aEvent.currentTarget)
       return;
 
     this.toggleRecentlyClosedTabs();
     this.toggleRecentlyClosedWindows();
     this.toggleTabsFromOtherComputers();
   },
 
-  _onCommand: function HM__onCommand(aEvent) {
+  _onCommand: function(aEvent) {
     let placesNode = aEvent.target._placesNode;
     if (placesNode) {
       if (!PrivateBrowsingUtils.isWindowPrivate(window))
         PlacesUIUtils.markPageAsTyped(placesNode.uri);
       openUILink(placesNode.uri, aEvent, { ignoreAlt: true });
     }
   }
 };
@@ -644,17 +644,17 @@ var BookmarksEventHandler = {
    * Left-click is handled in the onCommand function.
    * When items are middle-clicked (or clicked with modifier), open in tabs.
    * If the click came through a menu, close the menu.
    * @param aEvent
    *        DOMEvent for the click
    * @param aView
    *        The places view which aEvent should be associated with.
    */
-  onClick: function BEH_onClick(aEvent, aView) {
+  onClick: function(aEvent, aView) {
     // Only handle middle-click or left-click with modifiers.
 #ifdef XP_MACOSX
     var modifKey = aEvent.metaKey || aEvent.shiftKey;
 #else
     var modifKey = aEvent.ctrlKey || aEvent.shiftKey;
 #endif
     if (aEvent.button == 2 || (aEvent.button == 0 && !modifKey))
       return;
@@ -691,23 +691,23 @@ var BookmarksEventHandler = {
    * Handler for command event for an item in the bookmarks toolbar.
    * Menus and submenus from the folder buttons bubble up to this handler.
    * Opens the item.
    * @param aEvent 
    *        DOMEvent for the command
    * @param aView
    *        The places view which aEvent should be associated with.
    */
-  onCommand: function BEH_onCommand(aEvent, aView) {
+  onCommand: function(aEvent, aView) {
     var target = aEvent.originalTarget;
     if (target._placesNode)
       PlacesUIUtils.openNodeWithEvent(target._placesNode, aEvent, aView);
   },
 
-  fillInBHTooltip: function BEH_fillInBHTooltip(aDocument, aEvent) {
+  fillInBHTooltip: function(aDocument, aEvent) {
     var node;
     var cropped = false;
     var targetURI;
 
     if (aDocument.tooltipNode.localName == "treechildren") {
       var tree = aDocument.tooltipNode.parentNode;
       var tbo = tree.treeBoxObject;
       var cell = tbo.getCellAt(aEvent.clientX, aEvent.clientY);
@@ -770,17 +770,17 @@ var PlacesMenuDNDHandler = {
   _closeTimer: null,
   _closingTimerNode: null,
 
   /**
    * Called when the user enters the <menu> element during a drag.
    * @param   event
    *          The DragEnter event that spawned the opening. 
    */
-  onDragEnter: function PMDH_onDragEnter(event) {
+  onDragEnter: function(event) {
     // Opening menus in a Places popup is handled by the view itself.
     if (!this._isStaticContainer(event.target))
       return;
 
     // If we re-enter the same menu or anchor before the close timer runs out,
     // we should ensure that we do not close:
     if (this._closeTimer && this._closingTimerNode === event.currentTarget) {
       this._closeTimer.cancel();
@@ -801,17 +801,17 @@ var PlacesMenuDNDHandler = {
     }, this._springLoadDelayMs, Ci.nsITimer.TYPE_ONE_SHOT);
     event.preventDefault();
     event.stopPropagation();
   },
 
   /**
    * Handles dragleave on the <menu> element.
    */
-  onDragLeave: function PMDH_onDragLeave(event) {
+  onDragLeave: function(event) {
     // Handle menu-button separate targets.
     if (event.relatedTarget === event.currentTarget ||
         (event.relatedTarget &&
          event.relatedTarget.parentNode === event.currentTarget))
       return;
 
     // Closing menus in a Places popup is handled by the view itself.
     if (!this._isStaticContainer(event.target))
@@ -842,48 +842,48 @@ var PlacesMenuDNDHandler = {
     }, this._closeDelayMs, Ci.nsITimer.TYPE_ONE_SHOT);
   },
 
   /**
    * Determines if a XUL element represents a static container.
    * @returns true if the element is a container element (menu or 
    *`         menu-toolbarbutton), false otherwise.
    */
-  _isStaticContainer: function PMDH__isContainer(node) {
+  _isStaticContainer: function(node) {
     let isMenu = node.localName == "menu" ||
                  (node.localName == "toolbarbutton" &&
                   (node.getAttribute("type") == "menu" ||
                    node.getAttribute("type") == "menu-button"));
     let isStatic = !("_placesNode" in node) && node.lastChild &&
                    node.lastChild.hasAttribute("placespopup") &&
                    !node.parentNode.hasAttribute("placespopup");
     return isMenu && isStatic;
   },
 
   /**
    * Called when the user drags over the <menu> element.
    * @param   event
    *          The DragOver event. 
    */
-  onDragOver: function PMDH_onDragOver(event) {
+  onDragOver: function(event) {
     let ip = new InsertionPoint(PlacesUtils.bookmarksMenuFolderId,
                                 PlacesUtils.bookmarks.DEFAULT_INDEX,
                                 Ci.nsITreeView.DROP_ON);
     if (ip && PlacesControllerDragHelper.canDrop(ip, event.dataTransfer))
       event.preventDefault();
 
     event.stopPropagation();
   },
 
   /**
    * Called when the user drops on the <menu> element.
    * @param   event
    *          The Drop event. 
    */
-  onDrop: function PMDH_onDrop(event) {
+  onDrop: function(event) {
     // Put the item at the end of bookmark menu.
     let ip = new InsertionPoint(PlacesUtils.bookmarksMenuFolderId,
                                 PlacesUtils.bookmarks.DEFAULT_INDEX,
                                 Ci.nsITreeView.DROP_ON);
     PlacesControllerDragHelper.onDrop(ip, event.dataTransfer);
     PlacesControllerDragHelper.currentDropTarget = null;
     event.stopPropagation();
   }
@@ -902,17 +902,17 @@ let PlacesToolbarHelper = {
   get _viewElt() {
     return document.getElementById("PlacesToolbar");
   },
 
   get _placeholder() {
     return document.getElementById("bookmarks-toolbar-placeholder");
   },
 
-  init: function PTH_init(forceToolbarOverflowCheck) {
+  init: function(forceToolbarOverflowCheck) {
     let viewElt = this._viewElt;
     if (!viewElt || viewElt._placesView)
       return;
 
     // CustomizableUI.addListener is idempotent, so we can safely
     // call this multiple times.
     CustomizableUI.addListener(this);
 
@@ -930,58 +930,58 @@ let PlacesToolbarHelper = {
     new PlacesToolbar(this._place);
     if (forceToolbarOverflowCheck) {
       viewElt._placesView.updateOverflowStatus();
     }
     this._shouldWrap = false;
     this._setupPlaceholder();
   },
 
-  uninit: function PTH_uninit() {
+  uninit: function() {
     CustomizableUI.removeListener(this);
   },
 
-  customizeStart: function PTH_customizeStart() {
+  customizeStart: function() {
     try {
       let viewElt = this._viewElt;
       if (viewElt && viewElt._placesView)
         viewElt._placesView.uninit();
     } finally {
       this._isCustomizing = true;
     }
     this._shouldWrap = this._getShouldWrap();
   },
 
-  customizeChange: function PTH_customizeChange() {
+  customizeChange: function() {
     this._setupPlaceholder();
   },
 
-  _setupPlaceholder: function PTH_setupPlaceholder() {
+  _setupPlaceholder: function() {
     let placeholder = this._placeholder;
     if (!placeholder) {
       return;
     }
 
     let shouldWrapNow = this._getShouldWrap();
     if (this._shouldWrap != shouldWrapNow) {
       if (shouldWrapNow) {
         placeholder.setAttribute("wrap", "true");
       } else {
         placeholder.removeAttribute("wrap");
       }
       this._shouldWrap = shouldWrapNow;
     }
   },
 
-  customizeDone: function PTH_customizeDone() {
+  customizeDone: function() {
     this._isCustomizing = false;
     this.init(true);
   },
 
-  _getShouldWrap: function PTH_getShouldWrap() {
+  _getShouldWrap: function() {
     let placement = CustomizableUI.getPlacementOfWidget("personal-bookmarks");
     let area = placement && placement.area;
     let areaType = area && CustomizableUI.getAreaType(area);
     return !area || CustomizableUI.TYPE_MENU_PANEL == areaType;
   },
 
   onPlaceholderCommand: function () {
     let widgetGroup = CustomizableUI.getWidget("personal-bookmarks");
@@ -1136,21 +1136,21 @@ let BookmarkingUI = {
 
   /**
    * The popup contents must be updated when the user customizes the UI, or
    * changes the personal toolbar collapsed status.  In such a case, any needed
    * change should be handled in the popupshowing helper, for performance
    * reasons.
    */
   _popupNeedsUpdate: true,
-  onToolbarVisibilityChange: function BUI_onToolbarVisibilityChange() {
+  onToolbarVisibilityChange: function() {
     this._popupNeedsUpdate = true;
   },
 
-  onPopupShowing: function BUI_onPopupShowing(event) {
+  onPopupShowing: function(event) {
     // Don't handle events for submenus.
     if (event.target != event.currentTarget)
       return;
 
     // Ideally this code would never be reached, but if you click the outer
     // button's border, some cpp code for the menu button's so-called XBL binding
     // decides to open the popup even though the dropmarker is invisible.
     if (this._currentAreaType == CustomizableUI.TYPE_MENU_PANEL) {
@@ -1201,53 +1201,53 @@ let BookmarkingUI = {
       },
       insertionPoint: ".panel-subview-footer"
     });
   },
 
   /**
    * Handles star styling based on page proxy state changes.
    */
-  onPageProxyStateChanged: function BUI_onPageProxyStateChanged(aState) {
+  onPageProxyStateChanged: function(aState) {
     if (!this._shouldUpdateStarState() || !this.star) {
       return;
     }
 
     if (aState == "invalid") {
       this.star.setAttribute("disabled", "true");
       this.button.removeAttribute("starred");
       this.button.setAttribute("buttontooltiptext", "");
     }
     else {
       this.star.removeAttribute("disabled");
       this._updateStar();
     }
     this._updateToolbarStyle();
   },
 
-  _updateCustomizationState: function BUI__updateCustomizationState() {
+  _updateCustomizationState: function() {
     let placement = CustomizableUI.getPlacementOfWidget(this.BOOKMARK_BUTTON_ID);
     this._currentAreaType = placement && CustomizableUI.getAreaType(placement.area);
   },
 
-  _updateToolbarStyle: function BUI__updateToolbarStyle() {
+  _updateToolbarStyle: function() {
     let onPersonalToolbar = false;
     if (this._currentAreaType == CustomizableUI.TYPE_TOOLBAR) {
       let personalToolbar = document.getElementById("PersonalToolbar");
       onPersonalToolbar = this.button.parentNode == personalToolbar ||
                           this.button.parentNode.parentNode == personalToolbar;
     }
 
     if (onPersonalToolbar)
       this.button.classList.add("bookmark-item");
     else
       this.button.classList.remove("bookmark-item");
   },
 
-  _uninitView: function BUI__uninitView() {
+  _uninitView: function() {
     // When an element with a placesView attached is removed and re-inserted,
     // XBL reapplies the binding causing any kind of issues and possible leaks,
     // so kill current view and let popupshowing generate a new one.
     if (this.button._placesView)
       this.button._placesView.uninit();
 
     // We have to do the same thing for the "special" views underneath the
     // the bookmarks menu.
@@ -1255,102 +1255,102 @@ let BookmarkingUI = {
     for (let viewNodeID of kSpecialViewNodeIDs) {
       let elem = document.getElementById(viewNodeID);
       if (elem && elem._placesView) {
         elem._placesView.uninit();
       }
     }
   },
 
-  onCustomizeStart: function BUI_customizeStart(aWindow) {
+  onCustomizeStart: function(aWindow) {
     if (aWindow == window) {
       this._uninitView();
       this._isCustomizing = true;
     }
   },
 
-  onWidgetAdded: function BUI_widgetAdded(aWidgetId) {
+  onWidgetAdded: function(aWidgetId) {
     if (aWidgetId == this.BOOKMARK_BUTTON_ID) {
       this._onWidgetWasMoved();
     }
   },
 
-  onWidgetRemoved: function BUI_widgetRemoved(aWidgetId) {
+  onWidgetRemoved: function(aWidgetId) {
     if (aWidgetId == this.BOOKMARK_BUTTON_ID) {
       this._onWidgetWasMoved();
     }
   },
 
-  onWidgetReset: function BUI_widgetReset(aNode, aContainer) {
+  onWidgetReset: function(aNode, aContainer) {
     if (aNode == this.button) {
       this._onWidgetWasMoved();
     }
   },
 
-  onWidgetUndoMove: function BUI_undoWidgetUndoMove(aNode, aContainer) {
+  onWidgetUndoMove: function(aNode, aContainer) {
     if (aNode == this.button) {
       this._onWidgetWasMoved();
     }
   },
 
-  _onWidgetWasMoved: function BUI_widgetWasMoved() {
+  _onWidgetWasMoved: function() {
     let usedToUpdateStarState = this._shouldUpdateStarState();
     this._updateCustomizationState();
     if (!usedToUpdateStarState && this._shouldUpdateStarState()) {
       this.updateStarState();
     } else if (usedToUpdateStarState && !this._shouldUpdateStarState()) {
       this._updateStar();
     }
     // If we're moved outside of customize mode, we need to uninit
     // our view so it gets reconstructed.
     if (!this._isCustomizing) {
       this._uninitView();
     }
     this._updateToolbarStyle();
   },
 
-  onCustomizeEnd: function BUI_customizeEnd(aWindow) {
+  onCustomizeEnd: function(aWindow) {
     if (aWindow == window) {
       this._isCustomizing = false;
       this.onToolbarVisibilityChange();
       this._updateToolbarStyle();
     }
   },
 
   init: function() {
     CustomizableUI.addListener(this);
     this._updateCustomizationState();
   },
 
   _hasBookmarksObserver: false,
   _itemIds: [],
-  uninit: function BUI_uninit() {
+  uninit: function() {
     this._updateBookmarkPageMenuItem(true);
     CustomizableUI.removeListener(this);
 
     this._uninitView();
 
     if (this._hasBookmarksObserver) {
       PlacesUtils.removeLazyBookmarkObserver(this);
     }
 
     if (this._pendingStmt) {
       this._pendingStmt.cancel();
       delete this._pendingStmt;
     }
   },
 
-  onLocationChange: function BUI_onLocationChange() {
+  onLocationChange: function() {
     if (this._uri && gBrowser.currentURI.equals(this._uri)) {
       return;
     }
     this.updateStarState();
   },
 
-  updateStarState: function BUI_updateStarState() {
+  updateStarState: function() {
     // Reset tracked values.
     this._uri = gBrowser.currentURI;
     this._itemIds = [];
 
     if (this._pendingStmt) {
       this._pendingStmt.cancel();
       delete this._pendingStmt;
     }
@@ -1385,17 +1385,17 @@ let BookmarkingUI = {
           Components.utils.reportError("BookmarkingUI failed adding a bookmarks observer: " + ex);
         }
       }
 
       delete this._pendingStmt;
     });
   },
 
-  _updateStar: function BUI__updateStar() {
+  _updateStar: function() {
     if (!this._shouldUpdateStarState()) {
       if (this.button.hasAttribute("starred")) {
         this.button.removeAttribute("starred");
         this.button.removeAttribute("buttontooltiptext");
       }
       return;
     }
 
@@ -1414,28 +1414,28 @@ let BookmarkingUI = {
       }
     }
   },
 
   /**
    * forceReset is passed when we're destroyed and the label should go back
    * to the default (Bookmark This Page) for OS X.
    */
-  _updateBookmarkPageMenuItem: function BUI__updateBookmarkPageMenuItem(forceReset) {
+  _updateBookmarkPageMenuItem: function(forceReset) {
     let isStarred = !forceReset && this._itemIds.length > 0;
     let label = isStarred ? "editlabel" : "bookmarklabel";
     this.broadcaster.setAttribute("label", this.broadcaster.getAttribute(label));
   },
 
-  onMainMenuPopupShowing: function BUI_onMainMenuPopupShowing(event) {
+  onMainMenuPopupShowing: function(event) {
     this._updateBookmarkPageMenuItem();
     PlacesCommandHook.updateBookmarkAllTabsCommand();
   },
 
-  _showBookmarkedNotification: function BUI_showBookmarkedNotification() {
+  _showBookmarkedNotification: function() {
     function getCenteringTransformForRects(rectToPosition, referenceRect) {
       let topDiff = referenceRect.top - rectToPosition.top;
       let leftDiff = referenceRect.left - rectToPosition.left;
       let heightDiff = referenceRect.height - rectToPosition.height;
       let widthDiff = referenceRect.width - rectToPosition.width;
       return [(leftDiff + .5 * widthDiff) + "px", (topDiff + .5 * heightDiff) + "px"];
     }
 
@@ -1498,17 +1498,17 @@ let BookmarkingUI = {
     view.addEventListener("ViewShowing", this);
     view.addEventListener("ViewHiding", this);
     let anchor = document.getElementById(this.BOOKMARK_BUTTON_ID);
     anchor.setAttribute("closemenu", "none");
     PanelUI.showSubView("PanelUI-bookmarks", anchor,
                         CustomizableUI.AREA_PANEL);
   },
 
-  onCommand: function BUI_onCommand(aEvent) {
+  onCommand: function(aEvent) {
     if (aEvent.target != aEvent.currentTarget) {
       return;
     }
 
     // Handle special case when the button is in the panel.
     let isBookmarked = this._itemIds.length > 0;
 
     if (this._currentAreaType == CustomizableUI.TYPE_MENU_PANEL) {
@@ -1529,28 +1529,28 @@ let BookmarkingUI = {
     // Ignore clicks on the star if we are updating its state.
     if (!this._pendingStmt) {
       if (!isBookmarked)
         this._showBookmarkedNotification();
       PlacesCommandHook.bookmarkCurrentPage(isBookmarked);
     }
   },
 
-  handleEvent: function BUI_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "ViewShowing":
         this.onPanelMenuViewShowing(aEvent);
         break;
       case "ViewHiding":
         this.onPanelMenuViewHiding(aEvent);
         break;
     }
   },
 
-  onPanelMenuViewShowing: function BUI_onViewShowing(aEvent) {
+  onPanelMenuViewShowing: function(aEvent) {
     this._updateBookmarkPageMenuItem();
     // Update checked status of the toolbar toggle.
     let viewToolbar = document.getElementById("panelMenu_viewBookmarksToolbar");
     let personalToolbar = document.getElementById("PersonalToolbar");
     if (personalToolbar.collapsed)
       viewToolbar.removeAttribute("checked");
     else
       viewToolbar.setAttribute("checked", "true");
@@ -1565,23 +1565,23 @@ let BookmarkingUI = {
                                                     extraClasses: {
                                                       entry: "subviewbutton",
                                                       footer: "panel-subview-footer"
                                                     }
                                                   });
     aEvent.target.removeEventListener("ViewShowing", this);
   },
 
-  onPanelMenuViewHiding: function BUI_onViewHiding(aEvent) {
+  onPanelMenuViewHiding: function(aEvent) {
     this._panelMenuView.uninit();
     delete this._panelMenuView;
     aEvent.target.removeEventListener("ViewHiding", this);
   },
 
-  onPanelMenuViewCommand: function BUI_onPanelMenuViewCommand(aEvent, aView) {
+  onPanelMenuViewCommand: function(aEvent, aView) {
     let target = aEvent.originalTarget;
     if (!target._placesNode)
       return;
     if (PlacesUtils.nodeIsContainer(target._placesNode))
       PlacesCommandHook.showPlacesOrganizer([ "BookmarksMenu", target._placesNode.itemId ]);
     else
       PlacesUIUtils.openNodeWithEvent(target._placesNode, aEvent, aView);
     PanelUI.hide();
@@ -1597,17 +1597,17 @@ let BookmarkingUI = {
         // Only need to update the UI if it wasn't marked as starred before:
         if (this._itemIds.length == 1) {
           this._updateStar();
         }
       }
     }
   },
 
-  onItemRemoved: function BUI_onItemRemoved(aItemId) {
+  onItemRemoved: function(aItemId) {
     let index = this._itemIds.indexOf(aItemId);
     // If one of the tracked bookmarks has been removed, unregister it.
     if (index != -1) {
       this._itemIds.splice(index, 1);
       // Only need to update the UI if the page is no longer starred
       if (this._itemIds.length == 0) {
         this._updateStar();
       }
diff --git a/browser/base/content/browser-plugins.js b/browser/base/content/browser-plugins.js
--- a/browser/base/content/browser-plugins.js
+++ b/browser/base/content/browser-plugins.js
@@ -98,17 +98,17 @@ var gPluginHandler = {
 
   // Callback for user clicking on the link in a click-to-play plugin
   // (where the plugin has an update)
   openPluginUpdatePage: function () {
     openUILinkIn(Services.urlFormatter.formatURLPref("plugins.update.url"), "tab");
   },
 
 #ifdef MOZ_CRASHREPORTER
-  submitReport: function submitReport(pluginDumpID, browserDumpID, keyVals) {
+  submitReport: function(pluginDumpID, browserDumpID, keyVals) {
     keyVals = keyVals || {};
     this.CrashSubmit.submit(pluginDumpID, { recordSubmission: true,
                                             extraExtraKeyVals: keyVals });
     if (browserDumpID)
       this.CrashSubmit.submit(browserDumpID);
   },
 #endif
 
@@ -117,17 +117,17 @@ var gPluginHandler = {
     browser.reload();
   },
 
   // Callback for user clicking the help icon
   openHelpPage: function () {
     openHelpLink("plugin-crashed", false);
   },
 
-  _clickToPlayNotificationEventCallback: function PH_ctpEventCallback(event) {
+  _clickToPlayNotificationEventCallback: function(event) {
     if (event == "showing") {
       Services.telemetry.getHistogramById("PLUGINS_NOTIFICATION_SHOWN")
         .add(!this.options.primaryPlugin);
       // Histograms always start at 0, even though our data starts at 1
       let histogramCount = this.options.pluginData.size - 1;
       if (histogramCount > 4) {
         histogramCount = 4;
       }
diff --git a/browser/base/content/browser-social.js b/browser/base/content/browser-social.js
--- a/browser/base/content/browser-social.js
+++ b/browser/base/content/browser-social.js
@@ -51,17 +51,17 @@ XPCOMUtils.defineLazyGetter(this, "hookW
   Cu.import("resource://gre/modules/MozSocialAPI.jsm", tmp);
   return tmp.hookWindowCloseForPanelClose;
 });
 
 SocialUI = {
   _initialized: false,
 
   // Called on delayed startup to initialize the UI
-  init: function SocialUI_init() {
+  init: function() {
     if (this._initialized) {
       return;
     }
 
     Services.obs.addObserver(this, "social:ambient-notification-changed", false);
     Services.obs.addObserver(this, "social:profile-changed", false);
     Services.obs.addObserver(this, "social:frameworker-error", false);
     Services.obs.addObserver(this, "social:providers-changed", false);
@@ -85,17 +85,17 @@ SocialUI = {
       // handle SessionStore for the sidebar state
       SocialSidebar.restoreWindowState();
     });
 
     this._initialized = true;
   },
 
   // Called on window unload
-  uninit: function SocialUI_uninit() {
+  uninit: function() {
     if (!this._initialized) {
       return;
     }
     SocialSidebar.saveWindowState();
 
     Services.obs.removeObserver(this, "social:ambient-notification-changed");
     Services.obs.removeObserver(this, "social:profile-changed");
     Services.obs.removeObserver(this, "social:frameworker-error");
@@ -109,17 +109,17 @@ SocialUI = {
     SocialActivationListener.uninit();
 
     document.getElementById("viewSidebarMenu").removeEventListener("popupshowing", SocialSidebar.populateSidebarMenu, true);
     document.getElementById("social-statusarea-popup").removeEventListener("popupshowing", SocialSidebar.populateSidebarMenu, true);
 
     this._initialized = false;
   },
 
-  observe: function SocialUI_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     switch (topic) {
       case "social:provider-enabled":
         SocialMarks.populateToolbarPalette();
         SocialStatus.populateToolbarPalette();
         break;
       case "social:provider-disabled":
         SocialMarks.removeProvider(data);
         SocialStatus.removeProvider(data);
@@ -355,17 +355,17 @@ SocialFlyout = {
     iframe.setAttribute("type", "content");
     iframe.setAttribute("class", "social-panel-frame");
     iframe.setAttribute("flex", "1");
     iframe.setAttribute("tooltip", "aHTMLTooltip");
     iframe.setAttribute("origin", SocialSidebar.provider.origin);
     panel.appendChild(iframe);
   },
 
-  setFlyoutErrorMessage: function SF_setFlyoutErrorMessage() {
+  setFlyoutErrorMessage: function() {
     this.iframe.removeAttribute("src");
     this.iframe.webNavigation.loadURI("about:socialerror?mode=compactInfo&origin=" +
                                  encodeURIComponent(this.iframe.getAttribute("origin")),
                                  null, null, null, null);
     sizeSocialPanelToContent(this.panel, this.iframe);
   },
 
   unload: function() {
@@ -876,17 +876,17 @@ SocialSidebar = {
   },
 
   updateToggleNotifications: function() {
     let command = document.getElementById("Social:ToggleNotifications");
     command.setAttribute("checked", Services.prefs.getBoolPref("social.toast-notifications.enabled"));
     command.setAttribute("hidden", !SocialUI.enabled);
   },
 
-  update: function SocialSidebar_update() {
+  update: function() {
     // ensure we never update before restoreWindowState
     if (!this._initialized)
       return;
     this.ensureProvider();
     this.updateToggleNotifications();
     this._updateHeader();
     clearTimeout(this._unloadTimeoutId);
     // Hide the toggle menu item if the sidebar cannot appear
@@ -945,25 +945,25 @@ SocialSidebar = {
     }
     this._updateCheckedMenuItems(this.opened && this.provider ? this.provider.origin : null);
   },
 
   _onclick: function() {
     Services.telemetry.getHistogramById("SOCIAL_PANEL_CLICKS").add(3);
   },
 
-  _loadListener: function SocialSidebar_loadListener() {
+  _loadListener: function() {
     let sbrowser = document.getElementById("social-sidebar-browser");
     sbrowser.removeEventListener("load", SocialSidebar._loadListener, true);
     document.getElementById("social-sidebar-button").removeAttribute("loading");
     SocialSidebar.setSidebarVisibilityState(true);
     sbrowser.addEventListener("click", SocialSidebar._onclick, true);
   },
 
-  unloadSidebar: function SocialSidebar_unloadSidebar() {
+  unloadSidebar: function() {
     let sbrowser = document.getElementById("social-sidebar-browser");
     if (!sbrowser.hasAttribute("origin"))
       return;
 
     sbrowser.removeEventListener("click", SocialSidebar._onclick, true);
     sbrowser.stop();
     sbrowser.removeAttribute("origin");
     sbrowser.setAttribute("src", "about:blank");
@@ -1072,17 +1072,17 @@ SocialSidebar = {
     broadcaster.hidden = true;
     this._updateCheckedMenuItems();
     this.clearProviderMenus();
     SocialSidebar.update();
     this.saveWindowState();
     Services.telemetry.getHistogramById("SOCIAL_SIDEBAR_STATE").add(false);
   },
 
-  toggleSidebar: function SocialSidebar_toggle() {
+  toggleSidebar: function() {
     let broadcaster = document.getElementById("socialSidebarBroadcaster");
     if (broadcaster.hidden)
       this.show();
     else
       this.hide();
   },
 
   populateSidebarMenu: function(event) {
diff --git a/browser/base/content/browser-syncui.js b/browser/base/content/browser-syncui.js
--- a/browser/base/content/browser-syncui.js
+++ b/browser/base/content/browser-syncui.js
@@ -66,33 +66,33 @@ let gSyncUI = {
       if (Weave.Status.ready) {
         gSyncUI._obs.forEach(function(topic) {
           Services.obs.removeObserver(gSyncUI, topic);
         });
       }
     }, false);
   },
 
-  initUI: function SUI_initUI() {
+  initUI: function() {
     // If this is a browser window?
     if (gBrowser) {
       this._obs.push("weave:notification:added");
     }
 
     this._obs.forEach(function(topic) {
       Services.obs.addObserver(this, topic, true);
     }, this);
 
     if (gBrowser && Weave.Notifications.notifications.length) {
       this.initNotifications();
     }
     this.updateUI();
   },
 
-  initNotifications: function SUI_initNotifications() {
+  initNotifications: function() {
     const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
     let notificationbox = document.createElementNS(XULNS, "notificationbox");
     notificationbox.id = "sync-notifications";
     notificationbox.setAttribute("flex", "1");
 
     let bottombox = document.getElementById("browser-bottombox");
     bottombox.insertBefore(notificationbox, bottombox.firstChild);
 
@@ -135,17 +135,17 @@ let gSyncUI = {
            firstSync == "notReady";
   },
 
   _loginFailed: function () {
     return Weave.Status.login == Weave.LOGIN_FAILED_LOGIN_REJECTED ||
            ReadingListScheduler.state == ReadingListScheduler.STATE_ERROR_AUTHENTICATION;
   },
 
-  updateUI: function SUI_updateUI() {
+  updateUI: function() {
     let needsSetup = this._needsSetup();
     let loginFailed = this._loginFailed();
 
     // Start off with a clean slate
     document.getElementById("sync-reauth-state").hidden = true;
     document.getElementById("sync-setup-state").hidden = true;
     document.getElementById("sync-syncnow-state").hidden = true;
 
@@ -209,27 +209,27 @@ let gSyncUI = {
       syncButton.removeAttribute("status");
     }
     let panelHorizontalButton = document.getElementById("PanelUI-fxa-status");
     if (panelHorizontalButton) {
       panelHorizontalButton.removeAttribute("syncstatus");
     }
   },
 
-  onLoginFinish: function SUI_onLoginFinish() {
+  onLoginFinish: function() {
     // Clear out any login failure notifications
     let title = this._stringBundle.GetStringFromName("error.login.title");
     this.clearError(title);
   },
 
-  onSetupComplete: function SUI_onSetupComplete() {
+  onSetupComplete: function() {
     this.onLoginFinish();
   },
 
-  onLoginError: function SUI_onLoginError() {
+  onLoginError: function() {
     // Note: This is used for *both* Sync and ReadingList login errors.
     // if login fails, any other notifications are essentially moot
     Weave.Notifications.removeAll();
 
     // if we haven't set up the client, don't show errors
     if (this._needsSetup()) {
       this.updateUI();
       return;
@@ -270,25 +270,25 @@ let gSyncUI = {
       function() { gSyncUI.openPrefs(); return true; }
     ));
 
     let notification = new Weave.Notification(title, description, null,
                                               Weave.Notifications.PRIORITY_WARNING, buttons);
     Weave.Notifications.replaceTitle(notification);
   },
 
-  onLogout: function SUI_onLogout() {
+  onLogout: function() {
     this.updateUI();
   },
 
-  onStartOver: function SUI_onStartOver() {
+  onStartOver: function() {
     this.clearError();
   },
 
-  onQuotaNotice: function onQuotaNotice(subject, data) {
+  onQuotaNotice: function(subject, data) {
     let title = this._stringBundle.GetStringFromName("warning.sync.quota.label");
     let description = this._stringBundle.GetStringFromName("warning.sync.quota.description");
     let buttons = [];
     buttons.push(new Weave.NotificationButton(
       this._stringBundle.GetStringFromName("error.sync.viewQuotaButton.label"),
       this._stringBundle.GetStringFromName("error.sync.viewQuotaButton.accesskey"),
       function() { gSyncUI.openQuotaDialog(); return true; }
     ));
@@ -304,28 +304,28 @@ let gSyncUI = {
   },
 
   openServerStatus: function () {
     let statusURL = Services.prefs.getCharPref("services.sync.statusURL");
     window.openUILinkIn(statusURL, "tab");
   },
 
   // Commands
-  doSync: function SUI_doSync() {
+  doSync: function() {
     let needsSetup = this._needsSetup();
 
     if (!needsSetup) {
       setTimeout(function () Weave.Service.errorHandler.syncAndReportErrors(), 0);
     }
 
     Services.obs.notifyObservers(null, "cloudsync:user-sync", null);
     Services.obs.notifyObservers(null, "readinglist:user-sync", null);
   },
 
-  handleToolbarButton: function SUI_handleStatusbarButton() {
+  handleToolbarButton: function() {
     if (this._needsSetup())
       this.openSetup();
     else
       this.doSync();
   },
 
   //XXXzpao should be part of syncCommon.js - which we might want to make a module...
   //        To be fixed in a followup (bug 583366)
@@ -337,17 +337,17 @@ let gSyncUI = {
    *        Indicates type of wizard to launch:
    *          null    -- regular set up wizard
    *          "pair"  -- pair a device first
    *          "reset" -- reset sync
    * @param entryPoint
    *        Indicates the entrypoint from where this method was called.
    */
 
-  openSetup: function SUI_openSetup(wizardType, entryPoint = "syncbutton") {
+  openSetup: function(wizardType, entryPoint = "syncbutton") {
     let xps = Components.classes["@mozilla.org/weave/service;1"]
                                 .getService(Components.interfaces.nsISupports)
                                 .wrappedJSObject;
     if (xps.fxAccountsEnabled) {
       fxAccounts.getSignedInUser().then(userData => {
         if (userData) {
           this.openPrefs();
         } else {
@@ -380,36 +380,36 @@ let gSyncUI = {
     let win = Services.wm.getMostRecentWindow("Sync:AddDevice");
     if (win)
       win.focus();
     else
       window.openDialog("chrome://browser/content/sync/addDevice.xul",
                         "syncAddDevice", "centerscreen,chrome,resizable=no");
   },
 
-  openQuotaDialog: function SUI_openQuotaDialog() {
+  openQuotaDialog: function() {
     let win = Services.wm.getMostRecentWindow("Sync:ViewQuota");
     if (win)
       win.focus();
     else
       Services.ww.activeWindow.openDialog(
         "chrome://browser/content/sync/quota.xul", "",
         "centerscreen,chrome,dialog,modal");
   },
 
-  openPrefs: function SUI_openPrefs() {
+  openPrefs: function() {
     openPreferences("paneSync");
   },
 
   openSignInAgainPage: function (entryPoint = "syncbutton") {
     gFxAccounts.openSignInAgainPage(entryPoint);
   },
 
   // Helpers
-  _updateLastSyncTime: function SUI__updateLastSyncTime() {
+  _updateLastSyncTime: function() {
     if (!gBrowser)
       return;
 
     let syncButton = document.getElementById("sync-button");
     if (!syncButton)
       return;
 
     let lastSync;
@@ -433,22 +433,22 @@ let gSyncUI = {
     // Show the day-of-week and time (HH:MM) of last sync
     let lastSyncDateString = lastSync.toLocaleFormat("%a %H:%M");
     let lastSyncLabel =
       this._stringBundle.formatStringFromName("lastSync2.label", [lastSyncDateString], 1);
 
     syncButton.setAttribute("tooltiptext", lastSyncLabel);
   },
 
-  clearError: function SUI_clearError(errorString) {
+  clearError: function(errorString) {
     Weave.Notifications.removeAll(errorString);
     this.updateUI();
   },
 
-  onSyncFinish: function SUI_onSyncFinish() {
+  onSyncFinish: function() {
     let title = this._stringBundle.GetStringFromName("error.sync.title");
 
     // Clear out sync failures on a successful sync
     this.clearError(title);
   },
 
   // Return true if the reading-list is in a "prolonged" error state. That
   // engine doesn't impose what that means, so calculate it here. For
@@ -506,17 +506,17 @@ let gSyncUI = {
     ];
     let notification =
       new Weave.Notification(title, description, null, priority, buttons);
     Weave.Notifications.replaceTitle(notification);
 
     this.updateUI();
   },
 
-  onSyncError: function SUI_onSyncError() {
+  onSyncError: function() {
     this.log.debug("onSyncError");
     let title = this._stringBundle.GetStringFromName("error.sync.title");
 
     if (Weave.Status.login != Weave.LOGIN_SUCCEEDED) {
       this.onLoginError();
       return;
     }
 
@@ -581,17 +581,17 @@ let gSyncUI = {
 
     let notification =
       new Weave.Notification(title, description, null, priority, buttons);
     Weave.Notifications.replaceTitle(notification);
 
     this.updateUI();
   },
 
-  observe: function SUI_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     this.log.debug("observed", topic);
     if (this._unloaded) {
       Cu.reportError("SyncUI observer called after unload: " + topic);
       return;
     }
 
     // Unwrap, just like Svc.Obs, but without pulling in that dependency.
     if (subject && typeof subject == "object" &&
diff --git a/browser/base/content/browser-tabview.js b/browser/base/content/browser-tabview.js
--- a/browser/base/content/browser-tabview.js
+++ b/browser/base/content/browser-tabview.js
@@ -51,17 +51,17 @@ let TabView = {
   },
 
   // ----------
   set sessionRestoreEnabledOnce(val) {
     Services.prefs.setBoolPref(this.PREF_RESTORE_ENABLED_ONCE, val);
   },
 
   // ----------
-  init: function TabView_init() {
+  init: function() {
     // disable the ToggleTabView command for popup windows
     goSetCommandEnabled("Browser:ToggleTabView", window.toolbar.visible);
     if (!window.toolbar.visible)
       return;
 
     if (this._initialized)
       return;
 
@@ -118,26 +118,26 @@ let TabView = {
 
     Services.prefs.addObserver(this.PREF_BRANCH, this, false);
 
     this._initialized = true;
   },
 
   // ----------
   // Observes topic changes.
-  observe: function TabView_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     if (data == this.PREF_FIRST_RUN && this.firstUseExperienced) {
       this._addToolbarButton();
       this.enableSessionRestore();
     }
   },
 
   // ----------
   // Uninitializes TabView.
-  uninit: function TabView_uninit() {
+  uninit: function() {
     if (!this._initialized)
       return;
 
     Services.prefs.removeObserver(this.PREF_BRANCH, this);
 
     if (this._tabShowEventListener)
       gBrowser.tabContainer.removeEventListener(
         "TabShow", this._tabShowEventListener, false);
@@ -160,17 +160,17 @@ let TabView = {
       this._iframe.remove();
       this._iframe = null;
     }
   },
 
   // ----------
   // Creates the frame and calls the callback once it's loaded. 
   // If the frame already exists, calls the callback immediately. 
-  _initFrame: function TabView__initFrame(callback) {
+  _initFrame: function(callback) {
     let hasCallback = typeof callback == "function";
 
     // prevent frame to be initialized for popup windows
     if (!window.toolbar.visible)
       return;
 
     if (this._window) {
       if (hasCallback)
@@ -235,58 +235,58 @@ let TabView = {
     // ___ create tooltip
     let tooltip = document.createElement("tooltip");
     tooltip.id = "tab-view-tooltip";
     tooltip.setAttribute("onpopupshowing", "return TabView.fillInTooltip(document.tooltipNode);");
     document.getElementById("mainPopupSet").appendChild(tooltip);
   },
 
   // ----------
-  getContentWindow: function TabView_getContentWindow() {
+  getContentWindow: function() {
     return this._window;
   },
 
   // ----------
-  isVisible: function TabView_isVisible() {
+  isVisible: function() {
     return (this._deck ? this._deck.selectedPanel == this._iframe : false);
   },
 
   // ----------
-  show: function TabView_show() {
+  show: function() {
     if (this.isVisible())
       return;
 
     let self = this;
     this._initFrame(function() {
       self._window.UI.showTabView(true);
     });
   },
 
   // ----------
-  hide: function TabView_hide() {
+  hide: function() {
     if (this.isVisible() && this._window) {
       this._window.UI.exit();
     }
   },
 
   // ----------
-  toggle: function TabView_toggle() {
+  toggle: function() {
     if (this.isVisible())
       this.hide();
     else 
       this.show();
   },
 
   // ----------
-  _tabBrowserHasHiddenTabs: function TabView_tabBrowserHasHiddenTabs() {
+  _tabBrowserHasHiddenTabs: function() {
     return (gBrowser.tabs.length - gBrowser.visibleTabs.length) > 0;
   },
 
   // ----------
-  updateContextMenu: function TabView_updateContextMenu(tab, popup) {
+  updateContextMenu: function(tab, popup) {
     let separator = document.getElementById("context_tabViewNamedGroups");
     let isEmpty = true;
 
     while (popup.firstChild && popup.firstChild != separator)
       popup.removeChild(popup.firstChild);
 
     let self = this;
     this._initFrame(function() {
@@ -305,17 +305,17 @@ let TabView = {
           isEmpty = false;
         }
       });
       separator.hidden = isEmpty;
     });
   },
 
   // ----------
-  _createGroupMenuItem: function TabView__createGroupMenuItem(groupItem) {
+  _createGroupMenuItem: function(groupItem) {
     let menuItem = document.createElement("menuitem");
     let title = groupItem.getTitle();
 
     if (!title.trim()) {
       let topChildLabel = groupItem.getTopChild().tab.label;
       let childNum = groupItem.getChildren().length;
 
       if (childNum > 1) {
@@ -335,31 +335,31 @@ let TabView = {
     menuItem.setAttribute(
       "oncommand",
       "TabView.moveTabTo(TabContextMenu.contextTab,'" + groupItem.id + "')");
 
     return menuItem;
   },
 
   // ----------
-  moveTabTo: function TabView_moveTabTo(tab, groupItemId) {
+  moveTabTo: function(tab, groupItemId) {
     if (this._window) {
       this._window.GroupItems.moveTabToGroupItem(tab, groupItemId);
     } else {
       let self = this;
       this._initFrame(function() {
         self._window.GroupItems.moveTabToGroupItem(tab, groupItemId);
       });
     }
   },
 
   // ----------
   // Adds new key commands to the browser, for invoking the Tab Candy UI
   // and for switching between groups of tabs when outside of the Tab Candy UI.
-  _setBrowserKeyHandlers: function TabView__setBrowserKeyHandlers() {
+  _setBrowserKeyHandlers: function() {
     if (this._browserKeyHandlerInitialized)
       return;
 
     this._browserKeyHandlerInitialized = true;
 
     let self = this;
     window.addEventListener("keypress", function(event) {
       if (self.isVisible() || !self._tabBrowserHasHiddenTabs())
@@ -384,46 +384,46 @@ let TabView = {
             gBrowser.selectedTab = tabItem.tab;
         });
       }
     }, true);
   },
 
   // ----------
   // Prepares the tab view for undo close tab.
-  prepareUndoCloseTab: function TabView_prepareUndoCloseTab(blankTabToRemove) {
+  prepareUndoCloseTab: function(blankTabToRemove) {
     if (this._window) {
       this._window.UI.restoredClosedTab = true;
 
       if (blankTabToRemove && blankTabToRemove._tabViewTabItem)
         blankTabToRemove._tabViewTabItem.isRemovedAfterRestore = true;
     }
   },
 
   // ----------
   // Cleans up the tab view after undo close tab.
-  afterUndoCloseTab: function TabView_afterUndoCloseTab() {
+  afterUndoCloseTab: function() {
     if (this._window)
       this._window.UI.restoredClosedTab = false;
   },
 
   // ----------
   // On move to group pop showing.
-  moveToGroupPopupShowing: function TabView_moveToGroupPopupShowing(event) {
+  moveToGroupPopupShowing: function(event) {
     // Update the context menu only if Panorama was already initialized or if
     // there are hidden tabs.
     let numHiddenTabs = gBrowser.tabs.length - gBrowser.visibleTabs.length;
     if (this._window || numHiddenTabs > 0)
       this.updateContextMenu(TabContextMenu.contextTab, event.target);
   },
 
   // ----------
   // Function: _addToolbarButton
   // Adds the TabView button to the TabsToolbar.
-  _addToolbarButton: function TabView__addToolbarButton() {
+  _addToolbarButton: function() {
     let buttonId = "tabview-button";
 
     if (CustomizableUI.getPlacementOfWidget(buttonId))
       return;
 
     let allTabsBtnPlacement = CustomizableUI.getPlacementOfWidget("alltabs-button");
     // allTabsBtnPlacement can never be null because the button isn't removable
     let desiredPosition = allTabsBtnPlacement.position + 1;
@@ -431,26 +431,26 @@ let TabView = {
     // NB: this is for backwards compatibility, and should be removed by
     // https://bugzilla.mozilla.org/show_bug.cgi?id=976041
     document.persist("TabsToolbar", "currentset");
   },
 
   // ----------
   // Function: updateGroupNumberBroadcaster
   // Updates the group number broadcaster.
-  updateGroupNumberBroadcaster: function TabView_updateGroupNumberBroadcaster(number) {
+  updateGroupNumberBroadcaster: function(number) {
     let groupsNumber = document.getElementById("tabviewGroupsNumber");
     groupsNumber.setAttribute("groups", number);
   },
 
   // ----------
   // Function: enableSessionRestore
   // Enables automatic session restore when the browser is started. Does
   // nothing if we already did that once in the past.
-  enableSessionRestore: function TabView_enableSessionRestore() {
+  enableSessionRestore: function() {
     if (!this._window || !this.firstUseExperienced)
       return;
 
     // do nothing if we already enabled session restore once
     if (this.sessionRestoreEnabledOnce)
       return;
 
     this.sessionRestoreEnabledOnce = true;
@@ -462,17 +462,17 @@ let TabView = {
       // show banner
       this._window.UI.notifySessionRestoreEnabled();
     }
   },
 
   // ----------
   // Function: fillInTooltip
   // Fills in the tooltip text.
-  fillInTooltip: function fillInTooltip(tipElement) {
+  fillInTooltip: function(tipElement) {
     let retVal = false;
     let titleText = null;
     let direction = tipElement.ownerDocument.dir;
 
     while (!titleText && tipElement) {
       if (tipElement.nodeType == Node.ELEMENT_NODE)
         titleText = tipElement.getAttribute("title");
       tipElement = tipElement.parentNode;
diff --git a/browser/base/content/browser-thumbnails.js b/browser/base/content/browser-thumbnails.js
--- a/browser/base/content/browser-thumbnails.js
+++ b/browser/base/content/browser-thumbnails.js
@@ -25,59 +25,59 @@ let gBrowserThumbnails = {
    */
   _timeouts: null,
 
   /**
    * List of tab events we want to listen for.
    */
   _tabEvents: ["TabClose", "TabSelect"],
 
-  init: function Thumbnails_init() {
+  init: function() {
     PageThumbs.addExpirationFilter(this);
     gBrowser.addTabsProgressListener(this);
     Services.prefs.addObserver(this.PREF_DISK_CACHE_SSL, this, false);
 
     this._sslDiskCacheEnabled =
       Services.prefs.getBoolPref(this.PREF_DISK_CACHE_SSL);
 
     this._tabEvents.forEach(function (aEvent) {
       gBrowser.tabContainer.addEventListener(aEvent, this, false);
     }, this);
 
     this._timeouts = new WeakMap();
   },
 
-  uninit: function Thumbnails_uninit() {
+  uninit: function() {
     PageThumbs.removeExpirationFilter(this);
     gBrowser.removeTabsProgressListener(this);
     Services.prefs.removeObserver(this.PREF_DISK_CACHE_SSL, this);
 
     this._tabEvents.forEach(function (aEvent) {
       gBrowser.tabContainer.removeEventListener(aEvent, this, false);
     }, this);
   },
 
-  handleEvent: function Thumbnails_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "scroll":
         let browser = aEvent.currentTarget;
         if (this._timeouts.has(browser))
           this._delayedCapture(browser);
         break;
       case "TabSelect":
         this._delayedCapture(aEvent.target.linkedBrowser);
         break;
       case "TabClose": {
         this._clearTimeout(aEvent.target.linkedBrowser);
         break;
       }
     }
   },
 
-  observe: function Thumbnails_observe() {
+  observe: function() {
     this._sslDiskCacheEnabled =
       Services.prefs.getBoolPref(this.PREF_DISK_CACHE_SSL);
   },
 
   filterForThumbnailExpiration:
   function Thumbnails_filterForThumbnailExpiration(aCallback) {
     aCallback(this._topSiteURLs);
   },
@@ -87,58 +87,58 @@ let gBrowserThumbnails = {
    */
   onStateChange: function Thumbnails_onStateChange(aBrowser, aWebProgress,
                                                    aRequest, aStateFlags, aStatus) {
     if (aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
         aStateFlags & Ci.nsIWebProgressListener.STATE_IS_NETWORK)
       this._delayedCapture(aBrowser);
   },
 
-  _capture: function Thumbnails_capture(aBrowser) {
+  _capture: function(aBrowser) {
     // Only capture about:newtab top sites.
     if (this._topSiteURLs.indexOf(aBrowser.currentURI.spec) == -1)
       return;
     this._shouldCapture(aBrowser, function (aResult) {
       if (aResult) {
         PageThumbs.captureAndStoreIfStale(aBrowser);
       }
     });
   },
 
-  _delayedCapture: function Thumbnails_delayedCapture(aBrowser) {
+  _delayedCapture: function(aBrowser) {
     if (this._timeouts.has(aBrowser))
       clearTimeout(this._timeouts.get(aBrowser));
     else
       aBrowser.addEventListener("scroll", this, true);
 
     let timeout = setTimeout(function () {
       this._clearTimeout(aBrowser);
       this._capture(aBrowser);
     }.bind(this), this._captureDelayMS);
 
     this._timeouts.set(aBrowser, timeout);
   },
 
-  _shouldCapture: function Thumbnails_shouldCapture(aBrowser, aCallback) {
+  _shouldCapture: function(aBrowser, aCallback) {
     // Capture only if it's the currently selected tab.
     if (aBrowser != gBrowser.selectedBrowser) {
       aCallback(false);
       return;
     }
     PageThumbs.shouldStoreThumbnail(aBrowser, aCallback);
   },
 
   get _topSiteURLs() {
     return NewTabUtils.links.getLinks().reduce((urls, link) => {
       if (link)
         urls.push(link.url);
       return urls;
     }, []);
   },
 
-  _clearTimeout: function Thumbnails_clearTimeout(aBrowser) {
+  _clearTimeout: function(aBrowser) {
     if (this._timeouts.has(aBrowser)) {
       aBrowser.removeEventListener("scroll", this, false);
       clearTimeout(this._timeouts.get(aBrowser));
       this._timeouts.delete(aBrowser);
     }
   }
 };
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -3347,17 +3347,17 @@ const BrowserSearch = {
       searchBar.removeAttribute("addengines");
   },
 
   /**
    * Gives focus to the search bar, if it is present on the toolbar, or loads
    * the default engine's search form otherwise. For Mac, opens a new window
    * or focuses an existing window, if necessary.
    */
-  webSearch: function BrowserSearch_webSearch() {
+  webSearch: function() {
 #ifdef XP_MACOSX
     if (window.location.href != getBrowserURL()) {
       var win = getTopWin();
       if (win) {
         // If there's an open browser window, it should handle this command
         win.focus();
         win.BrowserSearch.webSearch();
       } else {
@@ -3467,17 +3467,17 @@ const BrowserSearch = {
   },
 
   /**
    * Just like _loadSearch, but preserving an old API.
    *
    * @return string Name of the search engine used to perform a search or null
    *         if a search was not performed.
    */
-  loadSearch: function BrowserSearch_search(searchText, useNewTab, purpose) {
+  loadSearch: function(searchText, useNewTab, purpose) {
     let engine = BrowserSearch._loadSearch(searchText, useNewTab, purpose);
     if (!engine) {
       return null;
     }
     return engine.name;
   },
 
   /**
@@ -3495,17 +3495,17 @@ const BrowserSearch = {
 
   /**
    * Returns the search bar element if it is present in the toolbar, null otherwise.
    */
   get searchBar() {
     return document.getElementById("searchbar");
   },
 
-  loadAddEngines: function BrowserSearch_loadAddEngines() {
+  loadAddEngines: function() {
     var newWindowPref = gPrefService.getIntPref("browser.link.open_newwindow");
     var where = newWindowPref == 3 ? "tab" : "window";
     var searchEnginesURL = formatURL("browser.search.searchEnginesURL", true);
     openUILinkIn(searchEnginesURL, where);
   },
 
   /**
    * Helper to record a search with Firefox Health Report.
@@ -4304,17 +4304,17 @@ var XULBrowserWindow = {
 
     try {
       uri = Services.uriFixup.createExposableURI(uri);
     } catch (e) {}
     gIdentityHandler.checkIdentity(this._state, uri);
   },
 
   // simulate all change notifications after switching tabs
-  onUpdateCurrentBrowser: function XWB_onUpdateCurrentBrowser(aStateFlags, aStatus, aMessage, aTotalProgress) {
+  onUpdateCurrentBrowser: function(aStateFlags, aStatus, aMessage, aTotalProgress) {
     if (FullZoom.updateBackgroundTabs)
       FullZoom.onLocationChange(gBrowser.currentURI, true);
     var nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
     var loadingDone = aStateFlags & nsIWebProgressListener.STATE_STOP;
     // use a pseudo-object instead of a (potentially nonexistent) channel for getting
     // a correct error message - and make sure that the UI is always either in
     // loading (STATE_START) or done (STATE_STOP) mode
     this.onStateChange(
@@ -4695,17 +4695,17 @@ nsBrowserAccess.prototype = {
           gBrowser.loadURIWithFlags(aURI.spec, loadflags, referrer, null, null);
         }
         if (!gPrefService.getBoolPref("browser.tabs.loadDivertedInBackground"))
           window.focus();
     }
     return newWindow;
   },
 
-  openURIInFrame: function browser_openURIInFrame(aURI, aParams, aWhere, aContext) {
+  openURIInFrame: function(aURI, aParams, aWhere, aContext) {
     if (aWhere != Ci.nsIBrowserDOMWindow.OPEN_NEWTAB) {
       dump("Error: openURIInFrame can only open in new tabs");
       return null;
     }
 
     var isExternal = (aContext == Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
     let browser = this._openURIInNewTab(aURI, aParams.referrer, aParams.isPrivate, isExternal);
     if (browser)
@@ -4904,17 +4904,17 @@ var TabsInTitlebar = {
       if (!(condition in this._disallowed)) {
         this._disallowed[condition] = null;
         this._update(true);
       }
     }
 #endif
   },
 
-  updateAppearance: function updateAppearance(aForce) {
+  updateAppearance: function(aForce) {
 #ifdef CAN_DRAW_IN_TITLEBAR
     this._update(aForce);
 #endif
   },
 
   get enabled() {
     return document.documentElement.getAttribute("tabsintitlebar") == "true";
   },
@@ -7187,17 +7187,17 @@ function getTabModalPromptBox(aWindow) {
   return null;
 };
 
 /* DEPRECATED */
 function getBrowser() gBrowser;
 function getNavToolbox() gNavToolbox;
 
 let gPrivateBrowsingUI = {
-  init: function PBUI_init() {
+  init: function() {
     // Do nothing for normal windows
     if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
       return;
     }
 
     // Disable the Clear Recent History... menu item when in PB mode
     // temporary fix until bug 463607 is fixed
     document.getElementById("Tools:Sanitize").setAttribute("disabled", "true");
@@ -7402,17 +7402,17 @@ let RestoreLastSessionObserver = {
 };
 
 function restoreLastSession() {
   SessionStore.restoreLastSession();
 }
 
 var TabContextMenu = {
   contextTab: null,
-  updateContextMenu: function updateContextMenu(aPopupMenu) {
+  updateContextMenu: function(aPopupMenu) {
     this.contextTab = aPopupMenu.triggerNode.localName == "tab" ?
                       aPopupMenu.triggerNode : gBrowser.selectedTab;
     let disabled = gBrowser.tabs.length == 1;
 
     var menuItems = aPopupMenu.getElementsByAttribute("tbattr", "tabbrowser-multiple");
     for (let menuItem of menuItems)
       menuItem.disabled = disabled;
 
@@ -7462,17 +7462,17 @@ var TabContextMenu = {
 
 XPCOMUtils.defineLazyModuleGetter(this, "gDevTools",
                                   "resource:///modules/devtools/gDevTools.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "gDevToolsBrowser",
                                   "resource:///modules/devtools/gDevTools.jsm");
 
 Object.defineProperty(this, "HUDService", {
-  get: function HUDService_getter() {
+  get: function() {
     let devtools = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools;
     return devtools.require("devtools/webconsole/hudservice");
   },
   configurable: true,
   enumerable: true
 });
 
 // Prompt user to restart the browser in safe mode
@@ -7503,29 +7503,29 @@ function duplicateTabIn(aTab, where, del
       break;
     case "tab":
       gBrowser.selectedTab = newTab;
       break;
   }
 }
 
 var Scratchpad = {
-  openScratchpad: function SP_openScratchpad() {
+  openScratchpad: function() {
     return this.ScratchpadManager.openScratchpad();
   }
 };
 
 XPCOMUtils.defineLazyGetter(Scratchpad, "ScratchpadManager", function() {
   let tmp = {};
   Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", tmp);
   return tmp.ScratchpadManager;
 });
 
 var ResponsiveUI = {
-  toggle: function RUI_toggle() {
+  toggle: function() {
     this.ResponsiveUIManager.toggle(window, gBrowser.selectedTab);
   }
 };
 
 XPCOMUtils.defineLazyGetter(ResponsiveUI, "ResponsiveUIManager", function() {
   let tmp = {};
   Cu.import("resource:///modules/devtools/responsivedesign.jsm", tmp);
   return tmp.ResponsiveUIManager;
diff --git a/browser/base/content/chatWindow.xul b/browser/base/content/chatWindow.xul
--- a/browser/base/content/chatWindow.xul
+++ b/browser/base/content/chatWindow.xul
@@ -118,17 +118,17 @@ chatBrowserAccess.prototype = {
     return browser;
   },
 
   openURI: function (aURI, aOpener, aWhere, aContext) {
     let browser = this._openURIInNewTab(aURI, aWhere);
     return browser ? browser.contentWindow : null;
   },
 
-  openURIInFrame: function browser_openURIInFrame(aURI, aParams, aWhere, aContext) {
+  openURIInFrame: function(aURI, aParams, aWhere, aContext) {
     let browser = this._openURIInNewTab(aURI, aWhere);
     return browser ? browser.QueryInterface(Ci.nsIFrameLoaderOwner) : null;
   },
 
   isTabContentWindow: function (aWindow) this.contentWindow == aWindow,
 };
 
 </script>
diff --git a/browser/base/content/content.js b/browser/base/content/content.js
--- a/browser/base/content/content.js
+++ b/browser/base/content/content.js
@@ -620,17 +620,17 @@ ContentSearchMediator.init(this);
 // Lazily load the finder code
 addMessageListener("Finder:Initialize", function () {
   let {RemoteFinderListener} = Cu.import("resource://gre/modules/RemoteFinder.jsm", {});
   new RemoteFinderListener(global);
 });
 
 
 let ClickEventHandler = {
-  init: function init() {
+  init: function() {
     Cc["@mozilla.org/eventlistenerservice;1"]
       .getService(Ci.nsIEventListenerService)
       .addSystemEventListener(global, "click", this, true);
   },
 
   handleEvent: function(event) {
     if (!event.isTrusted || event.defaultPrevented || event.button == 2) {
       return;
diff --git a/browser/base/content/newtab/cells.js b/browser/base/content/newtab/cells.js
--- a/browser/base/content/newtab/cells.js
+++ b/browser/base/content/newtab/cells.js
@@ -76,33 +76,33 @@ Cell.prototype = {
     let firstChild = this.node.firstElementChild;
     return firstChild && firstChild._newtabSite;
   },
 
   /**
    * Checks whether the cell contains a pinned site.
    * @return Whether the cell contains a pinned site.
    */
-  containsPinnedSite: function Cell_containsPinnedSite() {
+  containsPinnedSite: function() {
     let site = this.site;
     return site && site.isPinned();
   },
 
   /**
    * Checks whether the cell contains a site (is empty).
    * @return Whether the cell is empty.
    */
-  isEmpty: function Cell_isEmpty() {
+  isEmpty: function() {
     return !this.site;
   },
 
   /**
    * Handles all cell events.
    */
-  handleEvent: function Cell_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     // We're not responding to external drag/drop events
     // when our parent window is in private browsing mode.
     if (inPrivateBrowsingMode() && !gDrag.draggedSite)
       return;
 
     if (aEvent.type != "dragexit" && !gDrag.isValid(aEvent))
       return;
 
diff --git a/browser/base/content/newtab/drag.js b/browser/base/content/newtab/drag.js
--- a/browser/base/content/newtab/drag.js
+++ b/browser/base/content/newtab/drag.js
@@ -28,17 +28,17 @@ let gDrag = {
   get cellWidth() { return this._cellWidth; },
   get cellHeight() { return this._cellHeight; },
 
   /**
    * Start a new drag operation.
    * @param aSite The site that's being dragged.
    * @param aEvent The 'dragstart' event.
    */
-  start: function Drag_start(aSite, aEvent) {
+  start: function(aSite, aEvent) {
     this._draggedSite = aSite;
 
     // Mark nodes as being dragged.
     let selector = ".newtab-site, .newtab-control, .newtab-thumbnail";
     let parentCell = aSite.node.parentNode;
     let nodes = parentCell.querySelectorAll(selector);
     for (let i = 0; i < nodes.length; i++)
       nodes[i].setAttribute("dragged", "true");
@@ -61,17 +61,17 @@ let gDrag = {
     gTransformation.freezeSitePosition(aSite);
   },
 
   /**
    * Handles the 'drag' event.
    * @param aSite The site that's being dragged.
    * @param aEvent The 'drag' event.
    */
-  drag: function Drag_drag(aSite, aEvent) {
+  drag: function(aSite, aEvent) {
     // Get the viewport size.
     let {clientWidth, clientHeight} = document.documentElement;
 
     // We'll want a padding of 5px.
     let border = 5;
 
     // Enforce minimum constraints to keep the drag image inside the window.
     let left = Math.max(scrollX + aEvent.clientX - this._offsetX, border);
@@ -85,33 +85,33 @@ let gDrag = {
     gTransformation.setSitePosition(aSite, {left: left, top: top});
   },
 
   /**
    * Ends the current drag operation.
    * @param aSite The site that's being dragged.
    * @param aEvent The 'dragend' event.
    */
-  end: function Drag_end(aSite, aEvent) {
+  end: function(aSite, aEvent) {
     let nodes = gGrid.node.querySelectorAll("[dragged]")
     for (let i = 0; i < nodes.length; i++)
       nodes[i].removeAttribute("dragged");
 
     // Slide the dragged site back into its cell (may be the old or the new cell).
     gTransformation.slideSiteTo(aSite, aSite.cell, {unfreeze: true});
 
     this._draggedSite = null;
   },
 
   /**
    * Checks whether we're responsible for a given drag event.
    * @param aEvent The drag event to check.
    * @return Whether we should handle this drag and drop operation.
    */
-  isValid: function Drag_isValid(aEvent) {
+  isValid: function(aEvent) {
     let link = gDragDataHelper.getLinkFromDragEvent(aEvent);
 
     // Check that the drag data is non-empty.
     // Can happen when dragging places folders.
     if (!link || !link.url) {
       return false;
     }
 
@@ -120,17 +120,17 @@ let gDrag = {
     return gLinkChecker.checkLoadURI(link.url);
   },
 
   /**
    * Initializes the drag data for the current drag operation.
    * @param aSite The site that's being dragged.
    * @param aEvent The 'dragstart' event.
    */
-  _setDragData: function Drag_setDragData(aSite, aEvent) {
+  _setDragData: function(aSite, aEvent) {
     let {url, title} = aSite;
 
     let dt = aEvent.dataTransfer;
     dt.mozCursor = "default";
     dt.effectAllowed = "move";
     dt.setData("text/plain", url);
     dt.setData("text/uri-list", url);
     dt.setData("text/x-moz-url", url + "\n" + title);
diff --git a/browser/base/content/newtab/dragDataHelper.js b/browser/base/content/newtab/dragDataHelper.js
--- a/browser/base/content/newtab/dragDataHelper.js
+++ b/browser/base/content/newtab/dragDataHelper.js
@@ -4,17 +4,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 #endif
 
 let gDragDataHelper = {
   get mimeType() {
     return "text/x-moz-url";
   },
 
-  getLinkFromDragEvent: function DragDataHelper_getLinkFromDragEvent(aEvent) {
+  getLinkFromDragEvent: function(aEvent) {
     let dt = aEvent.dataTransfer;
     if (!dt || !dt.types.contains(this.mimeType)) {
       return null;
     }
 
     let data = dt.getData(this.mimeType) || "";
     let [url, title] = data.split(/[\r\n]+/);
     return {url: url, title: title};
diff --git a/browser/base/content/newtab/drop.js b/browser/base/content/newtab/drop.js
--- a/browser/base/content/newtab/drop.js
+++ b/browser/base/content/newtab/drop.js
@@ -16,41 +16,41 @@ let gDrop = {
    * The last drop target.
    */
   _lastDropTarget: null,
 
   /**
    * Handles the 'dragenter' event.
    * @param aCell The drop target cell.
    */
-  enter: function Drop_enter(aCell) {
+  enter: function(aCell) {
     this._delayedRearrange(aCell);
   },
 
   /**
    * Handles the 'dragexit' event.
    * @param aCell The drop target cell.
    * @param aEvent The 'dragexit' event.
    */
-  exit: function Drop_exit(aCell, aEvent) {
+  exit: function(aCell, aEvent) {
     if (aEvent.dataTransfer && !aEvent.dataTransfer.mozUserCancelled) {
       this._delayedRearrange();
     } else {
       // The drag operation has been cancelled.
       this._cancelDelayedArrange();
       this._rearrange();
     }
   },
 
   /**
    * Handles the 'drop' event.
    * @param aCell The drop target cell.
    * @param aEvent The 'dragexit' event.
    */
-  drop: function Drop_drop(aCell, aEvent) {
+  drop: function(aCell, aEvent) {
     // The cell that is the drop target could contain a pinned site. We need
     // to find out where that site has gone and re-pin it there.
     if (aCell.containsPinnedSite())
       this._repinSitesAfterDrop(aCell);
 
     // Pin the dragged or insert the new site.
     this._pinDraggedSite(aCell, aEvent);
 
@@ -59,34 +59,34 @@ let gDrop = {
     // Update the grid and move all sites to their new places.
     gUpdater.updateGrid();
   },
 
   /**
    * Re-pins all pinned sites in their (new) positions.
    * @param aCell The drop target cell.
    */
-  _repinSitesAfterDrop: function Drop_repinSitesAfterDrop(aCell) {
+  _repinSitesAfterDrop: function(aCell) {
     let sites = gDropPreview.rearrange(aCell);
 
     // Filter out pinned sites.
     let pinnedSites = sites.filter(function (aSite) {
       return aSite && aSite.isPinned();
     });
 
     // Re-pin all shifted pinned cells.
     pinnedSites.forEach(aSite => aSite.pin(sites.indexOf(aSite)));
   },
 
   /**
    * Pins the dragged site in its new place.
    * @param aCell The drop target cell.
    * @param aEvent The 'dragexit' event.
    */
-  _pinDraggedSite: function Drop_pinDraggedSite(aCell, aEvent) {
+  _pinDraggedSite: function(aCell, aEvent) {
     let index = aCell.index;
     let draggedSite = gDrag.draggedSite;
 
     if (draggedSite) {
       // Pin the dragged site at its new place.
       if (aCell != draggedSite.cell)
         draggedSite.pin(index);
     } else {
@@ -100,17 +100,17 @@ let gDrop = {
       }
     }
   },
 
   /**
    * Time a rearrange with a little delay.
    * @param aCell The drop target cell.
    */
-  _delayedRearrange: function Drop_delayedRearrange(aCell) {
+  _delayedRearrange: function(aCell) {
     // The last drop target didn't change so there's no need to re-arrange.
     if (this._lastDropTarget == aCell)
       return;
 
     let self = this;
 
     function callback() {
       self._rearrangeTimeout = null;
@@ -122,28 +122,28 @@ let gDrop = {
 
     // Store the last drop target.
     this._lastDropTarget = aCell;
   },
 
   /**
    * Cancels a timed rearrange, if any.
    */
-  _cancelDelayedArrange: function Drop_cancelDelayedArrange() {
+  _cancelDelayedArrange: function() {
     if (this._rearrangeTimeout) {
       clearTimeout(this._rearrangeTimeout);
       this._rearrangeTimeout = null;
     }
   },
 
   /**
    * Rearrange all sites in the grid depending on the current drop target.
    * @param aCell The drop target cell.
    */
-  _rearrange: function Drop_rearrange(aCell) {
+  _rearrange: function(aCell) {
     let sites = gGrid.sites;
 
     // We need to rearrange the grid only if there's a current drop target.
     if (aCell)
       sites = gDropPreview.rearrange(aCell);
 
     gTransformation.rearrangeSites(sites, {unfreeze: !aCell});
   }
diff --git a/browser/base/content/newtab/dropPreview.js b/browser/base/content/newtab/dropPreview.js
--- a/browser/base/content/newtab/dropPreview.js
+++ b/browser/base/content/newtab/dropPreview.js
@@ -11,17 +11,17 @@
  */
 let gDropPreview = {
   /**
    * Rearranges the sites currently contained in the grid when a site would be
    * dropped onto the given cell.
    * @param aCell The drop target cell.
    * @return The re-arranged array of sites.
    */
-  rearrange: function DropPreview_rearrange(aCell) {
+  rearrange: function(aCell) {
     let sites = gGrid.sites;
 
     // Insert the dragged site into the current grid.
     this._insertDraggedSite(sites, aCell);
 
     // After the new site has been inserted we need to correct the positions
     // of all pinned tabs that have been moved around.
     this._repositionPinnedSites(sites, aCell);
@@ -29,17 +29,17 @@ let gDropPreview = {
     return sites;
   },
 
   /**
    * Inserts the currently dragged site into the given array of sites.
    * @param aSites The array of sites to insert into.
    * @param aCell The drop target cell.
    */
-  _insertDraggedSite: function DropPreview_insertDraggedSite(aSites, aCell) {
+  _insertDraggedSite: function(aSites, aCell) {
     let dropIndex = aCell.index;
     let draggedSite = gDrag.draggedSite;
 
     // We're currently dragging a site.
     if (draggedSite) {
       let dragCell = draggedSite.cell;
       let dragIndex = dragCell.index;
 
@@ -80,17 +80,17 @@ let gDropPreview = {
 
   /**
    * Filter pinned sites out of the grid that are still on their old positions
    * and have not moved.
    * @param aSites The array of sites to filter.
    * @param aCell The drop target cell.
    * @return The filtered array of sites.
    */
-  _filterPinnedSites: function DropPreview_filterPinnedSites(aSites, aCell) {
+  _filterPinnedSites: function(aSites, aCell) {
     let draggedSite = gDrag.draggedSite;
 
     // When dropping on a cell that contains a pinned site make sure that all
     // pinned cells surrounding the drop target are moved as well.
     let range = this._getPinnedRange(aCell);
 
     return aSites.filter(function (aSite, aIndex) {
       // The site must be valid, pinned and not the dragged site.
@@ -104,17 +104,17 @@ let gDropPreview = {
     });
   },
 
   /**
    * Determines the range of pinned sites surrounding the drop target cell.
    * @param aCell The drop target cell.
    * @return The range of pinned cells.
    */
-  _getPinnedRange: function DropPreview_getPinnedRange(aCell) {
+  _getPinnedRange: function(aCell) {
     let dropIndex = aCell.index;
     let range = {start: dropIndex, end: dropIndex};
 
     // We need a pinned range only when dropping on a pinned site.
     if (aCell.containsPinnedSite()) {
       let links = gPinnedLinks.links;
 
       // Find all previous siblings of the drop target that are pinned as well.
diff --git a/browser/base/content/newtab/dropTargetShim.js b/browser/base/content/newtab/dropTargetShim.js
--- a/browser/base/content/newtab/dropTargetShim.js
+++ b/browser/base/content/newtab/dropTargetShim.js
@@ -194,17 +194,17 @@ let gDropTargetShim = {
     // No drop target found.
     return null;
   },
 
   /**
    * Gets the positions of all cell nodes.
    * @return The (cached) cell positions.
    */
-  _getCellPositions: function DropTargetShim_getCellPositions() {
+  _getCellPositions: function() {
     if (this._cellPositions)
       return this._cellPositions;
 
     return this._cellPositions = gGrid.cells.map(function (cell) {
       return {cell: cell, rect: gTransformation.getNodePosition(cell.node)};
     });
   },
 
diff --git a/browser/base/content/newtab/grid.js b/browser/base/content/newtab/grid.js
--- a/browser/base/content/newtab/grid.js
+++ b/browser/base/content/newtab/grid.js
@@ -41,17 +41,17 @@ let gGrid = {
 
   // Returns whether the page has finished loading yet.
   get isDocumentLoaded() { return document.readyState == "complete"; },
 
   /**
    * Initializes the grid.
    * @param aSelector The query selector of the grid.
    */
-  init: function Grid_init() {
+  init: function() {
     this._node = document.getElementById("newtab-grid");
     this._createSiteFragment();
 
     gLinks.populateCache(() => {
       this.refresh();
       this._ready = true;
 
       // If fetching links took longer than loading the page itself then
@@ -70,45 +70,45 @@ let gGrid = {
   },
 
   /**
    * Creates a new site in the grid.
    * @param aLink The new site's link.
    * @param aCell The cell that will contain the new site.
    * @return The newly created site.
    */
-  createSite: function Grid_createSite(aLink, aCell) {
+  createSite: function(aLink, aCell) {
     let node = aCell.node;
     node.appendChild(this._siteFragment.cloneNode(true));
     return new Site(node.firstElementChild, aLink);
   },
 
   /**
    * Handles all grid events.
    */
-  handleEvent: function Grid_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "load":
       case "resize":
         this._resizeGrid();
         break;
     }
   },
 
   /**
    * Locks the grid to block all pointer events.
    */
-  lock: function Grid_lock() {
+  lock: function() {
     this.node.setAttribute("locked", "true");
   },
 
   /**
    * Unlocks the grid to allow all pointer events.
    */
-  unlock: function Grid_unlock() {
+  unlock: function() {
     this.node.removeAttribute("locked");
   },
 
   /**
    * Renders the grid, including cells and sites.
    */
   refresh() {
     let cell = document.createElementNS(HTML_NAMESPACE, "div");
@@ -138,26 +138,26 @@ let gGrid = {
     this._node.innerHTML = "";
     this._node.appendChild(fragment);
   },
 
   /**
    * Calculate the height for a number of rows up to the maximum rows
    * @param rows Number of rows defaulting to the max
    */
-  _computeHeight: function Grid_computeHeight(aRows) {
+  _computeHeight: function(aRows) {
     let {gridRows} = gGridPrefs;
     aRows = aRows === undefined ? gridRows : Math.min(gridRows, aRows);
     return aRows * this._cellHeight + GRID_BOTTOM_EXTRA;
   },
 
   /**
    * Creates the DOM fragment that is re-used when creating sites.
    */
-  _createSiteFragment: function Grid_createSiteFragment() {
+  _createSiteFragment: function() {
     let site = document.createElementNS(HTML_NAMESPACE, "div");
     site.classList.add("newtab-site");
     site.setAttribute("draggable", "true");
 
     // Create the site's inner HTML code.
     site.innerHTML =
       '<a class="newtab-link">' +
       '  <span class="newtab-thumbnail"/>' +
@@ -172,17 +172,17 @@ let gGrid = {
 
     this._siteFragment = document.createDocumentFragment();
     this._siteFragment.appendChild(site);
   },
 
   /**
    * Make sure the correct number of rows and columns are visible
    */
-  _resizeGrid: function Grid_resizeGrid() {
+  _resizeGrid: function() {
     // If we're somehow called before the page has finished loading,
     // let's bail out to avoid caching zero heights and widths.
     // We'll be called again when DOMContentLoaded fires.
     // Same goes for the grid if that's not ready yet.
     if (!this.isDocumentLoaded || !this._ready) {
       return;
     }
 
diff --git a/browser/base/content/newtab/page.js b/browser/base/content/newtab/page.js
--- a/browser/base/content/newtab/page.js
+++ b/browser/base/content/newtab/page.js
@@ -10,17 +10,17 @@ const SCHEDULE_UPDATE_TIMEOUT_MS = 1000;
 /**
  * This singleton represents the whole 'New Tab Page' and takes care of
  * initializing all its components.
  */
 let gPage = {
   /**
    * Initializes the page.
    */
-  init: function Page_init() {
+  init: function() {
     // Add ourselves to the list of pages to receive notifications.
     gAllPages.register(this);
 
     // Listen for 'unload' to unregister this page.
     addEventListener("unload", this, false);
 
     // XXX bug 991111 - Not all click events are correctly triggered when
     // listening from xhtml nodes -- in particular middle clicks on sites, so
@@ -39,17 +39,17 @@ let gPage = {
 
     // Initialize intro panel.
     gIntro.init();
   },
 
   /**
    * Listens for notifications specific to this page.
    */
-  observe: function Page_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (aTopic == "nsPref:changed") {
       gCustomize.updateSelected();
 
       let enabled = gAllPages.enabled;
       this._updateAttributes(enabled);
 
       // Update thumbnails to the new enhanced setting
       if (aData == "browser.newtabpage.enhanced") {
@@ -106,17 +106,17 @@ let gPage = {
       this._scheduleUpdateTimeout = null;
     }, SCHEDULE_UPDATE_TIMEOUT_MS);
   },
 
   /**
    * Internally initializes the page. This runs only when/if the feature
    * is/gets enabled.
    */
-  _init: function Page_init() {
+  _init: function() {
     if (this._initialized)
       return;
 
     this._initialized = true;
 
     // Initialize search.
     gSearch.init();
 
@@ -138,17 +138,17 @@ let gPage = {
     document.addEventListener("drop", this, false);
 #endif
   },
 
   /**
    * Updates the 'page-disabled' attributes of the respective DOM nodes.
    * @param aValue Whether the New Tab Page is enabled or not.
    */
-  _updateAttributes: function Page_updateAttributes(aValue) {
+  _updateAttributes: function(aValue) {
     // Set the nodes' states.
     let nodeSelector = "#newtab-scrollbox, #newtab-grid, #newtab-search-container";
     for (let node of document.querySelectorAll(nodeSelector)) {
       if (aValue)
         node.removeAttribute("page-disabled");
       else
         node.setAttribute("page-disabled", "true");
     }
@@ -161,17 +161,17 @@ let gPage = {
       else
         input.setAttribute("tabindex", "-1");
     }
   },
 
   /**
    * Handles all page events.
    */
-  handleEvent: function Page_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "load":
         this.onPageVisibleAndLoaded();
         break;
       case "unload":
         gAllPages.unregister(this);
         break;
       case "click":
diff --git a/browser/base/content/newtab/sites.js b/browser/base/content/newtab/sites.js
--- a/browser/base/content/newtab/sites.js
+++ b/browser/base/content/newtab/sites.js
@@ -46,61 +46,61 @@ Site.prototype = {
     let parentNode = this.node.parentNode;
     return parentNode && parentNode._newtabCell;
   },
 
   /**
    * Pins the site on its current or a given index.
    * @param aIndex The pinned index (optional).
    */
-  pin: function Site_pin(aIndex) {
+  pin: function(aIndex) {
     if (typeof aIndex == "undefined")
       aIndex = this.cell.index;
 
     this._updateAttributes(true);
     gPinnedLinks.pin(this._link, aIndex);
   },
 
   /**
    * Unpins the site and calls the given callback when done.
    */
-  unpin: function Site_unpin() {
+  unpin: function() {
     if (this.isPinned()) {
       this._updateAttributes(false);
       gPinnedLinks.unpin(this._link);
       gUpdater.updateGrid();
     }
   },
 
   /**
    * Checks whether this site is pinned.
    * @return Whether this site is pinned.
    */
-  isPinned: function Site_isPinned() {
+  isPinned: function() {
     return gPinnedLinks.isPinned(this._link);
   },
 
   /**
    * Blocks the site (removes it from the grid) and calls the given callback
    * when done.
    */
-  block: function Site_block() {
+  block: function() {
     if (!gBlockedLinks.isBlocked(this._link)) {
       gUndoDialog.show(this);
       gBlockedLinks.block(this._link);
       gUpdater.updateGrid();
     }
   },
 
   /**
    * Gets the DOM node specified by the given query selector.
    * @param aSelector The query selector.
    * @return The DOM node we found.
    */
-  _querySelector: function Site_querySelector(aSelector) {
+  _querySelector: function(aSelector) {
     return this.node.querySelector(aSelector);
   },
 
   /**
    * Updates attributes for all nodes which status depends on this site being
    * pinned or unpinned.
    * @param aPinned Whether this site is now pinned or unpinned.
    */
@@ -114,17 +114,17 @@ Site.prototype = {
       this.node.removeAttribute("pinned");
       control.setAttribute("title", newTabString("pin"));
     }
   },
 
   /**
    * Renders the site's data (fills the HTML fragment).
    */
-  _render: function Site_render() {
+  _render: function() {
     let enhanced = gAllPages.enhanced && DirectoryLinksProvider.getEnhancedLink(this.link);
     let url = this.url;
     let title = enhanced && enhanced.title || this.title || url;
     let tooltip = (title == url ? title : title + "\n" + url);
 
     let link = this._querySelector(".newtab-link");
     link.setAttribute("title", tooltip);
     link.setAttribute("href", url);
@@ -139,26 +139,26 @@ Site.prototype = {
     // but still display whatever thumbnail might be available now.
     this.refreshThumbnail();
   },
 
   /**
    * Captures the site's thumbnail in the background, but only if there's no
    * existing thumbnail and the page allows background captures.
    */
-  captureIfMissing: function Site_captureIfMissing() {
+  captureIfMissing: function() {
     if (!document.hidden && !this.link.imageURI) {
       BackgroundPageThumbs.captureIfMissing(this.url);
     }
   },
 
   /**
    * Refreshes the thumbnail for the site.
    */
-  refreshThumbnail: function Site_refreshThumbnail() {
+  refreshThumbnail: function() {
     // Only enhance tiles if that feature is turned on
     let link = gAllPages.enhanced && DirectoryLinksProvider.getEnhancedLink(this.link) ||
                this.link;
 
     let thumbnail = this._querySelector(".newtab-thumbnail");
     if (link.bgColor) {
       thumbnail.style.backgroundColor = link.bgColor;
     }
@@ -175,17 +175,17 @@ Site.prototype = {
         this.enhancedId = link.directoryId;
       }
     }
   },
 
   /**
    * Adds event handlers for the site and its buttons.
    */
-  _addEventHandlers: function Site_addEventHandlers() {
+  _addEventHandlers: function() {
     // Register drag-and-drop event handlers.
     this._node.addEventListener("dragstart", this, false);
     this._node.addEventListener("dragend", this, false);
     this._node.addEventListener("mouseover", this, false);
 
     // Specially treat the sponsored icon to prevent regular hover effects
     let sponsored = this._querySelector(".newtab-sponsored");
     sponsored.addEventListener("mouseover", () => {
@@ -194,26 +194,26 @@ Site.prototype = {
     sponsored.addEventListener("mouseout", () => {
       this.cell.node.removeAttribute("ignorehover");
     });
   },
 
   /**
    * Speculatively opens a connection to the current site.
    */
-  _speculativeConnect: function Site_speculativeConnect() {
+  _speculativeConnect: function() {
     let sc = Services.io.QueryInterface(Ci.nsISpeculativeConnect);
     let uri = Services.io.newURI(this.url, null, null);
     sc.speculativeConnect(uri, null);
   },
 
   /**
    * Record interaction with site using telemetry.
    */
-  _recordSiteClicked: function Site_recordSiteClicked(aIndex) {
+  _recordSiteClicked: function(aIndex) {
     if (Services.prefs.prefHasUserValue("browser.newtabpage.rows") ||
         Services.prefs.prefHasUserValue("browser.newtabpage.columns") ||
         aIndex > 8) {
       // We only want to get indices for the default configuration, everything
       // else goes in the same bucket.
       aIndex = 9;
     }
     Services.telemetry.getHistogramById("NEWTAB_PAGE_SITE_CLICKED")
@@ -242,17 +242,17 @@ Site.prototype = {
 
       button.setAttribute("active", "true");
     }
   },
 
   /**
    * Handles site click events.
    */
-  onClick: function Site_onClick(aEvent) {
+  onClick: function(aEvent) {
     let action;
     let pinned = this.isPinned();
     let tileIndex = this.cell.index;
     let {button, target} = aEvent;
 
     // Handle tile/thumbnail link click
     if (target.classList.contains("newtab-link") ||
         target.parentElement.classList.contains("newtab-link")) {
@@ -290,17 +290,17 @@ Site.prototype = {
 
     // Report all link click actions
     DirectoryLinksProvider.reportSitesAction(gGrid.sites, action, tileIndex);
   },
 
   /**
    * Handles all site events.
    */
-  handleEvent: function Site_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "mouseover":
         this._node.removeEventListener("mouseover", this, false);
         this._speculativeConnect();
         break;
       case "dragstart":
         gDrag.start(this, aEvent);
         break;
diff --git a/browser/base/content/newtab/transformations.js b/browser/base/content/newtab/transformations.js
--- a/browser/base/content/newtab/transformations.js
+++ b/browser/base/content/newtab/transformations.js
@@ -28,115 +28,115 @@ let gTransformation = {
     return widths;
   },
 
   /**
    * Gets a DOM node's position.
    * @param aNode The DOM node.
    * @return A Rect instance with the position.
    */
-  getNodePosition: function Transformation_getNodePosition(aNode) {
+  getNodePosition: function(aNode) {
     let {left, top, width, height} = aNode.getBoundingClientRect();
     return new Rect(left + scrollX, top + scrollY, width, height);
   },
 
   /**
    * Fades a given node from zero to full opacity.
    * @param aNode The node to fade.
    * @param aCallback The callback to call when finished.
    */
-  fadeNodeIn: function Transformation_fadeNodeIn(aNode, aCallback) {
+  fadeNodeIn: function(aNode, aCallback) {
     this._setNodeOpacity(aNode, 1, function () {
       // Clear the style property.
       aNode.style.opacity = "";
 
       if (aCallback)
         aCallback();
     });
   },
 
   /**
    * Fades a given node from full to zero opacity.
    * @param aNode The node to fade.
    * @param aCallback The callback to call when finished.
    */
-  fadeNodeOut: function Transformation_fadeNodeOut(aNode, aCallback) {
+  fadeNodeOut: function(aNode, aCallback) {
     this._setNodeOpacity(aNode, 0, aCallback);
   },
 
   /**
    * Fades a given site from zero to full opacity.
    * @param aSite The site to fade.
    * @param aCallback The callback to call when finished.
    */
-  showSite: function Transformation_showSite(aSite, aCallback) {
+  showSite: function(aSite, aCallback) {
     this.fadeNodeIn(aSite.node, aCallback);
   },
 
   /**
    * Fades a given site from full to zero opacity.
    * @param aSite The site to fade.
    * @param aCallback The callback to call when finished.
    */
-  hideSite: function Transformation_hideSite(aSite, aCallback) {
+  hideSite: function(aSite, aCallback) {
     this.fadeNodeOut(aSite.node, aCallback);
   },
 
   /**
    * Allows to set a site's position.
    * @param aSite The site to re-position.
    * @param aPosition The desired position for the given site.
    */
-  setSitePosition: function Transformation_setSitePosition(aSite, aPosition) {
+  setSitePosition: function(aSite, aPosition) {
     let style = aSite.node.style;
     let {top, left} = aPosition;
 
     style.top = top + "px";
     style.left = left + "px";
   },
 
   /**
    * Freezes a site in its current position by positioning it absolute.
    * @param aSite The site to freeze.
    */
-  freezeSitePosition: function Transformation_freezeSitePosition(aSite) {
+  freezeSitePosition: function(aSite) {
     if (this._isFrozen(aSite))
       return;
 
     let style = aSite.node.style;
     let comp = getComputedStyle(aSite.node, null);
     style.width = comp.getPropertyValue("width")
     style.height = comp.getPropertyValue("height");
 
     aSite.node.setAttribute("frozen", "true");
     this.setSitePosition(aSite, this.getNodePosition(aSite.node));
   },
 
   /**
    * Unfreezes a site by removing its absolute positioning.
    * @param aSite The site to unfreeze.
    */
-  unfreezeSitePosition: function Transformation_unfreezeSitePosition(aSite) {
+  unfreezeSitePosition: function(aSite) {
     if (!this._isFrozen(aSite))
       return;
 
     let style = aSite.node.style;
     style.left = style.top = style.width = style.height = "";
     aSite.node.removeAttribute("frozen");
   },
 
   /**
    * Slides the given site to the target node's position.
    * @param aSite The site to move.
    * @param aTarget The slide target.
    * @param aOptions Set of options (see below).
    *        unfreeze - unfreeze the site after sliding
    *        callback - the callback to call when finished
    */
-  slideSiteTo: function Transformation_slideSiteTo(aSite, aTarget, aOptions) {
+  slideSiteTo: function(aSite, aTarget, aOptions) {
     let currentPosition = this.getNodePosition(aSite.node);
     let targetPosition = this.getNodePosition(aTarget.node)
     let callback = aOptions && aOptions.callback;
 
     let self = this;
 
     function finish() {
       if (aOptions && aOptions.unfreeze)
@@ -163,17 +163,17 @@ let gTransformation = {
   /**
    * Rearranges a given array of sites and moves them to their new positions or
    * fades in/out new/removed sites.
    * @param aSites An array of sites to rearrange.
    * @param aOptions Set of options (see below).
    *        unfreeze - unfreeze the site after rearranging
    *        callback - the callback to call when finished
    */
-  rearrangeSites: function Transformation_rearrangeSites(aSites, aOptions) {
+  rearrangeSites: function(aSites, aOptions) {
     let batch = [];
     let cells = gGrid.cells;
     let callback = aOptions && aOptions.callback;
     let unfreeze = aOptions && aOptions.unfreeze;
 
     aSites.forEach(function (aSite, aIndex) {
       // Do not re-arrange empty cells or the dragged site.
       if (!aSite || aSite == gDrag.draggedSite)
@@ -217,17 +217,17 @@ let gTransformation = {
     });
   },
 
   /**
    * Gets a given node's opacity value.
    * @param aNode The node to get the opacity value from.
    * @return The node's opacity value.
    */
-  _getNodeOpacity: function Transformation_getNodeOpacity(aNode) {
+  _getNodeOpacity: function(aNode) {
     let cstyle = window.getComputedStyle(aNode, null);
     return cstyle.getPropertyValue("opacity");
   },
 
   /**
    * Sets a given node's opacity.
    * @param aNode The node to set the opacity value for.
    * @param aOpacity The opacity value to set.
@@ -249,22 +249,22 @@ let gTransformation = {
   },
 
   /**
    * Moves a site to the cell with the given index.
    * @param aSite The site to move.
    * @param aIndex The target cell's index.
    * @param aOptions Options that are directly passed to slideSiteTo().
    */
-  _moveSite: function Transformation_moveSite(aSite, aIndex, aOptions) {
+  _moveSite: function(aSite, aIndex, aOptions) {
     this.freezeSitePosition(aSite);
     this.slideSiteTo(aSite, gGrid.cells[aIndex], aOptions);
   },
 
   /**
    * Checks whether a site is currently frozen.
    * @param aSite The site to check.
    * @return Whether the given site is frozen.
    */
-  _isFrozen: function Transformation_isFrozen(aSite) {
+  _isFrozen: function(aSite) {
     return aSite.node.hasAttribute("frozen");
   }
 };
diff --git a/browser/base/content/newtab/undo.js b/browser/base/content/newtab/undo.js
--- a/browser/base/content/newtab/undo.js
+++ b/browser/base/content/newtab/undo.js
@@ -17,29 +17,29 @@ let gUndoDialog = {
   /**
    * Contains undo information.
    */
   _undoData: null,
 
   /**
    * Initializes the undo dialog.
    */
-  init: function UndoDialog_init() {
+  init: function() {
     this._undoContainer = document.getElementById("newtab-undo-container");
     this._undoContainer.addEventListener("click", this, false);
     this._undoButton = document.getElementById("newtab-undo-button");
     this._undoCloseButton = document.getElementById("newtab-undo-close-button");
     this._undoRestoreButton = document.getElementById("newtab-undo-restore-button");
   },
 
   /**
    * Shows the undo dialog.
    * @param aSite The site that just got removed.
    */
-  show: function UndoDialog_show(aSite) {
+  show: function(aSite) {
     if (this._undoData)
       clearTimeout(this._undoData.timeout);
 
     this._undoData = {
       index: aSite.cell.index,
       wasPinned: aSite.isPinned(),
       blockedLink: aSite.link,
       timeout: setTimeout(this.hide.bind(this), this.HIDE_TIMEOUT_MS)
@@ -49,50 +49,50 @@ let gUndoDialog = {
     this._undoButton.removeAttribute("tabindex");
     this._undoCloseButton.removeAttribute("tabindex");
     this._undoRestoreButton.removeAttribute("tabindex");
   },
 
   /**
    * Hides the undo dialog.
    */
-  hide: function UndoDialog_hide() {
+  hide: function() {
     if (!this._undoData)
       return;
 
     clearTimeout(this._undoData.timeout);
     this._undoData = null;
     this._undoContainer.setAttribute("undo-disabled", "true");
     this._undoButton.setAttribute("tabindex", "-1");
     this._undoCloseButton.setAttribute("tabindex", "-1");
     this._undoRestoreButton.setAttribute("tabindex", "-1");
   },
 
   /**
    * The undo dialog event handler.
    * @param aEvent The event to handle.
    */
-  handleEvent: function UndoDialog_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.target.id) {
       case "newtab-undo-button":
         this._undo();
         break;
       case "newtab-undo-restore-button":
         this._undoAll();
         break;
       case "newtab-undo-close-button":
         this.hide();
         break;
     }
   },
 
   /**
    * Undo the last blocked site.
    */
-  _undo: function UndoDialog_undo() {
+  _undo: function() {
     if (!this._undoData)
       return;
 
     let {index, wasPinned, blockedLink} = this._undoData;
     gBlockedLinks.unblock(blockedLink);
 
     if (wasPinned) {
       gPinnedLinks.pin(blockedLink, index);
@@ -100,17 +100,17 @@ let gUndoDialog = {
 
     gUpdater.updateGrid();
     this.hide();
   },
 
   /**
    * Undo all blocked sites.
    */
-  _undoAll: function UndoDialog_undoAll() {
+  _undoAll: function() {
     NewTabUtils.undoAll(function() {
       gUpdater.updateGrid();
       this.hide();
     }.bind(this));
   }
 };
 
 gUndoDialog.init();
diff --git a/browser/base/content/newtab/updater.js b/browser/base/content/newtab/updater.js
--- a/browser/base/content/newtab/updater.js
+++ b/browser/base/content/newtab/updater.js
@@ -9,17 +9,17 @@
  * set of pinned and blocked sites. It adds, moves and removes sites.
  */
 let gUpdater = {
   /**
    * Updates the current grid according to its pinned and blocked sites.
    * This removes old, moves existing and creates new sites to fill gaps.
    * @param aCallback The callback to call when finished.
    */
-  updateGrid: function Updater_updateGrid(aCallback) {
+  updateGrid: function(aCallback) {
     let links = gLinks.getLinks().slice(0, gGrid.cells.length);
 
     // Find all sites that remain in the grid.
     let sites = this._findRemainingSites(links);
 
     // Remove sites that are no longer in the grid.
     this._removeLegacySites(sites, () => {
       // Freeze all site positions so that we can move their DOM nodes around
@@ -45,17 +45,17 @@ let gUpdater = {
 
   /**
    * Takes an array of links and tries to correlate them to sites contained in
    * the current grid. If no corresponding site can be found (i.e. the link is
    * new and a site will be created) then just set it to null.
    * @param aLinks The array of links to find sites for.
    * @return Array of sites mapped to the given links (can contain null values).
    */
-  _findRemainingSites: function Updater_findRemainingSites(aLinks) {
+  _findRemainingSites: function(aLinks) {
     let map = {};
 
     // Create a map to easily retrieve the site for a given URL.
     gGrid.sites.forEach(function (aSite) {
       if (aSite)
         map[aSite.url] = aSite;
     });
 
@@ -64,28 +64,28 @@ let gUpdater = {
       return aLink && (aLink.url in map) && map[aLink.url];
     });
   },
 
   /**
    * Freezes the given sites' positions.
    * @param aSites The array of sites to freeze.
    */
-  _freezeSitePositions: function Updater_freezeSitePositions(aSites) {
+  _freezeSitePositions: function(aSites) {
     aSites.forEach(function (aSite) {
       if (aSite)
         gTransformation.freezeSitePosition(aSite);
     });
   },
 
   /**
    * Moves the given sites' DOM nodes to their new positions.
    * @param aSites The array of sites to move.
    */
-  _moveSiteNodes: function Updater_moveSiteNodes(aSites) {
+  _moveSiteNodes: function(aSites) {
     let cells = gGrid.cells;
 
     // Truncate the given array of sites to not have more sites than cells.
     // This can happen when the user drags a bookmark (or any other new kind
     // of link) onto the grid.
     let sites = aSites.slice(0, cells.length);
 
     sites.forEach(function (aSite, aIndex) {
@@ -107,28 +107,28 @@ let gUpdater = {
     }, this);
   },
 
   /**
    * Rearranges the given sites and slides them to their new positions.
    * @param aSites The array of sites to re-arrange.
    * @param aCallback The callback to call when finished.
    */
-  _rearrangeSites: function Updater_rearrangeSites(aSites, aCallback) {
+  _rearrangeSites: function(aSites, aCallback) {
     let options = {callback: aCallback, unfreeze: true};
     gTransformation.rearrangeSites(aSites, options);
   },
 
   /**
    * Removes all sites from the grid that are not in the given links array or
    * exceed the grid.
    * @param aSites The array of sites remaining in the grid.
    * @param aCallback The callback to call when finished.
    */
-  _removeLegacySites: function Updater_removeLegacySites(aSites, aCallback) {
+  _removeLegacySites: function(aSites, aCallback) {
     let batch = [];
 
     // Delete sites that were removed from the grid.
     gGrid.sites.forEach(function (aSite) {
       // The site must be valid and not in the current grid.
       if (!aSite || aSites.indexOf(aSite) != -1)
         return;
 
@@ -147,17 +147,17 @@ let gUpdater = {
     Promise.all(batch).then(aCallback);
   },
 
   /**
    * Tries to fill empty cells with new links if available.
    * @param aLinks The array of links.
    * @param aCallback The callback to call when finished.
    */
-  _fillEmptyCells: function Updater_fillEmptyCells(aLinks, aCallback) {
+  _fillEmptyCells: function(aLinks, aCallback) {
     let {cells, sites} = gGrid;
 
     // Find empty cells and fill them.
     Promise.all(sites.map((aSite, aIndex) => {
       if (aSite || !aLinks[aIndex])
         return null;
 
       return new Promise(resolve => {
diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -11,17 +11,17 @@ var gContextMenuContentData = null;
 
 function nsContextMenu(aXulMenu, aIsShift) {
   this.shouldDisplay = true;
   this.initMenu(aXulMenu, aIsShift);
 }
 
 // Prototype for nsContextMenu "class."
 nsContextMenu.prototype = {
-  initMenu: function CM_initMenu(aXulMenu, aIsShift) {
+  initMenu: function(aXulMenu, aIsShift) {
     // Get contextual info.
     this.setTarget(document.popupNode, document.popupRangeParent,
                    document.popupRangeOffset);
     if (!this.shouldDisplay)
       return;
 
     this.hasPageMenu = false;
     if (!aIsShift) {
@@ -47,47 +47,47 @@ nsContextMenu.prototype = {
 
     // Initialize (disable/remove) menu items.
     this.initItems();
 
     // Register this opening of the menu with telemetry:
     this._checkTelemetryForMenu(aXulMenu);
   },
 
-  hiding: function CM_hiding() {
+  hiding: function() {
     gContextMenuContentData = null;
     InlineSpellCheckerUI.clearSuggestionsFromMenu();
     InlineSpellCheckerUI.clearDictionaryListFromMenu();
     InlineSpellCheckerUI.uninit();
 
     // This handler self-deletes, only run it if it is still there:
     if (this._onPopupHiding) {
       this._onPopupHiding();
     }
   },
 
-  initItems: function CM_initItems() {
+  initItems: function() {
     this.initPageMenuSeparator();
     this.initOpenItems();
     this.initNavigationItems();
     this.initViewItems();
     this.initMiscItems();
     this.initSpellingItems();
     this.initSaveItems();
     this.initClipboardItems();
     this.initMediaPlayerItems();
     this.initLeaveDOMFullScreenItems();
     this.initClickToPlayItems();
   },
 
-  initPageMenuSeparator: function CM_initPageMenuSeparator() {
+  initPageMenuSeparator: function() {
     this.showItem("page-menu-separator", this.hasPageMenu);
   },
 
-  initOpenItems: function CM_initOpenItems() {
+  initOpenItems: function() {
     var isMailtoInternal = false;
     if (this.onMailtoLink) {
       var mailtoHandler = Cc["@mozilla.org/uriloader/external-protocol-service;1"].
                           getService(Ci.nsIExternalProtocolService).
                           getProtocolHandlerInfo("mailto");
       isMailtoInternal = (!mailtoHandler.alwaysAskBeforeHandling &&
                           mailtoHandler.preferredAction == Ci.nsIHandlerInfo.useHelperApp &&
                           (mailtoHandler.preferredApplicationHandler instanceof Ci.nsIWebHandlerApp));
@@ -159,17 +159,17 @@ nsContextMenu.prototype = {
     var isWindowPrivate = PrivateBrowsingUtils.isWindowPrivate(window);
     this.showItem("context-openlink", shouldShow && !isWindowPrivate);
     this.showItem("context-openlinkprivate", shouldShow);
     this.showItem("context-openlinkintab", shouldShow);
     this.showItem("context-openlinkincurrent", this.onPlainTextLink);
     this.showItem("context-sep-open", shouldShow);
   },
 
-  initNavigationItems: function CM_initNavigationItems() {
+  initNavigationItems: function() {
     var shouldShow = !(this.isContentSelected || this.onLink || this.onImage ||
                        this.onCanvas || this.onVideo || this.onAudio ||
                        this.onTextInput || this.onSocial);
     this.showItem("context-navigation", shouldShow);
     this.showItem("context-sep-navigation", shouldShow);
 
     let stopped = XULBrowserWindow.stopCommand.getAttribute("disabled") == "true";
 
@@ -180,27 +180,27 @@ nsContextMenu.prototype = {
 
     this.showItem("context-reload", stopReloadItem == "reload");
     this.showItem("context-stop", stopReloadItem == "stop");
 
     // XXX: Stop is determined in browser.js; the canStop broadcaster is broken
     //this.setItemAttrFromNode( "context-stop", "disabled", "canStop" );
   },
 
-  initLeaveDOMFullScreenItems: function CM_initLeaveFullScreenItem() {
+  initLeaveDOMFullScreenItems: function() {
     // only show the option if the user is in DOM fullscreen
     var shouldShow = (this.target.ownerDocument.mozFullScreenElement != null);
     this.showItem("context-leave-dom-fullscreen", shouldShow);
 
     // Explicitly show if in DOM fullscreen, but do not hide it has already been shown
     if (shouldShow)
         this.showItem("context-media-sep-commands", true);
   },
 
-  initSaveItems: function CM_initSaveItems() {
+  initSaveItems: function() {
     var shouldShow = !(this.onTextInput || this.onLink ||
                        this.isContentSelected || this.onImage ||
                        this.onCanvas || this.onVideo || this.onAudio);
     this.showItem("context-savepage", shouldShow);
 
     // Save link depends on whether we're in a link, or selected text matches valid URL pattern.
     this.showItem("context-savelink", this.onSaveableLink || this.onPlainTextLink);
 
@@ -224,17 +224,17 @@ nsContextMenu.prototype = {
     // so check SimpleServiceDiscovery.services first to avoid needing to load
     // CastingApps.jsm if we don't need to.
     let shouldShowCast = this.mediaURL &&
                          SimpleServiceDiscovery.services.length > 0 &&
                          CastingApps.getServicesForVideo(this.target).length > 0;
     this.setItemAttr("context-castvideo", "disabled", !shouldShowCast);
   },
 
-  initViewItems: function CM_initViewItems() {
+  initViewItems: function() {
     // View source is always OK, unless in directory listing.
     this.showItem("context-viewpartialsource-selection",
                   this.isContentSelected);
     this.showItem("context-viewpartialsource-mathml",
                   this.onMathML && !this.isContentSelected);
 
     var shouldShow = !(this.isContentSelected ||
                        this.onImage || this.onCanvas ||
@@ -287,17 +287,17 @@ nsContextMenu.prototype = {
                                              !this.inSyntheticDoc);
     document.getElementById("context-viewbgimage")
             .disabled = !this.hasBGImage;
 
     this.showItem("context-viewimageinfo", this.onImage);
     this.showItem("context-viewimagedesc", this.onImage && this.imageDescURL !== "");
   },
 
-  initMiscItems: function CM_initMiscItems() {
+  initMiscItems: function() {
     // Use "Bookmark This Link" if on a link.
     this.showItem("context-bookmarkpage",
                   !(this.isContentSelected || this.onTextInput || this.onLink ||
                     this.onImage || this.onVideo || this.onAudio || this.onSocial ||
                     this.onCanvas));
     this.showItem("context-bookmarklink", (this.onLink && !this.onMailtoLink &&
                                            !this.onSocial) || this.onPlainTextLink);
     this.showItem("context-keywordfield",
@@ -512,17 +512,17 @@ nsContextMenu.prototype = {
   },
 
   initClickToPlayItems: function() {
     this.showItem("context-ctp-play", this.onCTPPlugin);
     this.showItem("context-ctp-hide", this.onCTPPlugin);
     this.showItem("context-sep-ctp", this.onCTPPlugin);
   },
 
-  inspectNode: function CM_inspectNode() {
+  inspectNode: function() {
     let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
     let gBrowser = this.browser.ownerDocument.defaultView.gBrowser;
     let tt = devtools.TargetFactory.forTab(gBrowser.selectedTab);
     return gDevTools.showToolbox(tt, "inspector").then(function(toolbox) {
       let inspector = toolbox.getCurrentPanel();
       if (this.isRemote) {
         this.browser.messageManager.sendAsyncMessage("debug:inspect", {}, {node: this.target});
         inspector.walker.findInspectingNode().then(nodeFront => {
@@ -1162,17 +1162,17 @@ nsContextMenu.prototype = {
     // an object to proxy the data through to
     // nsIExternalHelperAppService.doContent, which will wait for the
     // appropriate MIME-type headers and then prompt the user with a
     // file picker
     function saveAsListener() {}
     saveAsListener.prototype = {
       extListener: null, 
 
-      onStartRequest: function saveLinkAs_onStartRequest(aRequest, aContext) {
+      onStartRequest: function(aRequest, aContext) {
 
         // if the timer fired, the error status will have been caused by that,
         // and we'll be restarting in onStopRequest, so no reason to notify
         // the user
         if (aRequest.status == NS_ERROR_SAVE_LINK_AS_TIMEOUT)
           return;
 
         timer.cancel();
@@ -1222,17 +1222,17 @@ nsContextMenu.prototype = {
                                                            aOffset, aCount) {
         this.extListener.onDataAvailable(aRequest, aContext, aInputStream,
                                          aOffset, aCount);
       }
     }
 
     function callbacks() {}
     callbacks.prototype = {
-      getInterface: function sLA_callbacks_getInterface(aIID) {
+      getInterface: function(aIID) {
         if (aIID.equals(Ci.nsIAuthPrompt) || aIID.equals(Ci.nsIAuthPrompt2)) {
           // If the channel demands authentication prompt, we must cancel it
           // because the save-as-timer would expire and cancel the channel
           // before we get credentials from user.  Both authentication dialog
           // and save as dialog would appear on the screen as we fall back to
           // the old fashioned way after the timeout.
           timer.cancel();
           channel.cancel(NS_ERROR_SAVE_LINK_AS_TIMEOUT);
@@ -1241,17 +1241,17 @@ nsContextMenu.prototype = {
       } 
     }
 
     // if it we don't have the headers after a short time, the user 
     // won't have received any feedback from their click.  that's bad.  so
     // we give up waiting for the filename. 
     function timerCallback() {}
     timerCallback.prototype = {
-      notify: function sLA_timer_notify(aTimer) {
+      notify: function(aTimer) {
         channel.cancel(NS_ERROR_SAVE_LINK_AS_TIMEOUT);
         return;
       }
     }
 
     // set up a channel to do the saving
     var ioService = Cc["@mozilla.org/network/io-service;1"].
                     getService(Ci.nsIIOService);
@@ -1583,32 +1583,32 @@ nsContextMenu.prototype = {
     uri = uri.replace(/%LOCALE%/, escape(locale)).replace(/%VERSION%/, version);
 
     var newWindowPref = gPrefService.getIntPref("browser.link.open_newwindow");
     var where = newWindowPref == 3 ? "tab" : "window";
 
     openUILinkIn(uri, where);
   },
 
-  bookmarkThisPage: function CM_bookmarkThisPage() {
+  bookmarkThisPage: function() {
     window.top.PlacesCommandHook.bookmarkPage(this.browser, PlacesUtils.bookmarksMenuFolderId, true);
   },
 
-  bookmarkLink: function CM_bookmarkLink() {
+  bookmarkLink: function() {
     var linkText;
     // If selected text is found to match valid URL pattern.
     if (this.onPlainTextLink)
       linkText = this.focusedWindow.getSelection().toString().trim();
     else
       linkText = this.linkText();
     window.top.PlacesCommandHook.bookmarkLink(PlacesUtils.bookmarksMenuFolderId, this.linkURL,
                                               linkText);
   },
 
-  addBookmarkForFrame: function CM_addBookmarkForFrame() {
+  addBookmarkForFrame: function() {
     var doc = this.target.ownerDocument;
     var uri = doc.documentURIObject;
 
     var itemId = PlacesUtils.getMostRecentBookmarkForURI(uri);
     if (itemId == -1) {
       var title = doc.title;
       var description = PlacesUIUtils.getDescriptionFromDocument(doc);
       PlacesUIUtils.showBookmarkDialog({ action: "add"
@@ -1624,49 +1624,49 @@ nsContextMenu.prototype = {
     }
     else {
       PlacesUIUtils.showBookmarkDialog({ action: "edit"
                                        , type: "bookmark"
                                        , itemId: itemId
                                        }, window.top);
     }
   },
-  markLink: function CM_markLink(origin) {
+  markLink: function(origin) {
     // send link to social, if it is the page url linkURI will be null
     SocialMarks.markLink(origin, this.linkURI ? this.linkURI.spec : null, this.target);
   },
-  shareLink: function CM_shareLink() {
+  shareLink: function() {
     SocialShare.sharePage(null, { url: this.linkURI.spec }, this.target);
   },
 
-  shareImage: function CM_shareImage() {
+  shareImage: function() {
     SocialShare.sharePage(null, { url: this.imageURL, previews: [ this.mediaURL ] }, this.target);
   },
 
-  shareVideo: function CM_shareVideo() {
+  shareVideo: function() {
     SocialShare.sharePage(null, { url: this.mediaURL, source: this.mediaURL }, this.target);
   },
 
-  shareSelect: function CM_shareSelect(selection) {
+  shareSelect: function(selection) {
     SocialShare.sharePage(null, { url: this.browser.currentURI.spec, text: selection }, this.target);
   },
 
-  savePageAs: function CM_savePageAs() {
+  savePageAs: function() {
     saveDocument(this.browser.contentDocumentAsCPOW);
   },
 
-  printFrame: function CM_printFrame() {
+  printFrame: function() {
     PrintUtils.print(this.target.ownerDocument.defaultView);
   },
 
-  switchPageDirection: function CM_switchPageDirection() {
+  switchPageDirection: function() {
     SwitchDocumentDirection(this.browser.contentWindowAsCPOW);
   },
 
-  mediaCommand : function CM_mediaCommand(command, data) {
+  mediaCommand : function(command, data) {
     let mm = this.browser.messageManager;
     mm.sendAsyncMessage("ContextMenu:MediaCommand",
                         {command: command, data: data},
                         {element: this.target});
   },
 
   copyMediaLocation : function () {
     var clipboard = Cc["@mozilla.org/widget/clipboardhelper;1"].
diff --git a/browser/base/content/sync/addDevice.js b/browser/base/content/sync/addDevice.js
--- a/browser/base/content/sync/addDevice.js
+++ b/browser/base/content/sync/addDevice.js
@@ -12,34 +12,34 @@ Cu.import("resource://gre/modules/XPCOMU
 const PIN_PART_LENGTH = 4;
 
 const ADD_DEVICE_PAGE       = 0;
 const SYNC_KEY_PAGE         = 1;
 const DEVICE_CONNECTED_PAGE = 2;
 
 let gSyncAddDevice = {
 
-  init: function init() {
+  init: function() {
     this.pin1.setAttribute("maxlength", PIN_PART_LENGTH);
     this.pin2.setAttribute("maxlength", PIN_PART_LENGTH);
     this.pin3.setAttribute("maxlength", PIN_PART_LENGTH);
 
     this.nextFocusEl = {pin1: this.pin2,
                         pin2: this.pin3,
                         pin3: this.wizard.getButton("next")};
 
     this.throbber = document.getElementById("pairDeviceThrobber");
     this.errorRow = document.getElementById("errorRow");
 
     // Kick off a sync. That way the server will have the most recent data from
     // this computer and it will show up immediately on the new device.
     Weave.Service.scheduler.scheduleNextSync(0);
   },
 
-  onPageShow: function onPageShow() {
+  onPageShow: function() {
     this.wizard.getButton("back").hidden = true;
 
     switch (this.wizard.pageIndex) {
       case ADD_DEVICE_PAGE:
         this.onTextBoxInput();
         this.wizard.canRewind = false;
         this.wizard.getButton("next").hidden = false;
         this.pin1.focus();
@@ -55,51 +55,51 @@ let gSyncAddDevice = {
       case DEVICE_CONNECTED_PAGE:
         this.wizard.canAdvance = true;
         this.wizard.canRewind = false;
         this.wizard.getButton("cancel").hidden = true;
         break;
     }
   },
 
-  onWizardAdvance: function onWizardAdvance() {
+  onWizardAdvance: function() {
     switch (this.wizard.pageIndex) {
       case ADD_DEVICE_PAGE:
         this.startTransfer();
         return false;
       case DEVICE_CONNECTED_PAGE:
         window.close();
         return false;
     }
     return true;
   },
 
-  startTransfer: function startTransfer() {
+  startTransfer: function() {
     this.errorRow.hidden = true;
     // When onAbort is called, Weave may already be gone.
     const JPAKE_ERROR_USERABORT = Weave.JPAKE_ERROR_USERABORT;
 
     let self = this;
     let jpakeclient = this._jpakeclient = new Weave.JPAKEClient({
-      onPaired: function onPaired() {
+      onPaired: function() {
         let credentials = {account:   Weave.Service.identity.account,
                            password:  Weave.Service.identity.basicPassword,
                            synckey:   Weave.Service.identity.syncKey,
                            serverURL: Weave.Service.serverURL};
         jpakeclient.sendAndComplete(credentials);
       },
-      onComplete: function onComplete() {
+      onComplete: function() {
         delete self._jpakeclient;
         self.wizard.pageIndex = DEVICE_CONNECTED_PAGE;
 
         // Schedule a Sync for soonish to fetch the data uploaded by the
         // device with which we just paired.
         Weave.Service.scheduler.scheduleNextSync(Weave.Service.scheduler.activeInterval);
       },
-      onAbort: function onAbort(error) {
+      onAbort: function(error) {
         delete self._jpakeclient;
 
         // Aborted by user, ignore.
         if (error == JPAKE_ERROR_USERABORT) {
           return;
         }
 
         self.errorRow.hidden = false;
@@ -113,42 +113,42 @@ let gSyncAddDevice = {
     this.pin1.disabled = this.pin2.disabled = this.pin3.disabled = true;
     this.wizard.canAdvance = false;
 
     let pin = this.pin1.value + this.pin2.value + this.pin3.value;
     let expectDelay = false;
     jpakeclient.pairWithPIN(pin, expectDelay);
   },
 
-  onWizardBack: function onWizardBack() {
+  onWizardBack: function() {
     if (this.wizard.pageIndex != SYNC_KEY_PAGE)
       return true;
 
     this.wizard.pageIndex = ADD_DEVICE_PAGE;
     return false;
   },
 
-  onWizardCancel: function onWizardCancel() {
+  onWizardCancel: function() {
     if (this._jpakeclient) {
       this._jpakeclient.abort();
       delete this._jpakeclient;
     }
     return true;
   },
 
-  onTextBoxInput: function onTextBoxInput(textbox) {
+  onTextBoxInput: function(textbox) {
     if (textbox && textbox.value.length == PIN_PART_LENGTH)
       this.nextFocusEl[textbox.id].focus();
 
     this.wizard.canAdvance = (this.pin1.value.length == PIN_PART_LENGTH
                               && this.pin2.value.length == PIN_PART_LENGTH
                               && this.pin3.value.length == PIN_PART_LENGTH);
   },
 
-  goToSyncKeyPage: function goToSyncKeyPage() {
+  goToSyncKeyPage: function() {
     this.wizard.pageIndex = SYNC_KEY_PAGE;
   }
 
 };
 // onWizardAdvance() and onPageShow() are run before init() so we'll set
 // these up as lazy getters.
 ["wizard", "pin1", "pin2", "pin3"].forEach(function (id) {
   XPCOMUtils.defineLazyGetter(gSyncAddDevice, id, function() {
diff --git a/browser/base/content/sync/genericChange.js b/browser/base/content/sync/genericChange.js
--- a/browser/base/content/sync/genericChange.js
+++ b/browser/base/content/sync/genericChange.js
@@ -24,17 +24,17 @@ let Change = {
   get _currentPasswordInvalid() {
     return Weave.Status.login == Weave.LOGIN_FAILED_LOGIN_REJECTED;
   },
 
   get _updatingPassphrase() {
     return this._dialogType == "UpdatePassphrase";
   },
 
-  onLoad: function Change_onLoad() {
+  onLoad: function() {
     /* Load labels */
     let introText = document.getElementById("introText");
     let introText2 = document.getElementById("introText2");
     let warningText = document.getElementById("warningText");
 
     // load some other elements & info from the window
     this._dialog = document.getElementById("change-dialog");
     this._dialogType = window.arguments[0];
@@ -108,26 +108,26 @@ let Change = {
             = this._str("change.password.acceptButton");
         }
         break;
     }
     document.getElementById("change-page")
             .setAttribute("label", document.title);
   },
 
-  _clearStatus: function _clearStatus() {
+  _clearStatus: function() {
     this._status.value = "";
     this._statusIcon.removeAttribute("status");
   },
 
-  _updateStatus: function Change__updateStatus(str, state) {
+  _updateStatus: function(str, state) {
      this._updateStatusWithString(this._str(str), state);
   },
   
-  _updateStatusWithString: function Change__updateStatusWithString(string, state) {
+  _updateStatusWithString: function(string, state) {
     this._statusRow.hidden = false;
     this._status.value = string;
     this._statusIcon.setAttribute("status", state);
 
     let error = state == "error";
     this._dialog.getButton("cancel").disabled = !error;
     this._dialog.getButton("finish").disabled = !error;
     document.getElementById("printSyncKeyButton").disabled = !error;
@@ -150,17 +150,17 @@ let Change = {
   },
 
   doGeneratePassphrase: function () {
     let passphrase = Weave.Utils.generatePassphrase();
     this._passphraseBox.value = Weave.Utils.hyphenatePassphrase(passphrase);
     this._dialog.getButton("finish").disabled = false;
   },
 
-  doChangePassphrase: function Change_doChangePassphrase() {
+  doChangePassphrase: function() {
     let pp = Weave.Utils.normalizePassphrase(this._passphraseBox.value);
     if (this._updatingPassphrase) {
       Weave.Service.identity.syncKey = pp;
       if (Weave.Service.login()) {
         this._updateStatus("change.recoverykey.success", "success");
         Weave.Service.persistLogin();
         Weave.Service.scheduler.delayedAutoConnect(0);
       }
@@ -175,17 +175,17 @@ let Change = {
         this._updateStatus("change.recoverykey.success", "success");
       else
         this._updateStatus("change.recoverykey.error", "error");
     }
 
     return false;
   },
 
-  doChangePassword: function Change_doChangePassword() {
+  doChangePassword: function() {
     if (this._currentPasswordInvalid) {
       Weave.Service.identity.basicPassword = this._firstBox.value;
       if (Weave.Service.login()) {
         this._updateStatus("change.password.status.success", "success");
         Weave.Service.persistLogin();
       }
       else {
         this._updateStatus("new.password.status.incorrect", "error");
@@ -224,12 +224,12 @@ let Change = {
       this._clearStatus();
     else
       this._updateStatusWithString(errorString, "error");
 
     this._statusRow.hidden = valid;
     this._dialog.getButton("finish").disabled = !valid;
   },
 
-  _str: function Change__string(str) {
+  _str: function(str) {
     return this._stringBundle.GetStringFromName(str);
   }
 };
diff --git a/browser/base/content/sync/quota.js b/browser/base/content/sync/quota.js
--- a/browser/base/content/sync/quota.js
+++ b/browser/base/content/sync/quota.js
@@ -7,29 +7,29 @@ const Cc = Components.classes;
 const Cr = Components.results;
 const Cu = Components.utils;
 
 Cu.import("resource://services-sync/main.js");
 Cu.import("resource://gre/modules/DownloadUtils.jsm");
 
 let gSyncQuota = {
 
-  init: function init() {
+  init: function() {
     this.bundle = document.getElementById("quotaStrings");
     let caption = document.getElementById("treeCaption");
     caption.firstChild.nodeValue = this.bundle.getString("quota.treeCaption.label");
 
     gUsageTreeView.init();
     this.tree = document.getElementById("usageTree");
     this.tree.view = gUsageTreeView;
 
     this.loadData();
   },
 
-  loadData: function loadData() {
+  loadData: function() {
     this._usage_req = Weave.Service.getStorageInfo(Weave.INFO_COLLECTION_USAGE,
                                                    function (error, usage) {
       delete gSyncQuota._usage_req;
       // displayUsageData handles null values, so no need to check 'error'.
       gUsageTreeView.displayUsageData(usage);
     });
 
     let usageLabel = document.getElementById("usageLabel");
@@ -52,40 +52,40 @@ let gSyncQuota = {
       }
       let percent = Math.round(100 * quota[0] / quota[1]);
       let total = gSyncQuota.convertKB(quota[1]);
       usageLabel.value = bundle.getFormattedString(
         "quota.usagePercentage.label", [percent].concat(used).concat(total));
     });
   },
 
-  onCancel: function onCancel() {
+  onCancel: function() {
     if (this._usage_req) {
       this._usage_req.abort();
     }
     if (this._quota_req) {
       this._quota_req.abort();
     }
     return true;
   },
 
-  onAccept: function onAccept() {
+  onAccept: function() {
     let engines = gUsageTreeView.getEnginesToDisable();
     for each (let engine in engines) {
       Weave.Service.engineManager.get(engine).enabled = false;
     }
     if (engines.length) {
       // The 'Weave' object will disappear once the window closes.
       let Service = Weave.Service;
       Weave.Utils.nextTick(function() { Service.sync(); });
     }
     return this.onCancel();
   },
 
-  convertKB: function convertKB(value) {
+  convertKB: function(value) {
     return DownloadUtils.convertByteUnits(value * 1024);
   }
 
 };
 
 let gUsageTreeView = {
 
   _ignored: {keys: true,
@@ -93,17 +93,17 @@ let gUsageTreeView = {
              clients: true},
 
   /*
    * Internal data structures underlaying the tree.
    */
   _collections: [],
   _byname: {},
 
-  init: function init() {
+  init: function() {
     let retrievingLabel = gSyncQuota.bundle.getString("quota.retrieving.label");
     for each (let engine in Weave.Service.engineManager.getEnabled()) {
       if (this._ignored[engine.name])
         continue;
 
       // Some engines use the same pref, which means they can only be turned on
       // and off together. We need to combine them here as well.
       let existing = this._byname[engine.prefName];
@@ -117,29 +117,29 @@ let gUsageTreeView = {
                  engines: [engine.name],
                  enabled: true,
                  sizeLabel: retrievingLabel};
       this._collections.push(obj);
       this._byname[engine.prefName] = obj;
     }
   },
 
-  _collectionTitle: function _collectionTitle(engine) {
+  _collectionTitle: function(engine) {
     try {
       return gSyncQuota.bundle.getString(
         "collection." + engine.prefName + ".label");
     } catch (ex) {
       return engine.Name;
     }
   },
 
   /*
    * Process the quota information as returned by info/collection_usage.
    */
-  displayUsageData: function displayUsageData(data) {
+  displayUsageData: function(data) {
     for each (let coll in this._collections) {
       coll.size = 0;
       // If we couldn't retrieve any data, just blank out the label.
       if (!data) {
         coll.sizeLabel = "";
         continue;
       }
 
@@ -152,29 +152,29 @@ let gUsageTreeView = {
     }
     let sizeColumn = this.treeBox.columns.getNamedColumn("size");
     this.treeBox.invalidateColumn(sizeColumn);
   },
 
   /*
    * Handle click events on the tree.
    */
-  onTreeClick: function onTreeClick(event) {
+  onTreeClick: function(event) {
     if (event.button == 2)
       return;
 
     let cell = this.treeBox.getCellAt(event.clientX, event.clientY);
     if (cell.col && cell.col.id == "enabled")
       this.toggle(cell.row);
   },
 
   /*
    * Toggle enabled state of an engine.
    */
-  toggle: function toggle(row) {
+  toggle: function(row) {
     // Update the tree
     let collection = this._collections[row];
     collection.enabled = !collection.enabled;
     this.treeBox.invalidateRow(row);
 
     // Display which ones will be removed 
     let freeup = 0;
     let toremove = [];
@@ -202,17 +202,17 @@ let gUsageTreeView = {
         "quota.freeup.label", gSyncQuota.convertKB(freeup));
     caption.className = "captionWarning";
   },
 
   /*
    * Return a list of engines (or rather their pref names) that should be
    * disabled.
    */
-  getEnginesToDisable: function getEnginesToDisable() {
+  getEnginesToDisable: function() {
     return [coll.name for each (coll in this._collections) if (!coll.enabled)];
   },
 
   // nsITreeView
 
   get rowCount() {
     return this._collections.length;
   },
@@ -231,29 +231,29 @@ let gUsageTreeView = {
   hasNextSibling: function(rowIndex, afterIndex) { return false; },
   getLevel: function(index) { return 0; },
   getImageSrc: function(row, col) {},
 
   getCellValue: function(row, col) {
     return this._collections[row].enabled;
   },
 
-  getCellText: function getCellText(row, col) {
+  getCellText: function(row, col) {
     let collection = this._collections[row];
     switch (col.id) {
       case "collection":
         return collection.title;
       case "size":
         return collection.sizeLabel;
       default:
         return "";
     }
   },
 
-  setTree: function setTree(tree) {
+  setTree: function(tree) {
     this.treeBox = tree;
   },
 
   toggleOpenState: function(index) {},
   cycleHeader: function(col) {},
   selectionChanged: function() {},
   cycleCell: function(row, col) {},
   isEditable: function(row, col) { return false; },
diff --git a/browser/base/content/sync/setup.js b/browser/base/content/sync/setup.js
--- a/browser/base/content/sync/setup.js
+++ b/browser/base/content/sync/setup.js
@@ -134,17 +134,17 @@ var gSyncSetup = {
       // We're already pairing, so there's no point in pairing again.
       // Go straight to the manual login page.
       this.wizard.pageIndex = EXISTING_ACCOUNT_LOGIN_PAGE;
     } else {
       this.wizard.pageIndex = EXISTING_ACCOUNT_CONNECT_PAGE;
     }
   },
 
-  resetPassphrase: function resetPassphrase() {
+  resetPassphrase: function() {
     // Apply the existing form fields so that
     // Weave.Service.changePassphrase() has the necessary credentials.
     Weave.Service.identity.account = document.getElementById("existingAccountName").value;
     Weave.Service.identity.basicPassword = document.getElementById("existingPassword").value;
 
     // Generate a new passphrase so that Weave.Service.login() will
     // actually do something.
     let passphrase = Weave.Utils.generatePassphrase();
@@ -277,17 +277,17 @@ var gSyncSetup = {
           }
         }
         return false;
     }
     // Default, e.g. wizard's special page -1 etc.
     return true;
   },
 
-  onPINInput: function onPINInput(textbox) {
+  onPINInput: function(textbox) {
     if (textbox && textbox.value.length == PIN_PART_LENGTH) {
       this.nextFocusEl[textbox.id].focus();
     }
     this.wizard.canAdvance = (this.pin1.value.length == PIN_PART_LENGTH &&
                               this.pin2.value.length == PIN_PART_LENGTH &&
                               this.pin3.value.length == PIN_PART_LENGTH);
   },
 
@@ -593,31 +593,31 @@ var gSyncSetup = {
     this.wizard.getButton("back").setAttribute("accesskey",
                                                this._backButtonAccesskey);
     this.wizard.getButton("cancel").hidden = false;
     this.wizard.getButton("extra1").hidden = false;
     this.wizard.pageIndex = this._beforeOptionsPage;
     return false;
   },
 
-  startPairing: function startPairing() {
+  startPairing: function() {
     this.pairDeviceErrorRow.hidden = true;
     // When onAbort is called, Weave may already be gone.
     const JPAKE_ERROR_USERABORT = Weave.JPAKE_ERROR_USERABORT;
 
     let self = this;
     let jpakeclient = this._jpakeclient = new Weave.JPAKEClient({
-      onPaired: function onPaired() {
+      onPaired: function() {
         self.wizard.pageIndex = INTRO_PAGE;
       },
-      onComplete: function onComplete() {
+      onComplete: function() {
         // This method will never be called since SendCredentialsController
         // will take over after the wizard completes.
       },
-      onAbort: function onAbort(error) {
+      onAbort: function(error) {
         delete self._jpakeclient;
 
         // Aborted by user, ignore. The window is almost certainly going to close
         // or is already closed.
         if (error == JPAKE_ERROR_USERABORT) {
           return;
         }
 
@@ -634,17 +634,17 @@ var gSyncSetup = {
     this.pin1.disabled = this.pin2.disabled = this.pin3.disabled = true;
     this.wizard.canAdvance = false;
 
     let pin = this.pin1.value + this.pin2.value + this.pin3.value;
     let expectDelay = true;
     jpakeclient.pairWithPIN(pin, expectDelay);
   },
 
-  completePairing: function completePairing() {
+  completePairing: function() {
     if (!this._jpakeclient) {
       // The channel was aborted while we were setting up the account
       // locally. XXX TODO should we do anything here, e.g. tell
       // the user on the last wizard page that it's ok, they just
       // have to pair again?
       return;
     }
     let controller = new Weave.SendCredentialsController(this._jpakeclient,
@@ -658,33 +658,33 @@ var gSyncSetup = {
     if (this._jpakeclient)
       return;
 
     // When onAbort is called, Weave may already be gone
     const JPAKE_ERROR_USERABORT = Weave.JPAKE_ERROR_USERABORT;
 
     let self = this;
     this._jpakeclient = new Weave.JPAKEClient({
-      displayPIN: function displayPIN(pin) {
+      displayPIN: function(pin) {
         document.getElementById("easySetupPIN1").value = pin.slice(0, 4);
         document.getElementById("easySetupPIN2").value = pin.slice(4, 8);
         document.getElementById("easySetupPIN3").value = pin.slice(8);
       },
 
-      onPairingStart: function onPairingStart() {},
+      onPairingStart: function() {},
 
-      onComplete: function onComplete(credentials) {
+      onComplete: function(credentials) {
         Weave.Service.identity.account = credentials.account;
         Weave.Service.identity.basicPassword = credentials.password;
         Weave.Service.identity.syncKey = credentials.synckey;
         Weave.Service.serverURL = credentials.serverURL;
         gSyncSetup.wizardFinish();
       },
 
-      onAbort: function onAbort(error) {
+      onAbort: function(error) {
         delete self._jpakeclient;
 
         // Ignore if wizard is aborted.
         if (error == JPAKE_ERROR_USERABORT)
           return;
 
         // Automatically go to manual setup if we couldn't acquire a channel.
         if (error == Weave.JPAKE_ERROR_CHANNEL) {
@@ -1015,17 +1015,17 @@ var gSyncSetup = {
       } catch(e) {}
 
       if (!str)
         str = Weave.Utils.getErrorString(string);
     }
     this._setFeedback(element, success, str);
   },
 
-  loadCaptcha: function loadCaptcha() {
+  loadCaptcha: function() {
     let captchaURI = Weave.Service.miscAPI + "captcha_html";
     // First check for NoScript and whitelist the right sites.
     this._handleNoScript(true);
     if (this.captchaBrowser.currentURI.spec != captchaURI) {
       this.captchaBrowser.loadURI(captchaURI);
     }
   },
 
diff --git a/browser/base/content/sync/utils.js b/browser/base/content/sync/utils.js
--- a/browser/base/content/sync/utils.js
+++ b/browser/base/content/sync/utils.js
@@ -32,23 +32,23 @@ let gSyncUtils = {
       openUILinkIn(url, "window");
     else if (document.documentElement.id == "change-dialog")
       Services.wm.getMostRecentWindow("navigator:browser")
               .openUILinkIn(url, "tab");
     else
       openUILinkIn(url, "tab");
   },
 
-  changeName: function changeName(input) {
+  changeName: function(input) {
     // Make sure to update to a modified name, e.g., empty-string -> default
     Weave.Service.clientsEngine.localName = input.value;
     input.value = Weave.Service.clientsEngine.localName;
   },
 
-  openChange: function openChange(type, duringSetup) {
+  openChange: function(type, duringSetup) {
     // Just re-show the dialog if it's already open
     let openedDialog = Services.wm.getMostRecentWindow("Sync:" + type);
     if (openedDialog != null) {
       openedDialog.focus();
       return;
     }
 
     // Open up the change dialog
diff --git a/browser/base/content/test/general/browser_bug519216.js b/browser/base/content/test/general/browser_bug519216.js
--- a/browser/base/content/test/general/browser_bug519216.js
+++ b/browser/base/content/test/general/browser_bug519216.js
@@ -3,43 +3,43 @@ function test() {
   gBrowser.addProgressListener(progressListener1);
   gBrowser.addProgressListener(progressListener2);
   gBrowser.addProgressListener(progressListener3);
   gBrowser.loadURI("data:text/plain,bug519216");
 }
 
 var calledListener1 = false;
 var progressListener1 = {
-  onLocationChange: function onLocationChange() {
+  onLocationChange: function() {
     calledListener1 = true;
     gBrowser.removeProgressListener(this);
   }
 };
 
 var calledListener2 = false;
 var progressListener2 = {
-  onLocationChange: function onLocationChange() {
+  onLocationChange: function() {
     ok(calledListener1, "called progressListener1 before progressListener2");
     calledListener2 = true;
     gBrowser.removeProgressListener(this);
   }
 };
 
 var progressListener3 = {
-  onLocationChange: function onLocationChange() {
+  onLocationChange: function() {
     ok(calledListener2, "called progressListener2 before progressListener3");
     gBrowser.removeProgressListener(this);
     gBrowser.addProgressListener(progressListener4);
     executeSoon(function () {
       expectListener4 = true;
       gBrowser.reload();
     });
   }
 };
 
 var expectListener4 = false;
 var progressListener4 = {
-  onLocationChange: function onLocationChange() {
+  onLocationChange: function() {
     ok(expectListener4, "didn't call progressListener4 for the first location change");
     gBrowser.removeProgressListener(this);
     executeSoon(finish);
   }
 };
diff --git a/browser/base/content/test/general/browser_bug521216.js b/browser/base/content/test/general/browser_bug521216.js
--- a/browser/base/content/test/general/browser_bug521216.js
+++ b/browser/base/content/test/general/browser_bug521216.js
@@ -26,22 +26,22 @@ function record(aName) {
 }
 
 function TabOpen(aEvent) {
   if (aEvent.target == tab)
     record(arguments.callee.name);
 }
 
 var progressListener = {
-  onLocationChange: function onLocationChange(aBrowser) {
+  onLocationChange: function(aBrowser) {
     if (aBrowser == tab.linkedBrowser)
       record(arguments.callee.name);
   },
-  onStateChange: function onStateChange(aBrowser) {
+  onStateChange: function(aBrowser) {
     if (aBrowser == tab.linkedBrowser)
       record(arguments.callee.name);
   },
-  onLinkIconAvailable: function onLinkIconAvailable(aBrowser, aIconURL) {
+  onLinkIconAvailable: function(aBrowser, aIconURL) {
     if (aBrowser == tab.linkedBrowser &&
         aIconURL == "about:logo")
       record(arguments.callee.name);
   }
 };
diff --git a/browser/base/content/test/general/browser_canonizeURL.js b/browser/base/content/test/general/browser_canonizeURL.js
--- a/browser/base/content/test/general/browser_canonizeURL.js
+++ b/browser/base/content/test/general/browser_canonizeURL.js
@@ -24,17 +24,17 @@ function testNext() {
   if (!pairs.length) {
     finish();
     return;
   }
 
   let [inputValue, expectedURL] = pairs.shift();
 
   gBrowser.addProgressListener({
-    onStateChange: function onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+    onStateChange: function(aWebProgress, aRequest, aStateFlags, aStatus) {
       if (aStateFlags & Ci.nsIWebProgressListener.STATE_START &&
           aStateFlags & Ci.nsIWebProgressListener.STATE_IS_NETWORK) {
         is(aRequest.originalURI.spec, expectedURL,
            "entering '" + inputValue + "' loads expected URL");
 
         gBrowser.removeProgressListener(this);
         gBrowser.stop();
 
diff --git a/browser/base/content/test/general/browser_devices_get_user_media.js b/browser/base/content/test/general/browser_devices_get_user_media.js
--- a/browser/base/content/test/general/browser_devices_get_user_media.js
+++ b/browser/base/content/test/general/browser_devices_get_user_media.js
@@ -224,17 +224,17 @@ function* checkNotSharing() {
 }
 
 const permissionError = "error: PermissionDeniedError: The user did not grant permission for the operation.";
 
 let gTests = [
 
 {
   desc: "getUserMedia audio+video",
-  run: function checkAudioVideo() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
@@ -252,17 +252,17 @@ let gTests = [
 
     yield checkSharingUI({audio: true, video: true});
     yield closeStream();
   }
 },
 
 {
   desc: "getUserMedia audio only",
-  run: function checkAudioOnly() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true);
     });
     expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareMicrophone-notification-icon", "anchored to mic icon");
@@ -279,17 +279,17 @@ let gTests = [
 
     yield checkSharingUI({audio: true});
     yield closeStream();
   }
 },
 
 {
   desc: "getUserMedia video only",
-  run: function checkVideoOnly() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(false, true);
     });
     expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
        "webRTC-shareDevices-notification-icon", "anchored to device icon");
@@ -306,17 +306,17 @@ let gTests = [
 
     yield checkSharingUI({video: true});
     yield closeStream();
   }
 },
 
 {
   desc: "getUserMedia audio+video, user disables video",
-  run: function checkDisableVideo() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     // disable the camera
@@ -336,17 +336,17 @@ let gTests = [
 
     yield checkSharingUI({audio: true});
     yield closeStream();
   }
 },
 
 {
   desc: "getUserMedia audio+video, user disables audio",
-  run: function checkDisableAudio() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     // disable the microphone
@@ -366,17 +366,17 @@ let gTests = [
 
     yield checkSharingUI({video: true});
     yield closeStream();
   }
 },
 
 {
   desc: "getUserMedia audio+video, user disables both audio and video",
-  run: function checkDisableAudioVideo() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     // disable the camera and microphone
@@ -394,17 +394,17 @@ let gTests = [
     expectObserverCalled("getUserMedia:response:deny");
     expectObserverCalled("recording-window-ended");
     yield checkNotSharing();
   }
 },
 
 {
   desc: "getUserMedia audio+video, user clicks \"Don't Share\"",
-  run: function checkDontShare() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     yield promiseMessage(permissionError, () => {
@@ -414,17 +414,17 @@ let gTests = [
     expectObserverCalled("getUserMedia:response:deny");
     expectObserverCalled("recording-window-ended");
     yield checkNotSharing();
   }
 },
 
 {
   desc: "getUserMedia audio+video: stop sharing",
-  run: function checkStopSharing() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     yield promiseMessage("ok", () => {
@@ -456,17 +456,17 @@ let gTests = [
 
     // the stream is already closed, but this will do some cleanup anyway
     yield closeStream(true);
   }
 },
 
 {
   desc: "getUserMedia audio+video: reloading the page removes all gUM UI",
-  run: function checkReloading() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
     yield promiseMessage("ok", () => {
@@ -493,17 +493,17 @@ let gTests = [
     expectObserverCalled("recording-window-ended");
     expectNoObserverCalled();
     yield checkNotSharing();
   }
 },
 
 {
   desc: "getUserMedia prompt: Always/Never Share",
-  run: function checkRememberCheckbox() {
+  run: function() {
     let elt = id => document.getElementById(id);
 
     function checkPerm(aRequestAudio, aRequestVideo, aAllowAudio, aAllowVideo,
                        aExpectedAudioPerm, aExpectedVideoPerm, aNever) {
       yield promisePopupNotificationShown("webRTC-shareDevices", () => {
         content.wrappedJSObject.requestDevice(aRequestAudio, aRequestVideo);
       });
       expectObserverCalled("getUserMedia:request");
@@ -597,17 +597,17 @@ let gTests = [
     // reset the menuitems to have no impact on the following tests.
     enableDevice("Microphone", true);
     enableDevice("Camera", true);
   }
 },
 
 {
   desc: "getUserMedia without prompt: use persistent permissions",
-  run: function checkUsePersistentPermissions() {
+  run: function() {
     function usePerm(aAllowAudio, aAllowVideo, aRequestAudio, aRequestVideo,
                      aExpectStream) {
       let Perms = Services.perms;
       let uri = content.document.documentURIObject;
       if (aAllowAudio !== undefined) {
         Perms.add(uri, "microphone", aAllowAudio ? Perms.ALLOW_ACTION
                                                  : Perms.DENY_ACTION);
       }
@@ -716,17 +716,17 @@ let gTests = [
     yield usePerm(undefined, false, true, false, undefined);
     info("deny video, request video, expect denied");
     yield usePerm(undefined, false, false, true, false);
   }
 },
 
 {
   desc: "Stop Sharing removes persistent permissions",
-  run: function checkStopSharingRemovesPersistentPermissions() {
+  run: function() {
     function stopAndCheckPerm(aRequestAudio, aRequestVideo) {
       let Perms = Services.perms;
       let uri = content.document.documentURIObject;
 
       // Initially set both permissions to 'allow'.
       Perms.add(uri, "microphone", Perms.ALLOW_ACTION);
       Perms.add(uri, "camera", Perms.ALLOW_ACTION);
 
@@ -788,17 +788,17 @@ let gTests = [
     yield stopAndCheckPerm(true, false);
     info("request video, stop sharing resets video only");
     yield stopAndCheckPerm(false, true);
   }
 },
 
 {
   desc: "test showSharingDoorhanger",
-  run: function checkShowSharingDoorhanger() {
+  run: function() {
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       content.wrappedJSObject.requestDevice(false, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(false, true);
 
     yield promiseMessage("ok", () => {
@@ -828,17 +828,17 @@ let gTests = [
     expectNoObserverCalled();
 
     yield closeStream();
   }
 },
 
 {
   desc: "'Always Allow' ignored and not shown on http pages",
-  run: function checkNoAlwaysOnHttp() {
+  run: function() {
     // Load an http page instead of the https version.
     let deferred = Promise.defer();
     let browser = gBrowser.selectedBrowser;
     browser.addEventListener("load", function onload() {
       browser.removeEventListener("load", onload, true);
       deferred.resolve();
     }, true);
     content.location = content.location.href.replace("https://", "http://");
diff --git a/browser/base/content/test/general/browser_devices_get_user_media_about_urls.js b/browser/base/content/test/general/browser_devices_get_user_media_about_urls.js
--- a/browser/base/content/test/general/browser_devices_get_user_media_about_urls.js
+++ b/browser/base/content/test/general/browser_devices_get_user_media_about_urls.js
@@ -232,17 +232,17 @@ registerCleanupFunction(function() {
 });
 
 const permissionError = "error: PermissionDeniedError: The user did not grant permission for the operation.";
 
 let gTests = [
 
 {
   desc: "getUserMedia about:loopconversation shouldn't prompt",
-  run: function checkAudioVideoLoop() {
+  run: function() {
     Services.prefs.setCharPref(PREF_LOOP_CSP, "default-src 'unsafe-inline'");
 
     let classID = Cc["@mozilla.org/uuid-generator;1"]
                     .getService(Ci.nsIUUIDGenerator).generateUUID();
     registrar.registerFactory(classID, "",
                               "@mozilla.org/network/protocol/about;1?what=loopconversation",
                               factory);
 
@@ -263,17 +263,17 @@ let gTests = [
 
     registrar.unregisterFactory(classID, factory);
     Services.prefs.setCharPref(PREF_LOOP_CSP, originalLoopCsp);
   }
 },
 
 {
   desc: "getUserMedia about:loopconversation should prompt for window sharing",
-  run: function checkShareScreenLoop() {
+  run: function() {
     if (isOldPlatform() || isLinux()) {
       return;
     }
 
     Services.prefs.setCharPref(PREF_LOOP_CSP, "default-src 'unsafe-inline'");
 
     let classID = Cc["@mozilla.org/uuid-generator;1"]
                     .getService(Ci.nsIUUIDGenerator).generateUUID();
@@ -303,17 +303,17 @@ let gTests = [
 
     registrar.unregisterFactory(classID, factory);
     Services.prefs.setCharPref(PREF_LOOP_CSP, originalLoopCsp);
   }
 },
 
 {
   desc: "getUserMedia about:evil should prompt",
-  run: function checkAudioVideoNonLoop() {
+  run: function() {
     let classID = Cc["@mozilla.org/uuid-generator;1"]
                     .getService(Ci.nsIUUIDGenerator).generateUUID();
     registrar.registerFactory(classID, "",
                               "@mozilla.org/network/protocol/about;1?what=evil",
                               factory);
 
     yield loadPage("about:evil");
 
diff --git a/browser/base/content/test/general/browser_devices_get_user_media_in_frame.js b/browser/base/content/test/general/browser_devices_get_user_media_in_frame.js
--- a/browser/base/content/test/general/browser_devices_get_user_media_in_frame.js
+++ b/browser/base/content/test/general/browser_devices_get_user_media_in_frame.js
@@ -222,17 +222,17 @@ function getFrameGlobal(aFrameId) {
 }
 
 const permissionError = "error: PermissionDeniedError: The user did not grant permission for the operation.";
 
 let gTests = [
 
 {
   desc: "getUserMedia audio+video",
-  run: function checkAudioVideo() {
+  run: function() {
     let global = getFrameGlobal("frame1");
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       global.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
 
     is(PopupNotifications.getNotification("webRTC-shareDevices").anchorID,
@@ -251,17 +251,17 @@ let gTests = [
 
     yield checkSharingUI({audio: true, video: true});
     yield closeStream(global);
   }
 },
 
 {
   desc: "getUserMedia audio+video: stop sharing",
-  run: function checkStopSharing() {
+  run: function() {
     let global = getFrameGlobal("frame1");
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       global.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
@@ -294,17 +294,17 @@ let gTests = [
 
     // the stream is already closed, but this will do some cleanup anyway
     yield closeStream(global, true);
   }
 },
 
 {
   desc: "getUserMedia audio+video: reloading the frame removes all sharing UI",
-  run: function checkReloading() {
+  run: function() {
     let global = getFrameGlobal("frame1");
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       global.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
@@ -330,17 +330,17 @@ let gTests = [
     expectObserverCalled("recording-window-ended");
     expectNoObserverCalled();
     yield checkNotSharing();
   }
 },
 
 {
   desc: "getUserMedia audio+video: reloading the frame removes prompts",
-  run: function checkReloadingRemovesPrompts() {
+  run: function() {
     let global = getFrameGlobal("frame1");
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting devices");
       global.requestDevice(true, true);
     });
     expectObserverCalled("getUserMedia:request");
     checkDeviceSelectors(true, true);
 
@@ -352,17 +352,17 @@ let gTests = [
 
     expectNoObserverCalled();
     yield checkNotSharing();
   }
 },
 
 {
   desc: "getUserMedia audio+video: reloading a frame updates the sharing UI",
-  run: function checkUpdateWhenReloading() {
+  run: function() {
     // We'll share only the mic in the first frame, then share both in the
     // second frame, then reload the second frame. After each step, we'll check
     // the UI is in the correct state.
     let g1 = getFrameGlobal("frame1"), g2 = getFrameGlobal("frame2");
 
     yield promisePopupNotificationShown("webRTC-shareDevices", () => {
       info("requesting microphone in the first frame");
       g1.requestDevice(true, false);
diff --git a/browser/base/content/test/general/browser_keywordSearch.js b/browser/base/content/test/general/browser_keywordSearch.js
--- a/browser/base/content/test/general/browser_keywordSearch.js
+++ b/browser/base/content/test/general/browser_keywordSearch.js
@@ -33,17 +33,17 @@ function test() {
     }
   };
 
   Services.ww.registerNotification(windowObserver);
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onLocationChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       // Only care about document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart))
         return;
 
       info("received document start");
 
diff --git a/browser/base/content/test/general/head.js b/browser/base/content/test/general/head.js
--- a/browser/base/content/test/general/head.js
+++ b/browser/base/content/test/general/head.js
@@ -434,44 +434,44 @@ function waitForDocLoadComplete(aBrowser
   };
   aBrowser.addProgressListener(progressListener);
   info("Waiting for browser load");
   return deferred.promise;
 }
 
 let FullZoomHelper = {
 
-  selectTabAndWaitForLocationChange: function selectTabAndWaitForLocationChange(tab) {
+  selectTabAndWaitForLocationChange: function(tab) {
     if (!tab)
       throw new Error("tab must be given.");
     if (gBrowser.selectedTab == tab)
       return Promise.resolve();
     gBrowser.selectedTab = tab;
     return this.waitForLocationChange();
   },
 
-  removeTabAndWaitForLocationChange: function removeTabAndWaitForLocationChange(tab) {
+  removeTabAndWaitForLocationChange: function(tab) {
     tab = tab || gBrowser.selectedTab;
     let selected = gBrowser.selectedTab == tab;
     gBrowser.removeTab(tab);
     if (selected)
       return this.waitForLocationChange();
     return Promise.resolve();
   },
 
-  waitForLocationChange: function waitForLocationChange() {
+  waitForLocationChange: function() {
     let deferred = Promise.defer();
     Services.obs.addObserver(function obs(subj, topic, data) {
       Services.obs.removeObserver(obs, topic);
       deferred.resolve();
     }, "browser-fullZoom:location-change", false);
     return deferred.promise;
   },
 
-  load: function load(tab, url) {
+  load: function(tab, url) {
     let deferred = Promise.defer();
     let didLoad = false;
     let didZoom = false;
 
     promiseTabLoadEvent(tab).then(event => {
       didLoad = true;
       if (didZoom)
         deferred.resolve();
@@ -483,41 +483,41 @@ let FullZoomHelper = {
         deferred.resolve();
     });
 
     tab.linkedBrowser.loadURI(url);
 
     return deferred.promise;
   },
 
-  zoomTest: function zoomTest(tab, val, msg) {
+  zoomTest: function(tab, val, msg) {
     is(ZoomManager.getZoomForBrowser(tab.linkedBrowser), val, msg);
   },
 
-  enlarge: function enlarge() {
+  enlarge: function() {
     let deferred = Promise.defer();
     FullZoom.enlarge(function () deferred.resolve());
     return deferred.promise;
   },
 
-  reduce: function reduce() {
+  reduce: function() {
     let deferred = Promise.defer();
     FullZoom.reduce(function () deferred.resolve());
     return deferred.promise;
   },
 
-  reset: function reset() {
+  reset: function() {
     let deferred = Promise.defer();
     FullZoom.reset(function () deferred.resolve());
     return deferred.promise;
   },
 
   BACK: 0,
   FORWARD: 1,
-  navigate: function navigate(direction) {
+  navigate: function(direction) {
     let deferred = Promise.defer();
     let didPs = false;
     let didZoom = false;
 
     gBrowser.addEventListener("pageshow", function (event) {
       gBrowser.removeEventListener("pageshow", arguments.callee, true);
       didPs = true;
       if (didZoom)
@@ -532,17 +532,17 @@ let FullZoomHelper = {
     this.waitForLocationChange().then(function () {
       didZoom = true;
       if (didPs)
         deferred.resolve();
     });
     return deferred.promise;
   },
 
-  failAndContinue: function failAndContinue(func) {
+  failAndContinue: function(func) {
     return function (err) {
       ok(false, err);
       func();
     };
   },
 };
 
 /**
diff --git a/browser/base/content/test/plugins/browser_pluginplaypreview.js b/browser/base/content/test/plugins/browser_pluginplaypreview.js
--- a/browser/base/content/test/plugins/browser_pluginplaypreview.js
+++ b/browser/base/content/test/plugins/browser_pluginplaypreview.js
@@ -15,40 +15,40 @@ var gPlayPreviewRegistration = null;
 
 function registerPlayPreview(mimeType, targetUrl) {
 
   function StreamConverterFactory() {}
   StreamConverterFactory.prototype = {
     QueryInterface: XPCOMUtils.generateQI([Ci.nsIFactory]),
     _targetConstructor: null,
 
-    register: function register(targetConstructor) {
+    register: function(targetConstructor) {
       this._targetConstructor = targetConstructor;
       var proto = targetConstructor.prototype;
       var registrar = Components.manager.QueryInterface(Ci.nsIComponentRegistrar);
       registrar.registerFactory(proto.classID, proto.classDescription,
                                 proto.contractID, this);
     },
 
-    unregister: function unregister() {
+    unregister: function() {
       var proto = this._targetConstructor.prototype;
       var registrar = Components.manager.QueryInterface(Ci.nsIComponentRegistrar);
       registrar.unregisterFactory(proto.classID, this);
       this._targetConstructor = null;
     },
 
     // nsIFactory
-    createInstance: function createInstance(aOuter, iid) {
+    createInstance: function(aOuter, iid) {
       if (aOuter !== null)
         throw Cr.NS_ERROR_NO_AGGREGATION;
       return (new (this._targetConstructor)).QueryInterface(iid);
     },
 
     // nsIFactory
-    lockFactory: function lockFactory(lock) {
+    lockFactory: function(lock) {
       // No longer used as of gecko 1.7.
       throw Cr.NS_ERROR_NOT_IMPLEMENTED;
     }
   };
 
   function OverlayStreamConverter() {}
   OverlayStreamConverter.prototype = {
     QueryInterface: XPCOMUtils.generateQI([
diff --git a/browser/base/content/test/popupNotifications/browser_popupNotification_3.js b/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
--- a/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
+++ b/browser/base/content/test/popupNotifications/browser_popupNotification_3.js
@@ -241,17 +241,17 @@ let tests = [
           ok(false, "Notification removed from browser when subframe navigated");
         }
       };
       showNotification(this.notifyObj);
     },
     onShown: function (popup) {
       let self = this;
       let progressListener = {
-        onLocationChange: function onLocationChange() {
+        onLocationChange: function() {
           gBrowser.removeProgressListener(progressListener);
 
 	  executeSoon(() => {
             let notification = PopupNotifications.getNotification(self.notifyObj.id,
                                                                   self.notifyObj.browser);
             ok(notification != null, "Notification remained when subframe navigated");
             self.notifyObj.options.eventCallback = undefined;
 
diff --git a/browser/components/distribution.js b/browser/components/distribution.js
--- a/browser/components/distribution.js
+++ b/browser/components/distribution.js
@@ -76,17 +76,17 @@ DistributionCustomizer.prototype = {
 
   get _ioSvc() {
     let svc = Cc["@mozilla.org/network/io-service;1"].
               getService(Ci.nsIIOService);
     this.__defineGetter__("_ioSvc", function() svc);
     return this._ioSvc;
   },
 
-  _makeURI: function DIST__makeURI(spec) {
+  _makeURI: function(spec) {
     return this._ioSvc.newURI(spec, null, null);
   },
 
   _parseBookmarksSection:
   function DIST_parseBookmarksSection(parentId, section) {
     let keys = [];
     for (let i in enumerate(this._ini.getKeys(section)))
       keys.push(i);
@@ -190,30 +190,30 @@ DistributionCustomizer.prototype = {
                                                     PlacesUtils.annotations.EXPIRE_NEVER);
 
         break;
       }
     }
   },
 
   _customizationsApplied: false,
-  applyCustomizations: function DIST_applyCustomizations() {
+  applyCustomizations: function() {
     this._customizationsApplied = true;
     if (!this._iniFile)
       return this._checkCustomizationComplete();
 
     // nsPrefService loads very early.  Reload prefs so we can set
     // distribution defaults during the prefservice:after-app-defaults
     // notification (see applyPrefDefaults below)
     this._prefSvc.QueryInterface(Ci.nsIObserver);
     this._prefSvc.observe(null, "reload-default-prefs", null);
   },
 
   _bookmarksApplied: false,
-  applyBookmarks: function DIST_applyBookmarks() {
+  applyBookmarks: function() {
     this._bookmarksApplied = true;
     if (!this._iniFile)
       return this._checkCustomizationComplete();
 
     let sections = enumToObject(this._ini.getSections());
 
     // The global section, and several of its fields, is required
     // (we also check here to be consistent with applyPrefDefaults below)
@@ -247,17 +247,17 @@ DistributionCustomizer.prototype = {
         this._parseBookmarksSection(PlacesUtils.toolbarFolderId,
                                     "BookmarksToolbar");
       this._prefs.setBoolPref(bmProcessedPref, true);
     }
     return this._checkCustomizationComplete();
   },
 
   _prefDefaultsApplied: false,
-  applyPrefDefaults: function DIST_applyPrefDefaults() {
+  applyPrefDefaults: function() {
     this._prefDefaultsApplied = true;
     if (!this._iniFile)
       return this._checkCustomizationComplete();
 
     let sections = enumToObject(this._ini.getSections());
 
     // The global section, and several of its fields, is required
     if (!sections["Global"])
@@ -338,17 +338,17 @@ DistributionCustomizer.prototype = {
           defaults.setComplexValue(key, Ci.nsIPrefLocalizedString, localizedStr);
         } catch (e) { /* ignore bad prefs and move on */ }
       }
     }
 
     return this._checkCustomizationComplete();
   },
 
-  _checkCustomizationComplete: function DIST__checkCustomizationComplete() {
+  _checkCustomizationComplete: function() {
     let prefDefaultsApplied = this._prefDefaultsApplied || !this._iniFile;
     if (this._customizationsApplied && this._bookmarksApplied &&
         prefDefaultsApplied) {
       let os = Cc["@mozilla.org/observer-service;1"].
                getService(Ci.nsIObserverService);
       os.notifyObservers(null, DISTRIBUTION_CUSTOMIZATION_COMPLETE_TOPIC, null);
     }
   }
diff --git a/browser/components/feeds/FeedConverter.js b/browser/components/feeds/FeedConverter.js
--- a/browser/components/feeds/FeedConverter.js
+++ b/browser/components/feeds/FeedConverter.js
@@ -143,26 +143,26 @@ FeedConverter.prototype = {
   /**
    * Whether or not the preview page is being forced.
    */
   _forcePreviewPage: false,
   
   /** 
    * Release our references to various things once we're done using them.
    */
-  _releaseHandles: function FC__releaseHandles() {
+  _releaseHandles: function() {
     this._listener = null;
     this._request = null;
     this._processor = null;
   },
   
   /**
    * See nsIFeedResultListener.idl
    */
-  handleResult: function FC_handleResult(result) {
+  handleResult: function(result) {
     // Feeds come in various content types, which our feed sniffer coerces to
     // the maybe.feed type. However, feeds are used as a transport for 
     // different data types, e.g. news/blogs (traditional feed), video/audio
     // (podcasts) and photos (photocasts, photostreams). Each of these is 
     // different in that there's a different class of application suitable for
     // handling feeds of that type, but without a content-type differentiation
     // it is difficult for us to disambiguate.
     // 
@@ -275,17 +275,17 @@ FeedConverter.prototype = {
     if (this._processor)
       this._processor.onDataAvailable(request, context, inputStream,
                                       sourceOffset, count);
   },
   
   /**
    * See nsIRequestObserver.idl
    */
-  onStartRequest: function FC_onStartRequest(request, context) {
+  onStartRequest: function(request, context) {
     var channel = request.QueryInterface(Ci.nsIChannel);
 
     // Check for a header that tells us there was no sniffing
     // The value doesn't matter.
     try {
       var httpChannel = channel.QueryInterface(Ci.nsIHttpChannel);
       // Make sure to check requestSucceeded before the potentially-throwing
       // getResponseHeader.
@@ -318,25 +318,25 @@ FeedConverter.prototype = {
     this._processor.parseAsync(null, channel.URI);
     
     this._processor.onStartRequest(request, context);
   },
   
   /**
    * See nsIRequestObserver.idl
    */
-  onStopRequest: function FC_onStopRequest(request, context, status) {
+  onStopRequest: function(request, context, status) {
     if (this._processor)
       this._processor.onStopRequest(request, context, status);
   },
   
   /**
    * See nsISupports.idl
    */
-  QueryInterface: function FC_QueryInterface(iid) {
+  QueryInterface: function(iid) {
     if (iid.equals(Ci.nsIFeedResultListener) ||
         iid.equals(Ci.nsIStreamConverter) ||
         iid.equals(Ci.nsIStreamListener) ||
         iid.equals(Ci.nsIRequestObserver)||
         iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NO_INTERFACE;
   },
@@ -361,17 +361,17 @@ FeedResultService.prototype = {
   /**
    * See nsIFeedResultService.idl
    */
   forcePreviewPage: false,
   
   /**
    * See nsIFeedResultService.idl
    */
-  addToClientReader: function FRS_addToClientReader(spec, title, subtitle, feedType) {
+  addToClientReader: function(spec, title, subtitle, feedType) {
     var prefs =   
         Cc["@mozilla.org/preferences-service;1"].
         getService(Ci.nsIPrefBranch);
 
     var handler = safeGetCharPref(getPrefActionForType(feedType), "bookmarks");
     if (handler == "ask" || handler == "reader")
       handler = safeGetCharPref(getPrefReaderForType(feedType), "bookmarks");
 
@@ -427,42 +427,42 @@ FeedResultService.prototype = {
       topWindow.PlacesCommandHook.addLiveBookmark(spec, title, subtitle);
       break;
     }
   },
   
   /**
    * See nsIFeedResultService.idl
    */
-  addFeedResult: function FRS_addFeedResult(feedResult) {
+  addFeedResult: function(feedResult) {
     NS_ASSERT(feedResult.uri != null, "null URI!");
     NS_ASSERT(feedResult.uri != null, "null feedResult!");
     var spec = feedResult.uri.spec;
     if(!this._results[spec])  
       this._results[spec] = [];
     this._results[spec].push(feedResult);
   },
   
   /**
    * See nsIFeedResultService.idl
    */
-  getFeedResult: function RFS_getFeedResult(uri) {
+  getFeedResult: function(uri) {
     NS_ASSERT(uri != null, "null URI!");
     var resultList = this._results[uri.spec];
     for (var i in resultList) {
       if (resultList[i].uri == uri)
         return resultList[i];
     }
     return null;
   },
   
   /**
    * See nsIFeedResultService.idl
    */
-  removeFeedResult: function FRS_removeFeedResult(uri) {
+  removeFeedResult: function(uri) {
     NS_ASSERT(uri != null, "null URI!");
     var resultList = this._results[uri.spec];
     if (!resultList)
       return;
     var deletions = 0;
     for (var i = 0; i < resultList.length; ++i) {
       if (resultList[i].uri == uri) {
         delete resultList[i];
@@ -473,39 +473,39 @@ FeedResultService.prototype = {
     // send the holes to the end
     resultList.sort();
     // and trim the list
     resultList.splice(resultList.length - deletions, deletions);
     if (resultList.length == 0)
       delete this._results[uri.spec];
   },
 
-  createInstance: function FRS_createInstance(outer, iid) {
+  createInstance: function(outer, iid) {
     if (outer != null)
       throw Cr.NS_ERROR_NO_AGGREGATION;
     return this.QueryInterface(iid);
   },
   
-  QueryInterface: function FRS_QueryInterface(iid) {
+  QueryInterface: function(iid) {
     if (iid.equals(Ci.nsIFeedResultService) ||
         iid.equals(Ci.nsIFactory) ||
         iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NOT_IMPLEMENTED;
   },
 };
 
 /**
  * A protocol handler that attempts to deal with the variant forms of feed:
  * URIs that are actually either http or https.
  */
 function GenericProtocolHandler() {
 }
 GenericProtocolHandler.prototype = {
-  _init: function GPH_init(scheme) {
+  _init: function(scheme) {
     var ios = 
       Cc["@mozilla.org/network/io-service;1"].
       getService(Ci.nsIIOService);
     this._http = ios.getProtocolHandler("http");
     this._scheme = scheme;
   },
 
   get scheme() {
@@ -515,21 +515,21 @@ GenericProtocolHandler.prototype = {
   get protocolFlags() {
     return this._http.protocolFlags;
   },
   
   get defaultPort() {
     return this._http.defaultPort;
   },
   
-  allowPort: function GPH_allowPort(port, scheme) {
+  allowPort: function(port, scheme) {
     return this._http.allowPort(port, scheme);
   },
   
-  newURI: function GPH_newURI(spec, originalCharset, baseURI) {
+  newURI: function(spec, originalCharset, baseURI) {
     // Feed URIs can be either nested URIs of the form feed:realURI (in which
     // case we create a nested URI for the realURI) or feed://example.com, in
     // which case we create a nested URI for the real protocol which is http.
 
     var scheme = this._scheme + ":";
     if (spec.substr(0, scheme.length) != scheme)
       throw Cr.NS_ERROR_MALFORMED_URI;
 
@@ -543,31 +543,31 @@ GenericProtocolHandler.prototype = {
     if (netutil.URIChainHasFlags(inner, URI_INHERITS_SECURITY_CONTEXT))
       throw Cr.NS_ERROR_MALFORMED_URI;
 
     var uri = netutil.newSimpleNestedURI(inner);
     uri.spec = inner.spec.replace(prefix, scheme);
     return uri;
   },
   
-  newChannel2: function GPH_newChannel(aUri, aLoadInfo) {
+  newChannel2: function(aUri, aLoadInfo) {
     var inner = aUri.QueryInterface(Ci.nsINestedURI).innerURI;
     var channel = Cc["@mozilla.org/network/io-service;1"].
                   getService(Ci.nsIIOService).
                   newChannelFromURIWithLoadInfo(inner, aLoadInfo);
 
     if (channel instanceof Components.interfaces.nsIHttpChannel)
       // Set this so we know this is supposed to be a feed
       channel.setRequestHeader("X-Moz-Is-Feed", "1", false);
     channel.originalURI = aUri;
     return channel;
   },
   
 
-  QueryInterface: function GPH_QueryInterface(iid) {
+  QueryInterface: function(iid) {
     if (iid.equals(Ci.nsIProtocolHandler) ||
         iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NO_INTERFACE;
   }  
 };
 
 function FeedProtocolHandler() {
diff --git a/browser/components/feeds/FeedWriter.js b/browser/components/feeds/FeedWriter.js
--- a/browser/components/feeds/FeedWriter.js
+++ b/browser/components/feeds/FeedWriter.js
@@ -148,31 +148,31 @@ function convertByteUnits(aBytes) {
   return [aBytes, units[unitIndex]];
 }
 
 function FeedWriter() {}
 FeedWriter.prototype = {
   _mimeSvc      : Cc["@mozilla.org/mime;1"].
                   getService(Ci.nsIMIMEService),
 
-  _getPropertyAsBag: function FW__getPropertyAsBag(container, property) {
+  _getPropertyAsBag: function(container, property) {
     return container.fields.getProperty(property).
                      QueryInterface(Ci.nsIPropertyBag2);
   },
 
-  _getPropertyAsString: function FW__getPropertyAsString(container, property) {
+  _getPropertyAsString: function(container, property) {
     try {
       return container.fields.getPropertyAsAString(property);
     }
     catch (e) {
     }
     return "";
   },
 
-  _setContentText: function FW__setContentText(id, text) {
+  _setContentText: function(id, text) {
     this._contentSandbox.element = this._document.getElementById(id);
     this._contentSandbox.textNode = text.createDocumentFragment(this._contentSandbox.element);
     var codeStr =
       "while (element.hasChildNodes()) " +
       "  element.removeChild(element.firstChild);" +
       "element.appendChild(textNode);";
     if (text.base) {
       this._contentSandbox.spec = text.base.spec;
@@ -242,17 +242,17 @@ FeedWriter.prototype = {
 
   /**
    * Calls doCommand for a given XUL element within the context of the
    * content document.
    *
    * @param aElement
    *        the XUL element to call doCommand() on.
    */
-  _safeDoCommand: function FW___safeDoCommand(aElement) {
+  _safeDoCommand: function(aElement) {
     this._contentSandbox.element = aElement;
     Cu.evalInSandbox("element.doCommand();", this._contentSandbox);
     this._contentSandbox.element = null;
   },
 
   __faviconService: null,
   get _faviconService() {
     if (!this.__faviconService)
@@ -267,38 +267,38 @@ FeedWriter.prototype = {
     if (!this.__bundle) {
       this.__bundle = Cc["@mozilla.org/intl/stringbundle;1"].
                       getService(Ci.nsIStringBundleService).
                       createBundle(URI_BUNDLE);
     }
     return this.__bundle;
   },
 
-  _getFormattedString: function FW__getFormattedString(key, params) {
+  _getFormattedString: function(key, params) {
     return this._bundle.formatStringFromName(key, params, params.length);
   },
   
-  _getString: function FW__getString(key) {
+  _getString: function(key) {
     return this._bundle.GetStringFromName(key);
   },
 
   /* Magic helper methods to be used instead of xbl properties */
-  _getSelectedItemFromMenulist: function FW__getSelectedItemFromList(aList) {
+  _getSelectedItemFromMenulist: function(aList) {
     var node = aList.firstChild.firstChild;
     while (node) {
       if (node.localName == "menuitem" && node.getAttribute("selected") == "true")
         return node;
 
       node = node.nextSibling;
     }
 
     return null;
   },
 
-  _setCheckboxCheckedState: function FW__setCheckboxCheckedState(aCheckbox, aValue) {
+  _setCheckboxCheckedState: function(aCheckbox, aValue) {
     // see checkbox.xml, xbl bindings are not applied within the sandbox!
     this._contentSandbox.checkbox = aCheckbox;
     var codeStr;
     var change = (aValue != (aCheckbox.getAttribute('checked') == 'true'));
     if (aValue)
       codeStr = "checkbox.setAttribute('checked', 'true'); ";
     else
       codeStr = "checkbox.removeAttribute('checked'); ";
@@ -314,17 +314,17 @@ FeedWriter.prototype = {
   },
 
    /**
    * Returns a date suitable for displaying in the feed preview. 
    * If the date cannot be parsed, the return value is "false".
    * @param   dateString
    *          A date as extracted from a feed entry. (entry.updated)
    */
-  _parseDate: function FW__parseDate(dateString) {
+  _parseDate: function(dateString) {
     // Convert the date into the user's local time zone
     dateObj = new Date(dateString);
 
     // Make sure the date we're given is valid.
     if (!dateObj.getTime())
       return false;
 
     var dateService = Cc["@mozilla.org/intl/scriptabledateformat;1"].
@@ -333,17 +333,17 @@ FeedWriter.prototype = {
                                       dateObj.getFullYear(), dateObj.getMonth()+1, dateObj.getDate(),
                                       dateObj.getHours(), dateObj.getMinutes(), dateObj.getSeconds());
   },
 
   /**
    * Returns the feed type.
    */
   __feedType: null,
-  _getFeedType: function FW__getFeedType() {
+  _getFeedType: function() {
     if (this.__feedType != null)
       return this.__feedType;
 
     try {
       // grab the feed because it's got the feed.type in it.
       var container = this._getContainer();
       var feed = container.QueryInterface(Ci.nsIFeed);
       this.__feedType = feed.type;
@@ -351,17 +351,17 @@ FeedWriter.prototype = {
     } catch (ex) { }
 
     return Ci.nsIFeed.TYPE_FEED;
   },
 
   /**
    * Maps a feed type to a maybe-feed mimetype.
    */
-  _getMimeTypeForFeedType: function FW__getMimeTypeForFeedType() {
+  _getMimeTypeForFeedType: function() {
     switch (this._getFeedType()) {
       case Ci.nsIFeed.TYPE_VIDEO:
         return TYPE_MAYBE_VIDEO_FEED;
 
       case Ci.nsIFeed.TYPE_AUDIO:
         return TYPE_MAYBE_AUDIO_FEED;
 
       default:
@@ -369,17 +369,17 @@ FeedWriter.prototype = {
     }
   },
 
   /**
    * Writes the feed title into the preview document.
    * @param   container
    *          The feed container
    */
-  _setTitleText: function FW__setTitleText(container) {
+  _setTitleText: function(container) {
     if (container.title) {
       var title = container.title.plainText();
       this._setContentText(TITLE_ID, container.title);
       this._contentSandbox.document = this._document;
       this._contentSandbox.title = title;
       var codeStr = "document.title = title;"
       Cu.evalInSandbox(codeStr, this._contentSandbox);
     }
@@ -389,17 +389,17 @@ FeedWriter.prototype = {
       this._setContentText(SUBTITLE_ID, container.subtitle);
   },
 
   /**
    * Writes the title image into the preview document if one is present.
    * @param   container
    *          The feed container
    */
-  _setTitleImage: function FW__setTitleImage(container) {
+  _setTitleImage: function(container) {
     try {
       var parts = container.image;
       
       // Set up the title image (supplied by the feed)
       var feedTitleImage = this._document.getElementById("feedTitleImage");
       this._safeSetURIAttribute(feedTitleImage, "src", 
                                 parts.getPropertyAsAString("url"));
 
@@ -431,17 +431,17 @@ FeedWriter.prototype = {
     }
   },
 
   /**
    * Writes all entries contained in the feed.
    * @param   container
    *          The container of entries in the feed
    */
-  _writeFeedContent: function FW__writeFeedContent(container) {
+  _writeFeedContent: function(container) {
     // Build the actual feed content
     var feed = container.QueryInterface(Ci.nsIFeed);
     if (feed.items.length == 0)
       return;
 
     this._contentSandbox.feedContent =
       this._document.getElementById("feedContent");
 
@@ -531,33 +531,33 @@ FeedWriter.prototype = {
    * http://example.com/foo.mpeg would return "foo.mpeg"), but in more complex
    * cases, this will return the entire url (e.g. passing in
    * http://example.com/somedirectory/ would return 
    * http://example.com/somedirectory/).
    * @param aURL
    *        The URL string from which to create a display name
    * @returns a string
    */
-  _getURLDisplayName: function FW__getURLDisplayName(aURL) {
+  _getURLDisplayName: function(aURL) {
     var url = makeURI(aURL);
     url.QueryInterface(Ci.nsIURL);
     if (url == null || url.fileName.length == 0)
       return decodeURIComponent(aURL);
 
     return decodeURIComponent(url.fileName);
   },
 
   /**
    * Takes a FeedEntry with enclosures, generates the HTML code to represent
    * them, and returns that.
    * @param   entry
    *          FeedEntry with enclosures
    * @returns element
    */
-  _buildEnclosureDiv: function FW__buildEnclosureDiv(entry) {
+  _buildEnclosureDiv: function(entry) {
     var enclosuresDiv = this._document.createElementNS(HTML_NS, "div");
     enclosuresDiv.className = "enclosures";
 
     enclosuresDiv.appendChild(this._document.createTextNode(this._getString("mediaLabel")));
 
     var roundme = function(n) {
       return (Math.round(n * 100) / 100).toLocaleString();
     }
@@ -627,17 +627,17 @@ FeedWriter.prototype = {
   /**
    * Gets a valid nsIFeedContainer object from the parsed nsIFeedResult.
    * Displays error information if there was one.
    * @param   result
    *          The parsed feed result
    * @returns A valid nsIFeedContainer object containing the contents of
    *          the feed.
    */
-  _getContainer: function FW__getContainer(result) {
+  _getContainer: function(result) {
     var feedService = 
         Cc["@mozilla.org/browser/feeds/result-service;1"].
         getService(Ci.nsIFeedResultService);
 
     try {
       var result = 
         feedService.getFeedResult(this._getOriginalURI(this._window));
     }
@@ -661,17 +661,17 @@ FeedWriter.prototype = {
 
   /**
    * Get the human-readable display name of a file. This could be the 
    * application name.
    * @param   file
    *          A nsIFile to look up the name of
    * @returns The display name of the application represented by the file.
    */
-  _getFileDisplayName: function FW__getFileDisplayName(file) {
+  _getFileDisplayName: function(file) {
 #ifdef XP_WIN
     if (file instanceof Ci.nsILocalFileWin) {
       try {
         return file.getVersionInfoField("FileDescription");
       } catch (e) {}
     }
 #endif
 #ifdef XP_MACOSX
@@ -685,17 +685,17 @@ FeedWriter.prototype = {
   },
 
   /**
    * Get moz-icon url for a file
    * @param   file
    *          A nsIFile object for which the moz-icon:// is returned
    * @returns moz-icon url of the given file as a string
    */
-  _getFileIconURL: function FW__getFileIconURL(file) {
+  _getFileIconURL: function(file) {
     var ios = Cc["@mozilla.org/network/io-service;1"].
               getService(Ci.nsIIOService);
     var fph = ios.getProtocolHandler("file")
                  .QueryInterface(Ci.nsIFileProtocolHandler);
     var urlSpec = fph.getURLSpecFromFile(file);
     return "moz-icon://" + urlSpec + "?size=16";
   },
 
@@ -715,27 +715,27 @@ FeedWriter.prototype = {
                   "menuitem.setAttribute('image', image);"
     Cu.evalInSandbox(codeStr, this._contentSandbox);
   },
 
   /**
    * Helper method to get an element in the XBL binding where the handler
    * selection UI lives
    */
-  _getUIElement: function FW__getUIElement(id) {
+  _getUIElement: function(id) {
     return this._document.getAnonymousElementByAttribute(
       this._document.getElementById("feedSubscribeLine"), "anonid", id);
   },
 
   /**
    * Displays a prompt from which the user may choose a (client) feed reader.
    * @param aCallback the callback method, passes in true if a feed reader was
    *        selected, false otherwise.
    */
-  _chooseClientApp: function FW__chooseClientApp(aCallback) {
+  _chooseClientApp: function(aCallback) {
     try {
       let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
       let fpCallback = function fpCallback_done(aResult) {
         if (aResult == Ci.nsIFilePicker.returnOK) {
           this._selectedApp = fp.file;
           if (this._selectedApp) {
             // XXXben - we need to compare this with the running instance
             //          executable just don't know how to do that via script
@@ -771,32 +771,32 @@ FeedWriter.prototype = {
       fp.init(this._window, this._getString("chooseApplicationDialogTitle"),
               Ci.nsIFilePicker.modeOpen);
       fp.appendFilters(Ci.nsIFilePicker.filterApps);
       fp.open(fpCallback);
     } catch(ex) {
     }
   },
 
-  _setAlwaysUseCheckedState: function FW__setAlwaysUseCheckedState(feedType) {
+  _setAlwaysUseCheckedState: function(feedType) {
     var checkbox = this._getUIElement("alwaysUse");
     if (checkbox) {
       var alwaysUse = false;
       try {
         var prefs = Cc["@mozilla.org/preferences-service;1"].
                     getService(Ci.nsIPrefBranch);
         if (prefs.getCharPref(getPrefActionForType(feedType)) != "ask")
           alwaysUse = true;
       }
       catch(ex) { }
       this._setCheckboxCheckedState(checkbox, alwaysUse);
     }
   },
 
-  _setSubscribeUsingLabel: function FW__setSubscribeUsingLabel() {
+  _setSubscribeUsingLabel: function() {
     var stringLabel = "subscribeFeedUsing";
     switch (this._getFeedType()) {
       case Ci.nsIFeed.TYPE_VIDEO:
         stringLabel = "subscribeVideoPodcastUsing";
         break;
 
       case Ci.nsIFeed.TYPE_AUDIO:
         stringLabel = "subscribeAudioPodcastUsing";
@@ -805,17 +805,17 @@ FeedWriter.prototype = {
 
     this._contentSandbox.subscribeUsing =
       this._getUIElement("subscribeUsingDescription");
     this._contentSandbox.label = this._getString(stringLabel);
     var codeStr = "subscribeUsing.setAttribute('value', label);"
     Cu.evalInSandbox(codeStr, this._contentSandbox);
   },
 
-  _setAlwaysUseLabel: function FW__setAlwaysUseLabel() {
+  _setAlwaysUseLabel: function() {
     var checkbox = this._getUIElement("alwaysUse");
     if (checkbox) {
       if (this._handlersMenuList) {
         var handlerName = this._getSelectedItemFromMenulist(this._handlersMenuList)
                               .getAttribute("label");
         var stringLabel = "alwaysUseForFeeds";
         switch (this._getFeedType()) {
           case Ci.nsIFeed.TYPE_VIDEO:
@@ -869,17 +869,17 @@ FeedWriter.prototype = {
           }
           break;
         default:
           this._setAlwaysUseLabel();
       }
     }
   },
 
-  _setSelectedHandler: function FW__setSelectedHandler(feedType) {
+  _setSelectedHandler: function(feedType) {
     var prefs =   
         Cc["@mozilla.org/preferences-service;1"].
         getService(Ci.nsIPrefBranch);
 
     var handler = "bookmarks";
     try {
       handler = prefs.getCharPref(getPrefReaderForType(feedType));
     }
@@ -936,17 +936,17 @@ FeedWriter.prototype = {
       default: {
         var liveBookmarksMenuItem = this._getUIElement("liveBookmarksMenuItem");
         if (liveBookmarksMenuItem)
           this._safeDoCommand(liveBookmarksMenuItem);
       } 
     }
   },
 
-  _initSubscriptionUI: function FW__initSubscriptionUI() {
+  _initSubscriptionUI: function() {
     var handlersMenuPopup = this._getUIElement("handlersMenuPopup");
     if (!handlersMenuPopup)
       return;
  
     var feedType = this._getFeedType();
     var codeStr;
 
     // change the background
@@ -1118,17 +1118,17 @@ FeedWriter.prototype = {
   },
 
   /**
    * Returns the original URI object of the feed and ensures that this
    * component is only ever invoked from the preview document.  
    * @param aWindow 
    *        The window of the document invoking the BrowserFeedWriter
    */
-  _getOriginalURI: function FW__getOriginalURI(aWindow) {
+  _getOriginalURI: function(aWindow) {
     var chan = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
                getInterface(Ci.nsIWebNavigation).
                QueryInterface(Ci.nsIDocShell).currentDocumentChannel;
 
     var nullPrincipal = Cc["@mozilla.org/nullprincipal;1"].
                         createInstance(Ci.nsIPrincipal);
 
     var resolvedURI = Cc["@mozilla.org/network/io-service;1"].
@@ -1150,17 +1150,17 @@ FeedWriter.prototype = {
 
   _window: null,
   _document: null,
   _feedURI: null,
   _feedPrincipal: null,
   _handlersMenuList: null,
 
   // BrowserFeedWriter WebIDL methods
-  init: function FW_init(aWindow) {
+  init: function(aWindow) {
     var window = aWindow;
     this._feedURI = this._getOriginalURI(window);
     if (!this._feedURI)
       return;
 
     this._window = window;
     this._document = window.document;
     this._document.getElementById("feedSubscribeLine").offsetTop;
@@ -1186,17 +1186,17 @@ FeedWriter.prototype = {
     prefs.addObserver(PREF_VIDEO_SELECTED_APP, this, false);
 
     prefs.addObserver(PREF_AUDIO_SELECTED_ACTION, this, false);
     prefs.addObserver(PREF_AUDIO_SELECTED_READER, this, false);
     prefs.addObserver(PREF_AUDIO_SELECTED_WEB, this, false);
     prefs.addObserver(PREF_AUDIO_SELECTED_APP, this, false);
   },
 
-  writeContent: function FW_writeContent() {
+  writeContent: function() {
     if (!this._window)
       return;
 
     try {
       // Set up the feed content
       var container = this._getContainer();
       if (!container)
         return;
@@ -1205,17 +1205,17 @@ FeedWriter.prototype = {
       this._setTitleImage(container);
       this._writeFeedContent(container);
     }
     finally {
       this._removeFeedFromCache();
     }
   },
 
-  close: function FW_close() {
+  close: function() {
     this._getUIElement("handlersMenuPopup")
         .removeEventListener("command", this, false);
     this._getUIElement("subscribeButton")
         .removeEventListener("command", this, false);
     this._document = null;
     this._window = null;
     var prefs = Cc["@mozilla.org/preferences-service;1"].
                 getService(Ci.nsIPrefBranch);
@@ -1235,26 +1235,26 @@ FeedWriter.prototype = {
 
     this._removeFeedFromCache();
     this.__faviconService = null;
     this.__bundle = null;
     this._feedURI = null;
     this.__contentSandbox = null;
   },
 
-  _removeFeedFromCache: function FW__removeFeedFromCache() {
+  _removeFeedFromCache: function() {
     if (this._feedURI) {
       var feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
                         getService(Ci.nsIFeedResultService);
       feedService.removeFeedResult(this._feedURI);
       this._feedURI = null;
     }
   },
 
-  subscribe: function FW_subscribe() {
+  subscribe: function() {
     var feedType = this._getFeedType();
 
     // Subscribe to the feed using the selected handler and save prefs
     var prefs = Cc["@mozilla.org/preferences-service;1"].
                 getService(Ci.nsIPrefBranch);
     var defaultHandler = "reader";
     var useAsDefault = this._getUIElement("alwaysUse").getAttribute("checked");
 
@@ -1328,17 +1328,17 @@ FeedWriter.prototype = {
         }
       }.bind(this));
     } else {
       subscribeCallback();
     }
   },
 
   // nsIObserver
-  observe: function FW_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     if (!this._window) {
       // this._window is null unless this.init was called with a trusted
       // window object.
       return;
     }
 
     var feedType = this._getFeedType();
 
diff --git a/browser/components/feeds/WebContentConverter.js b/browser/components/feeds/WebContentConverter.js
--- a/browser/components/feeds/WebContentConverter.js
+++ b/browser/components/feeds/WebContentConverter.js
@@ -34,45 +34,45 @@ const PREF_ALLOW_DIFFERENT_HOST = "gecko
 const STRING_BUNDLE_URI = "chrome://browser/locale/feeds/subscribe.properties";
 
 const NS_ERROR_MODULE_DOM = 2152923136;
 const NS_ERROR_DOM_SYNTAX_ERR = NS_ERROR_MODULE_DOM + 12;
 
 function WebContentConverter() {
 }
 WebContentConverter.prototype = {
-  convert: function WCC_convert() { },
-  asyncConvertData: function WCC_asyncConvertData() { },
-  onDataAvailable: function WCC_onDataAvailable() { },
-  onStopRequest: function WCC_onStopRequest() { },
+  convert: function() { },
+  asyncConvertData: function() { },
+  onDataAvailable: function() { },
+  onStopRequest: function() { },
   
-  onStartRequest: function WCC_onStartRequest(request, context) {
+  onStartRequest: function(request, context) {
     var wccr = 
         Cc[WCCR_CONTRACTID].
         getService(Ci.nsIWebContentConverterService);
     wccr.loadPreferredHandler(request);
   },
   
-  QueryInterface: function WCC_QueryInterface(iid) {
+  QueryInterface: function(iid) {
     if (iid.equals(Ci.nsIStreamConverter) ||
         iid.equals(Ci.nsIStreamListener) ||
         iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NO_INTERFACE;
   }
 };
 
 var WebContentConverterFactory = {
-  createInstance: function WCCF_createInstance(outer, iid) {
+  createInstance: function(outer, iid) {
     if (outer != null)
       throw Cr.NS_ERROR_NO_AGGREGATION;
     return new WebContentConverter().QueryInterface(iid);
   },
     
-  QueryInterface: function WCC_QueryInterface(iid) {
+  QueryInterface: function(iid) {
     if (iid.equals(Ci.nsIFactory) ||
         iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NO_INTERFACE;
   }
 };
 
 function ServiceInfo(contentType, uri, name) {
@@ -86,17 +86,17 @@ ServiceInfo.prototype = {
    */
   get name() {
     return this._name;
   },
   
   /**
    * See nsIHandlerApp
    */
-  equals: function SI_equals(aHandlerApp) {
+  equals: function(aHandlerApp) {
     if (!aHandlerApp)
       throw Cr.NS_ERROR_NULL_POINTER;
 
     if (aHandlerApp instanceof Ci.nsIWebContentHandlerInfo &&
         aHandlerApp.contentType == this.contentType &&
         aHandlerApp.uri == this.uri)
       return true;
 
@@ -115,21 +115,21 @@ ServiceInfo.prototype = {
    */
   get uri() {
     return this._uri;
   },
 
   /**
    * See nsIWebContentHandlerInfo
    */
-  getHandlerURI: function SI_getHandlerURI(uri) {
+  getHandlerURI: function(uri) {
     return this._uri.replace(/%s/gi, encodeURIComponent(uri));
   },
   
-  QueryInterface: function SI_QueryInterface(iid) {
+  QueryInterface: function(iid) {
     if (iid.equals(Ci.nsIWebContentHandlerInfo) ||
         iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NO_INTERFACE;
   }
 };
 
 function WebContentConverterRegistrar() {
@@ -141,21 +141,21 @@ WebContentConverterRegistrar.prototype =
   get stringBundle() {
     var sb = Cc["@mozilla.org/intl/stringbundle;1"].
               getService(Ci.nsIStringBundleService).
               createBundle(STRING_BUNDLE_URI);
     delete WebContentConverterRegistrar.prototype.stringBundle;
     return WebContentConverterRegistrar.prototype.stringBundle = sb;
   },
 
-  _getFormattedString: function WCCR__getFormattedString(key, params) {
+  _getFormattedString: function(key, params) {
     return this.stringBundle.formatStringFromName(key, params, params.length);
   },
   
-  _getString: function WCCR_getString(key) {
+  _getString: function(key) {
     return this.stringBundle.GetStringFromName(key);
   },
 
   /**
    * See nsIWebContentConverterService
    */
   getAutoHandler: 
   function WCCR_getAutoHandler(contentType) {
@@ -646,17 +646,17 @@ WebContentConverterRegistrar.prototype =
   /**
    * Determines if there is a type with a particular uri registered for the 
    * specified content type already.
    * @param   contentType
    *          The content type that the uri handles
    * @param   uri
    *          The uri of the 
    */
-  _typeIsRegistered: function WCCR__typeIsRegistered(contentType, uri) {
+  _typeIsRegistered: function(contentType, uri) {
     if (!(contentType in this._contentTypes))
       return false;
       
     var services = this._contentTypes[contentType];
     for (var i = 0; i < services.length; ++i) {
       // This uri has already been registered
       if (services[i].uri == uri)
         return true;
@@ -666,17 +666,17 @@ WebContentConverterRegistrar.prototype =
   
   /**
    * Gets a stream converter contract id for the specified content type.
    * @param   contentType
    *          The source content type for the conversion.
    * @returns A contract id to construct a converter to convert between the 
    *          contentType and *\/*.
    */
-  _getConverterContractID: function WCCR__getConverterContractID(contentType) {
+  _getConverterContractID: function(contentType) {
     const template = "@mozilla.org/streamconv;1?from=%s&to=*/*";
     return template.replace(/%s/, contentType);
   },
   
   /**
    * Register a web service handler for a content type.
    * 
    * @param   contentType
@@ -794,17 +794,17 @@ WebContentConverterRegistrar.prototype =
       // do nothing, the next branch might have values
     }
   },
 
   /**
    * Load the auto handler, content handler and protocol tables from 
    * preferences.
    */
-  _init: function WCCR__init() {
+  _init: function() {
     var ps = 
         Cc["@mozilla.org/preferences-service;1"].
         getService(Ci.nsIPrefService);
 
     var kids = ps.getBranch(PREF_CONTENTHANDLERS_BRANCH)
                  .getChildList("");
 
     // first get the numbers of the providers by getting all ###.uri prefs
@@ -844,17 +844,17 @@ WebContentConverterRegistrar.prototype =
       // No auto branch yet, that's fine
       //LOG("WCCR.init: There is no auto branch, benign");
     }
   },
 
   /**
    * See nsIObserver
    */
-  observe: function WCCR_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     var os = 
         Cc["@mozilla.org/observer-service;1"].
         getService(Ci.nsIObserverService);
     switch (topic) {
     case "app-startup":
       os.addObserver(this, "browser-ui-startup-complete", false);
       break;
     case "browser-ui-startup-complete":
@@ -862,17 +862,17 @@ WebContentConverterRegistrar.prototype =
       this._init();
       break;
     }
   },
   
   /**
    * See nsIFactory
    */
-  createInstance: function WCCR_createInstance(outer, iid) {
+  createInstance: function(outer, iid) {
     if (outer != null)
       throw Cr.NS_ERROR_NO_AGGREGATION;
     return this.QueryInterface(iid);
   },
 
   classID: WCCR_CLASSID,
 
   /**
diff --git a/browser/components/feeds/content/subscribe.js b/browser/components/feeds/content/subscribe.js
--- a/browser/components/feeds/content/subscribe.js
+++ b/browser/components/feeds/content/subscribe.js
@@ -4,20 +4,20 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 var SubscribeHandler = {
   /**
    * The nsIFeedWriter object that produces the UI
    */
   _feedWriter: null,
   
-  init: function SH_init() {
+  init: function() {
     this._feedWriter = new BrowserFeedWriter();
   },
 
-  writeContent: function SH_writeContent() {
+  writeContent: function() {
     this._feedWriter.writeContent();
   },
 
-  uninit: function SH_uninit() {
+  uninit: function() {
     this._feedWriter.close();
   }
 };
diff --git a/browser/components/loop/content/shared/libs/sdk.js b/browser/components/loop/content/shared/libs/sdk.js
--- a/browser/components/loop/content/shared/libs/sdk.js
+++ b/browser/components/loop/content/shared/libs/sdk.js
@@ -7106,17 +7106,17 @@ OT.Rumor = {
     return this;
   }
 
   TextEncoder.prototype = {
     /**
      * @param {string=} opt_string The string to encode.
      * @param {{stream: boolean}=} options
      */
-    encode: function encode(opt_string, options) {
+    encode: function(opt_string, options) {
       opt_string = opt_string ? String(opt_string) : '';
       options = Object(options);
       // TODO: any options?
       if (!this._streaming) {
         this._encoder = this._encoding.getEncoder(this._options);
       }
       this._streaming = Boolean(options.stream);
 
@@ -7176,17 +7176,17 @@ OT.Rumor = {
   // TODO: Issue if input byte stream is offset by decoder
   // TODO: BOM detection will not work if stream header spans multiple calls
   // (last N bytes of previous stream may need to be retained?)
   TextDecoder.prototype = {
     /**
      * @param {ArrayBufferView=} opt_view The buffer of bytes to decode.
      * @param {{stream: boolean}=} options
      */
-    decode: function decode(opt_view, options) {
+    decode: function(opt_view, options) {
       if (opt_view && !('buffer' in opt_view && 'byteOffset' in opt_view &&
                         'byteLength' in opt_view)) {
         throw new TypeError('Expected ArrayBufferView');
       } else if (!opt_view) {
         opt_view = new Uint8Array(0);
       }
       options = Object(options);
 
@@ -9225,55 +9225,55 @@ OT.httpTest = httpTest;
 // * m=<media> <port>/<number of ports> <proto> <fmts>
 //
 // References:
 // * https://tools.ietf.org/html/rfc4566
 // * http://en.wikipedia.org/wiki/Session_Description_Protocol
 //
 var SDPHelpers = {
   // Search through sdpLines to find the Media Line of type +mediaType+.
-  getMLineIndex: function getMLineIndex(sdpLines, mediaType) {
+  getMLineIndex: function(sdpLines, mediaType) {
     var targetMLine = 'm=' + mediaType;
 
     // Find the index of the media line for +type+
     return OT.$.findIndex(sdpLines, function(line) {
       if (line.indexOf(targetMLine) !== -1) {
         return true;
       }
 
       return false;
     });
   },
 
   // Extract the payload types for a give Media Line.
   //
-  getMLinePayloadTypes: function getMLinePayloadTypes (mediaLine, mediaType) {
+  getMLinePayloadTypes: function(mediaLine, mediaType) {
     var mLineSelector = new RegExp('^m=' + mediaType +
                           ' \\d+(/\\d+)? [a-zA-Z0-9/]+(( [a-zA-Z0-9/]+)+)$', 'i');
 
     // Get all payload types that the line supports
     var payloadTypes = mediaLine.match(mLineSelector);
     if (!payloadTypes || payloadTypes.length < 2) {
       // Error, invalid M line?
       return [];
     }
 
     return OT.$.trim(payloadTypes[2]).split(' ');
   },
 
-  removeTypesFromMLine: function removeTypesFromMLine (mediaLine, payloadTypes) {
+  removeTypesFromMLine: function(mediaLine, payloadTypes) {
     return OT.$.trim(
               mediaLine.replace(new RegExp(' ' + payloadTypes.join(' |'), 'ig') , ' ')
                        .replace(/\s+/g, ' ') );
   },
 
 
   // Remove all references to a particular encodingName from a particular media type
   //
-  removeMediaEncoding: function removeMediaEncoding (sdp, mediaType, encodingName) {
+  removeMediaEncoding: function(sdp, mediaType, encodingName) {
     var sdpLines = sdp.split('\r\n'),
         mLineIndex = SDPHelpers.getMLineIndex(sdpLines, mediaType),
         mLine = mLineIndex > -1 ? sdpLines[mLineIndex] : void 0,
         typesToRemove = [],
         payloadTypes,
         match;
 
     if (mLineIndex === -1) {
@@ -9315,21 +9315,21 @@ var SDPHelpers = {
 
     return sdpLines.join('\r\n');
   },
 
   // Removes all Confort Noise from +sdp+.
   //
   // See https://jira.tokbox.com/browse/OPENTOK-7176
   //
-  removeComfortNoise: function removeComfortNoise (sdp) {
+  removeComfortNoise: function(sdp) {
     return SDPHelpers.removeMediaEncoding(sdp, 'audio', 'CN');
   },
 
-  removeVideoCodec: function removeVideoCodec (sdp, codec) {
+  removeVideoCodec: function(sdp, codec) {
     return SDPHelpers.removeMediaEncoding(sdp, 'video', codec);
   }
 };
 
 
 
 // tb_require('../../helpers/helpers.js')
 
diff --git a/browser/components/loop/standalone/content/libs/l10n-gaia-02ca67948fe8.js b/browser/components/loop/standalone/content/libs/l10n-gaia-02ca67948fe8.js
--- a/browser/components/loop/standalone/content/libs/l10n-gaia-02ca67948fe8.js
+++ b/browser/components/loop/standalone/content/libs/l10n-gaia-02ca67948fe8.js
@@ -15,17 +15,17 @@
   }
   L10nError.prototype = Object.create(Error.prototype);
   L10nError.prototype.constructor = L10nError;
 
 
   /* jshint browser:true */
 
   var io = {
-    load: function load(url, callback, sync) {
+    load: function(url, callback, sync) {
       var xhr = new XMLHttpRequest();
 
       if (xhr.overrideMimeType) {
         xhr.overrideMimeType('text/plain');
       }
 
       xhr.open('GET', url, !sync);
 
@@ -42,17 +42,17 @@
       // the app: protocol throws on 404, see https://bugzil.la/827243
       try {
         xhr.send(null);
       } catch (e) {
         callback(new L10nError('Not found: ' + url));
       }
     },
 
-    loadJSON: function loadJSON(url, callback) {
+    loadJSON: function(url, callback) {
       var xhr = new XMLHttpRequest();
 
       if (xhr.overrideMimeType) {
         xhr.overrideMimeType('application/json');
       }
 
       xhr.open('GET', url);
 
@@ -1373,34 +1373,34 @@
     subtree: true,
     attributeFilter: ['data-l10n-id', 'data-l10n-args']
   };
 
   // Public API
 
   navigator.mozL10n = {
     ctx: new Context(),
-    get: function get(id, ctxdata) {
+    get: function(id, ctxdata) {
       return navigator.mozL10n.ctx.get(id, ctxdata);
     },
-    localize: function localize(element, id, args) {
+    localize: function(element, id, args) {
       return localizeElement.call(navigator.mozL10n, element, id, args);
     },
     translate: function () {
       // XXX: Remove after removing obsolete calls. Bugs 992473 and 1020136
     },
     translateFragment: function (fragment) {
       return translateFragment.call(navigator.mozL10n, fragment);
     },
     setAttributes: setL10nAttributes,
     getAttributes: getL10nAttributes,
-    ready: function ready(callback) {
+    ready: function(callback) {
       return navigator.mozL10n.ctx.ready(callback);
     },
-    once: function once(callback) {
+    once: function(callback) {
       return navigator.mozL10n.ctx.once(callback);
     },
     get readyState() {
       return navigator.mozL10n.ctx.isReady ? 'complete' : 'loading';
     },
     language: {
       set code(lang) {
         navigator.mozL10n.ctx.requestLocales(lang);
diff --git a/browser/components/loop/test/mochitest/browser_fxa_login.js b/browser/components/loop/test/mochitest/browser_fxa_login.js
--- a/browser/components/loop/test/mochitest/browser_fxa_login.js
+++ b/browser/components/loop/test/mochitest/browser_fxa_login.js
@@ -433,17 +433,17 @@ add_task(function* openFxASettings() {
     profile_uri: BASE_URL + "/profile",
     state: "state",
     test_error: "token_401",
   };
   yield promiseOAuthParamsSetup(BASE_URL, params);
 
   yield new Promise((resolve, reject) => {
     let progressListener = {
-      onLocationChange: function onLocationChange(aBrowser) {
+      onLocationChange: function(aBrowser) {
         if (aBrowser.currentURI.spec == BASE_URL) {
           // Ignore the changes from the addTab above.
           return;
         }
         gBrowser.removeTabsProgressListener(progressListener);
         let contentURI = Services.io.newURI(params.content_uri, null, null);
         is(aBrowser.currentURI.spec, Services.io.newURI("/settings", null, contentURI).spec,
            "Check settings tab URL");
diff --git a/browser/components/loop/test/shared/vendor/sinon-1.12.2.js b/browser/components/loop/test/shared/vendor/sinon-1.12.2.js
--- a/browser/components/loop/test/shared/vendor/sinon-1.12.2.js
+++ b/browser/components/loop/test/shared/vendor/sinon-1.12.2.js
@@ -2015,70 +2015,70 @@ var sinon = (function () {
                 msg += " Received [" + slice.call(args).join(", ") + "]";
             }
             throw new Error(msg);
         }
 
         var slice = Array.prototype.slice;
 
         var callProto = {
-            calledOn: function calledOn(thisValue) {
+            calledOn: function(thisValue) {
                 if (sinon.match && sinon.match.isMatcher(thisValue)) {
                     return thisValue.test(this.thisValue);
                 }
                 return this.thisValue === thisValue;
             },
 
-            calledWith: function calledWith() {
+            calledWith: function() {
                 for (var i = 0, l = arguments.length; i < l; i += 1) {
                     if (!sinon.deepEqual(arguments[i], this.args[i])) {
                         return false;
                     }
                 }
 
                 return true;
             },
 
-            calledWithMatch: function calledWithMatch() {
+            calledWithMatch: function() {
                 for (var i = 0, l = arguments.length; i < l; i += 1) {
                     var actual = this.args[i];
                     var expectation = arguments[i];
                     if (!sinon.match || !sinon.match(expectation).test(actual)) {
                         return false;
                     }
                 }
                 return true;
             },
 
-            calledWithExactly: function calledWithExactly() {
+            calledWithExactly: function() {
                 return arguments.length == this.args.length &&
                     this.calledWith.apply(this, arguments);
             },
 
-            notCalledWith: function notCalledWith() {
+            notCalledWith: function() {
                 return !this.calledWith.apply(this, arguments);
             },
 
-            notCalledWithMatch: function notCalledWithMatch() {
+            notCalledWithMatch: function() {
                 return !this.calledWithMatch.apply(this, arguments);
             },
 
-            returned: function returned(value) {
+            returned: function(value) {
                 return sinon.deepEqual(value, this.returnValue);
             },
 
-            threw: function threw(error) {
+            threw: function(error) {
                 if (typeof error === "undefined" || !this.exception) {
                     return !!this.exception;
                 }
 
                 return this.exception === error || this.exception.name === error;
             },
 
-            calledWithNew: function calledWithNew() {
+            calledWithNew: function() {
                 return this.proxy.prototype && this.thisValue instanceof this.proxy;
             },
 
             calledBefore: function (other) {
                 return this.callId < other.callId;
             },
 
             calledAfter: function (other) {
@@ -2308,17 +2308,17 @@ var sinon = (function () {
                 this.callIds = [];
                 if (this.fakes) {
                     for (var i = 0; i < this.fakes.length; i++) {
                         this.fakes[i].reset();
                     }
                 }
             },
 
-            create: function create(func) {
+            create: function(func) {
                 var name;
 
                 if (typeof func != "function") {
                     func = function () { };
                 } else {
                     name = sinon.functionName(func);
                 }
 
@@ -2333,17 +2333,17 @@ var sinon = (function () {
                 proxy.displayName = name || "spy";
                 proxy.toString = sinon.functionToString;
                 proxy.instantiateFake = sinon.spy.create;
                 proxy.id = "spy#" + uuid++;
 
                 return proxy;
             },
 
-            invoke: function invoke(func, thisValue, args) {
+            invoke: function(func, thisValue, args) {
                 var matching = matchingFake(this.fakes, args);
                 var exception, returnValue;
 
                 incrementCallCount.call(this);
                 push.call(this.thisValues, thisValue);
                 push.call(this.args, args);
                 push.call(this.callIds, callId++);
 
@@ -2377,22 +2377,22 @@ var sinon = (function () {
 
                 if (exception !== undefined) {
                     throw exception;
                 }
 
                 return returnValue;
             },
 
-            named: function named(name) {
+            named: function(name) {
                 this.displayName = name;
                 return this;
             },
 
-            getCall: function getCall(i) {
+            getCall: function(i) {
                 if (i < 0 || i >= this.callCount) {
                     return null;
                 }
 
                 return sinon.spyCall(this, this.thisValues[i], this.args[i],
                                         this.returnValues[i], this.exceptions[i],
                                         this.callIds[i]);
             },
@@ -2403,29 +2403,29 @@ var sinon = (function () {
 
                 for (i = 0; i < this.callCount; i++) {
                     calls.push(this.getCall(i));
                 }
 
                 return calls;
             },
 
-            calledBefore: function calledBefore(spyFn) {
+            calledBefore: function(spyFn) {
                 if (!this.called) {
                     return false;
                 }
 
                 if (!spyFn.called) {
                     return true;
                 }
 
                 return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
             },
 
-            calledAfter: function calledAfter(spyFn) {
+            calledAfter: function(spyFn) {
                 if (!this.called || !spyFn.called) {
                     return false;
                 }
 
                 return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
             },
 
             withArgs: function () {
@@ -2741,113 +2741,113 @@ var sinon = (function () {
                     });
                 } else {
                     func.apply(behavior.callbackContext, behavior.callbackArguments);
                 }
             }
         }
 
         var proto = {
-            create: function create(stub) {
+            create: function(stub) {
                 var behavior = sinon.extend({}, sinon.behavior);
                 delete behavior.create;
                 behavior.stub = stub;
 
                 return behavior;
             },
 
-            isPresent: function isPresent() {
+            isPresent: function() {
                 return (typeof this.callArgAt == "number" ||
                         this.exception ||
                         typeof this.returnArgAt == "number" ||
                         this.returnThis ||
                         this.returnValueDefined);
             },
 
-            invoke: function invoke(context, args) {
+            invoke: function(context, args) {
                 callCallback(this, args);
 
                 if (this.exception) {
                     throw this.exception;
                 } else if (typeof this.returnArgAt == "number") {
                     return args[this.returnArgAt];
                 } else if (this.returnThis) {
                     return context;
                 }
 
                 return this.returnValue;
             },
 
-            onCall: function onCall(index) {
+            onCall: function(index) {
                 return this.stub.onCall(index);
             },
 
-            onFirstCall: function onFirstCall() {
+            onFirstCall: function() {
                 return this.stub.onFirstCall();
             },
 
-            onSecondCall: function onSecondCall() {
+            onSecondCall: function() {
                 return this.stub.onSecondCall();
             },
 
-            onThirdCall: function onThirdCall() {
+            onThirdCall: function() {
                 return this.stub.onThirdCall();
             },
 
-            withArgs: function withArgs(/* arguments */) {
+            withArgs: function(/* arguments */) {
                 throw new Error("Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" is not supported. " +
                                 "Use \"stub.withArgs(...).onCall(...)\" to define sequential behavior for calls with certain arguments.");
             },
 
-            callsArg: function callsArg(pos) {
+            callsArg: function(pos) {
                 if (typeof pos != "number") {
                     throw new TypeError("argument index is not number");
                 }
 
                 this.callArgAt = pos;
                 this.callbackArguments = [];
                 this.callbackContext = undefined;
                 this.callArgProp = undefined;
                 this.callbackAsync = false;
 
                 return this;
             },
 
-            callsArgOn: function callsArgOn(pos, context) {
+            callsArgOn: function(pos, context) {
                 if (typeof pos != "number") {
                     throw new TypeError("argument index is not number");
                 }
                 if (typeof context != "object") {
                     throw new TypeError("argument context is not an object");
                 }
 
                 this.callArgAt = pos;
                 this.callbackArguments = [];
                 this.callbackContext = context;
                 this.callArgProp = undefined;
                 this.callbackAsync = false;
 
                 return this;
             },
 
-            callsArgWith: function callsArgWith(pos) {
+            callsArgWith: function(pos) {
                 if (typeof pos != "number") {
                     throw new TypeError("argument index is not number");
                 }
 
                 this.callArgAt = pos;
                 this.callbackArguments = slice.call(arguments, 1);
                 this.callbackContext = undefined;
                 this.callArgProp = undefined;
                 this.callbackAsync = false;
 
                 return this;
             },
 
-            callsArgOnWith: function callsArgWith(pos, context) {
+            callsArgOnWith: function(pos, context) {
                 if (typeof pos != "number") {
                     throw new TypeError("argument index is not number");
                 }
                 if (typeof context != "object") {
                     throw new TypeError("argument context is not an object");
                 }
 
                 this.callArgAt = pos;
@@ -2905,34 +2905,34 @@ var sinon = (function () {
                 this.callbackAsync = false;
 
                 return this;
             },
 
             throws: throwsException,
             throwsException: throwsException,
 
-            returns: function returns(value) {
+            returns: function(value) {
                 this.returnValue = value;
                 this.returnValueDefined = true;
 
                 return this;
             },
 
-            returnsArg: function returnsArg(pos) {
+            returnsArg: function(pos) {
                 if (typeof pos != "number") {
                     throw new TypeError("argument index is not number");
                 }
 
                 this.returnArgAt = pos;
 
                 return this;
             },
 
-            returnsThis: function returnsThis() {
+            returnsThis: function() {
                 this.returnThis = true;
 
                 return this;
             }
         };
 
         // create asynchronous versions of callsArg* and yields* methods
         for (var method in proto) {
@@ -3031,17 +3031,17 @@ var sinon = (function () {
         function getCurrentBehavior(stub) {
             var behavior = stub.behaviors[stub.callCount - 1];
             return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stub);
         }
 
         var uuid = 0;
 
         var proto = {
-            create: function create() {
+            create: function() {
                 var functionStub = function () {
                     return getCurrentBehavior(functionStub).invoke(this, arguments);
                 };
 
                 functionStub.id = "stub#" + uuid++;
                 var orig = functionStub;
                 functionStub = sinon.spy.create(functionStub);
                 functionStub.func = orig;
@@ -3069,33 +3069,33 @@ var sinon = (function () {
 
                 if (this.fakes) {
                     for (i = 0; i < this.fakes.length; i++) {
                         this.fakes[i].resetBehavior();
                     }
                 }
             },
 
-            onCall: function onCall(index) {
+            onCall: function(index) {
                 if (!this.behaviors[index]) {
                     this.behaviors[index] = sinon.behavior.create(this);
                 }
 
                 return this.behaviors[index];
             },
 
-            onFirstCall: function onFirstCall() {
+            onFirstCall: function() {
                 return this.onCall(0);
             },
 
-            onSecondCall: function onSecondCall() {
+            onSecondCall: function() {
                 return this.onCall(1);
             },
 
-            onThirdCall: function onThirdCall() {
+            onThirdCall: function() {
                 return this.onCall(2);
             }
         };
 
         for (var method in sinon.behavior) {
             if (sinon.behavior.hasOwnProperty(method) &&
                 !proto.hasOwnProperty(method) &&
                 method != "create" &&
@@ -3173,29 +3173,29 @@ var sinon = (function () {
             }
 
             for (var i = 0, l = collection.length; i < l; i += 1) {
                 callback(collection[i]);
             }
         }
 
         sinon.extend(mock, {
-            create: function create(object) {
+            create: function(object) {
                 if (!object) {
                     throw new TypeError("object is null");
                 }
 
                 var mockObject = sinon.extend({}, mock);
                 mockObject.object = object;
                 delete mockObject.create;
 
                 return mockObject;
             },
 
-            expects: function expects(method) {
+            expects: function(method) {
                 if (!method) {
                     throw new TypeError("method is falsy");
                 }
 
                 if (!this.expectations) {
                     this.expectations = {};
                     this.proxies = [];
                 }
@@ -3212,27 +3212,27 @@ var sinon = (function () {
                 }
 
                 var expectation = sinon.expectation.create(method);
                 push.call(this.expectations[method], expectation);
 
                 return expectation;
             },
 
-            restore: function restore() {
+            restore: function() {
                 var object = this.object;
 
                 each(this.proxies, function (proxy) {
                     if (typeof object[proxy].restore == "function") {
                         object[proxy].restore();
                     }
                 });
             },
 
-            verify: function verify() {
+            verify: function() {
                 var expectations = this.expectations || {};
                 var messages = [], met = [];
 
                 each(this.proxies, function (proxy) {
                     each(expectations[proxy], function (expectation) {
                         if (!expectation.met()) {
                             push.call(messages, expectation.toString());
                         } else {
@@ -3247,17 +3247,17 @@ var sinon = (function () {
                     sinon.expectation.fail(messages.concat(met).join("\n"));
                 } else if (met.length > 0) {
                     sinon.expectation.pass(messages.concat(met).join("\n"));
                 }
 
                 return true;
             },
 
-            invokeMethod: function invokeMethod(method, thisValue, args) {
+            invokeMethod: function(method, thisValue, args) {
                 var expectations = this.expectations && this.expectations[method];
                 var length = expectations && expectations.length || 0, i;
 
                 for (i = 0; i < length; i += 1) {
                     if (!expectations[i].met() &&
                         expectations[i].allowsCall(thisValue, args)) {
                         return expectations[i].apply(thisValue, args);
                     }
@@ -3339,90 +3339,90 @@ var sinon = (function () {
                 return true;
             }
         }
 
         sinon.expectation = {
             minCalls: 1,
             maxCalls: 1,
 
-            create: function create(methodName) {
+            create: function(methodName) {
                 var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);
                 delete expectation.create;
                 expectation.method = methodName;
 
                 return expectation;
             },
 
-            invoke: function invoke(func, thisValue, args) {
+            invoke: function(func, thisValue, args) {
                 this.verifyCallAllowed(thisValue, args);
 
                 return sinon.spy.invoke.apply(this, arguments);
             },
 
-            atLeast: function atLeast(num) {
+            atLeast: function(num) {
                 if (typeof num != "number") {
                     throw new TypeError("'" + num + "' is not number");
                 }
 
                 if (!this.limitsSet) {
                     this.maxCalls = null;
                     this.limitsSet = true;
                 }
 
                 this.minCalls = num;
 
                 return this;
             },
 
-            atMost: function atMost(num) {
+            atMost: function(num) {
                 if (typeof num != "number") {
                     throw new TypeError("'" + num + "' is not number");
                 }
 
                 if (!this.limitsSet) {
                     this.minCalls = null;
                     this.limitsSet = true;
                 }
 
                 this.maxCalls = num;
 
                 return this;
             },
 
-            never: function never() {
+            never: function() {
                 return this.exactly(0);
             },
 
-            once: function once() {
+            once: function() {
                 return this.exactly(1);
             },
 
-            twice: function twice() {
+            twice: function() {
                 return this.exactly(2);
             },
 
-            thrice: function thrice() {
+            thrice: function() {
                 return this.exactly(3);
             },
 
-            exactly: function exactly(num) {
+            exactly: function(num) {
                 if (typeof num != "number") {
                     throw new TypeError("'" + num + "' is not a number");
                 }
 
                 this.atLeast(num);
                 return this.atMost(num);
             },
 
-            met: function met() {
+            met: function() {
                 return !this.failed && receivedMinCalls(this);
             },
 
-            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {
+            verifyCallAllowed: function(thisValue, args) {
                 if (receivedMaxCalls(this)) {
                     this.failed = true;
                     sinon.expectation.fail(this.method + " already called " + times(this.maxCalls));
                 }
 
                 if ("expectedThis" in this && this.expectedThis !== thisValue) {
                     sinon.expectation.fail(this.method + " called with " + thisValue + " as thisValue, expected " +
                         this.expectedThis);
@@ -3457,17 +3457,17 @@ var sinon = (function () {
 
                     if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                         sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                             ", expected " + sinon.format(this.expectedArguments));
                     }
                 }
             },
 
-            allowsCall: function allowsCall(thisValue, args) {
+            allowsCall: function(thisValue, args) {
                 if (this.met() && receivedMaxCalls(this)) {
                     return false;
                 }
 
                 if ("expectedThis" in this && this.expectedThis !== thisValue) {
                     return false;
                 }
 
@@ -3494,28 +3494,28 @@ var sinon = (function () {
                     if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                         return false;
                     }
                 }
 
                 return true;
             },
 
-            withArgs: function withArgs() {
+            withArgs: function() {
                 this.expectedArguments = slice.call(arguments);
                 return this;
             },
 
-            withExactArgs: function withExactArgs() {
+            withExactArgs: function() {
                 this.withArgs.apply(this, arguments);
                 this.expectsExactArgCount = true;
                 return this;
             },
 
-            on: function on(thisValue) {
+            on: function(thisValue) {
                 this.expectedThis = thisValue;
                 return this;
             },
 
             toString: function () {
                 var args = (this.expectedArguments || []).slice();
 
                 if (!this.expectsExactArgCount) {
@@ -3533,31 +3533,31 @@ var sinon = (function () {
                 if (this.met()) {
                     return "Expectation met: " + message;
                 }
 
                 return "Expected " + message + " (" +
                     callCountInWords(this.callCount) + ")";
             },
 
-            verify: function verify() {
+            verify: function() {
                 if (!this.met()) {
                     sinon.expectation.fail(this.toString());
                 } else {
                     sinon.expectation.pass(this.toString());
                 }
 
                 return true;
             },
 
-            pass: function pass(message) {
+            pass: function(message) {
                 sinon.assert.pass(message);
             },
 
-            fail: function fail(message) {
+            fail: function(message) {
                 var exception = new Error(message);
                 exception.name = "ExpectationError";
 
                 throw exception;
             }
         };
 
         sinon.mock = mock;
@@ -3627,55 +3627,55 @@ var sinon = (function () {
         var i = 0;
         while (i < fakes.length) {
             fakes.splice(i, 1);
         }
     }
 
     function makeApi(sinon) {
         var collection = {
-            verify: function resolve() {
+            verify: function() {
                 each(this, "verify");
             },
 
-            restore: function restore() {
+            restore: function() {
                 each(this, "restore");
                 compact(this);
             },
 
-            reset: function restore() {
+            reset: function() {
                 each(this, "reset");
             },
 
-            verifyAndRestore: function verifyAndRestore() {
+            verifyAndRestore: function() {
                 var exception;
 
                 try {
                     this.verify();
                 } catch (e) {
                     exception = e;
                 }
 
                 this.restore();
 
                 if (exception) {
                     throw exception;
                 }
             },
 
-            add: function add(fake) {
+            add: function(fake) {
                 push.call(getFakes(this), fake);
                 return fake;
             },
 
-            spy: function spy() {
+            spy: function() {
                 return this.add(sinon.spy.apply(sinon, arguments));
             },
 
-            stub: function stub(object, property, value) {
+            stub: function(object, property, value) {
                 if (property) {
                     var original = object[property];
 
                     if (typeof original != "function") {
                         if (!hasOwnProperty.call(object, property)) {
                             throw new TypeError("Cannot stub non-existent own property " + property);
                         }
 
@@ -3698,21 +3698,21 @@ var sinon = (function () {
                     }
 
                     return stubbedObj;
                 }
 
                 return this.add(sinon.stub.apply(sinon, arguments));
             },
 
-            mock: function mock() {
+            mock: function() {
                 return this.add(sinon.mock.apply(sinon, arguments));
             },
 
-            inject: function inject(obj) {
+            inject: function(obj) {
                 var col = this;
 
                 obj.spy = function () {
                     return col.spy.apply(col, arguments);
                 };
 
                 obj.stub = function () {
                     return col.stub.apply(col, arguments);
@@ -3884,33 +3884,33 @@ if (typeof sinon == "undefined") {
             this.detail = customData.detail || null;
         };
 
         sinon.CustomEvent.prototype = new sinon.Event();
 
         sinon.CustomEvent.prototype.constructor =  sinon.CustomEvent;
 
         sinon.EventTarget = {
-            addEventListener: function addEventListener(event, listener) {
+            addEventListener: function(event, listener) {
                 this.eventListeners = this.eventListeners || {};
                 this.eventListeners[event] = this.eventListeners[event] || [];
                 push.call(this.eventListeners[event], listener);
             },
 
-            removeEventListener: function removeEventListener(event, listener) {
+            removeEventListener: function(event, listener) {
                 var listeners = this.eventListeners && this.eventListeners[event] || [];
 
                 for (var i = 0, l = listeners.length; i < l; ++i) {
                     if (listeners[i] == listener) {
                         return listeners.splice(i, 1);
                     }
                 }
             },
 
-            dispatchEvent: function dispatchEvent(event) {
+            dispatchEvent: function(event) {
                 var type = event.type;
                 var listeners = this.eventListeners && this.eventListeners[type] || [];
 
                 for (var i = 0; i < listeners.length; i++) {
                     if (typeof listeners[i] == "function") {
                         listeners[i].call(this, event);
                     } else {
                         listeners[i].handleEvent(event);
@@ -4334,17 +4334,17 @@ if (typeof sinon == "undefined") {
     };
 
     function makeApi(sinon) {
         sinon.xhr = sinonXhr;
 
         sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {
             async: true,
 
-            open: function open(method, url, async, username, password) {
+            open: function(method, url, async, username, password) {
                 this.method = method;
                 this.url = url;
                 this.async = typeof async == "boolean" ? async : true;
                 this.username = username;
                 this.password = password;
                 this.responseText = null;
                 this.responseXML = null;
                 this.requestHeaders = {};
@@ -4357,17 +4357,17 @@ if (typeof sinon == "undefined") {
                     });
                     if (defake) {
                         return FakeXMLHttpRequest.defake(this, arguments);
                     }
                 }
                 this.readyStateChange(FakeXMLHttpRequest.OPENED);
             },
 
-            readyStateChange: function readyStateChange(state) {
+            readyStateChange: function(state) {
                 this.readyState = state;
 
                 if (typeof this.onreadystatechange == "function") {
                     try {
                         this.onreadystatechange();
                     } catch (e) {
                         sinon.logError("Fake XHR onreadystatechange handler", e);
                     }
@@ -4382,32 +4382,32 @@ if (typeof sinon == "undefined") {
                         this.upload.dispatchEvent(new sinon.Event("load", false, false, this));
                         if (supportsProgress) {
                             this.upload.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
                         }
                         break;
                 }
             },
 
-            setRequestHeader: function setRequestHeader(header, value) {
+            setRequestHeader: function(header, value) {
                 verifyState(this);
 
                 if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {
                     throw new Error("Refused to set unsafe header \"" + header + "\"");
                 }
 
                 if (this.requestHeaders[header]) {
                     this.requestHeaders[header] += "," + value;
                 } else {
                     this.requestHeaders[header] = value;
                 }
             },
 
             // Helps testing
-            setResponseHeaders: function setResponseHeaders(headers) {
+            setResponseHeaders: function(headers) {
                 verifyRequestOpened(this);
                 this.responseHeaders = {};
 
                 for (var header in headers) {
                     if (headers.hasOwnProperty(header)) {
                         this.responseHeaders[header] = headers[header];
                     }
                 }
@@ -4415,17 +4415,17 @@ if (typeof sinon == "undefined") {
                 if (this.async) {
                     this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);
                 } else {
                     this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;
                 }
             },
 
             // Currently treats ALL data as a DOMString (i.e. no Document)
-            send: function send(data) {
+            send: function(data) {
                 verifyState(this);
 
                 if (!/^(get|head)$/i.test(this.method)) {
                     var contentType = getHeader(this.requestHeaders, "Content-Type");
                     if (this.requestHeaders[contentType]) {
                         var value = this.requestHeaders[contentType].split(";");
                         this.requestHeaders[contentType] = value[0] + ";charset=utf-8";
                     } else {
@@ -4441,17 +4441,17 @@ if (typeof sinon == "undefined") {
 
                 if (typeof this.onSend == "function") {
                     this.onSend(this);
                 }
 
                 this.dispatchEvent(new sinon.Event("loadstart", false, false, this));
             },
 
-            abort: function abort() {
+            abort: function() {
                 this.aborted = true;
                 this.responseText = null;
                 this.errorFlag = true;
                 this.requestHeaders = {};
 
                 if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {
                     this.readyStateChange(FakeXMLHttpRequest.DONE);
                     this.sendFlag = false;
@@ -4463,48 +4463,48 @@ if (typeof sinon == "undefined") {
 
                 this.upload.dispatchEvent(new sinon.Event("abort", false, false, this));
 
                 if (typeof this.onerror === "function") {
                     this.onerror();
                 }
             },
 
-            getResponseHeader: function getResponseHeader(header) {
+            getResponseHeader: function(header) {
                 if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
                     return null;
                 }
 
                 if (/^Set-Cookie2?$/i.test(header)) {
                     return null;
                 }
 
                 header = getHeader(this.responseHeaders, header);
 
                 return this.responseHeaders[header] || null;
             },
 
-            getAllResponseHeaders: function getAllResponseHeaders() {
+            getAllResponseHeaders: function() {
                 if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
                     return "";
                 }
 
                 var headers = "";
 
                 for (var header in this.responseHeaders) {
                     if (this.responseHeaders.hasOwnProperty(header) &&
                         !/^Set-Cookie2?$/i.test(header)) {
                         headers += header + ": " + this.responseHeaders[header] + "\r\n";
                     }
                 }
 
                 return headers;
             },
 
-            setResponseBody: function setResponseBody(body) {
+            setResponseBody: function(body) {
                 verifyRequestSent(this);
                 verifyHeadersReceived(this);
                 verifyResponseBodyType(body);
 
                 var chunkSize = this.chunkSize || 10;
                 var index = 0;
                 this.responseText = "";
 
@@ -4526,30 +4526,30 @@ if (typeof sinon == "undefined") {
                     } catch (e) {
                         // Unable to parse XML - no biggie
                     }
                 }
 
                 this.readyStateChange(FakeXMLHttpRequest.DONE);
             },
 
-            respond: function respond(status, headers, body) {
+            respond: function(status, headers, body) {
                 this.status = typeof status == "number" ? status : 200;
                 this.statusText = FakeXMLHttpRequest.statusCodes[this.status];
                 this.setResponseHeaders(headers || {});
                 this.setResponseBody(body || "");
             },
 
-            uploadProgress: function uploadProgress(progressEventRaw) {
+            uploadProgress: function(progressEventRaw) {
                 if (supportsProgress) {
                     this.upload.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
                 }
             },
 
-            uploadError: function uploadError(error) {
+            uploadError: function(error) {
                 if (supportsCustomEvent) {
                     this.upload.dispatchEvent(new sinon.CustomEvent("error", {detail: error}));
                 }
             }
         });
 
         sinon.extend(FakeXMLHttpRequest, {
             UNSENT: 0,
@@ -4704,17 +4704,17 @@ if (typeof sinon == "undefined") {
 
                 this.xhr.onCreate = function (xhrObj) {
                     server.addRequest(xhrObj);
                 };
 
                 return server;
             },
 
-            addRequest: function addRequest(xhrObj) {
+            addRequest: function(xhrObj) {
                 var server = this;
                 push.call(this.requests, xhrObj);
 
                 xhrObj.onSend = function () {
                     server.handleRequest(this);
 
                     if (server.autoRespond && !server.responding) {
                         setTimeout(function () {
@@ -4722,47 +4722,47 @@ if (typeof sinon == "undefined") {
                             server.respond();
                         }, server.autoRespondAfter || 10);
 
                         server.responding = true;
                     }
                 };
             },
 
-            getHTTPMethod: function getHTTPMethod(request) {
+            getHTTPMethod: function(request) {
                 if (this.fakeHTTPMethods && /post/i.test(request.method)) {
                     var matches = (request.requestBody || "").match(/_method=([^\b;]+)/);
                     return !!matches ? matches[1] : request.method;
                 }
 
                 return request.method;
             },
 
-            handleRequest: function handleRequest(xhr) {
+            handleRequest: function(xhr) {
                 if (xhr.async) {
                     if (!this.queue) {
                         this.queue = [];
                     }
 
                     push.call(this.queue, xhr);
                 } else {
                     this.processRequest(xhr);
                 }
             },
 
-            log: function log(response, request) {
+            log: function(response, request) {
                 var str;
 
                 str =  "Request:\n"  + sinon.format(request)  + "\n\n";
                 str += "Response:\n" + sinon.format(response) + "\n\n";
 
                 sinon.log(str);
             },
 
-            respondWith: function respondWith(method, url, body) {
+            respondWith: function(method, url, body) {
                 if (arguments.length == 1 && typeof method != "function") {
                     this.response = responseArray(method);
                     return;
                 }
 
                 if (!this.responses) { this.responses = []; }
 
                 if (arguments.length == 1) {
@@ -4778,31 +4778,31 @@ if (typeof sinon == "undefined") {
 
                 push.call(this.responses, {
                     method: method,
                     url: url,
                     response: typeof body == "function" ? body : responseArray(body)
                 });
             },
 
-            respond: function respond() {
+            respond: function() {
                 if (arguments.length > 0) {
                     this.respondWith.apply(this, arguments);
                 }
 
                 var queue = this.queue || [];
                 var requests = queue.splice(0, queue.length);
                 var request;
 
                 while (request = requests.shift()) {
                     this.processRequest(request);
                 }
             },
 
-            processRequest: function processRequest(request) {
+            processRequest: function(request) {
                 try {
                     if (request.aborted) {
                         return;
                     }
 
                     var response = this.response || [404, {}, ""];
 
                     if (this.responses) {
@@ -4819,17 +4819,17 @@ if (typeof sinon == "undefined") {
 
                         request.respond(response[0], response[1], response[2]);
                     }
                 } catch (e) {
                     sinon.logError("Fake server request processing", e);
                 }
             },
 
-            restore: function restore() {
+            restore: function() {
                 return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);
             }
         };
     }
 
     var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";
     var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;
 
@@ -5002,25 +5002,25 @@ if (typeof sinon == "undefined") {
                     sandbox.useFakeTimers();
                 }
             }
 
             return sandbox;
         }
 
         sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {
-            useFakeTimers: function useFakeTimers() {
+            useFakeTimers: function() {
                 this.clock = sinon.useFakeTimers.apply(sinon, arguments);
 
                 return this.add(this.clock);
             },
 
             serverPrototype: sinon.fakeServer,
 
-            useFakeServer: function useFakeServer() {
+            useFakeServer: function() {
                 var proto = this.serverPrototype || sinon.fakeServer;
 
                 if (!proto || !proto.create) {
                     return null;
                 }
 
                 this.server = proto.create();
                 return this.add(this.server);
@@ -5397,26 +5397,26 @@ if (typeof sinon == "undefined") {
         function exposedName(prefix, prop) {
             return !prefix || /^fail/.test(prop) ? prop :
                 prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
         }
 
         assert = {
             failException: "AssertError",
 
-            fail: function fail(message) {
+            fail: function(message) {
                 var error = new Error(message);
                 error.name = this.failException || assert.failException;
 
                 throw error;
             },
 
-            pass: function pass(assertion) {},
-
-            callOrder: function assertCallOrder() {
+            pass: function(assertion) {},
+
+            callOrder: function() {
                 verifyIsStub.apply(null, arguments);
                 var expected = "", actual = "";
 
                 if (!sinon.calledInOrder(arguments)) {
                     try {
                         expected = [].join.call(arguments, ", ");
                         var calls = slice.call(arguments);
                         var i = calls.length;
@@ -5432,29 +5432,29 @@ if (typeof sinon == "undefined") {
 
                     failAssertion(this, "expected " + expected + " to be " +
                                 "called in order but were called as " + actual);
                 } else {
                     assert.pass("callOrder");
                 }
             },
 
-            callCount: function assertCallCount(method, count) {
+            callCount: function(method, count) {
                 verifyIsStub(method);
 
                 if (method.callCount != count) {
                     var msg = "expected %n to be called " + sinon.timesInWords(count) +
                         " but was called %c%C";
                     failAssertion(this, method.printf(msg));
                 } else {
                     assert.pass("callCount");
                 }
             },
 
-            expose: function expose(target, options) {
+            expose: function(target, options) {
                 if (!target) {
                     throw new TypeError("target is null or undefined");
                 }
 
                 var o = options || {};
                 var prefix = typeof o.prefix == "undefined" && "assert" || o.prefix;
                 var includeFail = typeof o.includeFail == "undefined" || !!o.includeFail;
 
@@ -5462,17 +5462,17 @@ if (typeof sinon == "undefined") {
                     if (method != "expose" && (includeFail || !/^(fail)/.test(method))) {
                         target[exposedName(prefix, method)] = this[method];
                     }
                 }
 
                 return target;
             },
 
-            match: function match(actual, expectation) {
+            match: function(actual, expectation) {
                 var matcher = sinon.match(expectation);
                 if (matcher.test(actual)) {
                     assert.pass("match");
                 } else {
                     var formatted = [
                         "expected value to match",
                         "    expected = " + sinon.format(expectation),
                         "    actual = " + sinon.format(actual)
@@ -5588,27 +5588,27 @@ if (typeof sinon == "undefined") {
                 var error = new Error("Attempted to respond to fake XDomainRequest with " +
                                     body + ", which is not a string.");
                 error.name = "InvalidBodyException";
                 throw error;
             }
         }
 
         sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {
-            open: function open(method, url) {
+            open: function(method, url) {
                 this.method = method;
                 this.url = url;
 
                 this.responseText = null;
                 this.sendFlag = false;
 
                 this.readyStateChange(FakeXDomainRequest.OPENED);
             },
 
-            readyStateChange: function readyStateChange(state) {
+            readyStateChange: function(state) {
                 this.readyState = state;
                 var eventName = "";
                 switch (this.readyState) {
                 case FakeXDomainRequest.UNSENT:
                     break;
                 case FakeXDomainRequest.OPENED:
                     break;
                 case FakeXDomainRequest.LOADING:
@@ -5635,70 +5635,70 @@ if (typeof sinon == "undefined") {
                             this[eventName]();
                         } catch (e) {
                             sinon.logError("Fake XHR " + eventName + " handler", e);
                         }
                     }
                 }
             },
 
-            send: function send(data) {
+            send: function(data) {
                 verifyState(this);
 
                 if (!/^(get|head)$/i.test(this.method)) {
                     this.requestBody = data;
                 }
                 this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";
 
                 this.errorFlag = false;
                 this.sendFlag = true;
                 this.readyStateChange(FakeXDomainRequest.OPENED);
 
                 if (typeof this.onSend == "function") {
                     this.onSend(this);
                 }
             },
 
-            abort: function abort() {
+            abort: function() {
                 this.aborted = true;
                 this.responseText = null;
                 this.errorFlag = true;
 
                 if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {
                     this.readyStateChange(sinon.FakeXDomainRequest.DONE);
                     this.sendFlag = false;
                 }
             },
 
-            setResponseBody: function setResponseBody(body) {
+            setResponseBody: function(body) {
                 verifyRequestSent(this);
                 verifyResponseBodyType(body);
 
                 var chunkSize = this.chunkSize || 10;
                 var index = 0;
                 this.responseText = "";
 
                 do {
                     this.readyStateChange(FakeXDomainRequest.LOADING);
                     this.responseText += body.substring(index, index + chunkSize);
                     index += chunkSize;
                 } while (index < body.length);
 
                 this.readyStateChange(FakeXDomainRequest.DONE);
             },
 
-            respond: function respond(status, contentType, body) {
+            respond: function(status, contentType, body) {
                 // content-type ignored, since XDomainRequest does not carry this
                 // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease
                 // test integration across browsers
                 this.status = typeof status == "number" ? status : 200;
                 this.setResponseBody(body || "");
             },
 
-            simulatetimeout: function simulatetimeout() {
+            simulatetimeout: function() {
                 this.status = 0;
                 this.isTimeout = true;
                 // Access to this should actually throw an error
                 this.responseText = undefined;
                 this.readyStateChange(FakeXDomainRequest.DONE);
             }
         });
 
diff --git a/browser/components/migration/ChromeProfileMigrator.js b/browser/components/migration/ChromeProfileMigrator.js
--- a/browser/components/migration/ChromeProfileMigrator.js
+++ b/browser/components/migration/ChromeProfileMigrator.js
@@ -100,17 +100,17 @@ ChromeProfileMigrator.prototype.getResou
                                  GetCookiesResource(profileFolder)];
         return [r for each (r in possibleResources) if (r != null)];
       }
     }
     return [];
   };
 
 Object.defineProperty(ChromeProfileMigrator.prototype, "sourceProfiles", {
-  get: function Chrome_sourceProfiles() {
+  get: function() {
     if ("__sourceProfiles" in this)
       return this.__sourceProfiles;
 
     if (!this._chromeUserDataFolder)
       return [];
 
     let profiles = [];
     try {
@@ -152,17 +152,17 @@ Object.defineProperty(ChromeProfileMigra
     return this.__sourceProfiles = profiles.filter(function(profile) {
       let resources = this.getResources(profile);
       return resources && resources.length > 0;
     }, this);
   }
 });
 
 Object.defineProperty(ChromeProfileMigrator.prototype, "sourceHomePageURL", {
-  get: function Chrome_sourceHomePageURL() {
+  get: function() {
     let prefsFile = this._chromeUserDataFolder.clone();
     prefsFile.append("Preferences");
     if (prefsFile.exists()) {
       // XXX reading and parsing JSON is synchronous.
       let fstream = Cc[FILE_INPUT_STREAM_CID].
                     createInstance(Ci.nsIFileInputStream);
       fstream.init(file, -1, 0, 0);
       try {
diff --git a/browser/components/migration/IEProfileMigrator.js b/browser/components/migration/IEProfileMigrator.js
--- a/browser/components/migration/IEProfileMigrator.js
+++ b/browser/components/migration/IEProfileMigrator.js
@@ -29,17 +29,17 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 let CtypesHelpers = {
   _structs: {},
   _functions: {},
   _libs: {},
 
   /**
    * Must be invoked once before first use of any of the provided helpers.
    */
-  initialize: function CH_initialize() {
+  initialize: function() {
     const WORD = ctypes.uint16_t;
     const DWORD = ctypes.uint32_t;
     const BOOL = ctypes.int;
 
     this._structs.SYSTEMTIME = new ctypes.StructType('SYSTEMTIME', [
       {wYear: WORD},
       {wMonth: WORD},
       {wDayOfWeek: WORD},
@@ -66,17 +66,17 @@ let CtypesHelpers = {
     } catch (ex) {
       this.finalize();
     }
   },
 
   /**
    * Must be invoked once after last use of any of the provided helpers.
    */
-  finalize: function CH_finalize() {
+  finalize: function() {
     this._structs = {};
     this._functions = {};
     for each (let lib in this._libs) {
       try {
         lib.close();
       } catch (ex) {}
     }
     this._libs = {};
@@ -86,17 +86,17 @@ let CtypesHelpers = {
    * Converts a FILETIME struct (2 DWORDS), to a SYSTEMTIME struct.
    *
    * @param aTimeHi
    *        Least significant DWORD.
    * @param aTimeLo
    *        Most significant DWORD.
    * @return a Date object representing the converted datetime.
    */
-  fileTimeToDate: function CH_fileTimeToDate(aTimeHi, aTimeLo) {
+  fileTimeToDate: function(aTimeHi, aTimeLo) {
     let fileTime = this._structs.FILETIME();
     fileTime.dwLowDateTime = aTimeLo;
     fileTime.dwHighDateTime = aTimeHi;
     let systemTime = this._structs.SYSTEMTIME();
     let result = this._functions.FileTimeToSystemTime(fileTime.address(),
                                                       systemTime.address());
     if (result == 0)
       throw new Error(ctypes.winLastError);
@@ -157,34 +157,34 @@ Bookmarks.prototype = {
       let folderName = WindowsRegistry.readRegKey(Ci.nsIWindowsRegKey.ROOT_KEY_CURRENT_USER,
                                                   "Software\\Microsoft\\Internet Explorer\\Toolbar",
                                                   "LinksFolderName");
       this.__toolbarFolderName = folderName || "Links";
     }
     return this.__toolbarFolderName;
   },
 
-  migrate: function B_migrate(aCallback) {
+  migrate: function(aCallback) {
     PlacesUtils.bookmarks.runInBatchMode({
       runBatched: (function migrateBatched() {
         // Import to the bookmarks menu.
         let destFolderId = PlacesUtils.bookmarksMenuFolderId;
         if (!MigrationUtils.isStartupMigration) {
           destFolderId =
             MigrationUtils.createImportedBookmarksFolder("IE", destFolderId);
         }
 
         this._migrateFolder(this._favoritesFolder, destFolderId);
 
         aCallback(true);
       }).bind(this)
     }, null);
   },
 
-  _migrateFolder: function B__migrateFolder(aSourceFolder, aDestFolderId) {
+  _migrateFolder: function(aSourceFolder, aDestFolderId) {
     // TODO (bug 741993): the favorites order is stored in the Registry, at
     // HCU\Software\Microsoft\Windows\CurrentVersion\Explorer\MenuOrder\Favorites
     // Until we support it, bookmarks are imported in alphabetical order.
     let entries = aSourceFolder.directoryEntries;
     while (entries.hasMoreElements()) {
       let entry = entries.getNext().QueryInterface(Ci.nsIFile);
       try {
         // Make sure that entry.path == entry.target to not follow .lnk folder
@@ -266,17 +266,17 @@ History.prototype = {
       } catch (ex) {
       } finally {
         registry.close();
       }
     }
     return this.__typedURLs;
   },
 
-  migrate: function H_migrate(aCallback) {
+  migrate: function(aCallback) {
     let places = [];
     let historyEnumerator = Cc["@mozilla.org/profile/migrator/iehistoryenumerator;1"].
                             createInstance(Ci.nsISimpleEnumerator);
     while (historyEnumerator.hasMoreElements()) {
       let entry = historyEnumerator.getNext().QueryInterface(Ci.nsIPropertyBag2);
       let uri = entry.get("uri").QueryInterface(Ci.nsIURI);
       // MSIE stores some types of URLs in its history that we don't handle,
       // like HTMLHelp and others.  Since we don't properly map handling for
@@ -352,17 +352,17 @@ Cookies.prototype = {
           cookiesFolder.append("Low");
         }
         this.__cookiesFolder = cookiesFolder;
       }
     }
     return this.__cookiesFolder;
   },
 
-  migrate: function C_migrate(aCallback) {
+  migrate: function(aCallback) {
     CtypesHelpers.initialize();
 
     let cookiesGenerator = (function genCookie() {
       let success = false;
       let entries = this._cookiesFolder.directoryEntries;
       while (entries.hasMoreElements()) {
         let entry = entries.getNext().QueryInterface(Ci.nsIFile);
         // Skip eventual bogus entries.
@@ -383,17 +383,17 @@ Cookies.prototype = {
 
       CtypesHelpers.finalize();
 
       aCallback(success);
     }).apply(this);
     cookiesGenerator.next();
   },
 
-  _readCookieFile: function C__readCookieFile(aFile, aCallback) {
+  _readCookieFile: function(aFile, aCallback) {
     let fileReader = Cc["@mozilla.org/files/filereader;1"].
                      createInstance(Ci.nsIDOMFileReader);
     fileReader.addEventListener("loadend", (function onLoadEnd() {
       fileReader.removeEventListener("loadend", onLoadEnd, false);
 
       if (fileReader.readyState != fileReader.DONE) {
         Cu.reportError("Could not read cookie contents: " + fileReader.error);
         aCallback(false);
@@ -426,17 +426,17 @@ Cookies.prototype = {
    *  - Expiration time most significant integer
    *  - Expiration time least significant integer
    *  - Creation time most significant integer
    *  - Creation time least significant integer
    *  - Record delimiter "*"
    *
    * @note All the times are in FILETIME format.
    */
-  _parseCookieBuffer: function C__parseCookieBuffer(aTextBuffer) {
+  _parseCookieBuffer: function(aTextBuffer) {
     // Note the last record is an empty string.
     let records = [r for each (r in aTextBuffer.split("*\n")) if (r)];
     for (let record of records) {
       let [name, value, hostpath, flags,
            expireTimeLo, expireTimeHi] = record.split("\n");
 
       // IE stores deleted cookies with a zero-length value, skip them.
       if (value.length == 0)
@@ -473,17 +473,17 @@ Cookies.prototype = {
 function Settings() {
 }
 
 Settings.prototype = {
   type: MigrationUtils.resourceTypes.SETTINGS,
 
   get exists() true,
 
-  migrate: function S_migrate(aCallback) {
+  migrate: function(aCallback) {
     // Converts from yes/no to a boolean.
     function yesNoToBoolean(v) v == "yes";
 
     // Converts source format like "en-us,ar-kw;q=0.7,ar-om;q=0.3" into
     // destination format like "en-us, ar-kw, ar-om".
     // Final string is sorted by quality (q=) param.
     function parseAcceptLanguageList(v) {
       return v.match(/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/gi)
@@ -561,17 +561,17 @@ Settings.prototype = {
    *        Registry path under HKCU.
    * @param aKey
    *        Name of the key.
    * @param aPref
    *        Firefox preference.
    * @param [optional] aTransformFn
    *        Conversion function from the Registry format to the pref format.
    */
-  _set: function S__set(aPath, aKey, aPref, aTransformFn) {
+  _set: function(aPath, aKey, aPref, aTransformFn) {
     let value = WindowsRegistry.readRegKey(Ci.nsIWindowsRegKey.ROOT_KEY_CURRENT_USER,
                                            aPath, aKey);
     // Don't import settings that have never been flipped.
     if (value === undefined)
       return;
 
     if (aTransformFn)
       value = aTransformFn(value);
@@ -607,17 +607,17 @@ IEProfileMigrator.prototype.getResources
   , new History()
   , new Cookies()
   , new Settings()
   ];
   return [r for each (r in resources) if (r.exists)];
 };
 
 Object.defineProperty(IEProfileMigrator.prototype, "sourceHomePageURL", {
-  get: function IE_get_sourceHomePageURL() {
+  get: function() {
     let defaultStartPage = WindowsRegistry.readRegKey(Ci.nsIWindowsRegKey.ROOT_KEY_LOCAL_MACHINE,
                                                       kMainKey, "Default_Page_URL");
     let startPage = WindowsRegistry.readRegKey(Ci.nsIWindowsRegKey.ROOT_KEY_CURRENT_USER,
                                                kMainKey, "Start Page");
     // If the user didn't customize the Start Page, he is still on the default
     // page, that may be considered the equivalent of our about:home.  There's
     // no reason to retain it, since it is heavily targeted to IE.
     let homepage = startPage != defaultStartPage ? startPage : "";
diff --git a/browser/components/migration/MigrationUtils.jsm b/browser/components/migration/MigrationUtils.jsm
--- a/browser/components/migration/MigrationUtils.jsm
+++ b/browser/components/migration/MigrationUtils.jsm
@@ -141,17 +141,17 @@ this.MigratorPrototype = {
    *
    * @param aProfile
    *        The profile from which data may be imported, or an empty string
    *        in the case of a single-profile migrator.
    *        In the case of multiple-profiles migrator, it is guaranteed that
    *        aProfile is a value returned by the sourceProfiles getter (see
    *        above).
    */
-  getResources: function MP_getResources(aProfile) {
+  getResources: function(aProfile) {
     throw new Error("getResources must be overridden");
   },
 
   /**
    * OVERRIDE IF AND ONLY IF the migrator is a startup-only migrator (For now,
    * that is just the Firefox migrator, see bug 737381).  Default: false.
    *
    * Startup-only migrators are different in two ways:
@@ -170,28 +170,28 @@ this.MigratorPrototype = {
   get sourceHomePageURL() "",
 
   /**
    * DO NOT OVERRIDE - After deCOMing migration, the UI will just call
    * getResources.
    *
    * @see nsIBrowserProfileMigrator
    */
-  getMigrateData: function MP_getMigrateData(aProfile) {
+  getMigrateData: function(aProfile) {
     let types = [r.type for each (r in this._getMaybeCachedResources(aProfile))];
     return types.reduce(function(a, b) a |= b, 0);
   },
 
   /**
    * DO NOT OVERRIDE - After deCOMing migration, the UI will just call
    * migrate for each resource.
    *
    * @see nsIBrowserProfileMigrator
    */
-  migrate: function MP_migrate(aItems, aStartup, aProfile) {
+  migrate: function(aItems, aStartup, aProfile) {
     let resources = this._getMaybeCachedResources(aProfile);
     if (resources.length == 0)
       throw new Error("migrate called for a non-existent source");
 
     if (aItems != Ci.nsIBrowserProfileMigrator.ALL)
       resources = [r for each (r in resources) if (aItems & r.type)];
 
     // Called either directly or through the bookmarks import callback.
@@ -307,17 +307,17 @@ this.MigratorPrototype = {
     }
     catch(ex) {
       Cu.reportError(ex);
     }
     return exists;
   },
 
   /*** PRIVATE STUFF - DO NOT OVERRIDE ***/
-  _getMaybeCachedResources: function PMB__getMaybeCachedResources(aProfile) {
+  _getMaybeCachedResources: function(aProfile) {
     let profileKey = aProfile ? aProfile.id : "";
     if (this._resourcesByProfile) {
       if (profileKey in this._resourcesByProfile)
         return this._resourcesByProfile[profileKey];
     }
     else {
       this._resourcesByProfile = { };
     }
@@ -367,17 +367,17 @@ this.MigrationUtils = Object.freeze({
    * @param aFunction
    *        the function that will be called sometime later.  If aFunction
    *        throws when it's called, aCallback(false) is called, otherwise
    *        aCallback(true) is called.
    * @param aCallback
    *        the callback function passed to |migrate|.
    * @return the wrapped function.
    */
-  wrapMigrateFunction: function MU_wrapMigrateFunction(aFunction, aCallback) {
+  wrapMigrateFunction: function(aFunction, aCallback) {
     return function() {
       let success = false;
       try {
         aFunction.apply(null, arguments);
         success = true;
       }
       catch(ex) {
         Cu.reportError(ex);
@@ -400,17 +400,17 @@ this.MigrationUtils = Object.freeze({
    * @param aKey
    *        The key of the string to retrieve.
    * @param aReplacemts
    *        [optioanl] Array of replacements to run on the retrieved string.
    * @return the retrieved string.
    *
    * @see nsIStringBundle
    */
-  getLocalizedString: function MU_getLocalizedString(aKey, aReplacements) {
+  getLocalizedString: function(aKey, aReplacements) {
     const OVERRIDES = {
       "4_firefox": "4_firefox_history_and_bookmarks",
       "64_firefox": "64_firefox_other"
     };
     aKey = OVERRIDES[aKey] || aKey;
 
     if (aReplacements === undefined)
       return getMigrationBundle().GetStringFromName(aKey);
@@ -455,17 +455,17 @@ this.MigrationUtils = Object.freeze({
    * If null is returned,  either no data can be imported
    * for the given migrator, or aMigratorKey is invalid  (e.g. ie on mac,
    * or mosaic everywhere).  This method should be used rather than direct
    * getService for future compatibility (see bug 718280).
    *
    * @return profile migrator implementing nsIBrowserProfileMigrator, if it can
    *         import any data, null otherwise.
    */
-  getMigrator: function MU_getMigrator(aKey) {
+  getMigrator: function(aKey) {
     let migrator = null;
     if (this._migrators.has(aKey)) {
       migrator = this._migrators.get(aKey);
     }
     else {
       try {
         migrator = Cc["@mozilla.org/profile/migrator;1?app=browser&type=" +
                       aKey].createInstance(Ci.nsIBrowserProfileMigrator);
@@ -623,14 +623,14 @@ this.MigrationUtils = Object.freeze({
     params.appendElement(skipImportSourcePageBool, false);
 
     this.showMigrationWizard(null, params);
   },
 
   /**
    * Cleans up references to migrators and nsIProfileInstance instances.
    */
-  finishMigration: function MU_finishMigration() {
+  finishMigration: function() {
     gMigrators = null;
     gProfileStartup = null;
     gMigrationBundle = null;
   }
 });
diff --git a/browser/components/migration/SafariProfileMigrator.js b/browser/components/migration/SafariProfileMigrator.js
--- a/browser/components/migration/SafariProfileMigrator.js
+++ b/browser/components/migration/SafariProfileMigrator.js
@@ -26,17 +26,17 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/FormHistory.jsm");
 
 function Bookmarks(aBookmarksFile) {
   this._file = aBookmarksFile;
 }
 Bookmarks.prototype = {
   type: MigrationUtils.resourceTypes.BOOKMARKS,
 
-  migrate: function B_migrate(aCallback) {
+  migrate: function(aCallback) {
     PropertyListUtils.read(this._file,
       MigrationUtils.wrapMigrateFunction(function migrateBookmarks(aDict) {
         if (!aDict)
           throw new Error("Could not read Bookmarks.plist");
 
         let children = aDict.get("Children");;
         if (!children)
           throw new Error("Invalid Bookmarks.plist format");
@@ -60,17 +60,17 @@ Bookmarks.prototype = {
   /**
    * Recursively migrate a Safari collection of bookmarks.
    *
    * @param aEntries
    *        the collection's children
    * @param aCollection
    *        one of the values above.
    */
-  _migrateCollection: function B__migrateCollection(aEntries, aCollection) {
+  _migrateCollection: function(aEntries, aCollection) {
     // A collection of bookmarks in Safari resembles places roots.  In the
     // property list files (Bookmarks.plist, ReadingList.plist) they are
     // stored as regular bookmarks folders, and thus can only be distinguished
     // from by their names and places in the hierarchy.
 
     let entriesFiltered = [];
     if (aCollection == this.ROOT_COLLECTION) {
       for (let entry of aEntries) {
@@ -141,17 +141,17 @@ Bookmarks.prototype = {
         throw new Error("Unexpected value for aCollection!");
     }
 
     this._migrateEntries(entriesFiltered, folder);
   },
 
   // migrate the given array of safari bookmarks to the given places
   // folder.
-  _migrateEntries: function B__migrateEntries(aEntries, aFolderId) {
+  _migrateEntries: function(aEntries, aFolderId) {
     for (let entry of aEntries) {
       let type = entry.get("WebBookmarkType");
       if (type == "WebBookmarkTypeList" && entry.has("Children")) {
         let title = entry.get("Title");
         let folderId = PlacesUtils.bookmarks.createFolder(
            aFolderId, title, PlacesUtils.bookmarks.DEFAULT_INDEX);
 
         // Empty folders may not have a children array.
@@ -182,28 +182,28 @@ function History(aHistoryFile) {
   this._file = aHistoryFile;
 }
 History.prototype = {
   type: MigrationUtils.resourceTypes.HISTORY,
 
   // Helper method for converting the visit date property to a PRTime value.
   // The visit date is stored as a string, so it's not read as a Date
   // object by PropertyListUtils.
-  _parseCocoaDate: function H___parseCocoaDate(aCocoaDateStr) {
+  _parseCocoaDate: function(aCocoaDateStr) {
     let asDouble = parseFloat(aCocoaDateStr);
     if (!isNaN(asDouble)) {
       // reference date of NSDate.
       let date = new Date("1 January 2001, GMT");
       date.setMilliseconds(asDouble * 1000);
       return date * 1000;
     }
     return 0;
   },
 
-  migrate: function H_migrate(aCallback) {
+  migrate: function(aCallback) {
     PropertyListUtils.read(this._file, function migrateHistory(aDict) {
       try {
         if (!aDict)
           throw new Error("Could not read history property list");
         if (!aDict.has("WebHistoryDates"))
           throw new Error("Unexpected history-property list format");
 
         // Safari's History file contains only top-level urls.  It does not
@@ -264,17 +264,17 @@ History.prototype = {
 function MainPreferencesPropertyList(aPreferencesFile) {
   this._file = aPreferencesFile;
   this._callbacks = [];
 }
 MainPreferencesPropertyList.prototype = {
   /**
    * @see PropertyListUtils.read
    */
-  read: function MPPL_read(aCallback) {
+  read: function(aCallback) {
     if ("_dict" in this) {
       aCallback(this._dict);
       return;
     }
 
     let alreadyReading = this._callbacks.length > 0;
     this._callbacks.push(aCallback);
     if (!alreadyReading) {
@@ -290,17 +290,17 @@ MainPreferencesPropertyList.prototype = 
         }
         this._callbacks.splice(0);
       }.bind(this));
     }
   },
 
   // Workaround for nsIBrowserProfileMigrator.sourceHomePageURL until
   // it's replaced with an async method.
-  _readSync: function MPPL__readSync() {
+  _readSync: function() {
     if ("_dict" in this)
       return this._dict;
   
     let inputStream = Cc["@mozilla.org/network/file-input-stream;1"].
                       createInstance(Ci.nsIFileInputStream);
     inputStream.init(this._file, -1, -1, 0);
     let binaryStream = Cc["@mozilla.org/binaryinputstream;1"].
                        createInstance(Ci.nsIBinaryInputStream);
@@ -313,17 +313,17 @@ MainPreferencesPropertyList.prototype = 
 };
 
 function Preferences(aMainPreferencesPropertyListInstance) {
   this._mainPreferencesPropertyList = aMainPreferencesPropertyListInstance;
 }
 Preferences.prototype = {
   type: MigrationUtils.resourceTypes.SETTINGS,
 
-  migrate: function MPR_migrate(aCallback) {
+  migrate: function(aCallback) {
     this._mainPreferencesPropertyList.read(aDict => {
       Task.spawn(function* () {
         if (!aDict)
           throw new Error("Could not read preferences file");
 
         this._dict = aDict;
 
         let invert = function(webkitVal) !webkitVal;
@@ -377,17 +377,17 @@ Preferences.prototype = {
    * @param [optional] aConvertFunction(aSafariValue)
    *        a function that converts the safari-preference value to the
    *        appropriate value for aMozPref.  If it's not passed, then the
    *        Safari value is set as is.
    *        If aConvertFunction returns undefined, then aMozPref is not set
    *        at all.
    * @return whether or not aMozPref was set.
    */
-  _set: function MPR_set(aSafariKey, aMozPref, aConvertFunction) {
+  _set: function(aSafariKey, aMozPref, aConvertFunction) {
     if (this._dict.has(aSafariKey)) {
       let safariVal = this._dict.get(aSafariKey);
       let mozVal = aConvertFunction !== undefined ?
                    aConvertFunction(safariVal) : safariVal;
       switch (typeof(mozVal)) {
         case "string":
           Services.prefs.setCharPref(aMozPref, mozVal);
           break;
@@ -424,17 +424,17 @@ Preferences.prototype = {
   //     (1) The default charset preference is set.
   //     (2) It's not a unicode charset.
   // For now, we use the language implied by the system locale as the
   // lang-group. The only exception is minimal font size, which is an
   // accessibility preference in Safari (under the Advanced tab). If it is set,
   // we set it for all languages.
   // As for the font type of the default font (serif/sans-serif), the default
   // type for the given language is used (set in font.default.LANGGROUP).
-  _migrateFontSettings: function MPR__migrateFontSettings() {
+  _migrateFontSettings: function() {
     // If "Never use font sizes smaller than [ ] is set", migrate it for all
     // languages.
     if (this._dict.has("WebKitMinimumFontSize")) {
       let minimumSize = this._dict.get("WebKitMinimumFontSize");
       if (typeof(minimumSize) == "number") {
         let prefs = Services.prefs.getChildList("font.minimum-size");
         for (let pref of prefs) {
           Services.prefs.setIntPref(pref, minimumSize);
@@ -460,17 +460,17 @@ Preferences.prototype = {
 
     // If we set font settings for a particular language, we'll also set the
     // fonts dialog to open with the fonts settings for that langauge.
     if (anySet)
       Services.prefs.setCharPref("font.language.group", lang);
   },
 
   // Get the language group for the system locale.
-  _getLocaleLangGroup: function MPR__getLocaleLangGroup() {
+  _getLocaleLangGroup: function() {
     let locale = Services.locale.getLocaleComponentForUserAgent();
 
     // See nsLanguageAtomService::GetLanguageGroup
     let localeLangGroup = "x-unicode";
     let bundle = Services.strings.createBundle(
       "resource://gre/res/langGroups.properties");
     try {
       localeLangGroup = bundle.GetStringFromName(locale);
@@ -520,17 +520,17 @@ Preferences.prototype = {
 };
 
 function SearchStrings(aMainPreferencesPropertyListInstance) {
   this._mainPreferencesPropertyList = aMainPreferencesPropertyListInstance;
 }
 SearchStrings.prototype = {
   type: MigrationUtils.resourceTypes.OTHERDATA,
 
-  migrate: function SS_migrate(aCallback) {
+  migrate: function(aCallback) {
     this._mainPreferencesPropertyList.read(MigrationUtils.wrapMigrateFunction(
       function migrateSearchStrings(aDict) {
         if (!aDict)
           throw new Error("Could not get preferences dictionary");
 
         if (aDict.has("RecentSearchStrings")) {
           let recentSearchStrings = aDict.get("RecentSearchStrings");
           if (recentSearchStrings && recentSearchStrings.length > 0) {
@@ -550,17 +550,17 @@ SearchStrings.prototype = {
 // property list.
 // For the Windows version, check Preferences.migrate.
 function WebFoundationCookieBehavior(aWebFoundationFile) {
   this._file = aWebFoundationFile;
 }
 WebFoundationCookieBehavior.prototype = {
   type: MigrationUtils.resourceTypes.SETTINGS,
 
-  migrate: function WFPL_migrate(aCallback) {
+  migrate: function(aCallback) {
     PropertyListUtils.read(this._file, MigrationUtils.wrapMigrateFunction(
       function migrateCookieBehavior(aDict) {
         if (!aDict)
           throw new Error("Could not read com.apple.WebFoundation.plist");
 
         if (aDict.has("NSHTTPAcceptCookies")) {
           // Setting                    Safari          Firefox
           // Always Accept              always          0
@@ -630,17 +630,17 @@ SafariProfileMigrator.prototype.getResou
   if (wfFile.exists())
     resources.push(new WebFoundationCookieBehavior(wfFile));
 #endif
 
   return resources;
 };
 
 Object.defineProperty(SafariProfileMigrator.prototype, "mainPreferencesPropertyList", {
-  get: function get_mainPreferencesPropertyList() {
+  get: function() {
     if (this._mainPreferencesPropertyList === undefined) {
       let file = 
 #ifdef XP_MACOSX
         FileUtils.getDir("UsrPrfs", [], false);
 #else
         FileUtils.getDir("AppData", ["Apple Computer", "Preferences"], false);
 #endif
       if (file.exists()) {
@@ -652,17 +652,17 @@ Object.defineProperty(SafariProfileMigra
       }
       return this._mainPreferencesPropertyList = null;
     }
     return this._mainPreferencesPropertyList;
   }
 });
 
 Object.defineProperty(SafariProfileMigrator.prototype, "sourceHomePageURL", {
-  get: function get_sourceHomePageURL() {
+  get: function() {
     if (this.mainPreferencesPropertyList) {
       let dict = this.mainPreferencesPropertyList._readSync();
       if (dict.has("HomePage"))
         return dict.get("HomePage");
     }
     return "";
   }
 });
diff --git a/browser/components/nsBrowserContentHandler.js b/browser/components/nsBrowserContentHandler.js
--- a/browser/components/nsBrowserContentHandler.js
+++ b/browser/components/nsBrowserContentHandler.js
@@ -298,17 +298,17 @@ function doSearch(searchTerm, cmdLine) {
 }
 
 function nsBrowserContentHandler() {
 }
 nsBrowserContentHandler.prototype = {
   classID: Components.ID("{5d0ce354-df01-421a-83fb-7ead0990c24e}"),
 
   _xpcom_factory: {
-    createInstance: function bch_factory_ci(outer, iid) {
+    createInstance: function(outer, iid) {
       if (outer)
         throw Components.results.NS_ERROR_NO_AGGREGATION;
       return gBrowserContentHandler.QueryInterface(iid);
     }
   },
 
   /* helper functions */
 
@@ -328,17 +328,17 @@ nsBrowserContentHandler.prototype = {
 
   /* nsISupports */
   QueryInterface : XPCOMUtils.generateQI([nsICommandLineHandler,
                                           nsIBrowserHandler,
                                           nsIContentHandler,
                                           nsICommandLineValidator]),
 
   /* nsICommandLineHandler */
-  handle : function bch_handle(cmdLine) {
+  handle : function(cmdLine) {
     if (cmdLine.handleFlag("browser", false)) {
       // Passing defaultArgs, so use NO_EXTERNAL_URIS
       openWindow(null, this.chromeURL, "_blank",
                  "chrome,dialog=no,all" + this.getFeatures(cmdLine),
                  this.defaultArgs, NO_EXTERNAL_URIS);
       cmdLine.preventDefault = true;
     }
 
@@ -550,17 +550,17 @@ nsBrowserContentHandler.prototype = {
       uri = Services.prefs.getComplexValue("browser.startup.homepage",
                                            nsIPrefLocalizedString).data;
     }
     return uri;
   },
 
   mFeatures : null,
 
-  getFeatures : function bch_features(cmdLine) {
+  getFeatures : function(cmdLine) {
     if (this.mFeatures === null) {
       this.mFeatures = "";
 
       try {
         var width = cmdLine.handleFlagWithParam("width", false);
         var height = cmdLine.handleFlagWithParam("height", false);
 
         if (width)
@@ -578,17 +578,17 @@ nsBrowserContentHandler.prototype = {
       }
     }
 
     return this.mFeatures;
   },
 
   /* nsIContentHandler */
 
-  handleContent : function bch_handleContent(contentType, context, request) {
+  handleContent : function(contentType, context, request) {
     try {
       var webNavInfo = Components.classes["@mozilla.org/webnavigation-info;1"]
                                  .getService(nsIWebNavigationInfo);
       if (!webNavInfo.isTypeSupported(contentType, null)) {
         throw NS_ERROR_WONT_HANDLE_CONTENT;
       }
     } catch (e) {
       throw NS_ERROR_WONT_HANDLE_CONTENT;
@@ -596,17 +596,17 @@ nsBrowserContentHandler.prototype = {
 
     request.QueryInterface(nsIChannel);
     handURIToExistingBrowser(request.URI,
       nsIBrowserDOMWindow.OPEN_DEFAULTWINDOW, null);
     request.cancel(NS_BINDING_ABORTED);
   },
 
   /* nsICommandLineValidator */
-  validate : function bch_validate(cmdLine) {
+  validate : function(cmdLine) {
     // Other handlers may use osint so only handle the osint flag if the url
     // flag is also present and the command line is valid.
     var osintFlagIdx = cmdLine.findFlag("osint", false);
     var urlFlagIdx = cmdLine.findFlag("url", false);
     if (urlFlagIdx > -1 && (osintFlagIdx > -1 ||
         cmdLine.state == nsICommandLine.STATE_REMOTE_EXPLICIT)) {
       var urlParam = cmdLine.getArgument(urlFlagIdx + 1);
       if (cmdLine.length != urlFlagIdx + 2 || /firefoxurl:/.test(urlParam))
@@ -648,30 +648,30 @@ function handURIToExistingBrowser(uri, l
 
 function nsDefaultCommandLineHandler() {
 }
 
 nsDefaultCommandLineHandler.prototype = {
   classID: Components.ID("{47cd0651-b1be-4a0f-b5c4-10e5a573ef71}"),
 
   /* nsISupports */
-  QueryInterface : function dch_QI(iid) {
+  QueryInterface : function(iid) {
     if (!iid.equals(nsISupports) &&
         !iid.equals(nsICommandLineHandler))
       throw Components.results.NS_ERROR_NO_INTERFACE;
 
     return this;
   },
 
 #ifdef XP_WIN
   _haveProfile: false,
 #endif
 
   /* nsICommandLineHandler */
-  handle : function dch_handle(cmdLine) {
+  handle : function(cmdLine) {
     var urilist = [];
 
 #ifdef XP_WIN
     // If we don't have a profile selected yet (e.g. the Profile Manager is
     // displayed) we will crash if we open an url and then select a profile. To
     // prevent this handle all url command line flags and set the command line's
     // preventDefault to true to prevent the display of the ui. The initial
     // command line will be retained when nsAppRunner calls LaunchChild though
diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -183,17 +183,17 @@ function recordDefaultSearchEngine() {
 
   let engines = Services.telemetry.getKeyedHistogramById("SEARCH_DEFAULT_ENGINE");
   engines.add(name, true)
 }
 
 // Factory object
 const BrowserGlueServiceFactory = {
   _instance: null,
-  createInstance: function BGSF_createInstance(outer, iid) {
+  createInstance: function(outer, iid) {
     if (outer != null)
       throw Components.results.NS_ERROR_NO_AGGREGATION;
     return this._instance == null ?
       this._instance = new BrowserGlue() : this._instance;
   }
 };
 
 // Constructor
@@ -227,30 +227,30 @@ function BrowserGlue() {
 BrowserGlue.prototype = {
   _saveSession: false,
   _isPlacesInitObserver: false,
   _isPlacesLockedObserver: false,
   _isPlacesShutdownObserver: false,
   _isPlacesDatabaseLocked: false,
   _migrationImportsDefaultBookmarks: false,
 
-  _setPrefToSaveSession: function BG__setPrefToSaveSession(aForce) {
+  _setPrefToSaveSession: function(aForce) {
     if (!this._saveSession && !aForce)
       return;
 
     Services.prefs.setBoolPref("browser.sessionstore.resume_session_once", true);
 
     // This method can be called via [NSApplication terminate:] on Mac, which
     // ends up causing prefs not to be flushed to disk, so we need to do that
     // explicitly here. See bug 497652.
     Services.prefs.savePrefFile(null);
   },
 
 #ifdef MOZ_SERVICES_SYNC
-  _setSyncAutoconnectDelay: function BG__setSyncAutoconnectDelay() {
+  _setSyncAutoconnectDelay: function() {
     // Assume that a non-zero value for services.sync.autoconnectDelay should override
     if (Services.prefs.prefHasUserValue("services.sync.autoconnectDelay")) {
       let prefDelay = Services.prefs.getIntPref("services.sync.autoconnectDelay");
 
       if (prefDelay > 0)
         return;
     }
 
@@ -264,17 +264,17 @@ BrowserGlue.prototype = {
     delay = delay <= MAX_DELAY ? delay : MAX_DELAY;
 
     Cu.import("resource://services-sync/main.js");
     Weave.Service.scheduler.delayedAutoConnect(delay);
   },
 #endif
 
   // nsIObserver implementation
-  observe: function BG_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     switch (topic) {
       case "prefservice:after-app-defaults":
         this._onAppDefaults();
         break;
       case "final-ui-startup":
         this._finalUIStartup();
         break;
       case "browser-delayed-startup-finished":
@@ -497,17 +497,17 @@ BrowserGlue.prototype = {
     // to catch both cases (search service initialization occurring before and
     // after final-ui-startup)
     if (Services.search.isInitialized) {
       Services.search.defaultEngine = Services.search.currentEngine;
     }
   },
 
   // initialization (called on application startup) 
-  _init: function BG__init() {
+  _init: function() {
     let os = Services.obs;
     os.addObserver(this, "prefservice:after-app-defaults", false);
     os.addObserver(this, "final-ui-startup", false);
     os.addObserver(this, "browser-delayed-startup-finished", false);
     os.addObserver(this, "sessionstore-windows-restored", false);
     os.addObserver(this, "browser:purge-session-history", false);
     os.addObserver(this, "quit-application-requested", false);
     os.addObserver(this, "quit-application-granted", false);
@@ -536,17 +536,17 @@ BrowserGlue.prototype = {
     os.addObserver(this, "browser-search-service", false);
     os.addObserver(this, "restart-in-safe-mode", false);
     os.addObserver(this, "flash-plugin-hang", false);
 
     this._flashHangCount = 0;
   },
 
   // cleanup (called on application shutdown)
-  _dispose: function BG__dispose() {
+  _dispose: function() {
     let os = Services.obs;
     os.removeObserver(this, "prefservice:after-app-defaults");
     os.removeObserver(this, "final-ui-startup");
     os.removeObserver(this, "sessionstore-windows-restored");
     os.removeObserver(this, "browser:purge-session-history");
     os.removeObserver(this, "quit-application-requested");
     os.removeObserver(this, "quit-application-granted");
     os.removeObserver(this, "restart-in-safe-mode");
@@ -580,23 +580,23 @@ BrowserGlue.prototype = {
       // may have already been removed by the observer
     } catch (ex) {}
 #ifdef NIGHTLY_BUILD
     Services.prefs.removeObserver(POLARIS_ENABLED, this);
 #endif
     os.removeObserver(this, "flash-plugin-hang");
   },
 
-  _onAppDefaults: function BG__onAppDefaults() {
+  _onAppDefaults: function() {
     // apply distribution customizations (prefs)
     // other customizations are applied in _finalUIStartup()
     this._distributionCustomizer.applyPrefDefaults();
   },
 
-  _notifySlowAddon: function BG_notifySlowAddon(addonId) {
+  _notifySlowAddon: function(addonId) {
     let addonCallback = function(addon) {
       if (!addon) {
         Cu.reportError("couldn't look up addon: " + addonId);
         return;
       }
       let win = RecentWindow.getMostRecentBrowserWindow();
 
       if (!win) {
@@ -658,17 +658,17 @@ BrowserGlue.prototype = {
                                              priority, buttons);
       }
     };
     AddonManager.getAddonByID(addonId, addonCallback);
   },
 
   // runs on startup, before the first command line handler is invoked
   // (i.e. before the first window is opened)
-  _finalUIStartup: function BG__finalUIStartup() {
+  _finalUIStartup: function() {
     this._sanitizer.onStartup();
     // check if we're in safe mode
     if (Services.appinfo.inSafeMode) {
       Services.ww.openWindow(null, "chrome://browser/content/safeMode.xul", 
                              "_blank", "chrome,centerscreen,modal,resizable=no", null);
     }
 
     // apply distribution customizations
@@ -739,17 +739,17 @@ BrowserGlue.prototype = {
       let acceptableAge = Services.prefs.getIntPref("app.update.checkInstallTime.days") * millisecondsIn24Hours;
 
       if (buildDate + acceptableAge < today) {
         Cc["@mozilla.org/updates/update-service;1"].getService(Ci.nsIApplicationUpdateService).checkForBackgroundUpdates();
       }
     }
   },
 
-  _onSafeModeRestart: function BG_onSafeModeRestart() {
+  _onSafeModeRestart: function() {
     // prompt the user to confirm
     let strings = Services.strings.createBundle("chrome://browser/locale/browser.properties");
     let promptTitle = strings.GetStringFromName("safeModeRestartPromptTitle");
     let promptMessage = strings.GetStringFromName("safeModeRestartPromptMessage");
     let restartText = strings.GetStringFromName("safeModeRestartButton");
     let buttonFlags = (Services.prompt.BUTTON_POS_0 *
                        Services.prompt.BUTTON_TITLE_IS_STRING) +
                       (Services.prompt.BUTTON_POS_1 *
@@ -879,17 +879,17 @@ BrowserGlue.prototype = {
 #endif
     if (SCALING_PROBE_NAME) {
       let scaling = aWindow.devicePixelRatio * 100;
       Services.telemetry.getHistogramById(SCALING_PROBE_NAME).add(scaling);
     }
   },
 
   // the first browser window has finished initializing
-  _onFirstWindowLoaded: function BG__onFirstWindowLoaded(aWindow) {
+  _onFirstWindowLoaded: function(aWindow) {
     // Initialize PdfJs when running in-process and remote. This only
     // happens once since PdfJs registers global hooks. If the PdfJs
     // extension is installed the init method below will be overridden
     // leaving initialization to the extension.
     // parent only: configure default prefs, set up pref observers, register
     // pdf content handler, and initializes parent side message manager
     // shim for privileged api access.
     PdfJs.init(true);
@@ -1002,17 +1002,17 @@ BrowserGlue.prototype = {
     // Register targets
     SimpleServiceDiscovery.registerDevice(rokuDevice);
 
     // Search for devices continuously every 120 seconds
     SimpleServiceDiscovery.search(120 * 1000);
   },
 
   // All initial windows have opened.
-  _onWindowsRestored: function BG__onWindowsRestored() {
+  _onWindowsRestored: function() {
 #ifdef MOZ_DEV_EDITION
     this._createExtraDefaultProfile();
 #endif
 
     this._initServiceDiscovery();
 
     // Show update notification, if needed.
     if (Services.prefs.prefHasUserValue("app.update.postupdate"))
@@ -1111,17 +1111,17 @@ BrowserGlue.prototype = {
         }).then(null, e => {
           Cu.reportError("Could not empty profile 'default': " + e);
         });
       }
     }
   },
 #endif
 
-  _onQuitRequest: function BG__onQuitRequest(aCancelQuit, aQuitType) {
+  _onQuitRequest: function(aCancelQuit, aQuitType) {
     // If user has already dismissed quit request, then do nothing
     if ((aCancelQuit instanceof Ci.nsISupportsPRBool) && aCancelQuit.data)
       return;
 
     // There are several cases where we won't show a dialog here:
     // 1. There is only 1 tab open in 1 window
     // 2. The session will be restored at startup, indicated by
     //    browser.startup.page == 3 or browser.sessionstore.resume_session_once == true
@@ -1245,17 +1245,17 @@ BrowserGlue.prototype = {
       if (neverAsk.value) {
         // always save state when shutting down
         Services.prefs.setIntPref("browser.startup.page", 3);
       }
       break;
     }
   },
 
-  _showUpdateNotification: function BG__showUpdateNotification() {
+  _showUpdateNotification: function() {
     Services.prefs.clearUserPref("app.update.postupdate");
 
     var um = Cc["@mozilla.org/updates/update-manager;1"].
              getService(Ci.nsIUpdateManager);
     try {
       // If the updates.xml file is deleted then getUpdateAt will throw.
       var update = um.getUpdateAt(0).QueryInterface(Ci.nsIPropertyBag);
     }
@@ -1357,17 +1357,17 @@ BrowserGlue.prototype = {
       // be displayed per the idl.
       notifier.showAlertNotification(null, title, text,
                                      true, url, clickCallback);
     }
     catch (e) {
     }
   },
 
-  _showPluginUpdatePage: function BG__showPluginUpdatePage() {
+  _showPluginUpdatePage: function() {
     Services.prefs.setBoolPref(PREF_PLUGINS_NOTIFYUSER, false);
 
     var formatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"].
                     getService(Ci.nsIURLFormatter);
     var updateUrl = formatter.formatURLPref(PREF_PLUGINS_UPDATEURL);
 
     var win = this.getMostRecentBrowserWindow();
     win.openUILinkIn(updateUrl, "tab");
@@ -1388,17 +1388,17 @@ BrowserGlue.prototype = {
    * - browser.places.smartBookmarksVersion
    *   Set during HTML import to indicate that Smart Bookmarks were created.
    *   Set to -1 to disable Smart Bookmarks creation.
    *   Set to 0 to restore current Smart Bookmarks.
    * - browser.bookmarks.restore_default_bookmarks
    *   Set to true by safe-mode dialog to indicate we must restore default
    *   bookmarks.
    */
-  _initPlaces: function BG__initPlaces(aInitialMigrationPerformed) {
+  _initPlaces: function(aInitialMigrationPerformed) {
     // We must instantiate the history service since it will tell us if we
     // need to import or restore bookmarks due to first-run, corruption or
     // forced migration (due to a major schema change).
     // If the database is corrupt or has been newly created we should
     // import bookmarks.
     let dbStatus = PlacesUtils.history.databaseStatus;
     let importBookmarks = !aInitialMigrationPerformed &&
                           (dbStatus == PlacesUtils.history.DATABASE_STATUS_CREATE ||
@@ -1572,46 +1572,46 @@ BrowserGlue.prototype = {
     }.bind(this));
   },
 
   /**
    * Places shut-down tasks
    * - finalize components depending on Places.
    * - export bookmarks as HTML, if so configured.
    */
-  _onPlacesShutdown: function BG__onPlacesShutdown() {
+  _onPlacesShutdown: function() {
     this._sanitizer.onShutdown();
     PageThumbs.uninit();
 
     if (this._bookmarksBackupIdleTime) {
       this._idleService.removeIdleObserver(this, this._bookmarksBackupIdleTime);
       delete this._bookmarksBackupIdleTime;
     }
   },
 
   /**
    * If a backup for today doesn't exist, this creates one.
    */
-  _backupBookmarks: function BG__backupBookmarks() {
+  _backupBookmarks: function() {
     return Task.spawn(function() {
       let lastBackupFile = yield PlacesBackups.getMostRecentBackup();
       // Should backup bookmarks if there are no backups or the maximum
       // interval between backups elapsed.
       if (!lastBackupFile ||
           new Date() - PlacesBackups.getDateForFile(lastBackupFile) > BOOKMARKS_BACKUP_MIN_INTERVAL_DAYS * 86400000) {
         let maxBackups = Services.prefs.getIntPref("browser.bookmarks.max_backups");
         yield PlacesBackups.create(maxBackups);
       }
     });
   },
 
   /**
    * Show the notificationBox for a locked places database.
    */
-  _showPlacesLockedNotificationBox: function BG__showPlacesLockedNotificationBox() {
+  _showPlacesLockedNotificationBox: function() {
     var brandBundle  = Services.strings.createBundle("chrome://branding/locale/brand.properties");
     var applicationName = brandBundle.GetStringFromName("brandShortName");
     var placesBundle = Services.strings.createBundle("chrome://browser/locale/places/places.properties");
     var title = placesBundle.GetStringFromName("lockPrompt.title");
     var text = placesBundle.formatStringFromName("lockPrompt.text", [applicationName], 1);
     var buttonText = placesBundle.GetStringFromName("lockPromptInfoButton.label");
     var accessKey = placesBundle.GetStringFromName("lockPromptInfoButton.accessKey");
 
@@ -1636,17 +1636,17 @@ BrowserGlue.prototype = {
 
     var notifyBox = win.gBrowser.getNotificationBox();
     var notification = notifyBox.appendNotification(text, title, null,
                                                     notifyBox.PRIORITY_CRITICAL_MEDIUM,
                                                     buttons);
     notification.persistence = -1; // Until user closes it
   },
 
-  _migrateUI: function BG__migrateUI() {
+  _migrateUI: function() {
     const UI_VERSION = 27;
     const BROWSER_DOCURL = "chrome://browser/content/browser.xul";
     let currentUIVersion = 0;
     try {
       currentUIVersion = Services.prefs.getIntPref("browser.migration.version");
     } catch(ex) {}
     if (currentUIVersion >= UI_VERSION)
       return;
@@ -1964,17 +1964,17 @@ BrowserGlue.prototype = {
     // Update the migration version.
     Services.prefs.setIntPref("browser.migration.version", UI_VERSION);
   },
 
   // ------------------------------
   // public nsIBrowserGlue members
   // ------------------------------
 
-  sanitize: function BG_sanitize(aParentWindow) {
+  sanitize: function(aParentWindow) {
     this._sanitizer.sanitize(aParentWindow);
   },
 
   ensurePlacesDefaultQueriesInitialized:
   function BG_ensurePlacesDefaultQueriesInitialized() {
     // This is actual version of the smart bookmarks, must be increased every
     // time smart bookmarks change.
     // When adding a new smart bookmark below, its newInVersion property must
@@ -1996,17 +1996,17 @@ BrowserGlue.prototype = {
 
     // If version is current or smart bookmarks are disabled, just bail out.
     if (smartBookmarksCurrentVersion == -1 ||
         smartBookmarksCurrentVersion >= SMART_BOOKMARKS_VERSION) {
       return;
     }
 
     let batch = {
-      runBatched: function BG_EPDQI_runBatched() {
+      runBatched: function() {
         let menuIndex = 0;
         let toolbarIndex = 0;
         let bundle = Services.strings.createBundle("chrome://browser/locale/places/places.properties");
 
         let smartBookmarks = {
           MostVisited: {
             title: bundle.GetStringFromName("mostVisitedTitle"),
             uri: NetUtil.newURI("place:sort=" +
@@ -2145,33 +2145,33 @@ BrowserGlue.prototype = {
     }
     finally {
       Services.prefs.setIntPref(SMART_BOOKMARKS_PREF, SMART_BOOKMARKS_VERSION);
       Services.prefs.savePrefFile(null);
     }
   },
 
   // this returns the most recent non-popup browser window
-  getMostRecentBrowserWindow: function BG_getMostRecentBrowserWindow() {
+  getMostRecentBrowserWindow: function() {
     return RecentWindow.getMostRecentBrowserWindow();
   },
 
 #ifdef MOZ_SERVICES_SYNC
   /**
    * Called as an observer when Sync's "display URI" notification is fired.
    *
    * We open the received URI in a background tab.
    *
    * Eventually, this will likely be replaced by a more robust tab syncing
    * feature. This functionality is considered somewhat evil by UX because it
    * opens a new tab automatically without any prompting. However, it is a
    * lesser evil than sending a tab to a specific device (from e.g. Fennec)
    * and having nothing happen on the receiving end.
    */
-  _onDisplaySyncURI: function _onDisplaySyncURI(data) {
+  _onDisplaySyncURI: function(data) {
     try {
       let tabbrowser = RecentWindow.getMostRecentBrowserWindow({private: false}).gBrowser;
 
       // The payload is wrapped weirdly because of how Sync does notifications.
       tabbrowser.addTab(data.wrappedJSObject.object.uri);
     } catch (ex) {
       Cu.reportError("Error displaying tab received by Sync: " + ex);
     }
@@ -2441,17 +2441,17 @@ ContentPermissionPrompt.prototype = {
       },
     ];
 
     this._showPrompt(aRequest, message, "desktop-notification", actions,
                      "web-notifications",
                      "web-notifications-notification-icon", null);
   },
 
-  _promptPointerLock: function CPP_promtPointerLock(aRequest, autoAllow) {
+  _promptPointerLock: function(aRequest, autoAllow) {
 
     let browserBundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
     let requestingURI = aRequest.principal.URI;
 
     let originString = requestingURI.schemeIs("file") ? requestingURI.path : requestingURI.host;
     let message = browserBundle.formatStringFromName(autoAllow ?
                                   "pointerLock.autoLock.title2" : "pointerLock.title2",
                                   [originString], 1);
@@ -2480,17 +2480,17 @@ ContentPermissionPrompt.prototype = {
         },
       ];
     }
 
     this._showPrompt(aRequest, message, "pointerLock", actions, "pointerLock",
                      "pointerLock-notification-icon", null);
   },
 
-  prompt: function CPP_prompt(request) {
+  prompt: function(request) {
 
     // Only allow exactly one permission rquest here.
     let types = request.types.QueryInterface(Ci.nsIArray);
     if (types.length != 1) {
       request.cancel();
       return;
     }
     let perm = types.queryElementAt(0, Ci.nsIContentPermissionType);
@@ -2820,17 +2820,17 @@ let E10SUINotification = {
         }
       }
     ];
     nb.appendNotification(message, "e10s-activated-noticed",
                           null, nb.PRIORITY_WARNING_MEDIUM, buttons);
 
   },
 
-  _showE10SPrompt: function BG__showE10SPrompt() {
+  _showE10SPrompt: function() {
     let win = RecentWindow.getMostRecentBrowserWindow();
     if (!win)
       return;
 
     let browser = win.gBrowser.selectedBrowser;
 
     let promptMessage = "Would you like to help us test multiprocess Nightly (e10s)? You can also enable e10s in Nightly preferences. Notable fixes:";
     let mainAction = {
diff --git a/browser/components/places/PlacesUIUtils.jsm b/browser/components/places/PlacesUIUtils.jsm
--- a/browser/components/places/PlacesUIUtils.jsm
+++ b/browser/components/places/PlacesUIUtils.jsm
@@ -92,21 +92,21 @@ this.PlacesUIUtils = {
   DESCRIPTION_ANNO: "bookmarkProperties/description",
 
   /**
    * Makes a URI from a spec, and do fixup
    * @param   aSpec
    *          The string spec of the URI
    * @return A URI object for the spec.
    */
-  createFixedURI: function PUIU_createFixedURI(aSpec) {
+  createFixedURI: function(aSpec) {
     return URIFixup.createFixupURI(aSpec, Ci.nsIURIFixup.FIXUP_FLAG_NONE);
   },
 
-  getFormattedString: function PUIU_getFormattedString(key, params) {
+  getFormattedString: function(key, params) {
     return bundle.formatStringFromName(key, params, params.length);
   },
 
   /**
    * Get a localized plural string for the specified key name and numeric value
    * substituting parameters.
    *
    * @param   aKey
@@ -115,27 +115,27 @@ this.PlacesUIUtils = {
    *          Number based on which the final localized form is looked up
    * @param   aParams
    *          Array whose items will substitute #1, #2,... #n parameters
    *          in the string.
    *
    * @see https://developer.mozilla.org/en/Localization_and_Plurals
    * @return The localized plural string.
    */
-  getPluralString: function PUIU_getPluralString(aKey, aNumber, aParams) {
+  getPluralString: function(aKey, aNumber, aParams) {
     let str = PluralForm.get(aNumber, bundle.GetStringFromName(aKey));
 
     // Replace #1 with aParams[0], #2 with aParams[1], and so on.
     return str.replace(/\#(\d+)/g, function (matchedId, matchedNumber) {
       let param = aParams[parseInt(matchedNumber, 10) - 1];
       return param !== undefined ? param : matchedId;
     });
   },
 
-  getString: function PUIU_getString(key) {
+  getString: function(key) {
     return bundle.GetStringFromName(key);
   },
 
   get _copyableAnnotations() [
     this.DESCRIPTION_ANNO,
     this.LOAD_IN_SIDEBAR_ANNO,
     PlacesUtils.POST_DATA_ANNO,
     PlacesUtils.READ_ONLY_ANNO,
@@ -469,27 +469,27 @@ this.PlacesUIUtils = {
 
     let features =
       "centerscreen,chrome,modal,resizable=" + (hasFolderPicker ? "yes" : "no");
 
     aParentWindow.openDialog(dialogURL, "",  features, aInfo);
     return ("performed" in aInfo && aInfo.performed);
   },
 
-  _getTopBrowserWin: function PUIU__getTopBrowserWin() {
+  _getTopBrowserWin: function() {
     return RecentWindow.getMostRecentBrowserWindow();
   },
 
   /**
    * Returns the closet ancestor places view for the given DOM node
    * @param aNode
    *        a DOM node
    * @return the closet ancestor places view if exists, null otherwsie.
    */
-  getViewForNode: function PUIU_getViewForNode(aNode) {
+  getViewForNode: function(aNode) {
     let node = aNode;
 
     // The view for a <menu> of which its associated menupopup is a places
     // view, is the menupopup.
     if (node.localName == "menu" && !node._placesNode &&
         node.lastChild._placesView)
       return node.lastChild._placesView;
 
@@ -508,52 +508,52 @@ this.PlacesUIUtils = {
   /**
    * By calling this before visiting an URL, the visit will be associated to a
    * TRANSITION_TYPED transition (if there is no a referrer).
    * This is used when visiting pages from the history menu, history sidebar,
    * url bar, url autocomplete results, and history searches from the places
    * organizer.  If this is not called visits will be marked as
    * TRANSITION_LINK.
    */
-  markPageAsTyped: function PUIU_markPageAsTyped(aURL) {
+  markPageAsTyped: function(aURL) {
     PlacesUtils.history.markPageAsTyped(this.createFixedURI(aURL));
   },
 
   /**
    * By calling this before visiting an URL, the visit will be associated to a
    * TRANSITION_BOOKMARK transition.
    * This is used when visiting pages from the bookmarks menu,
    * personal toolbar, and bookmarks from within the places organizer.
    * If this is not called visits will be marked as TRANSITION_LINK.
    */
-  markPageAsFollowedBookmark: function PUIU_markPageAsFollowedBookmark(aURL) {
+  markPageAsFollowedBookmark: function(aURL) {
     PlacesUtils.history.markPageAsFollowedBookmark(this.createFixedURI(aURL));
   },
 
   /**
    * By calling this before visiting an URL, any visit in frames will be
    * associated to a TRANSITION_FRAMED_LINK transition.
    * This is actually used to distinguish user-initiated visits in frames
    * so automatic visits can be correctly ignored.
    */
-  markPageAsFollowedLink: function PUIU_markPageAsFollowedLink(aURL) {
+  markPageAsFollowedLink: function(aURL) {
     PlacesUtils.history.markPageAsFollowedLink(this.createFixedURI(aURL));
   },
 
   /**
    * Allows opening of javascript/data URI only if the given node is
    * bookmarked (see bug 224521).
    * @param aURINode
    *        a URI node
    * @param aWindow
    *        a window on which a potential error alert is shown on.
    * @return true if it's safe to open the node in the browser, false otherwise.
    *
    */
-  checkURLSecurity: function PUIU_checkURLSecurity(aURINode, aWindow) {
+  checkURLSecurity: function(aURINode, aWindow) {
     if (PlacesUtils.nodeIsBookmark(aURINode))
       return true;
 
     var uri = PlacesUtils._uri(aURINode.uri);
     if (uri.schemeIs("javascript") || uri.schemeIs("data")) {
       const BRANDING_BUNDLE_URI = "chrome://branding/locale/brand.properties";
       var brandShortName = Cc["@mozilla.org/intl/stringbundle;1"].
                            getService(Ci.nsIStringBundleService).
@@ -570,17 +570,17 @@ this.PlacesUIUtils = {
   /**
    * Get the description associated with a document, as specified in a <META>
    * element.
    * @param   doc
    *          A DOM Document to get a description for
    * @return A description string if a META element was discovered with a
    *         "description" or "httpequiv" attribute, empty string otherwise.
    */
-  getDescriptionFromDocument: function PUIU_getDescriptionFromDocument(doc) {
+  getDescriptionFromDocument: function(doc) {
     var metaElements = doc.getElementsByTagName("META");
     for (var i = 0; i < metaElements.length; ++i) {
       if (metaElements[i].name.toLowerCase() == "description" ||
           metaElements[i].httpEquiv.toLowerCase() == "description") {
         return metaElements[i].content;
       }
     }
     return "";
@@ -588,17 +588,17 @@ this.PlacesUIUtils = {
 
   /**
    * Retrieve the description of an item
    * @param aItemId
    *        item identifier
    * @return the description of the given item, or an empty string if it is
    * not set.
    */
-  getItemDescription: function PUIU_getItemDescription(aItemId) {
+  getItemDescription: function(aItemId) {
     if (PlacesUtils.annotations.itemHasAnnotation(aItemId, this.DESCRIPTION_ANNO))
       return PlacesUtils.annotations.getItemAnnotation(aItemId, this.DESCRIPTION_ANNO);
     return "";
   },
 
   /**
    * Check whether or not the given node represents a removable entry (either in
    * history or in bookmarks).
@@ -727,17 +727,17 @@ this.PlacesUIUtils = {
     }
 
     return reallyOpen;
   },
 
   /** aItemsToOpen needs to be an array of objects of the form:
     * {uri: string, isBookmark: boolean}
     */
-  _openTabset: function PUIU__openTabset(aItemsToOpen, aEvent, aWindow) {
+  _openTabset: function(aItemsToOpen, aEvent, aWindow) {
     if (!aItemsToOpen.length)
       return;
 
     // Prefer the caller window if it's a browser window, otherwise use
     // the top browser window.
     var browserWindow = null;
     browserWindow =
       aWindow && aWindow.document.documentElement.getAttribute("windowtype") == "navigator:browser" ?
@@ -786,17 +786,17 @@ this.PlacesUIUtils = {
 
     let urlsToOpen = PlacesUtils.getURLsForContainerNode(aNode);
     if (!this._confirmOpenInTabs(urlsToOpen.length, window))
       return;
 
     this._openTabset(urlsToOpen, aEvent, window);
   },
 
-  openURINodesInTabs: function PUIU_openURINodesInTabs(aNodes, aEvent, aView) {
+  openURINodesInTabs: function(aNodes, aEvent, aView) {
     let window = aView.ownerWindow;
 
     let urlsToOpen = [];
     for (var i=0; i < aNodes.length; i++) {
       // Skip over separators and folders.
       if (PlacesUtils.nodeIsURI(aNodes[i]))
         urlsToOpen.push({uri: aNodes[i].uri, isBookmark: PlacesUtils.nodeIsBookmark(aNodes[i])});
     }
@@ -821,22 +821,22 @@ this.PlacesUIUtils = {
     this._openNodeIn(aNode, window.whereToOpenLink(aEvent, false, true), window);
   },
 
   /**
    * Loads the node's URL in the appropriate tab or window or as a
    * web panel.
    * see also openUILinkIn
    */
-  openNodeIn: function PUIU_openNodeIn(aNode, aWhere, aView, aPrivate) {
+  openNodeIn: function(aNode, aWhere, aView, aPrivate) {
     let window = aView.ownerWindow;
     this._openNodeIn(aNode, aWhere, window, aPrivate);
   },
 
-  _openNodeIn: function PUIU_openNodeIn(aNode, aWhere, aWindow, aPrivate=false) {
+  _openNodeIn: function(aNode, aWhere, aWindow, aPrivate=false) {
     if (aNode && PlacesUtils.nodeIsURI(aNode) &&
         this.checkURLSecurity(aNode, aWindow)) {
       let isBookmark = PlacesUtils.nodeIsBookmark(aNode);
 
       if (!PrivateBrowsingUtils.isWindowPrivate(aWindow)) {
         if (isBookmark)
           this.markPageAsFollowedBookmark(aNode.uri);
         else
@@ -868,21 +868,21 @@ this.PlacesUIUtils = {
    * Used to avoid nsIURI overhead in frequently called UI functions.
    *
    * @param aUrlString the url to guess the scheme from.
    *
    * @return guessed scheme for this url string.
    *
    * @note this is not supposed be perfect, so use it only for UI purposes.
    */
-  guessUrlSchemeForUI: function PUIU_guessUrlSchemeForUI(aUrlString) {
+  guessUrlSchemeForUI: function(aUrlString) {
     return aUrlString.substr(0, aUrlString.indexOf(":"));
   },
 
-  getBestTitle: function PUIU_getBestTitle(aNode, aDoNotCutTitle) {
+  getBestTitle: function(aNode, aDoNotCutTitle) {
     var title;
     if (!aNode.title && PlacesUtils.nodeIsURI(aNode)) {
       // if node title is empty, try to set the label using host and filename
       // PlacesUtils._uri() will throw if aNode.uri is not a valid URI
       try {
         var uri = PlacesUtils._uri(aNode.uri);
         var host = uri.host;
         var fileName = uri.QueryInterface(Ci.nsIURL).fileName;
@@ -1060,34 +1060,34 @@ this.PlacesUIUtils = {
         delete this.leftPaneFolderId;
         return this.leftPaneFolderId = leftPaneRoot;
       }
     }
 
     // Create a new left pane folder.
     var callback = {
       // Helper to create an organizer special query.
-      create_query: function CB_create_query(aQueryName, aParentId, aQueryUrl) {
+      create_query: function(aQueryName, aParentId, aQueryUrl) {
         let itemId = bs.insertBookmark(aParentId,
                                        PlacesUtils._uri(aQueryUrl),
                                        bs.DEFAULT_INDEX,
                                        queries[aQueryName].title);
         // Mark as special organizer query.
         as.setItemAnnotation(itemId, PlacesUIUtils.ORGANIZER_QUERY_ANNO, aQueryName,
                              0, as.EXPIRE_NEVER);
         // We should never backup this, since it changes between profiles.
         as.setItemAnnotation(itemId, PlacesUtils.EXCLUDE_FROM_BACKUP_ANNO, 1,
                              0, as.EXPIRE_NEVER);
         // Add to the queries map.
         PlacesUIUtils.leftPaneQueries[aQueryName] = itemId;
         return itemId;
       },
 
       // Helper to create an organizer special folder.
-      create_folder: function CB_create_folder(aFolderName, aParentId, aIsRoot) {
+      create_folder: function(aFolderName, aParentId, aIsRoot) {
               // Left Pane Root Folder.
         let folderId = bs.createFolder(aParentId,
                                        queries[aFolderName].title,
                                        bs.DEFAULT_INDEX);
         // We should never backup this, since it changes between profiles.
         as.setItemAnnotation(folderId, PlacesUtils.EXCLUDE_FROM_BACKUP_ANNO, 1,
                              0, as.EXPIRE_NEVER);
 
@@ -1101,17 +1101,17 @@ this.PlacesUIUtils = {
           // Mark as special organizer folder.
           as.setItemAnnotation(folderId, PlacesUIUtils.ORGANIZER_QUERY_ANNO, aFolderName,
                            0, as.EXPIRE_NEVER);
           PlacesUIUtils.leftPaneQueries[aFolderName] = folderId;
         }
         return folderId;
       },
 
-      runBatched: function CB_runBatched(aUserData) {
+      runBatched: function(aUserData) {
         delete PlacesUIUtils.leftPaneQueries;
         PlacesUIUtils.leftPaneQueries = { };
 
         // Left Pane Root Folder.
         leftPaneRoot = this.create_folder("PlacesRoot", bs.placesRoot, true);
 
         // History Query.
         this.create_query("History", leftPaneRoot,
@@ -1168,17 +1168,17 @@ this.PlacesUIUtils = {
 
   /**
    * If an item is a left-pane query, returns the name of the query
    * or an empty string if not.
    *
    * @param aItemId id of a container
    * @return the name of the query, or empty string if not a left-pane query
    */
-  getLeftPaneQueryNameFromId: function PUIU_getLeftPaneQueryNameFromId(aItemId) {
+  getLeftPaneQueryNameFromId: function(aItemId) {
     var queryName = "";
     // If the let pane hasn't been built, use the annotation service
     // directly, to avoid building the left pane too early.
     if (Object.getOwnPropertyDescriptor(this, "leftPaneFolderId").value === undefined) {
       try {
         queryName = PlacesUtils.annotations.
                                 getItemAnnotation(aItemId, this.ORGANIZER_QUERY_ANNO);
       }
diff --git a/browser/components/places/content/bookmarkProperties.js b/browser/components/places/content/bookmarkProperties.js
--- a/browser/components/places/content/bookmarkProperties.js
+++ b/browser/components/places/content/bookmarkProperties.js
@@ -98,17 +98,17 @@ var BookmarkPropertiesPanel = {
   _hiddenRows: [],
   _batching: false,
   _readOnly: false,
 
   /**
    * This method returns the correct label for the dialog's "accept"
    * button based on the variant of the dialog.
    */
-  _getAcceptLabel: function BPP__getAcceptLabel() {
+  _getAcceptLabel: function() {
     if (this._action == ACTION_ADD) {
       if (this._URIs.length)
         return this._strings.getString("dialogAcceptLabelAddMulti");
 
       if (this._itemType == LIVEMARK_CONTAINER)
         return this._strings.getString("dialogAcceptLabelAddLivemark");
 
       if (this._dummyItem || this._loadInSidebar)
@@ -118,17 +118,17 @@ var BookmarkPropertiesPanel = {
     }
     return this._strings.getString("dialogAcceptLabelEdit");
   },
 
   /**
    * This method returns the correct title for the current variant
    * of this dialog.
    */
-  _getDialogTitle: function BPP__getDialogTitle() {
+  _getDialogTitle: function() {
     if (this._action == ACTION_ADD) {
       if (this._itemType == BOOKMARK_ITEM)
         return this._strings.getString("dialogTitleAddBookmark");
       if (this._itemType == LIVEMARK_CONTAINER)
         return this._strings.getString("dialogTitleAddLivemark");
 
       // add folder
       NS_ASSERT(this._itemType == BOOKMARK_FOLDER, "Unknown item type");
@@ -141,17 +141,17 @@ var BookmarkPropertiesPanel = {
       return this._strings.getFormattedString("dialogTitleEdit", [this._title]);
     }
     return "";
   },
 
   /**
    * Determines the initial data for the item edited or added by this dialog
    */
-  _determineItemInfo: function BPP__determineItemInfo() {
+  _determineItemInfo: function() {
     var dialogInfo = window.arguments[0];
     this._action = dialogInfo.action == "add" ? ACTION_ADD : ACTION_EDIT;
     this._hiddenRows = dialogInfo.hiddenRows ? dialogInfo.hiddenRows : [];
     if (this._action == ACTION_ADD) {
       NS_ASSERT("type" in dialogInfo, "missing type property for add action");
 
       if ("title" in dialogInfo)
         this._title = dialogInfo.title;
@@ -285,28 +285,28 @@ var BookmarkPropertiesPanel = {
    * the given URI doesn't appear in bookmarks or history), we synthesize
    * a title from the first 100 characters of the URI.
    *
    * @param aURI
    *        nsIURI object for which we want the title
    *
    * @returns a title string
    */
-  _getURITitleFromHistory: function BPP__getURITitleFromHistory(aURI) {
+  _getURITitleFromHistory: function(aURI) {
     NS_ASSERT(aURI instanceof Ci.nsIURI);
 
     // get the title from History
     return PlacesUtils.history.getPageTitle(aURI);
   },
 
   /**
    * This method should be called by the onload of the Bookmark Properties
    * dialog to initialize the state of the panel.
    */
-  onDialogLoad: function BPP_onDialogLoad() {
+  onDialogLoad: function() {
     this._determineItemInfo();
 
     document.title = this._getDialogTitle();
     var acceptButton = document.documentElement.getButton("accept");
     acceptButton.label = this._getAcceptLabel();
 
     this._beginBatch();
 
@@ -356,17 +356,17 @@ var BookmarkPropertiesPanel = {
       }
     }
 
     window.sizeToContent();
   },
 
   // nsIDOMEventListener
   _elementsHeight: [],
-  handleEvent: function BPP_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     var target = aEvent.target;
     switch (aEvent.type) {
       case "input":
         if (target.id == "editBMPanel_locationField" ||
             target.id == "editBMPanel_feedLocationField" ||
             target.id == "editBMPanel_siteLocationField" ||
             target.id == "editBMPanel_keywordField") {
           // Check uri fields to enable accept button if input is valid
@@ -392,106 +392,106 @@ var BookmarkPropertiesPanel = {
           }
 
           window.resizeTo(window.outerWidth, newHeight);
         }
         break;
     }
   },
 
-  _beginBatch: function BPP__beginBatch() {
+  _beginBatch: function() {
     if (this._batching)
       return;
 
     PlacesUtils.transactionManager.beginBatch(null);
     this._batching = true;
   },
 
-  _endBatch: function BPP__endBatch() {
+  _endBatch: function() {
     if (!this._batching)
       return;
 
     PlacesUtils.transactionManager.endBatch(false);
     this._batching = false;
   },
 
-  _fillEditProperties: function BPP__fillEditProperties() {
+  _fillEditProperties: function() {
     gEditItemOverlay.initPanel(this._itemId,
                                { hiddenRows: this._hiddenRows,
                                  forceReadOnly: this._readOnly });
   },
 
-  _fillAddProperties: function BPP__fillAddProperties() {
+  _fillAddProperties: function() {
     this._createNewItem();
     // Edit the new item
     gEditItemOverlay.initPanel(this._itemId,
                                { hiddenRows: this._hiddenRows });
     // Empty location field if the uri is about:blank, this way inserting a new
     // url will be easier for the user, Accept button will be automatically
     // disabled by the input listener until the user fills the field.
     var locationField = this._element("locationField");
     if (locationField.value == "about:blank")
       locationField.value = "";
   },
 
   // nsISupports
-  QueryInterface: function BPP_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIDOMEventListener) ||
         aIID.equals(Ci.nsISupports))
       return this;
 
     throw Cr.NS_NOINTERFACE;
   },
 
-  _element: function BPP__element(aID) {
+  _element: function(aID) {
     return document.getElementById("editBMPanel_" + aID);
   },
 
-  onDialogUnload: function BPP_onDialogUnload() {
+  onDialogUnload: function() {
     // gEditItemOverlay does not exist anymore here, so don't rely on it.
     // Calling removeEventListener with arguments which do not identify any
     // currently registered EventListener on the EventTarget has no effect.
     this._element("tagsSelectorRow")
         .removeEventListener("DOMAttrModified", this, false);
     this._element("folderTreeRow")
         .removeEventListener("DOMAttrModified", this, false);
     this._element("locationField")
         .removeEventListener("input", this, false);
     this._element("feedLocationField")
         .removeEventListener("input", this, false);
     this._element("siteLocationField")
         .removeEventListener("input", this, false);
   },
 
-  onDialogAccept: function BPP_onDialogAccept() {
+  onDialogAccept: function() {
     // We must blur current focused element to save its changes correctly
     document.commandDispatcher.focusedElement.blur();
     // The order here is important! We have to uninit the panel first, otherwise
     // late changes could force it to commit more transactions.
     gEditItemOverlay.uninitPanel(true);
     this._endBatch();
     window.arguments[0].performed = true;
   },
 
-  onDialogCancel: function BPP_onDialogCancel() {
+  onDialogCancel: function() {
     // The order here is important! We have to uninit the panel first, otherwise
     // changes done as part of Undo may change the panel contents and by
     // that force it to commit more transactions.
     gEditItemOverlay.uninitPanel(true);
     this._endBatch();
     PlacesUtils.transactionManager.undoTransaction();
     window.arguments[0].performed = false;
   },
 
   /**
    * This method checks to see if the input fields are in a valid state.
    *
    * @returns  true if the input is valid, false otherwise
    */
-  _inputIsValid: function BPP__inputIsValid() {
+  _inputIsValid: function() {
     if (this._itemType == BOOKMARK_ITEM &&
         !this._containsValidURI("locationField"))
       return false;
     if (this._isAddKeywordDialog && !this._element("keywordField").value.length)
       return false;
 
     return true;
   },
@@ -500,17 +500,17 @@ var BookmarkPropertiesPanel = {
    * Determines whether the XUL textbox with the given ID contains a
    * string that can be converted into an nsIURI.
    *
    * @param aTextboxID
    *        the ID of the textbox element whose contents we'll test
    *
    * @returns true if the textbox contains a valid URI string, false otherwise
    */
-  _containsValidURI: function BPP__containsValidURI(aTextboxID) {
+  _containsValidURI: function(aTextboxID) {
     try {
       var value = this._element(aTextboxID).value;
       if (value) {
         PlacesUIUtils.createFixedURI(value);
         return true;
       }
     } catch (e) { }
     return false;
@@ -518,17 +518,17 @@ var BookmarkPropertiesPanel = {
 
   /**
    * [New Item Mode] Get the insertion point details for the new item, given
    * dialog state and opening arguments.
    *
    * The container-identifier and insertion-index are returned separately in
    * the form of [containerIdentifier, insertionIndex]
    */
-  _getInsertionPointDetails: function BPP__getInsertionPointDetails() {
+  _getInsertionPointDetails: function() {
     var containerId = this._defaultInsertionPoint.itemId;
     var indexInContainer = this._defaultInsertionPoint.index;
 
     return [containerId, indexInContainer];
   },
 
   /**
    * Returns a transaction for creating a new bookmark item representing the
@@ -576,17 +576,17 @@ var BookmarkPropertiesPanel = {
     return new PlacesAggregatedTransaction(this._getDialogTitle(),
                                            [createTxn]);
   },
 
   /**
    * Returns a childItems-transactions array representing the URIList with
    * which the dialog has been opened.
    */
-  _getTransactionsForURIList: function BPP__getTransactionsForURIList() {
+  _getTransactionsForURIList: function() {
     var transactions = [];
     for (var i = 0; i < this._URIs.length; ++i) {
       var uri = this._URIs[i];
       var title = this._getURITitleFromHistory(uri);
       var createTxn = new PlacesCreateBookmarkTransaction(uri, -1, 
                                                           PlacesUtils.bookmarks.DEFAULT_INDEX,
                                                           title);
       transactions.push(createTxn);
@@ -622,17 +622,17 @@ var BookmarkPropertiesPanel = {
     return new PlacesCreateLivemarkTransaction(this._feedURI, this._siteURI,
                                                this._title,
                                                aContainer, aIndex);
   },
 
   /**
    * Dialog-accept code-path for creating a new item (any type)
    */
-  _createNewItem: function BPP__getCreateItemTransaction() {
+  _createNewItem: function() {
     var [container, index] = this._getInsertionPointDetails();
     var txn;
 
     switch (this._itemType) {
       case BOOKMARK_FOLDER:
         txn = this._getCreateNewFolderTransaction(container, index);
         break;
       case LIVEMARK_CONTAINER:
diff --git a/browser/components/places/content/browserPlacesViews.js b/browser/components/places/content/browserPlacesViews.js
--- a/browser/components/places/content/browserPlacesViews.js
+++ b/browser/components/places/content/browserPlacesViews.js
@@ -212,27 +212,27 @@ PlacesViewBase.prototype = {
 
     if (PlacesControllerDragHelper.disallowInsertion(container))
       return null;
 
     return new InsertionPoint(PlacesUtils.getConcreteItemId(container),
                               index, orientation, tagName);
   },
 
-  buildContextMenu: function PVB_buildContextMenu(aPopup) {
+  buildContextMenu: function(aPopup) {
     this._contextMenuShown = aPopup;
     window.updateCommands("places");
     return this.controller.buildContextMenu(aPopup);
   },
 
-  destroyContextMenu: function PVB_destroyContextMenu(aPopup) {
+  destroyContextMenu: function(aPopup) {
     this._contextMenuShown = null;
   },
 
-  _cleanPopup: function PVB_cleanPopup(aPopup, aDelay) {
+  _cleanPopup: function(aPopup, aDelay) {
     // Remove Places nodes from the popup.
     let child = aPopup._startMarker;
     while (child.nextSibling != aPopup._endMarker) {
       let sibling = child.nextSibling;
       if (sibling._placesNode && !aDelay) {
         aPopup.removeChild(sibling);
       }
       else if (sibling._placesNode && aDelay) {
@@ -245,17 +245,17 @@ PlacesViewBase.prototype = {
         child = child.nextSibling;
       }
       else {
         child = child.nextSibling;
       }
     }
   },
 
-  _rebuildPopup: function PVB__rebuildPopup(aPopup) {
+  _rebuildPopup: function(aPopup) {
     let resultNode = aPopup._placesNode;
     if (!resultNode.containerOpen)
       return;
 
     if (this.controller.hasCachedLivemarkInfo(resultNode)) {
       this._setEmptyPopupStatus(aPopup, false);
       aPopup._built = true;
       this._populateLivemarkPopup(aPopup);
@@ -274,17 +274,17 @@ PlacesViewBase.prototype = {
       }
     }
     else {
       this._setEmptyPopupStatus(aPopup, true);
     }
     aPopup._built = true;
   },
 
-  _removeChild: function PVB__removeChild(aChild) {
+  _removeChild: function(aChild) {
     // If document.popupNode pointed to this child, null it out,
     // otherwise controller's command-updating may rely on the removed
     // item still being "selected".
     if (document.popupNode == aChild)
       document.popupNode = null;
 
     aChild.parentNode.removeChild(aChild);
   },
@@ -479,39 +479,39 @@ PlacesViewBase.prototype = {
     }
     else {
       // The livemark has finished loading.
       if (aPopup._statusMenuitem.parentNode == aPopup)
         aPopup.removeChild(aPopup._statusMenuitem);
     }
   },
 
-  toggleCutNode: function PVB_toggleCutNode(aPlacesNode, aValue) {
+  toggleCutNode: function(aPlacesNode, aValue) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
 
     // We may get the popup for menus, but we need the menu itself.
     if (elt.localName == "menupopup")
       elt = elt.parentNode;
     if (aValue)
       elt.setAttribute("cutting", "true");
     else
       elt.removeAttribute("cutting");
   },
 
-  nodeURIChanged: function PVB_nodeURIChanged(aPlacesNode, aURIString) {
+  nodeURIChanged: function(aPlacesNode, aURIString) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
 
     // Here we need the <menu>.
     if (elt.localName == "menupopup")
       elt = elt.parentNode;
 
     elt.setAttribute("scheme", PlacesUIUtils.guessUrlSchemeForUI(aURIString));
   },
 
-  nodeIconChanged: function PVB_nodeIconChanged(aPlacesNode) {
+  nodeIconChanged: function(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
 
     // There's no UI representation for the root node, thus there's nothing to
     // be done when the icon changes.
     if (elt == this._rootElt)
       return;
 
     // Here we need the <menu>.
@@ -724,26 +724,26 @@ PlacesViewBase.prototype = {
           if (child.accessCount)
             this._getDOMNodeForPlacesNode(child).setAttribute("visited", true);
           else
             this._getDOMNodeForPlacesNode(child).removeAttribute("visited");
         }
       }, Components.utils.reportError);
   },
 
-  invalidateContainer: function PVB_invalidateContainer(aPlacesNode) {
+  invalidateContainer: function(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     elt._built = false;
 
     // If the menupopup is open we should live-update it.
     if (elt.parentNode.open)
       this._rebuildPopup(elt);
   },
 
-  uninit: function PVB_uninit() {
+  uninit: function() {
     if (this._result) {
       this._result.removeObserver(this);
       this._resultNode.containerOpen = false;
       this._resultNode = null;
       this._result = null;
     }
 
     if (this._controller) {
@@ -776,17 +776,17 @@ PlacesViewBase.prototype = {
     return window;
   },
 
   /**
    * Adds an "Open All in Tabs" menuitem to the bottom of the popup.
    * @param aPopup
    *        a Places popup.
    */
-  _mayAddCommandsItems: function PVB__mayAddCommandsItems(aPopup) {
+  _mayAddCommandsItems: function(aPopup) {
     // The command items are never added to the root popup.
     if (aPopup == this._rootElt)
       return;
 
     let hasMultipleURIs = false;
 
     // Check if the popup contains at least 2 menuitems with places nodes.
     // We don't currently support opening multiple uri nodes when they are not
@@ -841,17 +841,17 @@ PlacesViewBase.prototype = {
       aPopup._endOptOpenAllInTabs.setAttribute("onclick",
         "checkForMiddleClick(this, event); event.stopPropagation();");
       aPopup._endOptOpenAllInTabs.setAttribute("label",
         gNavigatorBundle.getString("menuOpenAllInTabs.label"));
       aPopup.appendChild(aPopup._endOptOpenAllInTabs);
     }
   },
 
-  _ensureMarkers: function PVB__ensureMarkers(aPopup) {
+  _ensureMarkers: function(aPopup) {
     if (aPopup._startMarker)
       return;
 
     // _startMarker is an hidden menuseparator that lives before places nodes.
     aPopup._startMarker = document.createElement("menuseparator");
     aPopup._startMarker.hidden = true;
     aPopup.insertBefore(aPopup._startMarker, aPopup.firstChild);
 
@@ -884,17 +884,17 @@ PlacesViewBase.prototype = {
         aPopup.insertBefore(aPopup._startMarker, child);
       }
     }
     if (!firstNonStaticNodeFound) {
       aPopup.insertBefore(aPopup._startMarker, aPopup._endMarker);
     }
   },
 
-  _onPopupShowing: function PVB__onPopupShowing(aEvent) {
+  _onPopupShowing: function(aEvent) {
     // Avoid handling popupshowing of inner views.
     let popup = aEvent.originalTarget;
 
     this._ensureMarkers(popup);
 
     // Remove any delayed element, see _cleanPopup for details.
     if ("_delayedRemovals" in popup) {
       while (popup._delayedRemovals.length > 0) {
@@ -971,25 +971,25 @@ function PlacesToolbar(aPlace) {
 }
 
 PlacesToolbar.prototype = {
   __proto__: PlacesViewBase.prototype,
 
   _cbEvents: ["dragstart", "dragover", "dragexit", "dragend", "drop",
               "mousemove", "mouseover", "mouseout"],
 
-  QueryInterface: function PT_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIDOMEventListener) ||
         aIID.equals(Ci.nsITimerCallback))
       return this;
 
     return PlacesViewBase.prototype.QueryInterface.apply(this, arguments);
   },
 
-  uninit: function PT_uninit() {
+  uninit: function() {
     this._removeEventListeners(this._viewElt, this._cbEvents, false);
     this._removeEventListeners(this._rootElt, ["popupshowing", "popuphidden"],
                                true);
     this._removeEventListeners(this._rootElt, ["overflow", "underflow"], true);
     this._removeEventListeners(window, ["resize", "unload"], false);
     this._removeEventListeners(gBrowser.tabContainer, ["TabOpen", "TabClose"], false);
 
     if (this._chevron._placesView) {
@@ -997,17 +997,17 @@ PlacesToolbar.prototype = {
     }
 
     PlacesViewBase.prototype.uninit.apply(this, arguments);
   },
 
   _openedMenuButton: null,
   _allowPopupShowing: true,
 
-  _rebuild: function PT__rebuild() {
+  _rebuild: function() {
     // Clear out references to existing nodes, since they will be removed
     // and re-added.
     if (this._overFolder.elt)
       this._clearOverFolder();
 
     this._openedMenuButton = null;
     while (this._rootElt.hasChildNodes()) {
       this._rootElt.removeChild(this._rootElt.firstChild);
@@ -1101,17 +1101,17 @@ PlacesToolbar.prototype = {
       return;
 
     if (!this._chevron._placesView)
       this._chevron._placesView = new PlacesMenu(aEvent, this.place);
 
     this._updateChevronPopupNodesVisibility();
   },
 
-  handleEvent: function PT_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "unload":
         this.uninit();
         break;
       case "resize":
         // This handler updates nodes visibility in both the toolbar
         // and the chevron popup when a window resize does not change
         // the overflow status of the toolbar.
@@ -1169,51 +1169,51 @@ PlacesToolbar.prototype = {
   updateOverflowStatus: function() {
     if (this._rootElt.scrollLeftMax > 0) {
       this._onOverflow();
     } else {
       this._onUnderflow();
     }
   },
 
-  _isOverflowStateEventRelevant: function PT_isOverflowStateEventRelevant(aEvent) {
+  _isOverflowStateEventRelevant: function(aEvent) {
     // Ignore events not aimed at ourselves, as well as purely vertical ones:
     return aEvent.target == aEvent.currentTarget && aEvent.detail > 0;
   },
 
-  _onOverflow: function PT_onOverflow() {
+  _onOverflow: function() {
     // Attach the popup binding to the chevron popup if it has not yet
     // been initialized.
     if (!this._chevronPopup.hasAttribute("type")) {
       this._chevronPopup.setAttribute("place", this.place);
       this._chevronPopup.setAttribute("type", "places");
     }
     this._chevron.collapsed = false;
     this.updateChevron();
   },
 
-  _onUnderflow: function PT_onUnderflow() {
+  _onUnderflow: function() {
     this.updateChevron();
     this._chevron.collapsed = true;
   },
 
-  updateChevron: function PT_updateChevron() {
+  updateChevron: function() {
     // If the chevron is collapsed there's nothing to update.
     if (this._chevron.collapsed)
       return;
 
     // Update the chevron on a timer.  This will avoid repeated work when
     // lot of changes happen in a small timeframe.
     if (this._updateChevronTimer)
       this._updateChevronTimer.cancel();
 
     this._updateChevronTimer = this._setTimer(100);
   },
 
-  _updateChevronTimerCallback: function PT__updateChevronTimerCallback() {
+  _updateChevronTimerCallback: function() {
     let scrollRect = this._rootElt.getBoundingClientRect();
     let childOverflowed = false;
     for (let i = 0; i < this._rootElt.childNodes.length; i++) {
       let child = this._rootElt.childNodes[i];
       // Once a child overflows, all the next ones will.
       if (!childOverflowed) {
         let childRect = child.getBoundingClientRect();
         childOverflowed = this.isRTL ? (childRect.left < scrollRect.left)
@@ -1318,17 +1318,17 @@ PlacesToolbar.prototype = {
       }
     }
     else {
       // Node is in a submenu.
       PlacesViewBase.prototype.nodeAnnotationChanged.apply(this, arguments);
     }
   },
 
-  nodeTitleChanged: function PT_nodeTitleChanged(aPlacesNode, aNewTitle) {
+  nodeTitleChanged: function(aPlacesNode, aNewTitle) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
 
     // There's no UI representation for the root node, thus there's
     // nothing to be done when the title changes.
     if (elt == this._rootElt)
       return;
 
     PlacesViewBase.prototype.nodeTitleChanged.apply(this, arguments);
@@ -1338,33 +1338,33 @@ PlacesToolbar.prototype = {
       elt = elt.parentNode;
 
     if (elt.parentNode == this._rootElt) {
       // Node is on the toolbar
       this.updateChevron();
     }
   },
 
-  invalidateContainer: function PT_invalidateContainer(aPlacesNode) {
+  invalidateContainer: function(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     if (elt == this._rootElt) {
       // Container is the toolbar itself.
       this._rebuild();
       return;
     }
 
     PlacesViewBase.prototype.invalidateContainer.apply(this, arguments);
   },
 
   _overFolder: { elt: null,
                  openTimer: null,
                  hoverTime: 350,
                  closeTimer: null },
 
-  _clearOverFolder: function PT__clearOverFolder() {
+  _clearOverFolder: function() {
     // The mouse is no longer dragging over the stored menubutton.
     // Close the menubutton, clear out drag styles, and clear all
     // timers for opening/closing it.
     if (this._overFolder.elt && this._overFolder.elt.lastChild) {
       if (!this._overFolder.elt.lastChild.hasAttribute("dragover")) {
         this._overFolder.elt.lastChild.hidePopup();
       }
       this._overFolder.elt.removeAttribute("dragover");
@@ -1382,17 +1382,17 @@ PlacesToolbar.prototype = {
 
   /**
    * This function returns information about where to drop when dragging over
    * the toolbar.  The returned object has the following properties:
    * - ip: the insertion point for the bookmarks service.
    * - beforeIndex: child index to drop before, for the drop indicator.
    * - folderElt: the folder to drop into, if applicable.
    */
-  _getDropPoint: function PT__getDropPoint(aEvent) {
+  _getDropPoint: function(aEvent) {
     let result = this.result;
     if (!PlacesUtils.nodeIsFolder(this._resultNode))
       return null;
 
     let dropPoint = { ip: null, beforeIndex: null, folderElt: null };
     let elt = aEvent.target;
     if (elt._placesNode && elt != this._rootElt &&
         elt.localName != "menupopup") {
@@ -1467,23 +1467,23 @@ PlacesToolbar.prototype = {
         new InsertionPoint(PlacesUtils.getConcreteItemId(this._resultNode),
                            -1, Ci.nsITreeView.DROP_BEFORE);
       dropPoint.beforeIndex = -1;
     }
 
     return dropPoint;
   },
 
-  _setTimer: function PT_setTimer(aTime) {
+  _setTimer: function(aTime) {
     let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
     timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);
     return timer;
   },
 
-  notify: function PT_notify(aTimer) {
+  notify: function(aTimer) {
     if (aTimer == this._updateChevronTimer) {
       this._updateChevronTimer = null;
       this._updateChevronTimerCallback();
     }
 
     // * Timer to turn off indicator bar.
     else if (aTimer == this._ibTimer) {
       this._dropIndicator.collapsed = true;
@@ -1518,38 +1518,38 @@ PlacesToolbar.prototype = {
       if (inHierarchy)
         this._overFolder.elt = null;
 
       // Clear out the folder and all associated timers.
       this._clearOverFolder();
     }
   },
 
-  _onMouseOver: function PT__onMouseOver(aEvent) {
+  _onMouseOver: function(aEvent) {
     let button = aEvent.target;
     if (button.parentNode == this._rootElt && button._placesNode &&
         PlacesUtils.nodeIsURI(button._placesNode))
       window.XULBrowserWindow.setOverLink(aEvent.target._placesNode.uri, null);
   },
 
-  _onMouseOut: function PT__onMouseOut(aEvent) {
+  _onMouseOut: function(aEvent) {
     window.XULBrowserWindow.setOverLink("", null);
   },
 
-  _cleanupDragDetails: function PT__cleanupDragDetails() {
+  _cleanupDragDetails: function() {
     // Called on dragend and drop.
     PlacesControllerDragHelper.currentDropTarget = null;
     this._draggedElt = null;
     if (this._ibTimer)
       this._ibTimer.cancel();
 
     this._dropIndicator.collapsed = true;
   },
 
-  _onDragStart: function PT__onDragStart(aEvent) {
+  _onDragStart: function(aEvent) {
     // Sub menus have their own d&d handlers.
     let draggedElt = aEvent.target;
     if (draggedElt.parentNode != this._rootElt || !draggedElt._placesNode)
       return;
 
     if (draggedElt.localName == "toolbarbutton" &&
         draggedElt.getAttribute("type") == "menu") {
       // If the drag gesture on a container is toward down we open instead
@@ -1574,17 +1574,17 @@ PlacesToolbar.prototype = {
     // Activate the view and cache the dragged element.
     this._draggedElt = draggedElt._placesNode;
     this._rootElt.focus();
 
     this._controller.setDataTransfer(aEvent);
     aEvent.stopPropagation();
   },
 
-  _onDragOver: function PT__onDragOver(aEvent) {
+  _onDragOver: function(aEvent) {
     // Cache the dataTransfer
     PlacesControllerDragHelper.currentDropTarget = aEvent.target;
     let dt = aEvent.dataTransfer;
 
     let dropPoint = this._getDropPoint(aEvent);
     if (!dropPoint || !dropPoint.ip ||
         !PlacesControllerDragHelper.canDrop(dropPoint.ip, dt)) {
       this._dropIndicator.collapsed = true;
@@ -1651,64 +1651,64 @@ PlacesToolbar.prototype = {
       // Clear out old folder information.
       this._clearOverFolder();
     }
 
     aEvent.preventDefault();
     aEvent.stopPropagation();
   },
 
-  _onDrop: function PT__onDrop(aEvent) {
+  _onDrop: function(aEvent) {
     PlacesControllerDragHelper.currentDropTarget = aEvent.target;
 
     let dropPoint = this._getDropPoint(aEvent);
     if (dropPoint && dropPoint.ip) {
       PlacesControllerDragHelper.onDrop(dropPoint.ip, aEvent.dataTransfer)
                                 .then(null, Components.utils.reportError);
       aEvent.preventDefault();
     }
 
     this._cleanupDragDetails();
     aEvent.stopPropagation();
   },
 
-  _onDragExit: function PT__onDragExit(aEvent) {
+  _onDragExit: function(aEvent) {
     PlacesControllerDragHelper.currentDropTarget = null;
 
     // Set timer to turn off indicator bar (if we turn it off
     // here, dragenter might be called immediately after, creating
     // flicker).
     if (this._ibTimer)
       this._ibTimer.cancel();
     this._ibTimer = this._setTimer(10);
 
     // If we hovered over a folder, close it now.
     if (this._overFolder.elt)
         this._overFolder.closeTimer = this._setTimer(this._overFolder.hoverTime);
   },
 
-  _onDragEnd: function PT_onDragEnd(aEvent) {
+  _onDragEnd: function(aEvent) {
     this._cleanupDragDetails();
   },
 
-  _onPopupShowing: function PT__onPopupShowing(aEvent) {
+  _onPopupShowing: function(aEvent) {
     if (!this._allowPopupShowing) {
       this._allowPopupShowing = true;
       aEvent.preventDefault();
       return;
     }
 
     let parent = aEvent.target.parentNode;
     if (parent.localName == "toolbarbutton")
       this._openedMenuButton = parent;
 
     PlacesViewBase.prototype._onPopupShowing.apply(this, arguments);
   },
 
-  _onPopupHidden: function PT__onPopupHidden(aEvent) {
+  _onPopupHidden: function(aEvent) {
     let popup = aEvent.target;
     let placesNode = popup._placesNode;
     // Avoid handling popuphidden of inner views
     if (placesNode && PlacesUIUtils.getViewForNode(popup) == this) {
       // UI performance: folder queries are cheap, keep the resultnode open
       // so we don't rebuild its contents whenever the popup is reopened.
       // Though, we want to always close feed containers so their expiration
       // status will be checked at next opening.
@@ -1724,17 +1724,17 @@ PlacesToolbar.prototype = {
       // Clear the dragover attribute if present, if we are dragging into a
       // folder in the hierachy of current opened popup we don't clear
       // this attribute on clearOverFolder.  See Notify for closeTimer.
       if (parent.hasAttribute("dragover"))
         parent.removeAttribute("dragover");
     }
   },
 
-  _onMouseMove: function PT__onMouseMove(aEvent) {
+  _onMouseMove: function(aEvent) {
     // Used in dragStart to prevent dragging folders when dragging down.
     this._cachedMouseMoveEvent = aEvent;
 
     if (this._openedMenuButton == null ||
         PlacesControllerDragHelper.getSession())
       return;
 
     let target = aEvent.originalTarget;
@@ -1770,50 +1770,50 @@ function PlacesMenu(aPopupShowingEvent, 
 
   PlacesViewBase.call(this, aPlace, aOptions);
   this._onPopupShowing(aPopupShowingEvent);
 }
 
 PlacesMenu.prototype = {
   __proto__: PlacesViewBase.prototype,
 
-  QueryInterface: function PM_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIDOMEventListener))
       return this;
 
     return PlacesViewBase.prototype.QueryInterface.apply(this, arguments);
   },
 
-  _removeChild: function PM_removeChild(aChild) {
+  _removeChild: function(aChild) {
     PlacesViewBase.prototype._removeChild.apply(this, arguments);
   },
 
-  uninit: function PM_uninit() {
+  uninit: function() {
     this._removeEventListeners(this._rootElt, ["popupshowing", "popuphidden"],
                                true);
     this._removeEventListeners(window, ["unload"], false);
 
     PlacesViewBase.prototype.uninit.apply(this, arguments);
   },
 
-  handleEvent: function PM_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "unload":
         this.uninit();
         break;
       case "popupshowing":
         this._onPopupShowing(aEvent);
         break;
       case "popuphidden":
         this._onPopupHidden(aEvent);
         break;
     }
   },
 
-  _onPopupHidden: function PM__onPopupHidden(aEvent) {
+  _onPopupHidden: function(aEvent) {
     // Avoid handling popuphidden of inner views.
     let popup = aEvent.originalTarget;
     let placesNode = popup._placesNode;
     if (!placesNode || PlacesUIUtils.getViewForNode(popup) != this)
       return;
 
     // UI performance: folder queries are cheap, keep the resultnode open
     // so we don't rebuild its contents whenever the popup is reopened.
@@ -1838,21 +1838,21 @@ function PlacesPanelMenuView(aPlace, aVi
   this.options = aOptions;
 
   PlacesViewBase.call(this, aPlace, aOptions);
 }
 
 PlacesPanelMenuView.prototype = {
   __proto__: PlacesViewBase.prototype,
 
-  QueryInterface: function PAMV_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     return PlacesViewBase.prototype.QueryInterface.apply(this, arguments);
   },
 
-  uninit: function PAMV_uninit() {
+  uninit: function() {
     PlacesViewBase.prototype.uninit.apply(this, arguments);
   },
 
   _insertNewItem:
   function PAMV__insertNewItem(aChild, aBefore) {
     this._domNodes.delete(aChild);
 
     let type = aChild.type;
@@ -1952,27 +1952,27 @@ PlacesPanelMenuView.prototype = {
       PlacesUtils.livemarks.getLivemark({ id: aPlacesNode.itemId })
         .then(aLivemark => {
           this.controller.cacheLivemarkInfo(aPlacesNode, aLivemark);
           this.invalidateContainer(aPlacesNode);
         }, Components.utils.reportError);
     }
   },
 
-  nodeTitleChanged: function PAMV_nodeTitleChanged(aPlacesNode, aNewTitle) {
+  nodeTitleChanged: function(aPlacesNode, aNewTitle) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
 
     // There's no UI representation for the root node.
     if (elt == this._rootElt)
       return;
 
     PlacesViewBase.prototype.nodeTitleChanged.apply(this, arguments);
   },
 
-  invalidateContainer: function PAMV_invalidateContainer(aPlacesNode) {
+  invalidateContainer: function(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     if (elt != this._rootElt)
       return;
 
     // Container is the toolbar itself.
     while (this._rootElt.hasChildNodes()) {
       this._rootElt.removeChild(this._rootElt.firstChild);
     }
diff --git a/browser/components/places/content/controller.js b/browser/components/places/content/controller.js
--- a/browser/components/places/content/controller.js
+++ b/browser/components/places/content/controller.js
@@ -96,25 +96,25 @@ PlacesController.prototype = {
    */
   _view: null,
 
   QueryInterface: XPCOMUtils.generateQI([
     Ci.nsIClipboardOwner
   ]),
 
   // nsIClipboardOwner
-  LosingOwnership: function PC_LosingOwnership (aXferable) {
+  LosingOwnership: function(aXferable) {
     this.cutNodes = [];
   },
 
-  terminate: function PC_terminate() {
+  terminate: function() {
     this._releaseClipboardOwnership();
   },
 
-  supportsCommand: function PC_supportsCommand(aCommand) {
+  supportsCommand: function(aCommand) {
     // Non-Places specific commands that we also support
     switch (aCommand) {
     case "cmd_undo":
     case "cmd_redo":
     case "cmd_cut":
     case "cmd_copy":
     case "cmd_paste":
     case "cmd_delete":
@@ -123,17 +123,17 @@ PlacesController.prototype = {
     }
 
     // All other Places Commands are prefixed with "placesCmd_" ... this
     // filters out other commands that we do _not_ support (see 329587).
     const CMD_PREFIX = "placesCmd_";
     return (aCommand.substr(0, CMD_PREFIX.length) == CMD_PREFIX);
   },
 
-  isCommandEnabled: function PC_isCommandEnabled(aCommand) {
+  isCommandEnabled: function(aCommand) {
     if (PlacesUIUtils.useAsyncTransactions) {
       switch (aCommand) {
       case "placesCmd_new:folder":
       case "placesCmd_new:bookmark":
       case "placesCmd_createBookmark":
         return false;
       }
     }
@@ -210,17 +210,17 @@ PlacesController.prototype = {
     case "placesCmd_createBookmark":
       var node = this._view.selectedNode;
       return node && PlacesUtils.nodeIsURI(node) && node.itemId == -1;
     default:
       return false;
     }
   },
 
-  doCommand: function PC_doCommand(aCommand) {
+  doCommand: function(aCommand) {
     switch (aCommand) {
     case "cmd_undo":
       if (!PlacesUIUtils.useAsyncTransactions) {
         PlacesUtils.transactionManager.undoTransaction();
         return;
       }
       PlacesTransactions.undo().then(null, Components.utils.reportError);
       break;
@@ -303,17 +303,17 @@ PlacesController.prototype = {
                                                      , "loadInSidebar" ]
                                        , uri: NetUtil.newURI(node.uri)
                                        , title: node.title
                                        }, window.top);
       break;
     }
   },
 
-  onEvent: function PC_onEvent(eventName) { },
+  onEvent: function(eventName) { },
 
 
   /**
    * Determine whether or not the selection can be removed, either by the
    * delete or cut operations based on whether or not any of its contents
    * are non-removable. We don't need to worry about recursion here since it
    * is a policy decision that a removable item not be placed inside a non-
    * removable item.
@@ -341,30 +341,30 @@ PlacesController.prototype = {
     }
 
     return true;
   },
 
   /**
    * Determines whether or not nodes can be inserted relative to the selection.
    */
-  _canInsert: function PC__canInsert(isPaste) {
+  _canInsert: function(isPaste) {
     var ip = this._view.insertionPoint;
     return ip != null && (isPaste || ip.isTag != true);
   },
 
   /**
    * Looks at the data on the clipboard to see if it is paste-able.
    * Paste-able data is:
    *   - in a format that the view can receive
    * @return true if: - clipboard data is of a TYPE_X_MOZ_PLACE_* flavor,
    *                  - clipboard data is of type TEXT_UNICODE and
    *                    is a valid URI.
    */
-  _isClipboardDataPasteable: function PC__isClipboardDataPasteable() {
+  _isClipboardDataPasteable: function() {
     // if the clipboard contains TYPE_X_MOZ_PLACE_* data, it is definitely
     // pasteable, with no need to unwrap all the nodes.
 
     var flavors = PlacesUIUtils.PLACES_FLAVORS;
     var clipboard = this.clipboard;
     var hasPlacesData =
       clipboard.hasDataMatchingFlavors(flavors, flavors.length,
                                        Ci.nsIClipboard.kGlobalClipboard);
@@ -414,17 +414,17 @@ PlacesController.prototype = {
    *
    * @return an array of objects corresponding the selected nodes. Each
    *         object has each of the properties above set if its corresponding
    *         node matches the rule. In addition, the annotations names for each
    *         node are set on its corresponding object as properties.
    * Notes:
    *   1) This can be slow, so don't call it anywhere performance critical!
    */
-  _buildSelectionMetadata: function PC__buildSelectionMetadata() {
+  _buildSelectionMetadata: function() {
     var metadata = [];
     var nodes = this._view.selectedNodes;
 
     for (var i = 0; i < nodes.length; i++) {
       var nodeData = {};
       var node = nodes[i];
       var nodeType = node.type;
       var uri = null;
@@ -495,17 +495,17 @@ PlacesController.prototype = {
    * Determines if a context-menu item should be shown
    * @param   aMenuItem
    *          the context menu item
    * @param   aMetaData
    *          meta data about the selection
    * @return true if the conditions (see buildContextMenu) are satisfied
    *         and the item can be displayed, false otherwise.
    */
-  _shouldShowMenuItem: function PC__shouldShowMenuItem(aMenuItem, aMetaData) {
+  _shouldShowMenuItem: function(aMenuItem, aMetaData) {
     var selectiontype = aMenuItem.getAttribute("selectiontype");
     if (!selectiontype) {
       selectiontype = "single|multiple";
     }
     var selectionTypes = selectiontype.split("|");
     if (selectionTypes.indexOf("any") != -1) {
       return true;
     }
@@ -588,17 +588,17 @@ PlacesController.prototype = {
    *  7) These attributes should not be set on separators for which the
    *     visibility state is "auto-detected."
    *  8) The "hideifprivatebrowsing" attribute may be set on a menu-item to
    *     true if it should be hidden inside the private browsing mode
    * @param   aPopup
    *          The menupopup to build children into.
    * @return true if at least one item is visible, false otherwise.
    */
-  buildContextMenu: function PC_buildContextMenu(aPopup) {
+  buildContextMenu: function(aPopup) {
     var metadata = this._buildSelectionMetadata();
     var ip = this._view.insertionPoint;
     var noIp = !ip || ip.isTag;
 
     var separator = null;
     var visibleItemsBeforeSep = false;
     var usableItemCount = 0;
     for (var i = 0; i < aPopup.childNodes.length; ++i) {
@@ -654,17 +654,17 @@ PlacesController.prototype = {
     }
 
     return usableItemCount > 0;
   },
 
   /**
    * Select all links in the current view.
    */
-  selectAll: function PC_selectAll() {
+  selectAll: function() {
     this._view.selectAll();
   },
 
   /**
    * Opens the bookmark properties for the selected URI Node.
    */
   showBookmarkPropertiesForSelection:
   function PC_showBookmarkPropertiesForSelection() {
@@ -690,39 +690,39 @@ PlacesController.prototype = {
                                      , hiddenRows: [ "folderPicker" ]
                                      }, window.top);
   },
 
   /**
    * This method can be run on a URI parameter to ensure that it didn't
    * receive a string instead of an nsIURI object.
    */
-  _assertURINotString: function PC__assertURINotString(value) {
+  _assertURINotString: function(value) {
     NS_ASSERT((typeof(value) == "object") && !(value instanceof String),
            "This method should be passed a URI as a nsIURI object, not as a string.");
   },
 
   /**
    * Reloads the selected livemark if any.
    */
-  reloadSelectedLivemark: function PC_reloadSelectedLivemark() {
+  reloadSelectedLivemark: function() {
     var selectedNode = this._view.selectedNode;
     if (selectedNode) {
       let itemId = selectedNode.itemId;
       PlacesUtils.livemarks.getLivemark({ id: itemId })
         .then(aLivemark => {
           aLivemark.reload(true);
         }, Components.utils.reportError);
     }
   },
 
   /**
    * Opens the links in the selected folder, or the selected links in new tabs.
    */
-  openSelectionInTabs: function PC_openLinksInTabs(aEvent) {
+  openSelectionInTabs: function(aEvent) {
     var node = this._view.selectedNode;
     var nodes = this._view.selectedNodes;
     // In the case of no selection, open the root node:
     if (!node && !nodes.length) {
       node = this._view.result.root;
     }
     if (node && PlacesUtils.nodeIsContainer(node))
       PlacesUIUtils.openContainerNodeInTabs(node, aEvent, this._view);
@@ -731,17 +731,17 @@ PlacesController.prototype = {
   },
 
   /**
    * Shows the Add Bookmark UI for the current insertion point.
    *
    * @param aType
    *        the type of the new item (bookmark/livemark/folder)
    */
-  newItem: function PC_newItem(aType) {
+  newItem: function(aType) {
     let ip = this._view.insertionPoint;
     if (!ip)
       throw Cr.NS_ERROR_NOT_AVAILABLE;
 
     let performed =
       PlacesUIUtils.showBookmarkDialog({ action: "add"
                                        , type: aType
                                        , defaultInsertionPoint: ip
@@ -779,17 +779,17 @@ PlacesController.prototype = {
     let itemId = yield PlacesUtils.promiseItemId(guid);
     // Select the new item.
     this._view.selectItems([itemId], false);
   }),
 
   /**
    * Opens a dialog for moving the selected nodes.
    */
-  moveSelectedBookmarks: function PC_moveBookmarks() {
+  moveSelectedBookmarks: function() {
     window.openDialog("chrome://browser/content/places/moveBookmarks.xul",
                       "", "chrome, modal",
                       this._view.selectedNodes);
   },
 
   /**
    * Sort the selected folder by name
    */
@@ -809,17 +809,17 @@ PlacesController.prototype = {
    * see if the selected node specified is already implicitly being removed
    * because it is a child of that folder.
    * @param   node
    *          Node to check for containment.
    * @param   pastFolders
    *          List of folders the calling function has already traversed
    * @return true if the node should be skipped, false otherwise.
    */
-  _shouldSkipNode: function PC_shouldSkipNode(node, pastFolders) {
+  _shouldSkipNode: function(node, pastFolders) {
     /**
      * Determines if a node is contained by another node within a resultset.
      * @param   node
      *          The node to check for containment for
      * @param   parent
      *          The parent container to check for containment in
      * @return true if node is a member of parent's children, false otherwise.
      */
@@ -845,17 +845,17 @@ PlacesController.prototype = {
    * A range is an array of adjacent nodes in a view.
    * @param   [in] range
    *          An array of nodes to remove. Should all be adjacent.
    * @param   [out] transactions
    *          An array of transactions.
    * @param   [optional] removedFolders
    *          An array of folder nodes that have already been removed.
    */
-  _removeRange: function PC__removeRange(range, transactions, removedFolders) {
+  _removeRange: function(range, transactions, removedFolders) {
     NS_ASSERT(transactions instanceof Array, "Must pass a transactions array");
     if (!removedFolders)
       removedFolders = [];
 
     for (var i = 0; i < range.length; ++i) {
       var node = range[i];
       if (this._shouldSkipNode(node, removedFolders))
         continue;
@@ -957,17 +957,17 @@ PlacesController.prototype = {
     }
   }),
 
   /**
    * Removes the set of selected ranges from history.
    *
    * @note history deletes are not undoable.
    */
-  _removeRowsFromHistory: function PC__removeRowsFromHistory() {
+  _removeRowsFromHistory: function() {
     let nodes = this._view.selectedNodes;
     let URIs = [];
     for (let i = 0; i < nodes.length; ++i) {
       let node = nodes[i];
       if (PlacesUtils.nodeIsURI(node)) {
         let uri = NetUtil.newURI(node.uri);
         // Avoid duplicates.
         if (URIs.indexOf(uri) < 0) {
@@ -1000,17 +1000,17 @@ PlacesController.prototype = {
 
   /**
    * Removes history visits for an history container node.
    * @param   [in] aContainerNode
    *          The container node to remove.
    *
    * @note history deletes are not undoable.
    */
-  _removeHistoryContainer: function PC__removeHistoryContainer(aContainerNode) {
+  _removeHistoryContainer: function(aContainerNode) {
     if (PlacesUtils.nodeIsHost(aContainerNode)) {
       // Site container.
       PlacesUtils.bhistory.removePagesFromHost(aContainerNode.title, true);
     }
     else if (PlacesUtils.nodeIsDay(aContainerNode)) {
       // Day container.
       let query = aContainerNode.getQueries()[0];
       let beginTime = query.beginTime;
@@ -1065,17 +1065,17 @@ PlacesController.prototype = {
   }),
 
   /**
    * Fills a DataTransfer object with the content of the selection that can be
    * dropped elsewhere.
    * @param   aEvent
    *          The dragstart event.
    */
-  setDataTransfer: function PC_setDataTransfer(aEvent) {
+  setDataTransfer: function(aEvent) {
     let dt = aEvent.dataTransfer;
 
     let result = this._view.result;
     let didSuppressNotifications = result.suppressNotifications;
     if (!didSuppressNotifications)
       result.suppressNotifications = true;
 
     function addData(type, index, overrideURI) {
@@ -1135,35 +1135,35 @@ PlacesController.prototype = {
     // instances should instead be handled as copies (The sources are not
     // available for this instance).
     if (action == "cut" && actionOwner != this.profileName)
       action = "copy";
 
     return action;
   },
 
-  _releaseClipboardOwnership: function PC__releaseClipboardOwnership() {
+  _releaseClipboardOwnership: function() {
     if (this.cutNodes.length > 0) {
       // This clears the logical clipboard, doesn't remove data.
       this.clipboard.emptyClipboard(Ci.nsIClipboard.kGlobalClipboard);
     }
   },
 
-  _clearClipboard: function PC__clearClipboard() {
+  _clearClipboard: function() {
     let xferable = Cc["@mozilla.org/widget/transferable;1"].
                    createInstance(Ci.nsITransferable);
     xferable.init(null);
     // Empty transferables may cause crashes, so just add an unknown type.
     const TYPE = "text/x-moz-place-empty";
     xferable.addDataFlavor(TYPE);
     xferable.setTransferData(TYPE, PlacesUtils.toISupportsString(""), 0);
     this.clipboard.setData(xferable, null, Ci.nsIClipboard.kGlobalClipboard);
   },
 
-  _populateClipboard: function PC__populateClipboard(aNodes, aAction) {
+  _populateClipboard: function(aNodes, aAction) {
     // This order is _important_! It controls how this and other applications
     // select data to be inserted based on type.
     let contents = [
       { type: PlacesUtils.TYPE_X_MOZ_PLACE, entries: [] },
       { type: PlacesUtils.TYPE_X_MOZ_URL, entries: [] },
       { type: PlacesUtils.TYPE_HTML, entries: [] },
       { type: PlacesUtils.TYPE_UNICODE, entries: [] },
     ];
@@ -1235,34 +1235,34 @@ PlacesController.prototype = {
     this._cutNodes = aNodes;
     updateCutNodes(true);
     return aNodes;
   },
 
   /**
    * Copy Bookmarks and Folders to the clipboard
    */
-  copy: function PC_copy() {
+  copy: function() {
     let result = this._view.result;
     let didSuppressNotifications = result.suppressNotifications;
     if (!didSuppressNotifications)
       result.suppressNotifications = true;
     try {
       this._populateClipboard(this._view.selectedNodes, "copy");
     }
     finally {
       if (!didSuppressNotifications)
         result.suppressNotifications = false;
     }
   },
 
   /**
    * Cut Bookmarks and Folders to the clipboard
    */
-  cut: function PC_cut() {
+  cut: function() {
     let result = this._view.result;
     let didSuppressNotifications = result.suppressNotifications;
     if (!didSuppressNotifications)
       result.suppressNotifications = true;
     try {
       this._populateClipboard(this._view.selectedNodes, "cut");
       this.cutNodes = this._view.selectedNodes;
     }
@@ -1395,17 +1395,17 @@ PlacesController.prototype = {
   /**
    * Cache the livemark info for a node.  This allows the controller and the
    * views to treat the given node as a livemark.
    * @param aNode
    *        a places result node.
    * @param aLivemarkInfo
    *        a mozILivemarkInfo object.
    */
-  cacheLivemarkInfo: function PC_cacheLivemarkInfo(aNode, aLivemarkInfo) {
+  cacheLivemarkInfo: function(aNode, aLivemarkInfo) {
     this._cachedLivemarkInfoObjects.set(aNode, aLivemarkInfo);
   },
 
   /**
    * Returns whether or not there's cached mozILivemarkInfo object for a node.
    * @param aNode
    *        a places result node.
    * @return true if there's a cached mozILivemarkInfo object for
@@ -1441,39 +1441,39 @@ let PlacesControllerDragHelper = {
    * Determines if the mouse is currently being dragged over a child node of
    * this menu. This is necessary so that the menu doesn't close while the
    * mouse is dragging over one of its submenus
    * @param   node
    *          The container node
    * @return true if the user is dragging over a node within the hierarchy of
    *         the container, false otherwise.
    */
-  draggingOverChildNode: function PCDH_draggingOverChildNode(node) {
+  draggingOverChildNode: function(node) {
     let currentNode = this.currentDropTarget;
     while (currentNode) {
       if (currentNode == node)
         return true;
       currentNode = currentNode.parentNode;
     }
     return false;
   },
 
   /**
    * @return The current active drag session. Returns null if there is none.
    */
-  getSession: function PCDH__getSession() {
+  getSession: function() {
     return this.dragService.getCurrentSession();
   },
 
   /**
    * Extract the first accepted flavor from a list of flavors.
    * @param aFlavors
    *        The flavors list of type DOMStringList.
    */
-  getFirstValidFlavor: function PCDH_getFirstValidFlavor(aFlavors) {
+  getFirstValidFlavor: function(aFlavors) {
     for (let i = 0; i < aFlavors.length; i++) {
       if (PlacesUIUtils.SUPPORTED_FLAVORS.indexOf(aFlavors[i]) != -1)
         return aFlavors[i];
     }
 
     // If no supported flavor is found, check if data includes text/plain
     // contents.  If so, request them as text/unicode, a conversion will happen
     // automatically.
@@ -1485,17 +1485,17 @@ let PlacesControllerDragHelper = {
   },
 
   /**
    * Determines whether or not the data currently being dragged can be dropped
    * on a places view.
    * @param ip
    *        The insertion point where the items should be dropped.
    */
-  canDrop: function PCDH_canDrop(ip, dt) {
+  canDrop: function(ip, dt) {
     let dropCount = dt.mozItemCount;
 
     // Check every dragged item.
     for (let i = 0; i < dropCount; i++) {
       let flavor = this.getFirstValidFlavor(dt.mozTypesAt(i));
       if (!flavor)
         return false;
 
diff --git a/browser/components/places/content/editBookmarkOverlay.js b/browser/components/places/content/editBookmarkOverlay.js
--- a/browser/components/places/content/editBookmarkOverlay.js
+++ b/browser/components/places/content/editBookmarkOverlay.js
@@ -35,29 +35,29 @@ var gEditItemOverlay = {
 
   get multiEdit() {
     return this._multiEdit;
   },
 
   /**
    * Determines the initial data for the item edited or added by this dialog
    */
-  _determineInfo: function EIO__determineInfo(aInfo) {
+  _determineInfo: function(aInfo) {
     // hidden rows
     if (aInfo && aInfo.hiddenRows)
       this._hiddenRows = aInfo.hiddenRows;
     else
       this._hiddenRows.splice(0, this._hiddenRows.length);
     // force-read-only
     this._readOnly = aInfo && aInfo.forceReadOnly;
     this._titleOverride = aInfo && aInfo.titleOverride ? aInfo.titleOverride
                                                        : "";
   },
 
-  _showHideRows: function EIO__showHideRows() {
+  _showHideRows: function() {
     var isBookmark = this._itemId != -1 &&
                      this._itemType == Ci.nsINavBookmarksService.TYPE_BOOKMARK;
     var isQuery = false;
     if (this._uri)
       isQuery = this._uri.schemeIs("place");
 
     this._element("nameRow").collapsed = this._hiddenRows.indexOf("name") != -1;
     this._element("folderRow").collapsed =
@@ -94,17 +94,17 @@ var gEditItemOverlay = {
    *        initialization. The following properties may bet set:
    *        * hiddenRows (Strings array): list of rows to be hidden regardless
    *          of the item edited. Possible values: "title", "location",
    *          "description", "keyword", "loadInSidebar", "feedLocation",
    *          "siteLocation", folderPicker"
    *        * forceReadOnly - set this flag to initialize the panel to its
    *          read-only (view) mode even if the given item is editable.
    */
-  initPanel: function EIO_initPanel(aFor, aInfo) {
+  initPanel: function(aFor, aInfo) {
     // For sanity ensure that the implementer has uninited the panel before
     // trying to init it again, or we could end up leaking due to observers.
     if (this._initialized)
       this.uninitPanel(false);
 
     var aItemIdList;
     if (Array.isArray(aFor)) {
       aItemIdList = aFor;
@@ -268,17 +268,17 @@ var gEditItemOverlay = {
     var folderTitle = PlacesUtils.bookmarks.getItemTitle(aFolderId)
     folderMenuItem.folderId = aFolderId;
     folderMenuItem.setAttribute("label", folderTitle);
     folderMenuItem.className = "menuitem-iconic folder-icon";
     aMenupopup.appendChild(folderMenuItem);
     return folderMenuItem;
   },
 
-  _initFolderMenuList: function EIO__initFolderMenuList(aSelectedFolder) {
+  _initFolderMenuList: function(aSelectedFolder) {
     // clean up first
     var menupopup = this._folderMenuList.menupopup;
     while (menupopup.childNodes.length > 6)
       menupopup.removeChild(menupopup.lastChild);
 
     const bms = PlacesUtils.bookmarks;
     const annos = PlacesUtils.annotations;
 
@@ -334,55 +334,55 @@ var gEditItemOverlay = {
     this._folderMenuList.setAttribute("selectedIndex",
                                       this._folderMenuList.selectedIndex);
 
     // Hide the folders-separator if no folder is annotated as recently-used
     this._element("foldersSeparator").hidden = (menupopup.childNodes.length <= 6);
     this._folderMenuList.disabled = this._readOnly;
   },
 
-  QueryInterface: function EIO_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIDOMEventListener) ||
         aIID.equals(Ci.nsINavBookmarkObserver) ||
         aIID.equals(Ci.nsISupports))
       return this;
 
     throw Cr.NS_ERROR_NO_INTERFACE;
   },
 
-  _element: function EIO__element(aID) {
+  _element: function(aID) {
     return document.getElementById("editBMPanel_" + aID);
   },
 
-  _getItemStaticTitle: function EIO__getItemStaticTitle() {
+  _getItemStaticTitle: function() {
     if (this._titleOverride)
       return this._titleOverride;
 
     let title = "";
     if (this._itemId == -1) {
       title = PlacesUtils.history.getPageTitle(this._uri);
     }
     else {
       title = PlacesUtils.bookmarks.getItemTitle(this._itemId);
     }
     return title;
   },
 
-  _initNamePicker: function EIO_initNamePicker() {
+  _initNamePicker: function() {
     var namePicker = this._element("namePicker");
     namePicker.value = this._getItemStaticTitle();
     namePicker.readOnly = this._readOnly;
 
     // clear the undo stack
     var editor = namePicker.editor;
     if (editor)
       editor.transactionManager.clear();
   },
 
-  uninitPanel: function EIO_uninitPanel(aHideCollapsibleElements) {
+  uninitPanel: function(aHideCollapsibleElements) {
     if (aHideCollapsibleElements) {
       // hide the folder tree if it was previously visible
       var folderTreeRow = this._element("folderTreeRow");
       if (!folderTreeRow.collapsed)
         this.toggleFolderTreeVisibility();
 
       // hide the tag selector if it was previously visible
       var tagsSelectorRow = this._element("tagsSelectorRow");
@@ -411,28 +411,28 @@ var gEditItemOverlay = {
     this._itemIds = [];
     this._multiEdit = false;
     this._firstEditedField = "";
     this._initialized = false;
     this._titleOverride = "";
     this._readOnly = false;
   },
 
-  onTagsFieldBlur: function EIO_onTagsFieldBlur() {
+  onTagsFieldBlur: function() {
     if (this._updateTags()) // if anything has changed
       this._mayUpdateFirstEditField("tagsField");
   },
 
-  _updateTags: function EIO__updateTags() {
+  _updateTags: function() {
     if (this._multiEdit)
       return this._updateMultipleTagsForItems();
     return this._updateSingleTagForItem();
   },
 
-  _updateSingleTagForItem: function EIO__updateSingleTagForItem() {
+  _updateSingleTagForItem: function() {
     var currentTags = PlacesUtils.tagging.getTagsForURI(this._uri);
     var tags = this._getTagsArrayFromTagField();
     if (tags.length > 0 || currentTags.length > 0) {
       var tagsToRemove = [];
       var tagsToAdd = [];
       var txns = []; 
       for (var i = 0; i < currentTags.length; i++) {
         if (tags.indexOf(currentTags[i]) == -1)
@@ -467,32 +467,32 @@ var gEditItemOverlay = {
 
    /**
     * Stores the first-edit field for this dialog, if the passed-in field
     * is indeed the first edited field
     * @param aNewField
     *        the id of the field that may be set (without the "editBMPanel_"
     *        prefix)
     */
-  _mayUpdateFirstEditField: function EIO__mayUpdateFirstEditField(aNewField) {
+  _mayUpdateFirstEditField: function(aNewField) {
     // * The first-edit-field behavior is not applied in the multi-edit case
     // * if this._firstEditedField is already set, this is not the first field,
     //   so there's nothing to do
     if (this._multiEdit || this._firstEditedField)
       return;
 
     this._firstEditedField = aNewField;
 
     // set the pref
     var prefs = Cc["@mozilla.org/preferences-service;1"].
                 getService(Ci.nsIPrefBranch);
     prefs.setCharPref("browser.bookmarks.editDialog.firstEditField", aNewField);
   },
 
-  _updateMultipleTagsForItems: function EIO__updateMultipleTagsForItems() {
+  _updateMultipleTagsForItems: function() {
     var tags = this._getTagsArrayFromTagField();
     if (tags.length > 0 || this._allTags.length > 0) {
       var tagsToRemove = [];
       var tagsToAdd = [];
       var txns = []; 
       for (var i = 0; i < this._allTags.length; i++) {
         if (tags.indexOf(this._allTags[i]) == -1)
           tagsToRemove.push(this._allTags[i]);
@@ -535,17 +535,17 @@ var gEditItemOverlay = {
         // Ensure the tagsField is in sync, clean it up from empty tags
         this._initTextField("tagsField", tags, false);
         return true;
       }
     }
     return false;
   },
 
-  onNamePickerBlur: function EIO_onNamePickerBlur() {
+  onNamePickerBlur: function() {
     if (this._itemId == -1)
       return;
 
     var namePicker = this._element("namePicker")
 
     // Here we update either the item title or its cached static title
     var newTitle = namePicker.value;
     if (!newTitle &&
@@ -555,61 +555,61 @@ var gEditItemOverlay = {
     }
     else if (this._getItemStaticTitle() != newTitle) {
       this._mayUpdateFirstEditField("namePicker");
       let txn = new PlacesEditItemTitleTransaction(this._itemId, newTitle);
       PlacesUtils.transactionManager.doTransaction(txn);
     }
   },
 
-  onDescriptionFieldBlur: function EIO_onDescriptionFieldBlur() {
+  onDescriptionFieldBlur: function() {
     var description = this._element("descriptionField").value;
     if (description != PlacesUIUtils.getItemDescription(this._itemId)) {
       var annoObj = { name   : PlacesUIUtils.DESCRIPTION_ANNO,
                       type   : Ci.nsIAnnotationService.TYPE_STRING,
                       flags  : 0,
                       value  : description,
                       expires: Ci.nsIAnnotationService.EXPIRE_NEVER };
       var txn = new PlacesSetItemAnnotationTransaction(this._itemId, annoObj);
       PlacesUtils.transactionManager.doTransaction(txn);
     }
   },
 
-  onLocationFieldBlur: function EIO_onLocationFieldBlur() {
+  onLocationFieldBlur: function() {
     var uri;
     try {
       uri = PlacesUIUtils.createFixedURI(this._element("locationField").value);
     }
     catch(ex) { return; }
 
     if (!this._uri.equals(uri)) {
       var txn = new PlacesEditBookmarkURITransaction(this._itemId, uri);
       PlacesUtils.transactionManager.doTransaction(txn);
       this._uri = uri;
     }
   },
 
-  onKeywordFieldBlur: function EIO_onKeywordFieldBlur() {
+  onKeywordFieldBlur: function() {
     var keyword = this._element("keywordField").value;
     if (keyword != PlacesUtils.bookmarks.getKeywordForBookmark(this._itemId)) {
       var txn = new PlacesEditBookmarkKeywordTransaction(this._itemId, keyword);
       PlacesUtils.transactionManager.doTransaction(txn);
     }
   },
 
   onLoadInSidebarCheckboxCommand:
   function EIO_onLoadInSidebarCheckboxCommand() {
     let annoObj = { name : PlacesUIUtils.LOAD_IN_SIDEBAR_ANNO };
     if (this._element("loadInSidebarCheckbox").checked)
       annoObj.value = true;
     let txn = new PlacesSetItemAnnotationTransaction(this._itemId, annoObj);
     PlacesUtils.transactionManager.doTransaction(txn);
   },
 
-  toggleFolderTreeVisibility: function EIO_toggleFolderTreeVisibility() {
+  toggleFolderTreeVisibility: function() {
     var expander = this._element("foldersExpander");
     var folderTreeRow = this._element("folderTreeRow");
     if (!folderTreeRow.collapsed) {
       expander.className = "expander-down";
       expander.setAttribute("tooltiptext",
                             expander.getAttribute("tooltiptextdown"));
       folderTreeRow.collapsed = true;
       this._element("chooseFolderSeparator").hidden =
@@ -665,17 +665,17 @@ var gEditItemOverlay = {
 
     // 3 special folders + separator + folder-items-count limit
     if (menupopup.childNodes.length == 4 + MAX_FOLDER_ITEM_IN_MENU_LIST)
       menupopup.removeChild(menupopup.lastChild);
 
     return this._appendFolderItemToMenupopup(menupopup, aFolderId);
   },
 
-  onFolderMenuListCommand: function EIO_onFolderMenuListCommand(aEvent) {
+  onFolderMenuListCommand: function(aEvent) {
     // Set a selectedIndex attribute to show special icons
     this._folderMenuList.setAttribute("selectedIndex",
                                       this._folderMenuList.selectedIndex);
 
     if (aEvent.target.id == "editBMPanel_chooseFolderMenuItem") {
       // reset the selection back to where it was and expand the tree
       // (this menu-item is hidden when the tree is already visible
       var container = PlacesUtils.bookmarks.getFolderIdForItem(this._itemId);
@@ -708,17 +708,17 @@ var gEditItemOverlay = {
     if (!folderTreeRow.collapsed) {
       var selectedNode = this._folderTree.selectedNode;
       if (!selectedNode ||
           PlacesUtils.getConcreteItemId(selectedNode) != container)
         this._folderTree.selectItems([container]);
     }
   },
 
-  onFolderTreeSelect: function EIO_onFolderTreeSelect() {
+  onFolderTreeSelect: function() {
     var selectedNode = this._folderTree.selectedNode;
 
     // Disable the "New Folder" button if we cannot create a new folder
     this._element("newFolderButton")
         .disabled = !this._folderTree.insertionPoint || !selectedNode;
 
     if (!selectedNode)
       return;
@@ -768,17 +768,17 @@ var gEditItemOverlay = {
                  type: Ci.nsIAnnotationService.TYPE_INT32,
                  flags: 0,
                  value: aLastUsed ? new Date().getTime() : null,
                  expires: Ci.nsIAnnotationService.EXPIRE_NEVER };
 
     return anno;
   },
 
-  _rebuildTagsSelectorList: function EIO__rebuildTagsSelectorList() {
+  _rebuildTagsSelectorList: function() {
     var tagsSelector = this._element("tagsSelector");
     var tagsSelectorRow = this._element("tagsSelectorRow");
     if (tagsSelectorRow.collapsed)
       return;
 
     // Save the current scroll position and restore it after the rebuild.
     let firstIndex = tagsSelector.getIndexOfFirstVisibleRow();
     let selectedIndex = tagsSelector.selectedIndex;
@@ -811,17 +811,17 @@ var gEditItemOverlay = {
     tagsSelector.scrollToIndex(firstIndex);
     if (selectedIndex >= 0 && tagsSelector.itemCount > 0) {
       selectedIndex = Math.min(selectedIndex, tagsSelector.itemCount - 1);
       tagsSelector.selectedIndex = selectedIndex;
       tagsSelector.ensureIndexIsVisible(selectedIndex);
     }
   },
 
-  toggleTagsSelector: function EIO_toggleTagsSelector() {
+  toggleTagsSelector: function() {
     var tagsSelector = this._element("tagsSelector");
     var tagsSelectorRow = this._element("tagsSelectorRow");
     var expander = this._element("tagsSelectorExpander");
     if (tagsSelectorRow.collapsed) {
       expander.className = "expander-up";
       expander.setAttribute("tooltiptext",
                             expander.getAttribute("tooltiptextup"));
       tagsSelectorRow.collapsed = false;
@@ -838,24 +838,24 @@ var gEditItemOverlay = {
     }
   },
 
   /**
    * Splits "tagsField" element value, returning an array of valid tag strings.
    *
    * @return Array of tag strings found in the field value.
    */
-  _getTagsArrayFromTagField: function EIO__getTagsArrayFromTagField() {
+  _getTagsArrayFromTagField: function() {
     let tags = this._element("tagsField").value;
     return tags.trim()
                .split(/\s*,\s*/) // Split on commas and remove spaces.
                .filter(function (tag) tag.length > 0); // Kill empty tags.
   },
 
-  newFolder: function EIO_newFolder() {
+  newFolder: function() {
     var ip = this._folderTree.insertionPoint;
 
     // default to the bookmarks menu folder
     if (!ip || ip.itemId == PlacesUIUtils.allBookmarksFolderId) {
         ip = new InsertionPoint(PlacesUtils.bookmarksMenuFolderId,
                                 PlacesUtils.bookmarks.DEFAULT_INDEX,
                                 Ci.nsITreeView.DROP_ON);
     }
@@ -868,17 +868,17 @@ var gEditItemOverlay = {
     this._folderTree.selectItems([ip.itemId]);
     PlacesUtils.asContainer(this._folderTree.selectedNode).containerOpen = true;
     this._folderTree.selectItems([this._lastNewItem]);
     this._folderTree.startEditing(this._folderTree.view.selection.currentIndex,
                                   this._folderTree.columns.getFirstColumn());
   },
 
   // nsIDOMEventListener
-  handleEvent: function EIO_nsIDOMEventListener(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
     case "CheckboxStateChange":
       // Update the tags field when items are checked/unchecked in the listbox
       let tags = this._getTagsArrayFromTagField();
       let tagCheckbox = aEvent.target;
 
       let curTagIndex = tags.indexOf(tagCheckbox.label);
 
diff --git a/browser/components/places/content/menu.xml b/browser/components/places/content/menu.xml
--- a/browser/components/places/content/menu.xml
+++ b/browser/components/places/content/menu.xml
@@ -195,23 +195,23 @@
 
         get closeMenuTimer() {
           return this._closeMenuTimer;
         },
         set closeMenuTimer(val) {
           return this._closeMenuTimer = val;
         },
 
-        setTimer: function OF__setTimer(aTime) {
+        setTimer: function(aTime) {
           var timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
           timer.initWithCallback(this, aTime, timer.TYPE_ONE_SHOT);
           return timer;
         },
 
-        notify: function OF__notify(aTimer) {
+        notify: function(aTimer) {
           // Function to process all timer notifications.
 
           if (aTimer == this._folder.openTimer) {
             // Timer to open a submenu that's being dragged over.
             this._folder.elt.lastChild.setAttribute("autoopened", "true");
             this._folder.elt.lastChild.showPopup(this._folder.elt);
             this._folder.openTimer = null;
           }
@@ -248,33 +248,33 @@
             }
             this._closeMenuTimer = null;
           }
         },
 
         //  Helper function to close all parent menus of this menu,
         //  as long as none of the parent's children are currently being
         //  dragged over.
-        closeParentMenus: function OF__closeParentMenus() {
+        closeParentMenus: function() {
           var popup = this._self;
           var parent = popup.parentNode;
           while (parent) {
             if (parent.localName == "menupopup" && parent._placesNode) {
               if (PlacesControllerDragHelper.draggingOverChildNode(parent.parentNode))
                 break;
               parent.hidePopup();
             }
             parent = parent.parentNode;
           }
         },
 
         //  The mouse is no longer dragging over the stored menubutton.
         //  Close the menubutton, clear out drag styles, and clear all
         //  timers for opening/closing it.
-        clear: function OF__clear() {
+        clear: function() {
           if (this._folder.elt && this._folder.elt.lastChild) {
             if (!this._folder.elt.lastChild.hasAttribute("dragover"))
               this._folder.elt.lastChild.hidePopup();
             // remove menuactive style
             this._folder.elt.removeAttribute("_moz-menuactive");
             this._folder.elt = null;
           }
           if (this._folder.openTimer) {
diff --git a/browser/components/places/content/moveBookmarks.js b/browser/components/places/content/moveBookmarks.js
--- a/browser/components/places/content/moveBookmarks.js
+++ b/browser/components/places/content/moveBookmarks.js
@@ -17,17 +17,17 @@ var gMoveBookmarksDialog = {
   init: function() {
     this._nodes = window.arguments[0];
 
     this.foldersTree.place =
       "place:excludeItems=1&excludeQueries=1&excludeReadOnlyFolders=1&folder=" +
       PlacesUIUtils.allBookmarksFolderId;
   },
 
-  onOK: function MBD_onOK(aEvent) {
+  onOK: function(aEvent) {
     let selectedNode = this.foldersTree.selectedNode;
     let selectedFolderId = PlacesUtils.getConcreteItemId(selectedNode);
 
     if (!PlacesUIUtils.useAsyncTransactions) {
       let transactions = [];
       for (var i=0; i < this._nodes.length; i++) {
         // Nothing to do if the node is already under the selected folder
         if (this._nodes[i].parent.itemId == selectedFolderId)
@@ -52,14 +52,14 @@ var gMoveBookmarksDialog = {
         if (node.parent.itemId == selectedFolderId)
           continue;
         yield PlacesTransactions.Move({ guid: node.bookmarkGuid
                                       , newParentGuid }).transact();
       }
     }.bind(this)).then(null, Components.utils.reportError);
   },
 
-  newFolder: function MBD_newFolder() {
+  newFolder: function() {
     // The command is disabled when the tree is not focused
     this.foldersTree.focus();
     goDoCommand("placesCmd_new:folder");
   }
 };
diff --git a/browser/components/places/content/places.js b/browser/components/places/content/places.js
--- a/browser/components/places/content/places.js
+++ b/browser/components/places/content/places.js
@@ -31,17 +31,17 @@ var PlacesOrganizer = {
     "editBMPanel_keywordRow",
   ],
 
   _initFolderTree: function() {
     var leftPaneRoot = PlacesUIUtils.leftPaneFolderId;
     this._places.place = "place:excludeItems=1&expandQueries=0&folder=" + leftPaneRoot;
   },
 
-  selectLeftPaneQuery: function PO_selectLeftPaneQuery(aQueryName) {
+  selectLeftPaneQuery: function(aQueryName) {
     var itemId = PlacesUIUtils.leftPaneQueries[aQueryName];
     this._places.selectItems([itemId]);
     // Forcefully expand all-bookmarks
     if (aQueryName == "AllBookmarks" || aQueryName == "History")
       PlacesUtils.asContainer(this._places.selectedNode).containerOpen = true;
   },
 
   /**
@@ -83,17 +83,17 @@ var PlacesOrganizer = {
         PlacesUtils.asContainer(this._places.selectedNode).containerOpen = true;
       }
     } finally {
       if (!selectWasSuppressed)
         this._places.view.selection.selectEventsSuppressed = false;
     }
   },
 
-  init: function PO_init() {
+  init: function() {
     ContentArea.init();
 
     this._places = document.getElementById("placesList");
     this._initFolderTree();
 
     var leftPaneSelection = "AllBookmarks"; // default to all-bookmarks
     if (window.arguments && window.arguments[0])
       leftPaneSelection = window.arguments[0];
@@ -130,25 +130,25 @@ var PlacesOrganizer = {
 
     // remove the "Properties" context-menu item, we've our own details pane
     document.getElementById("placesContext")
             .removeChild(document.getElementById("placesContext_show:info"));
 
     ContentArea.focus();
   },
 
-  QueryInterface: function PO_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Components.interfaces.nsIDOMEventListener) ||
         aIID.equals(Components.interfaces.nsISupports))
       return this;
 
     throw Components.results.NS_NOINTERFACE;
   },
 
-  handleEvent: function PO_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (aEvent.type != "AppCommand")
       return;
 
     aEvent.stopPropagation();
     switch (aEvent.command) {
       case "Back":
         if (this._backHistory.length > 0)
           this.back();
@@ -158,17 +158,17 @@ var PlacesOrganizer = {
           this.forward();
         break;
       case "Search":
         PlacesSearchBox.findAll();
         break;
     }
   },
 
-  destroy: function PO_destroy() {
+  destroy: function() {
   },
 
   _location: null,
   get location() {
     return this._location;
   },
 
   set location(aLocation) {
@@ -200,23 +200,23 @@ var PlacesOrganizer = {
       document.getElementById("OrganizerCommand:Forward").removeAttribute("disabled");
 
     return aLocation;
   },
 
   _backHistory: [],
   _forwardHistory: [],
 
-  back: function PO_back() {
+  back: function() {
     this._forwardHistory.unshift(this.location);
     var historyEntry = this._backHistory.shift();
     this._location = null;
     this.location = historyEntry;
   },
-  forward: function PO_forward() {
+  forward: function() {
     this._backHistory.unshift(this.location);
     var historyEntry = this._forwardHistory.shift();
     this._location = null;
     this.location = historyEntry;
   },
 
   /**
    * Called when a place folder is selected in the left pane.
@@ -224,17 +224,17 @@ var PlacesOrganizer = {
    *          true if the search box should also be reset, false otherwise.
    *          The search box should be reset when a new folder in the left
    *          pane is selected; the search scope and text need to be cleared in
    *          preparation for the new folder.  Note that if the user manually
    *          resets the search box, either by clicking its reset button or by
    *          deleting its text, this will be false.
    */
   _cachedLeftPaneSelectedURI: null,
-  onPlaceSelected: function PO_onPlaceSelected(resetSearchBox) {
+  onPlaceSelected: function(resetSearchBox) {
     // Don't change the right-hand pane contents when there's no selection.
     if (!this._places.hasSelection)
       return;
 
     var node = this._places.selectedNode;
     var queries = PlacesUtils.asQuery(node).getQueries();
 
     // Items are only excluded on the left pane.
@@ -270,17 +270,17 @@ var PlacesOrganizer = {
     this.updateDetailsPane();
   },
 
   /**
    * Sets the search scope based on aNode's properties.
    * @param   aNode
    *          the node to set up scope from
    */
-  _setSearchScopeForNode: function PO__setScopeForNode(aNode) {
+  _setSearchScopeForNode: function(aNode) {
     let itemId = aNode.itemId;
 
     if (PlacesUtils.nodeIsHistoryContainer(aNode) ||
         itemId == PlacesUIUtils.leftPaneQueries["History"]) {
       PlacesQueryBuilder.setScope("history");
     }
     else if (itemId == PlacesUIUtils.leftPaneQueries["Downloads"]) {
       PlacesQueryBuilder.setScope("downloads");
@@ -293,17 +293,17 @@ var PlacesOrganizer = {
 
   /**
    * Handle clicks on the places list.
    * Single Left click, right click or modified click do not result in any
    * special action, since they're related to selection.
    * @param   aEvent
    *          The mouse event.
    */
-  onPlacesListClick: function PO_onPlacesListClick(aEvent) {
+  onPlacesListClick: function(aEvent) {
     // Only handle clicks on tree children.
     if (aEvent.target.localName != "treechildren")
       return;
 
     let node = this._places.selectedNode;
     if (node) {
       let middleClick = aEvent.button == 1 && aEvent.detail == 1;
       if (middleClick && PlacesUtils.nodeIsContainer(node)) {
@@ -313,65 +313,65 @@ var PlacesOrganizer = {
         PlacesUIUtils.openContainerNodeInTabs(selectedNode, aEvent, this._places);
       }
     }
   },
 
   /**
    * Handle focus changes on the places list and the current content view.
    */
-  updateDetailsPane: function PO_updateDetailsPane() {
+  updateDetailsPane: function() {
     if (!ContentArea.currentViewOptions.showDetailsPane)
       return;
     let view = PlacesUIUtils.getViewForNode(document.activeElement);
     if (view) {
       let selectedNodes = view.selectedNode ?
                           [view.selectedNode] : view.selectedNodes;
       this._fillDetailsPane(selectedNodes);
     }
   },
 
-  openFlatContainer: function PO_openFlatContainerFlatContainer(aContainer) {
+  openFlatContainer: function(aContainer) {
     if (aContainer.itemId != -1) {
       PlacesUtils.asContainer(this._places.selectedNode).containerOpen = true;
       this._places.selectItems([aContainer.itemId], false);
     }
     else if (PlacesUtils.nodeIsQuery(aContainer)) {
       this._places.selectPlaceURI(aContainer.uri);
     }
   },
 
   /**
    * Returns the options associated with the query currently loaded in the
    * main places pane.
    */
-  getCurrentOptions: function PO_getCurrentOptions() {
+  getCurrentOptions: function() {
     return PlacesUtils.asQuery(ContentArea.currentView.result.root).queryOptions;
   },
 
   /**
    * Returns the queries associated with the query currently loaded in the
    * main places pane.
    */
-  getCurrentQueries: function PO_getCurrentQueries() {
+  getCurrentQueries: function() {
     return PlacesUtils.asQuery(ContentArea.currentView.result.root).getQueries();
   },
 
   /**
    * Show the migration wizard for importing passwords,
    * cookies, history, preferences, and bookmarks.
    */
-  importFromBrowser: function PO_importFromBrowser() {
+  importFromBrowser: function() {
     MigrationUtils.showMigrationWizard(window);
   },
 
   /**
    * Open a file-picker and import the selected file into the bookmarks store
    */
-  importFromFile: function PO_importFromFile() {
+  importFromFile: function() {
     let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
     let fpCallback = function fpCallback_done(aResult) {
       if (aResult != Ci.nsIFilePicker.returnCancel && fp.fileURL) {
         Components.utils.import("resource://gre/modules/BookmarkHTMLUtils.jsm");
         BookmarkHTMLUtils.importFromURL(fp.fileURL.spec, false)
                          .then(null, Components.utils.reportError);
       }
     };
@@ -380,17 +380,17 @@ var PlacesOrganizer = {
             Ci.nsIFilePicker.modeOpen);
     fp.appendFilters(Ci.nsIFilePicker.filterHTML);
     fp.open(fpCallback);
   },
 
   /**
    * Allows simple exporting of bookmarks.
    */
-  exportBookmarks: function PO_exportBookmarks() {
+  exportBookmarks: function() {
     let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
     let fpCallback = function fpCallback_done(aResult) {
       if (aResult != Ci.nsIFilePicker.returnCancel) {
         Components.utils.import("resource://gre/modules/BookmarkHTMLUtils.jsm");
         BookmarkHTMLUtils.exportToFile(fp.file.path)
                          .then(null, Components.utils.reportError);
       }
     };
@@ -400,17 +400,17 @@ var PlacesOrganizer = {
     fp.appendFilters(Ci.nsIFilePicker.filterHTML);
     fp.defaultString = "bookmarks.html";
     fp.open(fpCallback);
   },
 
   /**
    * Populates the restore menu with the dates of the backups available.
    */
-  populateRestoreMenu: function PO_populateRestoreMenu() {
+  populateRestoreMenu: function() {
     let restorePopup = document.getElementById("fileRestorePopup");
 
     let dateSvc = Cc["@mozilla.org/intl/scriptabledateformat;1"].
                   getService(Ci.nsIScriptableDateFormat);
 
     // Remove existing menu items.  Last item is the restoreFromFile item.
     while (restorePopup.childNodes.length > 1)
       restorePopup.removeChild(restorePopup.firstChild);
@@ -457,34 +457,34 @@ var PlacesOrganizer = {
       restorePopup.insertBefore(document.createElement("menuseparator"),
                                 document.getElementById("restoreFromFile"));
     });
   },
 
   /**
    * Called when a menuitem is selected from the restore menu.
    */
-  onRestoreMenuItemClick: function PO_onRestoreMenuItemClick(aMenuItem) {
+  onRestoreMenuItemClick: function(aMenuItem) {
     Task.spawn(function() {
       let backupName = aMenuItem.getAttribute("value");
       let backupFilePaths = yield PlacesBackups.getBackupFiles();
       for (let backupFilePath of backupFilePaths) {
         if (OS.Path.basename(backupFilePath) == backupName) {
           PlacesOrganizer.restoreBookmarksFromFile(backupFilePath);
           break;
         }
       }
     });
   },
 
   /**
    * Called when 'Choose File...' is selected from the restore menu.
    * Prompts for a file and restores bookmarks to those in the file.
    */
-  onRestoreBookmarksFromFile: function PO_onRestoreBookmarksFromFile() {
+  onRestoreBookmarksFromFile: function() {
     let dirSvc = Cc["@mozilla.org/file/directory_service;1"].
                  getService(Ci.nsIProperties);
     let backupsDir = dirSvc.get("Desk", Ci.nsILocalFile);
     let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
     let fpCallback = function fpCallback_done(aResult) {
       if (aResult != Ci.nsIFilePicker.returnCancel) {
         this.restoreBookmarksFromFile(fp.file.path);
       }
@@ -497,17 +497,17 @@ var PlacesOrganizer = {
     fp.appendFilters(Ci.nsIFilePicker.filterAll);
     fp.displayDirectory = backupsDir;
     fp.open(fpCallback);
   },
 
   /**
    * Restores bookmarks from a JSON file.
    */
-  restoreBookmarksFromFile: function PO_restoreBookmarksFromFile(aFilePath) {
+  restoreBookmarksFromFile: function(aFilePath) {
     // check file extension
     if (!aFilePath.endsWith("json") && !aFilePath.endsWith("jsonlz4"))  {
       this._showErrorAlert(PlacesUIUtils.getString("bookmarksRestoreFormatError"));
       return;
     }
 
     // confirm ok to delete existing bookmarks
     var prompts = Cc["@mozilla.org/embedcomp/prompt-service;1"].
@@ -521,31 +521,31 @@ var PlacesOrganizer = {
       try {
         yield BookmarkJSONUtils.importFromFile(aFilePath, true);
       } catch(ex) {
         PlacesOrganizer._showErrorAlert(PlacesUIUtils.getString("bookmarksRestoreParseError"));
       }
     });
   },
 
-  _showErrorAlert: function PO__showErrorAlert(aMsg) {
+  _showErrorAlert: function(aMsg) {
     var brandShortName = document.getElementById("brandStrings").
                                   getString("brandShortName");
 
     Cc["@mozilla.org/embedcomp/prompt-service;1"].
       getService(Ci.nsIPromptService).
       alert(window, brandShortName, aMsg);
   },
 
   /**
    * Backup bookmarks to desktop, auto-generate a filename with a date.
    * The file is a JSON serialization of bookmarks, tags and any annotations
    * of those items.
    */
-  backupBookmarks: function PO_backupBookmarks() {
+  backupBookmarks: function() {
     let dirSvc = Cc["@mozilla.org/file/directory_service;1"].
                  getService(Ci.nsIProperties);
     let backupsDir = dirSvc.get("Desk", Ci.nsILocalFile);
     let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
     let fpCallback = function fpCallback_done(aResult) {
       if (aResult != Ci.nsIFilePicker.returnCancel) {
         // There is no OS.File version of the filepicker yet (Bug 937812).
         PlacesBackups.saveBookmarksToJSONFile(fp.file.path);
@@ -594,26 +594,26 @@ var PlacesOrganizer = {
       infoBoxExpanderWrapper.hidden =
         this._additionalInfoFields.every(function (id)
           document.getElementById(id).collapsed);
     }
     additionalInfoBroadcaster.hidden = infoBox.getAttribute("minimal") == "true";
   },
 
   // NOT YET USED
-  updateThumbnailProportions: function PO_updateThumbnailProportions() {
+  updateThumbnailProportions: function() {
     var previewBox = document.getElementById("previewBox");
     var canvas = document.getElementById("itemThumbnail");
     var height = previewBox.boxObject.height;
     var width = height * (screen.width / screen.height);
     canvas.width = width;
     canvas.height = height;
   },
 
-  _fillDetailsPane: function PO__fillDetailsPane(aNodeList) {
+  _fillDetailsPane: function(aNodeList) {
     var infoBox = document.getElementById("infoBox");
     var detailsDeck = document.getElementById("detailsDeck");
 
     // Make sure the infoBox UI is visible if we need to use it, we hide it
     // below when we don't.
     infoBox.hidden = false;
     var aSelectedNode = aNodeList.length == 1 ? aNodeList[0] : null;
     // If a textbox within a panel is focused, force-blur it so its contents
@@ -727,17 +727,17 @@ var PlacesOrganizer = {
         itemsCountLabel.value =
           PlacesUIUtils.getPluralString("detailsPane.itemsCountLabel",
                                         itemsCount, [itemsCount]);
       }
     }
   },
 
   // NOT YET USED
-  _updateThumbnail: function PO__updateThumbnail() {
+  _updateThumbnail: function() {
     var bo = document.getElementById("previewBox").boxObject;
     var width  = bo.width;
     var height = bo.height;
 
     var canvas = document.getElementById("itemThumbnail");
     var ctx = canvas.getContext('2d');
     var notAvailableText = canvas.getAttribute("notavailabletext");
     ctx.save();
@@ -748,17 +748,17 @@ var PlacesOrganizer = {
     ctx.fillStyle = "GrayText";
     ctx.mozTextStyle = "12pt sans serif";
     var len = ctx.mozMeasureText(notAvailableText);
     ctx.translate(-len/2,0);
     ctx.mozDrawText(notAvailableText);
     ctx.restore();
   },
 
-  toggleAdditionalInfoFields: function PO_toggleAdditionalInfoFields() {
+  toggleAdditionalInfoFields: function() {
     var infoBox = document.getElementById("infoBox");
     var infoBoxExpander = document.getElementById("infoBoxExpander");
     var infoBoxExpanderLabel = document.getElementById("infoBoxExpanderLabel");
     var additionalInfoBroadcaster = document.getElementById("additionalInfoBroadcaster");
 
     if (infoBox.getAttribute("minimal") == "true") {
       infoBox.removeAttribute("minimal");
       infoBoxExpanderLabel.value = infoBoxExpanderLabel.getAttribute("lesslabel");
@@ -807,17 +807,17 @@ var PlacesSearchBox = {
 
   /**
    * Run a search for the specified text, over the collection specified by
    * the dropdown arrow. The default is all bookmarks, but can be
    * localized to the active collection.
    * @param   filterString
    *          The text to search for.
    */
-  search: function PSB_search(filterString) {
+  search: function(filterString) {
     var PO = PlacesOrganizer;
     // If the user empties the search box manually, reset it and load all
     // contents of the current scope.
     // XXX this might be to jumpy, maybe should search for "", so results
     // are ungrouped, and search box not reset
     if (filterString == "") {
       PO.onPlaceSelected(false);
       return;
@@ -872,17 +872,17 @@ var PlacesSearchBox = {
 
     // Update the details panel
     PlacesOrganizer.updateDetailsPane();
   },
 
   /**
    * Finds across all history, downloads or all bookmarks.
    */
-  findAll: function PSB_findAll() {
+  findAll: function() {
     switch (this.filterCollection) {
       case "history":
         PlacesQueryBuilder.setScope("history");
         break;
       case "downloads":
         PlacesQueryBuilder.setScope("downloads");
         break;
       default:
@@ -892,17 +892,17 @@ var PlacesSearchBox = {
     this.focus();
   },
 
   /**
    * Updates the display with the title of the current collection.
    * @param   aTitle
    *          The title of the current collection.
    */
-  updateCollectionTitle: function PSB_updateCollectionTitle(aTitle) {
+  updateCollectionTitle: function(aTitle) {
     let title = "";
     switch (this.filterCollection) {
       case "history":
         title = PlacesUIUtils.getString("searchHistory");
         break;
       case "downloads":
         title = PlacesUIUtils.getString("searchDownloads");
         break;
@@ -926,24 +926,24 @@ var PlacesSearchBox = {
     this.updateCollectionTitle();
 
     return collectionName;
   },
 
   /**
    * Focus the search box
    */
-  focus: function PSB_focus() {
+  focus: function() {
     this.searchFilter.focus();
   },
 
   /**
    * Set up the gray text in the search bar as the Places View loads.
    */
-  init: function PSB_init() {
+  init: function() {
     this.updateCollectionTitle();
   },
 
   /**
    * Gets or sets the text shown in the Places Search Box
    */
   get value() {
     return this.searchFilter.value;
@@ -965,17 +965,17 @@ var PlacesQueryBuilder = {
    * Sets the search scope.  This can be called when no search is active, and
    * in that case, when the user does begin a search aScope will be used (see
    * PSB_search()).  If there is an active search, it's performed again to
    * update the content tree.
    * @param   aScope
    *          The search scope: "bookmarks", "collection", "downloads" or
    *          "history".
    */
-  setScope: function PQB_setScope(aScope) {
+  setScope: function(aScope) {
     // Determine filterCollection, folders, and scopeButtonId based on aScope.
     var filterCollection;
     var folders = [];
     switch (aScope) {
       case "history":
         filterCollection = "history";
         break;
       case "bookmarks":
@@ -1020,17 +1020,17 @@ var ViewMenu = {
    *          dynamically generated region - remove elements up to this
    *          item only.
    *          Must be contained by popup. Can be null (in which case all
    *          items until the end of the popup will be removed). Ignored
    *          if startID is null.
    * @returns The element for the caller to insert new items before,
    *          null if the caller should just append to the popup.
    */
-  _clean: function VM__clean(popup, startID, endID) {
+  _clean: function(popup, startID, endID) {
     if (endID)
       NS_ASSERT(startID, "meaningless to have valid endID and null startID");
     if (startID) {
       var startElement = document.getElementById(startID);
       NS_ASSERT(startElement.parentNode ==
                 popup, "startElement is not in popup");
       NS_ASSERT(startElement,
                 "startID does not correspond to an existing element");
@@ -1069,17 +1069,17 @@ var ViewMenu = {
    *          If propertyPrefix is non-null:
    *          propertyPrefix + column ID + ".label" will be used to get the
    *          localized label string.
    *          propertyPrefix + column ID + ".accesskey" will be used to get the
    *          localized accesskey.
    *          If propertyPrefix is null, the column label is used as label and
    *          no accesskey is assigned.
    */
-  fillWithColumns: function VM_fillWithColumns(event, startID, endID, type, propertyPrefix) {
+  fillWithColumns: function(event, startID, endID, type, propertyPrefix) {
     var popup = event.target;
     var pivot = this._clean(popup, startID, endID);
 
     // If no column is "sort-active", the "Unsorted" item needs to be checked,
     // so track whether or not we find a column that is sort-active.
     var isSorted = false;
     var content = document.getElementById("placeContent");
     var columns = content.columns;
@@ -1124,17 +1124,17 @@ var ViewMenu = {
         popup.appendChild(menuitem);
     }
     event.stopPropagation();
   },
 
   /**
    * Set up the content of the view menu.
    */
-  populateSortMenu: function VM_populateSortMenu(event) {
+  populateSortMenu: function(event) {
     this.fillWithColumns(event, "viewUnsorted", "directionSeparator", "radio", "view.sortBy.1.");
 
     var sortColumn = this._getSortColumn();
     var viewSortAscending = document.getElementById("viewSortAscending");
     var viewSortDescending = document.getElementById("viewSortDescending");
     // We need to remove an existing checked attribute because the unsorted
     // menu item is not rebuilt every time we open the menu like the others.
     var viewUnsorted = document.getElementById("viewUnsorted");
@@ -1155,17 +1155,17 @@ var ViewMenu = {
     }
   },
 
   /**
    * Shows/Hides a tree column.
    * @param   element
    *          The menuitem element for the column
    */
-  showHideColumn: function VM_showHideColumn(element) {
+  showHideColumn: function(element) {
     var column = element.column;
 
     var splitter = column.nextSibling;
     if (splitter && splitter.localName != "splitter")
       splitter = null;
 
     if (element.getAttribute("checked") == "true") {
       column.setAttribute("hidden", "false");
@@ -1178,17 +1178,17 @@ var ViewMenu = {
         splitter.setAttribute("hidden", "true");
     }
   },
 
   /**
    * Gets the last column that was sorted.
    * @returns  the currently sorted column, null if there is no sorted column.
    */
-  _getSortColumn: function VM__getSortColumn() {
+  _getSortColumn: function() {
     var content = document.getElementById("placeContent");
     var cols = content.columns;
     for (var i = 0; i < cols.count; ++i) {
       var column = cols.getColumnAt(i).element;
       var sortDirection = column.getAttribute("sortDirection");
       if (sortDirection == "ascending" || sortDirection == "descending")
         return column;
     }
@@ -1201,17 +1201,17 @@ var ViewMenu = {
    *          The colum that is the sort key. Can be null - the
    *          current sort column or the title column will be used.
    * @param   aDirection
    *          The direction to sort - "ascending" or "descending".
    *          Can be null - the last direction or descending will be used.
    *
    * If both aColumnID and aDirection are null, the view will be unsorted.
    */
-  setSortColumn: function VM_setSortColumn(aColumn, aDirection) {
+  setSortColumn: function(aColumn, aDirection) {
     var result = document.getElementById("placeContent").result;
     if (!aColumn && !aDirection) {
       result.sortingMode = Ci.nsINavHistoryQueryOptions.SORT_BY_NONE;
       return;
     }
 
     var columnId;
     if (aColumn) {
@@ -1261,17 +1261,17 @@ var ViewMenu = {
     result.sortingAnnotation = colLookupTable[columnId].anno || "";
     result.sortingMode = Ci.nsINavHistoryQueryOptions[sortConst];
   }
 }
 
 let ContentArea = {
   _specialViews: new Map(),
 
-  init: function CA_init() {
+  init: function() {
     this._deck = document.getElementById("placesViewsDeck");
     this._toolbar = document.getElementById("placesToolbar");
     ContentTree.init();
     this._setupView();
   },
 
   /**
    * Gets the content view to be used for loading the given query.
@@ -1348,17 +1348,17 @@ let ContentArea = {
       newView.active = true;
     }
     return aQueryString;
   },
 
   /**
    * Applies view options.
    */
-  _setupView: function CA__setupView() {
+  _setupView: function() {
     let options = this.currentViewOptions;
 
     // showDetailsPane.
     let detailsDeck = document.getElementById("detailsDeck");
     detailsDeck.hidden = !options.showDetailsPane;
 
     // toolbarSet.
     for (let elt of this._toolbar.childNodes) {
@@ -1392,33 +1392,33 @@ let ContentArea = {
   },
 
   focus: function() {
     this._deck.selectedPanel.focus();
   }
 };
 
 let ContentTree = {
-  init: function CT_init() {
+  init: function() {
     this._view = document.getElementById("placeContent");
   },
 
   get view() this._view,
 
   get viewOptions() Object.seal({
     showDetailsPane: true,
     toolbarSet: "back-button, forward-button, organizeButton, viewMenu, maintenanceButton, libraryToolbarSpacer, searchFilter"
   }),
 
-  openSelectedNode: function CT_openSelectedNode(aEvent) {
+  openSelectedNode: function(aEvent) {
     let view = this.view;
     PlacesUIUtils.openNodeWithEvent(view.selectedNode, aEvent, view);
   },
 
-  onClick: function CT_onClick(aEvent) {
+  onClick: function(aEvent) {
     let node = this.view.selectedNode;
     if (node) {
       let doubleClick = aEvent.button == 0 && aEvent.detail == 2;
       let middleClick = aEvent.button == 1 && aEvent.detail == 1;
       if (PlacesUtils.nodeIsURI(node) && (doubleClick || middleClick)) {
         // Open associated uri in the browser.
         this.openSelectedNode(aEvent);
       }
@@ -1426,13 +1426,13 @@ let ContentTree = {
         // The command execution function will take care of seeing if the
         // selection is a folder or a different container type, and will
         // load its contents in tabs.
         PlacesUIUtils.openContainerNodeInTabs(node, aEvent, this.view);
       }
     }
   },
 
-  onKeyPress: function CT_onKeyPress(aEvent) {
+  onKeyPress: function(aEvent) {
     if (aEvent.keyCode == KeyEvent.DOM_VK_RETURN)
       this.openSelectedNode(aEvent);
   }
 };
diff --git a/browser/components/places/content/sidebarUtils.js b/browser/components/places/content/sidebarUtils.js
--- a/browser/components/places/content/sidebarUtils.js
+++ b/browser/components/places/content/sidebarUtils.js
@@ -1,15 +1,15 @@
 # -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 var SidebarUtils = {
-  handleTreeClick: function SU_handleTreeClick(aTree, aEvent, aGutterSelect) {
+  handleTreeClick: function(aTree, aEvent, aGutterSelect) {
     // right-clicks are not handled here
     if (aEvent.button == 2)
       return;
 
     var tbo = aTree.treeBoxObject;
     var cell = tbo.getCellAt(aEvent.clientX, aEvent.clientY);
 
     if (cell.row == -1 || cell.childElt == "twisty")
@@ -56,31 +56,31 @@ var SidebarUtils = {
       // Clear all other selection since we're loading a link now. We must
       // do this *before* attempting to load the link since openURL uses
       // selection as an indication of which link to load.
       tbo.view.selection.select(cell.row);
       PlacesUIUtils.openNodeWithEvent(aTree.selectedNode, aEvent, aTree);
     }
   },
 
-  handleTreeKeyPress: function SU_handleTreeKeyPress(aEvent) {
+  handleTreeKeyPress: function(aEvent) {
     // XXX Bug 627901: Post Fx4, this method should take a tree parameter.
     let tree = aEvent.target;
     let node = tree.selectedNode;
     if (node) {
       if (aEvent.keyCode == KeyEvent.DOM_VK_RETURN)
         PlacesUIUtils.openNodeWithEvent(node, aEvent, tree);
     }
   },
 
   /**
    * The following function displays the URL of a node that is being
    * hovered over.
    */
-  handleTreeMouseMove: function SU_handleTreeMouseMove(aEvent) {
+  handleTreeMouseMove: function(aEvent) {
     if (aEvent.target.localName != "treechildren")
       return;
 
     var tree = aEvent.target.parentNode;
     var tbo = tree.treeBoxObject;
     var cell = tbo.getCellAt(aEvent.clientX, aEvent.clientY);
 
     // cell.row is -1 when the mouse is hovering an empty area within the tree.
@@ -92,17 +92,17 @@ var SidebarUtils = {
         this.setMouseoverURL(node.uri);
       else
         this.setMouseoverURL("");
     }
     else
       this.setMouseoverURL("");
   },
 
-  setMouseoverURL: function SU_setMouseoverURL(aURL) {
+  setMouseoverURL: function(aURL) {
     // When the browser window is closed with an open sidebar, the sidebar
     // unload event happens after the browser's one.  In this case
     // top.XULBrowserWindow has been nullified already.
     if (top.XULBrowserWindow) {
       top.XULBrowserWindow.setOverLink(aURL, null);
     }
   }
 };
diff --git a/browser/components/places/content/treeView.js b/browser/components/places/content/treeView.js
--- a/browser/components/places/content/treeView.js
+++ b/browser/components/places/content/treeView.js
@@ -50,17 +50,17 @@ PlacesTreeView.prototype = {
   // <tree>.view getter (which returns the wrappedJSObject of this object),
   // it raises an issue when the view retrieved through the treeBoxObject.view
   // getter.  Thus, to avoid breaking addons, the interfaces are prefetched.
   classInfo: XPCOMUtils.generateCI({ interfaces: PTV_interfaces }),
 
   /**
    * This is called once both the result and the tree are set.
    */
-  _finishInit: function PTV__finishInit() {
+  _finishInit: function() {
     let selection = this.selection;
     if (selection)
       selection.selectEventsSuppressed = true;
 
     if (!this._rootNode.containerOpen) {
       // This triggers containerStateChanged which then builds the visible
       // section.
       this._rootNode.containerOpen = true;
@@ -91,17 +91,17 @@ PlacesTreeView.prototype = {
    * filtered, see below) are listed in the visible elements array, because
    * bookmark folders are never built lazily, as described above.
    *
    * @param aContainer
    *        A container result node.
    *
    * @return true if aContainer is a plain container, false otherwise.
    */
-  _isPlainContainer: function PTV__isPlainContainer(aContainer) {
+  _isPlainContainer: function(aContainer) {
     // Livemarks are always plain containers.
     if (this._controller.hasCachedLivemarkInfo(aContainer))
       return true;
 
     // We don't know enough about non-query containers.
     if (!(aContainer instanceof Ci.nsINavHistoryQueryResultNode))
       return false;
 
@@ -203,32 +203,32 @@ PlacesTreeView.prototype = {
 
   /**
    * Given a row, finds and returns the parent details of the associated node.
    *
    * @param aChildRow
    *        Row number.
    * @return [parentNode, parentRow]
    */
-  _getParentByChildRow: function PTV__getParentByChildRow(aChildRow) {
+  _getParentByChildRow: function(aChildRow) {
     let node = this._getNodeForRow(aChildRow);
     let parent = (node === null) ? this._rootNode : node.parent;
 
     // The root node is never visible
     if (parent == this._rootNode)
       return [this._rootNode, -1];
 
     let parentRow = this._rows.lastIndexOf(parent, aChildRow - 1);
     return [parent, parentRow];
   },
 
   /**
    * Gets the node at a given row.
    */
-  _getNodeForRow: function PTV__getNodeForRow(aRow) {
+  _getNodeForRow: function(aRow) {
     if (aRow < 0) {
       return null;
     }
   
     let node = this._rows[aRow];
     if (node !== undefined)
       return node;
 
@@ -482,17 +482,17 @@ PlacesTreeView.prototype = {
           scrollToRow = aNodesInfo[0].oldRow;
       }
     }
 
     if (scrollToRow != -1)
       this._tree.ensureRowIsVisible(scrollToRow);
   },
 
-  _convertPRTimeToString: function PTV__convertPRTimeToString(aTime) {
+  _convertPRTimeToString: function(aTime) {
     const MS_PER_MINUTE = 60000;
     const MS_PER_DAY = 86400000;
     let timeMs = aTime / 1000; // PRTime is in microseconds
 
     // Date is calculated starting from midnight, so the modulo with a day are
     // milliseconds from today's midnight.
     // getTimezoneOffset corrects that based on local time, notice midnight
     // can have a different offset during DST-change days.
@@ -519,17 +519,17 @@ PlacesTreeView.prototype = {
   COLUMN_TYPE_DATE: 3,
   COLUMN_TYPE_VISITCOUNT: 4,
   COLUMN_TYPE_KEYWORD: 5,
   COLUMN_TYPE_DESCRIPTION: 6,
   COLUMN_TYPE_DATEADDED: 7,
   COLUMN_TYPE_LASTMODIFIED: 8,
   COLUMN_TYPE_TAGS: 9,
 
-  _getColumnType: function PTV__getColumnType(aColumn) {
+  _getColumnType: function(aColumn) {
     let columnType = aColumn.element.getAttribute("anonid") || aColumn.id;
 
     switch (columnType) {
       case "title":
         return this.COLUMN_TYPE_TITLE;
       case "url":
         return this.COLUMN_TYPE_URI;
       case "date":
@@ -545,17 +545,17 @@ PlacesTreeView.prototype = {
       case "lastModified":
         return this.COLUMN_TYPE_LASTMODIFIED;
       case "tags":
         return this.COLUMN_TYPE_TAGS;
     }
     return this.COLUMN_TYPE_UNKNOWN;
   },
 
-  _sortTypeToColumnType: function PTV__sortTypeToColumnType(aSortType) {
+  _sortTypeToColumnType: function(aSortType) {
     switch (aSortType) {
       case Ci.nsINavHistoryQueryOptions.SORT_BY_TITLE_ASCENDING:
         return [this.COLUMN_TYPE_TITLE, false];
       case Ci.nsINavHistoryQueryOptions.SORT_BY_TITLE_DESCENDING:
         return [this.COLUMN_TYPE_TITLE, true];
       case Ci.nsINavHistoryQueryOptions.SORT_BY_DATE_ASCENDING:
         return [this.COLUMN_TYPE_DATE, false];
       case Ci.nsINavHistoryQueryOptions.SORT_BY_DATE_DESCENDING:
@@ -591,17 +591,17 @@ PlacesTreeView.prototype = {
         return [this.COLUMN_TYPE_TAGS, false];
       case Ci.nsINavHistoryQueryOptions.SORT_BY_TAGS_DESCENDING:
         return [this.COLUMN_TYPE_TAGS, true];
     }
     return [this.COLUMN_TYPE_UNKNOWN, false];
   },
 
   // nsINavHistoryResultObserver
-  nodeInserted: function PTV_nodeInserted(aParentNode, aNode, aNewIndex) {
+  nodeInserted: function(aParentNode, aNode, aNewIndex) {
     NS_ASSERT(this._result, "Got a notification but have no result!");
     if (!this._tree || !this._result)
       return;
 
     // Bail out for hidden separators.
     if (PlacesUtils.nodeIsSeparator(aNode) && this.isSorted())
       return;
 
@@ -665,17 +665,17 @@ PlacesTreeView.prototype = {
    * THIS FUNCTION DOES NOT HANDLE cases where a collapsed node is being
    * removed but the node it is collapsed with is not being removed (this then
    * just swap out the removee with its collapsing partner). The only time
    * when we really remove things is when deleting URIs, which will apply to
    * all collapsees. This function is called sometimes when resorting items.
    * However, we won't do this when sorted by date because dates will never
    * change for visits, and date sorting is the only time things are collapsed.
    */
-  nodeRemoved: function PTV_nodeRemoved(aParentNode, aNode, aOldIndex) {
+  nodeRemoved: function(aParentNode, aNode, aOldIndex) {
     NS_ASSERT(this._result, "Got a notification but have no result!");
     if (!this._tree || !this._result)
       return;
 
     // XXX bug 517701: We don't know what to do when the root node is removed.
     if (aNode == this._rootNode)
       throw Cr.NS_ERROR_NOT_IMPLEMENTED;
 
@@ -791,41 +791,41 @@ PlacesTreeView.prototype = {
     if (aColumnType != this.COLUMN_TYPE_LASTMODIFIED) {
       let lastModifiedColumn =
         this._findColumnByType(this.COLUMN_TYPE_LASTMODIFIED);
       if (lastModifiedColumn && !lastModifiedColumn.hidden)
         this._tree.invalidateCell(row, lastModifiedColumn);
     }
   },
 
-  _populateLivemarkContainer: function PTV__populateLivemarkContainer(aNode) {
+  _populateLivemarkContainer: function(aNode) {
     PlacesUtils.livemarks.getLivemark({ id: aNode.itemId })
       .then(aLivemark => {
         let placesNode = aNode;
         // Need to check containerOpen since getLivemark is async.
         if (!placesNode.containerOpen)
           return;
 
         let children = aLivemark.getNodesForContainer(placesNode);
         for (let i = 0; i < children.length; i++) {
           let child = children[i];
           this.nodeInserted(placesNode, child, i);
         }
       }, Components.utils.reportError);
   },
 
-  nodeTitleChanged: function PTV_nodeTitleChanged(aNode, aNewTitle) {
+  nodeTitleChanged: function(aNode, aNewTitle) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_TITLE);
   },
 
-  nodeURIChanged: function PTV_nodeURIChanged(aNode, aNewURI) {
+  nodeURIChanged: function(aNode, aNewURI) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_URI);
   },
 
-  nodeIconChanged: function PTV_nodeIconChanged(aNode) {
+  nodeIconChanged: function(aNode) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_TITLE);
   },
 
   nodeHistoryDetailsChanged:
   function PTV_nodeHistoryDetailsChanged(aNode, aUpdatedVisitDate,
                                          aUpdatedVisitCount) {
     if (aNode.parent && this._controller.hasCachedLivemarkInfo(aNode.parent)) {
       // Find the node in the parent.
@@ -840,42 +840,42 @@ PlacesTreeView.prototype = {
       }
       return;
     }
 
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_DATE);
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_VISITCOUNT);
   },
 
-  nodeTagsChanged: function PTV_nodeTagsChanged(aNode) {
+  nodeTagsChanged: function(aNode) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_TAGS);
   },
 
-  nodeKeywordChanged: function PTV_nodeKeywordChanged(aNode, aNewKeyword) {
+  nodeKeywordChanged: function(aNode, aNewKeyword) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_KEYWORD);
   },
 
-  nodeAnnotationChanged: function PTV_nodeAnnotationChanged(aNode, aAnno) {
+  nodeAnnotationChanged: function(aNode, aAnno) {
     if (aAnno == PlacesUIUtils.DESCRIPTION_ANNO) {
       this._invalidateCellValue(aNode, this.COLUMN_TYPE_DESCRIPTION);
     }
     else if (aAnno == PlacesUtils.LMANNO_FEEDURI) {
       PlacesUtils.livemarks.getLivemark({ id: aNode.itemId })
         .then(aLivemark => {
           this._controller.cacheLivemarkInfo(aNode, aLivemark);
           let properties = this._cellProperties.get(aNode);
           this._cellProperties.set(aNode, properties += " livemark ");
 
           // The livemark attribute is set as a cell property on the title cell.
           this._invalidateCellValue(aNode, this.COLUMN_TYPE_TITLE);
         }, Components.utils.reportError);
     }
   },
 
-  nodeDateAddedChanged: function PTV_nodeDateAddedChanged(aNode, aNewValue) {
+  nodeDateAddedChanged: function(aNode, aNewValue) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_DATEADDED);
   },
 
   nodeLastModifiedChanged:
   function PTV_nodeLastModifiedChanged(aNode, aNewValue) {
     this._invalidateCellValue(aNode, this.COLUMN_TYPE_LASTMODIFIED);
   },
 
@@ -905,17 +905,17 @@ PlacesTreeView.prototype = {
           }
           else {
             aLivemark.unregisterForUpdates(aNode);
           }
         }, () => undefined);
     }
   },
 
-  invalidateContainer: function PTV_invalidateContainer(aContainer) {
+  invalidateContainer: function(aContainer) {
     NS_ASSERT(this._result, "Need to have a result to update");
     if (!this._tree)
       return;
 
     let startReplacement, replaceCount;
     if (aContainer == this._rootNode) {
       startReplacement = 0;
       replaceCount = this._rows.length;
@@ -1011,17 +1011,17 @@ PlacesTreeView.prototype = {
     this._tree.endUpdateBatch();
 
     // Restore selection.
     this._restoreSelection(nodesToReselect, aContainer);
     this.selection.selectEventsSuppressed = false;
   },
 
   _columns: [],
-  _findColumnByType: function PTV__findColumnByType(aColumnType) {
+  _findColumnByType: function(aColumnType) {
     if (this._columns[aColumnType])
       return this._columns[aColumnType];
 
     let columns = this._tree.columns;
     let colCount = columns.count;
     for (let i = 0; i < colCount; i++) {
       let column = columns.getColumnAt(i);
       let columnType = this._getColumnType(column);
@@ -1030,17 +1030,17 @@ PlacesTreeView.prototype = {
         return column;
     }
 
     // That's completely valid.  Most of our trees actually include just the
     // title column.
     return null;
   },
 
-  sortingChanged: function PTV__sortingChanged(aSortingMode) {
+  sortingChanged: function(aSortingMode) {
     if (!this._tree || !this._result)
       return;
 
     // Depending on the sort mode, certain commands may be disabled.
     window.updateCommands("sort");
 
     let columns = this._tree.columns;
 
@@ -1059,17 +1059,17 @@ PlacesTreeView.prototype = {
     let column = this._findColumnByType(desiredColumn);
     if (column) {
       let sortDir = desiredIsDescending ? "descending" : "ascending";
       column.element.setAttribute("sortDirection", sortDir);
     }
   },
 
   _inBatchMode: false,
-  batching: function PTV__batching(aToggleMode) {
+  batching: function(aToggleMode) {
     if (this._inBatchMode != aToggleMode) {
       this._inBatchMode = this.selection.selectEventsSuppressed = aToggleMode;
       if (this._inBatchMode) {
         this._tree.beginUpdateBatch();
       }
       else {
         this._tree.endUpdateBatch();
       }
@@ -1098,24 +1098,24 @@ PlacesTreeView.prototype = {
 
     // If the tree is not set yet, setTree will call finishInit.
     if (this._tree && val)
       this._finishInit();
 
     return val;
   },
 
-  nodeForTreeIndex: function PTV_nodeForTreeIndex(aIndex) {
+  nodeForTreeIndex: function(aIndex) {
     if (aIndex > this._rows.length)
       throw Cr.NS_ERROR_INVALID_ARG;
 
     return this._getNodeForRow(aIndex);
   },
 
-  treeIndexForNode: function PTV_treeNodeForIndex(aNode) {
+  treeIndexForNode: function(aNode) {
     // The API allows passing invisible nodes.
     try {
       return this._getRowForNode(aNode, true);
     }
     catch(ex) { }
 
     return Ci.nsINavHistoryResultTreeViewer.INDEX_INVISIBLE;
   },
@@ -1203,17 +1203,17 @@ PlacesTreeView.prototype = {
       this._cellProperties.set(node, properties);
     }
 
     return props + " " + properties;
   },
 
   getColumnProperties: function(aColumn) { return ""; },
 
-  isContainer: function PTV_isContainer(aRow) {
+  isContainer: function(aRow) {
     // Only leaf nodes aren't listed in the rows array.
     let node = this._rows[aRow];
     if (node === undefined)
       return false;
 
     if (PlacesUtils.nodeIsContainer(node)) {
       // Flat-lists may ignore expandQueries and other query options when
       // they are asked to open a container.
@@ -1228,62 +1228,62 @@ PlacesTreeView.prototype = {
             !PlacesUtils.asQuery(node).hasChildren)
           return PlacesUtils.asQuery(parent).queryOptions.expandQueries;
       }
       return true;
     }
     return false;
   },
 
-  isContainerOpen: function PTV_isContainerOpen(aRow) {
+  isContainerOpen: function(aRow) {
     if (this._flatList)
       return false;
 
     // All containers are listed in the rows array.
     return this._rows[aRow].containerOpen;
   },
 
-  isContainerEmpty: function PTV_isContainerEmpty(aRow) {
+  isContainerEmpty: function(aRow) {
     if (this._flatList)
       return true;
 
     let node = this._rows[aRow];
     if (this._controller.hasCachedLivemarkInfo(node)) {
       let queryOptions = PlacesUtils.asQuery(this._result.root).queryOptions;
       return queryOptions.excludeItems;
     }
 
     // All containers are listed in the rows array.
     return !node.hasChildren;
   },
 
-  isSeparator: function PTV_isSeparator(aRow) {
+  isSeparator: function(aRow) {
     // All separators are listed in the rows array.
     let node = this._rows[aRow];
     return node && PlacesUtils.nodeIsSeparator(node);
   },
 
-  isSorted: function PTV_isSorted() {
+  isSorted: function() {
     return this._result.sortingMode !=
            Ci.nsINavHistoryQueryOptions.SORT_BY_NONE;
   },
 
-  canDrop: function PTV_canDrop(aRow, aOrientation, aDataTransfer) {
+  canDrop: function(aRow, aOrientation, aDataTransfer) {
     if (!this._result)
       throw Cr.NS_ERROR_UNEXPECTED;
 
     // Drop position into a sorted treeview would be wrong.
     if (this.isSorted())
       return false;
 
     let ip = this._getInsertionPoint(aRow, aOrientation);
     return ip && PlacesControllerDragHelper.canDrop(ip, aDataTransfer);
   },
 
-  _getInsertionPoint: function PTV__getInsertionPoint(index, orientation) {
+  _getInsertionPoint: function(index, orientation) {
     let container = this._result.root;
     let dropNearItemId = -1;
     // When there's no selection, assume the container is the container
     // the view is populated from (i.e. the result's itemId).
     if (index != -1) {
       let lastSelected = this.nodeForTreeIndex(index);
       if (this.isContainer(index) && orientation == Ci.nsITreeView.DROP_ON) {
         // If the last selected item is an open container, append _into_
@@ -1345,35 +1345,35 @@ PlacesTreeView.prototype = {
 
     let tagName = PlacesUtils.nodeIsTagQuery(container) ? container.title : null;
     return new InsertionPoint(PlacesUtils.getConcreteItemId(container),
                               index, orientation,
                               tagName,
                               dropNearItemId);
   },
 
-  drop: function PTV_drop(aRow, aOrientation, aDataTransfer) {
+  drop: function(aRow, aOrientation, aDataTransfer) {
     // We are responsible for translating the |index| and |orientation|
     // parameters into a container id and index within the container,
     // since this information is specific to the tree view.
     let ip = this._getInsertionPoint(aRow, aOrientation);
     if (ip) {
       PlacesControllerDragHelper.onDrop(ip, aDataTransfer)
                                 .then(null, Components.utils.reportError);
     }
 
     PlacesControllerDragHelper.currentDropTarget = null;
   },
 
-  getParentIndex: function PTV_getParentIndex(aRow) {
+  getParentIndex: function(aRow) {
     let [parentNode, parentRow] = this._getParentByChildRow(aRow);
     return parentRow;
   },
 
-  hasNextSibling: function PTV_hasNextSibling(aRow, aAfterIndex) {
+  hasNextSibling: function(aRow, aAfterIndex) {
     if (aRow == this._rows.length - 1) {
       // The last row has no sibling.
       return false;
     }
 
     let node = this._rows[aRow];
     if (node === undefined || this._isPlainContainer(node.parent)) {
       // The node is a child of a plain container.
@@ -1393,32 +1393,32 @@ PlacesTreeView.prototype = {
         break;
     }
 
     return false;
   },
 
   getLevel: function(aRow) this._getNodeForRow(aRow).indentLevel,
 
-  getImageSrc: function PTV_getImageSrc(aRow, aColumn) {
+  getImageSrc: function(aRow, aColumn) {
     // Only the title column has an image.
     if (this._getColumnType(aColumn) != this.COLUMN_TYPE_TITLE)
       return "";
 
     let node = this._getNodeForRow(aRow);
     if (PlacesUtils.nodeIsURI(node) && node.icon)
       return PlacesUtils.getImageURLForResolution(window, node.icon);
 
     return node.icon;
   },
 
   getProgressMode: function(aRow, aColumn) { },
   getCellValue: function(aRow, aColumn) { },
 
-  getCellText: function PTV_getCellText(aRow, aColumn) {
+  getCellText: function(aRow, aColumn) {
     let node = this._getNodeForRow(aRow);
     switch (this._getColumnType(aColumn)) {
       case this.COLUMN_TYPE_TITLE:
         // normally, this is just the title, but we don't want empty items in
         // the tree view so return a special string if the title is empty.
         // Do it here so that callers can still get at the 0 length title
         // if they go through the "result" API.
         if (PlacesUtils.nodeIsSeparator(node))
@@ -1464,17 +1464,17 @@ PlacesTreeView.prototype = {
       case this.COLUMN_TYPE_LASTMODIFIED:
         if (node.lastModified)
           return this._convertPRTimeToString(node.lastModified);
         return "";
     }
     return "";
   },
 
-  setTree: function PTV_setTree(aTree) {
+  setTree: function(aTree) {
     // If we are replacing the tree during a batch, there is a concrete risk
     // that the treeView goes out of sync, thus it's safer to end the batch now.
     // This is a no-op if we are not batching.
     this.batching(false);
 
     let hasOldTree = this._tree != null;
     this._tree = aTree;
 
@@ -1487,17 +1487,17 @@ PlacesTreeView.prototype = {
           this._rootNode.containerOpen = false;
         }
       }
       if (aTree)
         this._finishInit();
     }
   },
 
-  toggleOpenState: function PTV_toggleOpenState(aRow) {
+  toggleOpenState: function(aRow) {
     if (!this._result)
       throw Cr.NS_ERROR_UNEXPECTED;
 
     let node = this._rows[aRow];
     if (this._flatList && this._openContainerCallback) {
       this._openContainerCallback(node);
       return;
     }
@@ -1515,17 +1515,17 @@ PlacesTreeView.prototype = {
           this._xulStore.setValue(docURI, uri, "open", "true");
         }
       }
     }
 
     node.containerOpen = !node.containerOpen;
   },
 
-  cycleHeader: function PTV_cycleHeader(aColumn) {
+  cycleHeader: function(aColumn) {
     if (!this._result)
       throw Cr.NS_ERROR_UNEXPECTED;
 
     // Sometimes you want a tri-state sorting, and sometimes you don't. This
     // rule allows tri-state sorting when the root node is a folder. This will
     // catch the most common cases. When you are looking at folders, you want
     // the third state to reset the sorting to the natural bookmark order. When
     // you are looking at history, that third state has no meaning so we try
@@ -1639,17 +1639,17 @@ PlacesTreeView.prototype = {
         break;
       default:
         throw Cr.NS_ERROR_INVALID_ARG;
     }
     this._result.sortingAnnotation = newSortingAnnotation;
     this._result.sortingMode = newSort;
   },
 
-  isEditable: function PTV_isEditable(aRow, aColumn) {
+  isEditable: function(aRow, aColumn) {
     // At this point we only support editing the title field.
     if (aColumn.index != 0)
       return false;
 
     let node = this._rows[aRow];
     if (!node) {
       Cu.reportError("isEditable called for an unbuilt row.");
       return false;
@@ -1682,26 +1682,26 @@ PlacesTreeView.prototype = {
       // That's because places root are only exposed through folder shortcuts
       // descendants of the left pane folder.
       return false;
     }
 
     return true;
   },
 
-  setCellText: function PTV_setCellText(aRow, aColumn, aText) {
+  setCellText: function(aRow, aColumn, aText) {
     // We may only get here if the cell is editable.
     let node = this._rows[aRow];
     if (node.title != aText) {
       let txn = new PlacesEditItemTitleTransaction(node.itemId, aText);
       PlacesUtils.transactionManager.doTransaction(txn);
     }
   },
 
-  toggleCutNode: function PTV_toggleCutNode(aNode, aValue) {
+  toggleCutNode: function(aNode, aValue) {
     let currentVal = this._cuttingNodes.has(aNode);
     if (currentVal != aValue) {
       if (aValue)
         this._cuttingNodes.add(aNode);
       else
         this._cuttingNodes.delete(aNode);
 
       this._invalidateCellValue(aNode, this.COLUMN_TYPE_TITLE);
diff --git a/browser/components/places/tests/browser/browser_library_views_liveupdate.js b/browser/components/places/tests/browser/browser_library_views_liveupdate.js
--- a/browser/components/places/tests/browser/browser_library_views_liveupdate.js
+++ b/browser/components/places/tests/browser/browser_library_views_liveupdate.js
@@ -180,17 +180,17 @@ var bookmarksObserver = {
         is(node, null, "New Places node not added in left pane");
         break;
       default:
         isnot(node, null, "Found new Places node in left pane");
         ok(index >= 0, "Node is at index " + index);
     }
   },
 
-  onItemRemoved: function PSB_onItemRemoved(aItemId, aFolder, aIndex) {
+  onItemRemoved: function(aItemId, aFolder, aIndex) {
     var node = null;
     var index = null;
     [node, index] = getNodeForTreeItem(aItemId, gLibrary.PlacesOrganizer._places);
     is(node, null, "Places node not found in left pane");
   },
 
   onItemMoved: function(aItemId,
                         aOldFolderId, aOldIndex,
@@ -213,18 +213,18 @@ var bookmarksObserver = {
         is(node, null, "New Places node not added in left pane");
         break;
       default:
         isnot(node, null, "Found new Places node in left pane");
         ok(index >= 0, "Node is at index " + index);
     }
   },
 
-  onBeginUpdateBatch: function PSB_onBeginUpdateBatch() {},
-  onEndUpdateBatch: function PSB_onEndUpdateBatch() {},
+  onBeginUpdateBatch: function() {},
+  onEndUpdateBatch: function() {},
   onItemVisited: function() {},
   onItemChanged: function PSB_onItemChanged(aItemId, aProperty,
                                             aIsAnnotationProperty, aNewValue) {
     if (aProperty == "title") {
       let validator = function(aTreeRowIndex) {
         let tree = gLibrary.PlacesOrganizer._places;
         let cellText = tree.view.getCellText(aTreeRowIndex,
                                              tree.columns.getColumnAt(0));
diff --git a/browser/components/places/tests/browser/browser_views_liveupdate.js b/browser/components/places/tests/browser/browser_views_liveupdate.js
--- a/browser/components/places/tests/browser/browser_views_liveupdate.js
+++ b/browser/components/places/tests/browser/browser_views_liveupdate.js
@@ -236,18 +236,18 @@ var bookmarksObserver = {
       var node = null;
       var index = null;
       [node, index] = searchItemInView(aItemId, views[i]);
       isnot(node, null, "Found new Places node in " + views[i]);
       is(index, aNewIndex, "Node is at index " + index);
     }
   },
 
-  onBeginUpdateBatch: function PSB_onBeginUpdateBatch() {},
-  onEndUpdateBatch: function PSB_onEndUpdateBatch() {},
+  onBeginUpdateBatch: function() {},
+  onEndUpdateBatch: function() {},
   onItemVisited: function() {},
 
   onItemChanged: function PSB_onItemChanged(aItemId, aProperty,
                                             aIsAnnotationProperty, aNewValue,
                                             aLastModified, aItemType,
                                             aParentId) {
     if (aProperty !== "title")
       return;
diff --git a/browser/components/places/tests/unit/test_clearHistory_shutdown.js b/browser/components/places/tests/unit/test_clearHistory_shutdown.js
--- a/browser/components/places/tests/unit/test_clearHistory_shutdown.js
+++ b/browser/components/places/tests/unit/test_clearHistory_shutdown.js
@@ -34,17 +34,17 @@ const FTP_URL = "ftp://localhost/clearHi
 // that it has been initialized.
 var formHistoryStartup = Cc["@mozilla.org/satchel/form-history-startup;1"].
                          getService(Ci.nsIObserver);
 formHistoryStartup.observe(null, "profile-after-change", null);
 
 let notificationIndex = 0;
 
 let notificationsObserver = {
-  observe: function observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     print("Received notification: " + aTopic);
 
     // Note that some of these notifications could arrive multiple times, for
     // example in case of sync, we allow that.
     if (EXPECTED_NOTIFICATIONS[notificationIndex] != aTopic)
       notificationIndex++;
     do_check_eq(EXPECTED_NOTIFICATIONS[notificationIndex], aTopic);
 
diff --git a/browser/components/preferences/aboutPermissions.js b/browser/components/preferences/aboutPermissions.js
--- a/browser/components/preferences/aboutPermissions.js
+++ b/browser/components/preferences/aboutPermissions.js
@@ -59,17 +59,17 @@ function Site(host) {
 Site.prototype = {
   /**
    * Gets the favicon to use for the site. The callback only gets called if
    * a favicon is found for either the http URI or the https URI.
    *
    * @param aCallback
    *        A callback function that takes a favicon image URL as a parameter.
    */
-  getFavicon: function Site_getFavicon(aCallback) {
+  getFavicon: function(aCallback) {
     function invokeCallback(aFaviconURI) {
       try {
         // Use getFaviconLinkForIcon to get image data from the database instead
         // of using the favicon URI to fetch image data over the network.
         aCallback(gFaviconService.getFaviconLinkForIcon(aFaviconURI).spec);
       } catch (e) {
         Cu.reportError("AboutPermissions: " + e);
       }
@@ -90,17 +90,17 @@ Site.prototype = {
   },
 
   /**
    * Gets the number of history visits for the site.
    *
    * @param aCallback
    *        A function that takes the visit count (a number) as a parameter.
    */
-  getVisitCount: function Site_getVisitCount(aCallback) {
+  getVisitCount: function(aCallback) {
     let rev_host = this.host.split("").reverse().join("") + ".";
     gVisitStmt.params.rev_host = rev_host;
     gVisitStmt.executeAsync({
       handleResult: function(aResults) {
         let row = aResults.getNextRow();
         let count = row.getResultByName("count") || 0;
         try {
           aCallback(count);
@@ -122,17 +122,17 @@ Site.prototype = {
    * @param aType
    *        The permission type string stored in permission manager.
    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
    * @param aResultObj
    *        An object that stores the permission value set for aType.
    *
    * @return A boolean indicating whether or not a permission is set.
    */
-  getPermission: function Site_getPermission(aType, aResultObj) {
+  getPermission: function(aType, aResultObj) {
     // Password saving isn't a nsIPermissionManager permission type, so handle
     // it seperately.
     if (aType == "password") {
       aResultObj.value =  this.loginSavingEnabled ?
                           Ci.nsIPermissionManager.ALLOW_ACTION :
                           Ci.nsIPermissionManager.DENY_ACTION;
       return true;
     }
@@ -153,17 +153,17 @@ Site.prototype = {
    *
    * @param aType
    *        The permission type string stored in permission manager.
    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
    * @param aPerm
    *        The permission value to set for the permission type. This should
    *        be one of the constants defined in nsIPermissionManager.
    */
-  setPermission: function Site_setPermission(aType, aPerm) {
+  setPermission: function(aType, aPerm) {
     // Password saving isn't a nsIPermissionManager permission type, so handle
     // it seperately.
     if (aType == "password") {
       this.loginSavingEnabled = aPerm == Ci.nsIPermissionManager.ALLOW_ACTION;
       return;
     }
 
     // Using httpURI is kind of bogus, but the permission manager stores the
@@ -173,17 +173,17 @@ Site.prototype = {
 
   /**
    * Clears a user-set permission value for the site given a permission type.
    *
    * @param aType
    *        The permission type string stored in permission manager.
    *        e.g. "cookie", "geo", "indexedDB", "popup", "image"
    */
-  clearPermission: function Site_clearPermission(aType) {
+  clearPermission: function(aType) {
     Services.perms.remove(this.host, aType);
   },
 
   /**
    * Gets cookies stored for the site. This does not return cookies stored
    * for the base domain, only the exact hostname stored for the site.
    *
    * @return An array of the cookies set for the site.
@@ -200,17 +200,17 @@ Site.prototype = {
       }
     }
     return cookies;
   },
 
   /**
    * Removes a set of specific cookies from the browser.
    */
-  clearCookies: function Site_clearCookies() {
+  clearCookies: function() {
     this.cookies.forEach(function(aCookie) {
       Services.cookies.remove(aCookie.host, aCookie.name, aCookie.path, false);
     });
   },
 
   /**
    * Gets logins stored for the site.
    *
@@ -231,17 +231,17 @@ Site.prototype = {
   set loginSavingEnabled(isEnabled) {
     Services.logins.setLoginSavingEnabled(this.httpURI.prePath, isEnabled);
     Services.logins.setLoginSavingEnabled(this.httpsURI.prePath, isEnabled);
   },
 
   /**
    * Removes all data from the browser corresponding to the site.
    */
-  forgetSite: function Site_forgetSite() {
+  forgetSite: function() {
     ForgetAboutSite.removeDataFromDomain(this.host);
   }
 }
 
 /**
  * PermissionDefaults object keeps track of default permissions for sites based
  * on global preferences.
  *
diff --git a/browser/components/preferences/applicationManager.js b/browser/components/preferences/applicationManager.js
--- a/browser/components/preferences/applicationManager.js
+++ b/browser/components/preferences/applicationManager.js
@@ -5,17 +5,17 @@
 #ifdef XP_MACOSX
 var Cc = Components.classes;
 var Ci = Components.interfaces;
 #endif
 
 var gAppManagerDialog = {
   _removed: [],
 
-  init: function appManager_init() {
+  init: function() {
     this.handlerInfo = window.arguments[0];
 
     var bundle = document.getElementById("appManagerBundle");
     var contentText;
     if (this.handlerInfo.type == TYPE_MAYBE_FEED)
       contentText = bundle.getString("handleWebFeeds");
     else {
       var description = gApplicationsPane._describeType(this.handlerInfo);
@@ -39,33 +39,33 @@ var gAppManagerDialog = {
       item.setAttribute("image", gApplicationsPane._getIconURLForHandlerApp(app));
       item.className = "listitem-iconic";
       item.app = app;
     }
 
     list.selectedIndex = 0;
   },
 
-  onOK: function appManager_onOK() {
+  onOK: function() {
     if (!this._removed.length) {
       // return early to avoid calling the |store| method.
       return;
     }
 
     for (var i = 0; i < this._removed.length; ++i)
       this.handlerInfo.removePossibleApplicationHandler(this._removed[i]);
 
     this.handlerInfo.store();
   },
 
-  onCancel: function appManager_onCancel() {
+  onCancel: function() {
     // do nothing
   },
 
-  remove: function appManager_remove() {
+  remove: function() {
     var list = document.getElementById("appList");
     this._removed.push(list.selectedItem.app);
     var index = list.selectedIndex;
     list.removeItemAt(index);
     if (list.getRowCount() == 0) {
       // The list is now empty, make the bottom part disappear
       document.getElementById("appDetails").hidden = true;
     }
@@ -73,17 +73,17 @@ var gAppManagerDialog = {
       // Select the item at the same index, if we removed the last
       // item of the list, select the previous item
       if (index == list.getRowCount())
         --index;
       list.selectedIndex = index;
     }
   },
 
-  onSelect: function appManager_onSelect() {
+  onSelect: function() {
     var list = document.getElementById("appList");
     if (!list.selectedItem) {
       document.getElementById("remove").disabled = true;
       return;
     }
     document.getElementById("remove").disabled = false;
     var app = list.selectedItem.app;
     var address = "";
diff --git a/browser/components/preferences/cookies.js b/browser/components/preferences/cookies.js
--- a/browser/components/preferences/cookies.js
+++ b/browser/components/preferences/cookies.js
@@ -553,17 +553,17 @@ var gCookiesWindow = {
     let buttonLabel = this._bundle.getString("removeSelectedCookies");
     let removeSelectedCookies = document.getElementById("removeSelectedCookies");
     removeSelectedCookies.label = PluralForm.get(selectedCookieCount, buttonLabel)
                                             .replace("#1", selectedCookieCount);
 
     removeSelectedCookies.disabled = !(seln.count > 0);
   },
 
-  performDeletion: function gCookiesWindow_performDeletion(deleteItems) {
+  performDeletion: function(deleteItems) {
     var psvc = Components.classes["@mozilla.org/preferences-service;1"]
                          .getService(Components.interfaces.nsIPrefBranch);
     var blockFutureCookies = false;
     if (psvc.prefHasUserValue("network.cookie.blockFutureCookies"))
       blockFutureCookies = psvc.getBoolPref("network.cookie.blockFutureCookies");
     for (var i = 0; i < deleteItems.length; ++i) {
       var item = deleteItems[i];
       this._cm.remove(item.host, item.name, item.path, blockFutureCookies);
@@ -857,17 +857,17 @@ var gCookiesWindow = {
     this._openIndices = [];
     for (i = 0; i < this._view.rowCount; ++i) {
       var item = this._view._getItemAtIndex(i);
       if (item && item.container && item.open)
         this._openIndices.push(i);
     }
   },
 
-  _updateRemoveAllButton: function gCookiesWindow__updateRemoveAllButton() {
+  _updateRemoveAllButton: function() {
     document.getElementById("removeAllCookies").disabled = this._view._rowCount == 0;
   },
 
   filter: function () {
     var filter = document.getElementById("filter").value;
     if (filter == "") {
       gCookiesWindow.clearFilter();
       return;
diff --git a/browser/components/preferences/in-content/privacy.js b/browser/components/preferences/in-content/privacy.js
--- a/browser/components/preferences/in-content/privacy.js
+++ b/browser/components/preferences/in-content/privacy.js
@@ -279,17 +279,17 @@ var gPrivacyPane = {
     let mode = document.getElementById("historyMode");
     let autoStart = document.getElementById("privateBrowsingAutoStart");
     this._lastMode = mode.selectedIndex;
     this._lastCheckState = autoStart.hasAttribute('checked');
   },
 
   _lastMode: null,
   _lastCheckState: null,
-  updateAutostart: function PPP_updateAutostart() {
+  updateAutostart: function() {
       let mode = document.getElementById("historyMode");
       let autoStart = document.getElementById("privateBrowsingAutoStart");
       let pref = document.getElementById("browser.privatebrowsing.autostart");
       if ((mode.value == "custom" && this._lastCheckState == autoStart.checked) ||
           (mode.value == "remember" && !this._lastCheckState) ||
           (mode.value == "dontremember" && this._lastCheckState)) {
           // These are all no-op changes, so we don't need to prompt.
           this._lastMode = mode.selectedIndex;
diff --git a/browser/components/preferences/in-content/search.js b/browser/components/preferences/in-content/search.js
--- a/browser/components/preferences/in-content/search.js
+++ b/browser/components/preferences/in-content/search.js
@@ -279,77 +279,77 @@ EngineStore.prototype = {
   get engines() {
     return this._engines;
   },
   set engines(val) {
     this._engines = val;
     return val;
   },
 
-  _getIndexForEngine: function ES_getIndexForEngine(aEngine) {
+  _getIndexForEngine: function(aEngine) {
     return this._engines.indexOf(aEngine);
   },
 
-  _getEngineByName: function ES_getEngineByName(aName) {
+  _getEngineByName: function(aName) {
     for each (var engine in this._engines)
       if (engine.name == aName)
         return engine;
 
     return null;
   },
 
-  _cloneEngine: function ES_cloneEngine(aEngine) {
+  _cloneEngine: function(aEngine) {
     var clonedObj={};
     for (var i in aEngine)
       clonedObj[i] = aEngine[i];
     clonedObj.originalEngine = aEngine;
     clonedObj.shown = this.hiddenList.indexOf(clonedObj.name) == -1;
     return clonedObj;
   },
 
   // Callback for Array's some(). A thisObj must be passed to some()
-  _isSameEngine: function ES_isSameEngine(aEngineClone) {
+  _isSameEngine: function(aEngineClone) {
     return aEngineClone.originalEngine == this.originalEngine;
   },
 
-  addEngine: function ES_addEngine(aEngine) {
+  addEngine: function(aEngine) {
     this._engines.push(this._cloneEngine(aEngine));
   },
 
-  moveEngine: function ES_moveEngine(aEngine, aNewIndex) {
+  moveEngine: function(aEngine, aNewIndex) {
     if (aNewIndex < 0 || aNewIndex > this._engines.length - 1)
       throw new Error("ES_moveEngine: invalid aNewIndex!");
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("ES_moveEngine: invalid engine?");
 
     if (index == aNewIndex)
       return; // nothing to do
 
     // Move the engine in our internal store
     var removedEngine = this._engines.splice(index, 1)[0];
     this._engines.splice(aNewIndex, 0, removedEngine);
 
     Services.search.moveEngine(aEngine.originalEngine, aNewIndex);
   },
 
-  removeEngine: function ES_removeEngine(aEngine) {
+  removeEngine: function(aEngine) {
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("invalid engine?");
 
     this._engines.splice(index, 1);
     Services.search.removeEngine(aEngine.originalEngine);
 
     if (this._defaultEngines.some(this._isSameEngine, aEngine))
       gSearchPane.showRestoreDefaults(true);
     gSearchPane.buildDefaultEngineDropDown();
   },
 
-  restoreDefaultEngines: function ES_restoreDefaultEngines() {
+  restoreDefaultEngines: function() {
     var added = 0;
 
     for (var i = 0; i < this._defaultEngines.length; ++i) {
       var e = this._defaultEngines[i];
 
       // If the engine is already in the list, just move it.
       if (this._engines.some(this._isSameEngine, e)) {
         this.moveEngine(this._getEngineByName(e.name), i);
@@ -367,26 +367,26 @@ EngineStore.prototype = {
         added++;
       }
     }
     gSearchPane.showRestoreDefaults(false);
     gSearchPane.buildDefaultEngineDropDown();
     return added;
   },
 
-  changeEngine: function ES_changeEngine(aEngine, aProp, aNewValue) {
+  changeEngine: function(aEngine, aProp, aNewValue) {
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("invalid engine?");
 
     this._engines[index][aProp] = aNewValue;
     aEngine.originalEngine[aProp] = aNewValue;
   },
 
-  reloadIcons: function ES_reloadIcons() {
+  reloadIcons: function() {
     this._engines.forEach(function (e) {
       e.uri = e.originalEngine.uri;
     });
   }
 };
 
 function EngineView(aEngineStore) {
   this._engineStore = aEngineStore;
diff --git a/browser/components/preferences/privacy.js b/browser/components/preferences/privacy.js
--- a/browser/components/preferences/privacy.js
+++ b/browser/components/preferences/privacy.js
@@ -245,17 +245,17 @@ var gPrivacyPane = {
     let mode = document.getElementById("historyMode");
     let autoStart = document.getElementById("privateBrowsingAutoStart");
     this._lastMode = mode.selectedIndex;
     this._lastCheckState = autoStart.hasAttribute('checked');
   },
 
   _lastMode: null,
   _lastCheckState: null,
-  updateAutostart: function PPP_updateAutostart() {
+  updateAutostart: function() {
       let mode = document.getElementById("historyMode");
       let autoStart = document.getElementById("privateBrowsingAutoStart");
       let pref = document.getElementById("browser.privatebrowsing.autostart");
       if ((mode.value == "custom" && this._lastCheckState == autoStart.checked) ||
           (mode.value == "remember" && !this._lastCheckState) ||
           (mode.value == "dontremember" && this._lastCheckState)) {
           // These are all no-op changes, so we don't need to prompt.
           this._lastMode = mode.selectedIndex;
@@ -309,17 +309,17 @@ var gPrivacyPane = {
   },
 
   // HISTORY
 
   /**
    * Update browser.urlbar.autocomplete.enabled when a
    * browser.urlbar.suggest.* pref is changed from the ui.
    */
-  writeSuggestionPref: function PPP_writeSuggestionPref() {
+  writeSuggestionPref: function() {
     let getVal = (aPref) => {
       return document.getElementById("browser.urlbar.suggest." + aPref).value;
     }
     // autocomplete.enabled is true if any of the suggestions is true
     let enabled = ["history", "bookmark", "openpage"].map(getVal).some(v => v);
     Services.prefs.setBoolPref("browser.urlbar.autocomplete.enabled", enabled);
   },
 
diff --git a/browser/components/preferences/search.js b/browser/components/preferences/search.js
--- a/browser/components/preferences/search.js
+++ b/browser/components/preferences/search.js
@@ -204,43 +204,43 @@ function EngineMoveOp(aEngineClone, aNew
   if (!aEngineClone)
     throw new Error("bad args to new EngineMoveOp!");
   this._engine = aEngineClone.originalEngine;
   this._newIndex = aNewIndex;
 }
 EngineMoveOp.prototype = {
   _engine: null,
   _newIndex: null,
-  commit: function EMO_commit() {
+  commit: function() {
     Services.search.moveEngine(this._engine, this._newIndex);
   }
 };
 
 function EngineRemoveOp(aEngineClone) {
   if (!aEngineClone)
     throw new Error("bad args to new EngineRemoveOp!");
   this._engine = aEngineClone.originalEngine;
 }
 EngineRemoveOp.prototype = {
   _engine: null,
-  commit: function ERO_commit() {
+  commit: function() {
     Services.search.removeEngine(this._engine);
   }
 };
 
 function EngineUnhideOp(aEngineClone, aNewIndex) {
   if (!aEngineClone)
     throw new Error("bad args to new EngineUnhideOp!");
   this._engine = aEngineClone.originalEngine;
   this._newIndex = aNewIndex;
 }
 EngineUnhideOp.prototype = {
   _engine: null,
   _newIndex: null,
-  commit: function EUO_commit() {
+  commit: function() {
     this._engine.hidden = false;
     Services.search.moveEngine(this._engine, this._newIndex);
   }
 };
 
 function EngineChangeOp(aEngineClone, aProp, aValue) {
   if (!aEngineClone)
     throw new Error("bad args to new EngineChangeOp!");
@@ -248,17 +248,17 @@ function EngineChangeOp(aEngineClone, aP
   this._engine = aEngineClone.originalEngine;
   this._prop = aProp;
   this._newValue = aValue;
 }
 EngineChangeOp.prototype = {
   _engine: null,
   _prop: null,
   _newValue: null,
-  commit: function ECO_commit() {
+  commit: function() {
     this._engine[this._prop] = this._newValue;
   }
 };
 
 function EngineStore() {
   let pref = document.getElementById("browser.search.hiddenOneOffs").value;
   this.hiddenList = pref ? pref.split(",") : [];
 
@@ -289,84 +289,84 @@ EngineStore.prototype = {
   get engines() {
     return this._engines;
   },
   set engines(val) {
     this._engines = val;
     return val;
   },
 
-  _getIndexForEngine: function ES_getIndexForEngine(aEngine) {
+  _getIndexForEngine: function(aEngine) {
     return this._engines.indexOf(aEngine);
   },
 
-  _getEngineByName: function ES_getEngineByName(aName) {
+  _getEngineByName: function(aName) {
     for each (var engine in this._engines)
       if (engine.name == aName)
         return engine;
 
     return null;
   },
 
-  _cloneEngine: function ES_cloneEngine(aEngine) {
+  _cloneEngine: function(aEngine) {
     var clonedObj={};
     for (var i in aEngine)
       clonedObj[i] = aEngine[i];
     clonedObj.originalEngine = aEngine;
     clonedObj.shown = this.hiddenList.indexOf(clonedObj.name) == -1;
     return clonedObj;
   },
 
   // Callback for Array's some(). A thisObj must be passed to some()
-  _isSameEngine: function ES_isSameEngine(aEngineClone) {
+  _isSameEngine: function(aEngineClone) {
     return aEngineClone.originalEngine == this.originalEngine;
   },
 
-  commit: function ES_commit() {
+  commit: function() {
     for (op of this._ops)
       op.commit();
 
     Services.search.currentEngine =
       document.getElementById("defaultEngine").selectedItem.engine;
   },
 
-  addEngine: function ES_addEngine(aEngine) {
+  addEngine: function(aEngine) {
     this._engines.push(this._cloneEngine(aEngine));
   },
 
-  moveEngine: function ES_moveEngine(aEngine, aNewIndex) {
+  moveEngine: function(aEngine, aNewIndex) {
     if (aNewIndex < 0 || aNewIndex > this._engines.length - 1)
       throw new Error("ES_moveEngine: invalid aNewIndex!");
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("ES_moveEngine: invalid engine?");
 
     if (index == aNewIndex)
       return; // nothing to do
 
     // Move the engine in our internal store
     var removedEngine = this._engines.splice(index, 1)[0];
     this._engines.splice(aNewIndex, 0, removedEngine);
 
     this._ops.push(new EngineMoveOp(aEngine, aNewIndex));
   },
 
-  removeEngine: function ES_removeEngine(aEngine) {
+  removeEngine: function(aEngine) {
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("invalid engine?");
 
     this._engines.splice(index, 1);
     this._ops.push(new EngineRemoveOp(aEngine));
     if (this._defaultEngines.some(this._isSameEngine, aEngine))
       gSearchPane.showRestoreDefaults(true);
     gSearchPane.buildDefaultEngineDropDown();
   },
 
-  restoreDefaultEngines: function ES_restoreDefaultEngines() {
+  restoreDefaultEngines: function() {
     var added = 0;
 
     for (var i = 0; i < this._defaultEngines.length; ++i) {
       var e = this._defaultEngines[i];
 
       // If the engine is already in the list, just move it.
       if (this._engines.some(this._isSameEngine, e)) {
         this.moveEngine(this._getEngineByName(e.name), i);
@@ -382,26 +382,26 @@ EngineStore.prototype = {
         added++;
       }
     }
     gSearchPane.showRestoreDefaults(false);
     gSearchPane.buildDefaultEngineDropDown();
     return added;
   },
 
-  changeEngine: function ES_changeEngine(aEngine, aProp, aNewValue) {
+  changeEngine: function(aEngine, aProp, aNewValue) {
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("invalid engine?");
 
     this._engines[index][aProp] = aNewValue;
     this._ops.push(new EngineChangeOp(aEngine, aProp, aNewValue));
   },
 
-  reloadIcons: function ES_reloadIcons() {
+  reloadIcons: function() {
     this._engines.forEach(function (e) {
       e.uri = e.originalEngine.uri;
     });
   }
 };
 
 function EngineView(aEngineStore) {
   this._engineStore = aEngineStore;
diff --git a/browser/components/preferences/selectBookmark.js b/browser/components/preferences/selectBookmark.js
--- a/browser/components/preferences/selectBookmark.js
+++ b/browser/components/preferences/selectBookmark.js
@@ -10,56 +10,56 @@
  * The caller (gMainPane.setHomePageToBookmark in main.js) invokes this dialog
  * with a single argument - a reference to an object with a .urls property and
  * a .names property.  This dialog is responsible for updating the contents of
  * the .urls property with an array of URLs to use as home pages and for
  * updating the .names property with an array of names for those URLs before it
  * closes.
  */ 
 var SelectBookmarkDialog = {
-  init: function SBD_init() {
+  init: function() {
     document.getElementById("bookmarks").place =
       "place:queryType=1&folder=" + PlacesUIUtils.allBookmarksFolderId;
 
     // Initial update of the OK button.
     this.selectionChanged();
   },
 
   /** 
    * Update the disabled state of the OK button as the user changes the 
    * selection within the view. 
    */
-  selectionChanged: function SBD_selectionChanged() {
+  selectionChanged: function() {
     var accept = document.documentElement.getButton("accept");
     var bookmarks = document.getElementById("bookmarks");
     var disableAcceptButton = true;
     if (bookmarks.hasSelection) {
       if (!PlacesUtils.nodeIsSeparator(bookmarks.selectedNode))
         disableAcceptButton = false;
     }
     accept.disabled = disableAcceptButton;
   },
 
-  onItemDblClick: function SBD_onItemDblClick() {
+  onItemDblClick: function() {
     var bookmarks = document.getElementById("bookmarks");
     var selectedNode = bookmarks.selectedNode;
     if (selectedNode && PlacesUtils.nodeIsURI(selectedNode)) {
       /**
        * The user has double clicked on a tree row that is a link. Take this to
        * mean that they want that link to be their homepage, and close the dialog.
        */
       document.documentElement.getButton("accept").click();
     }
   },
 
   /**
    * User accepts their selection. Set all the selected URLs or the contents
    * of the selected folder as the list of homepages.
    */
-  accept: function SBD_accept() {
+  accept: function() {
     var bookmarks = document.getElementById("bookmarks");
     NS_ASSERT(bookmarks.hasSelection,
               "Should not be able to accept dialog if there is no selected URL!");
     var urls = [];
     var names = [];
     var selectedNode = bookmarks.selectedNode;
     if (PlacesUtils.nodeIsFolder(selectedNode)) {
       var contents = PlacesUtils.getFolderContents(selectedNode.itemId).root;
diff --git a/browser/components/search/content/engineManager.js b/browser/components/search/content/engineManager.js
--- a/browser/components/search/content/engineManager.js
+++ b/browser/components/search/content/engineManager.js
@@ -9,34 +9,34 @@ const Cc = Components.classes;
 
 const ENGINE_FLAVOR = "text/x-moz-search-engine";
 
 const BROWSER_SUGGEST_PREF = "browser.search.suggest.enabled";
 
 var gEngineView = null;
 
 var gEngineManagerDialog = {
-  init: function engineManager_init() {
+  init: function() {
     gEngineView = new EngineView(new EngineStore());
 
     var suggestEnabled = Services.prefs.getBoolPref(BROWSER_SUGGEST_PREF);
     document.getElementById("enableSuggest").checked = suggestEnabled;
 
     var tree = document.getElementById("engineList");
     tree.view = gEngineView;
 
     Services.obs.addObserver(this, "browser-search-engine-modified", false);
   },
 
-  destroy: function engineManager_destroy() {
+  destroy: function() {
     // Remove the observer
     Services.obs.removeObserver(this, "browser-search-engine-modified");
   },
 
-  observe: function engineManager_observe(aEngine, aTopic, aVerb) {
+  observe: function(aEngine, aTopic, aVerb) {
     if (aTopic == "browser-search-engine-modified") {
       aEngine.QueryInterface(Ci.nsISearchEngine);
       switch (aVerb) {
       case "engine-added":
         gEngineView._engineStore.addEngine(aEngine);
         gEngineView.rowCountChanged(gEngineView.lastIndex, 1);
         break;
       case "engine-changed":
@@ -47,70 +47,70 @@ var gEngineManagerDialog = {
       case "engine-current":
       case "engine-default":
         // Not relevant
         break;
       }
     }
   },
 
-  onOK: function engineManager_onOK() {
+  onOK: function() {
     // Set the preference
     var newSuggestEnabled = document.getElementById("enableSuggest").checked;
     Services.prefs.setBoolPref(BROWSER_SUGGEST_PREF, newSuggestEnabled);
 
     // Commit the changes
     gEngineView._engineStore.commit();
   },
 
-  onRestoreDefaults: function engineManager_onRestoreDefaults() {
+  onRestoreDefaults: function() {
     var num = gEngineView._engineStore.restoreDefaultEngines();
     gEngineView.rowCountChanged(0, num);
     gEngineView.invalidate();
   },
 
-  showRestoreDefaults: function engineManager_showRestoreDefaults(val) {
+  showRestoreDefaults: function(val) {
     document.documentElement.getButton("extra2").disabled = !val;
   },
 
-  loadAddEngines: function engineManager_loadAddEngines() {
+  loadAddEngines: function() {
     this.onOK();
     window.opener.BrowserSearch.loadAddEngines();
     window.close();
   },
 
-  remove: function engineManager_remove() {
+  remove: function() {
     gEngineView._engineStore.removeEngine(gEngineView.selectedEngine);
     var index = gEngineView.selectedIndex;
     gEngineView.rowCountChanged(index, -1);
     gEngineView.invalidate();
     gEngineView.selection.select(Math.min(index, gEngineView.lastIndex));
     gEngineView.ensureRowIsVisible(gEngineView.currentIndex);
     document.getElementById("engineList").focus();
   },
 
   /**
    * Moves the selected engine either up or down in the engine list
    * @param aDir
    *        -1 to move the selected engine down, +1 to move it up.
    */
-  bump: function engineManager_move(aDir) {
+  bump: function(aDir) {
     var selectedEngine = gEngineView.selectedEngine;
     var newIndex = gEngineView.selectedIndex - aDir;
 
     gEngineView._engineStore.moveEngine(selectedEngine, newIndex);
 
     gEngineView.invalidate();
     gEngineView.selection.select(newIndex);
     gEngineView.ensureRowIsVisible(newIndex);
     this.showRestoreDefaults(true);
     document.getElementById("engineList").focus();
   },
 
-  editKeyword: function engineManager_editKeyword() {
+  editKeyword: function() {
     var selectedEngine = gEngineView.selectedEngine;
     if (!selectedEngine)
       return;
 
     var alias = { value: selectedEngine.alias };
     var strings = document.getElementById("engineManagerBundle");
     var title = strings.getString("editTitle");
     var msg = strings.getFormattedString("editMsg", [selectedEngine.name]);
@@ -151,17 +151,17 @@ var gEngineManagerDialog = {
         gEngineView._engineStore.changeEngine(selectedEngine, "alias",
                                               alias.value);
         gEngineView.invalidate();
         break;
       }
     }
   },
 
-  onSelect: function engineManager_onSelect() {
+  onSelect: function() {
     // Buttons only work if an engine is selected and it's not the last engine,
     // the latter is true when the selected is first and last at the same time.
     var lastSelected = (gEngineView.selectedIndex == gEngineView.lastIndex);
     var firstSelected = (gEngineView.selectedIndex == 0);
     var noSelection = (gEngineView.selectedIndex == -1);
 
     document.getElementById("cmd_remove")
             .setAttribute("disabled", noSelection ||
@@ -191,43 +191,43 @@ function EngineMoveOp(aEngineClone, aNew
   if (!aEngineClone)
     throw new Error("bad args to new EngineMoveOp!");
   this._engine = aEngineClone.originalEngine;
   this._newIndex = aNewIndex;
 }
 EngineMoveOp.prototype = {
   _engine: null,
   _newIndex: null,
-  commit: function EMO_commit() {
+  commit: function() {
     Services.search.moveEngine(this._engine, this._newIndex);
   }
 }
 
 function EngineRemoveOp(aEngineClone) {
   if (!aEngineClone)
     throw new Error("bad args to new EngineRemoveOp!");
   this._engine = aEngineClone.originalEngine;
 }
 EngineRemoveOp.prototype = {
   _engine: null,
-  commit: function ERO_commit() {
+  commit: function() {
     Services.search.removeEngine(this._engine);
   }
 }
 
 function EngineUnhideOp(aEngineClone, aNewIndex) {
   if (!aEngineClone)
     throw new Error("bad args to new EngineUnhideOp!");
   this._engine = aEngineClone.originalEngine;
   this._newIndex = aNewIndex;
 }
 EngineUnhideOp.prototype = {
   _engine: null,
   _newIndex: null,
-  commit: function EUO_commit() {
+  commit: function() {
     this._engine.hidden = false;
     Services.search.moveEngine(this._engine, this._newIndex);
   }
 }
 
 function EngineChangeOp(aEngineClone, aProp, aValue) {
   if (!aEngineClone)
     throw new Error("bad args to new EngineChangeOp!");
@@ -235,17 +235,17 @@ function EngineChangeOp(aEngineClone, aP
   this._engine = aEngineClone.originalEngine;
   this._prop = aProp;
   this._newValue = aValue;
 }
 EngineChangeOp.prototype = {
   _engine: null,
   _prop: null,
   _newValue: null,
-  commit: function ECO_commit() {
+  commit: function() {
     this._engine[this._prop] = this._newValue;
   }
 }
 
 function EngineStore() {
   this._engines = Services.search.getVisibleEngines().map(this._cloneEngine);
   this._defaultEngines = Services.search.getDefaultEngines().map(this._cloneEngine);
 
@@ -263,86 +263,86 @@ EngineStore.prototype = {
   get engines() {
     return this._engines;
   },
   set engines(val) {
     this._engines = val;
     return val;
   },
 
-  _getIndexForEngine: function ES_getIndexForEngine(aEngine) {
+  _getIndexForEngine: function(aEngine) {
     return this._engines.indexOf(aEngine);
   },
 
-  _getEngineByName: function ES_getEngineByName(aName) {
+  _getEngineByName: function(aName) {
     for each (var engine in this._engines)
       if (engine.name == aName)
         return engine;
 
     return null;
   },
 
-  _cloneEngine: function ES_cloneEngine(aEngine) {
+  _cloneEngine: function(aEngine) {
     var clonedObj={};
     for (var i in aEngine)
       clonedObj[i] = aEngine[i];
     clonedObj.originalEngine = aEngine;
     return clonedObj;
   },
 
   // Callback for Array's some(). A thisObj must be passed to some()
-  _isSameEngine: function ES_isSameEngine(aEngineClone) {
+  _isSameEngine: function(aEngineClone) {
     return aEngineClone.originalEngine == this.originalEngine;
   },
 
-  commit: function ES_commit() {
+  commit: function() {
     var currentEngine = this._cloneEngine(Services.search.currentEngine);
     for (var i = 0; i < this._ops.length; i++)
       this._ops[i].commit();
 
     // Restore currentEngine if it is a default engine that is still visible.
     // Needed if the user deletes currentEngine and then restores it.
     if (this._defaultEngines.some(this._isSameEngine, currentEngine) &&
         !currentEngine.originalEngine.hidden)
       Services.search.currentEngine = currentEngine.originalEngine;
   },
 
-  addEngine: function ES_addEngine(aEngine) {
+  addEngine: function(aEngine) {
     this._engines.push(this._cloneEngine(aEngine));
   },
 
-  moveEngine: function ES_moveEngine(aEngine, aNewIndex) {
+  moveEngine: function(aEngine, aNewIndex) {
     if (aNewIndex < 0 || aNewIndex > this._engines.length - 1)
       throw new Error("ES_moveEngine: invalid aNewIndex!");
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("ES_moveEngine: invalid engine?");
 
     if (index == aNewIndex)
       return; // nothing to do
 
     // Move the engine in our internal store
     var removedEngine = this._engines.splice(index, 1)[0];
     this._engines.splice(aNewIndex, 0, removedEngine);
 
     this._ops.push(new EngineMoveOp(aEngine, aNewIndex));
   },
 
-  removeEngine: function ES_removeEngine(aEngine) {
+  removeEngine: function(aEngine) {
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("invalid engine?");
 
     this._engines.splice(index, 1);
     this._ops.push(new EngineRemoveOp(aEngine));
     if (this._defaultEngines.some(this._isSameEngine, aEngine))
       gEngineManagerDialog.showRestoreDefaults(true);
   },
 
-  restoreDefaultEngines: function ES_restoreDefaultEngines() {
+  restoreDefaultEngines: function() {
     var added = 0;
 
     for (var i = 0; i < this._defaultEngines.length; ++i) {
       var e = this._defaultEngines[i];
 
       // If the engine is already in the list, just move it.
       if (this._engines.some(this._isSameEngine, e)) {
         this.moveEngine(this._getEngineByName(e.name), i);
@@ -352,26 +352,26 @@ EngineStore.prototype = {
         this._ops.push(new EngineUnhideOp(e, i));
         added++;
       }
     }
     gEngineManagerDialog.showRestoreDefaults(false);
     return added;
   },
 
-  changeEngine: function ES_changeEngine(aEngine, aProp, aNewValue) {
+  changeEngine: function(aEngine, aProp, aNewValue) {
     var index = this._getIndexForEngine(aEngine);
     if (index == -1)
       throw new Error("invalid engine?");
 
     this._engines[index][aProp] = aNewValue;
     this._ops.push(new EngineChangeOp(aEngine, aProp, aNewValue));
   },
 
-  reloadIcons: function ES_reloadIcons() {
+  reloadIcons: function() {
     this._engines.forEach(function (e) {
       e.uri = e.originalEngine.uri;
     });
   }
 }
 
 function EngineView(aEngineStore) {
   this._engineStore = aEngineStore;
diff --git a/browser/components/search/test/browser_abouthome_behavior.js b/browser/components/search/test/browser_abouthome_behavior.js
--- a/browser/components/search/test/browser_abouthome_behavior.js
+++ b/browser/components/search/test/browser_abouthome_behavior.js
@@ -106,17 +106,17 @@ function test() {
       // Make sure we listen again for uncaught exceptions in the next test or cleanup.
       executeSoon(finish);
     }
   }
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onStateChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       info("onStateChange");
       // Only care about top-level document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart) || !webProgress.isTopLevel)
         return;
 
       info("received document start");
diff --git a/browser/components/search/test/browser_amazon_behavior.js b/browser/components/search/test/browser_amazon_behavior.js
--- a/browser/components/search/test/browser_amazon_behavior.js
+++ b/browser/components/search/test/browser_amazon_behavior.js
@@ -123,17 +123,17 @@ function test() {
     } else {
       finish();
     }
   }
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onStateChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       info("onStateChange");
       // Only care about top-level document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart) || !webProgress.isTopLevel)
         return;
 
       info("received document start");
diff --git a/browser/components/search/test/browser_bing_behavior.js b/browser/components/search/test/browser_bing_behavior.js
--- a/browser/components/search/test/browser_bing_behavior.js
+++ b/browser/components/search/test/browser_bing_behavior.js
@@ -123,17 +123,17 @@ function test() {
     } else {
       finish();
     }
   }
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onStateChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       info("onStateChange");
       // Only care about top-level document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart) || !webProgress.isTopLevel)
         return;
 
       info("received document start");
diff --git a/browser/components/search/test/browser_eBay_behavior.js b/browser/components/search/test/browser_eBay_behavior.js
--- a/browser/components/search/test/browser_eBay_behavior.js
+++ b/browser/components/search/test/browser_eBay_behavior.js
@@ -123,17 +123,17 @@ function test() {
     } else {
       finish();
     }
   }
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onStateChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       info("onStateChange");
       // Only care about top-level document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart) || !webProgress.isTopLevel)
         return;
 
       info("received document start");
diff --git a/browser/components/search/test/browser_google_behavior.js b/browser/components/search/test/browser_google_behavior.js
--- a/browser/components/search/test/browser_google_behavior.js
+++ b/browser/components/search/test/browser_google_behavior.js
@@ -121,17 +121,17 @@ function test() {
     } else {
       finish();
     }
   }
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onStateChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       info("onStateChange");
       // Only care about top-level document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart) || !webProgress.isTopLevel)
         return;
 
       info("received document start");
diff --git a/browser/components/search/test/browser_yahoo_behavior.js b/browser/components/search/test/browser_yahoo_behavior.js
--- a/browser/components/search/test/browser_yahoo_behavior.js
+++ b/browser/components/search/test/browser_yahoo_behavior.js
@@ -123,17 +123,17 @@ function test() {
     } else {
       finish();
     }
   }
 
   let tab = gBrowser.selectedTab = gBrowser.addTab();
 
   let listener = {
-    onStateChange: function onStateChange(webProgress, req, flags, status) {
+    onStateChange: function(webProgress, req, flags, status) {
       info("onStateChange");
       // Only care about top-level document starts
       let docStart = Ci.nsIWebProgressListener.STATE_IS_DOCUMENT |
                      Ci.nsIWebProgressListener.STATE_START;
       if (!(flags & docStart) || !webProgress.isTopLevel)
         return;
 
       info("received document start");
diff --git a/browser/components/sessionstore/SessionStore.jsm b/browser/components/sessionstore/SessionStore.jsm
--- a/browser/components/sessionstore/SessionStore.jsm
+++ b/browser/components/sessionstore/SessionStore.jsm
@@ -167,131 +167,131 @@ this.SessionStore = {
   get canRestoreLastSession() {
     return SessionStoreInternal.canRestoreLastSession;
   },
 
   set canRestoreLastSession(val) {
     SessionStoreInternal.canRestoreLastSession = val;
   },
 
-  init: function ss_init() {
+  init: function() {
     SessionStoreInternal.init();
   },
 
-  getBrowserState: function ss_getBrowserState() {
+  getBrowserState: function() {
     return SessionStoreInternal.getBrowserState();
   },
 
-  setBrowserState: function ss_setBrowserState(aState) {
+  setBrowserState: function(aState) {
     SessionStoreInternal.setBrowserState(aState);
   },
 
-  getWindowState: function ss_getWindowState(aWindow) {
+  getWindowState: function(aWindow) {
     return SessionStoreInternal.getWindowState(aWindow);
   },
 
-  setWindowState: function ss_setWindowState(aWindow, aState, aOverwrite) {
+  setWindowState: function(aWindow, aState, aOverwrite) {
     SessionStoreInternal.setWindowState(aWindow, aState, aOverwrite);
   },
 
-  getTabState: function ss_getTabState(aTab) {
+  getTabState: function(aTab) {
     return SessionStoreInternal.getTabState(aTab);
   },
 
-  setTabState: function ss_setTabState(aTab, aState) {
+  setTabState: function(aTab, aState) {
     SessionStoreInternal.setTabState(aTab, aState);
   },
 
   // This should not be used by external code, the intention is to remove it
   // once a better fix is in place for process switching in e10s.
   // See bug 1075658 for context.
-  _restoreTabAndLoad: function ss_restoreTabAndLoad(aTab, aState, aLoadArguments) {
+  _restoreTabAndLoad: function(aTab, aState, aLoadArguments) {
     SessionStoreInternal.setTabState(aTab, aState, {
       restoreImmediately: true,
       loadArguments: aLoadArguments
     });
   },
 
-  duplicateTab: function ss_duplicateTab(aWindow, aTab, aDelta = 0) {
+  duplicateTab: function(aWindow, aTab, aDelta = 0) {
     return SessionStoreInternal.duplicateTab(aWindow, aTab, aDelta);
   },
 
-  getClosedTabCount: function ss_getClosedTabCount(aWindow) {
+  getClosedTabCount: function(aWindow) {
     return SessionStoreInternal.getClosedTabCount(aWindow);
   },
 
-  getClosedTabData: function ss_getClosedTabDataAt(aWindow) {
+  getClosedTabData: function(aWindow) {
     return SessionStoreInternal.getClosedTabData(aWindow);
   },
 
-  undoCloseTab: function ss_undoCloseTab(aWindow, aIndex) {
+  undoCloseTab: function(aWindow, aIndex) {
     return SessionStoreInternal.undoCloseTab(aWindow, aIndex);
   },
 
-  forgetClosedTab: function ss_forgetClosedTab(aWindow, aIndex) {
+  forgetClosedTab: function(aWindow, aIndex) {
     return SessionStoreInternal.forgetClosedTab(aWindow, aIndex);
   },
 
-  getClosedWindowCount: function ss_getClosedWindowCount() {
+  getClosedWindowCount: function() {
     return SessionStoreInternal.getClosedWindowCount();
   },
 
-  getClosedWindowData: function ss_getClosedWindowData() {
+  getClosedWindowData: function() {
     return SessionStoreInternal.getClosedWindowData();
   },
 
-  undoCloseWindow: function ss_undoCloseWindow(aIndex) {
+  undoCloseWindow: function(aIndex) {
     return SessionStoreInternal.undoCloseWindow(aIndex);
   },
 
-  forgetClosedWindow: function ss_forgetClosedWindow(aIndex) {
+  forgetClosedWindow: function(aIndex) {
     return SessionStoreInternal.forgetClosedWindow(aIndex);
   },
 
-  getWindowValue: function ss_getWindowValue(aWindow, aKey) {
+  getWindowValue: function(aWindow, aKey) {
     return SessionStoreInternal.getWindowValue(aWindow, aKey);
   },
 
-  setWindowValue: function ss_setWindowValue(aWindow, aKey, aStringValue) {
+  setWindowValue: function(aWindow, aKey, aStringValue) {
     SessionStoreInternal.setWindowValue(aWindow, aKey, aStringValue);
   },
 
-  deleteWindowValue: function ss_deleteWindowValue(aWindow, aKey) {
+  deleteWindowValue: function(aWindow, aKey) {
     SessionStoreInternal.deleteWindowValue(aWindow, aKey);
   },
 
-  getTabValue: function ss_getTabValue(aTab, aKey) {
+  getTabValue: function(aTab, aKey) {
     return SessionStoreInternal.getTabValue(aTab, aKey);
   },
 
-  setTabValue: function ss_setTabValue(aTab, aKey, aStringValue) {
+  setTabValue: function(aTab, aKey, aStringValue) {
     SessionStoreInternal.setTabValue(aTab, aKey, aStringValue);
   },
 
-  deleteTabValue: function ss_deleteTabValue(aTab, aKey) {
+  deleteTabValue: function(aTab, aKey) {
     SessionStoreInternal.deleteTabValue(aTab, aKey);
   },
 
-  getGlobalValue: function ss_getGlobalValue(aKey) {
+  getGlobalValue: function(aKey) {
     return SessionStoreInternal.getGlobalValue(aKey);
   },
 
-  setGlobalValue: function ss_setGlobalValue(aKey, aStringValue) {
+  setGlobalValue: function(aKey, aStringValue) {
     SessionStoreInternal.setGlobalValue(aKey, aStringValue);
   },
 
-  deleteGlobalValue: function ss_deleteGlobalValue(aKey) {
+  deleteGlobalValue: function(aKey) {
     SessionStoreInternal.deleteGlobalValue(aKey);
   },
 
-  persistTabAttribute: function ss_persistTabAttribute(aName) {
+  persistTabAttribute: function(aName) {
     SessionStoreInternal.persistTabAttribute(aName);
   },
 
-  restoreLastSession: function ss_restoreLastSession() {
+  restoreLastSession: function() {
     SessionStoreInternal.restoreLastSession();
   },
 
   getCurrentState: function (aUpdateAll) {
     return SessionStoreInternal.getCurrentState(aUpdateAll);
   },
 
   reviveCrashedTab(aTab) {
@@ -531,17 +531,17 @@ let SessionStoreInternal = {
     this._max_windows_undo = this._prefBranch.getIntPref("sessionstore.max_windows_undo");
     this._prefBranch.addObserver("sessionstore.max_windows_undo", this, true);
   },
 
   /**
    * Called on application shutdown, after notifications:
    * quit-application-granted, quit-application
    */
-  _uninit: function ssi_uninit() {
+  _uninit: function() {
     if (!this._initialized) {
       throw new Error("SessionStore is not initialized.");
     }
 
     // Prepare to close the session file and write the last state.
     RunState.setClosing();
 
     // save all data for session resuming
@@ -556,17 +556,17 @@ let SessionStoreInternal = {
     SessionSaver.cancel();
 
     PPMM_MESSAGES.forEach(msg => ppmm.removeMessageListener(msg, this));
   },
 
   /**
    * Handle notifications
    */
-  observe: function ssi_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "browser-window-before-show": // catch new windows
         this.onBeforeBrowserWindowShown(aSubject);
         break;
       case "domwindowclosed": // catch closed windows
         this.onClose(aSubject);
         break;
       case "quit-application-requested":
@@ -727,17 +727,17 @@ let SessionStoreInternal = {
     }
   },
 
   /* ........ Window Event Handlers .............. */
 
   /**
    * Implement nsIDOMEventListener for handling various window and tab events
    */
-  handleEvent: function ssi_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     var win = aEvent.currentTarget.ownerDocument.defaultView;
     switch (aEvent.type) {
       case "TabOpen":
         this.onTabAdd(win, aEvent.originalTarget);
         break;
       case "TabClose":
         // aEvent.detail determines if the tab was closed by moving to a different window
         if (!aEvent.detail)
@@ -765,32 +765,32 @@ let SessionStoreInternal = {
     this._clearRestoringWindows();
   },
 
   /**
    * Generate a unique window identifier
    * @return string
    *         A unique string to identify a window
    */
-  _generateWindowID: function ssi_generateWindowID() {
+  _generateWindowID: function() {
     return "window" + (this._nextWindowID++);
   },
 
   /**
    * If it's the first window load since app start...
    * - determine if we're reloading after a crash or a forced-restart
    * - restore window state
    * - restart downloads
    * Set up event listeners for this window's tabs
    * @param aWindow
    *        Window reference
    * @param aInitialState
    *        The initial state to be loaded after startup (optional)
    */
-  onLoad: function ssi_onLoad(aWindow, aInitialState = null) {
+  onLoad: function(aWindow, aInitialState = null) {
     // return if window has already been initialized
     if (aWindow && aWindow.__SSi && this._windows[aWindow.__SSi])
       return;
 
     // ignore windows opened while shutting down
     if (RunState.isQuitting)
       return;
 
@@ -1017,17 +1017,17 @@ let SessionStoreInternal = {
 
   /**
    * On window close...
    * - remove event listeners from tabs
    * - save all window data
    * @param aWindow
    *        Window reference
    */
-  onClose: function ssi_onClose(aWindow) {
+  onClose: function(aWindow) {
     // this window was about to be restored - conserve its original data, if any
     let isFullyLoaded = this._isWindowLoaded(aWindow);
     if (!isFullyLoaded) {
       if (!aWindow.__SSi) {
         aWindow.__SSi = this._generateWindowID();
       }
 
       this._windows[aWindow.__SSi] = this._statesToRestore[aWindow.__SS_restoreID];
@@ -1131,17 +1131,17 @@ let SessionStoreInternal = {
     FMM_MESSAGES.forEach(msg => mm.removeMessageListener(msg, this));
 
     delete aWindow.__SSi;
   },
 
   /**
    * On quit application requested
    */
-  onQuitApplicationRequested: function ssi_onQuitApplicationRequested() {
+  onQuitApplicationRequested: function() {
     // get a current snapshot of all windows
     this._forEachBrowserWindow(function(aWindow) {
       // Flush all data queued in the content script to not lose it when
       // shutting down.
       TabState.flushWindow(aWindow);
       this._collectWindowData(aWindow);
     });
     // we must cache this because _getMostRecentBrowserWindow will always
@@ -1150,30 +1150,30 @@ let SessionStoreInternal = {
     if (activeWindow)
       this.activeWindowSSiCache = activeWindow.__SSi || "";
     DirtyWindows.clear();
   },
 
   /**
    * On last browser window close
    */
-  onLastWindowCloseGranted: function ssi_onLastWindowCloseGranted() {
+  onLastWindowCloseGranted: function() {
     // last browser window is quitting.
     // remember to restore the last window when another browser window is opened
     // do not account for pref(resume_session_once) at this point, as it might be
     // set by another observer getting this notice after us
     this._restoreLastWindow = true;
   },
 
   /**
    * On quitting application
    * @param aData
    *        String type of quitting
    */
-  onQuitApplication: function ssi_onQuitApplication(aData) {
+  onQuitApplication: function(aData) {
     if (aData == "restart") {
       this._prefBranch.setBoolPref("sessionstore.resume_session_once", true);
       // The browser:purge-session-history notification fires after the
       // quit-application notification so unregister the
       // browser:purge-session-history notification to prevent clearing
       // session data on disk on a restart.  It is also unnecessary to
       // perform any other sanitization processing on a restart as the
       // browser is about to exit anyway.
@@ -1186,17 +1186,17 @@ let SessionStoreInternal = {
     }
 
     this._uninit();
   },
 
   /**
    * On purge of session history
    */
-  onPurgeSessionHistory: function ssi_onPurgeSessionHistory() {
+  onPurgeSessionHistory: function() {
     SessionFile.wipe();
     // If the browser is shutting down, simply return after clearing the
     // session data on disk as this notification fires after the
     // quit-application notification so the browser is about to exit.
     if (RunState.isQuitting)
       return;
     LastSession.clear();
     let openWindows = {};
@@ -1229,17 +1229,17 @@ let SessionStoreInternal = {
     this._clearRestoringWindows();
   },
 
   /**
    * On purge of domain data
    * @param aData
    *        String domain data
    */
-  onPurgeDomainData: function ssi_onPurgeDomainData(aData) {
+  onPurgeDomainData: function(aData) {
     // does a session history entry contain a url for the given domain?
     function containsDomain(aEntry) {
       if (Utils.hasRootDomain(aEntry.url, aData)) {
         return true;
       }
       return aEntry.children && aEntry.children.some(containsDomain, this);
     }
     // remove all closed tabs containing a reference to the given domain
@@ -1287,17 +1287,17 @@ let SessionStoreInternal = {
     this._clearRestoringWindows();
   },
 
   /**
    * On preference change
    * @param aData
    *        String preference changed
    */
-  onPrefChange: function ssi_onPrefChange(aData) {
+  onPrefChange: function(aData) {
     switch (aData) {
       // if the user decreases the max number of closed tabs they want
       // preserved update our internal states to match that max
       case "sessionstore.max_tabs_undo":
         this._max_tabs_undo = this._prefBranch.getIntPref("sessionstore.max_tabs_undo");
         for (let ix in this._windows) {
           this._windows[ix]._closedTabs.splice(this._max_tabs_undo, this._windows[ix]._closedTabs.length);
         }
@@ -1313,17 +1313,17 @@ let SessionStoreInternal = {
    * set up listeners for a new tab
    * @param aWindow
    *        Window reference
    * @param aTab
    *        Tab reference
    * @param aNoNotification
    *        bool Do not save state if we're updating an existing tab
    */
-  onTabAdd: function ssi_onTabAdd(aWindow, aTab, aNoNotification) {
+  onTabAdd: function(aWindow, aTab, aNoNotification) {
     let browser = aTab.linkedBrowser;
     browser.addEventListener("SwapDocShells", this);
     browser.addEventListener("oop-browser-crashed", this);
     if (!aNoNotification) {
       this.saveStateDelayed(aWindow);
     }
   },
 
@@ -1331,17 +1331,17 @@ let SessionStoreInternal = {
    * remove listeners for a tab
    * @param aWindow
    *        Window reference
    * @param aTab
    *        Tab reference
    * @param aNoNotification
    *        bool Do not save state if we're updating an existing tab
    */
-  onTabRemove: function ssi_onTabRemove(aWindow, aTab, aNoNotification) {
+  onTabRemove: function(aWindow, aTab, aNoNotification) {
     let browser = aTab.linkedBrowser;
     delete browser.__SS_data;
     browser.removeEventListener("SwapDocShells", this);
     browser.removeEventListener("oop-browser-crashed", this);
 
     // If this tab was in the middle of restoring or still needs to be restored,
     // we need to reset that state. If the tab was restoring, we will attempt to
     // restore the next tab.
@@ -1359,17 +1359,17 @@ let SessionStoreInternal = {
 
   /**
    * When a tab closes, collect its properties
    * @param aWindow
    *        Window reference
    * @param aTab
    *        Tab reference
    */
-  onTabClose: function ssi_onTabClose(aWindow, aTab) {
+  onTabClose: function(aWindow, aTab) {
     // notify the tabbrowser that the tab state will be retrieved for the last time
     // (so that extension authors can easily set data on soon-to-be-closed tabs)
     var event = aWindow.document.createEvent("Events");
     event.initEvent("SSTabClosing", true, false);
     aTab.dispatchEvent(event);
 
     // don't update our internal state if we don't have to
     if (this._max_tabs_undo == 0) {
@@ -1407,47 +1407,47 @@ let SessionStoreInternal = {
     }
   },
 
   /**
    * When a tab is selected, save session data
    * @param aWindow
    *        Window reference
    */
-  onTabSelect: function ssi_onTabSelect(aWindow) {
+  onTabSelect: function(aWindow) {
     if (RunState.isRunning) {
       this._windows[aWindow.__SSi].selected = aWindow.gBrowser.tabContainer.selectedIndex;
 
       let tab = aWindow.gBrowser.selectedTab;
       // If __SS_restoreState is still on the browser and it is
       // TAB_STATE_NEEDS_RESTORE, then then we haven't restored
       // this tab yet. Explicitly call restoreTabContent to kick off the restore.
       if (tab.linkedBrowser.__SS_restoreState &&
           tab.linkedBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE)
         this.restoreTabContent(tab);
     }
   },
 
-  onTabShow: function ssi_onTabShow(aWindow, aTab) {
+  onTabShow: function(aWindow, aTab) {
     // If the tab hasn't been restored yet, move it into the right bucket
     if (aTab.linkedBrowser.__SS_restoreState &&
         aTab.linkedBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE) {
       TabRestoreQueue.hiddenToVisible(aTab);
 
       // let's kick off tab restoration again to ensure this tab gets restored
       // with "restore_hidden_tabs" == false (now that it has become visible)
       this.restoreNextTab();
     }
 
     // Default delay of 2 seconds gives enough time to catch multiple TabShow
     // events due to changing groups in Panorama.
     this.saveStateDelayed(aWindow);
   },
 
-  onTabHide: function ssi_onTabHide(aWindow, aTab) {
+  onTabHide: function(aWindow, aTab) {
     // If the tab hasn't been restored yet, move it into the right bucket
     if (aTab.linkedBrowser.__SS_restoreState &&
         aTab.linkedBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE) {
       TabRestoreQueue.visibleToHidden(aTab);
     }
 
     // Default delay of 2 seconds gives enough time to catch multiple TabHide
     // events due to changing groups in Panorama.
@@ -1515,29 +1515,29 @@ let SessionStoreInternal = {
           array.splice(i, 1);
         }
       }
     }
   },
 
   /* ........ nsISessionStore API .............. */
 
-  getBrowserState: function ssi_getBrowserState() {
+  getBrowserState: function() {
     let state = this.getCurrentState();
 
     // Don't include the last session state in getBrowserState().
     delete state.lastSessionState;
 
     // Don't include any deferred initial state.
     delete state.deferredInitialState;
 
     return this._toJSONString(state);
   },
 
-  setBrowserState: function ssi_setBrowserState(aState) {
+  setBrowserState: function(aState) {
     this._handleClosedWindows();
 
     try {
       var state = JSON.parse(aState);
     }
     catch (ex) { /* invalid state object - don't restore anything */ }
     if (!state) {
       throw Components.Exception("Invalid state string: not JSON", Cr.NS_ERROR_INVALID_ARG);
@@ -1575,48 +1575,48 @@ let SessionStoreInternal = {
     // global data must be restored before restoreWindow is called so that
     // it happens before observers are notified
     this._globalState.setFromState(state);
 
     // restore to the given state
     this.restoreWindow(window, state, {overwriteTabs: true});
   },
 
-  getWindowState: function ssi_getWindowState(aWindow) {
+  getWindowState: function(aWindow) {
     if ("__SSi" in aWindow) {
       return this._toJSONString(this._getWindowState(aWindow));
     }
 
     if (DyingWindowCache.has(aWindow)) {
       let data = DyingWindowCache.get(aWindow);
       return this._toJSONString({ windows: [data] });
     }
 
     throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
   },
 
-  setWindowState: function ssi_setWindowState(aWindow, aState, aOverwrite) {
+  setWindowState: function(aWindow, aState, aOverwrite) {
     if (!aWindow.__SSi) {
       throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
 
     this.restoreWindow(aWindow, aState, {overwriteTabs: aOverwrite});
   },
 
-  getTabState: function ssi_getTabState(aTab) {
+  getTabState: function(aTab) {
     if (!aTab.ownerDocument.defaultView.__SSi) {
       throw Components.Exception("Default view is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
 
     let tabState = TabState.collect(aTab);
 
     return this._toJSONString(tabState);
   },
 
-  setTabState: function ssi_setTabState(aTab, aState, aOptions) {
+  setTabState: function(aTab, aState, aOptions) {
     // Remove the tab state from the cache.
     // Note that we cannot simply replace the contents of the cache
     // as |aState| can be an incomplete state that will be completed
     // by |restoreTabs|.
     let tabState = JSON.parse(aState);
     if (!tabState) {
       throw Components.Exception("Invalid state string: not JSON", Cr.NS_ERROR_INVALID_ARG);
     }
@@ -1634,17 +1634,17 @@ let SessionStoreInternal = {
 
     if (aTab.linkedBrowser.__SS_restoreState) {
       this._resetTabRestoringState(aTab);
     }
 
     this.restoreTab(aTab, tabState, aOptions);
   },
 
-  duplicateTab: function ssi_duplicateTab(aWindow, aTab, aDelta = 0) {
+  duplicateTab: function(aWindow, aTab, aDelta = 0) {
     if (!aTab.ownerDocument.defaultView.__SSi) {
       throw Components.Exception("Default view is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
     if (!aWindow.getBrowser) {
       throw Components.Exception("Invalid window object: no getBrowser", Cr.NS_ERROR_INVALID_ARG);
     }
 
     // Flush all data queued in the content script because we will need that
@@ -1663,42 +1663,42 @@ let SessionStoreInternal = {
       aWindow.gBrowser.addTab();
 
     this.restoreTab(newTab, tabState, {
       restoreImmediately: true /* Load this tab right away. */
     });
     return newTab;
   },
 
-  getClosedTabCount: function ssi_getClosedTabCount(aWindow) {
+  getClosedTabCount: function(aWindow) {
     if ("__SSi" in aWindow) {
       return this._windows[aWindow.__SSi]._closedTabs.length;
     }
 
     if (!DyingWindowCache.has(aWindow)) {
       throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
 
     return DyingWindowCache.get(aWindow)._closedTabs.length;
   },
 
-  getClosedTabData: function ssi_getClosedTabDataAt(aWindow) {
+  getClosedTabData: function(aWindow) {
     if ("__SSi" in aWindow) {
       return this._toJSONString(this._windows[aWindow.__SSi]._closedTabs);
     }
 
     if (!DyingWindowCache.has(aWindow)) {
       throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
 
     let data = DyingWindowCache.get(aWindow);
     return this._toJSONString(data._closedTabs);
   },
 
-  undoCloseTab: function ssi_undoCloseTab(aWindow, aIndex) {
+  undoCloseTab: function(aWindow, aIndex) {
     if (!aWindow.__SSi) {
       throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
 
     var closedTabs = this._windows[aWindow.__SSi]._closedTabs;
 
     // default to the most-recently closed tab
     aIndex = aIndex || 0;
@@ -1721,115 +1721,115 @@ let SessionStoreInternal = {
     tabbrowser.moveTabTo(tab, closedTab.pos);
 
     // focus the tab's content area (bug 342432)
     tab.linkedBrowser.focus();
 
     return tab;
   },
 
-  forgetClosedTab: function ssi_forgetClosedTab(aWindow, aIndex) {
+  forgetClosedTab: function(aWindow, aIndex) {
     if (!aWindow.__SSi) {
       throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
 
     var closedTabs = this._windows[aWindow.__SSi]._closedTabs;
 
     // default to the most-recently closed tab
     aIndex = aIndex || 0;
     if (!(aIndex in closedTabs)) {
       throw Components.Exception("Invalid index: not in the closed tabs", Cr.NS_ERROR_INVALID_ARG);
     }
 
     // remove closed tab from the array
     closedTabs.splice(aIndex, 1);
   },
 
-  getClosedWindowCount: function ssi_getClosedWindowCount() {
+  getClosedWindowCount: function() {
     return this._closedWindows.length;
   },
 
-  getClosedWindowData: function ssi_getClosedWindowData() {
+  getClosedWindowData: function() {
     return this._toJSONString(this._closedWindows);
   },
 
-  undoCloseWindow: function ssi_undoCloseWindow(aIndex) {
+  undoCloseWindow: function(aIndex) {
     if (!(aIndex in this._closedWindows)) {
       throw Components.Exception("Invalid index: not in the closed windows", Cr.NS_ERROR_INVALID_ARG);
     }
 
     // reopen the window
     let state = { windows: this._closedWindows.splice(aIndex, 1) };
     delete state.windows[0].closedAt; // Window is now open.
 
     let window = this._openWindowWithState(state);
     this.windowToFocus = window;
     return window;
   },
 
-  forgetClosedWindow: function ssi_forgetClosedWindow(aIndex) {
+  forgetClosedWindow: function(aIndex) {
     // default to the most-recently closed window
     aIndex = aIndex || 0;
     if (!(aIndex in this._closedWindows)) {
       throw Components.Exception("Invalid index: not in the closed windows", Cr.NS_ERROR_INVALID_ARG);
     }
 
     // remove closed window from the array
     this._closedWindows.splice(aIndex, 1);
   },
 
-  getWindowValue: function ssi_getWindowValue(aWindow, aKey) {
+  getWindowValue: function(aWindow, aKey) {
     if ("__SSi" in aWindow) {
       var data = this._windows[aWindow.__SSi].extData || {};
       return data[aKey] || "";
     }
 
     if (DyingWindowCache.has(aWindow)) {
       let data = DyingWindowCache.get(aWindow).extData || {};
       return data[aKey] || "";
     }
 
     throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
   },
 
-  setWindowValue: function ssi_setWindowValue(aWindow, aKey, aStringValue) {
+  setWindowValue: function(aWindow, aKey, aStringValue) {
     if (typeof aStringValue != "string") {
       throw new TypeError("setWindowValue only accepts string values");
     }
 
     if (!("__SSi" in aWindow)) {
       throw Components.Exception("Window is not tracked", Cr.NS_ERROR_INVALID_ARG);
     }
     if (!this._windows[aWindow.__SSi].extData) {
       this._windows[aWindow.__SSi].extData = {};
     }
     this._windows[aWindow.__SSi].extData[aKey] = aStringValue;
     this.saveStateDelayed(aWindow);
   },
 
-  deleteWindowValue: function ssi_deleteWindowValue(aWindow, aKey) {
+  deleteWindowValue: function(aWindow, aKey) {
     if (aWindow.__SSi && this._windows[aWindow.__SSi].extData &&
         this._windows[aWindow.__SSi].extData[aKey])
       delete this._windows[aWindow.__SSi].extData[aKey];
     this.saveStateDelayed(aWindow);
   },
 
-  getTabValue: function ssi_getTabValue(aTab, aKey) {
+  getTabValue: function(aTab, aKey) {
     let data = {};
     if (aTab.__SS_extdata) {
       data = aTab.__SS_extdata;
     }
     else if (aTab.linkedBrowser.__SS_data && aTab.linkedBrowser.__SS_data.extData) {
       // If the tab hasn't been fully restored, get the data from the to-be-restored data
       data = aTab.linkedBrowser.__SS_data.extData;
     }
     return data[aKey] || "";
   },
 
-  setTabValue: function ssi_setTabValue(aTab, aKey, aStringValue) {
+  setTabValue: function(aTab, aKey, aStringValue) {
     if (typeof aStringValue != "string") {
       throw new TypeError("setTabValue only accepts string values");
     }
 
     // If the tab hasn't been restored, then set the data there, otherwise we
     // could lose newly added data.
     let saveTo;
     if (aTab.__SS_extdata) {
@@ -1842,17 +1842,17 @@ let SessionStoreInternal = {
       aTab.__SS_extdata = {};
       saveTo = aTab.__SS_extdata;
     }
 
     saveTo[aKey] = aStringValue;
     this.saveStateDelayed(aTab.ownerDocument.defaultView);
   },
 
-  deleteTabValue: function ssi_deleteTabValue(aTab, aKey) {
+  deleteTabValue: function(aTab, aKey) {
     // We want to make sure that if data is accessed early, we attempt to delete
     // that data from __SS_data as well. Otherwise we'll throw in cases where
     // data can be set or read.
     let deleteFrom;
     if (aTab.__SS_extdata) {
       deleteFrom = aTab.__SS_extdata;
     }
     else if (aTab.linkedBrowser.__SS_data && aTab.linkedBrowser.__SS_data.extData) {
@@ -1860,48 +1860,48 @@ let SessionStoreInternal = {
     }
 
     if (deleteFrom && aKey in deleteFrom) {
       delete deleteFrom[aKey];
       this.saveStateDelayed(aTab.ownerDocument.defaultView);
     }
   },
 
-  getGlobalValue: function ssi_getGlobalValue(aKey) {
+  getGlobalValue: function(aKey) {
     return this._globalState.get(aKey);
   },
 
-  setGlobalValue: function ssi_setGlobalValue(aKey, aStringValue) {
+  setGlobalValue: function(aKey, aStringValue) {
     if (typeof aStringValue != "string") {
       throw new TypeError("setGlobalValue only accepts string values");
     }
 
     this._globalState.set(aKey, aStringValue);
     this.saveStateDelayed();
   },
 
-  deleteGlobalValue: function ssi_deleteGlobalValue(aKey) {
+  deleteGlobalValue: function(aKey) {
     this._globalState.delete(aKey);
     this.saveStateDelayed();
   },
 
-  persistTabAttribute: function ssi_persistTabAttribute(aName) {
+  persistTabAttribute: function(aName) {
     if (TabAttributes.persist(aName)) {
       this.saveStateDelayed();
     }
   },
 
   /**
    * Restores the session state stored in LastSession. This will attempt
    * to merge data into the current session. If a window was opened at startup
    * with pinned tab(s), then the remaining data from the previous session for
    * that window will be opened into that winddow. Otherwise new windows will
    * be opened.
    */
-  restoreLastSession: function ssi_restoreLastSession() {
+  restoreLastSession: function() {
     // Use the public getter since it also checks PB mode
     if (!this.canRestoreLastSession) {
       throw Components.Exception("Last session can not be restored");
     }
 
     // First collect each window with its id...
     let windows = {};
     this._forEachBrowserWindow(function(aWindow) {
@@ -2031,17 +2031,17 @@ let SessionStoreInternal = {
    *
    * @param aWindow
    *        the window to inspect & prepare
    * @returns [canUseWindow, canOverwriteTabs]
    *          canUseWindow: can the window be used to restore into
    *          canOverwriteTabs: all of the current tabs are home pages and we
    *                            can overwrite them
    */
-  _prepWindowToRestoreInto: function ssi_prepWindowToRestoreInto(aWindow) {
+  _prepWindowToRestoreInto: function(aWindow) {
     if (!aWindow)
       return [false, false];
 
     // We might be able to overwrite the existing tabs instead of just adding
     // the previous session's tabs to the end. This will be set if possible.
     let canOverwriteTabs = false;
 
     // Step 1 of processing:
@@ -2093,17 +2093,17 @@ let SessionStoreInternal = {
 
   /* ........ Saving Functionality .............. */
 
   /**
    * Store window dimensions, visibility, sidebar
    * @param aWindow
    *        Window reference
    */
-  _updateWindowFeatures: function ssi_updateWindowFeatures(aWindow) {
+  _updateWindowFeatures: function(aWindow) {
     var winData = this._windows[aWindow.__SSi];
 
     WINDOW_ATTRIBUTES.forEach(function(aAttr) {
       winData[aAttr] = this._getWindowDimension(aWindow, aAttr);
     }, this);
 
     var hidden = WINDOW_HIDEABLE_FEATURES.filter(function(aItem) {
       return aWindow[aItem] && !aWindow[aItem].visible;
@@ -2245,31 +2245,31 @@ let SessionStoreInternal = {
   },
 
   /**
    * serialize session data for a window
    * @param aWindow
    *        Window reference
    * @returns string
    */
-  _getWindowState: function ssi_getWindowState(aWindow) {
+  _getWindowState: function(aWindow) {
     if (!this._isWindowLoaded(aWindow))
       return this._statesToRestore[aWindow.__SS_restoreID];
 
     if (RunState.isRunning) {
       this._collectWindowData(aWindow);
     }
 
     let windows = [this._windows[aWindow.__SSi]];
     SessionCookies.update(windows);
 
     return { windows: windows };
   },
 
-  _collectWindowData: function ssi_collectWindowData(aWindow) {
+  _collectWindowData: function(aWindow) {
     if (!this._isWindowLoaded(aWindow))
       return;
     TelemetryStopwatch.start("FX_SESSION_RESTORE_COLLECT_SINGLE_WINDOW_DATA_MS");
 
     let tabbrowser = aWindow.gBrowser;
     let tabs = tabbrowser.tabs;
     let winData = this._windows[aWindow.__SSi];
     let tabsData = winData.tabs = [];
@@ -2302,17 +2302,17 @@ let SessionStoreInternal = {
    *        JS object or its eval'able source
    * @param aOptions
    *        {overwriteTabs: true} to overwrite existing tabs w/ new ones
    *        {isFollowUp: true} if this is not the restoration of the 1st window
    *        {firstWindow: true} if this is the first non-private window we're
    *                            restoring in this session, that might open an
    *                            external link as well
    */
-  restoreWindow: function ssi_restoreWindow(aWindow, aState, aOptions = {}) {
+  restoreWindow: function(aWindow, aState, aOptions = {}) {
     let overwriteTabs = aOptions && aOptions.overwriteTabs;
     let isFollowUp = aOptions && aOptions.isFollowUp;
     let firstWindow = aOptions && aOptions.firstWindow;
 
     if (isFollowUp) {
       this.windowToFocus = aWindow;
     }
     // initialize window if necessary
@@ -2730,17 +2730,17 @@ let SessionStoreInternal = {
   /**
    * This _attempts_ to restore the next available tab. If the restore fails,
    * then we will attempt the next one.
    * There are conditions where this won't do anything:
    *   if we're in the process of quitting
    *   if there are no tabs to restore
    *   if we have already reached the limit for number of tabs to restore
    */
-  restoreNextTab: function ssi_restoreNextTab() {
+  restoreNextTab: function() {
     // If we call in here while quitting, we don't actually want to do anything
     if (RunState.isQuitting)
       return;
 
     // Don't exceed the maximum number of concurrent tab restores.
     if (this._tabsRestoringCount >= MAX_CONCURRENT_TAB_RESTORES)
       return;
 
@@ -2752,17 +2752,17 @@ let SessionStoreInternal = {
 
   /**
    * Restore visibility and dimension features to a window
    * @param aWindow
    *        Window reference
    * @param aWinData
    *        Object containing session data for the window
    */
-  restoreWindowFeatures: function ssi_restoreWindowFeatures(aWindow, aWinData) {
+  restoreWindowFeatures: function(aWindow, aWinData) {
     var hidden = (aWinData.hidden)?aWinData.hidden.split(","):[];
     WINDOW_HIDEABLE_FEATURES.forEach(function(aItem) {
       aWindow[aItem].visible = hidden.indexOf(aItem) == -1;
     });
 
     if (aWinData.isPopup) {
       this._windows[aWindow.__SSi].isPopup = true;
       if (aWindow.gURLBar) {
@@ -2799,17 +2799,17 @@ let SessionStoreInternal = {
    *        Window left
    * @param aTop
    *        Window top
    * @param aSizeMode
    *        Window size mode (eg: maximized)
    * @param aSidebar
    *        Sidebar command
    */
-  restoreDimensions: function ssi_restoreDimensions(aWindow, aWidth, aHeight, aLeft, aTop, aSizeMode, aSidebar) {
+  restoreDimensions: function(aWindow, aWidth, aHeight, aLeft, aTop, aSizeMode, aSidebar) {
     var win = aWindow;
     var _this = this;
     function win_(aName) { return _this._getWindowDimension(win, aName); }
 
     // find available space on the screen where this window is being placed
     let screen = gScreenManager.screenForRect(aLeft, aTop, aWidth, aHeight);
     if (screen) {
       let screenLeft = {}, screenTop = {}, screenWidth = {}, screenHeight = {};
@@ -2871,17 +2871,17 @@ let SessionStoreInternal = {
     }
   },
 
   /**
    * Restores cookies
    * @param aCookies
    *        Array of cookie objects
    */
-  restoreCookies: function ssi_restoreCookies(aCookies) {
+  restoreCookies: function(aCookies) {
     // MAX_EXPIRY should be 2^63-1, but JavaScript can't handle that precision
     var MAX_EXPIRY = Math.pow(2, 62);
     for (let i = 0; i < aCookies.length; i++) {
       var cookie = aCookies[i];
       try {
         Services.cookies.add(cookie.host, cookie.path || "", cookie.name || "",
                              cookie.value, !!cookie.secure, !!cookie.httponly, true,
                              "expiry" in cookie ? cookie.expiry : MAX_EXPIRY);
@@ -2911,17 +2911,17 @@ let SessionStoreInternal = {
 
   /**
    * Update the session start time and send a telemetry measurement
    * for the number of days elapsed since the session was started.
    *
    * @param state
    *        The session state.
    */
-  _updateSessionStartTime: function ssi_updateSessionStartTime(state) {
+  _updateSessionStartTime: function(state) {
     // Attempt to load the session start time from the session state
     if (state.session && state.session.startTime) {
       this._sessionStartTime = state.session.startTime;
 
       // ms to days
       let sessionLength = (Date.now() - this._sessionStartTime) / MS_PER_DAY;
 
       if (sessionLength > 0) {
@@ -2932,58 +2932,58 @@ let SessionStoreInternal = {
   },
 
   /**
    * call a callback for all currently opened browser windows
    * (might miss the most recent one)
    * @param aFunc
    *        Callback each window is passed to
    */
-  _forEachBrowserWindow: function ssi_forEachBrowserWindow(aFunc) {
+  _forEachBrowserWindow: function(aFunc) {
     var windowsEnum = Services.wm.getEnumerator("navigator:browser");
 
     while (windowsEnum.hasMoreElements()) {
       var window = windowsEnum.getNext();
       if (window.__SSi && !window.closed) {
         aFunc.call(this, window);
       }
     }
   },
 
   /**
    * Returns most recent window
    * @returns Window reference
    */
-  _getMostRecentBrowserWindow: function ssi_getMostRecentBrowserWindow() {
+  _getMostRecentBrowserWindow: function() {
     return RecentWindow.getMostRecentBrowserWindow({ allowPopups: true });
   },
 
   /**
    * Calls onClose for windows that are determined to be closed but aren't
    * destroyed yet, which would otherwise cause getBrowserState and
    * setBrowserState to treat them as open windows.
    */
-  _handleClosedWindows: function ssi_handleClosedWindows() {
+  _handleClosedWindows: function() {
     var windowsEnum = Services.wm.getEnumerator("navigator:browser");
 
     while (windowsEnum.hasMoreElements()) {
       var window = windowsEnum.getNext();
       if (window.closed) {
         this.onClose(window);
       }
     }
   },
 
   /**
    * open a new browser window for a given session state
    * called when restoring a multi-window session
    * @param aState
    *        Object containing session data
    */
-  _openWindowWithState: function ssi_openWindowWithState(aState) {
+  _openWindowWithState: function(aState) {
     var argString = Cc["@mozilla.org/supports-string;1"].
                     createInstance(Ci.nsISupportsString);
     argString.data = "";
 
     // Build feature string
     let features = "chrome,dialog=no,macsuppressanimation,all";
     let winState = aState.windows[0];
     WINDOW_ATTRIBUTES.forEach(function(aFeature) {
@@ -3007,28 +3007,28 @@ let SessionStoreInternal = {
 
     return window;
   },
 
   /**
    * Whether or not to resume session, if not recovering from a crash.
    * @returns bool
    */
-  _doResumeSession: function ssi_doResumeSession() {
+  _doResumeSession: function() {
     return this._prefBranch.getIntPref("startup.page") == 3 ||
            this._prefBranch.getBoolPref("sessionstore.resume_session_once");
   },
 
   /**
    * whether the user wants to load any other page at startup
    * (except the homepage) - needed for determining whether to overwrite the current tabs
    * C.f.: nsBrowserContentHandler's defaultArgs implementation.
    * @returns bool
    */
-  _isCmdLineEmpty: function ssi_isCmdLineEmpty(aWindow, aState) {
+  _isCmdLineEmpty: function(aWindow, aState) {
     var pinnedOnly = aState.windows &&
                      aState.windows.every(function (win)
                        win.tabs.every(function (tab) tab.pinned));
 
     let hasFirstArgument = aWindow.arguments && aWindow.arguments[0];
     if (!pinnedOnly) {
       let defaultArgs = Cc["@mozilla.org/browser/clh;1"].
                         getService(Ci.nsIBrowserHandler).defaultArgs;
@@ -3047,17 +3047,17 @@ let SessionStoreInternal = {
    * (and hope for reasonable values when maximized/minimized - since then
    * outerWidth/outerHeight aren't the dimensions of the restored window)
    * @param aWindow
    *        Window reference
    * @param aAttribute
    *        String sizemode | width | height | other window attribute
    * @returns string
    */
-  _getWindowDimension: function ssi_getWindowDimension(aWindow, aAttribute) {
+  _getWindowDimension: function(aWindow, aAttribute) {
     if (aAttribute == "sizemode") {
       switch (aWindow.windowState) {
       case aWindow.STATE_FULLSCREEN:
       case aWindow.STATE_MAXIMIZED:
         return "maximized";
       case aWindow.STATE_MINIMIZED:
         return "minimized";
       default:
@@ -3084,26 +3084,26 @@ let SessionStoreInternal = {
     return aWindow.document.documentElement.getAttribute(aAttribute) || dimension;
   },
 
   /**
    * Get nsIURI from string
    * @param string
    * @returns nsIURI
    */
-  _getURIFromString: function ssi_getURIFromString(aString) {
+  _getURIFromString: function(aString) {
     return Services.io.newURI(aString, null, null);
   },
 
   /**
    * @param aState is a session state
    * @param aRecentCrashes is the number of consecutive crashes
    * @returns whether a restore page will be needed for the session state
    */
-  _needsRestorePage: function ssi_needsRestorePage(aState, aRecentCrashes) {
+  _needsRestorePage: function(aState, aRecentCrashes) {
     const SIX_HOURS_IN_MS = 6 * 60 * 60 * 1000;
 
     // don't display the page when there's nothing to restore
     let winData = aState.windows || null;
     if (!winData || winData.length == 0)
       return false;
 
     // don't wrap a single about:sessionrestore page
@@ -3146,17 +3146,17 @@ let SessionStoreInternal = {
   /**
    * Determine if the tab state we're passed is something we should save. This
    * is used when closing a tab or closing a window with a single tab
    *
    * @param aTabState
    *        The current tab state
    * @returns boolean
    */
-  _shouldSaveTabState: function ssi_shouldSaveTabState(aTabState) {
+  _shouldSaveTabState: function(aTabState) {
     // If the tab has only a transient about: history entry, no other
     // session history, and no userTypedValue, then we don't actually want to
     // store this tab's data.
     return aTabState.entries.length &&
            !(aTabState.entries.length == 1 &&
                 (aTabState.entries[0].url == "about:blank" ||
                  aTabState.entries[0].url == "about:newtab" ||
                  aTabState.entries[0].url == "about:privatebrowsing") &&
@@ -3175,17 +3175,17 @@ let SessionStoreInternal = {
    * defaultState will be restored at startup. state will be passed into
    * LastSession and will be kept in case the user explicitly wants
    * to restore the previous session (publicly exposed as restoreLastSession).
    *
    * @param state
    *        The state, presumably from nsISessionStartup.state
    * @returns [defaultState, state]
    */
-  _prepDataForDeferredRestore: function ssi_prepDataForDeferredRestore(state) {
+  _prepDataForDeferredRestore: function(state) {
     // Make sure that we don't modify the global state as provided by
     // nsSessionStartup.state.
     state = Cu.cloneInto(state, {});
 
     let defaultState = { windows: [], selectedWindow: 1 };
 
     state.selectedWindow = state.selectedWindow || 1;
 
@@ -3295,21 +3295,21 @@ let SessionStoreInternal = {
    * Converts a JavaScript object into a JSON string
    * (see http://www.json.org/ for more information).
    *
    * The inverse operation consists of JSON.parse(JSON_string).
    *
    * @param aJSObject is the object to be converted
    * @returns the object's JSON representation
    */
-  _toJSONString: function ssi_toJSONString(aJSObject) {
+  _toJSONString: function(aJSObject) {
     return JSON.stringify(aJSObject);
   },
 
-  _sendRestoreCompletedNotifications: function ssi_sendRestoreCompletedNotifications() {
+  _sendRestoreCompletedNotifications: function() {
     // not all windows restored, yet
     if (this._restoreCount > 1) {
       this._restoreCount--;
       return;
     }
 
     // observers were already notified
     if (this._restoreCount == -1)
@@ -3341,96 +3341,96 @@ let SessionStoreInternal = {
       stateToRestore.busy = aValue;
     }
   },
 
   /**
    * Set the given window's state to 'not busy'.
    * @param aWindow the window
    */
-  _setWindowStateReady: function ssi_setWindowStateReady(aWindow) {
+  _setWindowStateReady: function(aWindow) {
     let newCount = (this._windowBusyStates.get(aWindow) || 0) - 1;
     if (newCount < 0) {
       throw new Error("Invalid window busy state (less than zero).");
     }
     this._windowBusyStates.set(aWindow, newCount);
 
     if (newCount == 0) {
       this._setWindowStateBusyValue(aWindow, false);
       this._sendWindowStateEvent(aWindow, "Ready");
     }
   },
 
   /**
    * Set the given window's state to 'busy'.
    * @param aWindow the window
    */
-  _setWindowStateBusy: function ssi_setWindowStateBusy(aWindow) {
+  _setWindowStateBusy: function(aWindow) {
     let newCount = (this._windowBusyStates.get(aWindow) || 0) + 1;
     this._windowBusyStates.set(aWindow, newCount);
 
     if (newCount == 1) {
       this._setWindowStateBusyValue(aWindow, true);
       this._sendWindowStateEvent(aWindow, "Busy");
     }
   },
 
   /**
    * Dispatch an SSWindowState_____ event for the given window.
    * @param aWindow the window
    * @param aType the type of event, SSWindowState will be prepended to this string
    */
-  _sendWindowStateEvent: function ssi_sendWindowStateEvent(aWindow, aType) {
+  _sendWindowStateEvent: function(aWindow, aType) {
     let event = aWindow.document.createEvent("Events");
     event.initEvent("SSWindowState" + aType, true, false);
     aWindow.dispatchEvent(event);
   },
 
   /**
    * Dispatch the SSTabRestored event for the given tab.
    * @param aTab the which has been restored
    */
-  _sendTabRestoredNotification: function ssi_sendTabRestoredNotification(aTab) {
+  _sendTabRestoredNotification: function(aTab) {
     let event = aTab.ownerDocument.createEvent("Events");
     event.initEvent("SSTabRestored", true, false);
     aTab.dispatchEvent(event);
   },
 
   /**
    * @param aWindow
    *        Window reference
    * @returns whether this window's data is still cached in _statesToRestore
    *          because it's not fully loaded yet
    */
-  _isWindowLoaded: function ssi_isWindowLoaded(aWindow) {
+  _isWindowLoaded: function(aWindow) {
     return !aWindow.__SS_restoreID;
   },
 
   /**
    * Replace "Loading..." with the tab label (with minimal side-effects)
    * @param aString is the string the title is stored in
    * @param aTabbrowser is a tabbrowser object, containing aTab
    * @param aTab is the tab whose title we're updating & using
    *
    * @returns aString that has been updated with the new title
    */
-  _replaceLoadingTitle : function ssi_replaceLoadingTitle(aString, aTabbrowser, aTab) {
+  _replaceLoadingTitle : function(aString, aTabbrowser, aTab) {
     if (aString == aTabbrowser.mStringBundle.getString("tabs.connecting")) {
       aTabbrowser.setTabTitle(aTab);
       [aString, aTab.label] = [aTab.label, aString];
     }
     return aString;
   },
 
   /**
    * Resize this._closedWindows to the value of the pref, except in the case
    * where we don't have any non-popup windows on Windows and Linux. Then we must
    * resize such that we have at least one non-popup window.
    */
-  _capClosedWindows : function ssi_capClosedWindows() {
+  _capClosedWindows : function() {
     if (this._closedWindows.length <= this._max_windows_undo)
       return;
     let spliceTo = this._max_windows_undo;
 #ifndef XP_MACOSX
     let normalWindowIndex = 0;
     // try to find a non-popup window in this._closedWindows
     while (normalWindowIndex < this._closedWindows.length &&
            !!this._closedWindows[normalWindowIndex].isPopup)
@@ -3445,26 +3445,26 @@ let SessionStoreInternal = {
    * Clears the set of windows that are "resurrected" before writing to disk to
    * make closing windows one after the other until shutdown work as expected.
    *
    * This function should only be called when we are sure that there has been
    * a user action that indicates the browser is actively being used and all
    * windows that have been closed before are not part of a series of closing
    * windows.
    */
-  _clearRestoringWindows: function ssi_clearRestoringWindows() {
+  _clearRestoringWindows: function() {
     for (let i = 0; i < this._closedWindows.length; i++) {
       delete this._closedWindows[i]._shouldRestore;
     }
   },
 
   /**
    * Reset state to prepare for a new session state to be restored.
    */
-  _resetRestoringState: function ssi_initRestoringState() {
+  _resetRestoringState: function() {
     TabRestoreQueue.reset();
     this._tabsRestoringCount = 0;
   },
 
   /**
    * Reset the restoring state for a particular tab. This will be called when
    * removing a tab or when a tab needs to be reset (it's being overwritten).
    *
diff --git a/browser/components/sessionstore/nsSessionStartup.js b/browser/components/sessionstore/nsSessionStartup.js
--- a/browser/components/sessionstore/nsSessionStartup.js
+++ b/browser/components/sessionstore/nsSessionStartup.js
@@ -89,34 +89,34 @@ SessionStartup.prototype = {
   // Stores whether the previous session crashed.
   _previousSessionCrashed: null,
 
 /* ........ Global Event Handlers .............. */
 
   /**
    * Initialize the component
    */
-  init: function sss_init() {
+  init: function() {
     Services.obs.notifyObservers(null, "sessionstore-init-started", null);
 
     // do not need to initialize anything in auto-started private browsing sessions
     if (PrivateBrowsingUtils.permanentPrivateBrowsing) {
       this._initialized = true;
       gOnceInitializedDeferred.resolve();
       return;
     }
 
     SessionFile.read().then(
       this._onSessionFileRead.bind(this),
       console.error
     );
   },
 
   // Wrap a string as a nsISupports
-  _createSupportsString: function ssfi_createSupportsString(aData) {
+  _createSupportsString: function(aData) {
     let string = Cc["@mozilla.org/supports-string;1"]
                    .createInstance(Ci.nsISupportsString);
     string.data = aData;
     return string;
   },
 
   /**
    * Complete initialization once the Session File has been read
@@ -225,17 +225,17 @@ SessionStartup.prototype = {
       Services.obs.notifyObservers(null, "sessionstore-state-finalized", "");
       gOnceInitializedDeferred.resolve();
     });
   },
 
   /**
    * Handle notifications
    */
-  observe: function sss_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
     case "app-startup":
       Services.obs.addObserver(this, "final-ui-startup", true);
       Services.obs.addObserver(this, "quit-application", true);
       break;
     case "final-ui-startup":
       Services.obs.removeObserver(this, "final-ui-startup");
       Services.obs.removeObserver(this, "quit-application");
@@ -274,17 +274,17 @@ SessionStartup.prototype = {
     return this._initialState;
   },
 
   /**
    * Determines whether there is a pending session restore. Should only be
    * called after initialization has completed.
    * @returns bool
    */
-  doRestore: function sss_doRestore() {
+  doRestore: function() {
     return this._willRestore();
   },
 
   /**
    * Determines whether automatic session restoration is enabled for this
    * launch of the browser. This does not include crash restoration. In
    * particular, if session restore is configured to restore only in case of
    * crash, this method returns false.
diff --git a/browser/components/shell/nsSetDefaultBrowser.js b/browser/components/shell/nsSetDefaultBrowser.js
--- a/browser/components/shell/nsSetDefaultBrowser.js
+++ b/browser/components/shell/nsSetDefaultBrowser.js
@@ -9,17 +9,17 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 
 function nsSetDefaultBrowser() {}
 
 nsSetDefaultBrowser.prototype = {
-  handle: function nsSetDefault_handle(aCmdline) {
+  handle: function(aCmdline) {
     if (aCmdline.handleFlag("setDefaultBrowser", false)) {
       var shell = Cc["@mozilla.org/browser/shell-service;1"].
                   getService(Ci.nsIShellService);
       shell.setDefaultBrowser(true, true);
     }
   },
 
   helpInfo: "  --setDefaultBrowser Set this app as the default browser.\n",
diff --git a/browser/components/tabview/content.js b/browser/components/tabview/content.js
--- a/browser/components/tabview/content.js
+++ b/browser/components/tabview/content.js
@@ -20,33 +20,33 @@ this.__defineGetter__("webProgress", fun
 // WindowEventHandler
 //
 // Handles events dispatched by the content window.
 let WindowEventHandler = {
   // ----------
   // Function: onDOMWillOpenModalDialog
   // Sends a synchronous message when the "onDOMWillOpenModalDialog" event
   // is fired right before a modal dialog will be opened by the current page.
-  onDOMWillOpenModalDialog: function WEH_onDOMWillOpenModalDialog(event) {
+  onDOMWillOpenModalDialog: function(event) {
     // (event.isTrusted == true) when the event is generated by a user action
     // and does not originate from a script.
     if (!event.isTrusted)
       return;
 
     // we're intentionally sending a synchronous message to handle this event
     // as quick as possible, switch the selected tab and hide the tabview
     // before the modal dialog is shown
     sendSyncMessage("Panorama:DOMWillOpenModalDialog");
   },
 
   // ----------
   // Function: onMozAfterPaint
   // Sends an asynchronous message when the "onMozAfterPaint" event
   // is fired.
-  onMozAfterPaint: function WEH_onMozAfterPaint(event) {
+  onMozAfterPaint: function(event) {
     if (event.clientRects.length > 0) {
       sendAsyncMessage("Panorama:MozAfterPaint");
     }
   }
 };
 
 // add event listeners
 addEventListener("DOMWillOpenModalDialog", WindowEventHandler.onDOMWillOpenModalDialog, false);
@@ -55,33 +55,33 @@ addEventListener("MozAfterPaint", Window
 // ----------
 // WindowMessageHandler
 //
 // Handles messages sent by the chrome process.
 let WindowMessageHandler = {
   // ----------
   // Function: isDocumentLoaded
   // Checks if the currently active document is loaded.
-  isDocumentLoaded: function WMH_isDocumentLoaded(cx) {
+  isDocumentLoaded: function(cx) {
     let isLoaded = (content.document.readyState != "uninitialized" &&
                     !webProgress.isLoadingDocument);
 
     sendAsyncMessage(cx.name, {isLoaded: isLoaded});
   },
 
   // ----------
   // Function: isImageDocument
   // Checks if the currently active document is an image document or not.
-  isImageDocument: function WMH_isImageDocument(cx) {
+  isImageDocument: function(cx) {
     let isImageDocument = (content.document instanceof Ci.nsIImageDocument);
 
     sendAsyncMessage(cx.name, {isImageDocument: isImageDocument});
   },
 
-  waitForDocumentLoad: function WMH_waitForDocumentLoad() {
+  waitForDocumentLoad: function() {
     addEventListener("load", function listener() {
       removeEventListener("load", listener, true);
       sendAsyncMessage("Panorama:documentLoaded");
     }, true);
   },
 };
 
 // add message listeners
diff --git a/browser/components/tabview/drag.js b/browser/components/tabview/drag.js
--- a/browser/components/tabview/drag.js
+++ b/browser/components/tabview/drag.js
@@ -52,34 +52,34 @@ function Drag(item, event) {
 
   Trenches.activateOthersTrenches(this.el);
 };
 
 Drag.prototype = {
   // ----------
   // Function: toString
   // Prints [Drag (item)] for debug use
-  toString: function Drag_toString() {
+  toString: function() {
     return "[Drag (" + this.item + ")]";
   },
 
   // ----------
   // Function: snapBounds
   // Adjusts the given bounds according to the currently active trenches. Used by <Drag.snap>
   //
   // Parameters:
   //   bounds             - (<Rect>) bounds
   //   stationaryCorner   - which corner is stationary? by default, the top left in LTR mode,
   //                        and top right in RTL mode.
   //                        "topleft", "bottomleft", "topright", "bottomright"
   //   assumeConstantSize - (boolean) whether the bounds' dimensions are sacred or not.
   //   keepProportional   - (boolean) if assumeConstantSize is false, whether we should resize
   //                        proportionally or not
   //   checkItemStatus    - (boolean) make sure this is a valid item which should be snapped
-  snapBounds: function Drag_snapBounds(bounds, stationaryCorner, assumeConstantSize, keepProportional, checkItemStatus) {
+  snapBounds: function(bounds, stationaryCorner, assumeConstantSize, keepProportional, checkItemStatus) {
     if (!stationaryCorner)
       stationaryCorner = UI.rtl ? 'topright' : 'topleft';
     var update = false; // need to update
     var updateX = false;
     var updateY = false;
     var newRect;
     var snappedTrenches = {};
 
@@ -132,17 +132,17 @@ Drag.prototype = {
   //
   // Parameters:
   //   stationaryCorner   - which corner is stationary? by default, the top left in LTR mode,
   //                        and top right in RTL mode.
   //                        "topleft", "bottomleft", "topright", "bottomright"
   //   assumeConstantSize - (boolean) whether the bounds' dimensions are sacred or not.
   //   keepProportional   - (boolean) if assumeConstantSize is false, whether we should resize
   //                        proportionally or not
-  snap: function Drag_snap(stationaryCorner, assumeConstantSize, keepProportional) {
+  snap: function(stationaryCorner, assumeConstantSize, keepProportional) {
     var bounds = this.item.getBounds();
     bounds = this.snapBounds(bounds, stationaryCorner, assumeConstantSize, keepProportional, true);
     if (bounds) {
       this.item.setBounds(bounds, true);
       return true;
     }
     return false;
   },
@@ -156,17 +156,17 @@ Drag.prototype = {
   // Parameters:
   //   rect - (<Rect>) current bounds of the object
   //   stationaryCorner   - which corner is stationary? by default, the top left in LTR mode,
   //                        and top right in RTL mode.
   //                        "topleft", "bottomleft", "topright", "bottomright"
   //   assumeConstantSize - (boolean) whether the rect's dimensions are sacred or not
   //   keepProportional   - (boolean) if we are allowed to change the rect's size, whether the
   //                                  dimensions should scaled proportionally or not.
-  snapToEdge: function Drag_snapToEdge(rect, stationaryCorner, assumeConstantSize, keepProportional) {
+  snapToEdge: function(rect, stationaryCorner, assumeConstantSize, keepProportional) {
 
     var swb = this.safeWindowBounds;
     var update = false;
     var updateX = false;
     var updateY = false;
     var snappedTrenches = {};
 
     var snapRadius = (Keys.meta ? 0 : Trenches.defaultRadius);
@@ -221,17 +221,17 @@ Drag.prototype = {
       return rect;
     }
     return false;
   },
 
   // ----------
   // Function: drag
   // Called in response to an <Item> draggable "drag" event.
-  drag: function Drag_drag(event) {
+  drag: function(event) {
     this.snap(UI.rtl ? 'topright' : 'topleft', true);
 
     if (this.parent && this.parent.expanded) {
       var distance = this.startPosition.distance(new Point(event.clientX, event.clientY));
       if (distance > 100) {
         this.parent.remove(this.item);
         this.parent.collapse();
       }
@@ -239,17 +239,17 @@ Drag.prototype = {
   },
 
   // ----------
   // Function: stop
   // Called in response to an <Item> draggable "stop" event.
   //
   // Parameters:
   //  immediately - bool for doing the pushAway immediately, without animation
-  stop: function Drag_stop(immediately) {
+  stop: function(immediately) {
     Trenches.hideGuides();
     this.item.isDragging = false;
 
     if (this.parent && this.parent != this.item.parent)
       this.parent.closeIfEmpty();
 
     if (this.parent && this.parent.expanded)
       this.parent.arrange();
diff --git a/browser/components/tabview/favicons.js b/browser/components/tabview/favicons.js
--- a/browser/components/tabview/favicons.js
+++ b/browser/components/tabview/favicons.js
@@ -20,42 +20,42 @@ let FavIcons = {
   // Lazy getter for pref browser.chrome.favicons.
   get _prefFavicons() {
     delete this._prefFavicons;
     this._prefFavicons = Services.prefs.getBoolPref(this.PREF_CHROME_FAVICONS);
   },
 
   get defaultFavicon() this._favIconService.defaultFavicon.spec,
 
-  init: function FavIcons_init() {
+  init: function() {
     XPCOMUtils.defineLazyServiceGetter(this, "_favIconService",
       "@mozilla.org/browser/favicon-service;1", "nsIFaviconService");
 
     Services.prefs.addObserver(this.PREF_CHROME_SITE_ICONS, this, false);
     Services.prefs.addObserver(this.PREF_CHROME_FAVICONS, this, false);
   },
 
-  uninit: function FavIcons_uninit() {
+  uninit: function() {
     Services.prefs.removeObserver(this.PREF_CHROME_SITE_ICONS, this);
     Services.prefs.removeObserver(this.PREF_CHROME_FAVICONS, this);
   },
 
-  observe: function FavIcons_observe(subject, topic, data) {
+  observe: function(subject, topic, data) {
     let value = Services.prefs.getBoolPref(data);
 
     if (data == this.PREF_CHROME_SITE_ICONS)
       this._prefSiteIcons = value;
     else if (data == this.PREF_CHROME_FAVICONS)
       this._prefFavicons = value;
   },
 
   // ----------
   // Function: getFavIconUrlForTab
   // Gets the "favicon link URI" for the given xul:tab, or null if unavailable.
-  getFavIconUrlForTab: function FavIcons_getFavIconUrlForTab(tab, callback) {
+  getFavIconUrlForTab: function(tab, callback) {
     this._isImageDocument(tab, function (isImageDoc) {
       if (isImageDoc) {
         callback(tab.pinned ? tab.image : null);
       } else {
         this._getFavIconForNonImageDocument(tab, callback);
       }
     }.bind(this));
   },
@@ -110,32 +110,32 @@ let FavIcons = {
         callback(this.defaultFavicon);
       }
     }.bind(this));
   },
 
   // ----------
   // Function: _isImageDocument
   // Checks whether an image is loaded into the given tab.
-  _isImageDocument: function UI__isImageDocument(tab, callback) {
+  _isImageDocument: function(tab, callback) {
     let mm = tab.linkedBrowser.messageManager;
     let message = "Panorama:isImageDocument";
 
     mm.addMessageListener(message, function onMessage(cx) {
       mm.removeMessageListener(cx.name, onMessage);
       callback(cx.json.isImageDocument);
     });
 
     mm.sendAsyncMessage(message);
   },
 
   // ----------
   // Function: _shouldLoadFavIcon
   // Checks whether fav icon should be loaded for a given tab.
-  _shouldLoadFavIcon: function FavIcons_shouldLoadFavIcon(tab) {
+  _shouldLoadFavIcon: function(tab) {
     // No need to load a favicon if the user doesn't want site or favicons.
     if (!this._prefSiteIcons || !this._prefFavicons)
       return false;
 
     let uri = tab.linkedBrowser.currentURI;
 
     // Stop here if we don't have a valid nsIURI.
     if (!uri || !(uri instanceof Ci.nsIURI))
diff --git a/browser/components/tabview/groupitems.js b/browser/components/tabview/groupitems.js
--- a/browser/components/tabview/groupitems.js
+++ b/browser/components/tabview/groupitems.js
@@ -241,139 +241,139 @@ function GroupItem(listOfEls, options) {
   GroupItems.updateGroupCloseButtons();
 };
 
 // ----------
 GroupItem.prototype = Utils.extend(new Item(), new Subscribable(), {
   // ----------
   // Function: toString
   // Prints [GroupItem id=id] for debug use
-  toString: function GroupItem_toString() {
+  toString: function() {
     return "[GroupItem id=" + this.id + "]";
   },
 
   // ----------
   // Variable: defaultName
   // The prompt text for the title field.
   defaultName: tabviewString('groupItem.defaultName'),
 
   // -----------
   // Function: setActiveTab
   // Sets the active <TabItem> for this groupItem; can be null, but only
   // if there are no children.
-  setActiveTab: function GroupItem_setActiveTab(tab) {
+  setActiveTab: function(tab) {
     Utils.assertThrow((!tab && this._children.length == 0) || tab.isATabItem,
         "tab must be null (if no children) or a TabItem");
 
     this._activeTab = tab;
 
     if (this.isStacked())
       this.arrange({immediately: true});
   },
 
   // -----------
   // Function: getActiveTab
   // Gets the active <TabItem> for this groupItem; can be null, but only
   // if there are no children.
-  getActiveTab: function GroupItem_getActiveTab() {
+  getActiveTab: function() {
     return this._activeTab;
   },
 
   // ----------
   // Function: getStorageData
   // Returns all of the info worth storing about this groupItem.
-  getStorageData: function GroupItem_getStorageData() {
+  getStorageData: function() {
     var data = {
       bounds: this.getBounds(),
       userSize: null,
       title: this.getTitle(),
       id: this.id
     };
 
     if (Utils.isPoint(this.userSize))
       data.userSize = new Point(this.userSize);
 
     return data;
   },
 
   // ----------
   // Function: isEmpty
   // Returns true if the tab groupItem is empty and unnamed.
-  isEmpty: function GroupItem_isEmpty() {
+  isEmpty: function() {
     return !this._children.length && !this.getTitle();
   },
 
   // ----------
   // Function: isStacked
   // Returns true if this item is in a stacked groupItem.
-  isStacked: function GroupItem_isStacked() {
+  isStacked: function() {
     return this._isStacked;
   },
 
   // ----------
   // Function: isTopOfStack
   // Returns true if the item is showing on top of this group's stack,
   // determined by whether the tab is this group's topChild, or
   // if it doesn't have one, its first child.
-  isTopOfStack: function GroupItem_isTopOfStack(item) {
+  isTopOfStack: function(item) {
     return this.isStacked() && item == this.getTopChild();
   },
 
   // ----------
   // Function: save
   // Saves this groupItem to persistent storage.
-  save: function GroupItem_save() {
+  save: function() {
     if (!this._inited || this._uninited) // too soon/late to save
       return;
 
     var data = this.getStorageData();
     if (GroupItems.groupItemStorageSanity(data))
       Storage.saveGroupItem(gWindow, data);
   },
 
   // ----------
   // Function: deleteData
   // Deletes the groupItem in the persistent storage.
-  deleteData: function GroupItem_deleteData() {
+  deleteData: function() {
     this._uninited = true;
     Storage.deleteGroupItem(gWindow, this.id);
   },
 
   // ----------
   // Function: getTitle
   // Returns the title of this groupItem as a string.
-  getTitle: function GroupItem_getTitle() {
+  getTitle: function() {
     return this.$title ? this.$title.val() : '';
   },
 
   // ----------
   // Function: setTitle
   // Sets the title of this groupItem with the given string
-  setTitle: function GroupItem_setTitle(value) {
+  setTitle: function(value) {
     this.$title.val(value);
     this.save();
   },
 
   // ----------
   // Function: focusTitle
   // Hide the title's shield and focus the underlying input field.
-  focusTitle: function GroupItem_focusTitle() {
+  focusTitle: function() {
     this.$titleShield.hide();
     this.$title[0].focus();
   },
 
   // ----------
   // Function: adjustAppTabTray
   // Used to adjust the appTabTray size, to split the appTabIcons across
   // multiple columns when needed - if the groupItem size is too small.
   //
   // Parameters:
   //   arrangeGroup - rearrange the groupItem if the number of appTab columns
   //   changes. If true, then this.arrange() is called, otherwise not.
-  adjustAppTabTray: function GroupItem_adjustAppTabTray(arrangeGroup) {
+  adjustAppTabTray: function(arrangeGroup) {
     let icons = iQ(".appTabIcon", this.$appTabTray);
     let container = iQ(this.$appTabTray[0].parentNode);
     if (!icons.length) {
       // There are no icons, so hide the appTabTray if needed.
       if (parseInt(container.css("width")) != 0) {
         this.$appTabTray.css("-moz-column-count", "auto");
         this.$appTabTray.css("height", 0);
         container.css("width", 0);
@@ -435,17 +435,17 @@ GroupItem.prototype = Utils.extend(new I
   // Function: getContentBounds
   // Returns a <Rect> for the groupItem's content area (which doesn't include the title, etc).
   //
   // Parameters:
   //   options - an object with additional parameters, see below
   //
   // Possible options:
   //   stacked - true to get content bounds for stacked mode
-  getContentBounds: function GroupItem_getContentBounds(options) {
+  getContentBounds: function(options) {
     let box = this.getBounds();
     let titleHeight = this.$titlebar.height();
     box.top += titleHeight;
     box.height -= titleHeight;
 
     let appTabTrayContainer = iQ(this.$appTabTray[0].parentNode);
     let appTabTrayWidth = appTabTrayContainer.width();
     if (appTabTrayWidth)
@@ -473,17 +473,17 @@ GroupItem.prototype = Utils.extend(new I
   //
   // Parameters:
   //   inRect - a <Rect> giving the new bounds
   //   immediately - true if it should not animate; default false
   //   options - an object with additional parameters, see below
   //
   // Possible options:
   //   force - true to always update the DOM even if the bounds haven't changed; default false
-  setBounds: function GroupItem_setBounds(inRect, immediately, options) {
+  setBounds: function(inRect, immediately, options) {
       Utils.assert(Utils.isRect(inRect), 'GroupItem.setBounds: rect is not a real rectangle!');
 
     // Validate and conform passed in size
     let validSize = GroupItems.calcValidSize(
       new Point(inRect.width, inRect.height));
     let rect = new Rect(inRect.left, inRect.top, validSize.x, validSize.y);
 
     if (!options)
@@ -557,17 +557,17 @@ GroupItem.prototype = Utils.extend(new I
     UI.clearShouldResizeItems();
     this.setTrenches(rect);
     this.save();
   },
 
   // ----------
   // Function: setZ
   // Set the Z order for the groupItem's container, as well as its children.
-  setZ: function GroupItem_setZ(value) {
+  setZ: function(value) {
     this.zIndex = value;
 
     iQ(this.container).css({zIndex: value});
 
     var count = this._children.length;
     if (count) {
       var topZIndex = value + count + 1;
       var zIndex = topZIndex;
@@ -587,17 +587,17 @@ GroupItem.prototype = Utils.extend(new I
   // Function: close
   // Closes the groupItem, removing (but not closing) all of its children.
   //
   // Parameters:
   //   options - An object with optional settings for this call.
   //
   // Options:
   //   immediately - (bool) if true, no animation will be used
-  close: function GroupItem_close(options) {
+  close: function(options) {
     this.removeAll({dontClose: true});
     GroupItems.unregister(this);
 
     // remove unfreeze event handlers, if item size is frozen
     this._unfreezeItemSize({dontArrange: true});
 
     let self = this;
     let destroyGroup = function () {
@@ -625,17 +625,17 @@ GroupItem.prototype = Utils.extend(new I
     }
 
     this.deleteData();
   },
 
   // ----------
   // Function: closeAll
   // Closes the groupItem and all of its children.
-  closeAll: function GroupItem_closeAll() {
+  closeAll: function() {
     if (this._children.length > 0) {
       this._unfreezeItemSize();
       this._children.forEach(function(child) {
         iQ(child.container).hide();
       });
 
       iQ(this.container).animate({
          opacity: 0,
@@ -655,41 +655,41 @@ GroupItem.prototype = Utils.extend(new I
 
     this._makeLastActiveGroupItemActive();
   },
   
   // ----------
   // Function: _makeClosestTabActive
   // Make the closest tab external to this group active.
   // Used when closing the group.
-  _makeClosestTabActive: function GroupItem__makeClosestTabActive() {
+  _makeClosestTabActive: function() {
     let closeCenter = this.getBounds().center();
     // Find closest tab to make active
     let closestTabItem = UI.getClosestTab(closeCenter);
     if (closestTabItem)
       UI.setActive(closestTabItem);
   },
 
   // ----------
   // Function: _makeLastActiveGroupItemActive
   // Makes the last active group item active.
-  _makeLastActiveGroupItemActive: function GroupItem__makeLastActiveGroupItemActive() {
+  _makeLastActiveGroupItemActive: function() {
     let groupItem = GroupItems.getLastActiveGroupItem();
     if (groupItem)
       UI.setActive(groupItem);
     else
       this._makeClosestTabActive();
   },
 
   // ----------
   // Function: closeIfEmpty
   // Closes the group if it's empty, is closable, and autoclose is enabled
   // (see pauseAutoclose()). Returns true if the close occurred and false
   // otherwise.
-  closeIfEmpty: function GroupItem_closeIfEmpty() {
+  closeIfEmpty: function() {
     if (this.isEmpty() && !UI._closedLastVisibleTab &&
         !GroupItems.getUnclosableGroupItemId() && !GroupItems._autoclosePaused) {
       this.close();
       return true;
     }
     return false;
   },
 
@@ -697,17 +697,17 @@ GroupItem.prototype = Utils.extend(new I
   // Function: _unhide
   // Shows the hidden group.
   //
   // Parameters:
   //   options - various options (see below)
   //
   // Possible options:
   //   immediately - true when no animations should be used
-  _unhide: function GroupItem__unhide(options) {
+  _unhide: function(options) {
     this._cancelFadeAwayUndoButtonTimer();
     this.hidden = false;
     this.$undoContainer.remove();
     this.$undoContainer = null;
     this.droppable(true);
     this.setTrenches(this.bounds);
 
     let self = this;
@@ -737,17 +737,17 @@ GroupItem.prototype = Utils.extend(new I
     }
 
     GroupItems.updateGroupCloseButtons();
   },
 
   // ----------
   // Function: closeHidden
   // Removes the group item, its children and its container.
-  closeHidden: function GroupItem_closeHidden() {
+  closeHidden: function() {
     let self = this;
 
     this._cancelFadeAwayUndoButtonTimer();
 
     // When the last non-empty groupItem is closed and there are no
     // pinned tabs then create a new group with a blank tab.
     let remainingGroups = GroupItems.groupItems.filter(function (groupItem) {
       return (groupItem != self && groupItem.getChildren().length);
@@ -786,17 +786,17 @@ GroupItem.prototype = Utils.extend(new I
   //   options - An object with optional settings for this call.
   //
   // Options:
   //   immediately - (bool) if true, no animation will be used
   //
   // Returns true if the groupItem has been closed, or false otherwise. A group
   // could not have been closed due to a tab with an onUnload handler (that
   // waits for user interaction).
-  destroy: function GroupItem_destroy(options) {
+  destroy: function(options) {
     let self = this;
 
     // when "TabClose" event is fired, the browser tab is about to close and our 
     // item "close" event is fired.  And then, the browser tab gets closed. 
     // In other words, the group "close" event is fired before all browser
     // tabs in the group are closed.  The below code would fire the group "close"
     // event only after all browser tabs in that group are closed.
     this._children.concat().forEach(function(child) {
@@ -820,17 +820,17 @@ GroupItem.prototype = Utils.extend(new I
       this.close(options);
       return true;
     }
   },
 
   // ----------
   // Function: _fadeAwayUndoButton
   // Fades away the undo button
-  _fadeAwayUndoButton: function GroupItem__fadeAwayUndoButton() {
+  _fadeAwayUndoButton: function() {
     let self = this;
 
     if (this.$undoContainer) {
       // if there is more than one group and other groups are not empty,
       // fade away the undo button.
       let shouldFadeAway = false;
 
       if (GroupItems.groupItems.length > 1) {
@@ -850,17 +850,17 @@ GroupItem.prototype = Utils.extend(new I
         });
       }
     }
   },
 
   // ----------
   // Function: _createUndoButton
   // Makes the affordance for undo a close group action
-  _createUndoButton: function GroupItem__createUndoButton() {
+  _createUndoButton: function() {
     let self = this;
     this.$undoContainer = iQ("<div/>")
       .addClass("undo")
       .attr("type", "button")
       .attr("data-group-id", this.id)
       .appendTo("body");
     iQ("<span/>")
       .text(tabviewString("groupItem.undoCloseGroup"))
@@ -915,29 +915,29 @@ GroupItem.prototype = Utils.extend(new I
       self.setupFadeAwayUndoButtonTimer();
     });
 
     GroupItems.updateGroupCloseButtons();
   },
 
   // ----------
   // Sets up fade away undo button timeout. 
-  setupFadeAwayUndoButtonTimer: function GroupItem_setupFadeAwayUndoButtonTimer() {
+  setupFadeAwayUndoButtonTimer: function() {
     let self = this;
 
     if (!this._undoButtonTimeoutId) {
       this._undoButtonTimeoutId = setTimeout(function() { 
         self._fadeAwayUndoButton(); 
       }, this.fadeAwayUndoButtonDelay);
     }
   },
   
   // ----------
   // Cancels the fade away undo button timeout. 
-  _cancelFadeAwayUndoButtonTimer: function GroupItem__cancelFadeAwayUndoButtonTimer() {
+  _cancelFadeAwayUndoButtonTimer: function() {
     clearTimeout(this._undoButtonTimeoutId);
     this._undoButtonTimeoutId = null;
   }, 
 
   // ----------
   // Function: add
   // Adds an item to the groupItem.
   // Parameters:
@@ -946,17 +946,17 @@ GroupItem.prototype = Utils.extend(new I
   //       The latter two must refer to the container of an <Item>.
   //   options - An object with optional settings for this call.
   //
   // Options:
   //
   //   index - (int) if set, add this tab at this index
   //   immediately - (bool) if true, no animation will be used
   //   dontArrange - (bool) if true, will not trigger an arrange on the group
-  add: function GroupItem_add(a, options) {
+  add: function(a, options) {
     try {
       var item;
       var $el;
       if (a.isAnItem) {
         item = a;
         $el = iQ(a.container);
       } else {
         $el = iQ(a);
@@ -1021,17 +1021,17 @@ GroupItem.prototype = Utils.extend(new I
   },
 
   // ----------
   // Function: _onChildClose
   // Handles "close" events from the group's children.
   //
   // Parameters:
   //   tabItem - The tabItem that is closed.
-  _onChildClose: function GroupItem__onChildClose(tabItem) {
+  _onChildClose: function(tabItem) {
     let count = this._children.length;
     let dontArrange = tabItem.closedManually &&
                       (this.expanded || !this.shouldStack(count));
     let dontClose = !tabItem.closedManually && gBrowser._numPinnedTabs > 0;
     this.remove(tabItem, {dontArrange: dontArrange, dontClose: dontClose});
 
     if (dontArrange)
       this._freezeItemSize(count);
@@ -1048,17 +1048,17 @@ GroupItem.prototype = Utils.extend(new I
   //   a - The item to remove. Can be an <Item>, a DOM element or an iQ object.
   //       The latter two must refer to the container of an <Item>.
   //   options - An optional object with settings for this call. See below.
   //
   // Possible options: 
   //   dontArrange - don't rearrange the remaining items
   //   dontClose - don't close the group even if it normally would
   //   immediately - don't animate
-  remove: function GroupItem_remove(a, options) {
+  remove: function(a, options) {
     try {
       let $el;
       let item;
 
       if (a.isAnItem) {
         item = a;
         $el = iQ(item.container);
       } else {
@@ -1120,17 +1120,17 @@ GroupItem.prototype = Utils.extend(new I
       Utils.log(e);
     }
   },
 
   // ----------
   // Function: removeAll
   // Removes all of the groupItem's children.
   // The optional "options" param is passed to each remove call. 
-  removeAll: function GroupItem_removeAll(options) {
+  removeAll: function(options) {
     let self = this;
     let newOptions = {dontArrange: true};
     if (options)
       Utils.extend(newOptions, options);
       
     let toRemove = this._children.concat();
     toRemove.forEach(function(child) {
       self.remove(child, newOptions);
@@ -1142,17 +1142,17 @@ GroupItem.prototype = Utils.extend(new I
   //
   // Parameters:
   //   xulTab - the xul:tab.
   //   options - change how the app tab is added.
   //
   // Options:
   //   position - the position of the app tab should be added to.
   //   dontAdjustTray - (boolean) if true, do not adjust the tray.
-  addAppTab: function GroupItem_addAppTab(xulTab, options) {
+  addAppTab: function(xulTab, options) {
     GroupItems.getAppTabFavIconUrl(xulTab, function(iconUrl) {
       // The tab might have been removed or unpinned while waiting.
       if (!Utils.isValidXULTab(xulTab) || !xulTab.pinned)
         return;
 
       let self = this;
       let $appTab = iQ("<img>")
         .addClass("appTabIcon")
@@ -1184,34 +1184,34 @@ GroupItem.prototype = Utils.extend(new I
         this.adjustAppTabTray(true);
 
       this._sendToSubscribers("appTabIconAdded", { item: $appTab });
     }.bind(this));
   },
 
   // ----------
   // Removes the given xul:tab as an app tab in this group's apptab tray
-  removeAppTab: function GroupItem_removeAppTab(xulTab) {
+  removeAppTab: function(xulTab) {
     // remove the icon
     iQ(".appTabIcon", this.$appTabTray).each(function(icon) {
       let $icon = iQ(icon);
       if ($icon.data("xulTab") != xulTab)
         return true;
         
       $icon.remove();
       return false;
     });
     
     // adjust the tray
     this.adjustAppTabTray(true);
   },
 
   // ----------
   // Arranges the given xul:tab as an app tab in the group's apptab tray
-  arrangeAppTab: function GroupItem_arrangeAppTab(xulTab) {
+  arrangeAppTab: function(xulTab) {
     let self = this;
 
     let elements = iQ(".appTabIcon", this.$appTabTray);
     let length = elements.length;
 
     elements.each(function(icon) {
       let $icon = iQ(icon);
       if ($icon.data("xulTab") != xulTab)
@@ -1228,38 +1228,38 @@ GroupItem.prototype = Utils.extend(new I
         $icon.appendTo(self.$appTabTray);
       return false;
     });
   },
 
   // ----------
   // Function: hideExpandControl
   // Hide the control which expands a stacked groupItem into a quick-look view.
-  hideExpandControl: function GroupItem_hideExpandControl() {
+  hideExpandControl: function() {
     this.$expander.hide();
   },
 
   // ----------
   // Function: showExpandControl
   // Show the control which expands a stacked groupItem into a quick-look view.
-  showExpandControl: function GroupItem_showExpandControl() {
+  showExpandControl: function() {
     let parentBB = this.getBounds();
     let childBB = this.getChild(0).getBounds();
     this.$expander
         .show()
         .css({
           left: parentBB.width/2 - this.$expander.width()/2
         });
   },
 
   // ----------
   // Function: shouldStack
   // Returns true if the groupItem, given "count", should stack (instead of 
   // grid).
-  shouldStack: function GroupItem_shouldStack(count) {
+  shouldStack: function(count) {
     let bb = this.getContentBounds();
     let options = {
       return: 'widthAndColumns',
       count: count || this._children.length,
       hideTitle: false
     };
     let arrObj = Items.arrange(this._children, bb, options);
 
@@ -1270,17 +1270,17 @@ GroupItem.prototype = Utils.extend(new I
   },
 
   // ----------
   // Function: _freezeItemSize
   // Freezes current item size (when removing a child).
   //
   // Parameters:
   //   itemCount - the number of children before the last one was removed
-  _freezeItemSize: function GroupItem__freezeItemSize(itemCount) {
+  _freezeItemSize: function(itemCount) {
     let data = this._frozenItemSizeData;
 
     if (!data.lastItemCount) {
       let self = this;
       data.lastItemCount = itemCount;
 
       // unfreeze item size when tabview is hidden
       data.onTabViewHidden = function () self._unfreezeItemSize();
@@ -1306,17 +1306,17 @@ GroupItem.prototype = Utils.extend(new I
   // Function: _unfreezeItemSize
   // Unfreezes and updates item size.
   //
   // Parameters:
   //   options - various options (see below)
   //
   // Possible options:
   //   dontArrange - do not arrange items when unfreezing
-  _unfreezeItemSize: function GroupItem__unfreezeItemSize(options) {
+  _unfreezeItemSize: function(options) {
     let data = this._frozenItemSizeData;
     if (!data.lastItemCount)
       return;
 
     if (!options || !options.dontArrange)
       this.arrange({animate: true});
 
     // unbind event listeners
@@ -1341,17 +1341,17 @@ GroupItem.prototype = Utils.extend(new I
   //                  changed
   //   dropPos - (<Point>) a position where a tab is currently positioned, above
   //             this group.
   //   animate - (boolean) if true, movement of children will be animated.
   //
   // Returns:
   //   dropIndex - an index value for where an item would be dropped, if 
   //               options.dropPos is given.
-  arrange: function GroupItem_arrange(options) {
+  arrange: function(options) {
     if (!options)
       options = {};
 
     let childrenToArrange = [];
     this._children.forEach(function(child) {
       if (child.isDragging)
         options.addTab = true;
       else
@@ -1387,17 +1387,17 @@ GroupItem.prototype = Utils.extend(new I
   //
   // Parameters:
   //   childrenToArrange - array of <TabItem> children
   //   bb - <Rect> to arrange within
   //   options - see below
   //
   // Possible "options" properties:
   //   animate - whether to animate; default: true.
-  _stackArrange: function GroupItem__stackArrange(childrenToArrange, bb, options) {
+  _stackArrange: function(childrenToArrange, bb, options) {
     if (!options)
       options = {};
     var animate = "animate" in options ? options.animate : true;
 
     var count = childrenToArrange.length;
     if (!count)
       return;
 
@@ -1476,17 +1476,17 @@ GroupItem.prototype = Utils.extend(new I
   // Possible "options" properties:
   //   animate - whether to animate; default: true.
   //   z - (int) a z-index to assign the children
   //   columns - the number of columns to use in the layout, if known in advance
   //
   // Returns:
   //   dropIndex - (int) the index at which a dragged item (if there is one) should be added
   //               if it is dropped. Otherwise (boolean) false.
-  _gridArrange: function GroupItem__gridArrange(childrenToArrange, box, options) {
+  _gridArrange: function(childrenToArrange, box, options) {
     let arrangeOptions;
     if (this.expanded) {
       // if we're expanded, we actually want to use the expanded tray's bounds.
       box = new Rect(this.expanded.bounds);
       box.inset(8, 8);
       arrangeOptions = Utils.extend({}, options, {z: 99999});
     } else {
       this._isStacked = false;
@@ -1525,17 +1525,17 @@ GroupItem.prototype = Utils.extend(new I
       if (arrangeOptions.z)
         child.setZ(arrangeOptions.z);
       index++;
     });
 
     return dropIndex;
   },
 
-  expand: function GroupItem_expand() {
+  expand: function() {
     var self = this;
     // ___ we're stacked, and command is held down so expand
     UI.setActive(this.getTopChild());
     
     var startBounds = this.getChild(0).getBounds();
     var $tray = iQ("<div>").css({
       top: startBounds.top,
       left: startBounds.left,
@@ -1572,17 +1572,17 @@ GroupItem.prototype = Utils.extend(new I
       .animate({
         width:  overlayWidth,
         height: overlayHeight,
         top: pos.top,
         left: pos.left
       }, {
         duration: 200,
         easing: "tabviewBounce",
-        complete: function GroupItem_expand_animate_complete() {
+        complete: function() {
           self._sendToSubscribers("expanded");
         }
       })
       .addClass("overlay");
 
     this._children.forEach(function(child) {
       child.addClass("stack-trayed");
       child.setHidden(false);
@@ -1616,17 +1616,17 @@ GroupItem.prototype = Utils.extend(new I
     };
 
     this.arrange();
   },
 
   // ----------
   // Function: collapse
   // Collapses the groupItem from the expanded "tray" mode.
-  collapse: function GroupItem_collapse() {
+  collapse: function() {
     if (this.expanded) {
       var z = this.getZ();
       var box = this.getBounds();
       let self = this;
       this.expanded.$tray
         .css({
           zIndex: z + 1
         })
@@ -1634,17 +1634,17 @@ GroupItem.prototype = Utils.extend(new I
           width:  box.width,
           height: box.height,
           top: box.top,
           left: box.left,
           opacity: 0
         }, {
           duration: 350,
           easing: "tabviewBounce",
-          complete: function GroupItem_collapse_animate_complete() {
+          complete: function() {
             iQ(this).remove();
             self._sendToSubscribers("collapsed");
           }
         });
 
       this.expanded.$shield.remove();
       this.expanded = null;
 
@@ -1655,17 +1655,17 @@ GroupItem.prototype = Utils.extend(new I
       this.arrange({z: z + 2});
       this._unfreezeItemSize({dontArrange: true});
     }
   },
 
   // ----------
   // Function: _addHandlers
   // Helper routine for the constructor; adds various event handlers to the container.
-  _addHandlers: function GroupItem__addHandlers(container) {
+  _addHandlers: function(container) {
     let self = this;
     let lastMouseDownTarget;
 
     container.mousedown(function(e) {
       let target = e.target;
       // only set the last mouse down target if it is a left click, not on the
       // close button, not on the expand button, not on the title bar and its
       // elements
@@ -1789,17 +1789,17 @@ GroupItem.prototype = Utils.extend(new I
     this.$expander.click(function() {
       self.expand();
     });
   },
 
   // ----------
   // Function: setResizable
   // Sets whether the groupItem is resizable and updates the UI accordingly.
-  setResizable: function GroupItem_setResizable(value, immediately) {
+  setResizable: function(value, immediately) {
     var self = this;
 
     this.resizeOptions.minWidth = GroupItems.minGroupWidth;
     this.resizeOptions.minHeight = GroupItems.minGroupHeight;
 
     let start = this.resizeOptions.start;
     this.resizeOptions.start = function (event) {
       start.call(self, event);
@@ -1818,43 +1818,43 @@ GroupItem.prototype = Utils.extend(new I
   // ----------
   // Function: newTab
   // Creates a new tab within this groupItem.
   // Parameters:
   //  url - the new tab should open this url as well
   //  options - the options object
   //    dontZoomIn - set to true to not zoom into the newly created tab
   //    closedLastTab - boolean indicates the last tab has just been closed
-  newTab: function GroupItem_newTab(url, options) {
+  newTab: function(url, options) {
     if (options && options.closedLastTab)
       UI.closedLastTabInTabView = true;
 
     UI.setActive(this, { dontSetActiveTabInGroup: true });
 
     let dontZoomIn = !!(options && options.dontZoomIn);
     return gBrowser.loadOneTab(url || gWindow.BROWSER_NEW_TAB_URL, { inBackground: dontZoomIn });
   },
 
   // ----------
   // Function: reorderTabItemsBasedOnTabOrder
   // Reorders the tabs in a groupItem based on the arrangment of the tabs
   // shown in the tab bar. It does it by sorting the children
   // of the groupItem by the positions of their respective tabs in the
   // tab bar.
-  reorderTabItemsBasedOnTabOrder: function GroupItem_reorderTabItemsBasedOnTabOrder() {
+  reorderTabItemsBasedOnTabOrder: function() {
     this._children.sort(function(a,b) a.tab._tPos - b.tab._tPos);
 
     this.arrange({animate: false});
     // this.arrange calls this.save for us
   },
 
   // Function: reorderTabsBasedOnTabItemOrder
   // Reorders the tabs in the tab bar based on the arrangment of the tabs
   // shown in the groupItem.
-  reorderTabsBasedOnTabItemOrder: function GroupItem_reorderTabsBasedOnTabItemOrder() {
+  reorderTabsBasedOnTabItemOrder: function() {
     let indices;
     let tabs = this._children.map(function (tabItem) tabItem.tab);
 
     tabs.forEach(function (tab, index) {
       if (!indices)
         indices = tabs.map(function (tab) tab._tPos);
 
       let start = index ? indices[index - 1] + 1 : 0;
@@ -1866,43 +1866,43 @@ GroupItem.prototype = Utils.extend(new I
         indices = null;
       }
     });
   },
 
   // ----------
   // Function: getTopChild
   // Gets the <Item> that should be displayed on top when in stack mode.
-  getTopChild: function GroupItem_getTopChild() {
+  getTopChild: function() {
     if (!this.getChildren().length) {
       return null;
     }
 
     return this.getActiveTab() || this.getChild(0);
   },
 
   // ----------
   // Function: getChild
   // Returns the nth child tab or null if index is out of range.
   //
   // Parameters:
   //  index - the index of the child tab to return, use negative
   //          numbers to index from the end (-1 is the last child)
-  getChild: function GroupItem_getChild(index) {
+  getChild: function(index) {
     if (index < 0)
       index = this._children.length + index;
     if (index >= this._children.length || index < 0)
       return null;
     return this._children[index];
   },
 
   // ----------
   // Function: getChildren
   // Returns all children.
-  getChildren: function GroupItem_getChildren() {
+  getChildren: function() {
     return this._children;
   }
 });
 
 // ##########
 // Class: GroupItems
 // Singleton for managing all <GroupItem>s.
 let GroupItems = {
@@ -1918,23 +1918,23 @@ let GroupItems = {
   _autoclosePaused: false,
   minGroupHeight: 110,
   minGroupWidth: 125,
   _lastActiveList: null,
 
   // ----------
   // Function: toString
   // Prints [GroupItems] for debug use
-  toString: function GroupItems_toString() {
+  toString: function() {
     return "[GroupItems count=" + this.groupItems.length + "]";
   },
 
   // ----------
   // Function: init
-  init: function GroupItems_init() {
+  init: function() {
     let self = this;
 
     // setup attr modified handler, and prepare for its uninit
     function handleAttrModified(event) {
       self._handleAttrModified(event.target);
     }
 
     // make sure any closed tabs are removed from the delay update list
@@ -1951,53 +1951,53 @@ let GroupItems = {
     this._cleanupFunctions.push(function() {
       AllTabs.unregister("attrModified", handleAttrModified);
       AllTabs.unregister("close", handleClose);
     });
   },
 
   // ----------
   // Function: uninit
-  uninit: function GroupItems_uninit() {
+  uninit: function() {
     // call our cleanup functions
     this._cleanupFunctions.forEach(function(func) {
       func();
     });
 
     this._cleanupFunctions = [];
 
     // additional clean up
     this.groupItems = null;
   },
 
   // ----------
   // Function: newGroup
   // Creates a new empty group.
-  newGroup: function GroupItems_newGroup() {
+  newGroup: function() {
     let bounds = new Rect(20, 20, 250, 200);
     return new GroupItem([], {bounds: bounds, immediately: true});
   },
 
   // ----------
   // Function: pauseArrange
   // Bypass arrange() calls and collect for resolution in
   // resumeArrange()
-  pauseArrange: function GroupItems_pauseArrange() {
+  pauseArrange: function() {
     Utils.assert(this._arrangePaused == false, 
       "pauseArrange has been called while already paused");
     Utils.assert(this._arrangesPending.length == 0, 
       "There are bypassed arrange() calls that haven't been resolved");
     this._arrangePaused = true;
   },
 
   // ----------
   // Function: pushArrange
   // Push an arrange() call and its arguments onto an array
   // to be resolved in resumeArrange()
-  pushArrange: function GroupItems_pushArrange(groupItem, options) {
+  pushArrange: function(groupItem, options) {
     Utils.assert(this._arrangePaused, 
       "Ensure pushArrange() called while arrange()s aren't paused"); 
     let i;
     for (i = 0; i < this._arrangesPending.length; i++)
       if (this._arrangesPending[i].groupItem === groupItem)
         break;
     let arrangeInfo = {
       groupItem: groupItem,
@@ -2007,154 +2007,154 @@ let GroupItems = {
       this._arrangesPending[i] = arrangeInfo;
     else
       this._arrangesPending.push(arrangeInfo);
   },
 
   // ----------
   // Function: resumeArrange
   // Resolve bypassed and collected arrange() calls
-  resumeArrange: function GroupItems_resumeArrange() {
+  resumeArrange: function() {
     this._arrangePaused = false;
     for (let i = 0; i < this._arrangesPending.length; i++) {
       let g = this._arrangesPending[i];
       g.groupItem.arrange(g.options);
     }
     this._arrangesPending = [];
   },
 
   // ----------
   // Function: _handleAttrModified
   // watch for icon changes on app tabs
-  _handleAttrModified: function GroupItems__handleAttrModified(xulTab) {
+  _handleAttrModified: function(xulTab) {
     if (!UI.isTabViewVisible()) {
       if (this._delayedModUpdates.indexOf(xulTab) == -1) {
         this._delayedModUpdates.push(xulTab);
       }
     } else
       this._updateAppTabIcons(xulTab); 
   },
 
   // ----------
   // Function: flushTabUpdates
   // Update apptab icons based on xulTabs which have been updated
   // while the TabView hasn't been visible 
-  flushAppTabUpdates: function GroupItems_flushAppTabUpdates() {
+  flushAppTabUpdates: function() {
     let self = this;
     this._delayedModUpdates.forEach(function(xulTab) {
       self._updateAppTabIcons(xulTab);
     });
     this._delayedModUpdates = [];
   },
 
   // ----------
   // Function: _updateAppTabIcons
   // Update images of any apptab icons that point to passed in xultab 
-  _updateAppTabIcons: function GroupItems__updateAppTabIcons(xulTab) {
+  _updateAppTabIcons: function(xulTab) {
     if (!xulTab.pinned)
       return;
 
     this.getAppTabFavIconUrl(xulTab, function(iconUrl) {
       iQ(".appTabIcon").each(function GroupItems__updateAppTabIcons_forEach(icon) {
          let $icon = iQ(icon);
          if ($icon.data("xulTab") == xulTab && iconUrl != $icon.attr("src"))
            $icon.attr("src", iconUrl);
       });
     });
   },
 
   // ----------
   // Function: getAppTabFavIconUrl
   // Gets the fav icon url for app tab.
-  getAppTabFavIconUrl: function GroupItems_getAppTabFavIconUrl(xulTab, callback) {
+  getAppTabFavIconUrl: function(xulTab, callback) {
     FavIcons.getFavIconUrlForTab(xulTab, function GroupItems_getAppTabFavIconUrl_getFavIconUrlForTab(iconUrl) {
       callback(iconUrl || FavIcons.defaultFavicon);
     });
   },
 
   // ----------
   // Function: addAppTab
   // Adds the given xul:tab to the app tab tray in all groups
-  addAppTab: function GroupItems_addAppTab(xulTab) {
+  addAppTab: function(xulTab) {
     this.groupItems.forEach(function(groupItem) {
       groupItem.addAppTab(xulTab);
     });
     this.updateGroupCloseButtons();
   },
 
   // ----------
   // Function: removeAppTab
   // Removes the given xul:tab from the app tab tray in all groups
-  removeAppTab: function GroupItems_removeAppTab(xulTab) {
+  removeAppTab: function(xulTab) {
     this.groupItems.forEach(function(groupItem) {
       groupItem.removeAppTab(xulTab);
     });
     this.updateGroupCloseButtons();
   },
 
   // ----------
   // Function: arrangeAppTab
   // Arranges the given xul:tab as an app tab from app tab tray in all groups
-  arrangeAppTab: function GroupItems_arrangeAppTab(xulTab) {
+  arrangeAppTab: function(xulTab) {
     this.groupItems.forEach(function(groupItem) {
       groupItem.arrangeAppTab(xulTab);
     });
   },
 
   // ----------
   // Function: getNextID
   // Returns the next unused groupItem ID.
-  getNextID: function GroupItems_getNextID() {
+  getNextID: function() {
     var result = this.nextID;
     this.nextID++;
     this._save();
     return result;
   },
 
   // ----------
   // Function: saveAll
   // Saves GroupItems state, as well as the state of all of the groupItems.
-  saveAll: function GroupItems_saveAll() {
+  saveAll: function() {
     this._save();
     this.groupItems.forEach(function(groupItem) {
       groupItem.save();
     });
   },
 
   // ----------
   // Function: _save
   // Saves GroupItems state.
-  _save: function GroupItems__save() {
+  _save: function() {
     if (!this._inited) // too soon to save now
       return;
 
     let activeGroupId = this._activeGroupItem ? this._activeGroupItem.id : null;
     Storage.saveGroupItemsData(
       gWindow,
       { nextID: this.nextID, activeGroupId: activeGroupId,
         totalNumber: this.groupItems.length });
   },
 
   // ----------
   // Function: getBoundingBox
   // Given an array of DOM elements, returns a <Rect> with (roughly) the union of their locations.
-  getBoundingBox: function GroupItems_getBoundingBox(els) {
+  getBoundingBox: function(els) {
     var bounds = [iQ(el).bounds() for each (el in els)];
     var left   = Math.min.apply({},[ b.left   for each (b in bounds) ]);
     var top    = Math.min.apply({},[ b.top    for each (b in bounds) ]);
     var right  = Math.max.apply({},[ b.right  for each (b in bounds) ]);
     var bottom = Math.max.apply({},[ b.bottom for each (b in bounds) ]);
 
     return new Rect(left, top, right-left, bottom-top);
   },
 
   // ----------
   // Function: reconstitute
   // Restores to stored state, creating groupItems as needed.
-  reconstitute: function GroupItems_reconstitute(groupItemsData, groupItemData) {
+  reconstitute: function(groupItemsData, groupItemData) {
     try {
       let activeGroupId;
 
       if (groupItemsData) {
         if (groupItemsData.nextID)
           this.nextID = Math.max(this.nextID, groupItemsData.nextID);
         if (groupItemsData.activeGroupId)
           activeGroupId = groupItemsData.activeGroupId;
@@ -2228,55 +2228,55 @@ let GroupItems = {
       Utils.log("error in recons: "+e);
     }
   },
 
   // ----------
   // Function: load
   // Loads the storage data for groups. 
   // Returns true if there was global group data.
-  load: function GroupItems_load() {
+  load: function() {
     let groupItemsData = Storage.readGroupItemsData(gWindow);
     let groupItemData = Storage.readGroupItemData(gWindow);
     this.reconstitute(groupItemsData, groupItemData);
     
     return (groupItemsData && !Utils.isEmptyObject(groupItemsData));
   },
 
   // ----------
   // Function: groupItemStorageSanity
   // Given persistent storage data for a groupItem, returns true if it appears to not be damaged.
-  groupItemStorageSanity: function GroupItems_groupItemStorageSanity(groupItemData) {
+  groupItemStorageSanity: function(groupItemData) {
     let sane = true;
     if (!groupItemData.bounds || !Utils.isRect(groupItemData.bounds)) {
       Utils.log('GroupItems.groupItemStorageSanity: bad bounds', groupItemData.bounds);
       sane = false;
     } else if ((groupItemData.userSize && 
                !Utils.isPoint(groupItemData.userSize)) ||
                !groupItemData.id) {
       sane = false;
     }
 
     return sane;
   },
 
   // ----------
   // Function: register
   // Adds the given <GroupItem> to the list of groupItems we're tracking.
-  register: function GroupItems_register(groupItem) {
+  register: function(groupItem) {
     Utils.assert(groupItem, 'groupItem');
     Utils.assert(this.groupItems.indexOf(groupItem) == -1, 'only register once per groupItem');
     this.groupItems.push(groupItem);
     UI.updateTabButton();
   },
 
   // ----------
   // Function: unregister
   // Removes the given <GroupItem> from the list of groupItems we're tracking.
-  unregister: function GroupItems_unregister(groupItem) {
+  unregister: function(groupItem) {
     var index = this.groupItems.indexOf(groupItem);
     if (index != -1)
       this.groupItems.splice(index, 1);
 
     if (groupItem == this._activeGroupItem)
       this._activeGroupItem = null;
 
     this._arrangesPending = this._arrangesPending.filter(function (pending) {
@@ -2286,44 +2286,44 @@ let GroupItems = {
     this._lastActiveList.remove(groupItem);
     UI.updateTabButton();
   },
 
   // ----------
   // Function: groupItem
   // Given some sort of identifier, returns the appropriate groupItem.
   // Currently only supports groupItem ids.
-  groupItem: function GroupItems_groupItem(a) {
+  groupItem: function(a) {
     if (!this.groupItems) {
       // uninit has been called
       return null;
     }
     var result = null;
     this.groupItems.forEach(function(candidate) {
       if (candidate.id == a)
         result = candidate;
     });
 
     return result;
   },
 
   // ----------
   // Function: removeAll
   // Removes all tabs from all groupItems (which automatically closes all unnamed groupItems).
-  removeAll: function GroupItems_removeAll() {
+  removeAll: function() {
     var toRemove = this.groupItems.concat();
     toRemove.forEach(function(groupItem) {
       groupItem.removeAll();
     });
   },
 
   // ----------
   // Function: newTab
   // Given a <TabItem>, files it in the appropriate groupItem.
-  newTab: function GroupItems_newTab(tabItem, options) {
+  newTab: function(tabItem, options) {
     let activeGroupItem = this.getActiveGroupItem();
 
     // 1. Active group
     // 2. First visible non-app tab (that's not the tab in question)
     // 3. First group
     // 4. At this point there should be no groups or tabs (except for app tabs and the
     // tab in question): make a new group
 
@@ -2373,54 +2373,54 @@ let GroupItems = {
     newGroupItem.snap();
     UI.setActive(newGroupItem);
   },
 
   // ----------
   // Function: getActiveGroupItem
   // Returns the active groupItem. Active means its tabs are
   // shown in the tab bar when not in the TabView interface.
-  getActiveGroupItem: function GroupItems_getActiveGroupItem() {
+  getActiveGroupItem: function() {
     return this._activeGroupItem;
   },
 
   // ----------
   // Function: setActiveGroupItem
   // Sets the active groupItem, thereby showing only the relevant tabs and
   // setting the groupItem which will receive new tabs.
   //
   // Paramaters:
   //  groupItem - the active <GroupItem>
-  setActiveGroupItem: function GroupItems_setActiveGroupItem(groupItem) {
+  setActiveGroupItem: function(groupItem) {
     Utils.assert(groupItem, "groupItem must be given");
 
     if (this._activeGroupItem)
       iQ(this._activeGroupItem.container).removeClass('activeGroupItem');
 
     iQ(groupItem.container).addClass('activeGroupItem');
 
     this._lastActiveList.update(groupItem);
     this._activeGroupItem = groupItem;
     this._save();
   },
 
   // ----------
   // Function: getLastActiveGroupItem
   // Gets last active group item.
   // Returns the <groupItem>. If nothing is found, return null.
-  getLastActiveGroupItem: function GroupItem_getLastActiveGroupItem() {
+  getLastActiveGroupItem: function() {
     return this._lastActiveList.peek(function(groupItem) {
       return (groupItem && !groupItem.hidden && groupItem.getChildren().length > 0)
     });
   },
 
   // ----------
   // Function: _updateTabBar
   // Hides and shows tabs in the tab bar based on the active groupItem
-  _updateTabBar: function GroupItems__updateTabBar() {
+  _updateTabBar: function() {
     if (!window.UI)
       return; // called too soon
 
     Utils.assert(this._activeGroupItem, "There must be something to show in the tab bar!");
 
     let tabItems = this._activeGroupItem._children;
     gBrowser.showOnlyTheseTabs(tabItems.map(function(item) item.tab));
   },
@@ -2439,17 +2439,17 @@ let GroupItems = {
     this._updateTabBar();
   },
 
   // ----------
   // Function: getNextGroupItemTab
   // Paramaters:
   //  reverse - the boolean indicates the direction to look for the next groupItem.
   // Returns the <tabItem>. If nothing is found, return null.
-  getNextGroupItemTab: function GroupItems_getNextGroupItemTab(reverse) {
+  getNextGroupItemTab: function(reverse) {
     var groupItems = Utils.copy(GroupItems.groupItems);
     var activeGroupItem = GroupItems.getActiveGroupItem();
     var tabItem = null;
 
     if (reverse)
       groupItems = groupItems.reverse();
 
     if (!activeGroupItem) {
@@ -2525,17 +2525,17 @@ let GroupItems = {
 
   // ----------
   // Function: moveTabToGroupItem
   // Used for the right click menu in the tab strip; moves the given tab
   // into the given group. Does nothing if the tab is an app tab.
   // Paramaters:
   //  tab - the <xul:tab>.
   //  groupItemId - the <groupItem>'s id.  If nothing, create a new <groupItem>.
-  moveTabToGroupItem : function GroupItems_moveTabToGroupItem(tab, groupItemId) {
+  moveTabToGroupItem : function(tab, groupItemId) {
     if (tab.pinned)
       return;
 
     Utils.assertThrow(tab._tabViewTabItem, "tab must be linked to a TabItem");
 
     // given tab is already contained in target group
     if (tab._tabViewTabItem.parent && tab._tabViewTabItem.parent.id == groupItemId)
       return;
@@ -2580,17 +2580,17 @@ let GroupItems = {
       this._updateTabBar();
     else if (shouldShowTabView)
       UI.showTabView();
   },
 
   // ----------
   // Function: removeHiddenGroups
   // Removes all hidden groups' data and its browser tabs.
-  removeHiddenGroups: function GroupItems_removeHiddenGroups() {
+  removeHiddenGroups: function() {
     if (this._removingHiddenGroups)
       return;
     this._removingHiddenGroups = true;
 
     let groupItems = this.groupItems.concat();
     groupItems.forEach(function(groupItem) {
       if (groupItem.hidden)
         groupItem.closeHidden();
@@ -2599,17 +2599,17 @@ let GroupItems = {
     this._removingHiddenGroups = false;
   },
 
   // ----------
   // Function: getUnclosableGroupItemId
   // If there's only one (non-hidden) group, and there are app tabs present, 
   // returns that group.
   // Return the <GroupItem>'s Id
-  getUnclosableGroupItemId: function GroupItems_getUnclosableGroupItemId() {
+  getUnclosableGroupItemId: function() {
     let unclosableGroupItemId = null;
 
     if (gBrowser._numPinnedTabs > 0) {
       let hiddenGroupItems = 
         this.groupItems.concat().filter(function(groupItem) {
           return !groupItem.hidden;
         });
       if (hiddenGroupItems.length == 1)
@@ -2617,17 +2617,17 @@ let GroupItems = {
     }
 
     return unclosableGroupItemId;
   },
 
   // ----------
   // Function: updateGroupCloseButtons
   // Updates group close buttons.
-  updateGroupCloseButtons: function GroupItems_updateGroupCloseButtons() {
+  updateGroupCloseButtons: function() {
     let unclosableGroupItemId = this.getUnclosableGroupItemId();
 
     if (unclosableGroupItemId) {
       let groupItem = this.groupItem(unclosableGroupItemId);
 
       if (groupItem) {
         groupItem.$closeButton.hide();
       }
@@ -2636,33 +2636,33 @@ let GroupItems = {
         groupItem.$closeButton.show();
       });
     }
   },
   
   // ----------
   // Function: calcValidSize
   // Basic measure rules. Assures that item is a minimum size.
-  calcValidSize: function GroupItems_calcValidSize(size, options) {
+  calcValidSize: function(size, options) {
     Utils.assert(Utils.isPoint(size), 'input is a Point');
     Utils.assert((size.x>0 || size.y>0) && (size.x!=0 && size.y!=0), 
       "dimensions are valid:"+size.x+","+size.y);
     return new Point(
       Math.max(size.x, GroupItems.minGroupWidth),
       Math.max(size.y, GroupItems.minGroupHeight));
   },
 
   // ----------
   // Function: pauseAutoclose()
   // Temporarily disable the behavior that closes groups when they become
   // empty. This is used when entering private browsing, to avoid trashing the
   // user's groups while private browsing is shuffling things around.
-  pauseAutoclose: function GroupItems_pauseAutoclose() {
+  pauseAutoclose: function() {
     this._autoclosePaused = true;
   },
 
   // ----------
   // Function: unpauseAutoclose()
   // Re-enables the auto-close behavior.
-  resumeAutoclose: function GroupItems_resumeAutoclose() {
+  resumeAutoclose: function() {
     this._autoclosePaused = false;
   }
 };
diff --git a/browser/components/tabview/iq.js b/browser/components/tabview/iq.js
--- a/browser/components/tabview/iq.js
+++ b/browser/components/tabview/iq.js
@@ -141,17 +141,17 @@ function iQClass(selector, context) {
   return ret;
 };
   
 iQClass.prototype = {
 
   // ----------
   // Function: toString
   // Prints [iQ...] for debug use
-  toString: function iQClass_toString() {
+  toString: function() {
     if (this.length > 1) {
       if (this.selector)
         return "[iQ (" + this.selector + ")]";
       else
         return "[iQ multi-object]";
     }
 
     if (this.length == 1)
@@ -164,29 +164,29 @@ iQClass.prototype = {
   selector: "",
 
   // The default length of a iQ object is 0
   length: 0,
 
   // ----------
   // Function: each
   // Execute a callback for every element in the matched set.
-  each: function iQClass_each(callback) {
+  each: function(callback) {
     if (typeof callback != "function") {
       Utils.assert(false, "each's argument must be a function");
       return null;
     }
     for (let i = 0; this[i] != null && callback(this[i]) !== false; i++) {}
     return this;
   },
 
   // ----------
   // Function: addClass
   // Adds the given class(es) to the receiver.
-  addClass: function iQClass_addClass(value) {
+  addClass: function(value) {
     Utils.assertThrow(typeof value == "string" && value,
                       'requires a valid string argument');
 
     let length = this.length;
     for (let i = 0; i < length; i++) {
       let elem = this[i];
       if (elem.nodeType === 1) {
         value.split(/\s+/).forEach(function(className) {
@@ -196,17 +196,17 @@ iQClass.prototype = {
     }
 
     return this;
   },
 
   // ----------
   // Function: removeClass
   // Removes the given class(es) from the receiver.
-  removeClass: function iQClass_removeClass(value) {
+  removeClass: function(value) {
     if (typeof value != "string" || !value) {
       Utils.assert(false, 'does not support function argument');
       return null;
     }
 
     let length = this.length;
     for (let i = 0; i < length; i++) {
       let elem = this[i];
@@ -218,31 +218,31 @@ iQClass.prototype = {
     }
 
     return this;
   },
 
   // ----------
   // Function: hasClass
   // Returns true is the receiver has the given css class.
-  hasClass: function iQClass_hasClass(singleClassName) {
+  hasClass: function(singleClassName) {
     let length = this.length;
     for (let i = 0; i < length; i++) {
       if (this[i].classList.contains(singleClassName)) {
         return true;
       }
     }
     return false;
   },
 
   // ----------
   // Function: find
   // Searches the receiver and its children, returning a new iQ object with
   // elements that match the given selector.
-  find: function iQClass_find(selector) {
+  find: function(selector) {
     let ret = [];
     let length = 0;
 
     let l = this.length;
     for (let i = 0; i < l; i++) {
       length = ret.length;
       try {
         Utils.merge(ret, this[i].querySelectorAll(selector));
@@ -264,17 +264,17 @@ iQClass.prototype = {
     }
 
     return iQ(ret);
   },
 
   // ----------
   // Function: contains
   // Check to see if a given DOM node descends from the receiver.
-  contains: function iQClass_contains(selector) {
+  contains: function(selector) {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
 
     // fast path when querySelector() can be used
     if ('string' == typeof selector)
       return null != this[0].querySelector(selector);
 
     let object = iQ(selector);
     Utils.assert(object.length <= 1, 'does not yet support multi-objects');
@@ -288,80 +288,80 @@ iQClass.prototype = {
     } while (elem && this[0] != elem);
 
     return this[0] == elem;
   },
 
   // ----------
   // Function: remove
   // Removes the receiver from the DOM.
-  remove: function iQClass_remove(options) {
+  remove: function(options) {
     if (!options || !options.preserveEventHandlers)
       this.unbindAll();
     for (let i = 0; this[i] != null; i++) {
       let elem = this[i];
       if (elem.parentNode) {
         elem.parentNode.removeChild(elem);
       }
     }
     return this;
   },
 
   // ----------
   // Function: empty
   // Removes all of the reciever's children and HTML content from the DOM.
-  empty: function iQClass_empty() {
+  empty: function() {
     for (let i = 0; this[i] != null; i++) {
       let elem = this[i];
       while (elem.firstChild) {
         iQ(elem.firstChild).unbindAll();
         elem.removeChild(elem.firstChild);
       }
     }
     return this;
   },
 
   // ----------
   // Function: width
   // Returns the width of the receiver, including padding and border.
-  width: function iQClass_width() {
+  width: function() {
     return Math.floor(this[0].offsetWidth);
   },
 
   // ----------
   // Function: height
   // Returns the height of the receiver, including padding and border.
-  height: function iQClass_height() {
+  height: function() {
     return Math.floor(this[0].offsetHeight);
   },
 
   // ----------
   // Function: position
   // Returns an object with the receiver's position in left and top
   // properties.
-  position: function iQClass_position() {
+  position: function() {
     let bounds = this.bounds();
     return new Point(bounds.left, bounds.top);
   },
 
   // ----------
   // Function: bounds
   // Returns a <Rect> with the receiver's bounds.
-  bounds: function iQClass_bounds() {
+  bounds: function() {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
     let rect = this[0].getBoundingClientRect();
     return new Rect(Math.floor(rect.left), Math.floor(rect.top),
                     Math.floor(rect.width), Math.floor(rect.height));
   },
 
   // ----------
   // Function: data
   // Pass in both key and value to attach some data to the receiver;
   // pass in just key to retrieve it.
-  data: function iQClass_data(key, value) {
+  data: function(key, value) {
     let data = null;
     if (value === undefined) {
       Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
       data = this[0].iQData;
       if (data)
         return data[key];
       else
         return null;
@@ -379,75 +379,75 @@ iQClass.prototype = {
 
     return this;
   },
 
   // ----------
   // Function: html
   // Given a value, sets the receiver's innerHTML to it; otherwise returns
   // what's already there.
-  html: function iQClass_html(value) {
+  html: function(value) {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
     if (value === undefined)
       return this[0].innerHTML;
 
     this[0].innerHTML = value;
     return this;
   },
 
   // ----------
   // Function: text
   // Given a value, sets the receiver's textContent to it; otherwise returns
   // what's already there.
-  text: function iQClass_text(value) {
+  text: function(value) {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
     if (value === undefined) {
       return this[0].textContent;
     }
 
     return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
   },
 
   // ----------
   // Function: val
   // Given a value, sets the receiver's value to it; otherwise returns what's already there.
-  val: function iQClass_val(value) {
+  val: function(value) {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
     if (value === undefined) {
       return this[0].value;
     }
 
     this[0].value = value;
     return this;
   },
 
   // ----------
   // Function: appendTo
   // Appends the receiver to the result of iQ(selector).
-  appendTo: function iQClass_appendTo(selector) {
+  appendTo: function(selector) {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
     iQ(selector).append(this);
     return this;
   },
 
   // ----------
   // Function: append
   // Appends the result of iQ(selector) to the receiver.
-  append: function iQClass_append(selector) {
+  append: function(selector) {
     let object = iQ(selector);
     Utils.assert(object.length == 1 && this.length == 1, 
         'does not yet support multi-objects (or null objects)');
     this[0].appendChild(object[0]);
     return this;
   },
 
   // ----------
   // Function: attr
   // Sets or gets an attribute on the element(s).
-  attr: function iQClass_attr(key, value) {
+  attr: function(key, value) {
     Utils.assert(typeof key === 'string', 'string key');
     if (value === undefined) {
       Utils.assert(this.length == 1, 'retrieval does not support multi-objects (or null objects)');
       return this[0].getAttribute(key);
     }
 
     for (let i = 0; this[i] != null; i++)
       this[i].setAttribute(key, value);
@@ -459,17 +459,17 @@ iQClass.prototype = {
   // Function: css
   // Sets or gets CSS properties on the receiver. When setting certain numerical properties,
   // will automatically add "px". A property can be removed by setting it to null.
   //
   // Possible call patterns:
   //   a: object, b: undefined - sets with properties from a
   //   a: string, b: undefined - gets property specified by a
   //   a: string, b: string/number - sets property specified by a to b
-  css: function iQClass_css(a, b) {
+  css: function(a, b) {
     let properties = null;
 
     if (typeof a === 'string') {
       let key = a;
       if (b === undefined) {
         Utils.assert(this.length == 1, 'retrieval does not support multi-objects (or null objects)');
 
         return window.getComputedStyle(this[0], null).getPropertyValue(key);
@@ -525,17 +525,17 @@ iQClass.prototype = {
   //   options - an object with various properites (see below)
   //
   // Possible "options" properties:
   //   duration - how long to animate, in milliseconds
   //   easing - easing function to use. Possibilities include
   //     "tabviewBounce", "easeInQuad". Default is "ease".
   //   complete - function to call once the animation is done, takes nothing
   //     in, but "this" is set to the element that was animated.
-  animate: function iQClass_animate(css, options) {
+  animate: function(css, options) {
     Utils.assert(this.length == 1, 'does not yet support multi-objects (or null objects)');
 
     if (!options)
       options = {};
 
     let easings = {
       tabviewBounce: "cubic-bezier(0.0, 0.63, .6, 1.29)", 
       easeInQuad: 'ease-in', // TODO: make it a real easeInQuad, or decide we don't care
@@ -588,17 +588,17 @@ iQClass.prototype = {
     }, duration);
 
     return this;
   },
 
   // ----------
   // Function: fadeOut
   // Animates the receiver to full transparency. Calls callback on completion.
-  fadeOut: function iQClass_fadeOut(callback) {
+  fadeOut: function(callback) {
     Utils.assert(typeof callback == "function" || callback === undefined, 
         'does not yet support duration');
 
     this.animate({
       opacity: 0
     }, {
       duration: 400,
       complete: function() {
@@ -609,48 +609,48 @@ iQClass.prototype = {
     });
 
     return this;
   },
 
   // ----------
   // Function: fadeIn
   // Animates the receiver to full opacity.
-  fadeIn: function iQClass_fadeIn() {
+  fadeIn: function() {
     this.css({display: ''});
     this.animate({
       opacity: 1
     }, {
       duration: 400
     });
 
     return this;
   },
 
   // ----------
   // Function: hide
   // Hides the receiver.
-  hide: function iQClass_hide() {
+  hide: function() {
     this.css({display: 'none', opacity: 0});
     return this;
   },
 
   // ----------
   // Function: show
   // Shows the receiver.
-  show: function iQClass_show() {
+  show: function() {
     this.css({display: '', opacity: 1});
     return this;
   },
 
   // ----------
   // Function: bind
   // Binds the given function to the given event type. Also wraps the function
   // in a try/catch block that does a Utils.log on any errors.
-  bind: function iQClass_bind(type, func) {
+  bind: function(type, func) {
     let handler = function(event) func.apply(this, [event]);
 
     for (let i = 0; this[i] != null; i++) {
       let elem = this[i];
       if (!elem.iQEventData)
         elem.iQEventData = {};
 
       if (!elem.iQEventData[type])
@@ -666,31 +666,31 @@ iQClass.prototype = {
 
     return this;
   },
 
   // ----------
   // Function: one
   // Binds the given function to the given event type, but only for one call;
   // automatically unbinds after the event fires once.
-  one: function iQClass_one(type, func) {
+  one: function(type, func) {
     Utils.assert(typeof func == "function", 'does not support eventData argument');
 
     let handler = function(e) {
       iQ(this).unbind(type, handler);
       return func.apply(this, [e]);
     };
 
     return this.bind(type, handler);
   },
 
   // ----------
   // Function: unbind
   // Unbinds the given function from the given event type.
-  unbind: function iQClass_unbind(type, func) {
+  unbind: function(type, func) {
     Utils.assert(typeof func == "function", 'Must provide a function');
 
     for (let i = 0; this[i] != null; i++) {
       let elem = this[i];
       let handler = func;
       if (elem.iQEventData && elem.iQEventData[type]) {
         let count = elem.iQEventData[type].length;
         for (let a = 0; a < count; a++) {
@@ -712,17 +712,17 @@ iQClass.prototype = {
     }
 
     return this;
   },
 
   // ----------
   // Function: unbindAll
   // Unbinds all event handlers.
-  unbindAll: function iQClass_unbindAll() {
+  unbindAll: function() {
     for (let i = 0; this[i] != null; i++) {
       let elem = this[i];
 
       for (let j = 0; j < elem.childElementCount; j++)
         iQ(elem.children[j]).unbindAll();
 
       if (!elem.iQEventData)
         continue;
diff --git a/browser/components/tabview/items.js b/browser/components/tabview/items.js
--- a/browser/components/tabview/items.js
+++ b/browser/components/tabview/items.js
@@ -84,17 +84,17 @@ function Item() {
 
 Item.prototype = {
   // ----------
   // Function: _init
   // Initializes the object. To be called from the subclass's intialization function.
   //
   // Parameters:
   //   container - the outermost DOM element that describes this item onscreen.
-  _init: function Item__init(container) {
+  _init: function(container) {
     Utils.assert(typeof this.addSubscriber == 'function' && 
         typeof this.removeSubscriber == 'function' && 
         typeof this._sendToSubscribers == 'function',
         'Subclass must implement the Subscribable interface');
     Utils.assert(Utils.isDOMElement(container), 'container must be a DOM element');
     Utils.assert(typeof this.setBounds == 'function', 'Subclass must provide setBounds');
     Utils.assert(typeof this.setZ == 'function', 'Subclass must provide setZ');
     Utils.assert(typeof this.close == 'function', 'Subclass must provide close');
@@ -146,17 +146,17 @@ Item.prototype = {
         iQ(this.container).removeClass("acceptsDrop");
       },
       drop: function(event) {
         iQ(this.container).removeClass("acceptsDrop");
       },
       // Function: dropAcceptFunction
       // Given a DOM element, returns true if it should accept tabs being dropped on it.
       // Private to this file.
-      accept: function dropAcceptFunction(item) {
+      accept: function(item) {
         return (item && item.isATabItem && (!item.parent || !item.parent.expanded));
       }
     };
 
     // ___ resize
     var self = this;
     this.resizeOptions = {
       aspectRatio: self.keepProportional,
@@ -176,25 +176,25 @@ Item.prototype = {
         resize.info = null;
       }
     };
   },
 
   // ----------
   // Function: getBounds
   // Returns a copy of the Item's bounds as a <Rect>.
-  getBounds: function Item_getBounds() {
+  getBounds: function() {
     Utils.assert(Utils.isRect(this.bounds), 'this.bounds should be a rect');
     return new Rect(this.bounds);
   },
 
   // ----------
   // Function: overlapsWithOtherItems
   // Returns true if this Item overlaps with any other Item on the screen.
-  overlapsWithOtherItems: function Item_overlapsWithOtherItems() {
+  overlapsWithOtherItems: function() {
     var self = this;
     var items = Items.getTopLevelItems();
     var bounds = this.getBounds();
     return items.some(function(item) {
       if (item == self) // can't overlap with yourself.
         return false;
       var myBounds = item.getBounds();
       return myBounds.intersects(bounds);
@@ -205,75 +205,75 @@ Item.prototype = {
   // Function: setPosition
   // Moves the Item to the specified location.
   //
   // Parameters:
   //   left - the new left coordinate relative to the window
   //   top - the new top coordinate relative to the window
   //   immediately - if false or omitted, animates to the new position;
   //   otherwise goes there immediately
-  setPosition: function Item_setPosition(left, top, immediately) {
+  setPosition: function(left, top, immediately) {
     Utils.assert(Utils.isRect(this.bounds), 'this.bounds');
     this.setBounds(new Rect(left, top, this.bounds.width, this.bounds.height), immediately);
   },
 
   // ----------
   // Function: setSize
   // Resizes the Item to the specified size.
   //
   // Parameters:
   //   width - the new width in pixels
   //   height - the new height in pixels
   //   immediately - if false or omitted, animates to the new size;
   //   otherwise resizes immediately
-  setSize: function Item_setSize(width, height, immediately) {
+  setSize: function(width, height, immediately) {
     Utils.assert(Utils.isRect(this.bounds), 'this.bounds');
     this.setBounds(new Rect(this.bounds.left, this.bounds.top, width, height), immediately);
   },
 
   // ----------
   // Function: setUserSize
   // Remembers the current size as one the user has chosen.
-  setUserSize: function Item_setUserSize() {
+  setUserSize: function() {
     Utils.assert(Utils.isRect(this.bounds), 'this.bounds');
     this.userSize = new Point(this.bounds.width, this.bounds.height);
     this.save();
   },
 
   // ----------
   // Function: getZ
   // Returns the zIndex of the Item.
-  getZ: function Item_getZ() {
+  getZ: function() {
     return this.zIndex;
   },
 
   // ----------
   // Function: setRotation
   // Rotates the object to the given number of degrees.
-  setRotation: function Item_setRotation(degrees) {
+  setRotation: function(degrees) {
     var value = degrees ? "rotate(%deg)".replace(/%/, degrees) : null;
     iQ(this.container).css({"transform": value});
   },
 
   // ----------
   // Function: setParent
   // Sets the receiver's parent to the given <Item>.
-  setParent: function Item_setParent(parent) {
+  setParent: function(parent) {
     this.parent = parent;
     this.removeTrenches();
     this.save();
   },
 
   // ----------
   // Function: pushAway
   // Pushes all other items away so none overlap this Item.
   //
   // Parameters:
   //  immediately - boolean for doing the pushAway without animation
-  pushAway: function Item_pushAway(immediately) {
+  pushAway: function(immediately) {
     var items = Items.getTopLevelItems();
 
     // we need at least two top-level items to push something away
     if (items.length < 2)
       return;
 
     var buffer = Math.floor(Items.defaultGutter / 2);
 
@@ -455,17 +455,17 @@ Item.prototype = {
         item.setBounds(bounds, immediately);
       }
     });
   },
 
   // ----------
   // Function: setTrenches
   // Sets up/moves the trenches for snapping to this item.
-  setTrenches: function Item_setTrenches(rect) {
+  setTrenches: function(rect) {
     if (this.parent !== null)
       return;
 
     if (!this.borderTrenches)
       this.borderTrenches = Trenches.registerWithItem(this,"border");
 
     var bT = this.borderTrenches;
     Trenches.getById(bT.left).setWithRect(rect);
@@ -482,49 +482,49 @@ Item.prototype = {
     Trenches.getById(gT.top).setWithRect(rect);
     Trenches.getById(gT.bottom).setWithRect(rect);
 
   },
 
   // ----------
   // Function: removeTrenches
   // Removes the trenches for snapping to this item.
-  removeTrenches: function Item_removeTrenches() {
+  removeTrenches: function() {
     for (var edge in this.borderTrenches) {
       Trenches.unregister(this.borderTrenches[edge]); // unregister can take an array
     }
     this.borderTrenches = null;
     for (var edge in this.guideTrenches) {
       Trenches.unregister(this.guideTrenches[edge]); // unregister can take an array
     }
     this.guideTrenches = null;
   },
 
   // ----------
   // Function: snap
   // The snap function used during groupItem creation via drag-out
   //
   // Parameters:
   //  immediately - bool for having the drag do the final positioning without animation
-  snap: function Item_snap(immediately) {
+  snap: function(immediately) {
     // make the snapping work with a wider range!
     var defaultRadius = Trenches.defaultRadius;
     Trenches.defaultRadius = 2 * defaultRadius; // bump up from 10 to 20!
 
     var FauxDragInfo = new Drag(this, {});
     FauxDragInfo.snap('none', false);
     FauxDragInfo.stop(immediately);
 
     Trenches.defaultRadius = defaultRadius;
   },
 
   // ----------
   // Function: draggable
   // Enables dragging on this item. Note: not to be called multiple times on the same item!
-  draggable: function Item_draggable() {
+  draggable: function() {
     try {
       Utils.assert(this.dragOptions, 'dragOptions');
 
       var cancelClasses = [];
       if (typeof this.dragOptions.cancelClass == 'string')
         cancelClasses = this.dragOptions.cancelClass.split(' ');
 
       var self = this;
@@ -682,33 +682,33 @@ Item.prototype = {
     } catch(e) {
       Utils.log(e);
     }
   },
 
   // ----------
   // Function: droppable
   // Enables or disables dropping on this item.
-  droppable: function Item_droppable(value) {
+  droppable: function(value) {
     try {
       var $container = iQ(this.container);
       if (value) {
         Utils.assert(this.dropOptions, 'dropOptions');
         $container.addClass('iq-droppable');
       } else
         $container.removeClass('iq-droppable');
     } catch(e) {
       Utils.log(e);
     }
   },
 
   // ----------
   // Function: resizable
   // Enables or disables resizing of this item.
-  resizable: function Item_resizable(value) {
+  resizable: function(value) {
     try {
       var $container = iQ(this.container);
       iQ('.iq-resizable-handle', $container).remove();
 
       if (!value) {
         $container.removeClass('iq-resizable');
       } else {
         Utils.assert(this.resizeOptions, 'resizeOptions');
@@ -799,61 +799,61 @@ Item.prototype = {
 
 // ##########
 // Class: Items
 // Keeps track of all Items.
 let Items = {
   // ----------
   // Function: toString
   // Prints [Items] for debug use
-  toString: function Items_toString() {
+  toString: function() {
     return "[Items]";
   },
 
   // ----------
   // Variable: defaultGutter
   // How far apart Items should be from each other and from bounds
   defaultGutter: 15,
 
   // ----------
   // Function: item
   // Given a DOM element representing an Item, returns the Item.
-  item: function Items_item(el) {
+  item: function(el) {
     return iQ(el).data('item');
   },
 
   // ----------
   // Function: getTopLevelItems
   // Returns an array of all Items not grouped into groupItems.
-  getTopLevelItems: function Items_getTopLevelItems() {
+  getTopLevelItems: function() {
     var items = [];
 
     iQ('.tab, .groupItem').each(function(elem) {
       var $this = iQ(elem);
       var item = $this.data('item');
       if (item && !item.parent && !$this.hasClass('phantom'))
         items.push(item);
     });
 
     return items;
   },
 
   // ----------
   // Function: getPageBounds
   // Returns a <Rect> defining the area of the page <Item>s should stay within.
-  getPageBounds: function Items_getPageBounds() {
+  getPageBounds: function() {
     var width = Math.max(100, window.innerWidth);
     var height = Math.max(100, window.innerHeight);
     return new Rect(0, 0, width, height);
   },
 
   // ----------
   // Function: getSafeWindowBounds
   // Returns the bounds within which it is safe to place all non-stationary <Item>s.
-  getSafeWindowBounds: function Items_getSafeWindowBounds() {
+  getSafeWindowBounds: function() {
     // the safe bounds that would keep it "in the window"
     var gutter = Items.defaultGutter;
     // Here, I've set the top gutter separately, as the top of the window has its own
     // extra chrome which makes a large top gutter unnecessary.
     // TODO: set top gutter separately, elsewhere.
     var topGutter = 5;
     return new Rect(gutter, topGutter,
         window.innerWidth - 2 * gutter, window.innerHeight - gutter - topGutter);
@@ -884,17 +884,17 @@ let Items = {
   //
   // Returns:
   //   By default, an object with three properties: `rects`, the list of <Rect>s,
   //   `dropIndex`, the index which a dragged tab should have if dropped
   //   (null if no `dropPos` was specified), and the number of columns (`columns`).
   //   If the `return` option is set to 'widthAndColumns', an object with the
   //   width value of the child items (`childWidth`) and the number of columns
   //   (`columns`) is returned.
-  arrange: function Items_arrange(items, bounds, options) {
+  arrange: function(items, bounds, options) {
     if (!options)
       options = {};
     var animate = "animate" in options ? options.animate : true;
     var immediately = !animate;
 
     var rects = [];
 
     var count = options.count || (items ? items.length : 0);
@@ -986,17 +986,17 @@ let Items = {
   // Function: unsquish
   // Checks to see which items can now be unsquished.
   //
   // Parameters:
   //   pairs - an array of objects, each with two properties: item and bounds. The bounds are
   //     modified as appropriate, but the items are not changed. If pairs is null, the
   //     operation is performed directly on all of the top level items.
   //   ignore - an <Item> to not include in calculations (because it's about to be closed, for instance)
-  unsquish: function Items_unsquish(pairs, ignore) {
+  unsquish: function(pairs, ignore) {
     var pairsProvided = (pairs ? true : false);
     if (!pairsProvided) {
       var items = Items.getTopLevelItems();
       pairs = [];
       items.forEach(function(item) {
         pairs.push({
           item: item,
           bounds: item.getBounds()
diff --git a/browser/components/tabview/modules/utils.jsm b/browser/components/tabview/modules/utils.jsm
--- a/browser/components/tabview/modules/utils.jsm
+++ b/browser/components/tabview/modules/utils.jsm
@@ -32,24 +32,24 @@ this.Point = function Point(a, y) {
     this.y = (Utils.isNumber(y) ? y : 0);
   }
 };
 
 Point.prototype = {
   // ----------
   // Function: toString
   // Prints [Point (x,y)] for debug use
-  toString: function Point_toString() {
+  toString: function() {
     return "[Point (" + this.x + "," + this.y + ")]";
   },
 
   // ----------
   // Function: distance
   // Returns the distance from this point to the given <Point>.
-  distance: function Point_distance(point) {
+  distance: function(point) {
     var ax = this.x - point.x;
     var ay = this.y - point.y;
     return Math.sqrt((ax * ax) + (ay * ay));
   }
 };
 
 // ##########
 // Class: Rect
@@ -74,17 +74,17 @@ this.Rect = function Rect(a, top, width,
     this.height = height;
   }
 };
 
 Rect.prototype = {
   // ----------
   // Function: toString
   // Prints [Rect (left,top,width,height)] for debug use
-  toString: function Rect_toString() {
+  toString: function() {
     return "[Rect (" + this.left + "," + this.top + "," +
             this.width + "," + this.height + ")]";
   },
 
   get right() this.left + this.width,
   set right(value) {
     this.width = value - this.left;
   },
@@ -102,93 +102,93 @@ Rect.prototype = {
   // ----------
   // Variable: yRange
   // Gives you a new <Range> for the vertical dimension.
   get yRange() new Range(this.top, this.bottom),
 
   // ----------
   // Function: intersects
   // Returns true if this rectangle intersects the given <Rect>.
-  intersects: function Rect_intersects(rect) {
+  intersects: function(rect) {
     return (rect.right > this.left &&
             rect.left < this.right &&
             rect.bottom > this.top &&
             rect.top < this.bottom);
   },
 
   // ----------
   // Function: intersection
   // Returns a new <Rect> with the intersection of this rectangle and the give <Rect>,
   // or null if they don't intersect.
-  intersection: function Rect_intersection(rect) {
+  intersection: function(rect) {
     var box = new Rect(Math.max(rect.left, this.left), Math.max(rect.top, this.top), 0, 0);
     box.right = Math.min(rect.right, this.right);
     box.bottom = Math.min(rect.bottom, this.bottom);
     if (box.width > 0 && box.height > 0)
       return box;
 
     return null;
   },
 
   // ----------
   // Function: contains
   // Returns a boolean denoting if the <Rect> or <Point> is contained inside
   // this rectangle.
   //
   // Parameters
   //  - A <Rect> or a <Point>
-  contains: function Rect_contains(a) {
+  contains: function(a) {
     if (Utils.isPoint(a))
       return (a.x > this.left &&
               a.x < this.right &&
               a.y > this.top &&
               a.y < this.bottom);
 
     return (a.left >= this.left &&
             a.right <= this.right &&
             a.top >= this.top &&
             a.bottom <= this.bottom);
   },
 
   // ----------
   // Function: center
   // Returns a new <Point> with the center location of this rectangle.
-  center: function Rect_center() {
+  center: function() {
     return new Point(this.left + (this.width / 2), this.top + (this.height / 2));
   },
 
   // ----------
   // Function: size
   // Returns a new <Point> with the dimensions of this rectangle.
-  size: function Rect_size() {
+  size: function() {
     return new Point(this.width, this.height);
   },
 
   // ----------
   // Function: position
   // Returns a new <Point> with the top left of this rectangle.
-  position: function Rect_position() {
+  position: function() {
     return new Point(this.left, this.top);
   },
 
   // ----------
   // Function: area
   // Returns the area of this rectangle.
-  area: function Rect_area() {
+  area: function() {
     return this.width * this.height;
   },
 
   // ----------
   // Function: inset
   // Makes the rect smaller (if the arguments are positive) as if a margin is added all around
   // the initial rect, with the margin widths (symmetric) being specified by the arguments.
   //
   // Paramaters
   //  - A <Point> or two arguments: x and y
-  inset: function Rect_inset(a, b) {
+  inset: function(a, b) {
     if (Utils.isPoint(a)) {
       b = a.y;
       a = a.x;
     }
 
     this.left += a;
     this.width -= a * 2;
     this.top += b;
@@ -196,53 +196,53 @@ Rect.prototype = {
   },
 
   // ----------
   // Function: offset
   // Moves (translates) the rect by the given vector.
   //
   // Paramaters
   //  - A <Point> or two arguments: x and y
-  offset: function Rect_offset(a, b) {
+  offset: function(a, b) {
     if (Utils.isPoint(a)) {
       this.left += a.x;
       this.top += a.y;
     } else {
       this.left += a;
       this.top += b;
     }
   },
 
   // ----------
   // Function: equals
   // Returns true if this rectangle is identical to the given <Rect>.
-  equals: function Rect_equals(rect) {
+  equals: function(rect) {
     return (rect.left == this.left &&
             rect.top == this.top &&
             rect.width == this.width &&
             rect.height == this.height);
   },
 
   // ----------
   // Function: union
   // Returns a new <Rect> with the union of this rectangle and the given <Rect>.
-  union: function Rect_union(a) {
+  union: function(a) {
     var newLeft = Math.min(a.left, this.left);
     var newTop = Math.min(a.top, this.top);
     var newWidth = Math.max(a.right, this.right) - newLeft;
     var newHeight = Math.max(a.bottom, this.bottom) - newTop;
     var newRect = new Rect(newLeft, newTop, newWidth, newHeight);
 
     return newRect;
   },
 
   // ----------
   // Function: copy
   // Copies the values of the given <Rect> into this rectangle.
-  copy: function Rect_copy(a) {
+  copy: function(a) {
     this.left = a.left;
     this.top = a.top;
     this.width = a.width;
     this.height = a.height;
   }
 };
 
 // ##########
@@ -260,17 +260,17 @@ this.Range = function Range(min, max) {
     this.max = max || 0;
   }
 };
 
 Range.prototype = {
   // ----------
   // Function: toString
   // Prints [Range (min,max)] for debug use
-  toString: function Range_toString() {
+  toString: function() {
     return "[Range (" + this.min + "," + this.max + ")]";
   },
 
   // Variable: extent
   // Equivalent to max-min
   get extent() {
     return (this.max - this.min);
   },
@@ -280,47 +280,47 @@ Range.prototype = {
   },
 
   // ----------
   // Function: contains
   // Whether the <Range> contains the given <Range> or value or not.
   //
   // Parameters
   //  - a number or <Range>
-  contains: function Range_contains(value) {
+  contains: function(value) {
     if (Utils.isNumber(value))
       return value >= this.min && value <= this.max;
     if (Utils.isRange(value))
       return value.min >= this.min && value.max <= this.max;
     return false;
   },
 
   // ----------
   // Function: overlaps
   // Whether the <Range> overlaps with the given <Range> value or not.
   //
   // Parameters
   //  - a number or <Range>
-  overlaps: function Range_overlaps(value) {
+  overlaps: function(value) {
     if (Utils.isNumber(value))
       return this.contains(value);
     if (Utils.isRange(value))
       return !(value.max < this.min || this.max < value.min);
     return false;
   },
 
   // ----------
   // Function: proportion
   // Maps the given value to the range [0,1], so that it returns 0 if the value is <= the min,
   // returns 1 if the value >= the max, and returns an interpolated "proportion" in (min, max).
   //
   // Parameters
   //  - a number
   //  - (bool) smooth? If true, a smooth tanh-based function will be used instead of the linear.
-  proportion: function Range_proportion(value, smooth) {
+  proportion: function(value, smooth) {
     if (value <= this.min)
       return 0;
     if (this.max <= value)
       return 1;
 
     var proportion = (value - this.min) / this.extent;
 
     if (smooth) {
@@ -340,17 +340,17 @@ Range.prototype = {
   },
 
   // ----------
   // Function: scale
   // Takes the given value in [0,1] and maps it to the associated value on the Range.
   //
   // Parameters
   //  - a number in [0,1]
-  scale: function Range_scale(value) {
+  scale: function(value) {
     if (value > 1)
       value = 1;
     if (value < 0)
       value = 0;
     return this.min + this.extent * value;
   }
 };
 
@@ -360,17 +360,17 @@ Range.prototype = {
 this.Subscribable = function Subscribable() {
   this.subscribers = null;
 };
 
 Subscribable.prototype = {
   // ----------
   // Function: addSubscriber
   // The given callback will be called when the Subscribable fires the given event.
-  addSubscriber: function Subscribable_addSubscriber(eventName, callback) {
+  addSubscriber: function(eventName, callback) {
     try {
       Utils.assertThrow(typeof callback == "function", "callback must be a function");
       Utils.assertThrow(eventName && typeof eventName == "string",
           "eventName must be a non-empty string");
     } catch(e) {
       Utils.log(e);
       return;
     }
@@ -384,17 +384,17 @@ Subscribable.prototype = {
     let subscribers = this.subscribers[eventName];
     if (subscribers.indexOf(callback) == -1)
       subscribers.push(callback);
   },
 
   // ----------
   // Function: removeSubscriber
   // Removes the subscriber associated with the event for the given callback.
-  removeSubscriber: function Subscribable_removeSubscriber(eventName, callback) {
+  removeSubscriber: function(eventName, callback) {
     try {
       Utils.assertThrow(typeof callback == "function", "callback must be a function");
       Utils.assertThrow(eventName && typeof eventName == "string",
           "eventName must be a non-empty string");
     } catch(e) {
       Utils.log(e);
       return;
     }
@@ -407,17 +407,17 @@ Subscribable.prototype = {
 
     if (index > -1)
       subscribers.splice(index, 1);
   },
 
   // ----------
   // Function: _sendToSubscribers
   // Internal routine. Used by the Subscribable to fire events.
-  _sendToSubscribers: function Subscribable__sendToSubscribers(eventName, eventInfo) {
+  _sendToSubscribers: function(eventName, eventInfo) {
     try {
       Utils.assertThrow(eventName && typeof eventName == "string",
           "eventName must be a non-empty string");
     } catch(e) {
       Utils.log(e);
       return;
     }
 
@@ -437,87 +437,87 @@ Subscribable.prototype = {
 
 // ##########
 // Class: Utils
 // Singelton with common utility functions.
 this.Utils = {
   // ----------
   // Function: toString
   // Prints [Utils] for debug use
-  toString: function Utils_toString() {
+  toString: function() {
     return "[Utils]";
   },
 
   // ___ Logging
   useConsole: true, // as opposed to dump
   showTime: false,
 
   // ----------
   // Function: log
   // Prints the given arguments to the JavaScript error console as a message.
   // Pass as many arguments as you want, it'll print them all.
-  log: function Utils_log() {
+  log: function() {
     var text = this.expandArgumentsForLog(arguments);
     var prefix = this.showTime ? Date.now() + ': ' : '';
     if (this.useConsole)    
       Services.console.logStringMessage(prefix + text);
     else
       dump(prefix + text + '\n');
   },
 
   // ----------
   // Function: error
   // Prints the given arguments to the JavaScript error console as an error.
   // Pass as many arguments as you want, it'll print them all.
-  error: function Utils_error() {
+  error: function() {
     var text = this.expandArgumentsForLog(arguments);
     var prefix = this.showTime ? Date.now() + ': ' : '';
     if (this.useConsole)    
       Cu.reportError(prefix + "tabview error: " + text);
     else
       dump(prefix + "TABVIEW ERROR: " + text + '\n');
   },
 
   // ----------
   // Function: trace
   // Prints the given arguments to the JavaScript error console as a message,
   // along with a full stack trace.
   // Pass as many arguments as you want, it'll print them all.
-  trace: function Utils_trace() {
+  trace: function() {
     var text = this.expandArgumentsForLog(arguments);
 
     // cut off the first line of the stack trace, because that's just this function.
     let stack = Error().stack.split("\n").slice(1);
 
     // if the caller was assert, cut out the line for the assert function as well.
     if (stack[0].indexOf("Utils_assert(") == 0)
       stack.splice(0, 1);
 
     this.log('trace: ' + text + '\n' + stack.join("\n"));
   },
 
   // ----------
   // Function: assert
   // Prints a stack trace along with label (as a console message) if condition is false.
-  assert: function Utils_assert(condition, label) {
+  assert: function(condition, label) {
     if (!condition) {
       let text;
       if (typeof label != 'string')
         text = 'badly formed assert';
       else
         text = "tabview assert: " + label;
 
       this.trace(text);
     }
   },
 
   // ----------
   // Function: assertThrow
   // Throws label as an exception if condition is false.
-  assertThrow: function Utils_assertThrow(condition, label) {
+  assertThrow: function(condition, label) {
     if (!condition) {
       let text;
       if (typeof label != 'string')
         text = 'badly formed assert';
       else
         text = "tabview assert: " + label;
 
       // cut off the first line of the stack trace, because that's just this function.
@@ -525,17 +525,17 @@ this.Utils = {
 
       throw text + "\n" + stack.join("\n");
     }
   },
 
   // ----------
   // Function: expandObject
   // Prints the given object to a string, including all of its properties.
-  expandObject: function Utils_expandObject(obj) {
+  expandObject: function(obj) {
     var s = obj + ' = {';
     for (let prop in obj) {
       let value;
       try {
         value = obj[prop];
       } catch(e) {
         value = '[!!error retrieving property]';
       }
@@ -551,100 +551,100 @@ this.Utils = {
       s += ', ';
     }
     return s + '}';
   },
 
   // ----------
   // Function: expandArgumentsForLog
   // Expands all of the given args (an array) into a single string.
-  expandArgumentsForLog: function Utils_expandArgumentsForLog(args) {
+  expandArgumentsForLog: function(args) {
     var that = this;
     return Array.map(args, function(arg) {
       return typeof arg == 'object' ? that.expandObject(arg) : arg;
     }).join('; ');
   },
 
   // ___ Misc
 
   // ----------
   // Function: isLeftClick
   // Given a DOM mouse event, returns true if it was for the left mouse button.
-  isLeftClick: function Utils_isLeftClick(event) {
+  isLeftClick: function(event) {
     return event.button == 0;
   },
 
   // ----------
   // Function: isMiddleClick
   // Given a DOM mouse event, returns true if it was for the middle mouse button.
-  isMiddleClick: function Utils_isMiddleClick(event) {
+  isMiddleClick: function(event) {
     return event.button == 1;
   },
 
   // ----------
   // Function: isRightClick
   // Given a DOM mouse event, returns true if it was for the right mouse button.
-  isRightClick: function Utils_isRightClick(event) {
+  isRightClick: function(event) {
     return event.button == 2;
   },
 
   // ----------
   // Function: isDOMElement
   // Returns true if the given object is a DOM element.
-  isDOMElement: function Utils_isDOMElement(object) {
+  isDOMElement: function(object) {
     return object instanceof Ci.nsIDOMElement;
   },
 
   // ----------
   // Function: isValidXULTab
   // A xulTab is valid if it has not been closed,
   // and it has not been removed from the DOM
   // Returns true if the tab is valid.
-  isValidXULTab: function Utils_isValidXULTab(xulTab) {
+  isValidXULTab: function(xulTab) {
     return !xulTab.closing && xulTab.parentNode;
   },
 
   // ----------
   // Function: isNumber
   // Returns true if the argument is a valid number.
-  isNumber: function Utils_isNumber(n) {
+  isNumber: function(n) {
     return typeof n == 'number' && !isNaN(n);
   },
 
   // ----------
   // Function: isRect
   // Returns true if the given object (r) looks like a <Rect>.
-  isRect: function Utils_isRect(r) {
+  isRect: function(r) {
     return (r &&
             this.isNumber(r.left) &&
             this.isNumber(r.top) &&
             this.isNumber(r.width) &&
             this.isNumber(r.height));
   },
 
   // ----------
   // Function: isRange
   // Returns true if the given object (r) looks like a <Range>.
-  isRange: function Utils_isRange(r) {
+  isRange: function(r) {
     return (r &&
             this.isNumber(r.min) &&
             this.isNumber(r.max));
   },
 
   // ----------
   // Function: isPoint
   // Returns true if the given object (p) looks like a <Point>.
-  isPoint: function Utils_isPoint(p) {
+  isPoint: function(p) {
     return (p && this.isNumber(p.x) && this.isNumber(p.y));
   },
 
   // ----------
   // Function: isPlainObject
   // Check to see if an object is a plain object (created using "{}" or "new Object").
-  isPlainObject: function Utils_isPlainObject(obj) {
+  isPlainObject: function(obj) {
     // Must be an Object.
     // Make sure that DOM nodes and window objects don't pass through, as well
     if (!obj || Object.prototype.toString.call(obj) !== "[object Object]" ||
        obj.nodeType || obj.setInterval) {
       return false;
     }
 
     // Not own constructor property must be Object
@@ -663,47 +663,47 @@ this.Utils = {
     for (key in obj) {}
 
     return key === undefined || hasOwnProperty.call(obj, key);
   },
 
   // ----------
   // Function: isEmptyObject
   // Returns true if the given object has no members.
-  isEmptyObject: function Utils_isEmptyObject(obj) {
+  isEmptyObject: function(obj) {
     for (let name in obj)
       return false;
     return true;
   },
 
   // ----------
   // Function: copy
   // Returns a copy of the argument. Note that this is a shallow copy; if the argument
   // has properties that are themselves objects, those properties will be copied by reference.
-  copy: function Utils_copy(value) {
+  copy: function(value) {
     if (value && typeof value == 'object') {
       if (Array.isArray(value))
         return this.extend([], value);
       return this.extend({}, value);
     }
     return value;
   },
 
   // ----------
   // Function: merge
   // Merge two array-like objects into the first and return it.
-  merge: function Utils_merge(first, second) {
+  merge: function(first, second) {
     Array.forEach(second, function(el) Array.push(first, el));
     return first;
   },
 
   // ----------
   // Function: extend
   // Pass several objects in and it will combine them all into the first object and return it.
-  extend: function Utils_extend() {
+  extend: function() {
 
     // copy reference to target object
     let target = arguments[0] || {};
     // Deep copy is not supported
     if (typeof target === "boolean") {
       this.assert(false, "The first argument of extend cannot be a boolean." +
           "Deep copy is not supported.");
       return target;
@@ -744,17 +744,17 @@ this.Utils = {
     return target;
   },
 
   // ----------
   // Function: attempt
   // Tries to execute a number of functions. Returns immediately the return
   // value of the first non-failed function without executing successive
   // functions, or null.
-  attempt: function Utils_attempt() {
+  attempt: function() {
     let args = arguments;
 
     for (let i = 0; i < args.length; i++) {
       try {
         return args[i]();
       } catch (e) {}
     }
 
@@ -774,42 +774,42 @@ this.MRUList = function MRUList(a) {
   else
     this._list = [];
 };
 
 MRUList.prototype = {
   // ----------
   // Function: toString
   // Prints [List (entry1, entry2, ...)] for debug use
-  toString: function MRUList_toString() {
+  toString: function() {
     return "[List (" + this._list.join(", ") + ")]";
   },
 
   // ----------
   // Function: update
   // Updates/inserts the given entry as the most recently used one in the list.
-  update: function MRUList_update(entry) {
+  update: function(entry) {
     this.remove(entry);
     this._list.unshift(entry);
   },
 
   // ----------
   // Function: remove
   // Removes the given entry from the list.
-  remove: function MRUList_remove(entry) {
+  remove: function(entry) {
     let index = this._list.indexOf(entry);
     if (index > -1)
       this._list.splice(index, 1);
   },
 
   // ----------
   // Function: peek
   // Returns the most recently used entry.  If a filter exists, gets the most 
   // recently used entry which matches the filter.
-  peek: function MRUList_peek(filter) {
+  peek: function(filter) {
     let match = null;
     if (filter && typeof filter == "function")
       this._list.some(function MRUList_peek_getEntry(entry) {
         if (filter(entry)) {
           match = entry
           return true;
         }
         return false;
diff --git a/browser/components/tabview/search.js b/browser/components/tabview/search.js
--- a/browser/components/tabview/search.js
+++ b/browser/components/tabview/search.js
@@ -23,53 +23,53 @@
 // Class: TabUtils
 //
 // A collection of helper functions for dealing with both <TabItem>s and
 // <xul:tab>s without having to worry which one is which.
 let TabUtils = {
   // ----------
   // Function: toString
   // Prints [TabUtils] for debug use.
-  toString: function TabUtils_toString() {
+  toString: function() {
     return "[TabUtils]";
   },
 
   // ---------
   // Function: nameOfTab
   // Given a <TabItem> or a <xul:tab> returns the tab's name.
-  nameOf: function TabUtils_nameOf(tab) {
+  nameOf: function(tab) {
     // We can have two types of tabs: A <TabItem> or a <xul:tab>
     // because we have to deal with both tabs represented inside
     // of active Panoramas as well as for windows in which
     // Panorama has yet to be activated. We uses object sniffing to
     // determine the type of tab and then returns its name.     
     return tab.label != undefined ? tab.label : tab.$tabTitle[0].textContent;
   },
 
   // ---------
   // Function: URLOf
   // Given a <TabItem> or a <xul:tab> returns the URL of tab.
-  URLOf: function TabUtils_URLOf(tab) {
+  URLOf: function(tab) {
     // Convert a <TabItem> to <xul:tab>
     if ("tab" in tab)
       tab = tab.tab;
     return tab.linkedBrowser.currentURI.spec;
   },
 
   // ---------
   // Function: faviconURLOf
   // Given a <TabItem> or a <xul:tab> returns the URL of tab's favicon.
-  faviconURLOf: function TabUtils_faviconURLOf(tab) {
+  faviconURLOf: function(tab) {
     return tab.image != undefined ? tab.image : tab.$favImage[0].src;
   },
 
   // ---------
   // Function: focus
   // Given a <TabItem> or a <xul:tab>, focuses it and it's window.
-  focus: function TabUtils_focus(tab) {
+  focus: function(tab) {
     // Convert a <TabItem> to a <xul:tab>
     if ("tab" in tab)
       tab = tab.tab;
     tab.ownerDocument.defaultView.gBrowser.selectedTab = tab;
     tab.ownerDocument.defaultView.focus();
   }
 };
 
@@ -81,26 +81,26 @@ let TabUtils = {
 function TabMatcher(term) {
   this.term = term;
 }
 
 TabMatcher.prototype = {
   // ----------
   // Function: toString
   // Prints [TabMatcher (term)] for debug use.
-  toString: function TabMatcher_toString() {
+  toString: function() {
     return "[TabMatcher (" + this.term + ")]";
   },
 
   // ---------
   // Function: _filterAndSortForMatches
   // Given an array of <TabItem>s and <xul:tab>s returns a new array
   // of tabs whose name matched the search term, sorted by lexical
   // closeness.
-  _filterAndSortForMatches: function TabMatcher__filterAndSortForMatches(tabs) {
+  _filterAndSortForMatches: function(tabs) {
     let self = this;
     tabs = tabs.filter(function TabMatcher__filterAndSortForMatches_filter(tab) {
       let name = TabUtils.nameOf(tab);
       let url = TabUtils.URLOf(tab);
       return name.match(new RegExp(self.term, "i")) || url.match(new RegExp(self.term, "i"));
     });
 
     tabs.sort(function TabMatcher__filterAndSortForMatches_sort(x, y) {
@@ -111,33 +111,33 @@ TabMatcher.prototype = {
 
     return tabs;
   },
 
   // ---------
   // Function: _filterForUnmatches
   // Given an array of <TabItem>s returns an unsorted array of tabs whose name
   // does not match the the search term.
-  _filterForUnmatches: function TabMatcher__filterForUnmatches(tabs) {
+  _filterForUnmatches: function(tabs) {
     let self = this;
     return tabs.filter(function TabMatcher__filterForUnmatches_filter(tab) {
       let name = tab.$tabTitle[0].textContent;
       let url = TabUtils.URLOf(tab);
       return !name.match(new RegExp(self.term, "i")) && !url.match(new RegExp(self.term, "i"));
     });
   },
 
   // ---------
   // Function: _getTabsForOtherWindows
   // Returns an array of <TabItem>s and <xul:tabs>s representing tabs
   // from all windows but the current window. <TabItem>s will be returned
   // for windows in which Panorama has been activated at least once, while
   // <xul:tab>s will be returned for windows in which Panorama has never
   // been activated.
-  _getTabsForOtherWindows: function TabMatcher__getTabsForOtherWindows() {
+  _getTabsForOtherWindows: function() {
     let enumerator = Services.wm.getEnumerator("navigator:browser");
     let allTabs = [];
 
     while (enumerator.hasMoreElements()) {
       let win = enumerator.getNext();
       // This function gets tabs from other windows, not from the current window
       if (win != gWindow)
         allTabs.push.apply(allTabs, win.gBrowser.tabs);
@@ -148,40 +148,40 @@ TabMatcher.prototype = {
   // ----------
   // Function: matchedTabsFromOtherWindows
   // Returns an array of <TabItem>s and <xul:tab>s that match the search term
   // from all windows but the current window. <TabItem>s will be returned for
   // windows in which Panorama has been activated at least once, while
   // <xul:tab>s will be returned for windows in which Panorama has never
   // been activated.
   // (new TabMatcher("app")).matchedTabsFromOtherWindows();
-  matchedTabsFromOtherWindows: function TabMatcher_matchedTabsFromOtherWindows() {
+  matchedTabsFromOtherWindows: function() {
     if (this.term.length < 2)
       return [];
 
     let tabs = this._getTabsForOtherWindows();
     return this._filterAndSortForMatches(tabs);
   },
 
   // ----------
   // Function: matched
   // Returns an array of <TabItem>s which match the current search term.
   // If the term is less than 2 characters in length, it returns nothing.
-  matched: function TabMatcher_matched() {
+  matched: function() {
     if (this.term.length < 2)
       return [];
 
     let tabs = TabItems.getItems();
     return this._filterAndSortForMatches(tabs);
   },
 
   // ----------
   // Function: unmatched
   // Returns all of <TabItem>s that .matched() doesn't return.
-  unmatched: function TabMatcher_unmatched() {
+  unmatched: function() {
     let tabs = TabItems.getItems();
     if (this.term.length < 2)
       return tabs;
 
     return this._filterForUnmatches(tabs);
   },
 
   // ----------
@@ -189,17 +189,17 @@ TabMatcher.prototype = {
   // Performs the search. Lets you provide three functions.
   // The first is on all matched tabs in the window, the second on all unmatched
   // tabs in the window, and the third on all matched tabs in other windows.
   // The first two functions take two parameters: A <TabItem> and its integer index
   // indicating the absolute rank of the <TabItem> in terms of match to
   // the search term. The last function also takes two paramaters, but can be
   // passed both <TabItem>s and <xul:tab>s and the index is offset by the
   // number of matched tabs inside the window.
-  doSearch: function TabMatcher_doSearch(matchFunc, unmatchFunc, otherFunc) {
+  doSearch: function(matchFunc, unmatchFunc, otherFunc) {
     let matches = this.matched();
     let unmatched = this.unmatched();
     let otherMatches = this.matchedTabsFromOtherWindows();
     
     matches.forEach(function(tab, i) {
       matchFunc(tab, i);
     });
 
@@ -212,17 +212,17 @@ TabMatcher.prototype = {
     });
   },
 
   // ----------
   // Function: _scorePatternMatch
   // Given a pattern string, returns a score between 0 and 1 of how well
   // that pattern matches the original string. It mimics the heuristics
   // of the Mac application launcher Quicksilver.
-  _scorePatternMatch: function TabMatcher__scorePatternMatch(pattern, matched, offset) {
+  _scorePatternMatch: function(pattern, matched, offset) {
     offset = offset || 0;
     pattern = pattern.toLowerCase();
     matched = matched.toLowerCase();
 
     if (pattern.length == 0)
       return 0.9;
     if (pattern.length > matched.length)
       return 0.0;
@@ -275,17 +275,17 @@ TabMatcher.prototype = {
 // 
 // A object that handles all of the event handlers.
 let TabHandlers = {
   _mouseDownLocation: null,
 
   // ---------
   // Function: onMatch
   // Adds styles and event listeners to the matched tab items.
-  onMatch: function TabHandlers_onMatch(tab, index) {
+  onMatch: function(tab, index) {
     tab.addClass("onTop");
     index != 0 ? tab.addClass("notMainMatch") : tab.removeClass("notMainMatch");
 
     // Remove any existing handlers before adding the new ones.
     // If we don't do this, then we may add more handlers than
     // we remove.
     tab.$canvas
       .unbind("mousedown", TabHandlers._hideHandler)
@@ -294,29 +294,29 @@ let TabHandlers = {
     tab.$canvas
       .mousedown(TabHandlers._hideHandler)
       .mouseup(TabHandlers._showHandler);
   },
 
   // ---------
   // Function: onUnmatch
   // Removes styles and event listeners from the unmatched tab items.
-  onUnmatch: function TabHandlers_onUnmatch(tab, index) {
+  onUnmatch: function(tab, index) {
     tab.$container.removeClass("onTop");
     tab.removeClass("notMainMatch");
 
     tab.$canvas
       .unbind("mousedown", TabHandlers._hideHandler)
       .unbind("mouseup", TabHandlers._showHandler);
   },
 
   // ---------
   // Function: onOther
   // Removes styles and event listeners from the unmatched tabs.
-  onOther: function TabHandlers_onOther(tab, index) {
+  onOther: function(tab, index) {
     // Unlike the other on* functions, in this function tab can
     // either be a <TabItem> or a <xul:tab>. In other functions
     // it is always a <TabItem>. Also note that index is offset
     // by the number of matches within the window.
     let item = iQ("<div/>")
       .addClass("inlineMatch")
       .click(function TabHandlers_onOther_click(event) {
         Search.hide(event);
@@ -334,26 +334,26 @@ let TabHandlers = {
     index != 0 ? item.addClass("notMainMatch") : item.removeClass("notMainMatch");
     item.appendTo("#results");
     iQ("#otherresults").show();
   },
 
   // ---------
   // Function: _hideHandler
   // Performs when mouse down on a canvas of tab item.
-  _hideHandler: function TabHandlers_hideHandler(event) {
+  _hideHandler: function(event) {
     iQ("#search").fadeOut();
     iQ("#searchshade").fadeOut();
     TabHandlers._mouseDownLocation = {x:event.clientX, y:event.clientY};
   },
 
   // ---------
   // Function: _showHandler
   // Performs when mouse up on a canvas of tab item.
-  _showHandler: function TabHandlers_showHandler(event) {
+  _showHandler: function(event) {
     // If the user clicks on a tab without moving the mouse then
     // they are zooming into the tab and we need to exit search
     // mode.
     if (TabHandlers._mouseDownLocation.x == event.clientX &&
         TabHandlers._mouseDownLocation.y == event.clientY) {
       Search.hide();
       return;
     }
@@ -373,25 +373,25 @@ let TabHandlers = {
 let Search = {
   _initiatedBy: "",
   _blockClick: false,
   _currentHandler: null,
 
   // ----------
   // Function: toString
   // Prints [Search] for debug use.
-  toString: function Search_toString() {
+  toString: function() {
     return "[Search]";
   },
 
   // ----------
   // Function: init
   // Initializes the searchbox to be focused, and everything else to be hidden,
   // and to have everything have the appropriate event handlers.
-  init: function Search_init() {
+  init: function() {
     let self = this;
 
     iQ("#search").hide();
     iQ("#searchshade").hide().mousedown(function Search_init_shade_mousedown(event) {
       if (event.target.id != "searchbox" && !self._blockClick)
         self.hide();
     });
 
@@ -417,17 +417,17 @@ let Search = {
     }, false);
 
     this.switchToBeforeMode();
   },
 
   // ----------
   // Function: _beforeSearchKeyHandler
   // Handles all keydown before the search interface is brought up.
-  _beforeSearchKeyHandler: function Search__beforeSearchKeyHandler(event) {
+  _beforeSearchKeyHandler: function(event) {
     // Only match reasonable text-like characters for quick search.
     if (event.altKey || event.ctrlKey || event.metaKey)
       return;
 
     if ((event.keyCode > 0 && event.keyCode <= event.DOM_VK_DELETE) ||
         event.keyCode == event.DOM_VK_CONTEXT_MENU ||
         event.keyCode == event.DOM_VK_SLEEP ||
         (event.keyCode >= event.DOM_VK_F1 &&
@@ -453,17 +453,17 @@ let Search = {
     this.switchToInMode();
     this._initiatedBy = "keydown";
     this.ensureShown(true);
   },
 
   // ----------
   // Function: _inSearchKeyHandler
   // Handles all keydown while search mode.
-  _inSearchKeyHandler: function Search__inSearchKeyHandler(event) {
+  _inSearchKeyHandler: function(event) {
     let term = iQ("#searchbox").val();
     if ((event.keyCode == event.DOM_VK_ESCAPE) ||
         (event.keyCode == event.DOM_VK_BACK_SPACE && term.length <= 1 &&
          this._initiatedBy == "keydown")) {
       this.hide(event);
       return;
     }
 
@@ -478,54 +478,54 @@ let Search = {
       else
         TabUtils.focus(others[0]);
     }
   },
 
   // ----------
   // Function: switchToBeforeMode
   // Make sure the event handlers are appropriate for the before-search mode.
-  switchToBeforeMode: function Search_switchToBeforeMode() {
+  switchToBeforeMode: function() {
     let self = this;
     if (this._currentHandler)
       iQ(window).unbind("keydown", this._currentHandler);
     this._currentHandler = function Search_switchToBeforeMode_handler(event) {
       self._beforeSearchKeyHandler(event);
     }
     iQ(window).keydown(this._currentHandler);
   },
 
   // ----------
   // Function: switchToInMode
   // Make sure the event handlers are appropriate for the in-search mode.
-  switchToInMode: function Search_switchToInMode() {
+  switchToInMode: function() {
     let self = this;
     if (this._currentHandler)
       iQ(window).unbind("keydown", this._currentHandler);
     this._currentHandler = function Search_switchToInMode_handler(event) {
       self._inSearchKeyHandler(event);
     }
     iQ(window).keydown(this._currentHandler);
   },
 
-  createSearchTabMatcher: function Search_createSearchTabMatcher() {
+  createSearchTabMatcher: function() {
     return new TabMatcher(iQ("#searchbox").val());
   },
 
   // ----------
   // Function: isEnabled
   // Checks whether search mode is enabled or not.
-  isEnabled: function Search_isEnabled() {
+  isEnabled: function() {
     return iQ("#search").css("display") != "none";
   },
 
   // ----------
   // Function: hide
   // Hides search mode.
-  hide: function Search_hide(event) {
+  hide: function(event) {
     if (!this.isEnabled())
       return;
 
     iQ("#searchbox").val("");
     iQ("#searchshade").hide();
     iQ("#search").hide();
 
     iQ("#searchbutton").css({ opacity:.8 });
@@ -554,34 +554,34 @@ let Search = {
     let newEvent = document.createEvent("Events");
     newEvent.initEvent("tabviewsearchdisabled", false, false);
     dispatchEvent(newEvent);
   },
 
   // ----------
   // Function: perform
   // Performs a search.
-  perform: function Search_perform() {
+  perform: function() {
     let matcher =  this.createSearchTabMatcher();
 
     // Remove any previous other-window search results and
     // hide the display area.
     iQ("#results").empty();
     iQ("#otherresults").hide();
     iQ("#otherresults>.label").text(tabviewString("search.otherWindowTabs"));
 
     matcher.doSearch(TabHandlers.onMatch, TabHandlers.onUnmatch, TabHandlers.onOther);
   },
 
   // ----------
   // Function: ensureShown
   // Ensures the search feature is displayed.  If not, display it.
   // Parameters:
   //  - a boolean indicates whether this is triggered by a keypress or not
-  ensureShown: function Search_ensureShown(activatedByKeypress) {
+  ensureShown: function(activatedByKeypress) {
     let $search = iQ("#search");
     let $searchShade = iQ("#searchshade");
     let $searchbox = iQ("#searchbox");
     iQ("#searchbutton").css({ opacity: 1 });
 
     // NOTE: when this function is called by keydown handler, next keypress
     // event or composition events of IME will be fired on the focused editor.
     function dispatchTabViewSearchEnabledEvent() {
diff --git a/browser/components/tabview/storage.js b/browser/components/tabview/storage.js
--- a/browser/components/tabview/storage.js
+++ b/browser/components/tabview/storage.js
@@ -12,49 +12,49 @@ let Storage = {
   GROUP_DATA_IDENTIFIER: "tabview-group",
   GROUPS_DATA_IDENTIFIER: "tabview-groups",
   TAB_DATA_IDENTIFIER: "tabview-tab",
   UI_DATA_IDENTIFIER: "tabview-ui",
 
   // ----------
   // Function: toString
   // Prints [Storage] for debug use
-  toString: function Storage_toString() {
+  toString: function() {
     return "[Storage]";
   },
 
   // ----------
   // Function: init
   // Sets up the object.
-  init: function Storage_init() {
+  init: function() {
     this._sessionStore =
       Cc["@mozilla.org/browser/sessionstore;1"].
         getService(Ci.nsISessionStore);
   },
 
   // ----------
   // Function: uninit
-  uninit: function Storage_uninit () {
+  uninit: function() {
     this._sessionStore = null;
   },
 
   // ----------
   // Function: saveTab
   // Saves the data for a single tab.
-  saveTab: function Storage_saveTab(tab, data) {
+  saveTab: function(tab, data) {
     Utils.assert(tab, "tab");
 
     this._sessionStore.setTabValue(tab, this.TAB_DATA_IDENTIFIER,
       JSON.stringify(data));
   },
 
   // ----------
   // Function: getTabData
   // Load tab data from session store and return it.
-  getTabData: function Storage_getTabData(tab) {
+  getTabData: function(tab) {
     Utils.assert(tab, "tab");
 
     let existingData = null;
 
     try {
       let tabData = this._sessionStore.getTabValue(tab, this.TAB_DATA_IDENTIFIER);
       if (tabData != "")
         existingData = JSON.parse(tabData);
@@ -64,133 +64,133 @@ let Storage = {
     }
 
     return existingData;
   },
 
   // ----------
   // Function: getTabState
   // Returns the current state of the given tab.
-  getTabState: function Storage_getTabState(tab) {
+  getTabState: function(tab) {
     Utils.assert(tab, "tab");
     let tabState;
 
     try {
       tabState = JSON.parse(this._sessionStore.getTabState(tab));
     } catch (e) {}
 
     return tabState;
   },
 
   // ----------
   // Function: saveGroupItem
   // Saves the data for a single groupItem, associated with a specific window.
-  saveGroupItem: function Storage_saveGroupItem(win, data) {
+  saveGroupItem: function(win, data) {
     var id = data.id;
     var existingData = this.readGroupItemData(win);
     existingData[id] = data;
     this._sessionStore.setWindowValue(win, this.GROUP_DATA_IDENTIFIER,
       JSON.stringify(existingData));
   },
 
   // ----------
   // Function: deleteGroupItem
   // Deletes the data for a single groupItem from the given window.
-  deleteGroupItem: function Storage_deleteGroupItem(win, id) {
+  deleteGroupItem: function(win, id) {
     var existingData = this.readGroupItemData(win);
     delete existingData[id];
     this._sessionStore.setWindowValue(win, this.GROUP_DATA_IDENTIFIER,
       JSON.stringify(existingData));
   },
 
   // ----------
   // Function: readGroupItemData
   // Returns the data for all groupItems associated with the given window.
-  readGroupItemData: function Storage_readGroupItemData(win) {
+  readGroupItemData: function(win) {
     var existingData = {};
     let data;
     try {
       data = this._sessionStore.getWindowValue(win, this.GROUP_DATA_IDENTIFIER);
       if (data)
         existingData = JSON.parse(data);
     } catch (e) {
       // getWindowValue will fail if the property doesn't exist
       Utils.log("Error in readGroupItemData: "+e, data);
     }
     return existingData;
   },
 
   // ----------
   // Function: readWindowBusyState
   // Returns the current busyState for the given window.
-  readWindowBusyState: function Storage_readWindowBusyState(win) {
+  readWindowBusyState: function(win) {
     let state;
 
     try {
       let data = this._sessionStore.getWindowState(win);
       if (data)
         state = JSON.parse(data);
     } catch (e) {
       Utils.log("Error while parsing window state");
     }
 
     return (state && state.windows[0].busy);
   },
 
   // ----------
   // Function: saveGroupItemsData
   // Saves the global data for the <GroupItems> singleton for the given window.
-  saveGroupItemsData: function Storage_saveGroupItemsData(win, data) {
+  saveGroupItemsData: function(win, data) {
     this.saveData(win, this.GROUPS_DATA_IDENTIFIER, data);
   },
 
   // ----------
   // Function: readGroupItemsData
   // Reads the global data for the <GroupItems> singleton for the given window.
-  readGroupItemsData: function Storage_readGroupItemsData(win) {
+  readGroupItemsData: function(win) {
     return this.readData(win, this.GROUPS_DATA_IDENTIFIER);
   },
 
   // ----------
   // Function: saveUIData
   // Saves the global data for the <UIManager> singleton for the given window.
-  saveUIData: function Storage_saveUIData(win, data) {
+  saveUIData: function(win, data) {
     this.saveData(win, this.UI_DATA_IDENTIFIER, data);
   },
 
   // ----------
   // Function: readUIData
   // Reads the global data for the <UIManager> singleton for the given window.
-  readUIData: function Storage_readUIData(win) {
+  readUIData: function(win) {
     return this.readData(win, this.UI_DATA_IDENTIFIER);
   },
 
   // ----------
   // Function: saveVisibilityData
   // Saves visibility for the given window.
-  saveVisibilityData: function Storage_saveVisibilityData(win, data) {
+  saveVisibilityData: function(win, data) {
     this._sessionStore.setWindowValue(
       win, win.TabView.VISIBILITY_IDENTIFIER, data);
   },
 
   // ----------
   // Function: saveData
   // Generic routine for saving data to a window.
-  saveData: function Storage_saveData(win, id, data) {
+  saveData: function(win, id, data) {
     try {
       this._sessionStore.setWindowValue(win, id, JSON.stringify(data));
     } catch (e) {
       Utils.log("Error in saveData: "+e);
     }
   },
 
   // ----------
   // Function: readData
   // Generic routine for reading data from a window.
-  readData: function Storage_readData(win, id) {
+  readData: function(win, id) {
     var existingData = {};
     try {
       var data = this._sessionStore.getWindowValue(win, id);
       if (data)
         existingData = JSON.parse(data);
     } catch (e) {
       Utils.log("Error in readData: "+e);
     }
diff --git a/browser/components/tabview/tabitems.js b/browser/components/tabview/tabitems.js
--- a/browser/components/tabview/tabitems.js
+++ b/browser/components/tabview/tabitems.js
@@ -109,123 +109,123 @@ function TabItem(tab, options) {
   if (!TabItems.reconnectingPaused())
     this._reconnect(options);
 };
 
 TabItem.prototype = Utils.extend(new Item(), new Subscribable(), {
   // ----------
   // Function: toString
   // Prints [TabItem (tab)] for debug use
-  toString: function TabItem_toString() {
+  toString: function() {
     return "[TabItem (" + this.tab + ")]";
   },
 
   // ----------
   // Function: forceCanvasSize
   // Repaints the thumbnail with the given resolution, and forces it
   // to stay that resolution until unforceCanvasSize is called.
-  forceCanvasSize: function TabItem_forceCanvasSize(w, h) {
+  forceCanvasSize: function(w, h) {
     this.canvasSizeForced = true;
     this.$canvas[0].width = w;
     this.$canvas[0].height = h;
     this.tabCanvas.paint();
   },
 
   // ----------
   // Function: unforceCanvasSize
   // Stops holding the thumbnail resolution; allows it to shift to the
   // size of thumbnail on screen. Note that this call does not nest, unlike
   // <TabItems.resumePainting>; if you call forceCanvasSize multiple
   // times, you just need a single unforce to clear them all.
-  unforceCanvasSize: function TabItem_unforceCanvasSize() {
+  unforceCanvasSize: function() {
     this.canvasSizeForced = false;
   },
 
   // ----------
   // Function: isShowingCachedData
   // Returns a boolean indicates whether the cached data is being displayed or
   // not. 
-  isShowingCachedData: function TabItem_isShowingCachedData() {
+  isShowingCachedData: function() {
     return this._showsCachedData;
   },
 
   // ----------
   // Function: showCachedData
   // Shows the cached data i.e. image and title.  Note: this method should only
   // be called at browser startup with the cached data avaliable.
-  showCachedData: function TabItem_showCachedData() {
+  showCachedData: function() {
     let {title, url} = this.getTabState();
     let thumbnailURL = gPageThumbnails.getThumbnailURL(url);
 
     this.$cachedThumb.attr("src", thumbnailURL).show();
     this.$canvas.css({opacity: 0});
 
     let tooltip = (title && title != url ? title + "\n" + url : url);
     this.$tabTitle.text(title).attr("title", tooltip);
     this._showsCachedData = true;
   },
 
   // ----------
   // Function: hideCachedData
   // Hides the cached data i.e. image and title and show the canvas.
-  hideCachedData: function TabItem_hideCachedData() {
+  hideCachedData: function() {
     this.$cachedThumb.attr("src", "").hide();
     this.$canvas.css({opacity: 1.0});
     this._showsCachedData = false;
   },
 
   // ----------
   // Function: getStorageData
   // Get data to be used for persistent storage of this object.
-  getStorageData: function TabItem_getStorageData() {
+  getStorageData: function() {
     let data = {
       groupID: (this.parent ? this.parent.id : 0)
     };
     if (this.parent && this.parent.getActiveTab() == this)
       data.active = true;
 
     return data;
   },
 
   // ----------
   // Function: save
   // Store persistent for this object.
-  save: function TabItem_save() {
+  save: function() {
     try {
       if (!this.tab || !Utils.isValidXULTab(this.tab) || !this._reconnected) // too soon/late to save
         return;
 
       let data = this.getStorageData();
       if (TabItems.storageSanity(data))
         Storage.saveTab(this.tab, data);
     } catch(e) {
       Utils.log("Error in saving tab value: "+e);
     }
   },
 
   // ----------
   // Function: _getCurrentTabStateEntry
   // Returns the current tab state's active history entry.
-  _getCurrentTabStateEntry: function TabItem__getCurrentTabStateEntry() {
+  _getCurrentTabStateEntry: function() {
     let tabState = Storage.getTabState(this.tab);
 
     if (tabState) {
       let index = (tabState.index || tabState.entries.length) - 1;
       if (index in tabState.entries)
         return tabState.entries[index];
     }
 
     return null;
   },
 
   // ----------
   // Function: getTabState
   // Returns the current tab state, i.e. the title and URL of the active
   // history entry.
-  getTabState: function TabItem_getTabState() {
+  getTabState: function() {
     let entry = this._getCurrentTabStateEntry();
     let title = "";
     let url = "";
 
     if (entry) {
       if (entry.title)
         title = entry.title;
 
@@ -243,17 +243,17 @@ TabItem.prototype = Utils.extend(new Ite
   // treats it as a new tab. 
   //
   // Parameters:
   //   options - an object with additional parameters, see below
   //
   // Possible options:
   //   groupItemId - if the tab doesn't have any data associated with it and
   //                 groupItemId is available, add the tab to that group.
-  _reconnect: function TabItem__reconnect(options) {
+  _reconnect: function(options) {
     Utils.assertThrow(!this._reconnected, "shouldn't already be reconnected");
     Utils.assertThrow(this.tab, "should have a xul:tab");
 
     let tabData = Storage.getTabData(this.tab);
     let groupItem;
 
     if (tabData && TabItems.storageSanity(tabData)) {
       // Show the cached data while we're waiting for the tabItem to be updated.
@@ -296,43 +296,43 @@ TabItem.prototype = Utils.extend(new Ite
     this._reconnected = true;
     this.save();
     this._sendToSubscribers("reconnected");
   },
 
   // ----------
   // Function: setHidden
   // Hide/unhide this item
-  setHidden: function TabItem_setHidden(val) {
+  setHidden: function(val) {
     if (val)
       this.addClass("tabHidden");
     else
       this.removeClass("tabHidden");
     this._hidden = val;
   },
 
   // ----------
   // Function: getHidden
   // Return hide state of item
-  getHidden: function TabItem_getHidden() {
+  getHidden: function() {
     return this._hidden;
   },
 
   // ----------
   // Function: setBounds
   // Moves this item to the specified location and size.
   //
   // Parameters:
   //   rect - a <Rect> giving the new bounds
   //   immediately - true if it should not animate; default false
   //   options - an object with additional parameters, see below
   //
   // Possible options:
   //   force - true to always update the DOM even if the bounds haven't changed; default false
-  setBounds: function TabItem_setBounds(inRect, immediately, options) {
+  setBounds: function(inRect, immediately, options) {
     Utils.assert(Utils.isRect(inRect), 'TabItem.setBounds: rect is not a real rectangle!');
 
     if (!options)
       options = {};
 
     // force the input size to be valid
     let validSize = TabItems.calcValidSize(
       new Point(inRect.width, inRect.height), 
@@ -439,29 +439,29 @@ TabItem.prototype = Utils.extend(new Ite
       this.setTrenches(rect);
 
     this.save();
   },
 
   // ----------
   // Function: setZ
   // Sets the z-index for this item.
-  setZ: function TabItem_setZ(value) {
+  setZ: function(value) {
     this.zIndex = value;
     this.$container.css({zIndex: value});
   },
 
   // ----------
   // Function: close
   // Closes this item (actually closes the tab associated with it, which automatically
   // closes the item.
   // Parameters:
   //   groupClose - true if this method is called by group close action.
   // Returns true if this tab is removed.
-  close: function TabItem_close(groupClose) {
+  close: function(groupClose) {
     // When the last tab is closed, put a new tab into closing tab's group. If
     // closing tab doesn't belong to a group and no empty group, create a new 
     // one for the new tab.
     if (!groupClose && gBrowser.tabs.length == 1) {
       let group = this.tab._tabViewTabItem.parent;
       group.newTab(null, { closedLastTab: true });
     }
 
@@ -477,51 +477,51 @@ TabItem.prototype = Utils.extend(new Ite
     // No need to explicitly delete the tab data, becasue sessionstore data
     // associated with the tab will automatically go away
     return tabClosed;
   },
 
   // ----------
   // Function: addClass
   // Adds the specified CSS class to this item's container DOM element.
-  addClass: function TabItem_addClass(className) {
+  addClass: function(className) {
     this.$container.addClass(className);
   },
 
   // ----------
   // Function: removeClass
   // Removes the specified CSS class from this item's container DOM element.
-  removeClass: function TabItem_removeClass(className) {
+  removeClass: function(className) {
     this.$container.removeClass(className);
   },
 
   // ----------
   // Function: makeActive
   // Updates this item to visually indicate that it's active.
-  makeActive: function TabItem_makeActive() {
+  makeActive: function() {
     this.$container.addClass("focus");
 
     if (this.parent)
       this.parent.setActiveTab(this);
   },
 
   // ----------
   // Function: makeDeactive
   // Updates this item to visually indicate that it's not active.
-  makeDeactive: function TabItem_makeDeactive() {
+  makeDeactive: function() {
     this.$container.removeClass("focus");
   },
 
   // ----------
   // Function: zoomIn
   // Allows you to select the tab and zoom in on it, thereby bringing you
   // to the tab in Firefox to interact with.
   // Parameters:
   //   isNewBlankTab - boolean indicates whether it is a newly opened blank tab.
-  zoomIn: function TabItem_zoomIn(isNewBlankTab) {
+  zoomIn: function(isNewBlankTab) {
     // don't allow zoom in if its group is hidden
     if (this.parent && this.parent.hidden)
       return;
 
     let self = this;
     let $tabEl = this.$container;
     let $canvas = this.$canvas;
 
@@ -581,17 +581,17 @@ TabItem.prototype = Utils.extend(new Ite
 
   // ----------
   // Function: zoomOut
   // Handles the zoom down animation after returning to TabView.
   // It is expected that this routine will be called from the chrome thread
   //
   // Parameters:
   //   complete - a function to call after the zoom down animation
-  zoomOut: function TabItem_zoomOut(complete) {
+  zoomOut: function(complete) {
     let $tab = this.$container, $canvas = this.$canvas;
     var self = this;
     
     let onZoomDone = function onZoomDone() {
       $tab.removeClass("front");
       $canvas.css("transform", null);
 
       if (typeof complete == "function")
@@ -627,17 +627,17 @@ TabItem.prototype = Utils.extend(new Ite
       onZoomDone();
     }
   },
 
   // ----------
   // Function: getZoomTransform
   // Returns the transform function which represents the maximum bounds of the
   // tab thumbnail in the zoom animation.
-  getZoomTransform: function TabItem_getZoomTransform(scaleCheat) {
+  getZoomTransform: function(scaleCheat) {
     // Taking the bounds of the container (as opposed to the canvas) makes us
     // immune to any transformations applied to the canvas.
     let { left, top, width, height, right, bottom } = this.$container.bounds();
 
     let { innerWidth: windowWidth, innerHeight: windowHeight } = window;
 
     // The scaleCheat is a clever way to speed up the zoom-in code.
     // Because image scaling is slowest on big images, we cheat and stop
@@ -665,17 +665,17 @@ TabItem.prototype = Utils.extend(new Ite
       transformOrigin: xOrigin + "% " + yOrigin + "%",
       transform: "scale(" + zoomScaleFactor + ")"
     };
   },
 
   // ----------
   // Function: updateCanvas
   // Updates the tabitem's canvas.
-  updateCanvas: function TabItem_updateCanvas() {
+  updateCanvas: function() {
     // ___ thumbnail
     let $canvas = this.$canvas;
     if (!this.canvasSizeForced) {
       let w = $canvas.width();
       let h = $canvas.height();
       if (w != $canvas[0].width || h != $canvas[0].height) {
         $canvas[0].width = w;
         $canvas[0].height = h;
@@ -717,24 +717,24 @@ let TabItems = {
   _pauseUpdateForTest: false,
   _reconnectingPaused: false,
   tabItemPadding: {},
   _mozAfterPaintHandler: null,
 
   // ----------
   // Function: toString
   // Prints [TabItems count=count] for debug use
-  toString: function TabItems_toString() {
+  toString: function() {
     return "[TabItems count=" + this.items.length + "]";
   },
 
   // ----------
   // Function: init
   // Set up the necessary tracking to maintain the <TabItems>s.
-  init: function TabItems_init() {
+  init: function() {
     Utils.assert(window.AllTabs, "AllTabs must be initialized first");
     let self = this;
     
     // Set up tab priority queue
     this._tabsWaitingForUpdate = new TabPriorityQueue();
     this.minTabHeight = this.minTabWidth * this.tabHeight / this.tabWidth;
     this.tabAspect = this.tabHeight / this.tabWidth;
     this.invTabAspect = 1 / this.tabAspect;
@@ -791,17 +791,17 @@ let TabItems = {
          options.groupItemId = activeGroupItemId;
       self.link(tab, options);
       self.update(tab);
     });
   },
 
   // ----------
   // Function: uninit
-  uninit: function TabItems_uninit() {
+  uninit: function() {
     let mm = gWindow.messageManager;
     mm.removeMessageListener("Panorama:MozAfterPaint", this._mozAfterPaintHandler);
 
     for (let name in this._eventListeners) {
       AllTabs.unregister(name, this._eventListeners[name]);
     }
     this.items.forEach(function(tabItem) {
       delete tabItem.tab._tabViewTabItem;
@@ -818,17 +818,17 @@ let TabItems = {
     this._tabsWaitingForUpdate.clear();
   },
 
   // ----------
   // Function: fragment
   // Return a DocumentFragment which has a single <div> child. This child node
   // will act as a template for all TabItem containers.
   // The first call of this function caches the DocumentFragment in _fragment.
-  fragment: function TabItems_fragment() {
+  fragment: function() {
     if (this._fragment)
       return this._fragment;
 
     let div = document.createElement("div");
     div.classList.add("tab");
     div.innerHTML = "<div class='thumb'>" +
             "<img class='cached-thumb' style='display:none'/><canvas moz-opaque/></div>" +
             "<div class='favicon'><img/></div>" +
@@ -838,17 +838,17 @@ let TabItems = {
     this._fragment.appendChild(div);
 
     return this._fragment;
   },
 
   // Function: _isComplete
   // Checks whether the xul:tab has fully loaded and calls a callback with a 
   // boolean indicates whether the tab is loaded or not.
-  _isComplete: function TabItems__isComplete(tab, callback) {
+  _isComplete: function(tab, callback) {
     Utils.assertThrow(tab, "tab");
 
     // A pending tab can't be complete, yet.
     if (tab.hasAttribute("pending")) {
       setTimeout(() => callback(false));
       return;
     }
 
@@ -860,30 +860,30 @@ let TabItems = {
       callback(cx.json.isLoaded);
     });
     mm.sendAsyncMessage(message);
   },
 
   // ----------
   // Function: onMozAfterPaint
   // Called when a web page is painted.
-  onMozAfterPaint: function TabItems_onMozAfterPaint(cx) {
+  onMozAfterPaint: function(cx) {
     let index = gBrowser.browsers.indexOf(cx.target);
     if (index == -1)
       return;
 
     let tab = gBrowser.tabs[index];
     if (!tab.pinned)
       this.update(tab);
   },
 
   // ----------
   // Function: update
   // Takes in a xul:tab.
-  update: function TabItems_update(tab) {
+  update: function(tab) {
     try {
       Utils.assertThrow(tab, "tab");
       Utils.assertThrow(!tab.pinned, "shouldn't be an app tab");
       Utils.assertThrow(tab._tabViewTabItem, "should already be linked");
 
       let shouldDefer = (
         this.isPaintingPaused() ||
         this._tabsWaitingForUpdate.hasItems() ||
@@ -905,17 +905,17 @@ let TabItems = {
   // Takes in a xul:tab.
   //
   // Parameters:
   //   tab - a xul tab to update
   //   options - an object with additional parameters, see below
   //
   // Possible options:
   //   force - true to always update the tab item even if it's incomplete
-  _update: function TabItems__update(tab, options) {
+  _update: function(tab, options) {
     try {
       if (this._pauseUpdateForTest)
         return;
 
       Utils.assertThrow(tab, "tab");
 
       // ___ get the TabItem
       Utils.assertThrow(tab._tabViewTabItem, "must already be linked");
@@ -973,31 +973,31 @@ let TabItems = {
     } catch(e) {
       Utils.log(e);
     }
   },
 
   // ----------
   // Function: link
   // Takes in a xul:tab, creates a TabItem for it and adds it to the scene. 
-  link: function TabItems_link(tab, options) {
+  link: function(tab, options) {
     try {
       Utils.assertThrow(tab, "tab");
       Utils.assertThrow(!tab.pinned, "shouldn't be an app tab");
       Utils.assertThrow(!tab._tabViewTabItem, "shouldn't already be linked");
       new TabItem(tab, options); // sets tab._tabViewTabItem to itself
     } catch(e) {
       Utils.log(e);
     }
   },
 
   // ----------
   // Function: unlink
   // Takes in a xul:tab and destroys the TabItem associated with it. 
-  unlink: function TabItems_unlink(tab) {
+  unlink: function(tab) {
     try {
       Utils.assertThrow(tab, "tab");
       Utils.assertThrow(tab._tabViewTabItem, "should already be linked");
       // note that it's ok to unlink an app tab; see .handleTabUnpin
 
       this.unregister(tab._tabViewTabItem);
       tab._tabViewTabItem._sendToSubscribers("close");
       tab._tabViewTabItem.$container.remove();
@@ -1013,49 +1013,49 @@ let TabItems = {
       this._tabsWaitingForUpdate.remove(tab);
     } catch(e) {
       Utils.log(e);
     }
   },
 
   // ----------
   // when a tab becomes pinned, destroy its TabItem
-  handleTabPin: function TabItems_handleTabPin(xulTab) {
+  handleTabPin: function(xulTab) {
     this.unlink(xulTab);
   },
 
   // ----------
   // when a tab becomes unpinned, create a TabItem for it
-  handleTabUnpin: function TabItems_handleTabUnpin(xulTab) {
+  handleTabUnpin: function(xulTab) {
     this.link(xulTab);
     this.update(xulTab);
   },
 
   // ----------
   // Function: startHeartbeat
   // Start a new heartbeat if there isn't one already started.
   // The heartbeat is a chain of setTimeout calls that allows us to spread
   // out update calls over a period of time.
   // _heartbeat is used to make sure that we don't add multiple 
   // setTimeout chains.
-  startHeartbeat: function TabItems_startHeartbeat() {
+  startHeartbeat: function() {
     if (!this._heartbeat) {
       let self = this;
       this._heartbeat = setTimeout(function() {
         self._checkHeartbeat();
       }, this._heartbeatTiming);
     }
   },
 
   // ----------
   // Function: _checkHeartbeat
   // This periodically checks for tabs waiting to be updated, and calls
   // _update on them.
   // Should only be called by startHeartbeat and resumePainting.
-  _checkHeartbeat: function TabItems__checkHeartbeat() {
+  _checkHeartbeat: function() {
     this._heartbeat = null;
 
     if (this.isPaintingPaused())
       return;
 
     // restart the heartbeat to update all waiting tabs once the UI becomes idle
     if (!UI.isIdle()) {
       this.startHeartbeat();
@@ -1083,147 +1083,147 @@ let TabItems = {
   },
 
   // ----------
   // Function: pausePainting
   // Tells TabItems to stop updating thumbnails (so you can do
   // animations without thumbnail paints causing stutters).
   // pausePainting can be called multiple times, but every call to
   // pausePainting needs to be mirrored with a call to <resumePainting>.
-  pausePainting: function TabItems_pausePainting() {
+  pausePainting: function() {
     this.paintingPaused++;
     if (this._heartbeat) {
       clearTimeout(this._heartbeat);
       this._heartbeat = null;
     }
   },
 
   // ----------
   // Function: resumePainting
   // Undoes a call to <pausePainting>. For instance, if you called
   // pausePainting three times in a row, you'll need to call resumePainting
   // three times before TabItems will start updating thumbnails again.
-  resumePainting: function TabItems_resumePainting() {
+  resumePainting: function() {
     this.paintingPaused--;
     Utils.assert(this.paintingPaused > -1, "paintingPaused should not go below zero");
     if (!this.isPaintingPaused())
       this.startHeartbeat();
   },
 
   // ----------
   // Function: isPaintingPaused
   // Returns a boolean indicating whether painting
   // is paused or not.
-  isPaintingPaused: function TabItems_isPaintingPaused() {
+  isPaintingPaused: function() {
     return this.paintingPaused > 0;
   },
 
   // ----------
   // Function: pauseReconnecting
   // Don't reconnect any new tabs until resume is called.
-  pauseReconnecting: function TabItems_pauseReconnecting() {
+  pauseReconnecting: function() {
     Utils.assertThrow(!this._reconnectingPaused, "shouldn't already be paused");
 
     this._reconnectingPaused = true;
   },
   
   // ----------
   // Function: resumeReconnecting
   // Reconnect all of the tabs that were created since we paused.
-  resumeReconnecting: function TabItems_resumeReconnecting() {
+  resumeReconnecting: function() {
     Utils.assertThrow(this._reconnectingPaused, "should already be paused");
 
     this._reconnectingPaused = false;
     this.items.forEach(function(item) {
       if (!item._reconnected)
         item._reconnect();
     });
   },
   
   // ----------
   // Function: reconnectingPaused
   // Returns true if reconnecting is paused.
-  reconnectingPaused: function TabItems_reconnectingPaused() {
+  reconnectingPaused: function() {
     return this._reconnectingPaused;
   },
   
   // ----------
   // Function: register
   // Adds the given <TabItem> to the master list.
-  register: function TabItems_register(item) {
+  register: function(item) {
     Utils.assert(item && item.isAnItem, 'item must be a TabItem');
     Utils.assert(this.items.indexOf(item) == -1, 'only register once per item');
     this.items.push(item);
   },
 
   // ----------
   // Function: unregister
   // Removes the given <TabItem> from the master list.
-  unregister: function TabItems_unregister(item) {
+  unregister: function(item) {
     var index = this.items.indexOf(item);
     if (index != -1)
       this.items.splice(index, 1);
   },
 
   // ----------
   // Function: getItems
   // Returns a copy of the master array of <TabItem>s.
-  getItems: function TabItems_getItems() {
+  getItems: function() {
     return Utils.copy(this.items);
   },
 
   // ----------
   // Function: saveAll
   // Saves all open <TabItem>s.
-  saveAll: function TabItems_saveAll() {
+  saveAll: function() {
     let tabItems = this.getItems();
 
     tabItems.forEach(function TabItems_saveAll_forEach(tabItem) {
       tabItem.save();
     });
   },
 
   // ----------
   // Function: storageSanity
   // Checks the specified data (as returned by TabItem.getStorageData or loaded from storage)
   // and returns true if it looks valid.
   // TODO: this is a stub, please implement
-  storageSanity: function TabItems_storageSanity(data) {
+  storageSanity: function(data) {
     return true;
   },
 
   // ----------
   // Function: getFontSizeFromWidth
   // Private method that returns the fontsize to use given the tab's width
-  getFontSizeFromWidth: function TabItem_getFontSizeFromWidth(width) {
+  getFontSizeFromWidth: function(width) {
     let widthRange = new Range(0, TabItems.tabWidth);
     let proportion = widthRange.proportion(width - TabItems.tabItemPadding.x, true);
     // proportion is in [0,1]
     return TabItems.fontSizeRange.scale(proportion);
   },
 
   // ----------
   // Function: _getWidthForHeight
   // Private method that returns the tabitem width given a height.
-  _getWidthForHeight: function TabItems__getWidthForHeight(height) {
+  _getWidthForHeight: function(height) {
     return height * TabItems.invTabAspect;
   },
 
   // ----------
   // Function: _getHeightForWidth
   // Private method that returns the tabitem height given a width.
-  _getHeightForWidth: function TabItems__getHeightForWidth(width) {
+  _getHeightForWidth: function(width) {
     return width * TabItems.tabAspect;
   },
 
   // ----------
   // Function: calcValidSize
   // Pass in a desired size, and receive a size based on proper title
   // size and aspect ratio.
-  calcValidSize: function TabItems_calcValidSize(size, options) {
+  calcValidSize: function(size, options) {
     Utils.assert(Utils.isPoint(size), 'input is a Point');
 
     let width = Math.max(TabItems.minTabWidth, size.x);
     let showTitle = !options || !options.hideTitle;
     let titleSize = showTitle ? TabItems.fontSizeRange.max : 0;
     let height = Math.max(TabItems.minTabHeight, size.y - titleSize);
     let retSize = new Point(width, height);
 
@@ -1258,46 +1258,46 @@ function TabPriorityQueue() {
 
 TabPriorityQueue.prototype = {
   _low: [], // low priority queue
   _high: [], // high priority queue
 
   // ----------
   // Function: toString
   // Prints [TabPriorityQueue count=count] for debug use
-  toString: function TabPriorityQueue_toString() {
+  toString: function() {
     return "[TabPriorityQueue count=" + (this._low.length + this._high.length) + "]";
   },
 
   // ----------
   // Function: clear
   // Empty the update queue
-  clear: function TabPriorityQueue_clear() {
+  clear: function() {
     this._low = [];
     this._high = [];
   },
 
   // ----------
   // Function: hasItems
   // Return whether pending items exist
-  hasItems: function TabPriorityQueue_hasItems() {
+  hasItems: function() {
     return (this._low.length > 0) || (this._high.length > 0);
   },
 
   // ----------
   // Function: getItems
   // Returns all queued items, ordered from low to high priority
-  getItems: function TabPriorityQueue_getItems() {
+  getItems: function() {
     return this._low.concat(this._high);
   },
 
   // ----------
   // Function: push
   // Add an item to be prioritized
-  push: function TabPriorityQueue_push(tab) {
+  push: function(tab) {
     // Push onto correct priority queue.
     // It's only low priority if it's in a stack, and isn't the top,
     // and the stack isn't expanded.
     // If it already exists in the destination queue,
     // leave it. If it exists in a different queue, remove it first and push
     // onto new queue.
     let item = tab._tabViewTabItem;
     if (item.parent && (item.parent.isStacked() &&
@@ -1317,41 +1317,41 @@ TabPriorityQueue.prototype = {
       } else if (this._high.indexOf(tab) == -1)
         this._high.unshift(tab);
     }
   },
 
   // ----------
   // Function: pop
   // Remove and return the next item in priority order
-  pop: function TabPriorityQueue_pop() {
+  pop: function() {
     let ret = null;
     if (this._high.length)
       ret = this._high.pop();
     else if (this._low.length)
       ret = this._low.pop();
     return ret;
   },
 
   // ----------
   // Function: peek
   // Return the next item in priority order, without removing it
-  peek: function TabPriorityQueue_peek() {
+  peek: function() {
     let ret = null;
     if (this._high.length)
       ret = this._high[this._high.length-1];
     else if (this._low.length)
       ret = this._low[this._low.length-1];
     return ret;
   },
 
   // ----------
   // Function: remove
   // Remove the passed item
-  remove: function TabPriorityQueue_remove(tab) {
+  remove: function(tab) {
     let index = this._high.indexOf(tab);
     if (index != -1)
       this._high.splice(index, 1);
     else {
       index = this._low.indexOf(tab);
       if (index != -1)
         this._low.splice(index, 1);
     }
@@ -1366,31 +1366,31 @@ function TabCanvas(tab, canvas) {
   this.tab = tab;
   this.canvas = canvas;
 };
 
 TabCanvas.prototype = Utils.extend(new Subscribable(), {
   // ----------
   // Function: toString
   // Prints [TabCanvas (tab)] for debug use
-  toString: function TabCanvas_toString() {
+  toString: function() {
     return "[TabCanvas (" + this.tab + ")]";
   },
 
   // ----------
   // Function: paint
-  paint: function TabCanvas_paint(evt) {
+  paint: function(evt) {
     var w = this.canvas.width;
     var h = this.canvas.height;
     if (!w || !h)
       return;
 
     gPageThumbnails.captureToCanvas(this.tab.linkedBrowser, this.canvas, () => {
       this._sendToSubscribers("painted");
     });
   },
 
   // ----------
   // Function: toImageData
-  toImageData: function TabCanvas_toImageData() {
+  toImageData: function() {
     return this.canvas.toDataURL("image/png");
   }
 });
diff --git a/browser/components/tabview/tabview.js b/browser/components/tabview/tabview.js
--- a/browser/components/tabview/tabview.js
+++ b/browser/components/tabview/tabview.js
@@ -49,21 +49,21 @@ let AllTabs = {
     pinned:       "TabPinned",
     unpinned:     "TabUnpinned"
   },
 
   get tabs() {
     return Array.filter(gBrowser.tabs, function (tab) Utils.isValidXULTab(tab));
   },
 
-  register: function AllTabs_register(eventName, callback) {
+  register: function(eventName, callback) {
     gBrowser.tabContainer.addEventListener(this._events[eventName], callback, false);
   },
 
-  unregister: function AllTabs_unregister(eventName, callback) {
+  unregister: function(eventName, callback) {
     gBrowser.tabContainer.removeEventListener(this._events[eventName], callback, false);
   }
 };
 
 # NB: Certain files need to evaluate before others
 
 #include iq.js
 #include storage.js
diff --git a/browser/components/tabview/telemetry.js b/browser/components/tabview/telemetry.js
--- a/browser/components/tabview/telemetry.js
+++ b/browser/components/tabview/telemetry.js
@@ -6,31 +6,31 @@
  * Collects telemetry data for Tabview.
  */
 let Telemetry = {
   TOPIC_GATHER_TELEMETRY: "gather-telemetry",
 
   /**
    * Initializes the object.
    */
-  init: function Telemetry_init() {
+  init: function() {
     Services.obs.addObserver(this, this.TOPIC_GATHER_TELEMETRY, false);
   }, 
 
   /**
    * Uninitializes the object.
    */
-  uninit: function Telemetry_uninit() {
+  uninit: function() {
     Services.obs.removeObserver(this, this.TOPIC_GATHER_TELEMETRY);
   },
 
   /**
    * Adds telemetry values to gather usage statistics.
    */
-  _collect: function Telemetry_collect() {
+  _collect: function() {
     let stackedGroupsCount = 0;
     let childCounts = [];
 
     GroupItems.groupItems.forEach(function (groupItem) {
       if (!groupItem.isEmpty()) {
         childCounts.push(groupItem.getChildren().length);
 
         if (groupItem.isStacked())
@@ -50,14 +50,14 @@ let Telemetry = {
     addTelemetryValue("GROUPS_COUNT", GroupItems.groupItems.length);
     addTelemetryValue("STACKED_GROUPS_COUNT", stackedGroupsCount);
     addTelemetryValue("MEDIAN_TABS_IN_GROUPS_COUNT", median(childCounts));
   },
 
   /**
    * Observes for gather telemetry topic.
    */
-  observe: function Telemetry_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (!gWindow.PrivateBrowsingUtils.isWindowPrivate(gWindow))
       this._collect();
   }
 }
 
diff --git a/browser/components/tabview/trench.js b/browser/components/tabview/trench.js
--- a/browser/components/tabview/trench.js
+++ b/browser/components/tabview/trench.js
@@ -73,45 +73,45 @@ function Trench(element, xory, type, edg
   this.minRange = new Range(0,0);
   this.activeRange = new Range(0,10000);
 };
 
 Trench.prototype = {
   // ----------
   // Function: toString
   // Prints [Trench edge type (parentItem)] for debug use
-  toString: function Trench_toString() {
+  toString: function() {
     return "[Trench " + this.edge + " " + this.type +
            (this.parentItem ? " (" + this.parentItem + ")" : "") +
            "]";
   },
 
   //----------
   // Variable: radius
   // (integer) radius is how far away we should snap from
   get radius() this.customRadius || Trenches.defaultRadius,
 
-  setParentItem: function Trench_setParentItem(item) {
+  setParentItem: function(item) {
     if (!item.isAnItem) {
       Utils.assert(false, "parentItem must be an Item");
       return false;
     }
     this.parentItem = item;
     return true;
   },
 
   //----------
   // Function: setPosition
   // set the trench's position.
   //
   // Parameters:
   //   position - (integer) px center position of the trench
   //   range - (<Range>) the explicit active range of the trench
   //   minRange - (<Range>) the minimum range of the trench
-  setPosition: function Trench_setPosition(position, range, minRange) {
+  setPosition: function(position, range, minRange) {
     this.position = position;
 
     var page = Items.getPageBounds(true);
 
     // optionally, set the range.
     if (Utils.isRange(range)) {
       this.range = range;
     } else {
@@ -132,17 +132,17 @@ Trench.prototype = {
   },
 
   //----------
   // Function: setActiveRange
   // set the trench's currently active range.
   //
   // Parameters:
   //   activeRange - (<Range>)
-  setActiveRange: function Trench_setActiveRange(activeRange) {
+  setActiveRange: function(activeRange) {
     if (!Utils.isRange(activeRange))
       return false;
     this.activeRange = activeRange;
     if (this.xory == "x") { // horizontal
       this.activeRect = new Rect(this.position - this.radius, this.activeRange.min, 2 * this.radius, this.activeRange.extent);
       this.guideRect = new Rect(this.position, this.activeRange.min, 0, this.activeRange.extent);
     } else { // vertical
       this.activeRect = new Rect(this.activeRange.min, this.position - this.radius, this.activeRange.extent, 2 * this.radius);
@@ -153,17 +153,17 @@ Trench.prototype = {
 
   //----------
   // Function: setWithRect
   // Set the trench's position using the given rect. We know which side of the rect we should match
   // because we've already recorded this information in <edge>.
   //
   // Parameters:
   //   rect - (<Rect>)
-  setWithRect: function Trench_setWithRect(rect) {
+  setWithRect: function(rect) {
 
     if (!Utils.isRect(rect))
       Utils.error('argument must be Rect');
 
     // First, calculate the range for this trench.
     // Border trenches are always only active for the length of this range.
     // Guide trenches, however, still use this value as its minRange.
     if (this.xory == "x")
@@ -197,17 +197,17 @@ Trench.prototype = {
   //----------
   // Function: show
   //
   // Show guide (dotted line), if <showGuide> is true.
   //
   // If <Trenches.showDebug> is true, we will draw the trench. Active portions are drawn with 0.5
   // opacity. If <active> is false, the entire trench will be
   // very translucent.
-  show: function Trench_show() { // DEBUG
+  show: function() { // DEBUG
     if (this.active && this.showGuide) {
       if (!this.dom.guideTrench)
         this.dom.guideTrench = iQ("<div/>").addClass('guideTrench').css({id: 'guideTrench'+this.id});
       var guideTrench = this.dom.guideTrench;
       guideTrench.css(this.guideRect);
       iQ("body").append(guideTrench);
     } else {
       if (this.dom.guideTrench) {
@@ -244,17 +244,17 @@ Trench.prototype = {
     activeVisibleTrench.css(this.activeRect || this.rect);
     iQ("body").append(visibleTrench);
     iQ("body").append(activeVisibleTrench);
   },
 
   //----------
   // Function: hide
   // Hide the trench.
-  hide: function Trench_hide(dontHideGuides) {
+  hide: function(dontHideGuides) {
     if (this.dom.visibleTrench)
       this.dom.visibleTrench.remove();
     if (this.dom.activeVisibleTrench)
       this.dom.activeVisibleTrench.remove();
     if (!dontHideGuides && this.dom.guideTrench)
       this.dom.guideTrench.remove();
   },
 
@@ -275,17 +275,17 @@ Trench.prototype = {
   //                        "topleft", "bottomleft", "topright", "bottomright"
   //   assumeConstantSize - (boolean) whether the rect's dimensions are sacred or not
   //   keepProportional - (boolean) if we are allowed to change the rect's size, whether the
   //                                dimensions should scaled proportionally or not.
   //
   // Returns:
   //   false - if rect does not overlap with this trench
   //   newRect - (<Rect>) an adjusted version of rect, if it is affected by this trench
-  rectOverlaps: function Trench_rectOverlaps(rect,stationaryCorner,assumeConstantSize,keepProportional) {
+  rectOverlaps: function(rect,stationaryCorner,assumeConstantSize,keepProportional) {
     var edgeToCheck;
     if (this.type == "border") {
       if (this.edge == "left")
         edgeToCheck = "right";
       else if (this.edge == "right")
         edgeToCheck = "left";
       else if (this.edge == "top")
         edgeToCheck = "bottom";
@@ -348,32 +348,32 @@ Trench.prototype = {
   // Function: ruleOverlaps
   // Computes whether the given "rule" (a line segment, essentially), given by the position and
   // range arguments, overlaps with the current trench. Note that this function assumes that
   // the rule and the trench are in the same direction: both horizontal, or both vertical.
   //
   // Parameters:
   //   position - (integer) a position in px
   //   range - (<Range>) the rule's range
-  ruleOverlaps: function Trench_ruleOverlaps(position, range) {
+  ruleOverlaps: function(position, range) {
     return (this.position - this.radius < position &&
            position < this.position + this.radius &&
            this.activeRange.overlaps(range));
   },
 
   //----------
   // Function: adjustRangeIfIntercept
   // Computes whether the given boundary (given as a position and its active range), perpendicular
   // to the trench, intercepts the trench or not. If it does, it returns an adjusted <Range> for
   // the trench. If not, it returns false.
   //
   // Parameters:
   //   position - (integer) the position of the boundary
   //   range - (<Range>) the target's range, on the trench's transverse axis
-  adjustRangeIfIntercept: function Trench_adjustRangeIfIntercept(position, range) {
+  adjustRangeIfIntercept: function(position, range) {
     if (this.position - this.radius > range.min && this.position + this.radius < range.max) {
       var activeRange = new Range(this.activeRange);
 
       // there are three ways this can go:
       // 1. position < minRange.min
       // 2. position > minRange.max
       // 3. position >= minRange.min && position <= minRange.max
 
@@ -389,17 +389,17 @@ Trench.prototype = {
     }
     return false;
   },
 
   //----------
   // Function: calculateActiveRange
   // Computes and sets the <activeRange> for the trench, based on the <GroupItems> around.
   // This makes it so trenches' active ranges don't extend through other groupItems.
-  calculateActiveRange: function Trench_calculateActiveRange() {
+  calculateActiveRange: function() {
 
     // set it to the default: just the range itself.
     this.setActiveRange(this.range);
 
     // only guide-type trenches need to set a separate active range
     if (this.type != 'guide')
       return;
 
@@ -453,56 +453,56 @@ var Trenches = {
   preferTop: true,
   get preferLeft() { return !UI.rtl; },
 
   trenches: [],
 
   // ----------
   // Function: toString
   // Prints [Trenches count=count] for debug use
-  toString: function Trenches_toString() {
+  toString: function() {
     return "[Trenches count=" + this.trenches.length + "]";
   },
 
   // ---------
   // Function: getById
   // Return the specified <Trench>.
   //
   // Parameters:
   //   id - (integer)
-  getById: function Trenches_getById(id) {
+  getById: function(id) {
     return this.trenches[id];
   },
 
   // ---------
   // Function: register
   // Register a new <Trench> and returns the resulting <Trench> ID.
   //
   // Parameters:
   // See the constructor <Trench.Trench>'s parameters.
   //
   // Returns:
   //   id - (int) the new <Trench>'s ID.
-  register: function Trenches_register(element, xory, type, edge) {
+  register: function(element, xory, type, edge) {
     var trench = new Trench(element, xory, type, edge);
     this.trenches[trench.id] = trench;
     return trench.id;
   },
 
   // ---------
   // Function: registerWithItem
   // Register a whole set of <Trench>es using an <Item> and returns the resulting <Trench> IDs.
   //
   // Parameters:
   //   item - the <Item> to project trenches
   //   type - either "border" or "guide"
   //
   // Returns:
   //   ids - array of the new <Trench>es' IDs.
-  registerWithItem: function Trenches_registerWithItem(item, type) {
+  registerWithItem: function(item, type) {
     var container = item.container;
     var ids = {};
     ids.left = Trenches.register(container,"x",type,"left");
     ids.right = Trenches.register(container,"x",type,"right");
     ids.top = Trenches.register(container,"y",type,"top");
     ids.bottom = Trenches.register(container,"y",type,"bottom");
 
     this.getById(ids.left).setParentItem(item);
@@ -514,59 +514,59 @@ var Trenches = {
   },
 
   // ---------
   // Function: unregister
   // Unregister one or more <Trench>es.
   //
   // Parameters:
   //   ids - (integer) a single <Trench> ID or (array) a list of <Trench> IDs.
-  unregister: function Trenches_unregister(ids) {
+  unregister: function(ids) {
     if (!Array.isArray(ids))
       ids = [ids];
     var self = this;
     ids.forEach(function(id) {
       self.trenches[id].hide();
       delete self.trenches[id];
     });
   },
 
   // ---------
   // Function: activateOthersTrenches
   // Activate all <Trench>es other than those projected by the current element.
   //
   // Parameters:
   //   element - (DOMElement) the DOM element of the Item being dragged or resized.
-  activateOthersTrenches: function Trenches_activateOthersTrenches(element) {
+  activateOthersTrenches: function(element) {
     this.trenches.forEach(function(t) {
       if (t.el === element)
         return;
       if (t.parentItem && (t.parentItem.isAFauxItem || t.parentItem.isDragging))
         return;
       t.active = true;
       t.calculateActiveRange();
       t.show(); // debug
     });
   },
 
   // ---------
   // Function: disactivate
   // After <activateOthersTrenches>, disactivates all the <Trench>es again.
-  disactivate: function Trenches_disactivate() {
+  disactivate: function() {
     this.trenches.forEach(function(t) {
       t.active = false;
       t.showGuide = false;
       t.show();
     });
   },
 
   // ---------
   // Function: hideGuides
   // Hide all guides (dotted lines) en masse.
-  hideGuides: function Trenches_hideGuides() {
+  hideGuides: function() {
     this.trenches.forEach(function(t) {
       t.showGuide = false;
       t.show();
     });
   },
 
   // ---------
   // Function: snap
@@ -580,17 +580,17 @@ var Trenches = {
   //                        "topleft", "bottomleft", "topright", "bottomright"
   //   assumeConstantSize - (boolean) whether the rect's dimensions are sacred or not
   //   keepProportional   - (boolean) if we are allowed to change the rect's size, whether the
   //                                  dimensions should scaled proportionally or not.
   //
   // Returns:
   //   (<Rect>) - the updated bounds, if they were updated
   //   false - if the bounds were not updated
-  snap: function Trenches_snap(rect,stationaryCorner,assumeConstantSize,keepProportional) {
+  snap: function(rect,stationaryCorner,assumeConstantSize,keepProportional) {
     // hide all the guide trenches, because the correct ones will be turned on later.
     Trenches.hideGuides();
 
     var updated = false;
     var updatedX = false;
     var updatedY = false;
 
     var snappedTrenches = {};
@@ -637,22 +637,22 @@ var Trenches = {
       return rect;
     }
     return false;
   },
 
   // ---------
   // Function: show
   // <Trench.show> all <Trench>es.
-  show: function Trenches_show() {
+  show: function() {
     this.trenches.forEach(function(t) {
       t.show();
     });
   },
 
   // ---------
   // Function: toggleShown
   // Toggle <Trenches.showDebug> and trigger <Trenches.show>
-  toggleShown: function Trenches_toggleShown() {
+  toggleShown: function() {
     this.showDebug = !this.showDebug;
     this.show();
   }
 };
diff --git a/browser/components/tabview/ui.js b/browser/components/tabview/ui.js
--- a/browser/components/tabview/ui.js
+++ b/browser/components/tabview/ui.js
@@ -90,24 +90,24 @@ let UI = {
 
   // Variable: _originalSmoothScroll
   // Used to keep track of the tab strip smooth scroll value.
   _originalSmoothScroll: null,
 
   // ----------
   // Function: toString
   // Prints [UI] for debug use
-  toString: function UI_toString() {
+  toString: function() {
     return "[UI]";
   },
 
   // ----------
   // Function: init
   // Must be called after the object is created.
-  init: function UI_init() {
+  init: function() {
     try {
       let self = this;
 
       // initialize the direction of the page
       this._initPageDirection();
 
       // ___ storage
       Storage.init();
@@ -250,17 +250,17 @@ let UI = {
       Utils.log(e);
     } finally {
       GroupItems.resumeArrange();
     }
   },
 
   // Function: uninit
   // Should be called when window is unloaded.
-  uninit: function UI_uninit() {
+  uninit: function() {
     // call our cleanup functions
     this._cleanupFunctions.forEach(function(func) {
       func();
     });
     this._cleanupFunctions = [];
 
     // additional clean up
     TabItems.uninit();
@@ -278,17 +278,17 @@ let UI = {
   },
 
   // Property: rtl
   // Returns true if we are in RTL mode, false otherwise
   rtl: false,
 
   // Function: reset
   // Resets the Panorama view to have just one group with all tabs
-  reset: function UI_reset() {
+  reset: function() {
     let padding = Trenches.defaultRadius;
     let welcomeWidth = 300;
     let pageBounds = Items.getPageBounds();
     pageBounds.inset(padding, padding);
 
     let $actions = iQ("#actions");
     if ($actions) {
       pageBounds.width -= $actions.width();
@@ -321,51 +321,51 @@ let UI = {
       groupItem.add(item, {immediately: true});
     });
     this.setActive(groupItem);
   },
 
   // ----------
   // Function: blurAll
   // Blurs any currently focused element
-  blurAll: function UI_blurAll() {
+  blurAll: function() {
     iQ(":focus").each(function(element) {
       element.blur();
     });
   },
 
   // ----------
   // Function: isIdle
   // Returns true if the last interaction was long enough ago to consider the
   // UI idle. Used to determine whether interactivity would be sacrificed if 
   // the CPU was to become busy.
   //
-  isIdle: function UI_isIdle() {
+  isIdle: function() {
     let time = Date.now();
     let maxEvent = Math.max(drag.lastMoveTime, resize.lastMoveTime);
     return (time - maxEvent) > this._maxInteractiveWait;
   },
 
   // ----------
   // Function: getActiveTab
   // Returns the currently active tab as a <TabItem>
-  getActiveTab: function UI_getActiveTab() {
+  getActiveTab: function() {
     return this._activeTab;
   },
 
   // ----------
   // Function: _setActiveTab
   // Sets the currently active tab. The idea of a focused tab is useful
   // for keyboard navigation and returning to the last zoomed-in tab.
   // Hitting return/esc brings you to the focused tab, and using the
   // arrow keys lets you navigate between open tabs.
   //
   // Parameters:
   //  - Takes a <TabItem>
-  _setActiveTab: function UI__setActiveTab(tabItem) {
+  _setActiveTab: function(tabItem) {
     if (tabItem == this._activeTab)
       return;
 
     if (this._activeTab) {
       this._activeTab.makeDeactive();
       this._activeTab.removeSubscriber("close", this._onActiveTabClosed);
     }
 
@@ -390,17 +390,17 @@ let UI = {
 
   // ----------
   // Function: setActive
   // Sets the active tab item or group item
   // Parameters:
   //
   // options
   //  dontSetActiveTabInGroup bool for not setting active tab in group
-  setActive: function UI_setActive(item, options) {
+  setActive: function(item, options) {
     Utils.assert(item, "item must be given");
 
     if (item.isATabItem) {
       if (item.parent)
         GroupItems.setActiveGroupItem(item.parent);
       if (!options || !options.dontSetActiveTabInGroup)
         this._setActiveTab(item);
     } else {
@@ -411,44 +411,44 @@ let UI = {
           this._setActiveTab(activeTab);
       }
     }
   },
 
   // ----------
   // Function: clearActiveTab
   // Sets the active tab to 'null'.
-  clearActiveTab: function UI_clearActiveTab() {
+  clearActiveTab: function() {
     this._setActiveTab(null);
   },
 
   // ----------
   // Function: isTabViewVisible
   // Returns true if the TabView UI is currently shown.
-  isTabViewVisible: function UI_isTabViewVisible() {
+  isTabViewVisible: function() {
     return gTabViewDeck.selectedPanel == gTabViewFrame;
   },
 
   // ---------
   // Function: _initPageDirection
   // Initializes the page base direction
-  _initPageDirection: function UI__initPageDirection() {
+  _initPageDirection: function() {
     let chromeReg = Cc["@mozilla.org/chrome/chrome-registry;1"].
                     getService(Ci.nsIXULChromeRegistry);
     let dir = chromeReg.isLocaleRTL("global");
     document.documentElement.setAttribute("dir", dir ? "rtl" : "ltr");
     this.rtl = dir;
   },
 
   // ----------
   // Function: showTabView
   // Shows TabView and hides the main browser UI.
   // Parameters:
   //   zoomOut - true for zoom out animation, false for nothing.
-  showTabView: function UI_showTabView(zoomOut) {
+  showTabView: function(zoomOut) {
     if (this.isTabViewVisible() || this._isChangingVisibility)
       return;
 
     this._isChangingVisibility = true;
 
     // store tab strip smooth scroll value and disable it.
     let tabStrip = gBrowser.tabContainer.mTabstrip;
     this._originalSmoothScroll = tabStrip.smoothScroll;
@@ -518,17 +518,17 @@ let UI = {
 
     if (gTabView.firstUseExperienced)
       gTabView.enableSessionRestore();
   },
 
   // ----------
   // Function: hideTabView
   // Hides TabView and shows the main browser UI.
-  hideTabView: function UI_hideTabView() {
+  hideTabView: function() {
     if (!this.isTabViewVisible() || this._isChangingVisibility)
       return;
 
     // another tab might be select if user decides to stay on a page when
     // a onclose confirmation prompts.
     GroupItems.removeHiddenGroups();
 
     // We need to set this after removing the hidden groups because doing so
@@ -572,17 +572,17 @@ let UI = {
   // Function: setTitlebarColors
   // Used on the Mac to make the title bar match the gradient in the rest of the
   // TabView UI.
   //
   // Parameters:
   //   colors - (bool or object) true for the special TabView color, false for
   //         the normal color, and an object with "active" and "inactive"
   //         properties to specify directly.
-  setTitlebarColors: function UI_setTitlebarColors(colors) {
+  setTitlebarColors: function(colors) {
     // Mac Only
     var mainWindow = gWindow.document.getElementById("main-window");
     if (colors === true) {
       mainWindow.setAttribute("activetitlebarcolor", "#C4C4C4");
       mainWindow.setAttribute("inactivetitlebarcolor", "#EDEDED");
     } else if (colors && "active" in colors && "inactive" in colors) {
       mainWindow.setAttribute("activetitlebarcolor", colors.active);
       mainWindow.setAttribute("inactivetitlebarcolor", colors.inactive);
@@ -592,31 +592,31 @@ let UI = {
     }
   },
 #endif
 
   // ----------
   // Function: storageBusy
   // Pauses the storage activity that conflicts with sessionstore updates.
   // Calls can be nested.
-  storageBusy: function UI_storageBusy() {
+  storageBusy: function() {
     if (this._storageBusy)
       return;
 
     this._storageBusy = true;
 
     TabItems.pauseReconnecting();
     GroupItems.pauseAutoclose();
   },
   
   // ----------
   // Function: storageReady
   // Resumes the activity paused by storageBusy, and updates for any new group
   // information in sessionstore. Calls can be nested. 
-  storageReady: function UI_storageReady() {
+  storageReady: function() {
     if (!this._storageBusy)
       return;
 
     this._storageBusy = false;
 
     let hasGroupItemsData = GroupItems.load();
     if (!hasGroupItemsData)
       this.reset();
@@ -624,17 +624,17 @@ let UI = {
     TabItems.resumeReconnecting();
     GroupItems._updateTabBar();
     GroupItems.resumeAutoclose();
   },
 
   // ----------
   // Function: _addTabActionHandlers
   // Adds handlers to handle tab actions.
-  _addTabActionHandlers: function UI__addTabActionHandlers() {
+  _addTabActionHandlers: function() {
     var self = this;
 
     // session restore events
     function handleSSWindowStateBusy() {
       self.storageBusy();
     }
     
     function handleSSWindowStateReady() {
@@ -754,36 +754,36 @@ let UI = {
     // Actually register the above handlers
     for (let name in this._eventListeners)
       AllTabs.register(name, this._eventListeners[name]);
   },
 
   // ----------
   // Function: _removeTabActionHandlers
   // Removes handlers to handle tab actions.
-  _removeTabActionHandlers: function UI__removeTabActionHandlers() {
+  _removeTabActionHandlers: function() {
     for (let name in this._eventListeners)
       AllTabs.unregister(name, this._eventListeners[name]);
   },
 
   // ----------
   // Function: goToTab
   // Selects the given xul:tab in the browser.
-  goToTab: function UI_goToTab(xulTab) {
+  goToTab: function(xulTab) {
     // If it's not focused, the onFocus listener would handle it.
     if (xulTab.selected)
       this.onTabSelect(xulTab);
     else
       gBrowser.selectedTab = xulTab;
   },
 
   // ----------
   // Function: onTabSelect
   // Called when the user switches from one tab to another outside of the TabView UI.
-  onTabSelect: function UI_onTabSelect(tab) {
+  onTabSelect: function(tab) {
     this._currentTab = tab;
 
     if (this.isTabViewVisible()) {
       // We want to zoom in if:
       // 1) we didn't just restore a tab via Ctrl+Shift+T
       // 2) the currently selected tab is the last created tab and has a tabItem
       if (!this.restoredClosedTab &&
           this._lastOpenedTab == tab && tab._tabViewTabItem) {
@@ -858,17 +858,17 @@ let UI = {
       if (GroupItems.getActiveGroupItem())
         GroupItems._updateTabBar();
     }
   },
 
   // ----------
   // Function: _onDOMWillOpenModalDialog
   // Called when a web page is about to show a modal dialog.
-  _onDOMWillOpenModalDialog: function UI__onDOMWillOpenModalDialog(cx) {
+  _onDOMWillOpenModalDialog: function(cx) {
     if (!this.isTabViewVisible())
       return;
 
     let index = gBrowser.browsers.indexOf(cx.target);
     if (index == -1)
       return;
 
     let tab = gBrowser.tabs[index];
@@ -882,51 +882,51 @@ let UI = {
   },
 
   // ----------
   // Function: setReorderTabsOnHide
   // Sets the groupItem which the tab items' tabs should be re-ordered when
   // switching to the main browser UI.
   // Parameters:
   //   groupItem - the groupItem which would be used for re-ordering tabs.
-  setReorderTabsOnHide: function UI_setReorderTabsOnHide(groupItem) {
+  setReorderTabsOnHide: function(groupItem) {
     if (this.isTabViewVisible()) {
       var index = this._reorderTabsOnHide.indexOf(groupItem);
       if (index == -1)
         this._reorderTabsOnHide.push(groupItem);
     }
   },
 
   // ----------
   // Function: setReorderTabItemsOnShow
   // Sets the groupItem which the tab items should be re-ordered when
   // switching to the tab view UI.
   // Parameters:
   //   groupItem - the groupItem which would be used for re-ordering tab items.
-  setReorderTabItemsOnShow: function UI_setReorderTabItemsOnShow(groupItem) {
+  setReorderTabItemsOnShow: function(groupItem) {
     if (!this.isTabViewVisible()) {
       var index = this._reorderTabItemsOnShow.indexOf(groupItem);
       if (index == -1)
         this._reorderTabItemsOnShow.push(groupItem);
     }
   },
   
   // ----------
-  updateTabButton: function UI_updateTabButton() {
+  updateTabButton: function() {
     let exitButton = document.getElementById("exit-button");
     let numberOfGroups = GroupItems.groupItems.length;
 
     exitButton.setAttribute("groups", numberOfGroups);
     gTabView.updateGroupNumberBroadcaster(numberOfGroups);
   },
 
   // ----------
   // Function: getClosestTab
   // Convenience function to get the next tab closest to the entered position
-  getClosestTab: function UI_getClosestTab(tabCenter) {
+  getClosestTab: function(tabCenter) {
     let cl = null;
     let clDist;
     TabItems.getItems().forEach(function (item) {
       if (!item.parent || item.parent.hidden)
         return;
       let testDist = tabCenter.distance(item.bounds.center());
       if (cl==null || testDist < clDist) {
         cl = item;
@@ -934,17 +934,17 @@ let UI = {
       }
     });
     return cl;
   },
 
   // ----------
   // Function: _setupBrowserKeys
   // Sets up the allowed browser keys using key elements.
-  _setupBrowserKeys: function UI__setupKeyWhiteList() {
+  _setupBrowserKeys: function() {
     let keys = {};
 
     [
 #ifdef XP_UNIX
       "quitApplication",
 #else
       "redo",
 #endif
@@ -978,17 +978,17 @@ let UI = {
       keys[code] = key;
     });
     this._browserKeysWithShift = keys;
   },
 
   // ----------
   // Function: _setTabViewFrameKeyHandlers
   // Sets up the key handlers for navigating between tabs within the TabView UI.
-  _setTabViewFrameKeyHandlers: function UI__setTabViewFrameKeyHandlers() {
+  _setTabViewFrameKeyHandlers: function() {
     let self = this;
 
     this._setupBrowserKeys();
 
     iQ(window).keyup(function(event) {
       if (!event.metaKey)
         Keys.meta = false;
     });
@@ -1153,28 +1153,28 @@ let UI = {
         }
       }
     });
   },
 
   // ----------
   // Function: enableSearch
   // Enables the search feature.
-  enableSearch: function UI_enableSearch() {
+  enableSearch: function() {
     if (!Search.isEnabled()) {
       Search.ensureShown();
       Search.switchToInMode();
     }
   },
 
   // ----------
   // Function: _createGroupItemOnDrag
   // Called in response to a mousedown in empty space in the TabView UI;
   // creates a new groupItem based on the user's drag.
-  _createGroupItemOnDrag: function UI__createGroupItemOnDrag(e) {
+  _createGroupItemOnDrag: function(e) {
     const minSize = 60;
     const minMinSize = 15;
 
     let lastActiveGroupItem = GroupItems.getActiveGroupItem();
 
     var startPos = { x: e.clientX, y: e.clientY };
     var phantom = iQ("<div>")
       .addClass("groupItem phantom activeGroupItem dragRegion")
@@ -1184,26 +1184,26 @@ let UI = {
         cursor: "default"
       })
       .appendTo("body");
 
     var item = { // a faux-Item
       container: phantom,
       isAFauxItem: true,
       bounds: {},
-      getBounds: function FauxItem_getBounds() {
+      getBounds: function() {
         return this.container.bounds();
       },
-      setBounds: function FauxItem_setBounds(bounds) {
+      setBounds: function(bounds) {
         this.container.css(bounds);
       },
-      setZ: function FauxItem_setZ(z) {
+      setZ: function(z) {
         // don't set a z-index because we want to force it to be low.
       },
-      setOpacity: function FauxItem_setOpacity(opacity) {
+      setOpacity: function(opacity) {
         this.container.css("opacity", opacity);
       },
       // we don't need to pushAway the phantom item at the end, because
       // when we create a new GroupItem, it'll do the actual pushAway.
       pushAway: function () {},
     };
     item.setBounds(new Rect(startPos.y, startPos.x, 0, 0));
 
@@ -1284,17 +1284,17 @@ let UI = {
   },
 
   // ----------
   // Function: _resize
   // Update the TabView UI contents in response to a window size change.
   // Won't do anything if it doesn't deem the resize necessary.
   // Parameters:
   //   force - true to update even when "unnecessary"; default false
-  _resize: function UI__resize(force) {
+  _resize: function(force) {
     if (!this._pageBounds)
       return;
 
     // Here are reasons why we *won't* resize:
     // 1. Panorama isn't visible (in which case we will resize when we do display)
     // 2. the screen dimensions haven't changed
     // 3. everything on the screen fits and nothing feels cramped
     if (!force && !this.isTabViewVisible())
@@ -1372,17 +1372,17 @@ let UI = {
   
   // ----------
   // Function: shouldResizeItems
   // Returns whether we should resize the items on the screen, based on whether
   // the top-level items fit in the screen or not and whether they feel
   // "cramped" or not.
   // These computations may be done using cached values. The cache can be
   // cleared with UI.clearShouldResizeItems().
-  shouldResizeItems: function UI_shouldResizeItems() {
+  shouldResizeItems: function() {
     let newPageBounds = Items.getPageBounds();
     
     // If we don't have cached cached values...
     if (this._minimalRect === undefined || this._feelsCramped === undefined) {
 
       // Loop through every top-level Item for two operations:
       // 1. check if it is feeling "cramped" due to squishing (a technical term),
       // 2. union its bounds with the minimalRect
@@ -1411,25 +1411,25 @@ let UI = {
       this._feelsCramped;
   },
   
   // ----------
   // Function: clearShouldResizeItems
   // Clear the cache of whether we should resize the items on the Panorama
   // screen, forcing a recomputation on the next UI.shouldResizeItems()
   // call.
-  clearShouldResizeItems: function UI_clearShouldResizeItems() {
+  clearShouldResizeItems: function() {
     delete this._minimalRect;
     delete this._feelsCramped;
   },
 
   // ----------
   // Function: exit
   // Exits TabView UI.
-  exit: function UI_exit() {
+  exit: function() {
     let self = this;
     let zoomedIn = false;
 
     if (Search.isEnabled()) {
       let matcher = Search.createSearchTabMatcher();
       let matches = matcher.matched();
 
       if (matches.length > 0) {
@@ -1489,59 +1489,59 @@ let UI = {
         }
       }
     }
   },
 
   // ----------
   // Function: storageSanity
   // Given storage data for this object, returns true if it looks valid.
-  _storageSanity: function UI__storageSanity(data) {
+  _storageSanity: function(data) {
     if (Utils.isEmptyObject(data))
       return true;
 
     if (!Utils.isRect(data.pageBounds)) {
       Utils.log("UI.storageSanity: bad pageBounds", data.pageBounds);
       data.pageBounds = null;
       return false;
     }
 
     return true;
   },
 
   // ----------
   // Function: _save
   // Saves the data for this object to persistent storage
-  _save: function UI__save() {
+  _save: function() {
     if (!this._frameInitialized)
       return;
 
     var data = {
       pageBounds: this._pageBounds
     };
 
     if (this._storageSanity(data))
       Storage.saveUIData(gWindow, data);
   },
 
   // ----------
   // Function: _saveAll
   // Saves all data associated with TabView.
-  _saveAll: function UI__saveAll() {
+  _saveAll: function() {
     this._save();
     GroupItems.saveAll();
     TabItems.saveAll();
   },
 
   // ----------
   // Function: notifySessionRestoreEnabled
   // Notify the user that session restore has been automatically enabled
   // by showing a banner that expects no user interaction. It fades out after
   // some seconds.
-  notifySessionRestoreEnabled: function UI_notifySessionRestoreEnabled() {
+  notifySessionRestoreEnabled: function() {
     let brandBundle = gWindow.document.getElementById("bundle_brand");
     let brandShortName = brandBundle.getString("brandShortName");
     let notificationText = tabviewBundle.formatStringFromName(
       "tabview.notification.sessionStore", [brandShortName], 1);
 
     let banner = iQ("<div>")
       .text(notificationText)
       .addClass("banner")
diff --git a/browser/components/translation/Translation.jsm b/browser/components/translation/Translation.jsm
--- a/browser/components/translation/Translation.jsm
+++ b/browser/components/translation/Translation.jsm
@@ -474,17 +474,17 @@ TranslationProvider.prototype = Object.f
   __proto__: Metrics.Provider.prototype,
 
   name: "org.mozilla.translation",
 
   measurementTypes: [
     TranslationMeasurement1,
   ],
 
-  recordTranslationOpportunity: function (language, date=new Date()) {
+  recordTranslationOpportunity: function()) {
     let m = this.getMeasurement(TranslationMeasurement1.prototype.name,
                                 TranslationMeasurement1.prototype.version);
 
     return this._enqueueTelemetryStorageTask(function* recordTask() {
       yield m.incrementDailyCounter("translationOpportunityCount", date);
 
       let langCounts = yield m._getDailyLastTextFieldAsJSON(
         "translationOpportunityCountsByLanguage", date);
@@ -493,17 +493,17 @@ TranslationProvider.prototype = Object.f
       langCounts = JSON.stringify(langCounts);
 
       yield m.setDailyLastText("translationOpportunityCountsByLanguage",
                                langCounts, date);
 
     }.bind(this));
   },
 
-  recordMissedTranslationOpportunity: function (language, date=new Date()) {
+  recordMissedTranslationOpportunity: function()) {
     let m = this.getMeasurement(TranslationMeasurement1.prototype.name,
                                 TranslationMeasurement1.prototype.version);
 
     return this._enqueueTelemetryStorageTask(function* recordTask() {
       yield m.incrementDailyCounter("missedTranslationOpportunityCount", date);
 
       let langCounts = yield m._getDailyLastTextFieldAsJSON(
         "missedTranslationOpportunityCountsByLanguage", date);
@@ -512,26 +512,26 @@ TranslationProvider.prototype = Object.f
       langCounts = JSON.stringify(langCounts);
 
       yield m.setDailyLastText("missedTranslationOpportunityCountsByLanguage",
                                langCounts, date);
 
     }.bind(this));
   },
 
-  recordAutoRejectedTranslationOffer: function (date=new Date()) {
+  recordAutoRejectedTranslationOffer: function()) {
     let m = this.getMeasurement(TranslationMeasurement1.prototype.name,
                                 TranslationMeasurement1.prototype.version);
 
     return this._enqueueTelemetryStorageTask(function* recordTask() {
       yield m.incrementDailyCounter("autoRejectedTranslationOffer", date);
     }.bind(this));
   },
 
-  recordTranslation: function (langFrom, langTo, numCharacters, date=new Date()) {
+  recordTranslation: function()) {
     let m = this.getMeasurement(TranslationMeasurement1.prototype.name,
                                 TranslationMeasurement1.prototype.version);
 
     return this._enqueueTelemetryStorageTask(function* recordTask() {
       yield m.incrementDailyCounter("pageTranslatedCount", date);
       yield m.incrementDailyCounter("charactersTranslatedCount", date,
                                     numCharacters);
 
diff --git a/browser/components/translation/test/browser_translation_exceptions.js b/browser/components/translation/test/browser_translation_exceptions.js
--- a/browser/components/translation/test/browser_translation_exceptions.js
+++ b/browser/components/translation/test/browser_translation_exceptions.js
@@ -88,17 +88,17 @@ function waitForWindowLoad(aWin) {
   return deferred.promise;
 }
 
 
 let gTests = [
 
 {
   desc: "clean exception lists at startup",
-  run: function checkNeverForLanguage() {
+  run: function() {
     is(getLanguageExceptions().length, 0,
        "we start with an empty list of languages to never translate");
     is(getDomainExceptions().length, 0,
        "we start with an empty list of sites to never translate");
   }
 },
 
 {
diff --git a/browser/devtools/commandline/test/browser_gcli_cli2.js b/browser/devtools/commandline/test/browser_gcli_cli2.js
--- a/browser/devtools/commandline/test/browser_gcli_cli2.js
+++ b/browser/devtools/commandline/test/browser_gcli_cli2.js
@@ -407,17 +407,17 @@ exports.testSingleFloat = function(optio
 
 exports.testElementWeb = function(options) {
   var inputElement = options.isNoDom ?
       null :
       options.window.document.getElementById('gcli-input');
 
   return helpers.audit(options, [
     {
-      skipIf: function gcliInputElementExists() {
+      skipIf: function() {
         return inputElement == null;
       },
       setup:    'tse #gcli-input',
       check: {
         input:  'tse #gcli-input',
         hints:                 ' [options]',
         markup: 'VVVVVVVVVVVVVVV',
         cursor: 15,
diff --git a/browser/devtools/commandline/test/browser_gcli_intro.js b/browser/devtools/commandline/test/browser_gcli_intro.js
--- a/browser/devtools/commandline/test/browser_gcli_intro.js
+++ b/browser/devtools/commandline/test/browser_gcli_intro.js
@@ -40,17 +40,17 @@ function test() {
 
 // <INJECTED SOURCE:END>
 
 // var helpers = require('./helpers');
 
 exports.testIntroStatus = function(options) {
   return helpers.audit(options, [
     {
-      skipRemainingIf: function commandIntroMissing() {
+      skipRemainingIf: function() {
         return options.requisition.system.commands.get('intro') == null;
       },
       setup:    'intro',
       check: {
         typed:  'intro',
         markup: 'VVVVV',
         status: 'VALID',
         hints: ''
diff --git a/browser/devtools/commandline/test/browser_gcli_keyboard1.js b/browser/devtools/commandline/test/browser_gcli_keyboard1.js
--- a/browser/devtools/commandline/test/browser_gcli_keyboard1.js
+++ b/browser/devtools/commandline/test/browser_gcli_keyboard1.js
@@ -70,35 +70,35 @@ exports.testSimple = function(options) {
       check: { input: 'tsg aaa ', cursor: 8 }
     }
   ]);
 };
 
 exports.testScript = function(options) {
   return helpers.audit(options, [
     {
-      skipIf: function commandJsMissing() {
+      skipIf: function() {
         return options.requisition.system.commands.get('{') == null;
       },
       setup: '{ wind<TAB>',
       check: { input: '{ window' }
     },
     {
-      skipIf: function commandJsMissing() {
+      skipIf: function() {
         return options.requisition.system.commands.get('{') == null;
       },
       setup: '{ window.docum<TAB>',
       check: { input: '{ window.document' }
     }
   ]);
 };
 
 exports.testJsdom = function(options) {
   return helpers.audit(options, [
     {
-      skipIf: function jsDomOrCommandJsMissing() {
+      skipIf: function() {
         return options.requisition.system.commands.get('{') == null;
       },
       setup: '{ window.document.titl<TAB>',
       check: { input: '{ window.document.title ' }
     }
   ]);
 };
diff --git a/browser/devtools/commandline/test/browser_gcli_pref2.js b/browser/devtools/commandline/test/browser_gcli_pref2.js
--- a/browser/devtools/commandline/test/browser_gcli_pref2.js
+++ b/browser/devtools/commandline/test/browser_gcli_pref2.js
@@ -128,17 +128,17 @@ exports.testPrefExec = function(options)
       },
       post: function() {
         assert.is(mockSettings.tempNumber.value, 42, 'reset to 42');
 
         allowSet.value = initialAllowSet;
       }
     },
     {
-      skipRemainingIf: function commandPrefListMissing() {
+      skipRemainingIf: function() {
         return options.requisition.system.commands.get('pref list') == null;
       },
       setup:    'pref list tempNum',
       check: {
         args: {
           command: { name: 'pref list' },
           search: { value: 'tempNum' }
         }
diff --git a/browser/devtools/debugger/debugger-panes.js b/browser/devtools/debugger/debugger-panes.js
--- a/browser/devtools/debugger/debugger-panes.js
+++ b/browser/devtools/debugger/debugger-panes.js
@@ -1343,17 +1343,17 @@ TracerView.prototype = Heritage.extend(W
   /**
    * Handler for the widget's "select" event. Displays parameters, exception, or
    * return value depending on whether the selected trace is a call, throw, or
    * return respectively.
    *
    * @param Object traceItem
    *        The selected trace item.
    */
-  _onSelect: function _onSelect({ detail: traceItem }) {
+  _onSelect: function({ detail: traceItem }) {
     if (!traceItem) {
       return;
     }
 
     const data = traceItem.attachment.trace;
     const { location: { url, line } } = data;
     DebuggerView.setEditorLocation(
       DebuggerView.Sources.getActorForLocation({ url }),
diff --git a/browser/devtools/debugger/test/code_function-search-01.js b/browser/devtools/debugger/test/code_function-search-01.js
--- a/browser/devtools/debugger/test/code_function-search-01.js
+++ b/browser/devtools/debugger/test/code_function-search-01.js
@@ -3,40 +3,40 @@
 
 function test() {
   // Blah! First source!
 }
 
 test.prototype = {
   anonymousExpression: function() {
   },
-  namedExpression: function NAME() {
+  namedExpression: function() {
   },
   sub: {
     sub: {
       sub: {
       }
     }
   }
 };
 
 var foo = {
   a_test: function() {
   },
-  n_test: function x() {
+  n_test: function() {
   },
   sub: {
     a_test: function() {
     },
-    n_test: function y() {
+    n_test: function() {
     },
     sub: {
       a_test: function() {
       },
-      n_test: function z() {
+      n_test: function() {
       },
       sub: {
-        test_SAME_NAME: function test_SAME_NAME() {
+        test_SAME_NAME: function() {
         }
       }
     }
   }
 };
diff --git a/browser/devtools/debugger/test/code_function-search-03.js b/browser/devtools/debugger/test/code_function-search-03.js
--- a/browser/devtools/debugger/test/code_function-search-03.js
+++ b/browser/devtools/debugger/test/code_function-search-03.js
@@ -2,31 +2,31 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 window.addEventListener("bogus", function namedEventListener() {
   // Blah! Third source!
 });
 
 try {
   var bar = foo.sub.sub.test({
-    a: function A() {
+    a: function() {
     }
   });
 
   bar.alpha = foo.sub.sub.test({
-    b: function B() {
+    b: function() {
     }
   });
 
   bar.alpha.beta = new X(Y(Z(foo.sub.sub.test({
-    c: function C() {
+    c: function() {
     }
   }))));
 
   this.theta = new X(new Y(new Z(new foo.sub.sub.test({
-    d: function D() {
+    d: function() {
     }
   }))));
 
   var fun = foo = bar = this.t_foo = window.w_bar = function baz() {};
 
 } catch (e) {
 }
diff --git a/browser/devtools/debugger/test/testactors.js b/browser/devtools/debugger/test/testactors.js
--- a/browser/devtools/debugger/test/testactors.js
+++ b/browser/devtools/debugger/test/testactors.js
@@ -5,22 +5,22 @@ function TestActor1(aConnection, aTab)
 {
   this.conn = aConnection;
   this.tab = aTab;
 }
 
 TestActor1.prototype = {
   actorPrefix: "test_one",
 
-  grip: function TA1_grip() {
+  grip: function() {
     return { actor: this.actorID,
              test: "TestActor1" };
   },
 
-  onPing: function TA1_onPing() {
+  onPing: function() {
     return { pong: "pong" };
   }
 };
 
 TestActor1.prototype.requestTypes = {
   "ping": TestActor1.prototype.onPing
 };
 
diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -19,71 +19,71 @@ function FontInspector(inspector, window
 {
   this.inspector = inspector;
   this.pageStyle = this.inspector.pageStyle;
   this.chromeDoc = window.document;
   this.init();
 }
 
 FontInspector.prototype = {
-  init: function FI_init() {
+  init: function() {
     this.update = this.update.bind(this);
     this.onNewNode = this.onNewNode.bind(this);
     this.inspector.selection.on("new-node", this.onNewNode);
     this.inspector.sidebar.on("fontinspector-selected", this.onNewNode);
     this.showAll = this.showAll.bind(this);
     this.showAllButton = this.chromeDoc.getElementById("showall");
     this.showAllButton.addEventListener("click", this.showAll);
     this.update();
   },
 
   /**
    * Is the fontinspector visible in the sidebar?
    */
-  isActive: function FI_isActive() {
+  isActive: function() {
     return this.inspector.sidebar &&
            this.inspector.sidebar.getCurrentTabID() == "fontinspector";
   },
 
   /**
    * Remove listeners.
    */
-  destroy: function FI_destroy() {
+  destroy: function() {
     this.chromeDoc = null;
     this.inspector.sidebar.off("fontinspector-selected", this.onNewNode);
     this.inspector.selection.off("new-node", this.onNewNode);
     this.showAllButton.removeEventListener("click", this.showAll);
   },
 
   /**
    * Selection 'new-node' event handler.
    */
-  onNewNode: function FI_onNewNode() {
+  onNewNode: function() {
     if (this.isActive() &&
         this.inspector.selection.isConnected() &&
         this.inspector.selection.isElementNode()) {
       this.undim();
       this.update();
     } else {
       this.dim();
     }
   },
 
   /**
    * Hide the font list. No node are selected.
    */
-  dim: function FI_dim() {
+  dim: function() {
     this.chromeDoc.body.classList.add("dim");
     this.chromeDoc.querySelector("#all-fonts").innerHTML = "";
   },
 
   /**
    * Show the font list. A node is selected.
    */
-  undim: function FI_undim() {
+  undim: function() {
     this.chromeDoc.body.classList.remove("dim");
   },
 
  /**
   * Retrieve all the font info for the selected node and display it.
   */
   update: Task.async(function*(showAllFonts) {
     let node = this.inspector.selection.nodeFront;
@@ -135,17 +135,17 @@ FontInspector.prototype = {
     }
 
     this.inspector.emit("fontinspector-updated");
   }),
 
   /**
    * Display the information of one font.
    */
-  render: function FI_render(font) {
+  render: function(font) {
     let s = this.chromeDoc.querySelector("#template > section");
     s = s.cloneNode(true);
 
     s.querySelector(".font-name").textContent = font.name;
     s.querySelector(".font-css-name").textContent = font.CSSFamilyName;
 
     if (font.URI) {
       s.classList.add("is-remote");
@@ -173,17 +173,17 @@ FontInspector.prototype = {
     preview.src = font.previewUrl;
 
     this.chromeDoc.querySelector("#all-fonts").appendChild(s);
   },
 
   /**
    * Show all fonts for the document (including iframes)
    */
-  showAll: function FI_showAll() {
+  showAll: function() {
     this.update(true);
   },
 }
 
 window.setPanel = function(panel) {
   window.fontInspector = new FontInspector(panel, window);
 }
 
diff --git a/browser/devtools/framework/gDevTools.jsm b/browser/devtools/framework/gDevTools.jsm
--- a/browser/devtools/framework/gDevTools.jsm
+++ b/browser/devtools/framework/gDevTools.jsm
@@ -99,17 +99,17 @@ DevTools.prototype = {
    * - url: URL pointing to a XUL/XHTML document containing the user interface
    *        (string|required)
    * - label: Localized name for the tool to be displayed to the user
    *          (string|required)
    * - build: Function that takes an iframe, which has been populated with the
    *          markup from |url|, and also the toolbox containing the panel.
    *          And returns an instance of ToolPanel (function|required)
    */
-  registerTool: function DT_registerTool(toolDefinition) {
+  registerTool: function(toolDefinition) {
     let toolId = toolDefinition.id;
 
     if (!toolId || FORBIDDEN_IDS.has(toolId)) {
       throw new Error("Invalid definition.id");
     }
 
     // Make sure that additional tools will always be able to be hidden.
     // When being called from main.js, defaultTools has not yet been exported.
@@ -129,17 +129,17 @@ DevTools.prototype = {
    *
    * @param {string|object} tool
    *        Definition or the id of the tool to unregister. Passing the
    *        tool id should be avoided as it is a temporary measure.
    * @param {boolean} isQuitApplication
    *        true to indicate that the call is due to app quit, so we should not
    *        cause a cascade of costly events
    */
-  unregisterTool: function DT_unregisterTool(tool, isQuitApplication) {
+  unregisterTool: function(tool, isQuitApplication) {
     let toolId = null;
     if (typeof tool == "string") {
       toolId = tool;
       tool = this._tools.get(tool);
     }
     else {
       toolId = tool.id;
     }
@@ -148,27 +148,27 @@ DevTools.prototype = {
     if (!isQuitApplication) {
       this.emit("tool-unregistered", tool);
     }
   },
 
   /**
    * Sorting function used for sorting tools based on their ordinals.
    */
-  ordinalSort: function DT_ordinalSort(d1, d2) {
+  ordinalSort: function(d1, d2) {
     let o1 = (typeof d1.ordinal == "number") ? d1.ordinal : MAX_ORDINAL;
     let o2 = (typeof d2.ordinal == "number") ? d2.ordinal : MAX_ORDINAL;
     return o1 - o2;
   },
 
-  getDefaultTools: function DT_getDefaultTools() {
+  getDefaultTools: function() {
     return devtools.defaultTools.sort(this.ordinalSort);
   },
 
-  getAdditionalTools: function DT_getAdditionalTools() {
+  getAdditionalTools: function() {
     let tools = [];
     for (let [key, value] of this._tools) {
       if (devtools.defaultTools.indexOf(value) == -1) {
         tools.push(value);
       }
     }
     return tools.sort(this.ordinalSort);
   },
@@ -177,17 +177,17 @@ DevTools.prototype = {
    * Get a tool definition if it exists and is enabled.
    *
    * @param {string} toolId
    *        The id of the tool to show
    *
    * @return {ToolDefinition|null} tool
    *         The ToolDefinition for the id or null.
    */
-  getToolDefinition: function DT_getToolDefinition(toolId) {
+  getToolDefinition: function(toolId) {
     let tool = this._tools.get(toolId);
     if (!tool) {
       return null;
     } else if (!tool.visibilityswitch) {
       return tool;
     }
 
     let enabled;
@@ -202,17 +202,17 @@ DevTools.prototype = {
 
   /**
    * Allow ToolBoxes to get at the list of tools that they should populate
    * themselves with.
    *
    * @return {Map} tools
    *         A map of the the tool definitions registered in this instance
    */
-  getToolDefinitionMap: function DT_getToolDefinitionMap() {
+  getToolDefinitionMap: function() {
     let tools = new Map();
 
     for (let [id, definition] of this._tools) {
       if (this.getToolDefinition(id)) {
         tools.set(id, definition);
       }
     }
 
@@ -222,17 +222,17 @@ DevTools.prototype = {
   /**
    * Tools have an inherent ordering that can't be represented in a Map so
    * getToolDefinitionArray provides an alternative representation of the
    * definitions sorted by ordinal value.
    *
    * @return {Array} tools
    *         A sorted array of the tool definitions registered in this instance
    */
-  getToolDefinitionArray: function DT_getToolDefinitionArray() {
+  getToolDefinitionArray: function() {
     let definitions = [];
 
     for (let [id, definition] of this._tools) {
       if (this.getToolDefinition(id)) {
         definitions.push(definition);
       }
     }
 
@@ -256,17 +256,17 @@ DevTools.prototype = {
    *              the theme (array|required)
    * - onApply: Function that is executed by the framework when the theme
    *            is applied. The function takes the current iframe window
    *            and the previous theme id as arguments (function)
    * - onUnapply: Function that is executed by the framework when the theme
    *            is unapplied. The function takes the current iframe window
    *            and the new theme id as arguments (function)
    */
-  registerTheme: function DT_registerTheme(themeDefinition) {
+  registerTheme: function(themeDefinition) {
     let themeId = themeDefinition.id;
 
     if (!themeId) {
       throw new Error("Invalid theme id");
     }
 
     if (this._themes.get(themeId)) {
       throw new Error("Theme with the same id is already registered");
@@ -279,17 +279,17 @@ DevTools.prototype = {
 
   /**
    * Removes an existing theme from the list of registered themes.
    * Needed so that add-ons can remove themselves when they are deactivated
    *
    * @param {string|object} theme
    *        Definition or the id of the theme to unregister.
    */
-  unregisterTheme: function DT_unregisterTheme(theme) {
+  unregisterTheme: function(theme) {
     let themeId = null;
     if (typeof theme == "string") {
       themeId = theme;
       theme = this._themes.get(theme);
     }
     else {
       themeId = theme.id;
     }
@@ -320,31 +320,31 @@ DevTools.prototype = {
    * Get a theme definition if it exists.
    *
    * @param {string} themeId
    *        The id of the theme
    *
    * @return {ThemeDefinition|null} theme
    *         The ThemeDefinition for the id or null.
    */
-  getThemeDefinition: function DT_getThemeDefinition(themeId) {
+  getThemeDefinition: function(themeId) {
     let theme = this._themes.get(themeId);
     if (!theme) {
       return null;
     }
     return theme;
   },
 
   /**
    * Get map of registered themes.
    *
    * @return {Map} themes
    *         A map of the the theme definitions registered in this instance
    */
-  getThemeDefinitionMap: function DT_getThemeDefinitionMap() {
+  getThemeDefinitionMap: function() {
     let themes = new Map();
 
     for (let [id, definition] of this._themes) {
       if (this.getThemeDefinition(id)) {
         themes.set(id, definition);
       }
     }
 
@@ -352,17 +352,17 @@ DevTools.prototype = {
   },
 
   /**
    * Get registered themes definitions sorted by ordinal value.
    *
    * @return {Array} themes
    *         A sorted array of the theme definitions registered in this instance
    */
-  getThemeDefinitionArray: function DT_getThemeDefinitionArray() {
+  getThemeDefinitionArray: function() {
     let definitions = [];
 
     for (let [id, definition] of this._themes) {
       if (this.getThemeDefinition(id)) {
         definitions.push(definition);
       }
     }
 
@@ -442,40 +442,40 @@ DevTools.prototype = {
    * Return the toolbox for a given target.
    *
    * @param  {object} target
    *         Target value e.g. the target that owns this toolbox
    *
    * @return {Toolbox} toolbox
    *         The toolbox that is debugging the given target
    */
-  getToolbox: function DT_getToolbox(target) {
+  getToolbox: function(target) {
     return this._toolboxes.get(target);
   },
 
   /**
    * Close the toolbox for a given target
    *
    * @return promise
    *         This promise will resolve to false if no toolbox was found
    *         associated to the target. true, if the toolbox was successfully
    *         closed.
    */
-  closeToolbox: function DT_closeToolbox(target) {
+  closeToolbox: function(target) {
     let toolbox = this._toolboxes.get(target);
     if (toolbox == null) {
       return promise.resolve(false);
     }
     return toolbox.destroy().then(() => true);
   },
 
   /**
    * Called to tear down a tools provider.
    */
-  _teardown: function DT_teardown() {
+  _teardown: function() {
     for (let [target, toolbox] of this._toolboxes) {
       toolbox.destroy();
     }
   },
 
   /**
    * All browser windows have been closed, tidy up remaining objects.
    */
@@ -796,17 +796,17 @@ let gDevToolsBrowser = {
   },
 
   /**
    * Add this DevTools's presence to a browser window's document
    *
    * @param {XULDocument} doc
    *        The document to which menuitems and handlers are to be added
    */
-  registerBrowserWindow: function DT_registerBrowserWindow(win) {
+  registerBrowserWindow: function(win) {
     this.updateCommandAvailability(win);
     this.ensurePrefObserver();
     gDevToolsBrowser._trackedBrowserWindows.add(win);
     gDevToolsBrowser._addAllToolsToMenu(win.document);
 
     if (this._isFirebugInstalled()) {
       let broadcaster = win.document.getElementById("devtoolsMenuBroadcaster_DevToolbox");
       broadcaster.removeAttribute("key");
@@ -823,33 +823,33 @@ let gDevToolsBrowser = {
    * to be detached and reattached to make sure the <key> is taken into
    * account (see bug 832984).
    *
    * @param {XULDocument} doc
    *        The document to which keys are to be added
    * @param {XULElement} or {DocumentFragment} keys
    *        Keys to add
    */
-  attachKeybindingsToBrowser: function DT_attachKeybindingsToBrowser(doc, keys) {
+  attachKeybindingsToBrowser: function(doc, keys) {
     let devtoolsKeyset = doc.getElementById("devtoolsKeyset");
 
     if (!devtoolsKeyset) {
       devtoolsKeyset = doc.createElement("keyset");
       devtoolsKeyset.setAttribute("id", "devtoolsKeyset");
     }
     devtoolsKeyset.appendChild(keys);
     let mainKeyset = doc.getElementById("mainKeyset");
     mainKeyset.parentNode.insertBefore(devtoolsKeyset, mainKeyset);
   },
 
   /**
    * Hook the JS debugger tool to the "Debug Script" button of the slow script
    * dialog.
    */
-  setSlowScriptDebugHandler: function DT_setSlowScriptDebugHandler() {
+  setSlowScriptDebugHandler: function() {
     let debugService = Cc["@mozilla.org/dom/slow-script-debug;1"]
                          .getService(Ci.nsISlowScriptDebug);
     let tm = Cc["@mozilla.org/thread-manager;1"].getService(Ci.nsIThreadManager);
 
     function slowScriptDebugHandler(aTab, aCallback) {
       let target = devtools.TargetFactory.forTab(aTab);
 
       gDevTools.showToolbox(target, "jsdebugger").then(toolbox => {
@@ -921,39 +921,39 @@ let gDevToolsBrowser = {
 
       slowScriptDebugHandler(tab, callback);
     };
   },
 
   /**
    * Unset the slow script debug handler.
    */
-  unsetSlowScriptDebugHandler: function DT_unsetSlowScriptDebugHandler() {
+  unsetSlowScriptDebugHandler: function() {
     let debugService = Cc["@mozilla.org/dom/slow-script-debug;1"]
                          .getService(Ci.nsISlowScriptDebug);
     debugService.activationHandler = undefined;
   },
 
   /**
    * Detect the presence of a Firebug.
    *
    * @return promise
    */
-  _isFirebugInstalled: function DT_isFirebugInstalled() {
+  _isFirebugInstalled: function() {
     let bootstrappedAddons = Services.prefs.getCharPref("extensions.bootstrappedAddons");
     return bootstrappedAddons.indexOf("firebug@software.joehewitt.com") != -1;
   },
 
   /**
    * Add the menuitem for a tool to all open browser windows.
    *
    * @param {object} toolDefinition
    *        properties of the tool to add
    */
-  _addToolToWindows: function DT_addToolToWindows(toolDefinition) {
+  _addToolToWindows: function(toolDefinition) {
     // No menu item or global shortcut is required for options panel.
     if (!toolDefinition.inMenu) {
       return;
     }
 
     // Skip if the tool is disabled.
     try {
       if (toolDefinition.visibilityswitch &&
@@ -1027,17 +1027,17 @@ let gDevToolsBrowser = {
   },
 
   /**
    * Add all tools to the developer tools menu of a window.
    *
    * @param {XULDocument} doc
    *        The document to which the tool items are to be added.
    */
-  _addAllToolsToMenu: function DT_addAllToolsToMenu(doc) {
+  _addAllToolsToMenu: function(doc) {
     let fragCommands = doc.createDocumentFragment();
     let fragKeys = doc.createDocumentFragment();
     let fragBroadcasters = doc.createDocumentFragment();
     let fragAppMenuItems = doc.createDocumentFragment();
     let fragMenuItems = doc.createDocumentFragment();
 
     for (let toolDefinition of gDevTools.getToolDefinitionArray()) {
       if (!toolDefinition.inMenu) {
@@ -1081,17 +1081,17 @@ let gDevToolsBrowser = {
   /**
    * Add a menu entry for a tool definition
    *
    * @param {string} toolDefinition
    *        Tool definition of the tool to add a menu entry.
    * @param {XULDocument} doc
    *        The document to which the tool menu item is to be added.
    */
-  _createToolMenuElements: function DT_createToolMenuElements(toolDefinition, doc) {
+  _createToolMenuElements: function(toolDefinition, doc) {
     let id = toolDefinition.id;
 
     // Prevent multiple entries for the same tool.
     if (doc.getElementById("Tools:" + id)) {
       return;
     }
 
     let cmd = doc.createElement("command");
@@ -1143,17 +1143,17 @@ let gDevToolsBrowser = {
       menuitem: menuitem
     };
   },
 
   /**
    * Update the "Toggle Tools" checkbox in the developer tools menu. This is
    * called when a toolbox is created or destroyed.
    */
-  _updateMenuCheckbox: function DT_updateMenuCheckbox() {
+  _updateMenuCheckbox: function() {
     for (let win of gDevToolsBrowser._trackedBrowserWindows) {
 
       let hasToolbox = false;
       if (devtools.TargetFactory.isKnownTab(win.gBrowser.selectedTab)) {
         let target = devtools.TargetFactory.forTab(win.gBrowser.selectedTab);
         if (gDevTools._toolboxes.has(target)) {
           hasToolbox = true;
         }
@@ -1167,29 +1167,29 @@ let gDevToolsBrowser = {
       }
     }
   },
 
   /**
    * Connects to the SPS profiler when the developer tools are open. This is
    * necessary because of the WebConsole's `profile` and `profileEnd` methods.
    */
-  _connectToProfiler: function DT_connectToProfiler(event, toolbox) {
+  _connectToProfiler: function(event, toolbox) {
     let SharedProfilerUtils = devtools.require("devtools/profiler/shared");
     let connection = SharedProfilerUtils.getProfilerConnection(toolbox);
     connection.open();
   },
 
   /**
    * Remove the menuitem for a tool to all open browser windows.
    *
    * @param {string} toolId
    *        id of the tool to remove
    */
-  _removeToolFromWindows: function DT_removeToolFromWindows(toolId) {
+  _removeToolFromWindows: function(toolId) {
     for (let win of gDevToolsBrowser._trackedBrowserWindows) {
       gDevToolsBrowser._removeToolFromMenu(toolId, win.document);
     }
 
     if (toolId === "jsdebugger") {
       gDevToolsBrowser.unsetSlowScriptDebugHandler();
     }
   },
@@ -1197,17 +1197,17 @@ let gDevToolsBrowser = {
   /**
    * Remove a tool's menuitem from a window
    *
    * @param {string} toolId
    *        Id of the tool to add a menu entry for
    * @param {XULDocument} doc
    *        The document to which the tool menu item is to be removed from
    */
-  _removeToolFromMenu: function DT_removeToolFromMenu(toolId, doc) {
+  _removeToolFromMenu: function(toolId, doc) {
     let command = doc.getElementById("Tools:" + toolId);
     if (command) {
       command.parentNode.removeChild(command);
     }
 
     let key = doc.getElementById("key_" + toolId);
     if (key) {
       key.parentNode.removeChild(key);
@@ -1231,17 +1231,17 @@ let gDevToolsBrowser = {
 
   /**
    * Called on browser unload to remove menu entries, toolboxes and event
    * listeners from the closed browser window.
    *
    * @param  {XULWindow} win
    *         The window containing the menu entry
    */
-  forgetBrowserWindow: function DT_forgetBrowserWindow(win) {
+  forgetBrowserWindow: function(win) {
     gDevToolsBrowser._trackedBrowserWindows.delete(win);
 
     // Destroy toolboxes for closed window
     for (let [target, toolbox] of gDevTools._toolboxes) {
       if (toolbox.frame && toolbox.frame.ownerDocument.defaultView == win) {
         toolbox.destroy();
       }
     }
diff --git a/browser/devtools/framework/target.js b/browser/devtools/framework/target.js
--- a/browser/devtools/framework/target.js
+++ b/browser/devtools/framework/target.js
@@ -23,17 +23,17 @@ const promiseTargets = new WeakMap();
 exports.TargetFactory = {
   /**
    * Construct a Target
    * @param {XULTab} tab
    *        The tab to use in creating a new target.
    *
    * @return A target object
    */
-  forTab: function TF_forTab(tab) {
+  forTab: function(tab) {
     let target = targets.get(tab);
     if (target == null) {
       target = new TabTarget(tab);
       targets.set(tab, target);
     }
     return target;
   },
 
@@ -45,57 +45,57 @@ exports.TargetFactory = {
    *          form: the remote protocol form of a tab,
    *          client: a DebuggerClient instance
    *                  (caller owns this and is responsible for closing),
    *          chrome: true if the remote target is the whole process
    *        }
    *
    * @return A promise of a target object
    */
-  forRemoteTab: function TF_forRemoteTab(options) {
+  forRemoteTab: function(options) {
     let targetPromise = promiseTargets.get(options);
     if (targetPromise == null) {
       let target = new TabTarget(options);
       targetPromise = target.makeRemote().then(() => target);
       promiseTargets.set(options, targetPromise);
     }
     return targetPromise;
   },
 
   /**
    * Creating a target for a tab that is being closed is a problem because it
    * allows a leak as a result of coming after the close event which normally
    * clears things up. This function allows us to ask if there is a known
    * target for a tab without creating a target
    * @return true/false
    */
-  isKnownTab: function TF_isKnownTab(tab) {
+  isKnownTab: function(tab) {
     return targets.has(tab);
   },
 
   /**
    * Construct a Target
    * @param {nsIDOMWindow} window
    *        The chromeWindow to use in creating a new target
    * @return A target object
    */
-  forWindow: function TF_forWindow(window) {
+  forWindow: function(window) {
     let target = targets.get(window);
     if (target == null) {
       target = new WindowTarget(window);
       targets.set(window, target);
     }
     return target;
   },
 
   /**
    * Get all of the targets known to the local browser instance
    * @return An array of target objects
    */
-  allTargets: function TF_allTargets() {
+  allTargets: function() {
     let windows = [];
     let wm = Cc["@mozilla.org/appshell/window-mediator;1"]
                        .getService(Ci.nsIWindowMediator);
     let en = wm.getXULWindowEnumerator(null);
     while (en.hasMoreElements()) {
       windows.push(en.getNext());
     }
 
@@ -372,17 +372,17 @@ TabTarget.prototype = {
     return !!this._isThreadPaused;
   },
 
   /**
    * Adds remote protocol capabilities to the target, so that it can be used
    * for tools that support the Remote Debugging Protocol even for local
    * connections.
    */
-  makeRemote: function TabTarget_makeRemote() {
+  makeRemote: function() {
     if (this._remote) {
       return this._remote.promise;
     }
 
     this._remote = promise.defer();
 
     if (this.isLocalTab) {
       // Since a remote protocol connection will be made, let's start the
@@ -446,41 +446,41 @@ TabTarget.prototype = {
     }
 
     return this._remote.promise;
   },
 
   /**
    * Listen to the different events.
    */
-  _setupListeners: function TabTarget__setupListeners() {
+  _setupListeners: function() {
     this._webProgressListener = new TabWebProgressListener(this);
     this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
     this.tab.addEventListener("TabClose", this);
     this.tab.parentNode.addEventListener("TabSelect", this);
     this.tab.ownerDocument.defaultView.addEventListener("unload", this);
   },
 
   /**
    * Teardown event listeners.
    */
-  _teardownListeners: function TabTarget__teardownListeners() {
+  _teardownListeners: function() {
     if (this._webProgressListener) {
       this._webProgressListener.destroy();
     }
 
     this._tab.ownerDocument.defaultView.removeEventListener("unload", this);
     this._tab.removeEventListener("TabClose", this);
     this._tab.parentNode.removeEventListener("TabSelect", this);
   },
 
   /**
    * Setup listeners for remote debugging, updating existing ones as necessary.
    */
-  _setupRemoteListeners: function TabTarget__setupRemoteListeners() {
+  _setupRemoteListeners: function() {
     this.client.addListener("closed", this.destroy);
 
     this._onTabDetached = (aType, aPacket) => {
       // We have to filter message to ensure that this detach is for this tab
       if (aPacket.from == this._form.actor) {
         this.destroy();
       }
     };
@@ -510,17 +510,17 @@ TabTarget.prototype = {
       this.emit("frame-update", aPacket);
     };
     this.client.addListener("frameUpdate", this._onFrameUpdate);
   },
 
   /**
    * Teardown listeners for remote debugging.
    */
-  _teardownRemoteListeners: function TabTarget__teardownRemoteListeners() {
+  _teardownRemoteListeners: function() {
     this.client.removeListener("closed", this.destroy);
     this.client.removeListener("tabNavigated", this._onTabNavigated);
     this.client.removeListener("tabDetached", this._onTabDetached);
     this.client.removeListener("frameUpdate", this._onFrameUpdate);
   },
 
   /**
    * Handle tabs events.
@@ -611,17 +611,17 @@ TabTarget.prototype = {
     }
 
     return this._destroyer.promise;
   },
 
   /**
    * Clean up references to what this target points to.
    */
-  _cleanup: function TabTarget__cleanup() {
+  _cleanup: function() {
     if (this._tab) {
       targets.delete(this._tab);
     } else {
       promiseTargets.delete(this._form);
     }
     this.activeTab = null;
     this._client = null;
     this._tab = null;
@@ -645,17 +645,17 @@ function TabWebProgressListener(aTarget)
   this.target = aTarget;
 }
 
 TabWebProgressListener.prototype = {
   target: null,
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener, Ci.nsISupportsWeakReference]),
 
-  onStateChange: function TWPL_onStateChange(progress, request, flag, status) {
+  onStateChange: function(progress, request, flag, status) {
     let isStart = flag & Ci.nsIWebProgressListener.STATE_START;
     let isDocument = flag & Ci.nsIWebProgressListener.STATE_IS_DOCUMENT;
     let isNetwork = flag & Ci.nsIWebProgressListener.STATE_IS_NETWORK;
     let isRequest = flag & Ci.nsIWebProgressListener.STATE_IS_REQUEST;
 
     // Skip non-interesting states.
     if (!isStart || !isDocument || !isRequest || !isNetwork) {
       return;
@@ -672,34 +672,34 @@ TabWebProgressListener.prototype = {
       }
     }
   },
 
   onProgressChange: function() {},
   onSecurityChange: function() {},
   onStatusChange: function() {},
 
-  onLocationChange: function TWPL_onLocationChange(webProgress, request, URI, flags) {
+  onLocationChange: function(webProgress, request, URI, flags) {
     if (this.target &&
         !(flags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT)) {
       let window = webProgress.DOMWindow;
       // Emit the event if the target is not remoted or store the payload for
       // later emission otherwise.
       if (this.target._client) {
         this.target._navWindow = window;
       } else {
         this.target.emit("navigate", window);
       }
     }
   },
 
   /**
    * Destroy the progress listener instance.
    */
-  destroy: function TWPL_destroy() {
+  destroy: function() {
     if (this.target.tab) {
       try {
         this.target.tab.linkedBrowser.removeProgressListener(this);
       } catch (ex) {
         // This can throw when a tab crashes in e10s.
       }
     }
     this.target._webProgressListener = null;
diff --git a/browser/devtools/framework/test/browser_devtools_api.js b/browser/devtools/framework/test/browser_devtools_api.js
--- a/browser/devtools/framework/test/browser_devtools_api.js
+++ b/browser/devtools/framework/test/browser_devtools_api.js
@@ -232,12 +232,12 @@ DevToolPanel.prototype = {
   get target() this._toolbox.target,
 
   get toolbox() this._toolbox,
 
   get isReady() this._isReady,
 
   _isReady: false,
 
-  destroy: function DTI_destroy() {
+  destroy: function() {
     return promise.defer(null);
   },
 };
diff --git a/browser/devtools/framework/toolbox-hosts.js b/browser/devtools/framework/toolbox-hosts.js
--- a/browser/devtools/framework/toolbox-hosts.js
+++ b/browser/devtools/framework/toolbox-hosts.js
@@ -38,17 +38,17 @@ function BottomHost(hostTab) {
 BottomHost.prototype = {
   type: "bottom",
 
   heightPref: "devtools.toolbox.footer.height",
 
   /**
    * Create a box at the bottom of the host tab.
    */
-  create: function BH_create() {
+  create: function() {
     let deferred = promise.defer();
 
     let gBrowser = this.hostTab.ownerDocument.defaultView.gBrowser;
     let ownerDocument = gBrowser.ownerDocument;
 
     this._splitter = ownerDocument.createElement("splitter");
     this._splitter.setAttribute("class", "devtools-horizontal-splitter");
 
@@ -76,31 +76,31 @@ BottomHost.prototype = {
     focusTab(this.hostTab);
 
     return deferred.promise;
   },
 
   /**
    * Raise the host.
    */
-  raise: function BH_raise() {
+  raise: function() {
     focusTab(this.hostTab);
   },
 
   /**
    * Set the toolbox title.
    */
-  setTitle: function BH_setTitle(title) {
+  setTitle: function(title) {
     // Nothing to do for this host type.
   },
 
   /**
    * Destroy the bottom dock.
    */
-  destroy: function BH_destroy() {
+  destroy: function() {
     if (!this._destroyed) {
       this._destroyed = true;
 
       Services.prefs.setIntPref(this.heightPref, this.frame.height);
       this._nbox.removeChild(this._splitter);
       this._nbox.removeChild(this.frame);
     }
 
@@ -121,17 +121,17 @@ function SidebarHost(hostTab) {
 SidebarHost.prototype = {
   type: "side",
 
   widthPref: "devtools.toolbox.sidebar.width",
 
   /**
    * Create a box in the sidebar of the host tab.
    */
-  create: function SH_create() {
+  create: function() {
     let deferred = promise.defer();
 
     let gBrowser = this.hostTab.ownerDocument.defaultView.gBrowser;
     let ownerDocument = gBrowser.ownerDocument;
 
     this._splitter = ownerDocument.createElement("splitter");
     this._splitter.setAttribute("class", "devtools-side-splitter");
 
@@ -157,31 +157,31 @@ SidebarHost.prototype = {
     focusTab(this.hostTab);
 
     return deferred.promise;
   },
 
   /**
    * Raise the host.
    */
-  raise: function SH_raise() {
+  raise: function() {
     focusTab(this.hostTab);
   },
 
   /**
    * Set the toolbox title.
    */
-  setTitle: function SH_setTitle(title) {
+  setTitle: function(title) {
     // Nothing to do for this host type.
   },
 
   /**
    * Destroy the sidebar.
    */
-  destroy: function SH_destroy() {
+  destroy: function() {
     if (!this._destroyed) {
       this._destroyed = true;
 
       Services.prefs.setIntPref(this.widthPref, this.frame.width);
       this._sidebar.removeChild(this._splitter);
       this._sidebar.removeChild(this.frame);
     }
 
@@ -201,17 +201,17 @@ function WindowHost() {
 WindowHost.prototype = {
   type: "window",
 
   WINDOW_URL: "chrome://browser/content/devtools/framework/toolbox-window.xul",
 
   /**
    * Create a new xul window to contain the toolbox.
    */
-  create: function WH_create() {
+  create: function() {
     let deferred = promise.defer();
 
     let flags = "chrome,centerscreen,resizable,dialog=no";
     let win = Services.ww.openWindow(null, this.WINDOW_URL, "_blank",
                                      flags, null);
 
     let frameLoad = (event) => {
       win.removeEventListener("load", frameLoad, true);
@@ -240,31 +240,31 @@ WindowHost.prototype = {
     this._window.removeEventListener("unload", this._boundUnload);
 
     this.emit("window-closed");
   },
 
   /**
    * Raise the host.
    */
-  raise: function RH_raise() {
+  raise: function() {
     this._window.focus();
   },
 
   /**
    * Set the toolbox title.
    */
-  setTitle: function WH_setTitle(title) {
+  setTitle: function(title) {
     this._window.document.title = title;
   },
 
   /**
    * Destroy the window.
    */
-  destroy: function WH_destroy() {
+  destroy: function() {
     if (!this._destroyed) {
       this._destroyed = true;
 
       this._window.removeEventListener("unload", this._boundUnload);
       this._window.close();
     }
 
     return promise.resolve(null);
@@ -278,55 +278,55 @@ function CustomHost(hostTab, options) {
   this.frame = options.customIframe;
   this.uid = options.uid;
   EventEmitter.decorate(this);
 }
 
 CustomHost.prototype = {
   type: "custom",
 
-  _sendMessageToTopWindow: function CH__sendMessageToTopWindow(msg, data) {
+  _sendMessageToTopWindow: function(msg, data) {
     // It's up to the custom frame owner (parent window) to honor
     // "close" or "raise" instructions.
     let topWindow = this.frame.ownerDocument.defaultView;
     if (!topWindow) {
       return;
     }
     let json = {name:"toolbox-" + msg, uid: this.uid};
     if (data) {
       json.data = data;
     }
     topWindow.postMessage(JSON.stringify(json), "*");
   },
 
   /**
    * Create a new xul window to contain the toolbox.
    */
-  create: function CH_create() {
+  create: function() {
     return promise.resolve(this.frame);
   },
 
   /**
    * Raise the host.
    */
-  raise: function CH_raise() {
+  raise: function() {
     this._sendMessageToTopWindow("raise");
   },
 
   /**
    * Set the toolbox title.
    */
-  setTitle: function CH_setTitle(title) {
+  setTitle: function(title) {
     this._sendMessageToTopWindow("title", { value: title });
   },
 
   /**
    * Destroy the window.
    */
-  destroy: function WH_destroy() {
+  destroy: function() {
     if (!this._destroyed) {
       this._destroyed = true;
       this._sendMessageToTopWindow("close");
     }
     return promise.resolve(null);
   }
 }
 
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -71,17 +71,17 @@ function InspectorPanel(iframeWindow, to
 }
 
 exports.InspectorPanel = InspectorPanel;
 
 InspectorPanel.prototype = {
   /**
    * open is effectively an asynchronous constructor
    */
-  open: function InspectorPanel_open() {
+  open: function() {
     return this.target.makeRemote().then(() => {
       return this._getPageStyle();
     }).then(() => {
       return this._getDefaultNodeForSelection();
     }).then(defaultSelection => {
       return this._deferredOpen(defaultSelection);
     }).then(null, console.error);
   },
@@ -286,37 +286,37 @@ InspectorPanel.prototype = {
     return this.panelWin.gViewSourceUtils;
   },
 
   /**
    * Indicate that a tool has modified the state of the page.  Used to
    * decide whether to show the "are you sure you want to navigate"
    * notification.
    */
-  markDirty: function InspectorPanel_markDirty() {
+  markDirty: function() {
     this.isDirty = true;
   },
 
   /**
    * Hooks the searchbar to show result and auto completion suggestions.
    */
-  setupSearchBox: function InspectorPanel_setupSearchBox() {
+  setupSearchBox: function() {
     // Initiate the selectors search object.
     if (this.searchSuggestions) {
       this.searchSuggestions.destroy();
       this.searchSuggestions = null;
     }
     this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
     this.searchSuggestions = new SelectorSearch(this, this.searchBox);
   },
 
   /**
    * Build the sidebar.
    */
-  setupSidebar: function InspectorPanel_setupSidebar() {
+  setupSidebar: function() {
     let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
     this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
       showAllTabsMenu: true
     });
 
     let defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");
 
     this._setDefaultSidebar = (event, toolId) => {
@@ -350,17 +350,17 @@ InspectorPanel.prototype = {
     }
 
     this.sidebar.show();
   },
 
   /**
    * Reset the inspector on new root mutation.
    */
-  onNewRoot: function InspectorPanel_onNewRoot() {
+  onNewRoot: function() {
     this._defaultNode = null;
     this.selection.setNodeFront(null);
     this._destroyMarkup();
     this.isDirty = false;
 
     let onNodeSelected = defaultNode => {
       // Cancel this promise resolution as a new one had
       // been queued up.
@@ -409,17 +409,17 @@ InspectorPanel.prototype = {
     } else {
       return null;
     }
   },
 
   /**
    * When a new node is selected.
    */
-  onNewSelection: function InspectorPanel_onNewSelection(event, value, reason) {
+  onNewSelection: function(event, value, reason) {
     if (reason === "selection-destroy") {
       return;
     }
 
     this.cancelLayoutChange();
 
     // Wait for all the known tools to finish updating and then let the
     // client know.
@@ -516,26 +516,26 @@ InspectorPanel.prototype = {
     }
   },
 
   /**
    * When a node is deleted, select its parent node or the defaultNode if no
    * parent is found (may happen when deleting an iframe inside which the
    * node was selected).
    */
-  onDetached: function InspectorPanel_onDetached(event, parentNode) {
+  onDetached: function(event, parentNode) {
     this.cancelLayoutChange();
     this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
     this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
   },
 
   /**
    * Destroy the inspector.
    */
-  destroy: function InspectorPanel__destroy() {
+  destroy: function() {
     if (this._panelDestroyer) {
       return this._panelDestroyer;
     }
 
     if (this.walker) {
       this.walker.off("new-root", this.onNewRoot);
       this.pageStyle = null;
     }
@@ -584,49 +584,49 @@ InspectorPanel.prototype = {
     ]);
 
     return this._panelDestroyer;
   },
 
   /**
    * Show the node menu.
    */
-  showNodeMenu: function InspectorPanel_showNodeMenu(aButton, aPosition, aExtraItems) {
+  showNodeMenu: function(aButton, aPosition, aExtraItems) {
     if (aExtraItems) {
       for (let item of aExtraItems) {
         this.nodemenu.appendChild(item);
       }
     }
     this.nodemenu.openPopup(aButton, aPosition, 0, 0, true, false);
   },
 
-  hideNodeMenu: function InspectorPanel_hideNodeMenu() {
+  hideNodeMenu: function() {
     this.nodemenu.hidePopup();
   },
 
   /**
    * Returns the clipboard content if it is appropriate for pasting
    * into the current node's outer HTML, otherwise returns null.
    */
-  _getClipboardContentForPaste: function Inspector_getClipboardContentForPaste() {
+  _getClipboardContentForPaste: function() {
     let flavors = clipboard.currentFlavors;
     if (flavors.indexOf("text") != -1 ||
         (flavors.indexOf("html") != -1 && flavors.indexOf("image") == -1)) {
       let content = clipboard.get();
       if (content && content.trim().length > 0) {
         return content;
       }
     }
     return null;
   },
 
   /**
    * Disable the delete item if needed. Update the pseudo classes.
    */
-  _setupNodeMenu: function InspectorPanel_setupNodeMenu() {
+  _setupNodeMenu: function() {
     let isSelectionElement = this.selection.isElementNode() &&
                              !this.selection.isPseudoElementNode();
     let isEditableElement = isSelectionElement &&
                             !this.selection.isAnonymousNode();
 
     // Set the pseudo classes
     for (let name of ["hover", "active", "focus"]) {
       let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);
@@ -711,25 +711,25 @@ InspectorPanel.prototype = {
     let markupContainer = this.markup.getContainer(this.selection.nodeFront);
     if (isSelectionElement && markupContainer && markupContainer.isPreviewable()) {
       copyImageData.removeAttribute("disabled");
     } else {
       copyImageData.setAttribute("disabled", "true");
     }
   },
 
-  _resetNodeMenu: function InspectorPanel_resetNodeMenu() {
+  _resetNodeMenu: function() {
     // Remove any extra items
     while (this.lastNodemenuItem.nextSibling) {
       let toDelete = this.lastNodemenuItem.nextSibling;
       toDelete.parentNode.removeChild(toDelete);
     }
   },
 
-  _initMarkup: function InspectorPanel_initMarkup() {
+  _initMarkup: function() {
     let doc = this.panelDoc;
 
     this._markupBox = doc.getElementById("markup-box");
 
     // create tool iframe
     this._markupFrame = doc.createElement("iframe");
     this._markupFrame.setAttribute("flex", "1");
     this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
@@ -740,31 +740,31 @@ InspectorPanel.prototype = {
     this._markupFrame.addEventListener("load", this._boundMarkupFrameLoad, true);
 
     this._markupBox.setAttribute("collapsed", true);
     this._markupBox.appendChild(this._markupFrame);
     this._markupFrame.setAttribute("src", "chrome://browser/content/devtools/markup-view.xhtml");
     this._markupFrame.setAttribute("aria-label", this.strings.GetStringFromName("inspector.panelLabel.markupView"));
   },
 
-  _onMarkupFrameLoad: function InspectorPanel__onMarkupFrameLoad() {
+  _onMarkupFrameLoad: function() {
     this._markupFrame.removeEventListener("load", this._boundMarkupFrameLoad, true);
     delete this._boundMarkupFrameLoad;
 
     this._markupFrame.contentWindow.focus();
 
     this._markupBox.removeAttribute("collapsed");
 
     let controllerWindow = this._toolbox.doc.defaultView;
     this.markup = new MarkupView(this, this._markupFrame, controllerWindow);
 
     this.emit("markuploaded");
   },
 
-  _destroyMarkup: function InspectorPanel__destroyMarkup() {
+  _destroyMarkup: function() {
     let destroyPromise;
 
     if (this._boundMarkupFrameLoad) {
       this._markupFrame.removeEventListener("load", this._boundMarkupFrameLoad, true);
       this._boundMarkupFrameLoad = null;
     }
 
     if (this.markup) {
@@ -782,109 +782,109 @@ InspectorPanel.prototype = {
     this._markupBox = null;
 
     return destroyPromise;
   },
 
   /**
    * Toggle a pseudo class.
    */
-  togglePseudoClass: function InspectorPanel_togglePseudoClass(aPseudo) {
+  togglePseudoClass: function(aPseudo) {
     if (this.selection.isElementNode()) {
       let node = this.selection.nodeFront;
       if (node.hasPseudoClassLock(aPseudo)) {
         return this.walker.removePseudoClassLock(node, aPseudo, {parents: true});
       }
 
       let hierarchical = aPseudo == ":hover" || aPseudo == ":active";
       return this.walker.addPseudoClassLock(node, aPseudo, {parents: hierarchical});
     }
   },
 
   /**
    * Show DOM properties
    */
-  showDOMProperties: function InspectorPanel_showDOMProperties() {
+  showDOMProperties: function() {
     this._toolbox.openSplitConsole().then(() => {
       let panel = this._toolbox.getPanel("webconsole");
       let jsterm = panel.hud.jsterm;
 
       jsterm.execute("inspect($0)");
       jsterm.focusInput();
     });
   },
 
   /**
    * Clear any pseudo-class locks applied to the current hierarchy.
    */
-  clearPseudoClasses: function InspectorPanel_clearPseudoClasses() {
+  clearPseudoClasses: function() {
     if (!this.walker) {
       return;
     }
     return this.walker.clearPseudoClassLocks().then(null, console.error);
   },
 
   /**
    * Edit the outerHTML of the selected Node.
    */
-  editHTML: function InspectorPanel_editHTML() {
+  editHTML: function() {
     if (!this.selection.isNode()) {
       return;
     }
     if (this.markup) {
       this.markup.beginEditingOuterHTML(this.selection.nodeFront);
     }
   },
 
   /**
    * Paste the contents of the clipboard into the selected Node's outer HTML.
    */
-  pasteOuterHTML: function InspectorPanel_pasteOuterHTML() {
+  pasteOuterHTML: function() {
     let content = this._getClipboardContentForPaste();
     if (!content)
       return promise.reject("No clipboard content for paste");
 
     let node = this.selection.nodeFront;
     return this.markup.getNodeOuterHTML(node).then(oldContent => {
       this.markup.updateNodeOuterHTML(node, content, oldContent);
     });
   },
 
   /**
    * Paste the contents of the clipboard into the selected Node's inner HTML.
    */
-  pasteInnerHTML: function InspectorPanel_pasteInnerHTML() {
+  pasteInnerHTML: function() {
     let content = this._getClipboardContentForPaste();
     if (!content)
       return promise.reject("No clipboard content for paste");
 
     let node = this.selection.nodeFront;
     return this.markup.getNodeInnerHTML(node).then(oldContent => {
       this.markup.updateNodeInnerHTML(node, content, oldContent);
     });
   },
 
   /**
    * Paste the contents of the clipboard as adjacent HTML to the selected Node.
    * @param position The position as specified for Element.insertAdjacentHTML
    *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
    */
-  pasteAdjacentHTML: function InspectorPanel_pasteAdjacent(position) {
+  pasteAdjacentHTML: function(position) {
     let content = this._getClipboardContentForPaste();
     if (!content)
       return promise.reject("No clipboard content for paste");
 
     let node = this.selection.nodeFront;
     return this.markup.insertAdjacentHTMLToNode(node, position, content);
   },
 
   /**
    * Copy the innerHTML of the selected Node to the clipboard.
    */
-  copyInnerHTML: function InspectorPanel_copyInnerHTML() {
+  copyInnerHTML: function() {
     if (!this.selection.isNode()) {
       return;
     }
     this._copyLongStr(this.walker.innerHTML(this.selection.nodeFront));
   },
 
   /**
    * Copy the outerHTML of the selected Node to the clipboard.
@@ -931,17 +931,17 @@ InspectorPanel.prototype = {
     this.selection.nodeFront.getUniqueSelector().then((selector) => {
       clipboardHelper.copyString(selector);
     }).then(null, console.error);
   },
 
   /**
    * Delete the selected node.
    */
-  deleteNode: function IUI_deleteNode() {
+  deleteNode: function() {
     if (!this.selection.isNode() ||
          this.selection.isRoot()) {
       return;
     }
 
     // If the markup panel is active, use the markup panel to delete
     // the node, making this an undoable action.
     if (this.markup) {
diff --git a/browser/devtools/responsivedesign/responsivedesign-child.js b/browser/devtools/responsivedesign/responsivedesign-child.js
--- a/browser/devtools/responsivedesign/responsivedesign-child.js
+++ b/browser/devtools/responsivedesign/responsivedesign-child.js
@@ -108,20 +108,20 @@ function screenshot() {
   canvas.width = width;
   canvas.height = height;
   let ctx = canvas.getContext("2d");
   ctx.drawWindow(content, content.scrollX, content.scrollY, width, height, "#fff");
   sendAsyncMessage("ResponsiveMode:RequestScreenshot:Done", canvas.toDataURL());
 }
 
 let WebProgressListener = {
-  onLocationChange: function onLocationChange(aWebProgress) {
+  onLocationChange: function(aWebProgress) {
     makeScrollbarsFloating();
   },
-  QueryInterface: function QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIWebProgressListener) ||
         aIID.equals(Ci.nsISupportsWeakReference) ||
         aIID.equals(Ci.nsISupports)) {
         return this;
     }
     throw Components.results.NS_ERROR_NO_INTERFACE;
   }
 };
diff --git a/browser/devtools/responsivedesign/responsivedesign.jsm b/browser/devtools/responsivedesign/responsivedesign.jsm
--- a/browser/devtools/responsivedesign/responsivedesign.jsm
+++ b/browser/devtools/responsivedesign/responsivedesign.jsm
@@ -243,17 +243,17 @@ ResponsiveUI.prototype = {
     } else if (!aValue) {
       this.stack.setAttribute("notransition", "true");
     }
   },
 
   /**
    * Destroy the nodes. Remove listeners. Reset the style.
    */
-  close: function RUI_close() {
+  close: function() {
     if (this.closing)
       return;
     this.closing = true;
 
     this.unCheckMenus();
     // Reset style of the stack.
     let style = "max-width: none;" +
                 "min-width: 0;" +
@@ -346,24 +346,24 @@ ResponsiveUI.prototype = {
         }
         break;
     }
   },
 
   /**
    * Check the menu items.
    */
-   checkMenus: function RUI_checkMenus() {
+   checkMenus: function() {
      this.chromeDoc.getElementById("Tools:ResponsiveUI").setAttribute("checked", "true");
    },
 
   /**
    * Uncheck the menu items.
    */
-   unCheckMenus: function RUI_unCheckMenus() {
+   unCheckMenus: function() {
      this.chromeDoc.getElementById("Tools:ResponsiveUI").setAttribute("checked", "false");
    },
 
   /**
    * Build the toolbar and the resizers.
    *
    * <vbox class="browserContainer"> From tabbrowser.xml
    *  <toolbar class="devtools-responsiveui-toolbar">
@@ -384,17 +384,17 @@ ResponsiveUI.prototype = {
    *      <button class="devtools-responsiveui-volume-down-button" />
    *    </vbox>
    *  </stack>
    *  <toolbar class="devtools-responsiveui-hardware-button">
    *    <toolbarbutton class="devtools-responsiveui-home-button" />
    *  </toolbar>
    * </vbox>
    */
-  buildUI: function RUI_buildUI() {
+  buildUI: function() {
     // Toolbar
     this.toolbar = this.chromeDoc.createElement("toolbar");
     this.toolbar.className = "devtools-responsiveui-toolbar";
 
     this.menulist = this.chromeDoc.createElement("menulist");
     this.menulist.className = "devtools-responsiveui-menulist";
     this.menulist.setAttribute("editable", "true");
 
@@ -540,17 +540,17 @@ ResponsiveUI.prototype = {
     bottomToolbar.appendChild(homeButton);
     this.bottomToolbar = bottomToolbar;
     this.container.appendChild(bottomToolbar);
   },
 
   /**
    * Validate and apply any user input on the editable menulist
    */
-  handleManualInput: function RUI_handleManualInput() {
+  handleManualInput: function() {
     let userInput = this.menulist.inputField.value;
     let value = INPUT_PARSER.exec(userInput);
     let selectedPreset = this.menuitems.get(this.selectedItem);
 
     // In case of an invalide value, we show back the last preset
     if (!value || value.length < 3) {
       this.setMenuLabel(this.selectedItem, selectedPreset);
       return;
@@ -571,17 +571,17 @@ ResponsiveUI.prototype = {
     this.setSize(w, h);
   },
 
   /**
    * Build the presets list and append it to the menupopup.
    *
    * @param aParent menupopup.
    */
-  registerPresets: function RUI_registerPresets(aParent) {
+  registerPresets: function(aParent) {
     let fragment = this.chromeDoc.createDocumentFragment();
     let doc = this.chromeDoc;
 
     for (let preset of this.presets) {
       let menuitem = doc.createElement("menuitem");
       menuitem.setAttribute("ispreset", true);
       this.menuitems.set(menuitem, preset);
 
@@ -601,17 +601,17 @@ ResponsiveUI.prototype = {
   },
 
   /**
    * Set the menuitem label of a preset.
    *
    * @param aMenuitem menuitem to edit.
    * @param aPreset associated preset.
    */
-  setMenuLabel: function RUI_setMenuLabel(aMenuitem, aPreset) {
+  setMenuLabel: function(aMenuitem, aPreset) {
     let size = SHARED_L10N.getFormatStr("dimensions",
       Math.round(aPreset.width), Math.round(aPreset.height));
 
     // .inputField might be not reachable yet (async XBL loading)
     if (this.menulist.inputField) {
       this.menulist.inputField.value = size;
     }
 
@@ -622,17 +622,17 @@ ResponsiveUI.prototype = {
     }
 
     aMenuitem.setAttribute("label", size);
   },
 
   /**
    * When a preset is selected, apply it.
    */
-  presetSelected: function RUI_presetSelected() {
+  presetSelected: function() {
     if (this.menulist.selectedItem.getAttribute("ispreset") === "true") {
       this.selectedItem = this.menulist.selectedItem;
 
       this.rotateValue = false;
       let selectedPreset = this.menuitems.get(this.selectedItem);
       this.loadPreset(selectedPreset);
       this.currentPresetKey = selectedPreset.key;
       this.saveCurrentPreset();
@@ -648,24 +648,24 @@ ResponsiveUI.prototype = {
     }
   },
 
   /**
    * Apply a preset.
    *
    * @param aPreset preset to apply.
    */
-  loadPreset: function RUI_loadPreset(aPreset) {
+  loadPreset: function(aPreset) {
     this.setSize(aPreset.width, aPreset.height);
   },
 
   /**
    * Add a preset to the list and the memory
    */
-  addPreset: function RUI_addPreset() {
+  addPreset: function() {
     let w = this.customPreset.width;
     let h = this.customPreset.height;
     let newName = {};
 
     let title = this.strings.GetStringFromName("responsiveUI.customNamePromptTitle");
     let message = this.strings.formatStringFromName("responsiveUI.customNamePromptMsg", [w, h], 2);
     let promptOk = Services.prompt.prompt(null, title, message, newName, null, {});
 
@@ -719,17 +719,17 @@ ResponsiveUI.prototype = {
     this.menulist.selectedItem = newMenuitem;
     this.currentPresetKey = newPreset.key;
     this.saveCurrentPreset();
   },
 
   /**
    * remove a preset from the list and the memory
    */
-  removePreset: function RUI_removePreset() {
+  removePreset: function() {
     let selectedPreset = this.menuitems.get(this.selectedItem);
     let w = selectedPreset.width;
     let h = selectedPreset.height;
 
     this.presets.splice(this.presets.indexOf(selectedPreset), 1);
     this.menulist.firstChild.removeChild(this.selectedItem);
     this.menuitems.delete(this.selectedItem);
 
@@ -743,17 +743,17 @@ ResponsiveUI.prototype = {
     this.setSize(w, h);
 
     this.savePresets();
   },
 
   /**
    * Swap width and height.
    */
-  rotate: function RUI_rotate() {
+  rotate: function() {
     let selectedPreset = this.menuitems.get(this.selectedItem);
     let width = this.rotateValue ? selectedPreset.height : selectedPreset.width;
     let height = this.rotateValue ? selectedPreset.width : selectedPreset.height;
 
     this.setSize(height, width);
 
     if (selectedPreset.custom) {
       this.saveCustomSize();
@@ -763,17 +763,17 @@ ResponsiveUI.prototype = {
     }
   },
 
   /**
    * Take a screenshot of the page.
    *
    * @param aFileName name of the screenshot file (used for tests).
    */
-  screenshot: function RUI_screenshot(aFileName) {
+  screenshot: function(aFileName) {
     let filename = aFileName;
     if (!filename) {
       let date = new Date();
       let month = ("0" + (date.getMonth() + 1)).substr(-2, 2);
       let day = ("0" + date.getDate()).substr(-2, 2);
       let dateString = [date.getFullYear(), month, day].join("-");
       let timeString = date.toTimeString().replace(/:/g, ".").split(" ")[0];
       filename = this.strings.formatStringFromName("responsiveUI.screenshotGeneratedFilename", [dateString, timeString], 2);
@@ -787,41 +787,41 @@ ResponsiveUI.prototype = {
     }
     mm.addMessageListener("ResponsiveMode:RequestScreenshot:Done", onScreenshot);
     mm.sendAsyncMessage("ResponsiveMode:RequestScreenshot");
   },
 
   /**
    * Enable/Disable mouse -> touch events translation.
    */
-   enableTouch: function RUI_enableTouch() {
+   enableTouch: function() {
      if (!this.touchEventHandler.enabled) {
        let isReloadNeeded = this.touchEventHandler.start();
        this.touchbutton.setAttribute("checked", "true");
        return isReloadNeeded;
      }
      return false;
    },
 
-   disableTouch: function RUI_disableTouch() {
+   disableTouch: function() {
      if (this.touchEventHandler.enabled) {
        this.touchEventHandler.stop();
        this.touchbutton.removeAttribute("checked");
      }
    },
 
-   hideTouchNotification: function RUI_hideTouchNotification() {
+   hideTouchNotification: function() {
      let nbox = this.mainWindow.gBrowser.getNotificationBox(this.browser);
      let n = nbox.getNotificationWithValue("responsive-ui-need-reload");
      if (n) {
        n.close();
      }
    },
 
-   toggleTouch: function RUI_toggleTouch() {
+   toggleTouch: function() {
      this.hideTouchNotification();
      if (this.touchEventHandler.enabled) {
        this.disableTouch();
      } else {
        let isReloadNeeded = this.enableTouch();
        if (isReloadNeeded) {
          if (Services.prefs.getBoolPref("devtools.responsiveUI.no-reload-notification")) {
            return;
@@ -854,17 +854,17 @@ ResponsiveUI.prototype = {
    },
 
   /**
    * Change the size of the browser.
    *
    * @param aWidth width of the browser.
    * @param aHeight height of the browser.
    */
-  setSize: function RUI_setSize(aWidth, aHeight) {
+  setSize: function(aWidth, aHeight) {
     aWidth = Math.min(Math.max(aWidth, MIN_WIDTH), MAX_WIDTH);
     aHeight = Math.min(Math.max(aHeight, MIN_HEIGHT), MAX_HEIGHT);
 
     // We resize the containing stack.
     let style = "max-width: %width;" +
                 "min-width: %width;" +
                 "max-height: %height;" +
                 "min-height: %height;";
@@ -890,17 +890,17 @@ ResponsiveUI.prototype = {
     }
   },
 
   /**
    * Start the process of resizing the browser.
    *
    * @param aEvent
    */
-  startResizing: function RUI_startResizing(aEvent) {
+  startResizing: function(aEvent) {
     let selectedPreset = this.menuitems.get(this.selectedItem);
 
     if (!selectedPreset.custom) {
       this.customPreset.width = this.rotateValue ? selectedPreset.height : selectedPreset.width;
       this.customPreset.height = this.rotateValue ? selectedPreset.width : selectedPreset.height;
 
       let menuitem = this.customMenuitem;
       this.setMenuLabel(menuitem, this.customPreset);
@@ -924,17 +924,17 @@ ResponsiveUI.prototype = {
     this.isResizing = true;
   },
 
   /**
    * Resizing on mouse move.
    *
    * @param aEvent
    */
-  onDrag: function RUI_onDrag(aEvent) {
+  onDrag: function(aEvent) {
     let shift = aEvent.shiftKey;
     let ctrl = !aEvent.shiftKey && aEvent.ctrlKey;
 
     let screenX = aEvent.screenX;
     let screenY = aEvent.screenY;
 
     let deltaX = screenX - this.lastScreenX;
     let deltaY = screenY - this.lastScreenY;
@@ -975,17 +975,17 @@ ResponsiveUI.prototype = {
     }
 
     this.setSize(width, height);
   },
 
   /**
    * Stop End resizing
    */
-  stopResizing: function RUI_stopResizing() {
+  stopResizing: function() {
     this.container.style.pointerEvents = "auto";
 
     this.mainWindow.removeEventListener("mouseup", this.bound_stopResizing, true);
     this.mainWindow.removeEventListener("mousemove", this.bound_onDrag, true);
 
     this.saveCustomSize();
 
     delete this._resizing;
@@ -995,33 +995,33 @@ ResponsiveUI.prototype = {
     this.ignoreY = false;
     this.ignoreX = false;
     this.isResizing = false;
   },
 
   /**
    * Store the custom size as a pref.
    */
-   saveCustomSize: function RUI_saveCustomSize() {
+   saveCustomSize: function() {
      Services.prefs.setIntPref("devtools.responsiveUI.customWidth", this.customPreset.width);
      Services.prefs.setIntPref("devtools.responsiveUI.customHeight", this.customPreset.height);
    },
 
   /**
    * Store the current preset as a pref.
    */
-   saveCurrentPreset: function RUI_saveCurrentPreset() {
+   saveCurrentPreset: function() {
      Services.prefs.setCharPref("devtools.responsiveUI.currentPreset", this.currentPresetKey);
      Services.prefs.setBoolPref("devtools.responsiveUI.rotate", this.rotateValue);
    },
 
   /**
    * Store the list of all registered presets as a pref.
    */
-  savePresets: function RUI_savePresets() {
+  savePresets: function() {
     // We exclude the custom one
     let registeredPresets = this.presets.filter(function (aPreset) {
       return !aPreset.custom;
     });
 
     Services.prefs.setCharPref("devtools.responsiveUI.presets", JSON.stringify(registeredPresets));
   },
 }
diff --git a/browser/devtools/scratchpad/scratchpad-manager.jsm b/browser/devtools/scratchpad/scratchpad-manager.jsm
--- a/browser/devtools/scratchpad/scratchpad-manager.jsm
+++ b/browser/devtools/scratchpad/scratchpad-manager.jsm
@@ -61,17 +61,17 @@ this.ScratchpadManager = {
     }, this);
 
     return wins;
   },
 
   /**
    * Iterate through open scratchpad windows and save their states.
    */
-  saveOpenWindows: function SPM_saveOpenWindows() {
+  saveOpenWindows: function() {
     this._scratchpads = [];
 
     function clone(src) {
       let dest = {};
 
       for (let key in src) {
         if (src.hasOwnProperty(key)) {
           dest[key] = src[key];
diff --git a/browser/devtools/scratchpad/scratchpad.js b/browser/devtools/scratchpad/scratchpad.js
--- a/browser/devtools/scratchpad/scratchpad.js
+++ b/browser/devtools/scratchpad/scratchpad.js
@@ -134,17 +134,17 @@ var Scratchpad = {
     });
 
     return obj;
   },
 
   /**
    * Add the event listeners for popupshowing events.
    */
-  _setupPopupShowingListeners: function SP_setupPopupShowing() {
+  _setupPopupShowingListeners: function() {
     let elementIDs = ['sp-menu_editpopup', 'scratchpad-text-popup'];
 
     for (let elementID of elementIDs) {
       let elem = document.getElementById(elementID);
       if (elem) {
         elem.addEventListener("popupshowing", function () {
           goUpdateGlobalEditMenuItems();
           let commands = ['cmd_undo', 'cmd_redo', 'cmd_delete', 'cmd_findAgain'];
@@ -152,17 +152,17 @@ var Scratchpad = {
         });
       }
     }
   },
 
   /**
    * Add the event event listeners for command events.
    */
-  _setupCommandListeners: function SP_setupCommands() {
+  _setupCommandListeners: function() {
     let commands = {
       "cmd_gotoLine": () => {
         goDoCommand('cmd_gotoLine');
       },
       "sp-cmd-newWindow": () => {
         Scratchpad.openScratchpad();
       },
       "sp-cmd-openFile": () => {
@@ -641,17 +641,17 @@ var Scratchpad = {
 
   /**
    * Pretty print the source text inside the scratchpad.
    *
    * @return Promise
    *         A promise resolved with the pretty printed code, or rejected with
    *         an error.
    */
-  prettyPrint: function SP_prettyPrint() {
+  prettyPrint: function() {
     const uglyText = this.getText();
     const tabsize = Services.prefs.getIntPref(TAB_SIZE);
     const id = Math.random();
     const deferred = promise.defer();
 
     const onReply = ({ data }) => {
       if (data.id !== id) {
         return;
@@ -678,17 +678,17 @@ var Scratchpad = {
 
     return deferred.promise;
   },
 
   /**
    * Parse the text and return an AST. If we can't parse it, write an error
    * comment and return false.
    */
-  _parseText: function SP__parseText(aText) {
+  _parseText: function(aText) {
     try {
       return Reflect.parse(aText);
     } catch (e) {
       this.writeAsErrorComment({ exception: DevToolsUtils.safeErrorString(e) });
       return false;
     }
   },
 
@@ -723,17 +723,17 @@ var Scratchpad = {
     return false;
   },
 
   /**
    * Find the top level function AST node that the cursor is within.
    *
    * @returns Object|null
    */
-  _findTopLevelFunction: function SP__findTopLevelFunction(aAst, aCursorPos) {
+  _findTopLevelFunction: function(aAst, aCursorPos) {
     for (let statement of aAst.body) {
       switch (statement.type) {
       case "FunctionDeclaration":
         if (this._containsCursor(statement.loc, aCursorPos)) {
           return statement;
         }
         break;
 
@@ -757,17 +757,17 @@ var Scratchpad = {
 
   /**
    * Get the source text associated with the given function statement.
    *
    * @param Object aFunction
    * @param String aFullText
    * @returns String
    */
-  _getFunctionText: function SP__getFunctionText(aFunction, aFullText) {
+  _getFunctionText: function(aFunction, aFullText) {
     let functionText = "";
     // Initially set to 0, but incremented first thing in the loop below because
     // line numbers are 1 based, not 0 based.
     let lineNumber = 0;
     const { start, end } = aFunction.loc;
     const singleLine = start.line === end.line;
 
     for (let line of aFullText.split(/\n/g)) {
@@ -796,17 +796,17 @@ var Scratchpad = {
     return functionText;
   },
 
   /**
    * Evaluate the top level function that the cursor is resting in.
    *
    * @returns Promise [text, error, result]
    */
-  evalTopLevelFunction: function SP_evalTopLevelFunction() {
+  evalTopLevelFunction: function() {
     const text = this.getText();
     const ast = this._parseText(text);
     if (!ast) {
       return promise.resolve([text, undefined, undefined]);
     }
 
     const cursorPos = this.editor.getCursor();
     const funcStatement = this._findTopLevelFunction(ast, cursorPos);
@@ -1074,33 +1074,33 @@ var Scratchpad = {
 
   /**
    * Get a list of applicable charsets.
    * The best charset, defaulting to "UTF-8"
    *
    * @param string aBestCharset
    * @return array of strings
    */
-  _getApplicableCharsets: function SP__getApplicableCharsets(aBestCharset="UTF-8") {
+  _getApplicableCharsets: function(aBestCharset="UTF-8") {
     let charsets = Services.prefs.getCharPref(
       FALLBACK_CHARSET_LIST).split(",").filter(function (value) {
       return value.length;
     });
     charsets.unshift(aBestCharset);
     return charsets;
   },
 
   /**
    * Get content converted to unicode, using a list of input charset to try.
    *
    * @param string aContent
    * @param array of string aCharsetArray
    * @return string
    */
-  _getUnicodeContent: function SP__getUnicodeContent(aContent, aCharsetArray) {
+  _getUnicodeContent: function(aContent, aCharsetArray) {
     let content = null,
         converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"].createInstance(Ci.nsIScriptableUnicodeConverter),
         success = aCharsetArray.some(charset => {
           try {
             converter.charset = charset;
             content = converter.ConvertToUnicode(aContent);
             return true;
           } catch (e) {
@@ -2386,17 +2386,17 @@ var PreferenceObserver = {
     if (aData == "recentFilesMax") {
       Scratchpad.handleRecentFileMaxChange();
     }
     else if (aData == "recentFilePaths") {
       Scratchpad.populateRecentFilesMenu();
     }
   },
 
-  uninit: function PO_uninit () {
+  uninit: function() {
     if (!this.branch) {
       return;
     }
 
     this.branch.removeObserver("", this);
     this.branch = null;
   }
 };
diff --git a/browser/devtools/scratchpad/test/browser_scratchpad_recent_files.js b/browser/devtools/scratchpad/test/browser_scratchpad_recent_files.js
--- a/browser/devtools/scratchpad/test/browser_scratchpad_recent_files.js
+++ b/browser/devtools/scratchpad/test/browser_scratchpad_recent_files.js
@@ -303,17 +303,17 @@ var PreferenceObserver = {
         break;
       case 8:
         this.timesFired = 9;
         testClearedAll();
         break;
     }
   },
 
-  uninit: function PO_uninit () {
+  uninit: function() {
     this.branch.removeObserver("", this);
   }
 };
 
 function test()
 {
   waitForExplicitFinish();
 
diff --git a/browser/devtools/shared/AppCacheUtils.jsm b/browser/devtools/shared/AppCacheUtils.jsm
--- a/browser/devtools/shared/AppCacheUtils.jsm
+++ b/browser/devtools/shared/AppCacheUtils.jsm
@@ -47,17 +47,17 @@ function AppCacheUtils(documentOrUri) {
   }
 }
 
 AppCacheUtils.prototype = {
   get cachePath() {
     return "";
   },
 
-  validateManifest: function ACU_validateManifest() {
+  validateManifest: function() {
     let deferred = promise.defer();
     this.errors = [];
     // Check for missing manifest.
     this._getManifestURI().then(manifestURI => {
       this.manifestURI = manifestURI;
 
       if (!this.manifestURI) {
         this._addError(0, "noManifest");
@@ -73,17 +73,17 @@ AppCacheUtils.prototype = {
           deferred.resolve(this.errors);
         });
       });
     });
 
     return deferred.promise;
   },
 
-  _parseManifest: function ACU__parseManifest(uriInfo) {
+  _parseManifest: function(uriInfo) {
     let deferred = promise.defer();
     let manifestName = uriInfo.name;
     let manifestLastModified = new Date(uriInfo.responseHeaders["Last-Modified"]);
 
     if (uriInfo.charset.toLowerCase() != "utf-8") {
       this._addError(0, "notUTF8", uriInfo.charset);
     }
 
@@ -175,17 +175,17 @@ AppCacheUtils.prototype = {
           deferred.resolve();
         }
       });
     }
 
     return deferred.promise;
   },
 
-  _getURIInfo: function ACU__getURIInfo(uri) {
+  _getURIInfo: function(uri) {
     let inputStream = Cc["@mozilla.org/scriptableinputstream;1"]
                         .createInstance(Ci.nsIScriptableInputStream);
     let deferred = promise.defer();
     let buffer = "";
     let channel = Services.io.newChannel2(uri,
                                           null,
                                           null,
                                           null,      // aLoadingNode
@@ -205,17 +205,17 @@ AppCacheUtils.prototype = {
       },
 
       onDataAvailable: function (request, context, stream, offset, count) {
         request.QueryInterface(Ci.nsIHttpChannel);
         inputStream.init(stream);
         buffer = buffer.concat(inputStream.read(count));
       },
 
-      onStopRequest: function onStartRequest(request, context, statusCode) {
+      onStopRequest: function(request, context, statusCode) {
         if (statusCode === 0) {
           request.QueryInterface(Ci.nsIHttpChannel);
 
           let result = {
             name: request.name,
             success: request.requestSucceeded,
             status: request.responseStatus + " - " + request.responseStatusText,
             charset: request.contentCharset || "utf-8",
@@ -243,17 +243,17 @@ AppCacheUtils.prototype = {
             success: false
           });
         }
       }
     }, null);
     return deferred.promise;
   },
 
-  listEntries: function ACU_show(searchTerm) {
+  listEntries: function(searchTerm) {
     if (!Services.prefs.getBoolPref("browser.cache.disk.enable")) {
       throw new Error(l10n.GetStringFromName("cacheDisabled"));
     }
 
     let entries = [];
 
     let appCacheStorage = Services.cache2.appCacheStorage(LoadContextInfo.default, null);
     appCacheStorage.asyncVisitStorage({
@@ -286,36 +286,36 @@ AppCacheUtils.prototype = {
     }, true);
 
     if (entries.length === 0) {
       throw new Error(l10n.GetStringFromName("noResults"));
     }
     return entries;
   },
 
-  viewEntry: function ACU_viewEntry(key) {
+  viewEntry: function(key) {
     let wm = Cc["@mozilla.org/appshell/window-mediator;1"]
                .getService(Ci.nsIWindowMediator);
     let win = wm.getMostRecentWindow("navigator:browser");
     win.gBrowser.selectedTab = win.gBrowser.addTab(
       "about:cache-entry?storage=appcache&context=&eid=&uri=" + key);
   },
 
-  clearAll: function ACU_clearAll() {
+  clearAll: function() {
     if (!Services.prefs.getBoolPref("browser.cache.disk.enable")) {
       throw new Error(l10n.GetStringFromName("cacheDisabled"));
     }
 
     let appCacheStorage = Services.cache2.appCacheStorage(LoadContextInfo.default, null);
     appCacheStorage.asyncEvictStorage({
       onCacheEntryDoomed: function(result) {}
     });
   },
 
-  _getManifestURI: function ACU__getManifestURI() {
+  _getManifestURI: function() {
     let deferred = promise.defer();
 
     let getURI = () => {
       let htmlNode = this.doc.querySelector("html[manifest]");
       if (htmlNode) {
         let pageUri = this.doc.location ? this.doc.location.href : this.uri;
         let origin = pageUri.substr(0, pageUri.lastIndexOf("/") + 1);
         let manifestURI = htmlNode.getAttribute("manifest");
@@ -345,17 +345,17 @@ AppCacheUtils.prototype = {
             msg: l10n.GetStringFromName("invalidURI")
           });
         }
       });
     }
     return deferred.promise;
   },
 
-  _addError: function ACU__addError(line, l10nString, ...params) {
+  _addError: function(line, l10nString, ...params) {
     let msg;
 
     if (params) {
       msg = l10n.formatStringFromName(l10nString, params, params.length);
     } else {
       msg = l10n.GetStringFromName(l10nString);
     }
 
@@ -378,17 +378,17 @@ AppCacheUtils.prototype = {
  */
 function ManifestParser(manifestText, manifestURI) {
   this.manifestText = manifestText;
   this.origin = manifestURI.substr(0, manifestURI.lastIndexOf("/") + 1)
                            .replace(" ", "%20");
 }
 
 ManifestParser.prototype = {
-  parse: function OCIMP_parse() {
+  parse: function() {
     let lines = this.manifestText.split(/\r?\n/);
     let fallbacks = this.fallbacks = [];
     let settings = this.settings = [];
     let errors = this.errors = [];
     let uris = this.uris = [];
 
     this.currSection = "CACHE";
 
@@ -434,17 +434,17 @@ ManifestParser.prototype = {
     return {
       uris: uris,
       fallbacks: fallbacks,
       settings: settings,
       errors: errors
     };
   },
 
-  parseLine: function OCIMP_parseLine() {
+  parseLine: function() {
     let text = this.text;
 
     if (text.indexOf("*") != -1) {
       if (this.currSection != "NETWORK" || text.length != 1) {
         this._addError(this.currentLine, "asteriskInWrongSection2",
                        this.currSection, this.currentLine);
         return;
       }
@@ -483,17 +483,17 @@ ManifestParser.prototype = {
       if (/^https?:\/\//.test(path)) {
         this.uris.push(this._wrapURI(path));
         return;
       }
       this.uris.push(this._wrapURI(origin + path));
     }
   },
 
-  parseFallbackLine: function OCIMP_parseFallbackLine() {
+  parseFallbackLine: function() {
     let split = this.text.split(/\s+/);
     let origURI = this.text;
 
     if (split.length != 2) {
       this._addError(this.currentLine, "fallbackUseSpaces", this.currentLine);
       return;
     }
 
@@ -546,17 +546,17 @@ ManifestParser.prototype = {
     this.fallbacks.push({
       line: this.currentLine,
       original: origURI,
       namespace: namespace,
       fallback: fallback
     });
   },
 
-  parseSettingsLine: function OCIMP_parseSettingsLine() {
+  parseSettingsLine: function() {
     let text = this.text;
 
     if (this.settings.length == 1 || !/prefer-online|fast/.test(text)) {
       this._addError(this.currentLine, "settingsBadValue", this.currentLine);
       return;
     }
 
     switch (text) {
@@ -564,41 +564,41 @@ ManifestParser.prototype = {
         this.settings.push(this._wrapURI(text));
         break;
       case "fast":
         this.settings.push(this._wrapURI(text));
         break;
     }
   },
 
-  _wrapURI: function OCIMP__wrapURI(uri) {
+  _wrapURI: function(uri) {
     return {
       section: this.currSection,
       line: this.currentLine,
       uri: uri,
       original: this.text
     };
   },
 
-  _addError: function OCIMP__addError(line, l10nString, ...params) {
+  _addError: function(line, l10nString, ...params) {
     let msg;
 
     if (params) {
       msg = l10n.formatStringFromName(l10nString, params, params.length);
     } else {
       msg = l10n.GetStringFromName(l10nString);
     }
 
     this.errors.push({
       line: line,
       msg: msg
     });
   },
 
-  _maybeUpdateSectionName: function OCIMP__maybeUpdateSectionName() {
+  _maybeUpdateSectionName: function() {
     let text = this.text;
 
     if (text == text.toUpperCase() && text.charAt(text.length - 1) == ":") {
       text = text.substr(0, text.length - 1);
 
       switch (text) {
         case "CACHE":
         case "NETWORK":
diff --git a/browser/devtools/shared/DOMHelpers.jsm b/browser/devtools/shared/DOMHelpers.jsm
--- a/browser/devtools/shared/DOMHelpers.jsm
+++ b/browser/devtools/shared/DOMHelpers.jsm
@@ -132,17 +132,17 @@ DOMHelpers.prototype = {
   /**
    * A simple way to be notified (once) when a window becomes
    * interactive (DOMContentLoaded).
    *
    * It is based on the chromeEventHandler. This is useful when
    * chrome iframes are loaded in content docshells (in Firefox
    * tabs for example).
    */
-  onceDOMReady: function Helpers_onLocationChange(callback) {
+  onceDOMReady: function(callback) {
     let window = this.window;
     let docShell = window.QueryInterface(Ci.nsIInterfaceRequestor)
                          .getInterface(Ci.nsIWebNavigation)
                          .QueryInterface(Ci.nsIDocShell);
     let onReady = function(event) {
       if (event.target == window.document) {
         docShell.chromeEventHandler.removeEventListener("DOMContentLoaded", onReady, false);
         // If in `callback` the URL of the window is changed and a listener to DOMContentLoaded
diff --git a/browser/devtools/shared/DeveloperToolbar.jsm b/browser/devtools/shared/DeveloperToolbar.jsm
--- a/browser/devtools/shared/DeveloperToolbar.jsm
+++ b/browser/devtools/shared/DeveloperToolbar.jsm
@@ -300,29 +300,29 @@ Object.defineProperty(DeveloperToolbar.p
   },
   enumerable: true
 });
 
 /**
  * Is the toolbar open?
  */
 Object.defineProperty(DeveloperToolbar.prototype, 'visible', {
-  get: function DT_visible() {
+  get: function() {
     return !this._element.hidden;
   },
   enumerable: true
 });
 
 let _gSequenceId = 0;
 
 /**
  * Getter for a unique ID.
  */
 Object.defineProperty(DeveloperToolbar.prototype, 'sequenceId', {
-  get: function DT_visible() {
+  get: function() {
     return _gSequenceId++;
   },
   enumerable: true
 });
 
 /**
  * Called from browser.xul in response to menu-click or keyboard shortcut to
  * toggle the toolbar
diff --git a/browser/devtools/shared/Parser.jsm b/browser/devtools/shared/Parser.jsm
--- a/browser/devtools/shared/Parser.jsm
+++ b/browser/devtools/shared/Parser.jsm
@@ -422,17 +422,17 @@ let ParserHelpers = {
     }
     // Work around the fact that some identifier nodes don't have the
     // correct location attached.
     let { loc: parentLocation, type: parentType } = aNode._parent;
     let { loc: nodeLocation } = aNode;
     if (!nodeLocation) {
       if (parentType == "FunctionDeclaration" ||
           parentType == "FunctionExpression") {
-        // e.g. "function foo() {}" or "{ bar: function foo() {} }"
+        // e.g. "function foo() {}" or "{ bar: function() {} }"
         // The location is unavailable for the identifier node "foo".
         let loc = Cu.cloneInto(parentLocation, {});
         loc.end.line = loc.start.line;
         loc.end.column = loc.start.column + aNode.name.length;
         return loc;
       }
       if (parentType == "MemberExpression") {
         // e.g. "foo.bar"
diff --git a/browser/devtools/shared/undo.js b/browser/devtools/shared/undo.js
--- a/browser/devtools/shared/undo.js
+++ b/browser/devtools/shared/undo.js
@@ -90,17 +90,17 @@ UndoStack.prototype = {
   },
 
   /**
    * Perform an action, adding it to the undo stack.
    *
    * @param function aDo Called to perform the action.
    * @param function aUndo Called to reverse the action.
    */
-  do: function Undo_do(aDo, aUndo) {
+  do: function(aDo, aUndo) {
     this.startBatch();
     this._batch.push({ do: aDo, undo: aUndo });
     this.endBatch();
   },
 
   /*
    * Returns true if undo() will do anything.
    */
@@ -197,10 +197,10 @@ UndoStack.prototype = {
   doCommand: function Undo_doCommand(aCommand)
   {
     switch(aCommand) {
       case "cmd_undo": return this.undo();
       case "cmd_redo": return this.redo();
     }
   },
 
-  onEvent: function Undo_onEvent(aEvent) {},
+  onEvent: function(aEvent) {},
 }
diff --git a/browser/devtools/styleinspector/computed-view.js b/browser/devtools/styleinspector/computed-view.js
--- a/browser/devtools/styleinspector/computed-view.js
+++ b/browser/devtools/styleinspector/computed-view.js
@@ -80,17 +80,17 @@ UpdateProcess.prototype = {
     if (this._timeout) {
       this.win.clearTimeout(this._timeout);
       this._timeout = 0;
     }
     this.canceled = true;
     this.onCancel();
   },
 
-  _timeoutHandler: function UP_timeoutHandler() {
+  _timeoutHandler: function() {
     this._timeout = null;
     try {
       this._runBatch();
       this.schedule();
     } catch(e) {
       if (e instanceof StopIteration) {
         this.onBatch();
         this.onDone();
@@ -1245,17 +1245,17 @@ PropertyView.prototype = {
       browserWin.openUILinkIn(this.link, "tab");
     }
     aEvent.preventDefault();
   },
 
   /**
    * Destroy this property view, removing event listeners
    */
-  destroy: function PropertyView_destroy() {
+  destroy: function() {
     this.element.removeEventListener("dblclick", this.onMatchedToggle, false);
     this.element.removeEventListener("keydown", this.onKeyDown, false);
     this.element = null;
 
     this.matchedExpander.removeEventListener("click", this.onMatchedToggle, false);
     this.matchedExpander = null;
 
     this.nameNode.removeEventListener("click", this.onFocus, false);
diff --git a/browser/devtools/tilt/tilt-math.js b/browser/devtools/tilt/tilt-math.js
--- a/browser/devtools/tilt/tilt-math.js
+++ b/browser/devtools/tilt/tilt-math.js
@@ -2105,17 +2105,17 @@ let quat4 = {
   /**
    * Returns a string representation of a quaternion.
    *
    * @param {Array} aQuat
    *                quat4 to represent as a string
    *
    * @return {String} representation of the quaternion
    */
-  str: function Q4_str(aQuat) {
+  str: function(aQuat) {
     return "[" + aQuat[0] + ", " +
                  aQuat[1] + ", " +
                  aQuat[2] + ", " +
                  aQuat[3] + "]";
   }
 };
 
 exports.quat4 = quat4;
diff --git a/browser/devtools/tilt/tilt-visualizer.js b/browser/devtools/tilt/tilt-visualizer.js
--- a/browser/devtools/tilt/tilt-visualizer.js
+++ b/browser/devtools/tilt/tilt-visualizer.js
@@ -435,17 +435,17 @@ TiltVisualizer.Presenter.prototype = {
     this._setupEventListeners();
     this.canvas.focus();
   },
 
   /**
    * Get page zoom factor.
    * @return {Number}
    */
-  _getPageZoom: function TVP__getPageZoom() {
+  _getPageZoom: function() {
     return this.contentWindow
       .QueryInterface(Ci.nsIInterfaceRequestor)
       .getInterface(Ci.nsIDOMWindowUtils)
       .fullZoom;
   },
 
   /**
    * The animation logic.
@@ -1425,17 +1425,17 @@ TiltVisualizer.Controller.prototype = {
       e.stopPropagation();
       this.arcball.keyUp(code);
     }
   },
 
   /**
    * Called when the canvas looses focus.
    */
-  _onBlur: function TVC__onBlur(e) {
+  _onBlur: function(e) {
     this.arcball.cancelKeyEvents();
   },
 
   /**
    * Called when the content window of the current browser is resized.
    */
   _onResize: function TVC__onResize(e)
   {
@@ -1951,17 +1951,17 @@ TiltVisualizer.Arcball.prototype = {
 
   /**
    * Moves a target point into view only if it's outside the currently visible
    * area bounds (in which case it also resets any additional transforms).
    *
    * @param {Arary} aPoint
    *                the [x, y] point which should be brought into view
    */
-  moveIntoView: function TVA_moveIntoView(aPoint) {
+  moveIntoView: function(aPoint) {
     let visiblePointX = -(this._currentTrans[0] + this._additionalTrans[0]);
     let visiblePointY = -(this._currentTrans[1] + this._additionalTrans[1]);
 
     if (aPoint[1] - visiblePointY - MOVE_INTO_VIEW_ACCURACY > this.height ||
         aPoint[1] - visiblePointY + MOVE_INTO_VIEW_ACCURACY < 0 ||
         aPoint[0] - visiblePointX > this.width ||
         aPoint[0] - visiblePointX < 0) {
       this.reset([0, -aPoint[1]]);
diff --git a/browser/devtools/webconsole/hudservice.js b/browser/devtools/webconsole/hudservice.js
--- a/browser/devtools/webconsole/hudservice.js
+++ b/browser/devtools/webconsole/hudservice.js
@@ -62,17 +62,17 @@ HUD_SERVICE.prototype =
    */
   lastFinishedRequest: null,
 
   /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
-  currentContext: function HS_currentContext() {
+  currentContext: function() {
     return Services.wm.getMostRecentWindow("navigator:browser");
   },
 
   /**
    * Open a Web Console for the given target.
    *
    * @see devtools/framework/target.js for details about targets.
    *
diff --git a/browser/experiments/test/xpcshell/head.js b/browser/experiments/test/xpcshell/head.js
--- a/browser/experiments/test/xpcshell/head.js
+++ b/browser/experiments/test/xpcshell/head.js
@@ -199,17 +199,17 @@ function createAppInfo(optionsIn) {
     platformVersion: platformVersion ? platformVersion : "1.0",
     platformBuildID: buildID,
 
     // nsIXULRuntime
     inSafeMode: false,
     logConsoleErrors: true,
     OS: "XPCShell",
     XPCOMABI: "noarch-spidermonkey",
-    invalidateCachesOnRestart: function invalidateCachesOnRestart() {
+    invalidateCachesOnRestart: function() {
       // Do nothing
     },
 
     // nsICrashReporter
     annotations: {},
 
     annotateCrashReport: function(key, data) {
       this.annotations[key] = data;
diff --git a/browser/extensions/pdfjs/content/PdfJs.jsm b/browser/extensions/pdfjs/content/PdfJs.jsm
--- a/browser/extensions/pdfjs/content/PdfJs.jsm
+++ b/browser/extensions/pdfjs/content/PdfJs.jsm
@@ -112,55 +112,55 @@ var DEFAULT_PREFERENCES = {
         break;
     }
   }
 }
 
 // Register/unregister a constructor as a factory.
 function Factory() {}
 Factory.prototype = {
-  register: function register(targetConstructor) {
+  register: function(targetConstructor) {
     var proto = targetConstructor.prototype;
     this._classID = proto.classID;
 
     var factory = XPCOMUtils._getFactory(targetConstructor);
     this._factory = factory;
 
     var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     registrar.registerFactory(proto.classID, proto.classDescription,
                               proto.contractID, factory);
   },
 
-  unregister: function unregister() {
+  unregister: function() {
     var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     registrar.unregisterFactory(this._classID, this._factory);
     this._factory = null;
   }
 };
 
 let PdfJs = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
   _registered: false,
   _initialized: false,
 
-  init: function init(remote) {
+  init: function(remote) {
     if (Services.appinfo.processType !==
         Services.appinfo.PROCESS_TYPE_DEFAULT) {
       throw new Error('PdfJs.init should only get called ' +
                       'in the parent process.');
     }
     PdfjsChromeUtils.init();
     if (!remote) {
       PdfjsContentUtils.init();
     }
     this.initPrefs();
     this.updateRegistration();
   },
 
-  initPrefs: function initPrefs() {
+  initPrefs: function() {
     if (this._initialized) {
       return;
     }
     this._initialized = true;
 
     if (!getBoolPref(PREF_DISABLED, true)) {
       this._migrate();
     }
@@ -171,54 +171,54 @@ let PdfJs = {
     Services.prefs.addObserver(PREF_DISABLED_PLUGIN_TYPES, this, false);
     Services.obs.addObserver(this, TOPIC_PDFJS_HANDLER_CHANGED, false);
     Services.obs.addObserver(this, TOPIC_PLUGINS_LIST_UPDATED, false);
     Services.obs.addObserver(this, TOPIC_PLUGIN_INFO_UPDATED, false);
 
     initializeDefaultPreferences();
   },
 
-  updateRegistration: function updateRegistration() {
+  updateRegistration: function() {
     if (this.enabled) {
       this._ensureRegistered();
     } else {
       this._ensureUnregistered();
     }
   },
 
-  uninit: function uninit() {
+  uninit: function() {
     if (this._initialized) {
       Services.prefs.removeObserver(PREF_DISABLED, this, false);
       Services.prefs.removeObserver(PREF_DISABLED_PLUGIN_TYPES, this, false);
       Services.obs.removeObserver(this, TOPIC_PDFJS_HANDLER_CHANGED, false);
       Services.obs.removeObserver(this, TOPIC_PLUGINS_LIST_UPDATED, false);
       Services.obs.removeObserver(this, TOPIC_PLUGIN_INFO_UPDATED, false);
       this._initialized = false;
     }
     this._ensureUnregistered();
   },
 
-  _migrate: function migrate() {
+  _migrate: function() {
     const VERSION = 2;
     var currentVersion = getIntPref(PREF_MIGRATION_VERSION, 0);
     if (currentVersion >= VERSION) {
       return;
     }
     // Make pdf.js the default pdf viewer on the first migration.
     if (currentVersion < 1) {
       this._becomeHandler();
     }
     if (currentVersion < 2) {
       // cleaning up of unused database preference (see #3994)
       Services.prefs.clearUserPref(PREF_PREFIX + '.database');
     }
     Services.prefs.setIntPref(PREF_MIGRATION_VERSION, VERSION);
   },
 
-  _becomeHandler: function _becomeHandler() {
+  _becomeHandler: function() {
     let handlerInfo = Svc.mime.getFromTypeAndExtension(PDF_CONTENT_TYPE, 'pdf');
     let prefs = Services.prefs;
     if (handlerInfo.preferredAction !== Ci.nsIHandlerInfo.handleInternally &&
         handlerInfo.preferredAction !== false) {
       // Store the previous settings of preferredAction and
       // alwaysAskBeforeHandling in case we need to revert them in a hotfix that
       // would turn pdf.js off.
       prefs.setIntPref(PREF_PREVIOUS_ACTION, handlerInfo.preferredAction);
@@ -252,17 +252,17 @@ let PdfJs = {
     let categoryManager = Cc['@mozilla.org/categorymanager;1'];
     categoryManager.getService(Ci.nsICategoryManager).
                     deleteCategoryEntry('Gecko-Content-Viewers',
                                         PDF_CONTENT_TYPE,
                                         false);
   },
 
   // nsIObserver
-  observe: function observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     this.updateRegistration();
     if (Services.appinfo.processType ===
         Services.appinfo.PROCESS_TYPE_DEFAULT) {
       let jsm = 'resource://pdf.js/PdfjsChromeUtils.jsm';
       let PdfjsChromeUtils = Components.utils.import(jsm, {}).PdfjsChromeUtils;
       PdfjsChromeUtils.notifyChildOfSettingsChange();
     }
   },
@@ -307,17 +307,17 @@ let PdfJs = {
         return mimeType === PDF_CONTENT_TYPE;
       });
     });
 
     // Use pdf.js if pdf plugin is not present or disabled
     return !enabledPluginFound;
   },
 
-  _ensureRegistered: function _ensureRegistered() {
+  _ensureRegistered: function() {
     if (this._registered) {
       return;
     }
     this._pdfStreamConverterFactory = new Factory();
     Cu.import('resource://pdf.js/PdfStreamConverter.jsm');
     this._pdfStreamConverterFactory.register(PdfStreamConverter);
 
     this._pdfRedirectorFactory = new Factory();
@@ -325,17 +325,17 @@ let PdfJs = {
     this._pdfRedirectorFactory.register(PdfRedirector);
 
     Svc.pluginHost.registerPlayPreviewMimeType(PDF_CONTENT_TYPE, true,
       'data:application/x-moz-playpreview-pdfjs;,');
 
     this._registered = true;
   },
 
-  _ensureUnregistered: function _ensureUnregistered() {
+  _ensureUnregistered: function() {
     if (!this._registered) {
       return;
     }
     this._pdfStreamConverterFactory.unregister();
     Cu.unload('resource://pdf.js/PdfStreamConverter.jsm');
     delete this._pdfStreamConverterFactory;
 
     this._pdfRedirectorFactory.unregister();
diff --git a/browser/extensions/pdfjs/content/PdfStreamConverter.jsm b/browser/extensions/pdfjs/content/PdfStreamConverter.jsm
--- a/browser/extensions/pdfjs/content/PdfStreamConverter.jsm
+++ b/browser/extensions/pdfjs/content/PdfStreamConverter.jsm
@@ -166,17 +166,17 @@ function makeContentReadable(obj, window
 // PDF data storage
 function PdfDataListener(length) {
   this.length = length; // less than 0, if length is unknown
   this.buffer = null;
   this.loaded = 0;
 }
 
 PdfDataListener.prototype = {
-  append: function PdfDataListener_append(chunk) {
+  append: function(chunk) {
     // In most of the cases we will pass data as we receive it, but at the
     // beginning of the loading we may accumulate some data.
     if (!this.buffer) {
       this.buffer = new Uint8Array(chunk);
     } else {
       var buffer = this.buffer;
       var newBuffer = new Uint8Array(buffer.length + chunk.length);
       newBuffer.set(buffer);
@@ -184,28 +184,28 @@ PdfDataListener.prototype = {
       this.buffer = newBuffer;
     }
     this.loaded += chunk.length;
     if (this.length >= 0 && this.length < this.loaded) {
       this.length = -1; // reset the length, server is giving incorrect one
     }
     this.onprogress(this.loaded, this.length >= 0 ? this.length : void(0));
   },
-  readData: function PdfDataListener_readData() {
+  readData: function() {
     var result = this.buffer;
     this.buffer = null;
     return result;
   },
-  finish: function PdfDataListener_finish() {
+  finish: function() {
     this.isDataReady = true;
     if (this.oncompleteCallback) {
       this.oncompleteCallback(this.readData());
     }
   },
-  error: function PdfDataListener_error(errorCode) {
+  error: function(errorCode) {
     this.errorCode = errorCode;
     if (this.oncompleteCallback) {
       this.oncompleteCallback(null, errorCode);
     }
   },
   onprogress: function() {},
   get oncomplete() {
     return this.oncompleteCallback;
@@ -626,24 +626,24 @@ var RangedChromeActions = (function Rang
 
     var begin = args.begin;
     var end = args.end;
     var domWindow = this.domWindow;
     // TODO(mack): Support error handler. We're not currently not handling
     // errors from chrome code for non-range requests, so this doesn't
     // seem high-pri
     this.networkManager.requestRange(begin, end, {
-      onDone: function RangedChromeActions_onDone(args) {
+      onDone: function(args) {
         domWindow.postMessage({
           pdfjsLoadAction: 'range',
           begin: args.begin,
           chunk: args.chunk
         }, '*');
       },
-      onProgress: function RangedChromeActions_onProgress(evt) {
+      onProgress: function(evt) {
         domWindow.postMessage({
           pdfjsLoadAction: 'rangeProgress',
           loaded: evt.loaded,
         }, '*');
       }
     });
   };
 
diff --git a/browser/extensions/pdfjs/content/build/pdf.js b/browser/extensions/pdfjs/content/build/pdf.js
--- a/browser/extensions/pdfjs/content/build/pdf.js
+++ b/browser/extensions/pdfjs/content/build/pdf.js
@@ -531,17 +531,17 @@ function isLittleEndian() {
   var buffer8 = new Uint8Array(2);
   buffer8[0] = 1;
   var buffer16 = new Uint16Array(buffer8.buffer);
   return (buffer16[0] === 1);
 }
 
 Object.defineProperty(PDFJS, 'isLittleEndian', {
   configurable: true,
-  get: function PDFJS_isLittleEndian() {
+  get: function() {
     return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
   }
 });
 
   PDFJS.hasCanvasTypedArrays = true;
 
 var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
 
@@ -839,34 +839,34 @@ var PageViewport = PDFJS.PageViewport = 
   PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
     /**
      * Clones viewport with additional properties.
      * @param args {Object} (optional) If specified, may contain the 'scale' or
      * 'rotation' properties to override the corresponding properties in
      * the cloned viewport.
      * @returns {PDFJS.PageViewport} Cloned viewport.
      */
-    clone: function PageViewPort_clone(args) {
+    clone: function(args) {
       args = args || {};
       var scale = 'scale' in args ? args.scale : this.scale;
       var rotation = 'rotation' in args ? args.rotation : this.rotation;
       return new PageViewport(this.viewBox.slice(), scale, rotation,
                               this.offsetX, this.offsetY, args.dontFlip);
     },
     /**
      * Converts PDF point to the viewport coordinates. For examples, useful for
      * converting PDF location into canvas pixel coordinates.
      * @param x {number} X coordinate.
      * @param y {number} Y coordinate.
      * @returns {Object} Object that contains 'x' and 'y' properties of the
      * point in the viewport coordinate space.
      * @see {@link convertToPdfPoint}
      * @see {@link convertToViewportRectangle}
      */
-    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
+    convertToViewportPoint: function(x, y) {
       return Util.applyTransform([x, y], this.transform);
     },
     /**
      * Converts PDF rectangle to the viewport coordinates.
      * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
      * @returns {Array} Contains corresponding coordinates of the rectangle
      * in the viewport coordinate space.
      * @see {@link convertToViewportPoint}
@@ -881,17 +881,17 @@ var PageViewport = PDFJS.PageViewport = 
      * Converts viewport coordinates to the PDF location. For examples, useful
      * for converting canvas pixel location into PDF one.
      * @param x {number} X coordinate.
      * @param y {number} Y coordinate.
      * @returns {Object} Object that contains 'x' and 'y' properties of the
      * point in the PDF coordinate space.
      * @see {@link convertToViewportPoint}
      */
-    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
+    convertToPdfPoint: function(x, y) {
       return Util.applyInverseTransform([x, y], this.transform);
     }
   };
   return PageViewport;
 })();
 
 var PDFStringTranslateTable = [
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -1081,41 +1081,41 @@ var StatTimer = (function StatTimerClosu
     return str;
   }
   function StatTimer() {
     this.started = {};
     this.times = [];
     this.enabled = true;
   }
   StatTimer.prototype = {
-    time: function StatTimer_time(name) {
+    time: function(name) {
       if (!this.enabled) {
         return;
       }
       if (name in this.started) {
         warn('Timer is already running for ' + name);
       }
       this.started[name] = Date.now();
     },
-    timeEnd: function StatTimer_timeEnd(name) {
+    timeEnd: function(name) {
       if (!this.enabled) {
         return;
       }
       if (!(name in this.started)) {
         warn('Timer has not been started for ' + name);
       }
       this.times.push({
         'name': name,
         'start': this.started[name],
         'end': Date.now()
       });
       // Remove timer from started so it can be called again.
       delete this.started[name];
     },
-    toString: function StatTimer_toString() {
+    toString: function() {
       var i, ii;
       var times = this.times;
       var out = '';
       // Find the longest name for padding purposes.
       var longest = 0;
       for (i = 0, ii = times.length; i < ii; ++i) {
         var name = times[i]['name'];
         if (name.length > longest) {
@@ -1225,30 +1225,30 @@ function MessageHandler(name, comObj) {
       }
     } else {
       error('Unknown action from worker: ' + data.action);
     }
   };
 }
 
 MessageHandler.prototype = {
-  on: function messageHandlerOn(actionName, handler, scope) {
+  on: function(actionName, handler, scope) {
     var ah = this.actionHandler;
     if (ah[actionName]) {
       error('There is already an actionName called "' + actionName + '"');
     }
     ah[actionName] = [handler, scope];
   },
   /**
    * Sends a message to the comObj to invoke the action with the supplied data.
    * @param {String} actionName Action to call.
    * @param {JSON} data JSON data to send.
    * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
    */
-  send: function messageHandlerSend(actionName, data, transfers) {
+  send: function(actionName, data, transfers) {
     var message = {
       action: actionName,
       data: data
     };
     this.postMessage(message, transfers);
   },
   /**
    * Sends a message to the comObj to invoke the action with the supplied data.
@@ -1606,17 +1606,17 @@ var PDFDocumentLoadingTask = (function P
     /**
      * Registers callbacks to indicate the document loading completion.
      *
      * @param {function} onFulfilled The callback for the loading completion.
      * @param {function} onRejected The callback for the loading failure.
      * @return {Promise} A promise that is resolved after the onFulfilled or
      *                   onRejected callback.
      */
-    then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {
+    then: function(onFulfilled, onRejected) {
       return this.promise.then.apply(this.promise, arguments);
     }
   };
 
   return PDFDocumentLoadingTask;
 })();
 
 /**
@@ -1650,24 +1650,24 @@ var PDFDataRangeTransport = (function pd
       this._progressListeners.push(listener);
     },
 
     addProgressiveReadListener:
         function PDFDataRangeTransport_addProgressiveReadListener(listener) {
       this._progressiveReadListeners.push(listener);
     },
 
-    onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {
+    onDataRange: function(begin, chunk) {
       var listeners = this._rangeListeners;
       for (var i = 0, n = listeners.length; i < n; ++i) {
         listeners[i](begin, chunk);
       }
     },
 
-    onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {
+    onDataProgress: function(loaded) {
       this._readyCapability.promise.then(function () {
         var listeners = this._progressListeners;
         for (var i = 0, n = listeners.length; i < n; ++i) {
           listeners[i](loaded);
         }
       }.bind(this));
     },
 
@@ -1676,17 +1676,17 @@ var PDFDataRangeTransport = (function pd
       this._readyCapability.promise.then(function () {
         var listeners = this._progressiveReadListeners;
         for (var i = 0, n = listeners.length; i < n; ++i) {
           listeners[i](chunk);
         }
       }.bind(this));
     },
 
-    transportReady: function PDFDataRangeTransport_transportReady() {
+    transportReady: function() {
       this._readyCapability.resolve();
     },
 
     requestDataRange:
         function PDFDataRangeTransport_requestDataRange(begin, end) {
       throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');
     }
   };
@@ -1719,57 +1719,57 @@ var PDFDocumentProxy = (function PDFDocu
     get fingerprint() {
       return this.pdfInfo.fingerprint;
     },
     /**
      * @param {number} pageNumber The page number to get. The first page is 1.
      * @return {Promise} A promise that is resolved with a {@link PDFPageProxy}
      * object.
      */
-    getPage: function PDFDocumentProxy_getPage(pageNumber) {
+    getPage: function(pageNumber) {
       return this.transport.getPage(pageNumber);
     },
     /**
      * @param {{num: number, gen: number}} ref The page reference. Must have
      *   the 'num' and 'gen' properties.
      * @return {Promise} A promise that is resolved with the page index that is
      * associated with the reference.
      */
-    getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {
+    getPageIndex: function(ref) {
       return this.transport.getPageIndex(ref);
     },
     /**
      * @return {Promise} A promise that is resolved with a lookup table for
      * mapping named destinations to reference numbers.
      *
      * This can be slow for large documents: use getDestination instead
      */
-    getDestinations: function PDFDocumentProxy_getDestinations() {
+    getDestinations: function() {
       return this.transport.getDestinations();
     },
     /**
      * @param {string} id The named destination to get.
      * @return {Promise} A promise that is resolved with all information
      * of the given named destination.
      */
-    getDestination: function PDFDocumentProxy_getDestination(id) {
+    getDestination: function(id) {
       return this.transport.getDestination(id);
     },
     /**
      * @return {Promise} A promise that is resolved with a lookup table for
      * mapping named attachments to their content.
      */
-    getAttachments: function PDFDocumentProxy_getAttachments() {
+    getAttachments: function() {
       return this.transport.getAttachments();
     },
     /**
      * @return {Promise} A promise that is resolved with an array of all the
      * JavaScript strings in the name tree.
      */
-    getJavaScript: function PDFDocumentProxy_getJavaScript() {
+    getJavaScript: function() {
       return this.transport.getJavaScript();
     },
     /**
      * @return {Promise} A promise that is resolved with an {Array} that is a
      * tree outline (if it has one) of the PDF. The tree is in the format of:
      * [
      *  {
      *   title: string,
@@ -1777,60 +1777,60 @@ var PDFDocumentProxy = (function PDFDocu
      *   italic: boolean,
      *   color: rgb array,
      *   dest: dest obj,
      *   items: array of more items like this
      *  },
      *  ...
      * ].
      */
-    getOutline: function PDFDocumentProxy_getOutline() {
+    getOutline: function() {
       return this.transport.getOutline();
     },
     /**
      * @return {Promise} A promise that is resolved with an {Object} that has
      * info and metadata properties.  Info is an {Object} filled with anything
      * available in the information dictionary and similarly metadata is a
      * {Metadata} object with information from the metadata section of the PDF.
      */
-    getMetadata: function PDFDocumentProxy_getMetadata() {
+    getMetadata: function() {
       return this.transport.getMetadata();
     },
     /**
      * @return {Promise} A promise that is resolved with a TypedArray that has
      * the raw data from the PDF.
      */
-    getData: function PDFDocumentProxy_getData() {
+    getData: function() {
       return this.transport.getData();
     },
     /**
      * @return {Promise} A promise that is resolved when the document's data
      * is loaded. It is resolved with an {Object} that contains the length
      * property that indicates size of the PDF data in bytes.
      */
-    getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {
+    getDownloadInfo: function() {
       return this.transport.downloadInfoCapability.promise;
     },
     /**
      * @return {Promise} A promise this is resolved with current stats about
      * document structures (see {@link PDFDocumentStats}).
      */
-    getStats: function PDFDocumentProxy_getStats() {
+    getStats: function() {
       return this.transport.getStats();
     },
     /**
      * Cleans up resources allocated by the document, e.g. created @font-face.
      */
-    cleanup: function PDFDocumentProxy_cleanup() {
+    cleanup: function() {
       this.transport.startCleanup();
     },
     /**
      * Destroys current document instance and terminates worker.
      */
-    destroy: function PDFDocumentProxy_destroy() {
+    destroy: function() {
       this.transport.destroy();
     }
   };
   return PDFDocumentProxy;
 })();
 
 /**
  * Page text content.
@@ -1935,42 +1935,42 @@ var PDFPageProxy = (function PDFPageProx
     },
     /**
      * @param {number} scale The desired scale of the viewport.
      * @param {number} rotate Degrees to rotate the viewport. If omitted this
      * defaults to the page rotation.
      * @return {PDFJS.PageViewport} Contains 'width' and 'height' properties
      * along with transforms required for rendering.
      */
-    getViewport: function PDFPageProxy_getViewport(scale, rotate) {
+    getViewport: function(scale, rotate) {
       if (arguments.length < 2) {
         rotate = this.rotate;
       }
       return new PDFJS.PageViewport(this.view, scale, rotate, 0, 0);
     },
     /**
      * @return {Promise} A promise that is resolved with an {Array} of the
      * annotation objects.
      */
-    getAnnotations: function PDFPageProxy_getAnnotations() {
+    getAnnotations: function() {
       if (this.annotationsPromise) {
         return this.annotationsPromise;
       }
 
       var promise = this.transport.getAnnotations(this.pageIndex);
       this.annotationsPromise = promise;
       return promise;
     },
     /**
      * Begins the process of rendering a page to the desired context.
      * @param {RenderParameters} params Page render parameters.
      * @return {RenderTask} An object that contains the promise, which
      *                      is resolved when the page finishes rendering.
      */
-    render: function PDFPageProxy_render(params) {
+    render: function(params) {
       var stats = this.stats;
       stats.time('Overall');
 
       // If there was a pending destroy cancel it so no cleanup happens during
       // this call to render.
       this.pendingDestroy = false;
 
       var renderingIntent = (params.intent === 'print' ? 'print' : 'display');
@@ -2052,17 +2052,17 @@ var PDFPageProxy = (function PDFPageProx
 
       return renderTask;
     },
 
     /**
      * @return {Promise} A promise resolved with an {@link PDFOperatorList}
      * object that represents page's operator list.
      */
-    getOperatorList: function PDFPageProxy_getOperatorList() {
+    getOperatorList: function() {
       function operatorListChanged() {
         if (intentState.operatorList.lastChunk) {
           intentState.opListReadCapability.resolve(intentState.operatorList);
         }
       }
 
       var renderingIntent = 'oplist';
       if (!this.intentStates[renderingIntent]) {
@@ -2090,34 +2090,34 @@ var PDFPageProxy = (function PDFPageProx
       }
       return intentState.opListReadCapability.promise;
     },
 
     /**
      * @return {Promise} That is resolved a {@link TextContent}
      * object that represent the page text content.
      */
-    getTextContent: function PDFPageProxy_getTextContent() {
+    getTextContent: function() {
       return this.transport.messageHandler.sendWithPromise('GetTextContent', {
         pageIndex: this.pageNumber - 1
       });
     },
     /**
      * Destroys resources allocated by the page.
      */
-    destroy: function PDFPageProxy_destroy() {
+    destroy: function() {
       this.pendingDestroy = true;
       this._tryDestroy();
     },
     /**
      * For internal use only. Attempts to clean up if rendering is in a state
      * where that's possible.
      * @ignore
      */
-    _tryDestroy: function PDFPageProxy__destroy() {
+    _tryDestroy: function() {
       if (!this.pendingDestroy ||
           Object.keys(this.intentStates).some(function(intent) {
             var intentState = this.intentStates[intent];
             return (intentState.renderTasks.length !== 0 ||
                     intentState.receivingOperatorList);
           }, this)) {
         return;
       }
@@ -2235,48 +2235,48 @@ var WorkerTransport = (function WorkerTr
         info('The worker has been disabled.');
       }
     }
     // Either workers are disabled, not supported or have thrown an exception.
     // Thus, we fallback to a faked worker.
     this.setupFakeWorker();
   }
   WorkerTransport.prototype = {
-    destroy: function WorkerTransport_destroy() {
+    destroy: function() {
       this.pageCache = [];
       this.pagePromises = [];
       var self = this;
       this.messageHandler.sendWithPromise('Terminate', null).then(function () {
         FontLoader.clear();
         if (self.worker) {
           self.worker.terminate();
         }
       });
     },
 
-    setupFakeWorker: function WorkerTransport_setupFakeWorker() {
+    setupFakeWorker: function() {
       globalScope.PDFJS.disableWorker = true;
 
       if (!PDFJS.fakeWorkerFilesLoadedCapability) {
         PDFJS.fakeWorkerFilesLoadedCapability = createPromiseCapability();
         // In the developer build load worker_loader which in turn loads all the
         // other files and resolves the promise. In production only the
         // pdf.worker.js file is needed.
         Util.loadScript(PDFJS.workerSrc, function() {
           PDFJS.fakeWorkerFilesLoadedCapability.resolve();
         });
       }
       PDFJS.fakeWorkerFilesLoadedCapability.promise.then(function () {
         warn('Setting up fake worker.');
         // If we don't use a worker, just post/sendMessage to the main thread.
         var fakeWorker = {
-          postMessage: function WorkerTransport_postMessage(obj) {
+          postMessage: function(obj) {
             fakeWorker.onmessage({data: obj});
           },
-          terminate: function WorkerTransport_terminate() {}
+          terminate: function() {}
         };
 
         var messageHandler = new MessageHandler('main', fakeWorker);
         this.setupMessageHandler(messageHandler);
 
         // If the main thread is our worker, setup the handling for the messages
         // the main thread sends to it self.
         PDFJS.WorkerMessageHandler.setup(messageHandler);
@@ -2520,17 +2520,17 @@ var WorkerTransport = (function WorkerTr
           img.onerror = function () {
             reject(new Error('JpegDecode failed to load image'));
           };
           img.src = imageUrl;
         });
       });
     },
 
-    fetchDocument: function WorkerTransport_fetchDocument(loadingTask, source) {
+    fetchDocument: function(loadingTask, source) {
       this.loadingTask = loadingTask;
 
       source.disableAutoFetch = PDFJS.disableAutoFetch;
       source.disableStream = PDFJS.disableStream;
       source.chunkedViewerLoading = !!this.pdfDataRangeTransport;
       if (this.pdfDataRangeTransport) {
         source.length = this.pdfDataRangeTransport.length;
         source.initialData = this.pdfDataRangeTransport.initialData;
@@ -2542,21 +2542,21 @@ var WorkerTransport = (function WorkerTr
         cMapUrl: PDFJS.cMapUrl,
         cMapPacked: PDFJS.cMapPacked,
         disableFontFace: PDFJS.disableFontFace,
         disableCreateObjectURL: PDFJS.disableCreateObjectURL,
         verbosity: PDFJS.verbosity
       });
     },
 
-    getData: function WorkerTransport_getData() {
+    getData: function() {
       return this.messageHandler.sendWithPromise('GetData', null);
     },
 
-    getPage: function WorkerTransport_getPage(pageNumber, capability) {
+    getPage: function(pageNumber, capability) {
       if (pageNumber <= 0 || pageNumber > this.numPages ||
           (pageNumber|0) !== pageNumber) {
         return Promise.reject(new Error('Invalid page request'));
       }
 
       var pageIndex = pageNumber - 1;
       if (pageIndex in this.pagePromises) {
         return this.pagePromises[pageIndex];
@@ -2567,60 +2567,60 @@ var WorkerTransport = (function WorkerTr
         var page = new PDFPageProxy(pageIndex, pageInfo, this);
         this.pageCache[pageIndex] = page;
         return page;
       }.bind(this));
       this.pagePromises[pageIndex] = promise;
       return promise;
     },
 
-    getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {
+    getPageIndex: function(ref) {
       return this.messageHandler.sendWithPromise('GetPageIndex', { ref: ref });
     },
 
-    getAnnotations: function WorkerTransport_getAnnotations(pageIndex) {
+    getAnnotations: function(pageIndex) {
       return this.messageHandler.sendWithPromise('GetAnnotations',
         { pageIndex: pageIndex });
     },
 
-    getDestinations: function WorkerTransport_getDestinations() {
+    getDestinations: function() {
       return this.messageHandler.sendWithPromise('GetDestinations', null);
     },
 
-    getDestination: function WorkerTransport_getDestination(id) {
+    getDestination: function(id) {
       return this.messageHandler.sendWithPromise('GetDestination', { id: id } );
     },
 
-    getAttachments: function WorkerTransport_getAttachments() {
+    getAttachments: function() {
       return this.messageHandler.sendWithPromise('GetAttachments', null);
     },
 
-    getJavaScript: function WorkerTransport_getJavaScript() {
+    getJavaScript: function() {
       return this.messageHandler.sendWithPromise('GetJavaScript', null);
     },
 
-    getOutline: function WorkerTransport_getOutline() {
+    getOutline: function() {
       return this.messageHandler.sendWithPromise('GetOutline', null);
     },
 
-    getMetadata: function WorkerTransport_getMetadata() {
+    getMetadata: function() {
       return this.messageHandler.sendWithPromise('GetMetadata', null).
         then(function transportMetadata(results) {
         return {
           info: results[0],
           metadata: (results[1] ? new PDFJS.Metadata(results[1]) : null)
         };
       });
     },
 
-    getStats: function WorkerTransport_getStats() {
+    getStats: function() {
       return this.messageHandler.sendWithPromise('GetStats', null);
     },
 
-    startCleanup: function WorkerTransport_startCleanup() {
+    startCleanup: function() {
       this.messageHandler.sendWithPromise('Cleanup', null).
         then(function endCleanup() {
         for (var i = 0, ii = this.pageCache.length; i < ii; i++) {
           var page = this.pageCache[i];
           if (page) {
             page.destroy();
           }
         }
@@ -2645,17 +2645,17 @@ var PDFObjects = (function PDFObjectsClo
     this.objs = {};
   }
 
   PDFObjects.prototype = {
     /**
      * Internal function.
      * Ensures there is an object defined for `objId`.
      */
-    ensureObj: function PDFObjects_ensureObj(objId) {
+    ensureObj: function(objId) {
       if (this.objs[objId]) {
         return this.objs[objId];
       }
 
       var obj = {
         capability: createPromiseCapability(),
         data: null,
         resolved: false
@@ -2669,17 +2669,17 @@ var PDFObjects = (function PDFObjectsClo
      * If called *without* callback, this returns the data of `objId` but the
      * object needs to be resolved. If it isn't, this function throws.
      *
      * If called *with* a callback, the callback is called with the data of the
      * object once the object is resolved. That means, if you call this
      * function and the object is already resolved, the callback gets called
      * right away.
      */
-    get: function PDFObjects_get(objId, callback) {
+    get: function(objId, callback) {
       // If there is a callback, then the get can be async and the object is
       // not required to be resolved right now
       if (callback) {
         this.ensureObj(objId).capability.promise.then(callback);
         return null;
       }
 
       // If there isn't a callback, the user expects to get the resolved data
@@ -2693,51 +2693,51 @@ var PDFObjects = (function PDFObjectsClo
       }
 
       return obj.data;
     },
 
     /**
      * Resolves the object `objId` with optional `data`.
      */
-    resolve: function PDFObjects_resolve(objId, data) {
+    resolve: function(objId, data) {
       var obj = this.ensureObj(objId);
 
       obj.resolved = true;
       obj.data = data;
       obj.capability.resolve(data);
     },
 
-    isResolved: function PDFObjects_isResolved(objId) {
+    isResolved: function(objId) {
       var objs = this.objs;
 
       if (!objs[objId]) {
         return false;
       } else {
         return objs[objId].resolved;
       }
     },
 
-    hasData: function PDFObjects_hasData(objId) {
+    hasData: function(objId) {
       return this.isResolved(objId);
     },
 
     /**
      * Returns the data of `objId` if object exists, null otherwise.
      */
-    getData: function PDFObjects_getData(objId) {
+    getData: function(objId) {
       var objs = this.objs;
       if (!objs[objId] || !objs[objId].resolved) {
         return null;
       } else {
         return objs[objId].data;
       }
     },
 
-    clear: function PDFObjects_clear() {
+    clear: function() {
       this.objs = {};
     }
   };
   return PDFObjects;
 })();
 
 /**
  * Allows controlling of the rendering tasks.
@@ -2765,29 +2765,29 @@ var RenderTask = (function RenderTaskClo
       return this._internalRenderTask.capability.promise;
     },
 
     /**
      * Cancels the rendering task. If the task is currently rendering it will
      * not be cancelled until graphics pauses with a timeout. The promise that
      * this object extends will resolved when cancelled.
      */
-    cancel: function RenderTask_cancel() {
+    cancel: function() {
       this._internalRenderTask.cancel();
     },
 
     /**
      * Registers callbacks to indicate the rendering task completion.
      *
      * @param {function} onFulfilled The callback for the rendering completion.
      * @param {function} onRejected The callback for the rendering failure.
      * @return {Promise} A promise that is resolved after the onFulfilled or
      *                   onRejected callback.
      */
-    then: function RenderTask_then(onFulfilled, onRejected) {
+    then: function(onFulfilled, onRejected) {
       return this.promise.then.apply(this.promise, arguments);
     }
   };
 
   return RenderTask;
 })();
 
 /**
@@ -2839,23 +2839,23 @@ var InternalRenderTask = (function Inter
       this.gfx.beginDrawing(params.viewport, transparency);
       this.operatorListIdx = 0;
       this.graphicsReady = true;
       if (this.graphicsReadyCallback) {
         this.graphicsReadyCallback();
       }
     },
 
-    cancel: function InternalRenderTask_cancel() {
+    cancel: function() {
       this.running = false;
       this.cancelled = true;
       this.callback('cancelled');
     },
 
-    operatorListChanged: function InternalRenderTask_operatorListChanged() {
+    operatorListChanged: function() {
       if (!this.graphicsReady) {
         if (!this.graphicsReadyCallback) {
           this.graphicsReadyCallback = this._continueBound;
         }
         return;
       }
 
       if (this.stepper) {
@@ -2863,33 +2863,33 @@ var InternalRenderTask = (function Inter
       }
 
       if (this.running) {
         return;
       }
       this._continue();
     },
 
-    _continue: function InternalRenderTask__continue() {
+    _continue: function() {
       this.running = true;
       if (this.cancelled) {
         return;
       }
       if (this.task.onContinue) {
         this.task.onContinue.call(this.task, this._scheduleNextBound);
       } else {
         this._scheduleNext();
       }
     },
 
-    _scheduleNext: function InternalRenderTask__scheduleNext() {
+    _scheduleNext: function() {
       window.requestAnimationFrame(this._nextBound);
     },
 
-    _next: function InternalRenderTask__next() {
+    _next: function() {
       if (this.cancelled) {
         return;
       }
       this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,
                                         this.operatorListIdx,
                                         this._continueBound,
                                         this.stepper);
       if (this.operatorListIdx === this.operatorList.argsArray.length) {
@@ -2937,17 +2937,17 @@ var Metadata = PDFJS.Metadata = (functio
     }
 
     this.metaDocument = meta;
     this.metadata = {};
     this.parse();
   }
 
   Metadata.prototype = {
-    parse: function Metadata_parse() {
+    parse: function() {
       var doc = this.metaDocument;
       var rdf = doc.documentElement;
 
       if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') { // Wrapped in <xmpmeta>
         rdf = rdf.firstChild;
         while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
           rdf = rdf.nextSibling;
         }
@@ -2970,21 +2970,21 @@ var Metadata = PDFJS.Metadata = (functio
             entry = desc.childNodes[ii];
             name = entry.nodeName.toLowerCase();
             this.metadata[name] = entry.textContent.trim();
           }
         }
       }
     },
 
-    get: function Metadata_get(name) {
+    get: function(name) {
       return this.metadata[name] || null;
     },
 
-    has: function Metadata_has(name) {
+    has: function(name) {
       return typeof this.metadata[name] !== 'undefined';
     }
   };
 
   return Metadata;
 })();
 
 
@@ -3025,23 +3025,23 @@ function addContextCurrentTransform(ctx)
     ctx._originalTranslate = ctx.translate;
     ctx._originalTransform = ctx.transform;
     ctx._originalSetTransform = ctx.setTransform;
 
     ctx._transformMatrix = [ctx._scaleX, 0, 0, ctx._scaleY, 0, 0];
     ctx._transformStack = [];
 
     Object.defineProperty(ctx, 'mozCurrentTransform', {
-      get: function getCurrentTransform() {
+      get: function() {
         return this._transformMatrix;
       }
     });
 
     Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
-      get: function getCurrentTransformInverse() {
+      get: function() {
         // Calculation done using WolframAlpha:
         // http://www.wolframalpha.com/input/?
         //   i=Inverse+{{a%2C+c%2C+e}%2C+{b%2C+d%2C+f}%2C+{0%2C+0%2C+1}}
 
         var m = this._transformMatrix;
         var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
 
         var ad_bc = a * d - b * c;
@@ -3357,20 +3357,20 @@ var CanvasExtraState = (function CanvasE
     this.strokeAlpha = 1;
     this.lineWidth = 1;
     this.activeSMask = null; // nonclonable field (see the save method below)
 
     this.old = old;
   }
 
   CanvasExtraState.prototype = {
-    clone: function CanvasExtraState_clone() {
+    clone: function() {
       return Object.create(this);
     },
-    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
+    setCurrentPoint: function(x, y) {
       this.x = x;
       this.y = y;
     }
   };
   return CanvasExtraState;
 })();
 
 var CanvasGraphics = (function CanvasGraphicsClosure() {
@@ -3670,17 +3670,17 @@ var CanvasGraphics = (function CanvasGra
 
   var LINE_CAP_STYLES = ['butt', 'round', 'square'];
   var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
   var NORMAL_CLIP = {};
   var EO_CLIP = {};
 
   CanvasGraphics.prototype = {
 
-    beginDrawing: function CanvasGraphics_beginDrawing(viewport, transparency) {
+    beginDrawing: function(viewport, transparency) {
       // For pdfs that use blend modes we have to clear the canvas else certain
       // blend modes can look wrong since we'd be blending with a white
       // backdrop. The problem with a transparent backdrop though is we then
       // don't get sub pixel anti aliasing on text, so we fill with white if
       // we can.
       var width = this.ctx.canvas.width;
       var height = this.ctx.canvas.height;
       if (transparency) {
@@ -3771,60 +3771,60 @@ var CanvasGraphics = (function CanvasGra
           steps = 0;
         }
 
         // If the operatorList isn't executed completely yet OR the execution
         // time was short enough, do another execution round.
       }
     },
 
-    endDrawing: function CanvasGraphics_endDrawing() {
+    endDrawing: function() {
       this.ctx.restore();
       CachedCanvases.clear();
       WebGLUtils.clear();
 
       if (this.imageLayer) {
         this.imageLayer.endLayout();
       }
     },
 
     // Graphics state
-    setLineWidth: function CanvasGraphics_setLineWidth(width) {
+    setLineWidth: function(width) {
       this.current.lineWidth = width;
       this.ctx.lineWidth = width;
     },
-    setLineCap: function CanvasGraphics_setLineCap(style) {
+    setLineCap: function(style) {
       this.ctx.lineCap = LINE_CAP_STYLES[style];
     },
-    setLineJoin: function CanvasGraphics_setLineJoin(style) {
+    setLineJoin: function(style) {
       this.ctx.lineJoin = LINE_JOIN_STYLES[style];
     },
-    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
+    setMiterLimit: function(limit) {
       this.ctx.miterLimit = limit;
     },
-    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
+    setDash: function(dashArray, dashPhase) {
       var ctx = this.ctx;
       if (ctx.setLineDash !== undefined) {
         ctx.setLineDash(dashArray);
         ctx.lineDashOffset = dashPhase;
       } else {
         ctx.mozDash = dashArray;
         ctx.mozDashOffset = dashPhase;
       }
     },
-    setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {
+    setRenderingIntent: function(intent) {
       // Maybe if we one day fully support color spaces this will be important
       // for now we can ignore.
       // TODO set rendering intent?
     },
-    setFlatness: function CanvasGraphics_setFlatness(flatness) {
+    setFlatness: function(flatness) {
       // There's no way to control this with canvas, but we can safely ignore.
       // TODO set flatness?
     },
-    setGState: function CanvasGraphics_setGState(states) {
+    setGState: function(states) {
       for (var i = 0, ii = states.length; i < ii; i++) {
         var state = states[i];
         var key = state[0];
         var value = state[1];
 
         switch (key) {
           case 'LW':
             this.setLineWidth(value);
@@ -3881,17 +3881,17 @@ var CanvasGraphics = (function CanvasGra
             if (this.current.activeSMask) {
               this.beginSMaskGroup();
             }
             this.tempSMask = null;
             break;
         }
       }
     },
-    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
+    beginSMaskGroup: function() {
 
       var activeSMask = this.current.activeSMask;
       var drawnWidth = activeSMask.canvas.width;
       var drawnHeight = activeSMask.canvas.height;
       var cacheId = 'smaskGroupAt' + this.groupLevel;
       var scratchCanvas = CachedCanvases.getCanvas(
         cacheId, drawnWidth, drawnHeight, true);
 
@@ -3909,51 +3909,51 @@ var CanvasGraphics = (function CanvasGra
       this.setGState([
         ['BM', 'Normal'],
         ['ca', 1],
         ['CA', 1]
       ]);
       this.groupStack.push(currentCtx);
       this.groupLevel++;
     },
-    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
+    endSMaskGroup: function() {
       var groupCtx = this.ctx;
       this.groupLevel--;
       this.ctx = this.groupStack.pop();
 
       composeSMask(this.ctx, this.current.activeSMask, groupCtx);
       this.ctx.restore();
     },
-    save: function CanvasGraphics_save() {
+    save: function() {
       this.ctx.save();
       var old = this.current;
       this.stateStack.push(old);
       this.current = old.clone();
       this.current.activeSMask = null;
     },
-    restore: function CanvasGraphics_restore() {
+    restore: function() {
       if (this.stateStack.length !== 0) {
         if (this.current.activeSMask !== null) {
           this.endSMaskGroup();
         }
 
         this.current = this.stateStack.pop();
         this.ctx.restore();
 
         this.cachedGetSinglePixelWidth = null;
       }
     },
-    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
+    transform: function(a, b, c, d, e, f) {
       this.ctx.transform(a, b, c, d, e, f);
 
       this.cachedGetSinglePixelWidth = null;
     },
 
     // Path
-    constructPath: function CanvasGraphics_constructPath(ops, args) {
+    constructPath: function(ops, args) {
       var ctx = this.ctx;
       var current = this.current;
       var x = current.x, y = current.y;
       for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
         switch (ops[i] | 0) {
           case OPS.rectangle:
             x = args[j++];
             y = args[j++];
@@ -4006,20 +4006,20 @@ var CanvasGraphics = (function CanvasGra
             break;
           case OPS.closePath:
             ctx.closePath();
             break;
         }
       }
       current.setCurrentPoint(x, y);
     },
-    closePath: function CanvasGraphics_closePath() {
+    closePath: function() {
       this.ctx.closePath();
     },
-    stroke: function CanvasGraphics_stroke(consumePath) {
+    stroke: function(consumePath) {
       consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
       var ctx = this.ctx;
       var strokeColor = this.current.strokeColor;
       // Prevent drawing too thin lines by enforcing a minimum line width.
       ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR,
                                this.current.lineWidth);
       // For stroke we want to temporarily change the global alpha to the
       // stroking alpha.
@@ -4036,21 +4036,21 @@ var CanvasGraphics = (function CanvasGra
         ctx.stroke();
       }
       if (consumePath) {
         this.consumePath();
       }
       // Restore the global alpha to the fill alpha
       ctx.globalAlpha = this.current.fillAlpha;
     },
-    closeStroke: function CanvasGraphics_closeStroke() {
+    closeStroke: function() {
       this.closePath();
       this.stroke();
     },
-    fill: function CanvasGraphics_fill(consumePath) {
+    fill: function(consumePath) {
       consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
       var ctx = this.ctx;
       var fillColor = this.current.fillColor;
       var isPatternFill = this.current.patternFill;
       var needRestore = false;
 
       if (isPatternFill) {
         ctx.save();
@@ -4078,59 +4078,59 @@ var CanvasGraphics = (function CanvasGra
 
       if (needRestore) {
         ctx.restore();
       }
       if (consumePath) {
         this.consumePath();
       }
     },
-    eoFill: function CanvasGraphics_eoFill() {
+    eoFill: function() {
       this.pendingEOFill = true;
       this.fill();
     },
-    fillStroke: function CanvasGraphics_fillStroke() {
+    fillStroke: function() {
       this.fill(false);
       this.stroke(false);
 
       this.consumePath();
     },
-    eoFillStroke: function CanvasGraphics_eoFillStroke() {
+    eoFillStroke: function() {
       this.pendingEOFill = true;
       this.fillStroke();
     },
-    closeFillStroke: function CanvasGraphics_closeFillStroke() {
+    closeFillStroke: function() {
       this.closePath();
       this.fillStroke();
     },
-    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
+    closeEOFillStroke: function() {
       this.pendingEOFill = true;
       this.closePath();
       this.fillStroke();
     },
-    endPath: function CanvasGraphics_endPath() {
+    endPath: function() {
       this.consumePath();
     },
 
     // Clipping
-    clip: function CanvasGraphics_clip() {
+    clip: function() {
       this.pendingClip = NORMAL_CLIP;
     },
-    eoClip: function CanvasGraphics_eoClip() {
+    eoClip: function() {
       this.pendingClip = EO_CLIP;
     },
 
     // Text
-    beginText: function CanvasGraphics_beginText() {
+    beginText: function() {
       this.current.textMatrix = IDENTITY_MATRIX;
       this.current.textMatrixScale = 1;
       this.current.x = this.current.lineX = 0;
       this.current.y = this.current.lineY = 0;
     },
-    endText: function CanvasGraphics_endText() {
+    endText: function() {
       var paths = this.pendingTextPaths;
       var ctx = this.ctx;
       if (paths === undefined) {
         ctx.beginPath();
         return;
       }
 
       ctx.save();
@@ -4141,29 +4141,29 @@ var CanvasGraphics = (function CanvasGra
         ctx.translate(path.x, path.y);
         path.addToPath(ctx, path.fontSize);
       }
       ctx.restore();
       ctx.clip();
       ctx.beginPath();
       delete this.pendingTextPaths;
     },
-    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
+    setCharSpacing: function(spacing) {
       this.current.charSpacing = spacing;
     },
-    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
+    setWordSpacing: function(spacing) {
       this.current.wordSpacing = spacing;
     },
-    setHScale: function CanvasGraphics_setHScale(scale) {
+    setHScale: function(scale) {
       this.current.textHScale = scale / 100;
     },
-    setLeading: function CanvasGraphics_setLeading(leading) {
+    setLeading: function(leading) {
       this.current.leading = -leading;
     },
-    setFont: function CanvasGraphics_setFont(fontRefName, size) {
+    setFont: function(fontRefName, size) {
       var fontObj = this.commonObjs.get(fontRefName);
       var current = this.current;
 
       if (!fontObj) {
         error('Can\'t find font for ' + fontRefName);
       }
 
       current.fontMatrix = (fontObj.fontMatrix ?
@@ -4205,42 +4205,42 @@ var CanvasGraphics = (function CanvasGra
       // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
       var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE :
                             size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
       this.current.fontSizeScale = size / browserFontSize;
 
       var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;
       this.ctx.font = rule;
     },
-    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
+    setTextRenderingMode: function(mode) {
       this.current.textRenderingMode = mode;
     },
-    setTextRise: function CanvasGraphics_setTextRise(rise) {
+    setTextRise: function(rise) {
       this.current.textRise = rise;
     },
-    moveText: function CanvasGraphics_moveText(x, y) {
+    moveText: function(x, y) {
       this.current.x = this.current.lineX += x;
       this.current.y = this.current.lineY += y;
     },
-    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
+    setLeadingMoveText: function(x, y) {
       this.setLeading(-y);
       this.moveText(x, y);
     },
-    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
+    setTextMatrix: function(a, b, c, d, e, f) {
       this.current.textMatrix = [a, b, c, d, e, f];
       this.current.textMatrixScale = Math.sqrt(a * a + b * b);
 
       this.current.x = this.current.lineX = 0;
       this.current.y = this.current.lineY = 0;
     },
-    nextLine: function CanvasGraphics_nextLine() {
+    nextLine: function() {
       this.moveText(0, this.current.leading);
     },
 
-    paintChar: function CanvasGraphics_paintChar(character, x, y) {
+    paintChar: function(character, x, y) {
       var ctx = this.ctx;
       var current = this.current;
       var font = current.font;
       var textRenderingMode = current.textRenderingMode;
       var fontSize = current.fontSize / current.fontSizeScale;
       var fillStrokeMode = textRenderingMode &
         TextRenderingMode.FILL_STROKE_MASK;
       var isAddToPathSet = !!(textRenderingMode &
@@ -4300,17 +4300,17 @@ var CanvasGraphics = (function CanvasGra
         if (data[i] > 0 && data[i] < 255) {
           enabled = true;
           break;
         }
       }
       return shadow(this, 'isFontSubpixelAAEnabled', enabled);
     },
 
-    showText: function CanvasGraphics_showText(glyphs) {
+    showText: function(glyphs) {
       var current = this.current;
       var font = current.font;
       if (font.isType3Font) {
         return this.showType3Text(glyphs);
       }
 
       var fontSize = current.fontSize;
       if (fontSize === 0) {
@@ -4429,17 +4429,17 @@ var CanvasGraphics = (function CanvasGra
       if (vertical) {
         current.y -= x * textHScale;
       } else {
         current.x += x * textHScale;
       }
       ctx.restore();
     },
 
-    showType3Text: function CanvasGraphics_showType3Text(glyphs) {
+    showType3Text: function(glyphs) {
       // Type3 fonts - each glyph is a "mini-PDF"
       var ctx = this.ctx;
       var current = this.current;
       var font = current.font;
       var fontSize = current.fontSize;
       var fontDirection = current.fontDirection;
       var charSpacing = current.charSpacing;
       var wordSpacing = current.wordSpacing;
@@ -4493,17 +4493,17 @@ var CanvasGraphics = (function CanvasGra
         ctx.translate(width, 0);
         current.x += width * textHScale;
       }
       ctx.restore();
       this.processingType3 = null;
     },
 
     // Type3 fonts
-    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
+    setCharWidth: function(xWidth, yWidth) {
       // We can safely ignore this since the width should be the same
       // as the width in the Widths array.
     },
     setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth,
                                                                         yWidth,
                                                                         llx,
                                                                         lly,
                                                                         urx,
@@ -4511,47 +4511,47 @@ var CanvasGraphics = (function CanvasGra
       // TODO According to the spec we're also suppose to ignore any operators
       // that set color or include images while processing this type3 font.
       this.ctx.rect(llx, lly, urx - llx, ury - lly);
       this.clip();
       this.endPath();
     },
 
     // Color
-    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
+    getColorN_Pattern: function(IR) {
       var pattern;
       if (IR[0] === 'TilingPattern') {
         var color = IR[1];
         pattern = new TilingPattern(IR, color, this.ctx, this.objs,
                                     this.commonObjs, this.baseTransform);
       } else {
         pattern = getShadingPatternFromIR(IR);
       }
       return pattern;
     },
-    setStrokeColorN: function CanvasGraphics_setStrokeColorN(/*...*/) {
+    setStrokeColorN: function(/*...*/) {
       this.current.strokeColor = this.getColorN_Pattern(arguments);
     },
-    setFillColorN: function CanvasGraphics_setFillColorN(/*...*/) {
+    setFillColorN: function(/*...*/) {
       this.current.fillColor = this.getColorN_Pattern(arguments);
       this.current.patternFill = true;
     },
-    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
+    setStrokeRGBColor: function(r, g, b) {
       var color = Util.makeCssRgb(r, g, b);
       this.ctx.strokeStyle = color;
       this.current.strokeColor = color;
     },
-    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
+    setFillRGBColor: function(r, g, b) {
       var color = Util.makeCssRgb(r, g, b);
       this.ctx.fillStyle = color;
       this.current.fillColor = color;
       this.current.patternFill = false;
     },
 
-    shadingFill: function CanvasGraphics_shadingFill(patternIR) {
+    shadingFill: function(patternIR) {
       var ctx = this.ctx;
 
       this.save();
       var pattern = getShadingPatternFromIR(patternIR);
       ctx.fillStyle = pattern.getPattern(ctx, this, true);
 
       var inv = ctx.mozCurrentTransformInverse;
       if (inv) {
@@ -4579,20 +4579,20 @@ var CanvasGraphics = (function CanvasGra
 
         this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
       }
 
       this.restore();
     },
 
     // Images
-    beginInlineImage: function CanvasGraphics_beginInlineImage() {
+    beginInlineImage: function() {
       error('Should not call beginInlineImage');
     },
-    beginImageData: function CanvasGraphics_beginImageData() {
+    beginImageData: function() {
       error('Should not call beginImageData');
     },
 
     paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix,
                                                                         bbox) {
       this.save();
       this.baseTransformStack.push(this.baseTransform);
 
@@ -4606,22 +4606,22 @@ var CanvasGraphics = (function CanvasGra
         var width = bbox[2] - bbox[0];
         var height = bbox[3] - bbox[1];
         this.ctx.rect(bbox[0], bbox[1], width, height);
         this.clip();
         this.endPath();
       }
     },
 
-    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
+    paintFormXObjectEnd: function() {
       this.restore();
       this.baseTransform = this.baseTransformStack.pop();
     },
 
-    beginGroup: function CanvasGraphics_beginGroup(group) {
+    beginGroup: function(group) {
       this.save();
       var currentCtx = this.ctx;
       // TODO non-isolated groups - according to Rik at adobe non-isolated
       // group results aren't usually that different and they even have tools
       // that ignore this setting. Notes from Rik on implmenting:
       // - When you encounter an transparency group, create a new canvas with
       // the dimensions of the bbox
       // - copy the content from the previous canvas to the new canvas
@@ -4717,17 +4717,17 @@ var CanvasGraphics = (function CanvasGra
         ['BM', 'Normal'],
         ['ca', 1],
         ['CA', 1]
       ]);
       this.groupStack.push(currentCtx);
       this.groupLevel++;
     },
 
-    endGroup: function CanvasGraphics_endGroup(group) {
+    endGroup: function(group) {
       this.groupLevel--;
       var groupCtx = this.ctx;
       this.ctx = this.groupStack.pop();
       // Turn off image smoothing to avoid sub pixel interpolation which can
       // look kind of blurry for some pdfs.
       if (this.ctx.imageSmoothingEnabled !== undefined) {
         this.ctx.imageSmoothingEnabled = false;
       } else {
@@ -4736,22 +4736,22 @@ var CanvasGraphics = (function CanvasGra
       if (group.smask) {
         this.tempSMask = this.smaskStack.pop();
       } else {
         this.ctx.drawImage(groupCtx.canvas, 0, 0);
       }
       this.restore();
     },
 
-    beginAnnotations: function CanvasGraphics_beginAnnotations() {
+    beginAnnotations: function() {
       this.save();
       this.current = new CanvasExtraState();
     },
 
-    endAnnotations: function CanvasGraphics_endAnnotations() {
+    endAnnotations: function() {
       this.restore();
     },
 
     beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform,
                                                              matrix) {
       this.save();
 
       if (isArray(rect) && 4 === rect.length) {
@@ -4761,21 +4761,21 @@ var CanvasGraphics = (function CanvasGra
         this.clip();
         this.endPath();
       }
 
       this.transform.apply(this, transform);
       this.transform.apply(this, matrix);
     },
 
-    endAnnotation: function CanvasGraphics_endAnnotation() {
+    endAnnotation: function() {
       this.restore();
     },
 
-    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
+    paintJpegXObject: function(objId, w, h) {
       var domImage = this.objs.get(objId);
       if (!domImage) {
         warn('Dependent image isn\'t ready yet');
         return;
       }
 
       this.save();
 
@@ -4794,17 +4794,17 @@ var CanvasGraphics = (function CanvasGra
           top: position[1],
           width: w / currentTransform[0],
           height: h / currentTransform[3]
         });
       }
       this.restore();
     },
 
-    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
+    paintImageMaskXObject: function(img) {
       var ctx = this.ctx;
       var width = img.width, height = img.height;
       var fillColor = this.current.fillColor;
       var isPatternFill = this.current.patternFill;
 
       var glyph = this.processingType3;
 
       if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
@@ -4899,17 +4899,17 @@ var CanvasGraphics = (function CanvasGra
         ctx.transform.apply(ctx, image.transform);
         ctx.scale(1, -1);
         ctx.drawImage(maskCanvas.canvas, 0, 0, width, height,
                       0, -1, 1, 1);
         ctx.restore();
       }
     },
 
-    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
+    paintImageXObject: function(objId) {
       var imgData = this.objs.get(objId);
       if (!imgData) {
         warn('Dependent image isn\'t ready yet');
         return;
       }
 
       this.paintInlineImageXObject(imgData);
     },
@@ -5035,45 +5035,45 @@ var CanvasGraphics = (function CanvasGra
 
     paintSolidColorImageMask:
       function CanvasGraphics_paintSolidColorImageMask() {
         this.ctx.fillRect(0, 0, 1, 1);
     },
 
     // Marked content
 
-    markPoint: function CanvasGraphics_markPoint(tag) {
+    markPoint: function(tag) {
       // TODO Marked content.
     },
-    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
+    markPointProps: function(tag, properties) {
       // TODO Marked content.
     },
-    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
+    beginMarkedContent: function(tag) {
       // TODO Marked content.
     },
     beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(
                                         tag, properties) {
       // TODO Marked content.
     },
-    endMarkedContent: function CanvasGraphics_endMarkedContent() {
+    endMarkedContent: function() {
       // TODO Marked content.
     },
 
     // Compatibility
 
-    beginCompat: function CanvasGraphics_beginCompat() {
+    beginCompat: function() {
       // TODO ignore undefined operators (should we do that anyway?)
     },
-    endCompat: function CanvasGraphics_endCompat() {
+    endCompat: function() {
       // TODO stop ignoring undefined operators
     },
 
     // Helper functions
 
-    consumePath: function CanvasGraphics_consumePath() {
+    consumePath: function() {
       var ctx = this.ctx;
       if (this.pendingClip) {
         if (this.pendingClip === EO_CLIP) {
           if (ctx.mozFillRule !== undefined) {
             ctx.mozFillRule = 'evenodd';
             ctx.clip();
             ctx.mozFillRule = 'nonzero';
           } else {
@@ -5086,27 +5086,27 @@ var CanvasGraphics = (function CanvasGra
           }
         } else {
           ctx.clip();
         }
         this.pendingClip = null;
       }
       ctx.beginPath();
     },
-    getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {
+    getSinglePixelWidth: function(scale) {
       if (this.cachedGetSinglePixelWidth === null) {
         var inverse = this.ctx.mozCurrentTransformInverse;
         // max of the current horizontal and vertical scale
         this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(
           (inverse[0] * inverse[0] + inverse[1] * inverse[1]),
           (inverse[2] * inverse[2] + inverse[3] * inverse[3])));
       }
       return this.cachedGetSinglePixelWidth;
     },
-    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
+    getCanvasPosition: function(x, y) {
         var transform = this.ctx.mozCurrentTransform;
         return [
           transform[0] * x + transform[2] * y + transform[4],
           transform[1] * x + transform[3] * y + transform[5]
         ];
     }
   };
 
@@ -5535,26 +5535,26 @@ var WebGLUtils = (function WebGLUtilsClo
     clear: cleanup
   };
 })();
 
 
 var ShadingIRs = {};
 
 ShadingIRs.RadialAxial = {
-  fromIR: function RadialAxial_fromIR(raw) {
+  fromIR: function(raw) {
     var type = raw[1];
     var colorStops = raw[2];
     var p0 = raw[3];
     var p1 = raw[4];
     var r0 = raw[5];
     var r1 = raw[6];
     return {
       type: 'Pattern',
-      getPattern: function RadialAxial_getPattern(ctx) {
+      getPattern: function(ctx) {
         var grad;
         if (type === 'axial') {
           grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
         } else if (type === 'radial') {
           grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
         }
 
         for (var i = 0, ii = colorStops.length; i < ii; ++i) {
@@ -5727,28 +5727,28 @@ var createMeshCanvas = (function createM
 
     return {canvas: canvas, offsetX: offsetX, offsetY: offsetY,
             scaleX: scaleX, scaleY: scaleY};
   }
   return createMeshCanvas;
 })();
 
 ShadingIRs.Mesh = {
-  fromIR: function Mesh_fromIR(raw) {
+  fromIR: function(raw) {
     //var type = raw[1];
     var coords = raw[2];
     var colors = raw[3];
     var figures = raw[4];
     var bounds = raw[5];
     var matrix = raw[6];
     //var bbox = raw[7];
     var background = raw[8];
     return {
       type: 'Pattern',
-      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
+      getPattern: function(ctx, owner, shadingFill) {
         var scale;
         if (shadingFill) {
           scale = Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
         } else {
           // Obtain scale from matrix and current transformation matrix.
           scale = Util.singularValueDecompose2dScale(owner.baseTransform);
           if (matrix) {
             var matrixScale = Util.singularValueDecompose2dScale(matrix);
@@ -5777,20 +5777,20 @@ ShadingIRs.Mesh = {
 
         return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');
       }
     };
   }
 };
 
 ShadingIRs.Dummy = {
-  fromIR: function Dummy_fromIR() {
+  fromIR: function() {
     return {
       type: 'Pattern',
-      getPattern: function Dummy_fromIR_getPattern() {
+      getPattern: function() {
         return 'hotpink';
       }
     };
   }
 };
 
 function getShadingPatternFromIR(raw) {
   var shadingIR = ShadingIRs[raw[0]];
@@ -5820,17 +5820,17 @@ var TilingPattern = (function TilingPatt
     this.objs = objs;
     this.commonObjs = commonObjs;
     this.baseTransform = baseTransform;
     this.type = 'Pattern';
     this.ctx = ctx;
   }
 
   TilingPattern.prototype = {
-    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
+    createPatternCanvas: function(owner) {
       var operatorList = this.operatorList;
       var bbox = this.bbox;
       var xstep = this.xstep;
       var ystep = this.ystep;
       var paintType = this.paintType;
       var tilingType = this.tilingType;
       var color = this.color;
       var objs = this.objs;
@@ -5879,32 +5879,32 @@ var TilingPattern = (function TilingPatt
       graphics.transform.apply(graphics, tmpTranslate);
 
       this.clipBbox(graphics, bbox, x0, y0, x1, y1);
 
       graphics.executeOperatorList(operatorList);
       return tmpCanvas.canvas;
     },
 
-    setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
+    setScale: function(width, height, xstep, ystep) {
       this.scale = [width / xstep, height / ystep];
     },
 
-    transformToScale: function TilingPattern_transformToScale(graphics) {
+    transformToScale: function(graphics) {
       var scale = this.scale;
       var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
       graphics.transform.apply(graphics, tmpScale);
     },
 
-    scaleToContext: function TilingPattern_scaleToContext() {
+    scaleToContext: function() {
       var scale = this.scale;
       this.ctx.scale(1 / scale[0], 1 / scale[1]);
     },
 
-    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
+    clipBbox: function(graphics, bbox, x0, y0, x1, y1) {
       if (bbox && isArray(bbox) && bbox.length === 4) {
         var bboxWidth = x1 - x0;
         var bboxHeight = y1 - y0;
         graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
         graphics.clip();
         graphics.endPath();
       }
     },
@@ -5922,17 +5922,17 @@ var TilingPattern = (function TilingPatt
             context.fillStyle = cssColor;
             context.strokeStyle = cssColor;
             break;
           default:
             error('Unsupported paint type: ' + paintType);
         }
       },
 
-    getPattern: function TilingPattern_getPattern(ctx, owner) {
+    getPattern: function(ctx, owner) {
       var temporaryPatternCanvas = this.createPatternCanvas(owner);
 
       ctx = this.ctx;
       ctx.setTransform.apply(ctx, this.baseTransform);
       ctx.transform.apply(ctx, this.matrix);
       this.scaleToContext();
 
       return ctx.createPattern(temporaryPatternCanvas, 'repeat');
@@ -5941,36 +5941,36 @@ var TilingPattern = (function TilingPatt
 
   return TilingPattern;
 })();
 
 
 PDFJS.disableFontFace = false;
 
 var FontLoader = {
-  insertRule: function fontLoaderInsertRule(rule) {
+  insertRule: function(rule) {
     var styleElement = document.getElementById('PDFJS_FONT_STYLE_TAG');
     if (!styleElement) {
       styleElement = document.createElement('style');
       styleElement.id = 'PDFJS_FONT_STYLE_TAG';
       document.documentElement.getElementsByTagName('head')[0].appendChild(
         styleElement);
     }
 
     var styleSheet = styleElement.sheet;
     styleSheet.insertRule(rule, styleSheet.cssRules.length);
   },
 
-  clear: function fontLoaderClear() {
+  clear: function() {
     var styleElement = document.getElementById('PDFJS_FONT_STYLE_TAG');
     if (styleElement) {
       styleElement.parentNode.removeChild(styleElement);
     }
   },
-  bind: function fontLoaderBind(fonts, callback) {
+  bind: function(fonts, callback) {
     assert(!isWorker, 'bind() shall be called from main thread');
   
     for (var i = 0, ii = fonts.length; i < ii; i++) {
       var font = fonts[i];
       if (font.attached) {
         continue;
       }
   
@@ -5991,17 +5991,17 @@ var FontFaceObject = (function FontFaceO
       for (var i in data) {
         this[i] = data[i];
       }
       return;
     }
   }
   FontFaceObject.prototype = {
 
-    bindDOM: function FontFaceObject_bindDOM() {
+    bindDOM: function() {
       if (!this.data) {
         return null;
       }
 
       if (PDFJS.disableFontFace) {
         this.disableFontFace = true;
         return null;
       }
@@ -6018,17 +6018,17 @@ var FontFaceObject = (function FontFaceO
       if (PDFJS.pdfBug && 'FontInspector' in globalScope &&
           globalScope['FontInspector'].enabled) {
         globalScope['FontInspector'].fontAdded(this, url);
       }
 
       return rule;
     },
 
-    getPathGenerator: function FontLoader_getPathGenerator(objs, character) {
+    getPathGenerator: function(objs, character) {
       if (!(character in this.compiledGlyphs)) {
         var js = objs.get(this.loadedName + '_path_' + character);
         /*jshint -W054 */
         this.compiledGlyphs[character] = new Function('c', 'size', js);
       }
       return this.compiledGlyphs[character];
     }
   };
diff --git a/browser/extensions/pdfjs/content/build/pdf.worker.js b/browser/extensions/pdfjs/content/build/pdf.worker.js
--- a/browser/extensions/pdfjs/content/build/pdf.worker.js
+++ b/browser/extensions/pdfjs/content/build/pdf.worker.js
@@ -531,17 +531,17 @@ function isLittleEndian() {
   var buffer8 = new Uint8Array(2);
   buffer8[0] = 1;
   var buffer16 = new Uint16Array(buffer8.buffer);
   return (buffer16[0] === 1);
 }
 
 Object.defineProperty(PDFJS, 'isLittleEndian', {
   configurable: true,
-  get: function PDFJS_isLittleEndian() {
+  get: function() {
     return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
   }
 });
 
   PDFJS.hasCanvasTypedArrays = true;
 
 var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
 
@@ -839,34 +839,34 @@ var PageViewport = PDFJS.PageViewport = 
   PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
     /**
      * Clones viewport with additional properties.
      * @param args {Object} (optional) If specified, may contain the 'scale' or
      * 'rotation' properties to override the corresponding properties in
      * the cloned viewport.
      * @returns {PDFJS.PageViewport} Cloned viewport.
      */
-    clone: function PageViewPort_clone(args) {
+    clone: function(args) {
       args = args || {};
       var scale = 'scale' in args ? args.scale : this.scale;
       var rotation = 'rotation' in args ? args.rotation : this.rotation;
       return new PageViewport(this.viewBox.slice(), scale, rotation,
                               this.offsetX, this.offsetY, args.dontFlip);
     },
     /**
      * Converts PDF point to the viewport coordinates. For examples, useful for
      * converting PDF location into canvas pixel coordinates.
      * @param x {number} X coordinate.
      * @param y {number} Y coordinate.
      * @returns {Object} Object that contains 'x' and 'y' properties of the
      * point in the viewport coordinate space.
      * @see {@link convertToPdfPoint}
      * @see {@link convertToViewportRectangle}
      */
-    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
+    convertToViewportPoint: function(x, y) {
       return Util.applyTransform([x, y], this.transform);
     },
     /**
      * Converts PDF rectangle to the viewport coordinates.
      * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
      * @returns {Array} Contains corresponding coordinates of the rectangle
      * in the viewport coordinate space.
      * @see {@link convertToViewportPoint}
@@ -881,17 +881,17 @@ var PageViewport = PDFJS.PageViewport = 
      * Converts viewport coordinates to the PDF location. For examples, useful
      * for converting canvas pixel location into PDF one.
      * @param x {number} X coordinate.
      * @param y {number} Y coordinate.
      * @returns {Object} Object that contains 'x' and 'y' properties of the
      * point in the PDF coordinate space.
      * @see {@link convertToViewportPoint}
      */
-    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
+    convertToPdfPoint: function(x, y) {
       return Util.applyInverseTransform([x, y], this.transform);
     }
   };
   return PageViewport;
 })();
 
 var PDFStringTranslateTable = [
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -1081,41 +1081,41 @@ var StatTimer = (function StatTimerClosu
     return str;
   }
   function StatTimer() {
     this.started = {};
     this.times = [];
     this.enabled = true;
   }
   StatTimer.prototype = {
-    time: function StatTimer_time(name) {
+    time: function(name) {
       if (!this.enabled) {
         return;
       }
       if (name in this.started) {
         warn('Timer is already running for ' + name);
       }
       this.started[name] = Date.now();
     },
-    timeEnd: function StatTimer_timeEnd(name) {
+    timeEnd: function(name) {
       if (!this.enabled) {
         return;
       }
       if (!(name in this.started)) {
         warn('Timer has not been started for ' + name);
       }
       this.times.push({
         'name': name,
         'start': this.started[name],
         'end': Date.now()
       });
       // Remove timer from started so it can be called again.
       delete this.started[name];
     },
-    toString: function StatTimer_toString() {
+    toString: function() {
       var i, ii;
       var times = this.times;
       var out = '';
       // Find the longest name for padding purposes.
       var longest = 0;
       for (i = 0, ii = times.length; i < ii; ++i) {
         var name = times[i]['name'];
         if (name.length > longest) {
@@ -1225,30 +1225,30 @@ function MessageHandler(name, comObj) {
       }
     } else {
       error('Unknown action from worker: ' + data.action);
     }
   };
 }
 
 MessageHandler.prototype = {
-  on: function messageHandlerOn(actionName, handler, scope) {
+  on: function(actionName, handler, scope) {
     var ah = this.actionHandler;
     if (ah[actionName]) {
       error('There is already an actionName called "' + actionName + '"');
     }
     ah[actionName] = [handler, scope];
   },
   /**
    * Sends a message to the comObj to invoke the action with the supplied data.
    * @param {String} actionName Action to call.
    * @param {JSON} data JSON data to send.
    * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
    */
-  send: function messageHandlerSend(actionName, data, transfers) {
+  send: function(actionName, data, transfers) {
     var message = {
       action: actionName,
       data: data
     };
     this.postMessage(message, transfers);
   },
   /**
    * Sends a message to the comObj to invoke the action with the supplied data.
@@ -1317,35 +1317,35 @@ var ChunkedStream = (function ChunkedStr
     this.progressiveDataLength = 0;
     this.lastSuccessfulEnsureByteChunk = -1;  // a single-entry cache
   }
 
   // required methods for a stream. if a particular stream does not
   // implement these, an error should be thrown
   ChunkedStream.prototype = {
 
-    getMissingChunks: function ChunkedStream_getMissingChunks() {
+    getMissingChunks: function() {
       var chunks = [];
       for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
         if (!this.loadedChunks[chunk]) {
           chunks.push(chunk);
         }
       }
       return chunks;
     },
 
-    getBaseStreams: function ChunkedStream_getBaseStreams() {
+    getBaseStreams: function() {
       return [this];
     },
 
-    allChunksLoaded: function ChunkedStream_allChunksLoaded() {
+    allChunksLoaded: function() {
       return this.numChunksLoaded === this.numChunks;
     },
 
-    onReceiveData: function ChunkedStream_onReceiveData(begin, chunk) {
+    onReceiveData: function(begin, chunk) {
       var end = begin + chunk.byteLength;
 
       assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);
       // Using this.length is inaccurate here since this.start can be moved
       // See ChunkedStream.moveStart()
       var length = this.bytes.length;
       assert(end % this.chunkSize === 0 || end === length,
              'Bad end offset: ' + end);
@@ -1378,29 +1378,29 @@ var ChunkedStream = (function ChunkedStr
       for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
         if (!this.loadedChunks[curChunk]) {
           this.loadedChunks[curChunk] = true;
           ++this.numChunksLoaded;
         }
       }
     },
 
-    ensureByte: function ChunkedStream_ensureByte(pos) {
+    ensureByte: function(pos) {
       var chunk = Math.floor(pos / this.chunkSize);
       if (chunk === this.lastSuccessfulEnsureByteChunk) {
         return;
       }
 
       if (!this.loadedChunks[chunk]) {
         throw new MissingDataException(pos, pos + 1);
       }
       this.lastSuccessfulEnsureByteChunk = chunk;
     },
 
-    ensureRange: function ChunkedStream_ensureRange(begin, end) {
+    ensureRange: function(begin, end) {
       if (begin >= end) {
         return;
       }
 
       if (end <= this.progressiveDataLength) {
         return;
       }
 
@@ -1409,73 +1409,73 @@ var ChunkedStream = (function ChunkedStr
       var endChunk = Math.floor((end - 1) / chunkSize) + 1;
       for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
         if (!this.loadedChunks[chunk]) {
           throw new MissingDataException(begin, end);
         }
       }
     },
 
-    nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
+    nextEmptyChunk: function(beginChunk) {
       var chunk, n;
       for (chunk = beginChunk, n = this.numChunks; chunk < n; ++chunk) {
         if (!this.loadedChunks[chunk]) {
           return chunk;
         }
       }
       // Wrap around to beginning
       for (chunk = 0; chunk < beginChunk; ++chunk) {
         if (!this.loadedChunks[chunk]) {
           return chunk;
         }
       }
       return null;
     },
 
-    hasChunk: function ChunkedStream_hasChunk(chunk) {
+    hasChunk: function(chunk) {
       return !!this.loadedChunks[chunk];
     },
 
     get length() {
       return this.end - this.start;
     },
 
     get isEmpty() {
       return this.length === 0;
     },
 
-    getByte: function ChunkedStream_getByte() {
+    getByte: function() {
       var pos = this.pos;
       if (pos >= this.end) {
         return -1;
       }
       this.ensureByte(pos);
       return this.bytes[this.pos++];
     },
 
-    getUint16: function ChunkedStream_getUint16() {
+    getUint16: function() {
       var b0 = this.getByte();
       var b1 = this.getByte();
       if (b0 === -1 || b1 === -1) {
         return -1;
       }
       return (b0 << 8) + b1;
     },
 
-    getInt32: function ChunkedStream_getInt32() {
+    getInt32: function() {
       var b0 = this.getByte();
       var b1 = this.getByte();
       var b2 = this.getByte();
       var b3 = this.getByte();
       return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
     },
 
     // returns subarray of original buffer
     // should only be read
-    getBytes: function ChunkedStream_getBytes(length) {
+    getBytes: function(length) {
       var bytes = this.bytes;
       var pos = this.pos;
       var strEnd = this.end;
 
       if (!length) {
         this.ensureRange(pos, strEnd);
         return bytes.subarray(pos, strEnd);
       }
@@ -1485,49 +1485,49 @@ var ChunkedStream = (function ChunkedStr
         end = strEnd;
       }
       this.ensureRange(pos, end);
 
       this.pos = end;
       return bytes.subarray(pos, end);
     },
 
-    peekByte: function ChunkedStream_peekByte() {
+    peekByte: function() {
       var peekedByte = this.getByte();
       this.pos--;
       return peekedByte;
     },
 
-    peekBytes: function ChunkedStream_peekBytes(length) {
+    peekBytes: function(length) {
       var bytes = this.getBytes(length);
       this.pos -= bytes.length;
       return bytes;
     },
 
-    getByteRange: function ChunkedStream_getBytes(begin, end) {
+    getByteRange: function(begin, end) {
       this.ensureRange(begin, end);
       return this.bytes.subarray(begin, end);
     },
 
-    skip: function ChunkedStream_skip(n) {
+    skip: function(n) {
       if (!n) {
         n = 1;
       }
       this.pos += n;
     },
 
-    reset: function ChunkedStream_reset() {
+    reset: function() {
       this.pos = this.start;
     },
 
-    moveStart: function ChunkedStream_moveStart() {
+    moveStart: function() {
       this.start = this.pos;
     },
 
-    makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
+    makeSubStream: function(start, length, dict) {
       this.ensureRange(start, start + length);
 
       function ChunkedStreamSubstream() {}
       ChunkedStreamSubstream.prototype = Object.create(this);
       ChunkedStreamSubstream.prototype.getMissingChunks = function() {
         var chunkSize = this.chunkSize;
         var beginChunk = Math.floor(this.start / chunkSize);
         var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
@@ -1596,23 +1596,23 @@ var ChunkedStreamManager = (function Chu
     this._loadedStreamCapability = createPromiseCapability();
 
     if (args.initialData) {
       this.onReceiveData({chunk: args.initialData});
     }
   }
 
   ChunkedStreamManager.prototype = {
-    onLoadedStream: function ChunkedStreamManager_getLoadedStream() {
+    onLoadedStream: function() {
       return this._loadedStreamCapability.promise;
     },
 
     // Get all the chunks that are not yet loaded and groups them into
     // contiguous ranges to load in as few requests as possible
-    requestAllChunks: function ChunkedStreamManager_requestAllChunks() {
+    requestAllChunks: function() {
       var missingChunks = this.stream.getMissingChunks();
       this.requestChunks(missingChunks);
       return this._loadedStreamCapability.promise;
     },
 
     requestChunks: function ChunkedStreamManager_requestChunks(chunks,
                                                                callback) {
       var requestId = this.currRequestId++;
@@ -1654,17 +1654,17 @@ var ChunkedStreamManager = (function Chu
       for (i = 0; i < groupedChunksToRequest.length; ++i) {
         var groupedChunk = groupedChunksToRequest[i];
         var begin = groupedChunk.beginChunk * this.chunkSize;
         var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
         this.sendRequest(begin, end);
       }
     },
 
-    getStream: function ChunkedStreamManager_getStream() {
+    getStream: function() {
       return this.stream;
     },
 
     // Loads any chunks in the requested range that are not yet loaded
     requestRange: function ChunkedStreamManager_requestRange(
                       begin, end, callback) {
 
       end = Math.min(end, this.length);
@@ -1696,17 +1696,17 @@ var ChunkedStreamManager = (function Chu
       }
 
       chunksToRequest.sort(function(a, b) { return a - b; });
       this.requestChunks(chunksToRequest, callback);
     },
 
     // Groups a sorted array of chunks into as few continguous larger
     // chunks as possible
-    groupChunks: function ChunkedStreamManager_groupChunks(chunks) {
+    groupChunks: function(chunks) {
       var groupedChunks = [];
       var beginChunk = -1;
       var prevChunk = -1;
       for (var i = 0; i < chunks.length; ++i) {
         var chunk = chunks[i];
 
         if (beginChunk < 0) {
           beginChunk = chunk;
@@ -1722,26 +1722,26 @@ var ChunkedStreamManager = (function Chu
                                endChunk: chunk + 1 });
         }
 
         prevChunk = chunk;
       }
       return groupedChunks;
     },
 
-    onProgress: function ChunkedStreamManager_onProgress(args) {
+    onProgress: function(args) {
       var bytesLoaded = (this.stream.numChunksLoaded * this.chunkSize +
                          args.loaded);
       this.msgHandler.send('DocProgress', {
         loaded: bytesLoaded,
         total: this.length
       });
     },
 
-    onReceiveData: function ChunkedStreamManager_onReceiveData(args) {
+    onReceiveData: function(args) {
       var chunk = args.chunk;
       var isProgressive = args.begin === undefined;
       var begin = isProgressive ? this.progressiveDataLength : args.begin;
       var end = begin + chunk.byteLength;
 
       var beginChunk = Math.floor(begin / this.chunkSize);
       var endChunk = end < this.length ? Math.floor(end / this.chunkSize) :
                                          Math.ceil(end / this.chunkSize);
@@ -1809,26 +1809,26 @@ var ChunkedStreamManager = (function Chu
       }
 
       this.msgHandler.send('DocProgress', {
         loaded: this.stream.numChunksLoaded * this.chunkSize,
         total: this.length
       });
     },
 
-    onError: function ChunkedStreamManager_onError(err) {
+    onError: function(err) {
       this._loadedStreamCapability.reject(err);
     },
 
-    getBeginChunk: function ChunkedStreamManager_getBeginChunk(begin) {
+    getBeginChunk: function(begin) {
       var chunk = Math.floor(begin / this.chunkSize);
       return chunk;
     },
 
-    getEndChunk: function ChunkedStreamManager_getEndChunk(end) {
+    getEndChunk: function(end) {
       if (end % this.chunkSize === 0) {
         return end / this.chunkSize;
       }
 
       // 0 -> 0
       // 1 -> 1
       // 99 -> 1
       // 100 -> 1
@@ -1848,69 +1848,69 @@ var RANGE_CHUNK_SIZE = 65536;
 
 // TODO(mack): Make use of PDFJS.Util.inherit() when it becomes available
 var BasePdfManager = (function BasePdfManagerClosure() {
   function BasePdfManager() {
     throw new Error('Cannot initialize BaseManagerManager');
   }
 
   BasePdfManager.prototype = {
-    onLoadedStream: function BasePdfManager_onLoadedStream() {
+    onLoadedStream: function() {
       throw new NotImplementedException();
     },
 
-    ensureDoc: function BasePdfManager_ensureDoc(prop, args) {
+    ensureDoc: function(prop, args) {
       return this.ensure(this.pdfDocument, prop, args);
     },
 
-    ensureXRef: function BasePdfManager_ensureXRef(prop, args) {
+    ensureXRef: function(prop, args) {
       return this.ensure(this.pdfDocument.xref, prop, args);
     },
 
-    ensureCatalog: function BasePdfManager_ensureCatalog(prop, args) {
+    ensureCatalog: function(prop, args) {
       return this.ensure(this.pdfDocument.catalog, prop, args);
     },
 
-    getPage: function BasePdfManager_pagePage(pageIndex) {
+    getPage: function(pageIndex) {
       return this.pdfDocument.getPage(pageIndex);
     },
 
-    cleanup: function BasePdfManager_cleanup() {
+    cleanup: function() {
       return this.pdfDocument.cleanup();
     },
 
-    ensure: function BasePdfManager_ensure(obj, prop, args) {
+    ensure: function(obj, prop, args) {
       return new NotImplementedException();
     },
 
-    requestRange: function BasePdfManager_ensure(begin, end) {
+    requestRange: function(begin, end) {
       return new NotImplementedException();
     },
 
-    requestLoadedStream: function BasePdfManager_requestLoadedStream() {
+    requestLoadedStream: function() {
       return new NotImplementedException();
     },
 
-    sendProgressiveData: function BasePdfManager_sendProgressiveData(chunk) {
+    sendProgressiveData: function(chunk) {
       return new NotImplementedException();
     },
 
-    updatePassword: function BasePdfManager_updatePassword(password) {
+    updatePassword: function(password) {
       this.pdfDocument.xref.password = this.password = password;
       if (this._passwordChangedCapability) {
         this._passwordChangedCapability.resolve();
       }
     },
 
-    passwordChanged: function BasePdfManager_passwordChanged() {
+    passwordChanged: function() {
       this._passwordChangedCapability = createPromiseCapability();
       return this._passwordChangedCapability.promise;
     },
 
-    terminate: function BasePdfManager_terminate() {
+    terminate: function() {
       return new NotImplementedException();
     }
   };
 
   return BasePdfManager;
 })();
 
 var LocalPdfManager = (function LocalPdfManagerClosure() {
@@ -2062,21 +2062,21 @@ var Page = (function PageClosure() {
     this.fontCache = fontCache;
     this.idCounters = {
       obj: 0
     };
     this.resourcesPromise = null;
   }
 
   Page.prototype = {
-    getPageProp: function Page_getPageProp(key) {
+    getPageProp: function(key) {
       return this.pageDict.get(key);
     },
 
-    getInheritedPageProp: function Page_inheritPageProp(key) {
+    getInheritedPageProp: function(key) {
       var dict = this.pageDict;
       var value = dict.get(key);
       while (value === undefined) {
         dict = dict.get('Parent');
         if (!dict) {
           break;
         }
         value = dict.get(key);
@@ -2141,17 +2141,17 @@ var Page = (function PageClosure() {
       } else if (rotate < 0) {
         // The spec doesn't cover negatives, assume its counterclockwise
         // rotation. The following is the other implementation of modulo.
         rotate = ((rotate % 360) + 360) % 360;
       }
       return shadow(this, 'rotate', rotate);
     },
 
-    getContentStream: function Page_getContentStream() {
+    getContentStream: function() {
       var content = this.content;
       var stream;
       if (isArray(content)) {
         // fetching items
         var xref = this.xref;
         var i, n = content.length;
         var streams = [];
         for (i = 0; i < n; ++i) {
@@ -2162,30 +2162,30 @@ var Page = (function PageClosure() {
         stream = content;
       } else {
         // replacing non-existent page content with empty one
         stream = new NullStream();
       }
       return stream;
     },
 
-    loadResources: function Page_loadResources(keys) {
+    loadResources: function(keys) {
       if (!this.resourcesPromise) {
         // TODO: add async getInheritedPageProp and remove this.
         this.resourcesPromise = this.pdfManager.ensure(this, 'resources');
       }
       return this.resourcesPromise.then(function resourceSuccess() {
         var objectLoader = new ObjectLoader(this.resources.map,
                                             keys,
                                             this.xref);
         return objectLoader.load();
       }.bind(this));
     },
 
-    getOperatorList: function Page_getOperatorList(handler, intent) {
+    getOperatorList: function(handler, intent) {
       var self = this;
 
       var pdfManager = this.pdfManager;
       var contentStreamPromise = pdfManager.ensure(this, 'getContentStream',
                                                    []);
       var resourcesPromise = this.loadResources([
         'ExtGState',
         'ColorSpace',
@@ -2234,20 +2234,20 @@ var Page = (function PageClosure() {
           annotations, pageOpList, pdfManager, partialEvaluator, intent);
         return annotationsReadyPromise.then(function () {
           pageOpList.flush(true);
           return pageOpList;
         });
       });
     },
 
-    extractTextContent: function Page_extractTextContent() {
+    extractTextContent: function() {
       var handler = {
-        on: function nullHandlerOn() {},
-        send: function nullHandlerSend() {}
+        on: function() {},
+        send: function() {}
       };
 
       var self = this;
 
       var pdfManager = this.pdfManager;
       var contentStreamPromise = pdfManager.ensure(this, 'getContentStream',
                                                    []);
 
@@ -2267,17 +2267,17 @@ var Page = (function PageClosure() {
                                                     self.idCounters,
                                                     self.fontCache);
 
         return partialEvaluator.getTextContent(contentStream,
                                                self.resources);
       });
     },
 
-    getAnnotationsData: function Page_getAnnotationsData() {
+    getAnnotationsData: function() {
       var annotations = this.annotations;
       var annotationsData = [];
       for (var i = 0, n = annotations.length; i < n; ++i) {
         annotationsData.push(annotations[i].getData());
       }
       return annotationsData;
     },
 
@@ -2362,17 +2362,17 @@ var PDFDocument = (function PDFDocumentC
         CreationDate: isString,
         ModDate: isString,
         Trapped: isName
       });
     }
   };
 
   PDFDocument.prototype = {
-    parse: function PDFDocument_parse(recoveryMode) {
+    parse: function(recoveryMode) {
       this.setup(recoveryMode);
       try {
         // checking if AcroForm is present
         this.acroForm = this.catalog.catDict.get('AcroForm');
         if (this.acroForm) {
           this.xfa = this.acroForm.get('XFA');
           var fields = this.acroForm.get('Fields');
           if ((!fields || !isArray(fields) || fields.length === 0) &&
@@ -2450,17 +2450,17 @@ var PDFDocument = (function PDFDocumentC
       if (linearization) {
         mainXRefEntriesOffset = linearization.mainXRefEntriesOffset;
       }
       // shadow the prototype getter with a data property
       return shadow(this, 'mainXRefEntriesOffset', mainXRefEntriesOffset);
     },
     // Find the header, remove leading garbage and setup the stream
     // starting from the header.
-    checkHeader: function PDFDocument_checkHeader() {
+    checkHeader: function() {
       var stream = this.stream;
       stream.reset();
       if (find(stream, '%PDF-', 1024)) {
         // Found the header, trim off any garbage before it.
         stream.moveStart();
         // Reading file format version
         var MAX_VERSION_LENGTH = 12;
         var version = '', ch;
@@ -2471,21 +2471,21 @@ var PDFDocument = (function PDFDocumentC
           version += String.fromCharCode(ch);
         }
         // removing "%PDF-"-prefix
         this.pdfFormatVersion = version.substring(5);
         return;
       }
       // May not be a PDF file, continue anyway.
     },
-    parseStartXRef: function PDFDocument_parseStartXRef() {
+    parseStartXRef: function() {
       var startXRef = this.startXRef;
       this.xref.setStartXRef(startXRef);
     },
-    setup: function PDFDocument_setup(recoveryMode) {
+    setup: function(recoveryMode) {
       this.xref.parse(recoveryMode);
       this.catalog = new Catalog(this.pdfManager, this.xref);
     },
     get numPages() {
       var linearization = this.linearization;
       var num = linearization ? linearization.numPages : this.catalog.numPages;
       // shadow the prototype getter
       return shadow(this, 'numPages', num);
@@ -2540,21 +2540,21 @@ var PDFDocument = (function PDFDocumentC
       for (var i = 0, n = hash.length; i < n; i++) {
         var hex = hash[i].toString(16);
         fileID += hex.length === 1 ? '0' + hex : hex;
       }
 
       return shadow(this, 'fingerprint', fileID);
     },
 
-    getPage: function PDFDocument_getPage(pageIndex) {
+    getPage: function(pageIndex) {
       return this.catalog.getPage(pageIndex);
     },
 
-    cleanup: function PDFDocument_cleanup() {
+    cleanup: function() {
       return this.catalog.cleanup();
     }
   };
 
   return PDFDocument;
 })();
 
 
@@ -2621,38 +2621,38 @@ var Dict = (function DictClosure() {
     // Map should only be used internally, use functions below to access.
     this.map = Object.create(null);
     this.xref = xref;
     this.objId = null;
     this.__nonSerializable__ = nonSerializable; // disable cloning of the Dict
   }
 
   Dict.prototype = {
-    assignXref: function Dict_assignXref(newXref) {
+    assignXref: function(newXref) {
       this.xref = newXref;
     },
 
     // automatically dereferences Ref objects
-    get: function Dict_get(key1, key2, key3) {
+    get: function(key1, key2, key3) {
       var value;
       var xref = this.xref;
       if (typeof (value = this.map[key1]) !== 'undefined' || key1 in this.map ||
           typeof key2 === 'undefined') {
         return xref ? xref.fetchIfRef(value) : value;
       }
       if (typeof (value = this.map[key2]) !== 'undefined' || key2 in this.map ||
           typeof key3 === 'undefined') {
         return xref ? xref.fetchIfRef(value) : value;
       }
       value = this.map[key3] || null;
       return xref ? xref.fetchIfRef(value) : value;
     },
 
     // Same as get(), but returns a promise and uses fetchIfRefAsync().
-    getAsync: function Dict_getAsync(key1, key2, key3) {
+    getAsync: function(key1, key2, key3) {
       var value;
       var xref = this.xref;
       if (typeof (value = this.map[key1]) !== 'undefined' || key1 in this.map ||
           typeof key2 === 'undefined') {
         if (xref) {
           return xref.fetchIfRefAsync(value);
         }
         return Promise.resolve(value);
@@ -2667,22 +2667,22 @@ var Dict = (function DictClosure() {
       value = this.map[key3] || null;
       if (xref) {
         return xref.fetchIfRefAsync(value);
       }
       return Promise.resolve(value);
     },
 
     // no dereferencing
-    getRaw: function Dict_getRaw(key) {
+    getRaw: function(key) {
       return this.map[key];
     },
 
     // creates new map and dereferences all Refs
-    getAll: function Dict_getAll() {
+    getAll: function() {
       var all = Object.create(null);
       var queue = null;
       var key, obj;
       for (key in this.map) {
         obj = this.get(key);
         if (obj instanceof Dict) {
           if (isRecursionAllowedFor(obj)) {
             (queue || (queue = [])).push({target: all, key: key, obj: obj});
@@ -2723,25 +2723,25 @@ var Dict = (function DictClosure() {
         if (objId) {
           processed[objId] = dereferenced;
         }
         item.target[item.key] = dereferenced;
       }
       return all;
     },
 
-    set: function Dict_set(key, value) {
+    set: function(key, value) {
       this.map[key] = value;
     },
 
-    has: function Dict_has(key) {
+    has: function(key) {
       return key in this.map;
     },
 
-    forEach: function Dict_forEach(callback) {
+    forEach: function(callback) {
       for (var key in this.map) {
         callback(key, this.get(key));
       }
     }
   };
 
   Dict.empty = new Dict(null);
 
@@ -2750,17 +2750,17 @@ var Dict = (function DictClosure() {
 
 var Ref = (function RefClosure() {
   function Ref(num, gen) {
     this.num = num;
     this.gen = gen;
   }
 
   Ref.prototype = {
-    toString: function Ref_toString() {
+    toString: function() {
       // This function is hot, so we make the string as compact as possible.
       // |this.gen| is almost always zero, so we treat that case specially.
       var str = this.num + 'R';
       if (this.gen !== 0) {
         str += this.gen;
       }
       return str;
     }
@@ -2772,61 +2772,61 @@ var Ref = (function RefClosure() {
 // The reference is identified by number and generation.
 // This structure stores only one instance of the reference.
 var RefSet = (function RefSetClosure() {
   function RefSet() {
     this.dict = {};
   }
 
   RefSet.prototype = {
-    has: function RefSet_has(ref) {
+    has: function(ref) {
       return ref.toString() in this.dict;
     },
 
-    put: function RefSet_put(ref) {
+    put: function(ref) {
       this.dict[ref.toString()] = true;
     },
 
-    remove: function RefSet_remove(ref) {
+    remove: function(ref) {
       delete this.dict[ref.toString()];
     }
   };
 
   return RefSet;
 })();
 
 var RefSetCache = (function RefSetCacheClosure() {
   function RefSetCache() {
     this.dict = Object.create(null);
   }
 
   RefSetCache.prototype = {
-    get: function RefSetCache_get(ref) {
+    get: function(ref) {
       return this.dict[ref.toString()];
     },
 
-    has: function RefSetCache_has(ref) {
+    has: function(ref) {
       return ref.toString() in this.dict;
     },
 
-    put: function RefSetCache_put(ref, obj) {
+    put: function(ref, obj) {
       this.dict[ref.toString()] = obj;
     },
 
-    putAlias: function RefSetCache_putAlias(ref, aliasRef) {
+    putAlias: function(ref, aliasRef) {
       this.dict[ref.toString()] = this.get(aliasRef);
     },
 
-    forEach: function RefSetCache_forEach(fn, thisArg) {
+    forEach: function(fn, thisArg) {
       for (var i in this.dict) {
         fn.call(thisArg, this.dict[i]);
       }
     },
 
-    clear: function RefSetCache_clear() {
+    clear: function() {
       this.dict = Object.create(null);
     }
   };
 
   return RefSetCache;
 })();
 
 var Catalog = (function CatalogClosure() {
@@ -2887,17 +2887,17 @@ var Catalog = (function CatalogClosure()
       } catch (ex) {
         if (ex instanceof MissingDataException) {
           throw ex;
         }
         warn('Unable to read document outline');
       }
       return shadow(this, 'documentOutline', obj);
     },
-    readDocumentOutline: function Catalog_readDocumentOutline() {
+    readDocumentOutline: function() {
       var xref = this.xref;
       var obj = this.catDict.get('Outlines');
       var root = { items: [] };
       if (isDict(obj)) {
         obj = obj.getRaw('First');
         var processed = new RefSet();
         if (isRef(obj)) {
           var queue = [{obj: obj, parent: root}];
@@ -2988,17 +2988,17 @@ var Catalog = (function CatalogClosure()
           if (!names.hasOwnProperty(name)) {
             continue;
           }
           dests[name] = fetchDestination(names[name]);
         }
       }
       return shadow(this, 'destinations', dests);
     },
-    getDestination: function Catalog_getDestination(destinationId) {
+    getDestination: function(destinationId) {
       function fetchDestination(dest) {
         return isDict(dest) ? dest.get('D') : dest;
       }
 
       var xref = this.xref;
       var dest, nameTreeRef, nameDictionaryRef;
       var obj = this.catDict.get('Names');
       if (obj && obj.has('Dests')) {
@@ -3095,45 +3095,45 @@ var Catalog = (function CatalogClosure()
         if (isPrintAction) {
           javaScript.push('print(true);');
         }
       }
 
       return shadow(this, 'javaScript', javaScript);
     },
 
-    cleanup: function Catalog_cleanup() {
+    cleanup: function() {
       var promises = [];
       this.fontCache.forEach(function (promise) {
         promises.push(promise);
       });
       return Promise.all(promises).then(function (translatedFonts) {
         for (var i = 0, ii = translatedFonts.length; i < ii; i++) {
           var font = translatedFonts[i].dict;
           delete font.translated;
         }
         this.fontCache.clear();
       }.bind(this));
     },
 
-    getPage: function Catalog_getPage(pageIndex) {
+    getPage: function(pageIndex) {
       if (!(pageIndex in this.pagePromises)) {
         this.pagePromises[pageIndex] = this.getPageDict(pageIndex).then(
           function (a) {
             var dict = a[0];
             var ref = a[1];
             return new Page(this.pdfManager, this.xref, pageIndex, dict, ref,
                             this.fontCache);
           }.bind(this)
         );
       }
       return this.pagePromises[pageIndex];
     },
 
-    getPageDict: function Catalog_getPageDict(pageIndex) {
+    getPageDict: function(pageIndex) {
       var capability = createPromiseCapability();
       var nodesToVisit = [this.catDict.getRaw('Pages')];
       var currentPageIndex = 0;
       var xref = this.xref;
 
       function next() {
         while (nodesToVisit.length) {
           var currentNode = nodesToVisit.pop();
@@ -3187,17 +3187,17 @@ var Catalog = (function CatalogClosure()
           }
         }
         capability.reject('Page index ' + pageIndex + ' not found.');
       }
       next();
       return capability.promise;
     },
 
-    getPageIndex: function Catalog_getPageIndex(ref) {
+    getPageIndex: function(ref) {
       // The page tree nodes have the count of all the leaves below them. To get
       // how many pages are before we just have to walk up the tree and keep
       // adding the count of siblings to the left of the node.
       var xref = this.xref;
       function pagesBeforeRef(kidRef) {
         var total = 0;
         var parentRef;
         return xref.fetchAsync(kidRef).then(function (node) {
@@ -3272,23 +3272,23 @@ var XRef = (function XRefClosure() {
     this.password = password;
     this.stats = {
       streamTypes: [],
       fontTypes: []
     };
   }
 
   XRef.prototype = {
-    setStartXRef: function XRef_setStartXRef(startXRef) {
+    setStartXRef: function(startXRef) {
       // Store the starting positions of xref tables as we process them
       // so we can recover from missing data errors
       this.startXRefQueue = [startXRef];
     },
 
-    parse: function XRef_parse(recoveryMode) {
+    parse: function(recoveryMode) {
       var trailerDict;
       if (!recoveryMode) {
         trailerDict = this.readXRef();
       } else {
         warn('Indexing all PDF objects');
         trailerDict = this.indexObjects();
       }
       trailerDict.assignXref(this);
@@ -3302,17 +3302,17 @@ var XRef = (function XRefClosure() {
       }
 
       // get the root dictionary (catalog) object
       if (!(this.root = trailerDict.get('Root'))) {
         error('Invalid root reference');
       }
     },
 
-    processXRefTable: function XRef_processXRefTable(parser) {
+    processXRefTable: function(parser) {
       if (!('tableState' in this)) {
         // Stores state of the table as we process it so we can resume
         // from middle of table in case of missing data error
         this.tableState = {
           entryNum: 0,
           streamPos: parser.lexer.stream.pos,
           parserBuf1: parser.buf1,
           parserBuf2: parser.buf2
@@ -3343,17 +3343,17 @@ var XRef = (function XRefClosure() {
       if (!isDict(dict)) {
         error('Invalid XRef table: could not parse trailer dictionary');
       }
       delete this.tableState;
 
       return dict;
     },
 
-    readXRefTable: function XRef_readXRefTable(parser) {
+    readXRefTable: function(parser) {
       // Example of cross-reference table:
       // xref
       // 0 1                    <-- subsection header (first obj #, obj count)
       // 0000000000 65535 f     <-- actual object (offset, generation #, f/n)
       // 23 2                   <-- subsection header ... and so on ...
       // 0000025518 00002 n
       // 0000025635 00000 n
       // trailer
@@ -3427,17 +3427,17 @@ var XRef = (function XRefClosure() {
 
       // Sanity check: as per spec, first object must be free
       if (this.entries[0] && !this.entries[0].free) {
         error('Invalid XRef table: unexpected first object');
       }
       return obj;
     },
 
-    processXRefStream: function XRef_processXRefStream(stream) {
+    processXRefStream: function(stream) {
       if (!('streamState' in this)) {
         // Stores state of the stream as we process it so we can resume
         // from middle of stream in case of missing data error
         var streamParameters = stream.dict;
         var byteWidths = streamParameters.get('W');
         var range = streamParameters.get('Index');
         if (!range) {
           range = [0, streamParameters.get('Size')];
@@ -3451,17 +3451,17 @@ var XRef = (function XRefClosure() {
         };
       }
       this.readXRefStream(stream);
       delete this.streamState;
 
       return stream.dict;
     },
 
-    readXRefStream: function XRef_readXRefStream(stream) {
+    readXRefStream: function(stream) {
       var i, j;
       var streamState = this.streamState;
       stream.pos = streamState.streamPos;
 
       var byteWidths = streamState.byteWidths;
       var typeFieldWidth = byteWidths[0];
       var offsetFieldWidth = byteWidths[1];
       var generationFieldWidth = byteWidths[2];
@@ -3517,17 +3517,17 @@ var XRef = (function XRefClosure() {
         }
 
         streamState.entryNum = 0;
         streamState.streamPos = stream.pos;
         entryRanges.splice(0, 2);
       }
     },
 
-    indexObjects: function XRef_indexObjects() {
+    indexObjects: function() {
       // Simple scan through the PDF content to find objects,
       // trailers and XRef streams.
       function readToken(data, offset) {
         var token = '', ch = data[offset];
         while (ch !== 13 && ch !== 10) {
           if (++offset >= data.length) {
             break;
           }
@@ -3638,17 +3638,17 @@ var XRef = (function XRefClosure() {
       if (dict) {
         return dict;
       }
       // nothing helps
       // calling error() would reject worker with an UnknownErrorException.
       throw new InvalidPDFException('Invalid PDF structure');
     },
 
-    readXRef: function XRef_readXRef(recoveryMode) {
+    readXRef: function(recoveryMode) {
       var stream = this.stream;
 
       try {
         while (this.startXRefQueue.length) {
           var startXRef = this.startXRefQueue[0];
 
           stream.pos = startXRef + stream.start;
 
@@ -3715,32 +3715,32 @@ var XRef = (function XRefClosure() {
       }
 
       if (recoveryMode) {
         return;
       }
       throw new XRefParseException();
     },
 
-    getEntry: function XRef_getEntry(i) {
+    getEntry: function(i) {
       var xrefEntry = this.entries[i];
       if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
         return xrefEntry;
       }
       return null;
     },
 
-    fetchIfRef: function XRef_fetchIfRef(obj) {
+    fetchIfRef: function(obj) {
       if (!isRef(obj)) {
         return obj;
       }
       return this.fetch(obj);
     },
 
-    fetch: function XRef_fetch(ref, suppressEncryption) {
+    fetch: function(ref, suppressEncryption) {
       assert(isRef(ref), 'ref object is not a reference');
       var num = ref.num;
       if (num in this.cache) {
         var cacheEntry = this.cache[num];
         return cacheEntry;
       }
 
       var xrefEntry = this.getEntry(num);
@@ -3840,24 +3840,24 @@ var XRef = (function XRefClosure() {
       }
       xrefEntry = entries[xrefEntry.gen];
       if (xrefEntry === undefined) {
         error('bad XRef entry for compressed object');
       }
       return xrefEntry;
     },
 
-    fetchIfRefAsync: function XRef_fetchIfRefAsync(obj) {
+    fetchIfRefAsync: function(obj) {
       if (!isRef(obj)) {
         return Promise.resolve(obj);
       }
       return this.fetchAsync(obj);
     },
 
-    fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {
+    fetchAsync: function(ref, suppressEncryption) {
       var streamManager = this.stream.manager;
       var xref = this;
       return new Promise(function tryFetch(resolve, reject) {
         try {
           resolve(xref.fetch(ref, suppressEncryption));
         } catch (e) {
           if (e instanceof MissingDataException) {
             streamManager.requestRange(e.begin, e.end, function () {
@@ -3865,17 +3865,17 @@ var XRef = (function XRefClosure() {
             });
             return;
           }
           reject(e);
         }
       });
     },
 
-    getCatalogObj: function XRef_getCatalogObj() {
+    getCatalogObj: function() {
       return this.root;
     }
   };
 
   return XRef;
 })();
 
 /**
@@ -3885,17 +3885,17 @@ var XRef = (function XRefClosure() {
  */
 var NameTree = (function NameTreeClosure() {
   function NameTree(root, xref) {
     this.root = root;
     this.xref = xref;
   }
 
   NameTree.prototype = {
-    getAll: function NameTree_getAll() {
+    getAll: function() {
       var dict = {};
       if (!this.root) {
         return dict;
       }
       var xref = this.xref;
       // reading name tree
       var processed = new RefSet();
       processed.put(this.root);
@@ -3923,17 +3923,17 @@ var NameTree = (function NameTreeClosure
           for (i = 0, n = names.length; i < n; i += 2) {
             dict[names[i]] = xref.fetchIfRef(names[i + 1]);
           }
         }
       }
       return dict;
     },
 
-    get: function NameTree_get(destinationId) {
+    get: function(destinationId) {
       if (!this.root) {
         return null;
       }
 
       var xref = this.xref;
       var kidsOrNames = xref.fetchIfRef(this.root);
       var loopCount = 0;
       var MAX_NAMES_LEVELS = 10;
@@ -4136,17 +4136,17 @@ var ObjectLoader = (function() {
   function ObjectLoader(obj, keys, xref) {
     this.obj = obj;
     this.keys = keys;
     this.xref = xref;
     this.refSet = null;
   }
 
   ObjectLoader.prototype = {
-    load: function ObjectLoader_load() {
+    load: function() {
       var keys = this.keys;
       this.capability = createPromiseCapability();
       // Don't walk the graph if all the data is already loaded.
       if (!(this.xref.stream instanceof ChunkedStream) ||
           this.xref.stream.getMissingChunks().length === 0) {
         this.capability.resolve();
         return this.capability.promise;
       }
@@ -4157,17 +4157,17 @@ var ObjectLoader = (function() {
       for (var i = 0; i < keys.length; i++) {
         nodesToVisit.push(this.obj[keys[i]]);
       }
 
       this.walk(nodesToVisit);
       return this.capability.promise;
     },
 
-    walk: function ObjectLoader_walk(nodesToVisit) {
+    walk: function(nodesToVisit) {
       var nodesToRevisit = [];
       var pendingRequests = [];
       // DFS walk of the object graph.
       while (nodesToVisit.length) {
         var currentNode = nodesToVisit.pop();
 
         // Only references or chunked streams can cause missing data exceptions.
         if (isRef(currentNode)) {
@@ -4459,68 +4459,68 @@ var Annotation = (function AnnotationClo
 
     this.appearance = getDefaultAppearance(dict);
     data.hasAppearance = !!this.appearance;
     data.id = params.ref.num;
   }
 
   Annotation.prototype = {
 
-    getData: function Annotation_getData() {
+    getData: function() {
       return this.data;
     },
 
-    isInvisible: function Annotation_isInvisible() {
+    isInvisible: function() {
       var data = this.data;
       if (data && SUPPORTED_TYPES.indexOf(data.subtype) !== -1) {
         return false;
       } else {
         return !!(data &&
                   data.annotationFlags &&            // Default: not invisible
                   data.annotationFlags & 0x1);       // Invisible
       }
     },
 
-    isViewable: function Annotation_isViewable() {
+    isViewable: function() {
       var data = this.data;
       return !!(!this.isInvisible() &&
                 data &&
                 (!data.annotationFlags ||
                  !(data.annotationFlags & 0x22)) &&  // Hidden or NoView
                 data.rect);                          // rectangle is necessary
     },
 
-    isPrintable: function Annotation_isPrintable() {
+    isPrintable: function() {
       var data = this.data;
       return !!(!this.isInvisible() &&
                 data &&
                 data.annotationFlags &&              // Default: not printable
                 data.annotationFlags & 0x4 &&        // Print
                 !(data.annotationFlags & 0x2) &&     // Hidden
                 data.rect);                          // rectangle is necessary
     },
 
-    loadResources: function Annotation_loadResources(keys) {
+    loadResources: function(keys) {
       return new Promise(function (resolve, reject) {
         this.appearance.dict.getAsync('Resources').then(function (resources) {
           if (!resources) {
             resolve();
             return;
           }
           var objectLoader = new ObjectLoader(resources.map,
                                               keys,
                                               resources.xref);
           objectLoader.load().then(function() {
             resolve(resources);
           }, reject);
         }, reject);
       }.bind(this));
     },
 
-    getOperatorList: function Annotation_getOperatorList(evaluator) {
+    getOperatorList: function(evaluator) {
 
       if (!this.appearance) {
         return Promise.resolve(new OperatorList());
       }
 
       var data = this.data;
 
       var appearanceDict = this.appearance.dict;
@@ -4696,17 +4696,17 @@ var WidgetAnnotation = (function WidgetA
       namedItem = parent;
       ref = parentRef;
     }
     data.fullName = fieldName.join('.');
   }
 
   var parent = Annotation.prototype;
   Util.inherit(WidgetAnnotation, Annotation, {
-    isViewable: function WidgetAnnotation_isViewable() {
+    isViewable: function() {
       if (this.data.fieldType === 'Sig') {
         warn('unimplemented annotation type: Widget signature');
         return false;
       }
 
       return parent.isViewable.call(this);
     }
   });
@@ -4719,17 +4719,17 @@ var TextWidgetAnnotation = (function Tex
     WidgetAnnotation.call(this, params);
 
     this.data.textAlignment = Util.getInheritableProperty(params.dict, 'Q');
     this.data.annotationType = AnnotationType.WIDGET;
     this.data.hasHtml = !this.data.hasAppearance && !!this.data.fieldValue;
   }
 
   Util.inherit(TextWidgetAnnotation, WidgetAnnotation, {
-    getOperatorList: function TextWidgetAnnotation_getOperatorList(evaluator) {
+    getOperatorList: function(evaluator) {
       if (this.appearance) {
         return Annotation.prototype.getOperatorList.call(this, evaluator);
       }
 
       var opList = new OperatorList();
       var data = this.data;
 
       // Even if there is an appearance stream, ignore it. This is the
@@ -4892,17 +4892,17 @@ var PDFFunction = (function PDFFunctionC
         }
         codeSize -= bps;
         array[i] = (codeBuf >> codeSize) * sampleMul;
         codeBuf &= (1 << codeSize) - 1;
       }
       return array;
     },
 
-    getIR: function PDFFunction_getIR(xref, fn) {
+    getIR: function(xref, fn) {
       var dict = fn.dict;
       if (!dict) {
         dict = fn;
       }
 
       var types = [this.constructSampled,
                    null,
                    this.constructInterpolated,
@@ -4913,37 +4913,37 @@ var PDFFunction = (function PDFFunctionC
       var typeFn = types[typeNum];
       if (!typeFn) {
         error('Unknown type of function');
       }
 
       return typeFn.call(this, fn, dict, xref);
     },
 
-    fromIR: function PDFFunction_fromIR(IR) {
+    fromIR: function(IR) {
       var type = IR[0];
       switch (type) {
         case CONSTRUCT_SAMPLED:
           return this.constructSampledFromIR(IR);
         case CONSTRUCT_INTERPOLATED:
           return this.constructInterpolatedFromIR(IR);
         case CONSTRUCT_STICHED:
           return this.constructStichedFromIR(IR);
         //case CONSTRUCT_POSTSCRIPT:
         default:
           return this.constructPostScriptFromIR(IR);
       }
     },
 
-    parse: function PDFFunction_parse(xref, fn) {
+    parse: function(xref, fn) {
       var IR = this.getIR(xref, fn);
       return this.fromIR(IR);
     },
 
-    parseArray: function PDFFunction_parseArray(xref, fnObj) {
+    parseArray: function(xref, fnObj) {
       if (!isArray(fnObj)) {
         // not an array -- parsing as regular function
         return this.parse(xref, fnObj);
       }
 
       var fnArray = [];
       for (var j = 0, jj = fnObj.length; j < jj; j++) {
         var obj = xref.fetchIfRef(fnObj[j]);
@@ -4951,17 +4951,17 @@ var PDFFunction = (function PDFFunctionC
       }
       return function (src, srcOffset, dest, destOffset) {
         for (var i = 0, ii = fnArray.length; i < ii; i++) {
           fnArray[i](src, srcOffset, dest, destOffset + i);
         }
       };
     },
 
-    constructSampled: function PDFFunction_constructSampled(str, dict) {
+    constructSampled: function(str, dict) {
       function toMultiArray(arr) {
         var inputLength = arr.length;
         var out = [];
         var index = 0;
         for (var i = 0; i < inputLength; i += 2) {
           out[index] = [arr[i], arr[i + 1]];
           ++index;
         }
@@ -5009,17 +5009,17 @@ var PDFFunction = (function PDFFunctionC
       var samples = this.getSampleArray(size, outputSize, bps, str);
 
       return [
         CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size,
         outputSize, Math.pow(2, bps) - 1, range
       ];
     },
 
-    constructSampledFromIR: function PDFFunction_constructSampledFromIR(IR) {
+    constructSampledFromIR: function(IR) {
       // See chapter 3, page 109 of the PDF reference
       function interpolate(x, xmin, xmax, ymin, ymax) {
         return ymin + ((x - xmin) * ((ymax - ymin) / (xmax - xmin)));
       }
 
       return function constructSampledFromIRResult(src, srcOffset,
                                                    dest, destOffset) {
         // See chapter 3, page 110 of the PDF reference.
@@ -5131,17 +5131,17 @@ var PDFFunction = (function PDFFunctionC
         var x = n === 1 ? src[srcOffset] : Math.pow(src[srcOffset], n);
 
         for (var j = 0; j < length; ++j) {
           dest[destOffset + j] = c0[j] + (x * diff[j]);
         }
       };
     },
 
-    constructStiched: function PDFFunction_constructStiched(fn, dict, xref) {
+    constructStiched: function(fn, dict, xref) {
       var domain = dict.get('Domain');
 
       if (!domain) {
         error('No domain');
       }
 
       var inputSize = domain.length / 2;
       if (inputSize !== 1) {
@@ -5155,17 +5155,17 @@ var PDFFunction = (function PDFFunctionC
       }
 
       var bounds = dict.get('Bounds');
       var encode = dict.get('Encode');
 
       return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
     },
 
-    constructStichedFromIR: function PDFFunction_constructStichedFromIR(IR) {
+    constructStichedFromIR: function(IR) {
       var domain = IR[1];
       var bounds = IR[2];
       var encode = IR[3];
       var fnsIR = IR[4];
       var fns = [];
       var tmpBuf = new Float32Array(1);
 
       for (var i = 0, ii = fnsIR.length; i < ii; i++) {
@@ -5321,42 +5321,42 @@ function isPDFFunction(v) {
 var PostScriptStack = (function PostScriptStackClosure() {
   var MAX_STACK_SIZE = 100;
   function PostScriptStack(initialStack) {
     this.stack = !initialStack ? [] :
                  Array.prototype.slice.call(initialStack, 0);
   }
 
   PostScriptStack.prototype = {
-    push: function PostScriptStack_push(value) {
+    push: function(value) {
       if (this.stack.length >= MAX_STACK_SIZE) {
         error('PostScript function stack overflow.');
       }
       this.stack.push(value);
     },
-    pop: function PostScriptStack_pop() {
+    pop: function() {
       if (this.stack.length <= 0) {
         error('PostScript function stack underflow.');
       }
       return this.stack.pop();
     },
-    copy: function PostScriptStack_copy(n) {
+    copy: function(n) {
       if (this.stack.length + n >= MAX_STACK_SIZE) {
         error('PostScript function stack overflow.');
       }
       var stack = this.stack;
       for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
         stack.push(stack[i]);
       }
     },
-    index: function PostScriptStack_index(n) {
+    index: function(n) {
       this.push(this.stack[this.stack.length - n - 1]);
     },
     // rotate the last n stack elements p times
-    roll: function PostScriptStack_roll(n, p) {
+    roll: function(n, p) {
       var stack = this.stack;
       var l = stack.length - n;
       var r = stack.length - 1, c = l + (p - Math.floor(p / n) * n), i, j, t;
       for (i = l, j = r; i < j; i++, j--) {
         t = stack[i]; stack[i] = stack[j]; stack[j] = t;
       }
       for (i = l, j = c - 1; i < j; i++, j--) {
         t = stack[i]; stack[i] = stack[j]; stack[j] = t;
@@ -5368,17 +5368,17 @@ var PostScriptStack = (function PostScri
   };
   return PostScriptStack;
 })();
 var PostScriptEvaluator = (function PostScriptEvaluatorClosure() {
   function PostScriptEvaluator(operators) {
     this.operators = operators;
   }
   PostScriptEvaluator.prototype = {
-    execute: function PostScriptEvaluator_execute(initialStack) {
+    execute: function(initialStack) {
       var stack = new PostScriptStack(initialStack);
       var counter = 0;
       var operators = this.operators;
       var length = operators.length;
       var operator, a, b;
       while (counter < length) {
         operator = operators[counter++];
         if (typeof operator === 'number') {
@@ -5796,17 +5796,17 @@ var PostScriptCompiler = (function PostS
       // optimization: num1 max value is not greater than required max
       return num1; // just returning an argument
     }
     return new AstMin(num1, max);
   }
 
   function PostScriptCompiler() {}
   PostScriptCompiler.prototype = {
-    compile: function PostScriptCompiler_compile(code, domain, range) {
+    compile: function(code, domain, range) {
       var stack = [];
       var i, ii;
       var instructions = [];
       var inputSize = domain.length >> 1, outputSize = range.length >> 1;
       var lastRegister = 0;
       var n, j, min, max;
       var num1, num2, ast1, ast2, tmpVar, item;
       for (i = 0; i < inputSize; i++) {
@@ -5980,17 +5980,17 @@ var ColorSpace = (function ColorSpaceClo
   }
 
   ColorSpace.prototype = {
     /**
      * Converts the color value to the RGB color. The color components are
      * located in the src array starting from the srcOffset. Returns the array
      * of the rgb components, each value ranging from [0,255].
      */
-    getRgb: function ColorSpace_getRgb(src, srcOffset) {
+    getRgb: function(src, srcOffset) {
       var rgb = new Uint8Array(3);
       this.getRgbItem(src, srcOffset, rgb, 0);
       return rgb;
     },
     /**
      * Converts the color value to the RGB color, similar to the getRgb method.
      * The result placed into the dest array starting from the destOffset.
      */
@@ -6019,17 +6019,17 @@ var ColorSpace = (function ColorSpaceClo
      */
     getOutputLength: function ColorSpace_getOutputLength(inputLength,
                                                          alpha01) {
       error('Should not call ColorSpace.getOutputLength');
     },
     /**
      * Returns true if source data will be equal the result/output data.
      */
-    isPassthrough: function ColorSpace_isPassthrough(bits) {
+    isPassthrough: function(bits) {
       return false;
     },
     /**
      * Fills in the RGB colors in the destination buffer.  alpha01 indicates
      * how many alpha components there are in the dest array; it will be either
      * 0 (RGB array) or 1 (RGBA array).
      */
     fillRgb: function ColorSpace_fillRgb(dest, originalWidth,
@@ -6396,17 +6396,17 @@ var AlternateCS = (function AlternateCSC
     getOutputLength: function AlternateCS_getOutputLength(inputLength,
                                                           alpha01) {
       return this.base.getOutputLength(inputLength *
                                        this.base.numComps / this.numComps,
                                        alpha01);
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
     },
     usesZeroToOneRange: true
   };
 
   return AlternateCS;
 })();
 
@@ -6466,23 +6466,23 @@ var IndexedCS = (function IndexedCSClosu
       var lookup = this.lookup;
 
       for (var i = 0; i < count; ++i) {
         var lookupPos = src[srcOffset++] * numComps;
         base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
         destOffset += outputDelta;
       }
     },
-    getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
+    getOutputLength: function(inputLength, alpha01) {
       return this.base.getOutputLength(inputLength * this.base.numComps,
                                        alpha01);
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       // indexed color maps shouldn't be changed
       return true;
     },
     usesZeroToOneRange: true
   };
   return IndexedCS;
 })();
 
@@ -6515,17 +6515,17 @@ var DeviceGrayCS = (function DeviceGrayC
       }
     },
     getOutputLength: function DeviceGrayCS_getOutputLength(inputLength,
                                                            alpha01) {
       return inputLength * (3 + alpha01);
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
     },
     usesZeroToOneRange: true
   };
   return DeviceGrayCS;
 })();
 
 var DeviceRgbCS = (function DeviceRgbCSClosure() {
@@ -6560,21 +6560,21 @@ var DeviceRgbCS = (function DeviceRgbCSC
         dest[q++] = (scale * src[j++]) | 0;
         q += alpha01;
       }
     },
     getOutputLength: function DeviceRgbCS_getOutputLength(inputLength,
                                                           alpha01) {
       return (inputLength * (3 + alpha01) / 3) | 0;
     },
-    isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
+    isPassthrough: function(bits) {
       return bits === 8;
     },
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
     },
     usesZeroToOneRange: true
   };
   return DeviceRgbCS;
 })();
 
 var DeviceCmykCS = (function DeviceCmykCSClosure() {
@@ -6644,17 +6644,17 @@ var DeviceCmykCS = (function DeviceCmykC
       }
     },
     getOutputLength: function DeviceCmykCS_getOutputLength(inputLength,
                                                            alpha01) {
       return (inputLength / 4 * (3 + alpha01)) | 0;
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
     },
     usesZeroToOneRange: true
   };
 
   return DeviceCmykCS;
 })();
 
@@ -6736,22 +6736,22 @@ var CalGrayCS = (function CalGrayCSClosu
       var scale = 1 / ((1 << bits) - 1);
 
       for (var i = 0; i < count; ++i) {
         convertToRgb(this, src, srcOffset, dest, destOffset, scale);
         srcOffset += 1;
         destOffset += 3 + alpha01;
       }
     },
-    getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
+    getOutputLength: function(inputLength, alpha01) {
       return inputLength * (3 + alpha01);
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
     },
     usesZeroToOneRange: true
   };
   return CalGrayCS;
 })();
 
 //
@@ -7019,17 +7019,17 @@ var CalRGBCS = (function CalRGBCSClosure
 
     // Convert the values to rgb range [0, 255].
     dest[destOffset] = Math.round(sR * 255);
     dest[destOffset + 1] = Math.round(sG * 255);
     dest[destOffset + 2] = Math.round(sB * 255);
   }
 
   CalRGBCS.prototype = {
-    getRgb: function CalRGBCS_getRgb(src, srcOffset) {
+    getRgb: function(src, srcOffset) {
       var rgb = new Uint8Array(3);
       this.getRgbItem(src, srcOffset, rgb, 0);
       return rgb;
     },
     getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset,
                                              dest, destOffset) {
       convertToRgb(this, src, srcOffset, dest, destOffset, 1);
     },
@@ -7039,22 +7039,22 @@ var CalRGBCS = (function CalRGBCSClosure
       var scale = 1 / ((1 << bits) - 1);
 
       for (var i = 0; i < count; ++i) {
         convertToRgb(this, src, srcOffset, dest, destOffset, scale);
         srcOffset += 3;
         destOffset += 3 + alpha01;
       }
     },
-    getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
+    getOutputLength: function(inputLength, alpha01) {
       return (inputLength * (3 + alpha01) / 3) | 0;
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
     },
     usesZeroToOneRange: true
   };
   return CalRGBCS;
 })();
 
 //
@@ -7166,35 +7166,35 @@ var LabCS = (function LabCSClosure() {
     // clamp color values to [0,1] range then convert to [0,255] range.
     dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
     dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
     dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
   }
 
   LabCS.prototype = {
     getRgb: ColorSpace.prototype.getRgb,
-    getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
+    getRgbItem: function(src, srcOffset, dest, destOffset) {
       convertToRgb(this, src, srcOffset, false, dest, destOffset);
     },
     getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count,
                                               dest, destOffset, bits,
                                               alpha01) {
       var maxVal = (1 << bits) - 1;
       for (var i = 0; i < count; i++) {
         convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
         srcOffset += 3;
         destOffset += 3 + alpha01;
       }
     },
-    getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
+    getOutputLength: function(inputLength, alpha01) {
       return (inputLength * (3 + alpha01) / 3) | 0;
     },
     isPassthrough: ColorSpace.prototype.isPassthrough,
     fillRgb: ColorSpace.prototype.fillRgb,
-    isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
+    isDefaultDecode: function(decodeMap) {
       // XXX: Decoding is handled with the lab conversion because of the strange
       // ranges that are used.
       return true;
     },
     usesZeroToOneRange: false
   };
   return LabCS;
 })();
@@ -7214,17 +7214,17 @@ var ARCFourCipher = (function ARCFourCip
       j = (j + tmp + key[i % keyLength]) & 0xFF;
       s[i] = s[j];
       s[j] = tmp;
     }
     this.s = s;
   }
 
   ARCFourCipher.prototype = {
-    encryptBlock: function ARCFourCipher_encryptBlock(data) {
+    encryptBlock: function(data) {
       var i, n = data.length, tmp, tmp2;
       var a = this.a, b = this.b, s = this.s;
       var output = new Uint8Array(n);
       for (i = 0; i < n; ++i) {
         a = (a + 1) & 0xFF;
         tmp = s[a];
         b = (b + tmp) & 0xFF;
         tmp2 = s[b];
@@ -7327,91 +7327,91 @@ var calculateMD5 = (function calculateMD
   return hash;
 })();
 var Word64 = (function Word64Closure() {
   function Word64(highInteger, lowInteger) {
     this.high = highInteger | 0;
     this.low = lowInteger | 0;
   }
   Word64.prototype = {
-    and: function Word64_and(word) {
+    and: function(word) {
       this.high &= word.high;
       this.low &= word.low;
     },
-    xor: function Word64_xor(word) {
+    xor: function(word) {
      this.high ^= word.high;
      this.low ^= word.low;
     },
 
-    or: function Word64_or(word) {
+    or: function(word) {
       this.high |= word.high;
       this.low |= word.low;
     },
 
-    shiftRight: function Word64_shiftRight(places) {
+    shiftRight: function(places) {
       if (places >= 32) {
         this.low = (this.high >>> (places - 32)) | 0;
         this.high = 0;
       } else {
         this.low = (this.low >>> places) | (this.high << (32 - places));
         this.high = (this.high >>> places) | 0;
       }
     },
 
-    shiftLeft: function Word64_shiftLeft(places) {
+    shiftLeft: function(places) {
       if (places >= 32) {
         this.high = this.low << (places - 32);
         this.low = 0;
       } else {
         this.high = (this.high << places) | (this.low >>> (32 - places));
         this.low = this.low << places;
       }
     },
 
-    rotateRight: function Word64_rotateRight(places) {
+    rotateRight: function(places) {
       var low, high;
       if (places & 32) {
         high = this.low;
         low = this.high;
       } else {
         low = this.low;
         high = this.high;
       }
       places &= 31;
       this.low = (low >>> places) | (high << (32 - places));
       this.high = (high >>> places) | (low << (32 - places));
     },
 
-    not: function Word64_not() {
+    not: function() {
       this.high = ~this.high;
       this.low = ~this.low;
     },
 
-    add: function Word64_add(word) {
+    add: function(word) {
       var lowAdd = (this.low >>> 0) + (word.low >>> 0);
       var highAdd = (this.high >>> 0) + (word.high >>> 0);
       if (lowAdd > 0xFFFFFFFF) {
         highAdd += 1;
       }
       this.low = lowAdd | 0;
       this.high = highAdd | 0;
     },
 
-    copyTo: function Word64_copyTo(bytes, offset) {
+    copyTo: function(bytes, offset) {
       bytes[offset] = (this.high >>> 24) & 0xFF;
       bytes[offset + 1] = (this.high >> 16) & 0xFF;
       bytes[offset + 2] = (this.high >> 8) & 0xFF;
       bytes[offset + 3] = this.high & 0xFF;
       bytes[offset + 4] = (this.low >>> 24) & 0xFF;
       bytes[offset + 5] = (this.low >> 16) & 0xFF;
       bytes[offset + 6] = (this.low >> 8) & 0xFF;
       bytes[offset + 7] = this.low & 0xFF;
     },
 
-    assign: function Word64_assign(word) {
+    assign: function(word) {
       this.high = word.high;
       this.low = word.low;
     }
   };
   return Word64;
 })();
 
 var calculateSHA256 = (function calculateSHA256Closure() {
@@ -7798,17 +7798,17 @@ var calculateSHA384 = (function calculat
 
   return hash;
 })();
 var NullCipher = (function NullCipherClosure() {
   function NullCipher() {
   }
 
   NullCipher.prototype = {
-    decryptBlock: function NullCipher_decryptBlock(data) {
+    decryptBlock: function(data) {
       return data;
     }
   };
 
   return NullCipher;
 })();
 
 var AES128Cipher = (function AES128CipherClosure() {
@@ -8175,17 +8175,17 @@ var AES128Cipher = (function AES128Ciphe
     var output = new Uint8Array(outputLength);
     for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
       output.set(result[i], j);
     }
     return output;
   }
 
   AES128Cipher.prototype = {
-    decryptBlock: function AES128Cipher_decryptBlock(data, finalize) {
+    decryptBlock: function(data, finalize) {
       var i, sourceLength = data.length;
       var buffer = this.buffer, bufferLength = this.bufferPosition;
       // waiting for IV values -- they are at the start of the stream
       for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
         buffer[bufferLength] = data[i];
       }
       if (bufferLength < 16) {
         // need more data
@@ -8194,17 +8194,17 @@ var AES128Cipher = (function AES128Ciphe
       }
       this.iv = buffer;
       this.buffer = new Uint8Array(16);
       this.bufferLength = 0;
       // starting decryption
       this.decryptBlock = decryptBlock2;
       return this.decryptBlock(data.subarray(16), finalize);
     },
-    encrypt: function AES128Cipher_encrypt(data, iv) {
+    encrypt: function(data, iv) {
       var i, j, ii, sourceLength = data.length,
           buffer = this.buffer, bufferLength = this.bufferPosition,
           result = [];
       if (!iv) {
         iv = new Uint8Array(16);
       }
       for (i = 0; i < sourceLength; ++i) {
         buffer[bufferLength] = data[i];
@@ -8625,17 +8625,17 @@ var AES256Cipher = (function AES256Ciphe
     for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
       output.set(result[i], j);
     }
     return output;
 
   }
 
   AES256Cipher.prototype = {
-    decryptBlock: function AES256Cipher_decryptBlock(data, finalize, iv) {
+    decryptBlock: function(data, finalize, iv) {
       var i, sourceLength = data.length;
       var buffer = this.buffer, bufferLength = this.bufferPosition;
       // if not supplied an IV wait for IV values
       // they are at the start of the stream
       if (iv) {
         this.iv = iv;
       } else {
         for (i = 0; bufferLength < 16 &&
@@ -8651,17 +8651,17 @@ var AES256Cipher = (function AES256Ciphe
         data = data.subarray(16);
       }
       this.buffer = new Uint8Array(16);
       this.bufferLength = 0;
       // starting decryption
       this.decryptBlock = decryptBlock2;
       return this.decryptBlock(data, finalize);
     },
-    encrypt: function AES256Cipher_encrypt(data, iv) {
+    encrypt: function(data, iv) {
       var i, j, ii, sourceLength = data.length,
           buffer = this.buffer, bufferLength = this.bufferPosition,
           result = [];
       if (!iv) {
         iv = new Uint8Array(16);
       }
       for (i = 0; i < sourceLength; ++i) {
         buffer[bufferLength] = data[i];
@@ -8832,17 +8832,17 @@ var PDF20 = (function PDF20Closure() {
       if (array1[i] !== array2[i]) {
         return false;
       }
     }
     return true;
   }
 
   PDF20.prototype = {
-    hash: function PDF20_hash(password, concatBytes, userBytes) {
+    hash: function(password, concatBytes, userBytes) {
       return calculatePDF20Hash(password, concatBytes, userBytes);
     },
     checkOwnerPassword: function PDF20_checkOwnerPassword(password,
                                                           ownerValidationSalt,
                                                           userBytes,
                                                           ownerPassword) {
       var hashData = new Uint8Array(password.length + 56);
       hashData.set(password, 0);
@@ -8891,25 +8891,25 @@ var PDF20 = (function PDF20Closure() {
 
 var CipherTransform = (function CipherTransformClosure() {
   function CipherTransform(stringCipherConstructor, streamCipherConstructor) {
     this.stringCipherConstructor = stringCipherConstructor;
     this.streamCipherConstructor = streamCipherConstructor;
   }
 
   CipherTransform.prototype = {
-    createStream: function CipherTransform_createStream(stream, length) {
+    createStream: function(stream, length) {
       var cipher = new this.streamCipherConstructor();
       return new DecryptStream(stream, length,
         function cipherTransformDecryptStream(data, finalize) {
           return cipher.decryptBlock(data, finalize);
         }
       );
     },
-    decryptString: function CipherTransform_decryptString(s) {
+    decryptString: function(s) {
       var cipher = new this.stringCipherConstructor();
       var data = stringToBytes(s);
       data = cipher.decryptBlock(data, true);
       return bytesToString(data);
     }
   };
   return CipherTransform;
 })();
@@ -9237,17 +9237,17 @@ var Pattern = (function PatternClosure()
   // Constructor should define this.getPattern
   function Pattern() {
     error('should not call Pattern constructor');
   }
 
   Pattern.prototype = {
     // Input: current Canvas context
     // Output: the appropriate fillStyle or strokeStyle
-    getPattern: function Pattern_getPattern(ctx) {
+    getPattern: function(ctx) {
       error('Should not call Pattern.getStyle: ' + ctx);
     }
   };
 
   Pattern.parseShading = function Pattern_parseShading(shading, matrix, xref,
                                                        res) {
 
     var dict = isStream(shading) ? shading.dict : shading;
@@ -9379,17 +9379,17 @@ Shadings.RadialAxial = (function RadialA
       colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
       colorStops.push([1, background]);
     }
 
     this.colorStops = colorStops;
   }
 
   RadialAxial.prototype = {
-    getIR: function RadialAxial_getIR() {
+    getIR: function() {
       var coordsArr = this.coordsArr;
       var shadingType = this.shadingType;
       var type, p0, p1, r0, r1;
       if (shadingType === PatternType.AXIAL) {
         p0 = [coordsArr[0], coordsArr[1]];
         p1 = [coordsArr[2], coordsArr[3]];
         r0 = null;
         r1 = null;
@@ -9443,17 +9443,17 @@ Shadings.Mesh = (function MeshClosure() 
       var nextByte = this.stream.getByte();
       if (nextByte < 0) {
         return false;
       }
       this.buffer = nextByte;
       this.bufferLength = 8;
       return true;
     },
-    readBits: function MeshStreamReader_readBits(n) {
+    readBits: function(n) {
       var buffer = this.buffer;
       var bufferLength = this.bufferLength;
       if (n === 32) {
         if (bufferLength === 0) {
           return ((this.stream.getByte() << 24) |
             (this.stream.getByte() << 16) | (this.stream.getByte() << 8) |
             this.stream.getByte()) >>> 0;
         }
@@ -9471,36 +9471,36 @@ Shadings.Mesh = (function MeshClosure() 
         buffer = (buffer << 8) | this.stream.getByte();
         bufferLength += 8;
       }
       bufferLength -= n;
       this.bufferLength = bufferLength;
       this.buffer = buffer & ((1 << bufferLength) - 1);
       return buffer >> bufferLength;
     },
-    align: function MeshStreamReader_align() {
+    align: function() {
       this.buffer = 0;
       this.bufferLength = 0;
     },
-    readFlag: function MeshStreamReader_readFlag() {
+    readFlag: function() {
       return this.readBits(this.context.bitsPerFlag);
     },
-    readCoordinate: function MeshStreamReader_readCoordinate() {
+    readCoordinate: function() {
       var bitsPerCoordinate = this.context.bitsPerCoordinate;
       var xi = this.readBits(bitsPerCoordinate);
       var yi = this.readBits(bitsPerCoordinate);
       var decode = this.context.decode;
       var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) :
         2.3283064365386963e-10; // 2 ^ -32
       return [
         xi * scale * (decode[1] - decode[0]) + decode[0],
         yi * scale * (decode[3] - decode[2]) + decode[2]
       ];
     },
-    readComponents: function MeshStreamReader_readComponents() {
+    readComponents: function() {
       var numComps = this.context.numComps;
       var bitsPerComponent = this.context.bitsPerComponent;
       var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) :
         2.3283064365386963e-10; // 2 ^ -32
       var decode = this.context.decode;
       var components = this.tmpCompsBuf;
       for (var i = 0, j = 4; i < numComps; i++, j += 2) {
         var ci = this.readBits(bitsPerComponent);
@@ -9965,32 +9965,32 @@ Shadings.Mesh = (function MeshClosure() 
     }
     // calculate bounds
     updateBounds(this);
 
     packData(this);
   }
 
   Mesh.prototype = {
-    getIR: function Mesh_getIR() {
+    getIR: function() {
       return ['Mesh', this.shadingType, this.coords, this.colors, this.figures,
         this.bounds, this.matrix, this.bbox, this.background];
     }
   };
 
   return Mesh;
 })();
 
 Shadings.Dummy = (function DummyClosure() {
   function Dummy() {
     this.type = 'Pattern';
   }
 
   Dummy.prototype = {
-    getIR: function Dummy_getIR() {
+    getIR: function() {
       return ['Dummy'];
     }
   };
   return Dummy;
 })();
 
 function getTilingPatternIR(operatorList, dict, args) {
   var matrix = dict.get('Matrix');
@@ -10021,35 +10021,35 @@ var PartialEvaluator = (function Partial
 
   // Trying to minimize Date.now() usage and check every 100 time
   var TIME_SLOT_DURATION_MS = 20;
   var CHECK_TIME_EVERY = 100;
   function TimeSlotManager() {
     this.reset();
   }
   TimeSlotManager.prototype = {
-    check: function TimeSlotManager_check() {
+    check: function() {
       if (++this.checked < CHECK_TIME_EVERY) {
         return false;
       }
       this.checked = 0;
       return this.endTime <= Date.now();
     },
-    reset: function TimeSlotManager_reset() {
+    reset: function() {
       this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
       this.checked = 0;
     }
   };
 
   var deferred = Promise.resolve();
 
   var TILING_PATTERN = 1, SHADING_PATTERN = 2;
 
   PartialEvaluator.prototype = {
-    hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
+    hasBlendModes: function(resources) {
       if (!isDict(resources)) {
         return false;
       }
 
       var processed = Object.create(null);
       if (resources.objId) {
         processed[resources.objId] = true;
       }
@@ -10301,17 +10301,17 @@ var PartialEvaluator = (function Partial
         });
       }).then(function (translated) {
         state.font = translated.font;
         translated.send(self.handler);
         return translated.loadedName;
       });
     },
 
-    handleText: function PartialEvaluator_handleText(chars, state) {
+    handleText: function(chars, state) {
       var font = state.font;
       var glyphs = font.charsToGlyphs(chars);
       var isAddToPathSet = !!(state.textRenderingMode &
                               TextRenderingMode.ADD_TO_PATH_FLAG);
       if (font.data && (isAddToPathSet || PDFJS.disableFontFace)) {
         var buildPath = function (fontChar) {
           if (!font.renderer.hasBuiltPath(fontChar)) {
             var path = font.renderer.getPathJs(fontChar);
@@ -10548,17 +10548,17 @@ var PartialEvaluator = (function Partial
 
         fontCapability.resolve(new TranslatedFont(font.loadedName,
           new ErrorFont(reason instanceof Error ? reason.message : reason),
           font));
       });
       return fontCapability.promise;
     },
 
-    buildPath: function PartialEvaluator_buildPath(operatorList, fn, args) {
+    buildPath: function(operatorList, fn, args) {
       var lastIndex = operatorList.length - 1;
       if (!args) {
         args = [];
       }
       if (lastIndex < 0 ||
           operatorList.fnArray[lastIndex] !== OPS.constructPath) {
         operatorList.addOp(OPS.constructPath, [[fn], args]);
       } else {
@@ -11303,17 +11303,17 @@ var PartialEvaluator = (function Partial
         properties.defaultEncoding = encoding;
       }
 
       properties.differences = differences;
       properties.baseEncodingName = baseEncodingName;
       properties.dict = dict;
     },
 
-    readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
+    readToUnicode: function(toUnicode) {
       var cmap, cmapObj = toUnicode;
       if (isName(cmapObj)) {
         cmap = CMapFactory.create(cmapObj,
           { url: PDFJS.cMapUrl, packed: PDFJS.cMapPacked }, null).getMap();
         return new ToUnicodeMap(cmap);
       } else if (isStream(cmapObj)) {
         cmap = CMapFactory.create(cmapObj,
           { url: PDFJS.cMapUrl, packed: PDFJS.cMapPacked }, null).getMap();
@@ -11334,17 +11334,17 @@ var PartialEvaluator = (function Partial
           }
           cmap[i] = String.fromCharCode.apply(String, str);
         });
         return new ToUnicodeMap(cmap);
       }
       return null;
     },
 
-    readCidToGidMap: function PartialEvaluator_readCidToGidMap(cidToGidStream) {
+    readCidToGidMap: function(cidToGidStream) {
       // Extract the encoding from the CIDToGIDMap
       var glyphsData = cidToGidStream.getBytes();
 
       // Set encoding 0 to later verify the font has an encoding
       var result = [];
       for (var j = 0, jj = glyphsData.length; j < jj; j++) {
         var glyphID = (glyphsData[j++] << 8) | glyphsData[j];
         if (glyphID === 0) {
@@ -11450,24 +11450,24 @@ var PartialEvaluator = (function Partial
       }
 
       properties.defaultWidth = defaultWidth;
       properties.widths = glyphsWidths;
       properties.defaultVMetrics = defaultVMetrics;
       properties.vmetrics = glyphsVMetrics;
     },
 
-    isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
+    isSerifFont: function(baseFontName) {
       // Simulating descriptor flags attribute
       var fontNameWoStyle = baseFontName.split('-')[0];
       return (fontNameWoStyle in serifFonts) ||
               (fontNameWoStyle.search(/serif/gi) !== -1);
     },
 
-    getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
+    getBaseFontMetrics: function(name) {
       var defaultWidth = 0;
       var widths = [];
       var monospace = false;
       var lookupName = (stdFontMap[name] || name);
 
       if (!(lookupName in Metrics)) {
         // Use default fonts for looking up font metrics if the passed
         // font is not a base font
@@ -11508,17 +11508,17 @@ var PartialEvaluator = (function Partial
         if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
           widths[charCode] = widthsByGlyphName[encoding[charCode]];
           continue;
         }
       }
       return widths;
     },
 
-    preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict, xref) {
+    preEvaluateFont: function(dict, xref) {
       var baseDict = dict;
       var type = dict.get('Subtype');
       assert(isName(type), 'invalid font Subtype');
 
       var composite = false;
       var uint8array;
       if (type.name === 'Type0') {
         // If font is a composite
@@ -11924,46 +11924,46 @@ var TextState = (function TextStateClosu
     this.charSpacing = 0;
     this.wordSpacing = 0;
     this.leading = 0;
     this.textHScale = 1;
     this.textRise = 0;
   }
 
   TextState.prototype = {
-    setTextMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
+    setTextMatrix: function(a, b, c, d, e, f) {
       var m = this.textMatrix;
       m[0] = a; m[1] = b; m[2] = c; m[3] = d; m[4] = e; m[5] = f;
     },
-    setTextLineMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
+    setTextLineMatrix: function(a, b, c, d, e, f) {
       var m = this.textLineMatrix;
       m[0] = a; m[1] = b; m[2] = c; m[3] = d; m[4] = e; m[5] = f;
     },
-    translateTextMatrix: function TextState_translateTextMatrix(x, y) {
+    translateTextMatrix: function(x, y) {
       var m = this.textMatrix;
       m[4] = m[0] * x + m[2] * y + m[4];
       m[5] = m[1] * x + m[3] * y + m[5];
     },
-    translateTextLineMatrix: function TextState_translateTextMatrix(x, y) {
+    translateTextLineMatrix: function(x, y) {
       var m = this.textLineMatrix;
       m[4] = m[0] * x + m[2] * y + m[4];
       m[5] = m[1] * x + m[3] * y + m[5];
     },
-    calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
+    calcRenderMatrix: function(ctm) {
       // 9.4.4 Text Space Details
       var tsm = [this.fontSize * this.textHScale, 0,
                 0, this.fontSize,
                 0, this.textRise];
       return Util.transform(ctm, Util.transform(this.textMatrix, tsm));
     },
-    carriageReturn: function TextState_carriageReturn() {
+    carriageReturn: function() {
       this.translateTextLineMatrix(0, -this.leading);
       this.textMatrix = this.textLineMatrix.slice();
     },
-    clone: function TextState_clone() {
+    clone: function() {
       var clone = Object.create(this);
       clone.textMatrix = this.textMatrix.slice();
       clone.textLineMatrix = this.textLineMatrix.slice();
       clone.fontMatrix = this.fontMatrix.slice();
       return clone;
     }
   };
   return TextState;
@@ -11973,17 +11973,17 @@ var EvalState = (function EvalStateClosu
   function EvalState() {
     this.ctm = new Float32Array(IDENTITY_MATRIX);
     this.font = null;
     this.textRenderingMode = TextRenderingMode.FILL;
     this.fillColorSpace = ColorSpace.singletons.gray;
     this.strokeColorSpace = ColorSpace.singletons.gray;
   }
   EvalState.prototype = {
-    clone: function CanvasExtraState_clone() {
+    clone: function() {
       return Object.create(this);
     },
   };
   return EvalState;
 })();
 
 var EvaluatorPreprocessor = (function EvaluatorPreprocessorClosure() {
   // Specifies properties for each command
@@ -12128,17 +12128,17 @@ var EvaluatorPreprocessor = (function Ev
     //     allocations that would occur if we used an empty array to represent
     //     zero arguments). Otherwise, it will replace |null| with a new array
     //     containing the arguments. The caller should use this value if it
     //     cannot reuse an array for each call to read().
     //
     // These two modes are present because this function is very hot and so
     // avoiding allocations where possible is worthwhile.
     //
-    read: function EvaluatorPreprocessor_read(operation) {
+    read: function(operation) {
       var args = operation.args;
       while (true) {
         var obj = this.parser.getObj();
         if (isCmd(obj)) {
           var cmd = obj.cmd;
           // Check that the command is valid
           var opSpec = OP_MAP[cmd];
           if (!opSpec) {
@@ -12592,17 +12592,17 @@ var QueueOptimizer = (function QueueOpti
       }
 
       return iEndText + 1;
     });
 
   function QueueOptimizer() {}
 
   QueueOptimizer.prototype = {
-    optimize: function QueueOptimizer_optimize(queue) {
+    optimize: function(queue) {
       var fnArray = queue.fnArray, argsArray = queue.argsArray;
       var context = {
         iCurr: 0,
         fnArray: fnArray,
         argsArray: argsArray
       };
       var state;
       var i = 0, ii = fnArray.length;
@@ -15844,17 +15844,17 @@ var OpenTypeFileBuilder = (function Open
       rangeShift: entrySize * entriesCount - searchRange
     };
   };
 
   var OTF_HEADER_SIZE = 12;
   var OTF_TABLE_ENTRY_SIZE = 16;
 
   OpenTypeFileBuilder.prototype = {
-    toArray: function OpenTypeFileBuilder_toArray() {
+    toArray: function() {
       var sfnt = this.sfnt;
 
       // Tables needs to be written by ascendant alphabetic order
       var tables = this.tables;
       var tablesNames = Object.keys(tables);
       tablesNames.sort();
       var numTables = tablesNames.length;
 
@@ -15921,17 +15921,17 @@ var OpenTypeFileBuilder = (function Open
         // length
         writeInt32(file, offset + 12, tables[tableName].length);
 
         offset += OTF_TABLE_ENTRY_SIZE;
       }
       return file;
     },
 
-    addTable: function OpenTypeFileBuilder_addTable(tag, data) {
+    addTable: function(tag, data) {
       if (tag in this.tables) {
         throw new Error('Table ' + tag + ' already exists');
       }
       this.tables[tag] = data;
     }
   };
 
   return OpenTypeFileBuilder;
@@ -16636,27 +16636,27 @@ var Font = (function FontClosure() {
     font: null,
     mimetype: null,
     encoding: null,
     get renderer() {
       var renderer = FontRendererFactory.create(this);
       return shadow(this, 'renderer', renderer);
     },
 
-    exportData: function Font_exportData() {
+    exportData: function() {
       var data = {};
       for (var i in this) {
         if (this.hasOwnProperty(i)) {
           data[i] = this[i];
         }
       }
       return data;
     },
 
-    checkAndRepair: function Font_checkAndRepair(name, font, properties) {
+    checkAndRepair: function(name, font, properties) {
       function readTableEntry(file) {
         var tag = bytesToString(file.getBytes(4));
 
         var checksum = file.getInt32();
         var offset = file.getInt32() >>> 0;
         var length = file.getInt32() >>> 0;
 
         // Read the table associated data
@@ -17813,17 +17813,17 @@ var Font = (function FontClosure() {
 
       var builder = new OpenTypeFileBuilder(header.version);
       for (var tableTag in tables) {
         builder.addTable(tableTag, tables[tableTag].data);
       }
       return builder.toArray();
     },
 
-    convert: function Font_convert(fontName, font, properties) {
+    convert: function(fontName, font, properties) {
       // TODO: Check the charstring widths to determine this.
       properties.fixedPitch = false;
 
       var mapping = font.getGlyphMapping(properties);
       var newMapping = adjustMapping(mapping, properties);
       this.toFontChar = newMapping.toFontChar;
       var numGlyphs = font.numGlyphs;
 
@@ -17979,17 +17979,17 @@ var Font = (function FontClosure() {
       return builder.toArray();
     },
 
     /**
      * Builds a char code to unicode map based on section 9.10 of the spec.
      * @param {Object} properties Font properties object.
      * @return {Object} A ToUnicodeMap object.
      */
-    buildToUnicode: function Font_buildToUnicode(properties) {
+    buildToUnicode: function(properties) {
       // Section 9.10.2 Mapping Character Codes to Unicode Values
       if (properties.toUnicode && properties.toUnicode.length !== 0) {
         return properties.toUnicode;
       }
       // According to the spec if the font is a simple font we should only map
       // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
       // the differences array only contains adobe standard or symbol set names,
       // in pratice it seems better to always try to create a toUnicode
@@ -18142,17 +18142,17 @@ var Font = (function FontClosure() {
       }
       width = width || this.defaultWidth;
       // Do not shadow the property here. See discussion:
       // https://github.com/mozilla/pdf.js/pull/2127#discussion_r1662280
       this._shadowWidth = width;
       return width;
     },
 
-    charToGlyph: function Font_charToGlyph(charcode) {
+    charToGlyph: function(charcode) {
       var fontCharCode, width, operatorListId;
 
       var widthCode = charcode;
       if (this.cMap && this.cMap.contains(charcode)) {
         widthCode = this.cMap.lookup(charcode);
       }
       width = this.widths[widthCode];
       width = isNum(width) ? width : this.defaultWidth;
@@ -18193,17 +18193,17 @@ var Font = (function FontClosure() {
                                  operatorListId)) {
         glyph = new Glyph(fontChar, unicode, accent, width, vmetric,
                           operatorListId);
         this.glyphCache[charcode] = glyph;
       }
       return glyph;
     },
 
-    charsToGlyphs: function Font_charsToGlyphs(chars) {
+    charsToGlyphs: function(chars) {
       var charsCache = this.charsCache;
       var glyphs, glyph, charcode;
 
       // if we translated this string before, just grab it from the cache
       if (charsCache) {
         glyphs = charsCache[chars];
         if (glyphs) {
           return glyphs;
@@ -18258,20 +18258,20 @@ var Font = (function FontClosure() {
 var ErrorFont = (function ErrorFontClosure() {
   function ErrorFont(error) {
     this.error = error;
     this.loadedName = 'g_font_error';
     this.loading = false;
   }
 
   ErrorFont.prototype = {
-    charsToGlyphs: function ErrorFont_charsToGlyphs() {
+    charsToGlyphs: function() {
       return [];
     },
-    exportData: function ErrorFont_exportData() {
+    exportData: function() {
       return {error: this.error};
     }
   };
 
   return ErrorFont;
 })();
 
 /**
@@ -18396,17 +18396,17 @@ var Type1CharString = (function Type1Cha
     this.width = 0;
     this.lsb = 0;
     this.flexing = false;
     this.output = [];
     this.stack = [];
   }
 
   Type1CharString.prototype = {
-    convert: function Type1CharString_convert(encoded, subrs) {
+    convert: function(encoded, subrs) {
       var count = encoded.length;
       var error = false;
       var wx, sbx, subrNumber;
       for (var i = 0; i < count; i++) {
         var value = encoded[i];
         if (value < 32) {
           if (value === 12) {
             value = (value << 8) + encoded[++i];
@@ -18734,53 +18734,53 @@ var Type1Parser = (function Type1ParserC
       stream = new Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) :
                           decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
     }
     this.stream = stream;
     this.nextChar();
   }
 
   Type1Parser.prototype = {
-    readNumberArray: function Type1Parser_readNumberArray() {
+    readNumberArray: function() {
       this.getToken(); // read '[' or '{' (arrays can start with either)
       var array = [];
       while (true) {
         var token = this.getToken();
         if (token === null || token === ']' || token === '}') {
           break;
         }
         array.push(parseFloat(token || 0));
       }
       return array;
     },
 
-    readNumber: function Type1Parser_readNumber() {
+    readNumber: function() {
       var token = this.getToken();
       return parseFloat(token || 0);
     },
 
-    readInt: function Type1Parser_readInt() {
+    readInt: function() {
       // Use '| 0' to prevent setting a double into length such as the double
       // does not flow into the loop variable.
       var token = this.getToken();
       return parseInt(token || 0, 10) | 0;
     },
 
-    readBoolean: function Type1Parser_readBoolean() {
+    readBoolean: function() {
       var token = this.getToken();
 
       // Use 1 and 0 since that's what type2 charstrings use.
       return token === 'true' ? 1 : 0;
     },
 
-    nextChar : function Type1_nextChar() {
+    nextChar : function() {
       return (this.currentChar = this.stream.getByte());
     },
 
-    getToken: function Type1Parser_getToken() {
+    getToken: function() {
       // Eat whitespace and comments.
       var comment = false;
       var ch = this.currentChar;
       while (true) {
         if (ch === -1) {
           return null;
         }
 
@@ -18806,17 +18806,17 @@ var Type1Parser = (function Type1ParserC
       } while (ch >= 0 && !Lexer.isSpace(ch) && !isSpecial(ch));
       return token;
     },
 
     /*
      * Returns an object containing a Subrs array and a CharStrings
      * array extracted from and eexec encrypted block of data
      */
-    extractFontProgram: function Type1Parser_extractFontProgram() {
+    extractFontProgram: function() {
       var stream = this.stream;
 
       var subrs = [], charstrings = [];
       var program = {
         subrs: [],
         charstrings: [],
         properties: {
           'privateData': {
@@ -18940,17 +18940,17 @@ var Type1Parser = (function Type1ParserC
           lsb: charString.lsb,
           seac: charString.seac
         });
       }
 
       return program;
     },
 
-    extractFontHeader: function Type1Parser_extractFontHeader(properties) {
+    extractFontHeader: function(properties) {
       var token;
       while ((token = this.getToken()) !== null) {
         if (token !== '/') {
           continue;
         }
         token = this.getToken();
         switch (token) {
           case 'FontMatrix':
@@ -19121,26 +19121,26 @@ var Type1Font = function Type1Font(name,
   this.seacs = this.getSeacs(data.charstrings);
 };
 
 Type1Font.prototype = {
   get numGlyphs() {
     return this.charstrings.length + 1;
   },
 
-  getCharset: function Type1Font_getCharset() {
+  getCharset: function() {
     var charset = ['.notdef'];
     var charstrings = this.charstrings;
     for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
       charset.push(charstrings[glyphId].glyphName);
     }
     return charset;
   },
 
-  getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
+  getGlyphMapping: function(properties) {
     var charstrings = this.charstrings;
     var glyphNames = ['.notdef'], glyphId;
     for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
       glyphNames.push(charstrings[glyphId].glyphName);
     }
     var encoding = properties.builtInEncoding;
     if (encoding) {
       var builtInEncoding = {};
@@ -19150,17 +19150,17 @@ Type1Font.prototype = {
           builtInEncoding[charCode] = glyphId;
         }
       }
     }
 
     return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
   },
 
-  getSeacs: function Type1Font_getSeacs(charstrings) {
+  getSeacs: function(charstrings) {
     var i, ii;
     var seacMap = [];
     for (i = 0, ii = charstrings.length; i < ii; i++) {
       var charstring = charstrings[i];
       if (charstring.seac) {
         // Offset by 1 for .notdef
         seacMap[i + 1] = charstring.seac;
       }
@@ -19172,17 +19172,17 @@ Type1Font.prototype = {
                                   type1Charstrings) {
     var type2Charstrings = [];
     for (var i = 0, ii = type1Charstrings.length; i < ii; i++) {
       type2Charstrings.push(type1Charstrings[i].charstring);
     }
     return type2Charstrings;
   },
 
-  getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
+  getType2Subrs: function(type1Subrs) {
     var bias = 0;
     var count = type1Subrs.length;
     if (count < 1133) {
       bias = 107;
     } else if (count < 33769) {
       bias = 1131;
     } else {
       bias = 32768;
@@ -19197,17 +19197,17 @@ Type1Font.prototype = {
 
     for (i = 0; i < count; i++) {
       type2Subrs.push(type1Subrs[i]);
     }
 
     return type2Subrs;
   },
 
-  wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
+  wrap: function(name, glyphs, charstrings, subrs, properties) {
     var cff = new CFF();
     cff.header = new CFFHeader(1, 0, 4, 4);
 
     cff.names = [name];
 
     var topDict = new CFFTopDict();
     // CFF strings IDs 0...390 are predefined names, so refering
     // to entries in our own String INDEX starts at SID 391.
@@ -19320,20 +19320,20 @@ var CFFFont = (function CFFFontClosure()
       this.data = file;
     }
   }
 
   CFFFont.prototype = {
     get numGlyphs() {
       return this.cff.charStrings.count;
     },
-    getCharset: function CFFFont_getCharset() {
+    getCharset: function() {
       return this.cff.charset.charset;
     },
-    getGlyphMapping: function CFFFont_getGlyphMapping() {
+    getGlyphMapping: function() {
       var cff = this.cff;
       var properties = this.properties;
       var charsets = cff.charset.charset;
       var charCodeToGlyphId;
       var glyphId;
 
       if (properties.composite) {
         charCodeToGlyphId = Object.create(null);
@@ -19406,47 +19406,47 @@ var CFFParser = (function CFFParserClosu
     { id: 'and', min: 2, stackDelta: -1 },
     { id: 'or', min: 2, stackDelta: -1 },
     { id: 'not', min: 1, stackDelta: 0 },
     null,
     null,
     null,
     { id: 'abs', min: 1, stackDelta: 0 },
     { id: 'add', min: 2, stackDelta: -1,
-      stackFn: function stack_div(stack, index) {
+      stackFn: function(stack, index) {
         stack[index - 2] = stack[index - 2] + stack[index - 1];
       }
     },
     { id: 'sub', min: 2, stackDelta: -1,
-      stackFn: function stack_div(stack, index) {
+      stackFn: function(stack, index) {
         stack[index - 2] = stack[index - 2] - stack[index - 1];
       }
     },
     { id: 'div', min: 2, stackDelta: -1,
-      stackFn: function stack_div(stack, index) {
+      stackFn: function(stack, index) {
         stack[index - 2] = stack[index - 2] / stack[index - 1];
       }
     },
     null,
     { id: 'neg', min: 1, stackDelta: 0,
-      stackFn: function stack_div(stack, index) {
+      stackFn: function(stack, index) {
         stack[index - 1] = -stack[index - 1];
       }
     },
     { id: 'eq', min: 2, stackDelta: -1 },
     null,
     null,
     { id: 'drop', min: 1, stackDelta: -1 },
     null,
     { id: 'put', min: 2, stackDelta: -2 },
     { id: 'get', min: 1, stackDelta: 0 },
     { id: 'ifelse', min: 4, stackDelta: -3 },
     { id: 'random', min: 0, stackDelta: 1 },
     { id: 'mul', min: 2, stackDelta: -1,
-      stackFn: function stack_div(stack, index) {
+      stackFn: function(stack, index) {
         stack[index - 2] = stack[index - 2] * stack[index - 1];
       }
     },
     null,
     { id: 'sqrt', min: 1, stackDelta: 0 },
     { id: 'dup', min: 1, stackDelta: 1 },
     { id: 'exch', min: 2, stackDelta: 0 },
     { id: 'index', min: 2, stackDelta: 0 },
@@ -19460,17 +19460,17 @@ var CFFParser = (function CFFParserClosu
     { id: 'flex1', min: 11, resetStack: true }
   ];
 
   function CFFParser(file, properties) {
     this.bytes = file.getBytes();
     this.properties = properties;
   }
   CFFParser.prototype = {
-    parse: function CFFParser_parse() {
+    parse: function() {
       var properties = this.properties;
       var cff = new CFF();
       this.cff = cff;
 
       // The first five sections must be in order, all the others are reached
       // via offsets contained in one of the below.
       var header = this.parseHeader();
       var nameIndex = this.parseIndex(header.endPos);
@@ -19533,17 +19533,17 @@ var CFFParser = (function CFFParserClosu
                                       properties,
                                       cff.strings, charset.charset);
       }
       cff.charset = charset;
       cff.encoding = encoding;
 
       return cff;
     },
-    parseHeader: function CFFParser_parseHeader() {
+    parseHeader: function() {
       var bytes = this.bytes;
       var bytesLength = bytes.length;
       var offset = 0;
 
       // Prevent an infinite loop, by checking that the offset is within the
       // bounds of the bytes array. Necessary in empty, or invalid, font files.
       while (offset < bytesLength && bytes[offset] !== 1) {
         ++offset;
@@ -19557,17 +19557,17 @@ var CFFParser = (function CFFParserClosu
       }
       var major = bytes[0];
       var minor = bytes[1];
       var hdrSize = bytes[2];
       var offSize = bytes[3];
       var header = new CFFHeader(major, minor, hdrSize, offSize);
       return { obj: header, endPos: hdrSize };
     },
-    parseDict: function CFFParser_parseDict(dict) {
+    parseDict: function(dict) {
       var pos = 0;
 
       function parseOperand() {
         var value = dict[pos++];
         if (value === 30) {
           return parseFloatOperand(pos);
         } else if (value === 28) {
           value = dict[pos++];
@@ -19630,17 +19630,17 @@ var CFFParser = (function CFFParserClosu
           operands = [];
           ++pos;
         } else {
           operands.push(parseOperand());
         }
       }
       return entries;
     },
-    parseIndex: function CFFParser_parseIndex(pos) {
+    parseIndex: function(pos) {
       var cffIndex = new CFFIndex();
       var bytes = this.bytes;
       var count = (bytes[pos++] << 8) | bytes[pos++];
       var offsets = [];
       var end = pos;
       var i, ii;
 
       if (count !== 0) {
@@ -19660,17 +19660,17 @@ var CFFParser = (function CFFParserClosu
       }
       for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
         var offsetStart = offsets[i];
         var offsetEnd = offsets[i + 1];
         cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
       }
       return {obj: cffIndex, endPos: end};
     },
-    parseNameIndex: function CFFParser_parseNameIndex(index) {
+    parseNameIndex: function(index) {
       var names = [];
       for (var i = 0, ii = index.count; i < ii; ++i) {
         var name = index.get(i);
         // OTS doesn't allow names to be over 127 characters.
         var length = Math.min(name.length, 127);
         var data = [];
         // OTS also only permits certain characters in the name.
         for (var j = 0; j < length; ++j) {
@@ -19687,35 +19687,35 @@ var CFFParser = (function CFFParserClosu
             continue;
           }
           data[j] = c;
         }
         names.push(bytesToString(data));
       }
       return names;
     },
-    parseStringIndex: function CFFParser_parseStringIndex(index) {
+    parseStringIndex: function(index) {
       var strings = new CFFStrings();
       for (var i = 0, ii = index.count; i < ii; ++i) {
         var data = index.get(i);
         strings.add(bytesToString(data));
       }
       return strings;
     },
-    createDict: function CFFParser_createDict(Type, dict, strings) {
+    createDict: function(Type, dict, strings) {
       var cffDict = new Type(strings);
       for (var i = 0, ii = dict.length; i < ii; ++i) {
         var pair = dict[i];
         var key = pair[0];
         var value = pair[1];
         cffDict.setByKey(key, value);
       }
       return cffDict;
     },
-    parseCharStrings: function CFFParser_parseCharStrings(charStringOffset) {
+    parseCharStrings: function(charStringOffset) {
       var charStrings = this.parseIndex(charStringOffset).obj;
       var seacs = [];
       var widths = [];
       var count = charStrings.count;
       for (var i = 0; i < count; i++) {
         var charstring = charStrings.get(i);
 
         var stackSize = 0;
@@ -19832,17 +19832,17 @@ var CFFParser = (function CFFParserClosu
     },
     emptyPrivateDictionary:
       function CFFParser_emptyPrivateDictionary(parentDict) {
       var privateDict = this.createDict(CFFPrivateDict, [],
                                         parentDict.strings);
       parentDict.setByKey(18, [0, 0]);
       parentDict.privateDict = privateDict;
     },
-    parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
+    parsePrivateDict: function(parentDict) {
       // no private dict, do nothing
       if (!parentDict.hasName('Private')) {
         this.emptyPrivateDictionary(parentDict);
         return;
       }
       var privateOffset = parentDict.getByName('Private');
       // make sure the params are formatted correctly
       if (!isArray(privateOffset) || privateOffset.length !== 2) {
@@ -19873,17 +19873,17 @@ var CFFParser = (function CFFParserClosu
       // Validate the offset.
       if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
         this.emptyPrivateDictionary(parentDict);
         return;
       }
       var subrsIndex = this.parseIndex(relativeOffset);
       privateDict.subrsIndex = subrsIndex.obj;
     },
-    parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
+    parseCharsets: function(pos, length, strings, cid) {
       if (pos === 0) {
         return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE,
                               ISOAdobeCharset);
       } else if (pos === 1) {
         return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT,
                               ExpertCharset);
       } else if (pos === 2) {
         return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET,
@@ -20002,17 +20002,17 @@ var CFFParser = (function CFFParserClosu
           readSupplement();
           hasSupplement = true;
         }
         raw = bytes.subarray(dataStart, dataEnd);
       }
       format = format & 0x7f;
       return new CFFEncoding(predefined, format, encoding, raw);
     },
-    parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
+    parseFDSelect: function(pos, length) {
       var start = pos;
       var bytes = this.bytes;
       var format = bytes[pos++];
       var fdSelect = [];
       var i;
 
       switch (format) {
         case 0:
@@ -20077,50 +20077,50 @@ var CFFHeader = (function CFFHeaderClosu
   return CFFHeader;
 })();
 
 var CFFStrings = (function CFFStringsClosure() {
   function CFFStrings() {
     this.strings = [];
   }
   CFFStrings.prototype = {
-    get: function CFFStrings_get(index) {
+    get: function(index) {
       if (index >= 0 && index <= 390) {
         return CFFStandardStrings[index];
       }
       if (index - 391 <= this.strings.length) {
         return this.strings[index - 391];
       }
       return CFFStandardStrings[0];
     },
-    add: function CFFStrings_add(value) {
+    add: function(value) {
       this.strings.push(value);
     },
     get count() {
       return this.strings.length;
     }
   };
   return CFFStrings;
 })();
 
 var CFFIndex = (function CFFIndexClosure() {
   function CFFIndex() {
     this.objects = [];
     this.length = 0;
   }
   CFFIndex.prototype = {
-    add: function CFFIndex_add(data) {
+    add: function(data) {
       this.length += data.length;
       this.objects.push(data);
     },
-    set: function CFFIndex_set(index, data) {
+    set: function(index, data) {
       this.length += data.length - this.objects[index].length;
       this.objects[index] = data;
     },
-    get: function CFFIndex_get(index) {
+    get: function(index) {
       return this.objects[index];
     },
     get count() {
       return this.objects.length;
     }
   };
   return CFFIndex;
 })();
@@ -20133,52 +20133,52 @@ var CFFDict = (function CFFDictClosure()
     this.types = tables.types;
     this.opcodes = tables.opcodes;
     this.order = tables.order;
     this.strings = strings;
     this.values = {};
   }
   CFFDict.prototype = {
     // value should always be an array
-    setByKey: function CFFDict_setByKey(key, value) {
+    setByKey: function(key, value) {
       if (!(key in this.keyToNameMap)) {
         return false;
       }
       // ignore empty values
       if (value.length === 0) {
         return true;
       }
       var type = this.types[key];
       // remove the array wrapping these types of values
       if (type === 'num' || type === 'sid' || type === 'offset') {
         value = value[0];
       }
       this.values[key] = value;
       return true;
     },
-    setByName: function CFFDict_setByName(name, value) {
+    setByName: function(name, value) {
       if (!(name in this.nameToKeyMap)) {
         error('Invalid dictionary name "' + name + '"');
       }
       this.values[this.nameToKeyMap[name]] = value;
     },
-    hasName: function CFFDict_hasName(name) {
+    hasName: function(name) {
       return this.nameToKeyMap[name] in this.values;
     },
-    getByName: function CFFDict_getByName(name) {
+    getByName: function(name) {
       if (!(name in this.nameToKeyMap)) {
         error('Invalid dictionary name "' + name + '"');
       }
       var key = this.nameToKeyMap[name];
       if (!(key in this.values)) {
         return this.defaults[key];
       }
       return this.values[key];
     },
-    removeByName: function CFFDict_removeByName(name) {
+    removeByName: function(name) {
       delete this.values[this.nameToKeyMap[name]];
     }
   };
   CFFDict.createTables = function CFFDict_createTables(layout) {
     var tables = {
       keyToNameMap: {},
       nameToKeyMap: {},
       defaults: {},
@@ -20321,26 +20321,26 @@ var CFFFDSelect = (function CFFFDSelectC
 
 // Helper class to keep track of where an offset is within the data and helps
 // filling in that offset once it's known.
 var CFFOffsetTracker = (function CFFOffsetTrackerClosure() {
   function CFFOffsetTracker() {
     this.offsets = {};
   }
   CFFOffsetTracker.prototype = {
-    isTracking: function CFFOffsetTracker_isTracking(key) {
+    isTracking: function(key) {
       return key in this.offsets;
     },
-    track: function CFFOffsetTracker_track(key, location) {
+    track: function(key, location) {
       if (key in this.offsets) {
         error('Already tracking location of ' + key);
       }
       this.offsets[key] = location;
     },
-    offset: function CFFOffsetTracker_offset(value) {
+    offset: function(value) {
       for (var key in this.offsets) {
         this.offsets[key] += value;
       }
     },
     setEntryLocation: function CFFOffsetTracker_setEntryLocation(key,
                                                                  values,
                                                                  output) {
       if (!(key in this.offsets)) {
@@ -20373,22 +20373,22 @@ var CFFOffsetTracker = (function CFFOffs
 })();
 
 // Takes a CFF and converts it to the binary representation.
 var CFFCompiler = (function CFFCompilerClosure() {
   function CFFCompiler(cff) {
     this.cff = cff;
   }
   CFFCompiler.prototype = {
-    compile: function CFFCompiler_compile() {
+    compile: function() {
       var cff = this.cff;
       var output = {
         data: [],
         length: 0,
-        add: function CFFCompiler_add(data) {
+        add: function(data) {
           this.data = this.data.concat(data);
           this.length = this.data.length;
         }
       };
 
       // Compile the five entries that must be in order.
       var header = this.compileHeader(cff.header);
       output.add(header);
@@ -20481,24 +20481,24 @@ var CFFCompiler = (function CFFCompilerC
       this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
 
       // If the font data ends with INDEX whose object data is zero-length,
       // the sanitizer will bail out. Add a dummy byte to avoid that.
       output.add([0]);
 
       return output.data;
     },
-    encodeNumber: function CFFCompiler_encodeNumber(value) {
+    encodeNumber: function(value) {
       if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) { // isInt
         return this.encodeInteger(value);
       } else {
         return this.encodeFloat(value);
       }
     },
-    encodeFloat: function CFFCompiler_encodeFloat(num) {
+    encodeFloat: function(num) {
       var value = num.toString();
 
       // rounding inaccurate doubles
       var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
       if (m) {
         var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
         value = (Math.round(num * epsilon) / epsilon).toString();
       }
@@ -20519,17 +20519,17 @@ var CFFCompiler = (function CFFCompilerC
       }
       nibbles += (nibbles.length & 1) ? 'f' : 'ff';
       var out = [30];
       for (i = 0, ii = nibbles.length; i < ii; i += 2) {
         out.push(parseInt(nibbles.substr(i, 2), 16));
       }
       return out;
     },
-    encodeInteger: function CFFCompiler_encodeInteger(value) {
+    encodeInteger: function(value) {
       var code;
       if (value >= -107 && value <= 107) {
         code = [value + 139];
       } else if (value >= 108 && value <= 1131) {
         value = [value - 108];
         code = [(value >> 8) + 247, value & 0xFF];
       } else if (value >= -1131 && value <= -108) {
         value = -value - 108;
@@ -20540,25 +20540,25 @@ var CFFCompiler = (function CFFCompilerC
         code = [0x1d,
                 (value >> 24) & 0xFF,
                 (value >> 16) & 0xFF,
                 (value >> 8) & 0xFF,
                  value & 0xFF];
       }
       return code;
     },
-    compileHeader: function CFFCompiler_compileHeader(header) {
+    compileHeader: function(header) {
       return [
         header.major,
         header.minor,
         header.hdrSize,
         header.offSize
       ];
     },
-    compileNameIndex: function CFFCompiler_compileNameIndex(names) {
+    compileNameIndex: function(names) {
       var nameIndex = new CFFIndex();
       for (var i = 0, ii = names.length; i < ii; ++i) {
         nameIndex.add(stringToBytes(names[i]));
       }
       return this.compileIndex(nameIndex);
     },
     compileTopDicts: function CFFCompiler_compileTopDicts(dicts,
                                                           length,
@@ -20614,17 +20614,17 @@ var CFFCompiler = (function CFFCompilerC
         if (privateDict.subrsIndex && privateDict.hasName('Subrs')) {
           var subrs = this.compileIndex(privateDict.subrsIndex);
           privateDictTracker.setEntryLocation('Subrs', [privateDictData.length],
                                               output);
           output.add(subrs);
         }
       }
     },
-    compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
+    compileDict: function(dict, offsetTracker) {
       var out = [];
       // The dictionary keys must be in a certain order.
       var order = dict.order;
       for (var i = 0; i < order.length; ++i) {
         var key = order[i];
         if (!(key in dict.values)) {
           continue;
         }
@@ -20673,47 +20673,47 @@ var CFFCompiler = (function CFFCompilerC
               error('Unknown data type of ' + type);
               break;
           }
         }
         out = out.concat(dict.opcodes[key]);
       }
       return out;
     },
-    compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
+    compileStringIndex: function(strings) {
       var stringIndex = new CFFIndex();
       for (var i = 0, ii = strings.length; i < ii; ++i) {
         stringIndex.add(stringToBytes(strings[i]));
       }
       return this.compileIndex(stringIndex);
     },
-    compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
+    compileGlobalSubrIndex: function() {
       var globalSubrIndex = this.cff.globalSubrIndex;
       this.out.writeByteArray(this.compileIndex(globalSubrIndex));
     },
-    compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
+    compileCharStrings: function(charStrings) {
       return this.compileIndex(charStrings);
     },
-    compileCharset: function CFFCompiler_compileCharset(charset) {
+    compileCharset: function(charset) {
       return this.compileTypedArray(charset.raw);
     },
-    compileEncoding: function CFFCompiler_compileEncoding(encoding) {
+    compileEncoding: function(encoding) {
       return this.compileTypedArray(encoding.raw);
     },
-    compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
+    compileFDSelect: function(fdSelect) {
       return this.compileTypedArray(fdSelect);
     },
-    compileTypedArray: function CFFCompiler_compileTypedArray(data) {
+    compileTypedArray: function(data) {
       var out = [];
       for (var i = 0, ii = data.length; i < ii; ++i) {
         out[i] = data[i];
       }
       return out;
     },
-    compileIndex: function CFFCompiler_compileIndex(index, trackers) {
+    compileIndex: function(index, trackers) {
       trackers = trackers || [];
       var objects = index.objects;
       // First 2 bytes contains the number of objects contained into this index
       var count = objects.length;
 
       // If there is no object, just create an index. This technically
       // should just be [0, 0] but OTS has an issue with that.
       if (count === 0) {
@@ -21444,17 +21444,17 @@ var FontRendererFactory = (function Font
   Util.inherit(Type2Compiled, CompiledFont, {
     compileGlyphImpl: function (code, js) {
       compileCharString(code, js, this);
     }
   });
 
 
   return {
-    create: function FontRendererFactory_create(font) {
+    create: function(font) {
       var data = new Uint8Array(font.data);
       var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
       var numTables = getUshort(data, 4);
       for (var i = 0, p = 12; i < numTables; i++, p += 16) {
         var tag = bytesToString(data.subarray(p, p + 4));
         var offset = getLong(data, p + 8);
         var length = getLong(data, p + 12);
         switch (tag) {
@@ -26183,17 +26183,17 @@ var PDFImage = (function PDFImageClosure
     },
 
     get drawHeight() {
       return Math.max(this.height,
                       this.smask && this.smask.height || 0,
                       this.mask && this.mask.height || 0);
     },
 
-    decodeBuffer: function PDFImage_decodeBuffer(buffer) {
+    decodeBuffer: function(buffer) {
       var bpc = this.bpc;
       var numComps = this.numComps;
 
       var decodeAddends = this.decodeAddends;
       var decodeCoefficients = this.decodeCoefficients;
       var max = (1 << bpc) - 1;
       var i, ii;
 
@@ -26209,17 +26209,17 @@ var PDFImage = (function PDFImageClosure
         for (var j = 0; j < numComps; j++) {
           buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j],
                                          decodeCoefficients[j], max);
           index++;
         }
       }
     },
 
-    getComponents: function PDFImage_getComponents(buffer) {
+    getComponents: function(buffer) {
       var bpc = this.bpc;
 
       // This image doesn't require any extra work.
       if (bpc === 8) {
         return buffer;
       }
 
       var width = this.width;
@@ -26353,17 +26353,17 @@ var PDFImage = (function PDFImageClosure
       } else {
         // No mask.
         for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
           rgbaBuf[j] = 255;
         }
       }
     },
 
-    undoPreblend: function PDFImage_undoPreblend(buffer, width, height) {
+    undoPreblend: function(buffer, width, height) {
       var matte = this.smask && this.smask.matte;
       if (!matte) {
         return;
       }
       var matteRgb = this.colorSpace.getRgb(matte, 0);
       var matteR = matteRgb[0];
       var matteG = matteRgb[1];
       var matteB = matteRgb[2];
@@ -26384,17 +26384,17 @@ var PDFImage = (function PDFImageClosure
         g = (buffer[i + 1] - matteG) * k + matteG;
         b = (buffer[i + 2] - matteB) * k + matteB;
         buffer[i] = r <= 0 ? 0 : r >= 255 ? 255 : r | 0;
         buffer[i + 1] = g <= 0 ? 0 : g >= 255 ? 255 : g | 0;
         buffer[i + 2] = b <= 0 ? 0 : b >= 255 ? 255 : b | 0;
       }
     },
 
-    createImageData: function PDFImage_createImageData(forceRGBA) {
+    createImageData: function(forceRGBA) {
       var drawWidth = this.drawWidth;
       var drawHeight = this.drawHeight;
       var imgData = { // other fields are filled in below
         width: drawWidth,
         height: drawHeight
       };
 
       var numComps = this.numComps;
@@ -26490,17 +26490,17 @@ var PDFImage = (function PDFImageClosure
                               alpha01);
       if (maybeUndoPreblend) {
         this.undoPreblend(imgData.data, drawWidth, actualHeight);
       }
 
       return imgData;
     },
 
-    fillGrayBuffer: function PDFImage_fillGrayBuffer(buffer) {
+    fillGrayBuffer: function(buffer) {
       var numComps = this.numComps;
       if (numComps !== 1) {
         error('Reading gray scale from a color image: ' + numComps);
       }
 
       var width = this.width;
       var height = this.height;
       var bpc = this.bpc;
@@ -29511,30 +29511,30 @@ var Parser = (function ParserClosure() {
     this.lexer = lexer;
     this.allowStreams = allowStreams;
     this.xref = xref;
     this.imageCache = {};
     this.refill();
   }
 
   Parser.prototype = {
-    refill: function Parser_refill() {
+    refill: function() {
       this.buf1 = this.lexer.getObj();
       this.buf2 = this.lexer.getObj();
     },
-    shift: function Parser_shift() {
+    shift: function() {
       if (isCmd(this.buf2, 'ID')) {
         this.buf1 = this.buf2;
         this.buf2 = null;
       } else {
         this.buf1 = this.buf2;
         this.buf2 = this.lexer.getObj();
       }
     },
-    getObj: function Parser_getObj(cipherTransform) {
+    getObj: function(cipherTransform) {
       var buf1 = this.buf1;
       this.shift();
 
       if (buf1 instanceof Cmd) {
         switch (buf1.cmd) {
           case 'BI': // inline image
             return this.makeInlineImage(cipherTransform);
           case '[': // array
@@ -29781,30 +29781,30 @@ var Parser = (function ParserClosure() {
         return this.findDefaultInlineStreamEnd(stream);
       }
       this.inlineStreamSkipEI(stream);
       return length;
     },
     /**
      * Skip over the /EI/ for streams where we search for an EOD marker.
      */
-    inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
+    inlineStreamSkipEI: function(stream) {
       var E = 0x45, I = 0x49;
       var state = 0, ch;
       while ((ch = stream.getByte()) !== -1) {
         if (state === 0) {
           state = (ch === E) ? 1 : 0;
         } else if (state === 1) {
           state = (ch === I) ? 2 : 0;
         } else if (state === 2) {
           break;
         }
       }
     },
-    makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
+    makeInlineImage: function(cipherTransform) {
       var lexer = this.lexer;
       var stream = lexer.stream;
 
       // Parse dictionary.
       var dict = new Dict(null);
       while (!isCmd(this.buf1, 'ID') && !isEOF(this.buf1)) {
         if (!isName(this.buf1)) {
           error('Dictionary key must be a name object');
@@ -29874,21 +29874,21 @@ var Parser = (function ParserClosure() {
         this.imageCache[adler32] = imageStream;
       }
 
       this.buf2 = Cmd.get('EI');
       this.shift();
 
       return imageStream;
     },
-    fetchIfRef: function Parser_fetchIfRef(obj) {
+    fetchIfRef: function(obj) {
       // not relying on the xref.fetchIfRef -- xref might not be set
       return (isRef(obj) ? this.xref.fetch(obj) : obj);
     },
-    makeStream: function Parser_makeStream(dict, cipherTransform) {
+    makeStream: function(dict, cipherTransform) {
       var lexer = this.lexer;
       var stream = lexer.stream;
 
       // get stream start position
       lexer.skipToNextLine();
       var pos = stream.pos - 1;
 
       // get length
@@ -29955,17 +29955,17 @@ var Parser = (function ParserClosure() {
       stream = stream.makeSubStream(pos, length, dict);
       if (cipherTransform) {
         stream = cipherTransform.createStream(stream, length);
       }
       stream = this.filter(stream, dict, length);
       stream.dict = dict;
       return stream;
     },
-    filter: function Parser_filter(stream, dict, length) {
+    filter: function(stream, dict, length) {
       var filter = this.fetchIfRef(dict.get('Filter', 'F'));
       var params = this.fetchIfRef(dict.get('DecodeParms', 'DP'));
       if (isName(filter)) {
         return this.makeFilter(stream, filter.name, length, params);
       }
 
       var maybeLength = length;
       if (isArray(filter)) {
@@ -29983,17 +29983,17 @@ var Parser = (function ParserClosure() {
           }
           stream = this.makeFilter(stream, filter.name, maybeLength, params);
           // after the first stream the length variable is invalid
           maybeLength = null;
         }
       }
       return stream;
     },
-    makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
+    makeFilter: function(stream, name, maybeLength, params) {
       if (stream.dict.get('Length') === 0) {
         return new NullStream(stream);
       }
       try {
         if (params) {
           params = this.fetchIfRef(params);
         }
         var xrefStreamStats = this.xref.stats.streamTypes;
@@ -30116,23 +30116,23 @@ var Lexer = (function LexerClosure() {
     if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {
       // 'A'-'F', 'a'-'f'
       return (ch & 0x0F) + 9;
     }
     return -1;
   }
 
   Lexer.prototype = {
-    nextChar: function Lexer_nextChar() {
+    nextChar: function() {
       return (this.currentChar = this.stream.getByte());
     },
-    peekChar: function Lexer_peekChar() {
+    peekChar: function() {
       return this.stream.peekByte();
     },
-    getNumber: function Lexer_getNumber() {
+    getNumber: function() {
       var ch = this.currentChar;
       var eNotation = false;
       var divideBy = 0; // different from 0 if it's a floating point value
       var sign = 1;
 
       if (ch === 0x2D) { // '-'
         sign = -1;
         ch = this.nextChar();
@@ -30195,17 +30195,17 @@ var Lexer = (function LexerClosure() {
       if (divideBy !== 0) {
         baseValue /= divideBy;
       }
       if (eNotation) {
         baseValue *= Math.pow(10, powerValueSign * powerValue);
       }
       return sign * baseValue;
     },
-    getString: function Lexer_getString() {
+    getString: function() {
       var numParen = 1;
       var done = false;
       var strBuf = this.strBuf;
       strBuf.length = 0;
 
       var ch = this.nextChar();
       while (true) {
         var charBuffered = false;
@@ -30288,17 +30288,17 @@ var Lexer = (function LexerClosure() {
           break;
         }
         if (!charBuffered) {
           ch = this.nextChar();
         }
       }
       return strBuf.join('');
     },
-    getName: function Lexer_getName() {
+    getName: function() {
       var ch;
       var strBuf = this.strBuf;
       strBuf.length = 0;
       while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
         if (ch === 0x23) { // '#'
           ch = this.nextChar();
           var x = toHexDigit(ch);
           if (x !== -1) {
@@ -30315,17 +30315,17 @@ var Lexer = (function LexerClosure() {
         }
       }
       if (strBuf.length > 128) {
         error('Warning: name token is longer than allowed by the spec: ' +
               strBuf.length);
       }
       return Name.get(strBuf.join(''));
     },
-    getHexString: function Lexer_getHexString() {
+    getHexString: function() {
       var strBuf = this.strBuf;
       strBuf.length = 0;
       var ch = this.currentChar;
       var isFirstHex = true;
       var firstDigit;
       var secondDigit;
       while (true) {
         if (ch < 0) {
@@ -30355,17 +30355,17 @@ var Lexer = (function LexerClosure() {
             strBuf.push(String.fromCharCode((firstDigit << 4) | secondDigit));
           }
           isFirstHex = !isFirstHex;
           ch = this.nextChar();
         }
       }
       return strBuf.join('');
     },
-    getObj: function Lexer_getObj() {
+    getObj: function() {
       // skip whitespace and comments
       var comment = false;
       var ch = this.currentChar;
       while (true) {
         if (ch < 0) {
           return EOF;
         }
         if (comment) {
@@ -30448,17 +30448,17 @@ var Lexer = (function LexerClosure() {
       if (str === 'false') {
         return false;
       }
       if (str === 'null') {
         return null;
       }
       return Cmd.get(str);
     },
-    skipToNextLine: function Lexer_skipToNextLine() {
+    skipToNextLine: function() {
       var ch = this.currentChar;
       while (ch >= 0) {
         if (ch === 0x0D) { // CR
           ch = this.nextChar();
           if (ch === 0x0A) { // LF
             this.nextChar();
           }
           break;
@@ -30470,17 +30470,17 @@ var Lexer = (function LexerClosure() {
       }
     }
   };
 
   return Lexer;
 })();
 
 var Linearization = {
-  create: function LinearizationCreate(stream) {
+  create: function(stream) {
     function getInt(name, allowZeroValue) {
       var obj = linDict.get(name);
       if (isInt(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
         return obj;
       }
       throw new Error('The "' + name + '" parameter in the linearization ' +
                       'dictionary is invalid.');
     }
@@ -30527,55 +30527,55 @@ var Linearization = {
 var PostScriptParser = (function PostScriptParserClosure() {
   function PostScriptParser(lexer) {
     this.lexer = lexer;
     this.operators = [];
     this.token = null;
     this.prev = null;
   }
   PostScriptParser.prototype = {
-    nextToken: function PostScriptParser_nextToken() {
+    nextToken: function() {
       this.prev = this.token;
       this.token = this.lexer.getToken();
     },
-    accept: function PostScriptParser_accept(type) {
+    accept: function(type) {
       if (this.token.type === type) {
         this.nextToken();
         return true;
       }
       return false;
     },
-    expect: function PostScriptParser_expect(type) {
+    expect: function(type) {
       if (this.accept(type)) {
         return true;
       }
       error('Unexpected symbol: found ' + this.token.type + ' expected ' +
         type + '.');
     },
-    parse: function PostScriptParser_parse() {
+    parse: function() {
       this.nextToken();
       this.expect(PostScriptTokenTypes.LBRACE);
       this.parseBlock();
       this.expect(PostScriptTokenTypes.RBRACE);
       return this.operators;
     },
-    parseBlock: function PostScriptParser_parseBlock() {
+    parseBlock: function() {
       while (true) {
         if (this.accept(PostScriptTokenTypes.NUMBER)) {
           this.operators.push(this.prev.value);
         } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
           this.operators.push(this.prev.value);
         } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
           this.parseCondition();
         } else {
           return;
         }
       }
     },
-    parseCondition: function PostScriptParser_parseCondition() {
+    parseCondition: function() {
       // Add two place holders that will be updated later
       var conditionLocation = this.operators.length;
       this.operators.push(null, null);
 
       this.parseBlock();
       this.expect(PostScriptTokenTypes.RBRACE);
       if (this.accept(PostScriptTokenTypes.IF)) {
         // The true block is right after the 'if' so it just falls through on
@@ -30642,20 +30642,20 @@ var PostScriptToken = (function PostScri
 var PostScriptLexer = (function PostScriptLexerClosure() {
   function PostScriptLexer(stream) {
     this.stream = stream;
     this.nextChar();
 
     this.strBuf = [];
   }
   PostScriptLexer.prototype = {
-    nextChar: function PostScriptLexer_nextChar() {
+    nextChar: function() {
       return (this.currentChar = this.stream.getByte());
     },
-    getToken: function PostScriptLexer_getToken() {
+    getToken: function() {
       var comment = false;
       var ch = this.currentChar;
 
       // skip comments
       while (true) {
         if (ch < 0) {
           return EOF;
         }
@@ -30698,17 +30698,17 @@ var PostScriptLexer = (function PostScri
         case 'if':
           return PostScriptToken.IF;
         case 'ifelse':
           return PostScriptToken.IFELSE;
         default:
           return PostScriptToken.getOperator(str);
       }
     },
-    getNumber: function PostScriptLexer_getNumber() {
+    getNumber: function() {
       var ch = this.currentChar;
       var strBuf = this.strBuf;
       strBuf.length = 0;
       strBuf[0] = String.fromCharCode(ch);
 
       while ((ch = this.nextChar()) >= 0) {
         if ((ch >= 0x30 && ch <= 0x39) || // '0'-'9'
             ch === 0x2D || ch === 0x2E) { // '-', '.'
@@ -30742,77 +30742,77 @@ var Stream = (function StreamClosure() {
   // implement these, an error should be thrown
   Stream.prototype = {
     get length() {
       return this.end - this.start;
     },
     get isEmpty() {
       return this.length === 0;
     },
-    getByte: function Stream_getByte() {
+    getByte: function() {
       if (this.pos >= this.end) {
         return -1;
       }
       return this.bytes[this.pos++];
     },
-    getUint16: function Stream_getUint16() {
+    getUint16: function() {
       var b0 = this.getByte();
       var b1 = this.getByte();
       if (b0 === -1 || b1 === -1) {
         return -1;
       }
       return (b0 << 8) + b1;
     },
-    getInt32: function Stream_getInt32() {
+    getInt32: function() {
       var b0 = this.getByte();
       var b1 = this.getByte();
       var b2 = this.getByte();
       var b3 = this.getByte();
       return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
     },
     // returns subarray of original buffer
     // should only be read
-    getBytes: function Stream_getBytes(length) {
+    getBytes: function(length) {
       var bytes = this.bytes;
       var pos = this.pos;
       var strEnd = this.end;
 
       if (!length) {
         return bytes.subarray(pos, strEnd);
       }
       var end = pos + length;
       if (end > strEnd) {
         end = strEnd;
       }
       this.pos = end;
       return bytes.subarray(pos, end);
     },
-    peekByte: function Stream_peekByte() {
+    peekByte: function() {
       var peekedByte = this.getByte();
       this.pos--;
       return peekedByte;
     },
-    peekBytes: function Stream_peekBytes(length) {
+    peekBytes: function(length) {
       var bytes = this.getBytes(length);
       this.pos -= bytes.length;
       return bytes;
     },
-    skip: function Stream_skip(n) {
+    skip: function(n) {
       if (!n) {
         n = 1;
       }
       this.pos += n;
     },
-    reset: function Stream_reset() {
+    reset: function() {
       this.pos = this.start;
     },
-    moveStart: function Stream_moveStart() {
+    moveStart: function() {
       this.start = this.pos;
     },
-    makeSubStream: function Stream_makeSubStream(start, length, dict) {
+    makeSubStream: function(start, length, dict) {
       return new Stream(this.bytes.buffer, start, length, dict);
     },
     isStream: true
   };
 
   return Stream;
 })();
 
@@ -30855,55 +30855,55 @@ var DecodeStream = (function DecodeStrea
 
   DecodeStream.prototype = {
     get isEmpty() {
       while (!this.eof && this.bufferLength === 0) {
         this.readBlock();
       }
       return this.bufferLength === 0;
     },
-    ensureBuffer: function DecodeStream_ensureBuffer(requested) {
+    ensureBuffer: function(requested) {
       var buffer = this.buffer;
       if (requested <= buffer.byteLength) {
         return buffer;
       }
       var size = this.minBufferLength;
       while (size < requested) {
         size *= 2;
       }
       var buffer2 = new Uint8Array(size);
       buffer2.set(buffer);
       return (this.buffer = buffer2);
     },
-    getByte: function DecodeStream_getByte() {
+    getByte: function() {
       var pos = this.pos;
       while (this.bufferLength <= pos) {
         if (this.eof) {
           return -1;
         }
         this.readBlock();
       }
       return this.buffer[this.pos++];
     },
-    getUint16: function DecodeStream_getUint16() {
+    getUint16: function() {
       var b0 = this.getByte();
       var b1 = this.getByte();
       if (b0 === -1 || b1 === -1) {
         return -1;
       }
       return (b0 << 8) + b1;
     },
-    getInt32: function DecodeStream_getInt32() {
+    getInt32: function() {
       var b0 = this.getByte();
       var b1 = this.getByte();
       var b2 = this.getByte();
       var b3 = this.getByte();
       return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
     },
-    getBytes: function DecodeStream_getBytes(length) {
+    getBytes: function(length) {
       var end, pos = this.pos;
 
       if (length) {
         this.ensureBuffer(pos + length);
         end = pos + length;
 
         while (!this.eof && this.bufferLength < end) {
           this.readBlock();
@@ -30917,43 +30917,43 @@ var DecodeStream = (function DecodeStrea
           this.readBlock();
         }
         end = this.bufferLength;
       }
 
       this.pos = end;
       return this.buffer.subarray(pos, end);
     },
-    peekByte: function DecodeStream_peekByte() {
+    peekByte: function() {
       var peekedByte = this.getByte();
       this.pos--;
       return peekedByte;
     },
-    peekBytes: function DecodeStream_peekBytes(length) {
+    peekBytes: function(length) {
       var bytes = this.getBytes(length);
       this.pos -= bytes.length;
       return bytes;
     },
-    makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
+    makeSubStream: function(start, length, dict) {
       var end = start + length;
       while (this.bufferLength <= end && !this.eof) {
         this.readBlock();
       }
       return new Stream(this.buffer, start, length, dict);
     },
-    skip: function DecodeStream_skip(n) {
+    skip: function(n) {
       if (!n) {
         n = 1;
       }
       this.pos += n;
     },
-    reset: function DecodeStream_reset() {
+    reset: function() {
       this.pos = 0;
     },
-    getBaseStreams: function DecodeStream_getBaseStreams() {
+    getBaseStreams: function() {
       if (this.str && this.str.getBaseStreams) {
         return this.str.getBaseStreams();
       }
       return [];
     }
   };
 
   return DecodeStream;
@@ -31586,17 +31586,17 @@ var JpegStream = (function JpegStreamClo
     this.dict = dict;
 
     DecodeStream.call(this, maybeLength);
   }
 
   JpegStream.prototype = Object.create(DecodeStream.prototype);
 
   Object.defineProperty(JpegStream.prototype, 'bytes', {
-    get: function JpegStream_bytes() {
+    get: function() {
       // If this.maybeLength is null, we'll get the entire stream.
       return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
     },
     configurable: true
   });
 
   JpegStream.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
     if (this.bufferLength) {
@@ -31677,17 +31677,17 @@ var JpxStream = (function JpxStreamClosu
     this.dict = dict;
 
     DecodeStream.call(this, maybeLength);
   }
 
   JpxStream.prototype = Object.create(DecodeStream.prototype);
 
   Object.defineProperty(JpxStream.prototype, 'bytes', {
-    get: function JpxStream_bytes() {
+    get: function() {
       // If this.maybeLength is null, we'll get the entire stream.
       return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
     },
     configurable: true
   });
 
   JpxStream.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
     if (this.bufferLength) {
@@ -31746,17 +31746,17 @@ var Jbig2Stream = (function Jbig2StreamC
     this.dict = dict;
 
     DecodeStream.call(this, maybeLength);
   }
 
   Jbig2Stream.prototype = Object.create(DecodeStream.prototype);
 
   Object.defineProperty(Jbig2Stream.prototype, 'bytes', {
-    get: function Jbig2Stream_bytes() {
+    get: function() {
       // If this.maybeLength is null, we'll get the entire stream.
       return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
     },
     configurable: true
   });
 
   Jbig2Stream.prototype.ensureBuffer = function Jbig2Stream_ensureBuffer(req) {
     if (this.bufferLength) {
@@ -33172,17 +33172,17 @@ var NullStream = (function NullStreamClo
 
   NullStream.prototype = Stream.prototype;
 
   return NullStream;
 })();
 
 
 var WorkerMessageHandler = PDFJS.WorkerMessageHandler = {
-  setup: function wphSetup(handler) {
+  setup: function(handler) {
     var pdfManager;
 
     function loadDocument(recoveryMode) {
       var loadDocumentCapability = createPromiseCapability();
 
       var parseSuccess = function parseSuccess() {
         var numPagesPromise = pdfManager.ensureDoc('numPages');
         var fingerprintPromise = pdfManager.ensureDoc('fingerprint');
@@ -33237,17 +33237,17 @@ var WorkerMessageHandler = PDFJS.WorkerM
       }
 
       var networkManager = new NetworkManager(source.url, {
         httpHeaders: source.httpHeaders,
         withCredentials: source.withCredentials
       });
       var cachedChunks = [];
       var fullRequestXhrId = networkManager.requestFull({
-        onHeadersReceived: function onHeadersReceived() {
+        onHeadersReceived: function() {
           if (disableRange) {
             return;
           }
 
           var fullRequestXhr = networkManager.getRequestXhr(fullRequestXhrId);
           if (fullRequestXhr.getResponseHeader('Accept-Ranges') !== 'bytes') {
             return;
           }
@@ -33296,17 +33296,17 @@ var WorkerMessageHandler = PDFJS.WorkerM
             function onProgressiveData(chunk) {
           if (!pdfManager) {
             cachedChunks.push(chunk);
             return;
           }
           pdfManager.sendProgressiveData(chunk);
         },
 
-        onDone: function onDone(args) {
+        onDone: function(args) {
           if (pdfManager) {
             return; // already processed
           }
 
           var pdfFile;
           if (args === null) {
             // TODO add some streaming manager, e.g. for unknown length files.
             // The data was returned in the onProgressiveData, combining...
@@ -33331,31 +33331,31 @@ var WorkerMessageHandler = PDFJS.WorkerM
           try {
             pdfManager = new LocalPdfManager(pdfFile, source.password);
             pdfManagerCapability.resolve();
           } catch (ex) {
             pdfManagerCapability.reject(ex);
           }
         },
 
-        onError: function onError(status) {
+        onError: function(status) {
           var exception;
           if (status === 404) {
             exception = new MissingPDFException('Missing PDF "' +
                                                 source.url + '".');
             handler.send('MissingPDF', exception);
           } else {
             exception = new UnexpectedResponseException(
               'Unexpected server response (' + status +
               ') while retrieving PDF "' + source.url + '".', status);
             handler.send('UnexpectedResponse', exception);
           }
         },
 
-        onProgress: function onProgress(evt) {
+        onProgress: function(evt) {
           handler.send('DocProgress', {
             loaded: evt.loaded,
             total: evt.lengthComputable ? evt.total : source.length
           });
         }
       });
 
       return pdfManagerCapability.promise;
@@ -33598,38 +33598,38 @@ var WorkerMessageHandler = PDFJS.WorkerM
       pdfManager.terminate();
     });
   }
 };
 
 var consoleTimer = {};
 
 var workerConsole = {
-  log: function log() {
+  log: function() {
     var args = Array.prototype.slice.call(arguments);
     globalScope.postMessage({
       action: 'console_log',
       data: args
     });
   },
 
-  error: function error() {
+  error: function() {
     var args = Array.prototype.slice.call(arguments);
     globalScope.postMessage({
       action: 'console_error',
       data: args
     });
     throw 'pdf.js execution error';
   },
 
-  time: function time(name) {
+  time: function(name) {
     consoleTimer[name] = Date.now();
   },
 
-  timeEnd: function timeEnd(name) {
+  timeEnd: function(name) {
     var time = consoleTimer[name];
     if (!time) {
       error('Unknown timer name ' + name);
     }
     this.log('Timer:', name, Date.now() - time);
   }
 };
 
@@ -33727,17 +33727,17 @@ var ArithmeticDecoder = (function Arithm
     this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
     this.clow = (this.clow << 7) & 0xFFFF;
     this.ct -= 7;
     this.a = 0x8000;
   }
 
   ArithmeticDecoder.prototype = {
     // C.3.4 Compressed data input (BYTEIN)
-    byteIn: function ArithmeticDecoder_byteIn() {
+    byteIn: function() {
       var data = this.data;
       var bp = this.bp;
       if (data[bp] === 0xFF) {
         var b1 = data[bp + 1];
         if (b1 > 0x8F) {
           this.clow += 0xFF00;
           this.ct = 8;
         } else {
@@ -33753,17 +33753,17 @@ var ArithmeticDecoder = (function Arithm
         this.bp = bp;
       }
       if (this.clow > 0xFFFF) {
         this.chigh += (this.clow >> 16);
         this.clow &= 0xFFFF;
       }
     },
     // C.3.2 Decoding a decision (DECODE)
-    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
+    readBit: function(contexts, pos) {
       // contexts are packed into 1 byte:
       // highest 7 bits carry cx.index, lowest bit carries cx.mps
       var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
       var qeTableIcx = QeTable[cx_index];
       var qeIcx = qeTableIcx.qe;
       var d;
       var a = this.a - qeIcx;
 
@@ -34362,17 +34362,17 @@ var JpegImage = (function jpegImage() {
     return component.blockData;
   }
 
   function clamp0to255(a) {
     return a <= 0 ? 0 : a >= 255 ? 255 : a;
   }
 
   constructor.prototype = {
-    parse: function parse(data) {
+    parse: function(data) {
 
       function readUint16() {
         var value = (data[offset] << 8) | data[offset + 1];
         offset += 2;
         return value;
       }
 
       function readDataBlock() {
@@ -34608,17 +34608,17 @@ var JpegImage = (function jpegImage() {
           scaleY: component.v / frame.maxV,
           blocksPerLine: component.blocksPerLine,
           blocksPerColumn: component.blocksPerColumn
         });
       }
       this.numComponents = this.components.length;
     },
 
-    _getLinearizedBlockData: function getLinearizedBlockData(width, height) {
+    _getLinearizedBlockData: function(width, height) {
       var scaleX = this.width / width, scaleY = this.height / height;
 
       var component, componentScaleX, componentScaleY, blocksPerScanline;
       var x, y, i, j, k;
       var index;
       var offset = 0;
       var output;
       var numComponents = this.components.length;
@@ -34657,41 +34657,41 @@ var JpegImage = (function jpegImage() {
           for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
             data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];
           }
         }
       }
       return data;
     },
 
-    _isColorConversionNeeded: function isColorConversionNeeded() {
+    _isColorConversionNeeded: function() {
       if (this.adobe && this.adobe.transformCode) {
         // The adobe transform marker overrides any previous setting
         return true;
       } else if (this.numComponents === 3) {
         return true;
       } else {
         return false;
       }
     },
 
-    _convertYccToRgb: function convertYccToRgb(data) {
+    _convertYccToRgb: function(data) {
       var Y, Cb, Cr;
       for (var i = 0, length = data.length; i < length; i += 3) {
         Y  = data[i    ];
         Cb = data[i + 1];
         Cr = data[i + 2];
         data[i    ] = clamp0to255(Y - 179.456 + 1.402 * Cr);
         data[i + 1] = clamp0to255(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
         data[i + 2] = clamp0to255(Y - 226.816 + 1.772 * Cb);
       }
       return data;
     },
 
-    _convertYcckToRgb: function convertYcckToRgb(data) {
+    _convertYcckToRgb: function(data) {
       var Y, Cb, Cr, k;
       var offset = 0;
       for (var i = 0, length = data.length; i < length; i += 4) {
         Y  = data[i];
         Cb = data[i + 1];
         Cr = data[i + 2];
         k = data[i + 3];
 
@@ -34727,31 +34727,31 @@ var JpegImage = (function jpegImage() {
 
         data[offset++] = clamp0to255(r);
         data[offset++] = clamp0to255(g);
         data[offset++] = clamp0to255(b);
       }
       return data;
     },
 
-    _convertYcckToCmyk: function convertYcckToCmyk(data) {
+    _convertYcckToCmyk: function(data) {
       var Y, Cb, Cr;
       for (var i = 0, length = data.length; i < length; i += 4) {
         Y  = data[i];
         Cb = data[i + 1];
         Cr = data[i + 2];
         data[i    ] = clamp0to255(434.456 - Y - 1.402 * Cr);
         data[i + 1] = clamp0to255(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
         data[i + 2] = clamp0to255(481.816 - Y - 1.772 * Cb);
         // K in data[i + 3] is unchanged
       }
       return data;
     },
 
-    _convertCmykToRgb: function convertCmykToRgb(data) {
+    _convertCmykToRgb: function(data) {
       var c, m, y, k;
       var offset = 0;
       var min = -255 * 255 * 255;
       var scale = 1 / 255 / 255;
       for (var i = 0, length = data.length; i < length; i += 4) {
         c = data[i];
         m = data[i + 1];
         y = data[i + 2];
@@ -34787,17 +34787,17 @@ var JpegImage = (function jpegImage() {
 
         data[offset++] = r >= 0 ? 255 : r <= min ? 0 : 255 + r * scale | 0;
         data[offset++] = g >= 0 ? 255 : g <= min ? 0 : 255 + g * scale | 0;
         data[offset++] = b >= 0 ? 255 : b <= min ? 0 : 255 + b * scale | 0;
       }
       return data;
     },
 
-    getData: function getData(width, height, forceRGBoutput) {
+    getData: function(width, height, forceRGBoutput) {
       if (this.numComponents > 4) {
         throw 'Unsupported color mode';
       }
       // type of data: Uint8Array(width * height * numComponents)
       var data = this._getLinearizedBlockData(width, height);
 
       if (this.numComponents === 3) {
         return this._convertYccToRgb(data);
@@ -34827,17 +34827,17 @@ var JpxImage = (function JpxImageClosure
     'LH': 1,
     'HL': 1,
     'HH': 2
   };
   function JpxImage() {
     this.failOnCorruptedImage = false;
   }
   JpxImage.prototype = {
-    parse: function JpxImage_parse(data) {
+    parse: function(data) {
 
       var head = readUint16(data, 0);
       // No box header, immediate start of codestream (SOC)
       if (head === 0xFF4F) {
         this.parseCodestream(data, 0, data.length);
         return;
       }
 
@@ -34911,17 +34911,17 @@ var JpxImage = (function JpxImageClosure
             warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
             break;
         }
         if (jumpDataLength) {
           position += dataLength;
         }
       }
     },
-    parseImageProperties: function JpxImage_parseImageProperties(stream) {
+    parseImageProperties: function(stream) {
       var newByte = stream.getByte();
       while (newByte >= 0) {
         var oldByte = newByte;
         newByte = stream.getByte();
         var code = (oldByte << 8) | newByte;
         // Image and tile size (SIZ)
         if (code === 0xFF51) {
           stream.skip(4);
@@ -34936,17 +34936,17 @@ var JpxImage = (function JpxImageClosure
           this.componentsCount = Csiz;
           // Results are always returned as Uint8Arrays
           this.bitsPerComponent = 8;
           return;
         }
       }
       throw new Error('JPX Error: No size marker found in JPX stream');
     },
-    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
+    parseCodestream: function(data, start, end) {
       var context = {};
       try {
         var doNotRecover = false;
         var position = start;
         while (position + 1 < end) {
           var code = readUint16(data, position);
           position += 2;
 
@@ -36291,17 +36291,17 @@ var JpxImage = (function JpxImageClosure
           items: []
         };
         this.levels.push(level);
         width = Math.ceil(width / 2);
         height = Math.ceil(height / 2);
       }
     }
     TagTree.prototype = {
-      reset: function TagTree_reset(i, j) {
+      reset: function(i, j) {
         var currentLevel = 0, value = 0, level;
         while (currentLevel < this.levels.length) {
           level = this.levels[currentLevel];
           var index = i + j * level.width;
           if (level.items[index] !== undefined) {
             value = level.items[index];
             break;
           }
@@ -36311,21 +36311,21 @@ var JpxImage = (function JpxImageClosure
           currentLevel++;
         }
         currentLevel--;
         level = this.levels[currentLevel];
         level.items[level.index] = value;
         this.currentLevel = currentLevel;
         delete this.value;
       },
-      incrementValue: function TagTree_incrementValue() {
+      incrementValue: function() {
         var level = this.levels[this.currentLevel];
         level.items[level.index]++;
       },
-      nextLevel: function TagTree_nextLevel() {
+      nextLevel: function() {
         var currentLevel = this.currentLevel;
         var level = this.levels[currentLevel];
         var value = level.items[level.index];
         currentLevel--;
         if (currentLevel < 0) {
           this.value = value;
           return false;
         }
@@ -36356,17 +36356,17 @@ var JpxImage = (function JpxImageClosure
         };
         this.levels.push(level);
 
         width = Math.ceil(width / 2);
         height = Math.ceil(height / 2);
       }
     }
     InclusionTree.prototype = {
-      reset: function InclusionTree_reset(i, j, stopValue) {
+      reset: function(i, j, stopValue) {
         var currentLevel = 0;
         while (currentLevel < this.levels.length) {
           var level = this.levels[currentLevel];
           var index = i + j * level.width;
           level.index = index;
           var value = level.items[index];
 
           if (value === 0xFF) {
@@ -36382,31 +36382,31 @@ var JpxImage = (function JpxImageClosure
 
           i >>= 1;
           j >>= 1;
           currentLevel++;
         }
         this.currentLevel = currentLevel - 1;
         return true;
       },
-      incrementValue: function InclusionTree_incrementValue(stopValue) {
+      incrementValue: function(stopValue) {
         var level = this.levels[this.currentLevel];
         level.items[level.index] = stopValue + 1;
         this.propagateValues();
       },
-      propagateValues: function InclusionTree_propagateValues() {
+      propagateValues: function() {
         var levelIndex = this.currentLevel;
         var level = this.levels[levelIndex];
         var currentValue = level.items[level.index];
         while (--levelIndex >= 0) {
           level = this.levels[levelIndex];
           level.items[level.index] = currentValue;
         }
       },
-      nextLevel: function InclusionTree_nextLevel() {
+      nextLevel: function() {
         var currentLevel = this.currentLevel;
         var level = this.levels[currentLevel];
         var value = level.items[level.index];
         level.items[level.index] = 0xFF;
         currentLevel--;
         if (currentLevel < 0) {
           return false;
         }
@@ -36468,20 +36468,20 @@ var JpxImage = (function JpxImageClosure
         }
       }
       this.bitsDecoded = bitsDecoded;
 
       this.reset();
     }
 
     BitModel.prototype = {
-      setDecoder: function BitModel_setDecoder(decoder) {
+      setDecoder: function(decoder) {
         this.decoder = decoder;
       },
-      reset: function BitModel_reset() {
+      reset: function() {
         // We have 17 contexts that are accessed via context labels,
         // plus the uniform and runlength context.
         this.contexts = new Int8Array(19);
 
         // Contexts are packed into 1 byte:
         // highest 7 bits carry the index, lowest bit carries mps
         this.contexts[0] = (4 << 1) | 0;
         this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
@@ -36566,17 +36566,17 @@ var JpxImage = (function JpxImageClosure
                 processingFlags[index] |= firstMagnitudeBitMask;
               }
               bitsDecoded[index]++;
               processingFlags[index] |= processedMask;
             }
           }
         }
       },
-      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
+      decodeSignBit: function(row, column, index) {
         var width = this.width, height = this.height;
         var coefficentsMagnitude = this.coefficentsMagnitude;
         var coefficentsSign = this.coefficentsSign;
         var contribution, sign0, sign1, significance1;
         var contextLabel, decoded;
 
         // calculate horizontal contribution
         significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
@@ -36659,17 +36659,17 @@ var JpxImage = (function JpxImageClosure
               coefficentsMagnitude[index] =
                 (coefficentsMagnitude[index] << 1) | bit;
               bitsDecoded[index]++;
               processingFlags[index] |= processedMask;
             }
           }
         }
       },
-      runCleanupPass: function BitModel_runCleanupPass() {
+      runCleanupPass: function() {
         var decoder = this.decoder;
         var width = this.width, height = this.height;
         var neighborsSignificance = this.neighborsSignificance;
         var coefficentsMagnitude = this.coefficentsMagnitude;
         var coefficentsSign = this.coefficentsSign;
         var contexts = this.contexts;
         var labels = this.contextLabelTable;
         var bitsDecoded = this.bitsDecoded;
@@ -36744,17 +36744,17 @@ var JpxImage = (function JpxImageClosure
                 this.setNeighborsSignificance(i, j, index);
                 processingFlags[index] |= firstMagnitudeBitMask;
               }
               bitsDecoded[index]++;
             }
           }
         }
       },
-      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
+      checkSegmentationSymbol: function() {
         var decoder = this.decoder;
         var contexts = this.contexts;
         var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |
                      (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |
                      (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                       decoder.readBit(contexts, UNIFORM_CONTEXT);
         if (symbol !== 0xA) {
           throw new Error('JPX Error: Invalid segmentation symbol');
@@ -37933,30 +37933,30 @@ var Jbig2Image = (function Jbig2ImageClo
       processSegments(segments, visitor);
     }
     return visitor.buffer;
   }
 
   function SimpleSegmentVisitor() {}
 
   SimpleSegmentVisitor.prototype = {
-    onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
+    onPageInformation: function(info) {
       this.currentPageInfo = info;
       var rowSize = (info.width + 7) >> 3;
       var buffer = new Uint8Array(rowSize * info.height);
       // The contents of ArrayBuffers are initialized to 0.
       // Fill the buffer with 0xFF only if info.defaultPixelValue is set
       if (info.defaultPixelValue) {
         for (var i = 0, ii = buffer.length; i < ii; i++) {
           buffer[i] = 0xFF;
         }
       }
       this.buffer = buffer;
     },
-    drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
+    drawBitmap: function(regionInfo, bitmap) {
       var pageInfo = this.currentPageInfo;
       var width = regionInfo.width, height = regionInfo.height;
       var rowSize = (pageInfo.width + 7) >> 3;
       var combinationOperator = pageInfo.combinationOperatorOverride ?
         regionInfo.combinationOperator : pageInfo.combinationOperator;
       var buffer = this.buffer;
       var mask0 =  128 >> (regionInfo.x & 7);
       var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
@@ -38072,17 +38072,17 @@ var Jbig2Image = (function Jbig2ImageClo
       function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
       this.onImmediateTextRegion.apply(this, arguments);
     }
   };
 
   function Jbig2Image() {}
 
   Jbig2Image.prototype = {
-    parseChunks: function Jbig2Image_parseChunks(chunks) {
+    parseChunks: function(chunks) {
       return parseJbig2Chunks(chunks);
     }
   };
 
   return Jbig2Image;
 })();
 
 
@@ -38528,17 +38528,17 @@ var MurmurHash3_64 = (function MurmurHas
     var SEED = 0xc3d2e1f0;
     this.h1 = seed ? seed & 0xffffffff : SEED;
     this.h2 = seed ? seed & 0xffffffff : SEED;
   }
 
   var alwaysUseUint32ArrayView = false;
 
   MurmurHash3_64.prototype = {
-    update: function MurmurHash3_64_update(input) {
+    update: function(input) {
       var useUint32ArrayView = alwaysUseUint32ArrayView;
       var i;
       if (typeof input === 'string') {
         var data = new Uint8Array(input.length * 2);
         var length = 0;
         for (i = 0; i < input.length; i++) {
           var code = input.charCodeAt(i);
           if (code <= 0xff) {
@@ -38619,17 +38619,17 @@ var MurmurHash3_64 = (function MurmurHas
         }
       }
 
       this.h1 = h1;
       this.h2 = h2;
       return this;
     },
 
-    hexdigest: function MurmurHash3_64_hexdigest () {
+    hexdigest: function() {
       var h1 = this.h1;
       var h2 = this.h2;
 
       h1 ^= h2 >>> 1;
       h1 = (h1 * 0xed558ccd & MASK_HIGH) | (h1 * 0x8ccd & MASK_LOW);
       h2 = (h2 * 0xff51afd7 & MASK_HIGH) |
            (((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16);
       h1 ^= h2 >>> 1;
diff --git a/browser/extensions/pdfjs/content/network.js b/browser/extensions/pdfjs/content/network.js
--- a/browser/extensions/pdfjs/content/network.js
+++ b/browser/extensions/pdfjs/content/network.js
@@ -22,17 +22,17 @@
 
 
   
   Components.utils.import('resource://gre/modules/Services.jsm');
   
   var EXPORTED_SYMBOLS = ['NetworkManager'];
   
   var console = {
-    log: function console_log(aMsg) {
+    log: function(aMsg) {
       var msg = 'network.js: ' + (aMsg.join ? aMsg.join('') : aMsg);
       Services.console.logStringMessage(msg);
       // TODO(mack): dump() doesn't seem to work here...
       dump(msg + '\n');
     }
   }
 
 var NetworkManager = (function NetworkManagerClosure() {
@@ -65,32 +65,32 @@ var NetworkManager = (function NetworkMa
     var array = new Uint8Array(length);
     for (var i = 0; i < length; i++) {
       array[i] = data.charCodeAt(i) & 0xFF;
     }
     return array.buffer;
   }
 
   NetworkManager.prototype = {
-    requestRange: function NetworkManager_requestRange(begin, end, listeners) {
+    requestRange: function(begin, end, listeners) {
       var args = {
         begin: begin,
         end: end
       };
       for (var prop in listeners) {
         args[prop] = listeners[prop];
       }
       return this.request(args);
     },
 
-    requestFull: function NetworkManager_requestFull(listeners) {
+    requestFull: function(listeners) {
       return this.request(listeners);
     },
 
-    request: function NetworkManager_request(args) {
+    request: function(args) {
       var xhr = this.getXhr();
       var xhrId = this.currXhrId++;
       var pendingRequest = this.pendingRequests[xhrId] = {
         xhr: xhr
       };
 
       xhr.open('GET', this.url);
       xhr.withCredentials = this.withCredentials;
@@ -137,17 +137,17 @@ var NetworkManager = (function NetworkMa
       pendingRequest.onError = args.onError;
       pendingRequest.onProgress = args.onProgress;
 
       xhr.send(null);
 
       return xhrId;
     },
 
-    onProgress: function NetworkManager_onProgress(xhrId, evt) {
+    onProgress: function(xhrId, evt) {
       var pendingRequest = this.pendingRequests[xhrId];
       if (!pendingRequest) {
         // Maybe abortRequest was called...
         return;
       }
 
       if (pendingRequest.mozChunked) {
         var chunk = getArrayBuffer(pendingRequest.xhr);
@@ -155,17 +155,17 @@ var NetworkManager = (function NetworkMa
       }
 
       var onProgress = pendingRequest.onProgress;
       if (onProgress) {
         onProgress(evt);
       }
     },
 
-    onStateChange: function NetworkManager_onStateChange(xhrId, evt) {
+    onStateChange: function(xhrId, evt) {
       var pendingRequest = this.pendingRequests[xhrId];
       if (!pendingRequest) {
         // Maybe abortRequest was called...
         return;
       }
 
       var xhr = pendingRequest.xhr;
       if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
@@ -225,46 +225,46 @@ var NetworkManager = (function NetworkMa
       } else {
         pendingRequest.onDone({
           begin: 0,
           chunk: chunk
         });
       }
     },
 
-    hasPendingRequests: function NetworkManager_hasPendingRequests() {
+    hasPendingRequests: function() {
       for (var xhrId in this.pendingRequests) {
         return true;
       }
       return false;
     },
 
-    getRequestXhr: function NetworkManager_getXhr(xhrId) {
+    getRequestXhr: function(xhrId) {
       return this.pendingRequests[xhrId].xhr;
     },
 
-    isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {
+    isStreamingRequest: function(xhrId) {
       return !!(this.pendingRequests[xhrId].onProgressiveData);
     },
 
-    isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {
+    isPendingRequest: function(xhrId) {
       return xhrId in this.pendingRequests;
     },
 
-    isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {
+    isLoadedRequest: function(xhrId) {
       return xhrId in this.loadedRequests;
     },
 
-    abortAllRequests: function NetworkManager_abortAllRequests() {
+    abortAllRequests: function() {
       for (var xhrId in this.pendingRequests) {
         this.abortRequest(xhrId | 0);
       }
     },
 
-    abortRequest: function NetworkManager_abortRequest(xhrId) {
+    abortRequest: function(xhrId) {
       var xhr = this.pendingRequests[xhrId].xhr;
       delete this.pendingRequests[xhrId];
       xhr.abort();
     }
   };
 
   return NetworkManager;
 })();
diff --git a/browser/extensions/pdfjs/content/web/debugger.js b/browser/extensions/pdfjs/content/web/debugger.js
--- a/browser/extensions/pdfjs/content/web/debugger.js
+++ b/browser/extensions/pdfjs/content/web/debugger.js
@@ -62,28 +62,28 @@ var FontInspector = (function FontInspec
     }
   }
   return {
     // Properties/functions needed by PDFBug.
     id: 'FontInspector',
     name: 'Font Inspector',
     panel: null,
     manager: null,
-    init: function init() {
+    init: function() {
       var panel = this.panel;
       panel.setAttribute('style', 'padding: 5px;');
       var tmp = document.createElement('button');
       tmp.addEventListener('click', resetSelection);
       tmp.textContent = 'Refresh';
       panel.appendChild(tmp);
 
       fonts = document.createElement('div');
       panel.appendChild(fonts);
     },
-    cleanup: function cleanup() {
+    cleanup: function() {
       fonts.textContent = '';
     },
     enabled: false,
     get active() {
       return active;
     },
     set active(value) {
       active = value;
@@ -91,17 +91,17 @@ var FontInspector = (function FontInspec
         document.body.addEventListener('click', textLayerClick, true);
         resetSelection();
       } else {
         document.body.removeEventListener('click', textLayerClick, true);
         removeSelection();
       }
     },
     // FontInspector specific functions.
-    fontAdded: function fontAdded(fontObj, url) {
+    fontAdded: function(fontObj, url) {
       function properties(obj, list) {
         var moreInfo = document.createElement('table');
         for (var i = 0; i < list.length; i++) {
           var tr = document.createElement('tr');
           var td1 = document.createElement('td');
           td1.textContent = list[i];
           tr.appendChild(td1);
           var td2 = document.createElement('td');
@@ -169,41 +169,41 @@ var StepperManager = (function StepperMa
   var stepperChooser = null;
   var breakPoints = {};
   return {
     // Properties/functions needed by PDFBug.
     id: 'Stepper',
     name: 'Stepper',
     panel: null,
     manager: null,
-    init: function init() {
+    init: function() {
       var self = this;
       this.panel.setAttribute('style', 'padding: 5px;');
       stepperControls = document.createElement('div');
       stepperChooser = document.createElement('select');
       stepperChooser.addEventListener('change', function(event) {
         self.selectStepper(this.value);
       });
       stepperControls.appendChild(stepperChooser);
       stepperDiv = document.createElement('div');
       this.panel.appendChild(stepperControls);
       this.panel.appendChild(stepperDiv);
       if (sessionStorage.getItem('pdfjsBreakPoints')) {
         breakPoints = JSON.parse(sessionStorage.getItem('pdfjsBreakPoints'));
       }
     },
-    cleanup: function cleanup() {
+    cleanup: function() {
       stepperChooser.textContent = '';
       stepperDiv.textContent = '';
       steppers = [];
     },
     enabled: false,
     active: false,
     // Stepper specific functions.
-    create: function create(pageIndex) {
+    create: function(pageIndex) {
       var debug = document.createElement('div');
       debug.id = 'stepper' + pageIndex;
       debug.setAttribute('hidden', true);
       debug.className = 'stepper';
       stepperDiv.appendChild(debug);
       var b = document.createElement('option');
       b.textContent = 'Page ' + (pageIndex + 1);
       b.value = pageIndex;
@@ -211,17 +211,17 @@ var StepperManager = (function StepperMa
       var initBreakPoints = breakPoints[pageIndex] || [];
       var stepper = new Stepper(debug, pageIndex, initBreakPoints);
       steppers.push(stepper);
       if (steppers.length === 1) {
         this.selectStepper(pageIndex, false);
       }
       return stepper;
     },
-    selectStepper: function selectStepper(pageIndex, selectPanel) {
+    selectStepper: function(pageIndex, selectPanel) {
       var i;
       pageIndex = pageIndex | 0;
       if (selectPanel) {
         this.manager.selectPanel(this);
       }
       for (i = 0; i < steppers.length; ++i) {
         var stepper = steppers[i];
         if (stepper.pageIndex === pageIndex) {
@@ -231,17 +231,17 @@ var StepperManager = (function StepperMa
         }
       }
       var options = stepperChooser.options;
       for (i = 0; i < options.length; ++i) {
         var option = options[i];
         option.selected = (option.value | 0) === pageIndex;
       }
     },
-    saveBreakPoints: function saveBreakPoints(pageIndex, bps) {
+    saveBreakPoints: function(pageIndex, bps) {
       breakPoints[pageIndex] = bps;
       sessionStorage.setItem('pdfjsBreakPoints', JSON.stringify(breakPoints));
     }
   };
 })();
 
 // The stepper for each page's IRQueue.
 var Stepper = (function StepperClosure() {
@@ -288,17 +288,17 @@ var Stepper = (function StepperClosure()
     this.breakPoint = 0;
     this.nextBreakPoint = null;
     this.pageIndex = pageIndex;
     this.breakPoints = initialBreakPoints;
     this.currentIdx = -1;
     this.operatorListIdx = 0;
   }
   Stepper.prototype = {
-    init: function init() {
+    init: function() {
       var panel = this.panel;
       var content = c('div', 'c=continue, s=step');
       var table = c('table');
       content.appendChild(table);
       table.cellSpacing = 0;
       var headerRow = c('tr');
       table.appendChild(headerRow);
       headerRow.appendChild(c('th', 'Break'));
@@ -309,17 +309,17 @@ var Stepper = (function StepperClosure()
       this.table = table;
       if (!opMap) {
         opMap = Object.create(null);
         for (var key in PDFJS.OPS) {
           opMap[PDFJS.OPS[key]] = key;
         }
       }
     },
-    updateOperatorList: function updateOperatorList(operatorList) {
+    updateOperatorList: function(operatorList) {
       var self = this;
 
       function cboxOnClick() {
         var x = +this.dataset.idx;
         if (this.checked) {
           self.breakPoints.push(x);
         } else {
           self.breakPoints.splice(self.breakPoints.indexOf(x), 1);
@@ -384,26 +384,26 @@ var Stepper = (function StepperClosure()
         line = c('tr');
         var lastCell = c('td', '...');
         lastCell.colspan = 4;
         chunk.appendChild(lastCell);
       }
       this.operatorListIdx = operatorList.fnArray.length;
       this.table.appendChild(chunk);
     },
-    getNextBreakPoint: function getNextBreakPoint() {
+    getNextBreakPoint: function() {
       this.breakPoints.sort(function(a, b) { return a - b; });
       for (var i = 0; i < this.breakPoints.length; i++) {
         if (this.breakPoints[i] > this.currentIdx) {
           return this.breakPoints[i];
         }
       }
       return null;
     },
-    breakIt: function breakIt(idx, callback) {
+    breakIt: function(idx, callback) {
       StepperManager.selectStepper(this.pageIndex, true);
       var self = this;
       var dom = document;
       self.currentIdx = idx;
       var listener = function(e) {
         switch (e.keyCode) {
           case 83: // step
             dom.removeEventListener('keydown', listener, false);
@@ -418,17 +418,17 @@ var Stepper = (function StepperClosure()
             self.goTo(-1);
             callback();
             break;
         }
       };
       dom.addEventListener('keydown', listener, false);
       self.goTo(idx);
     },
-    goTo: function goTo(idx) {
+    goTo: function(idx) {
       var allRows = this.panel.getElementsByClassName('line');
       for (var x = 0, xx = allRows.length; x < xx; ++x) {
         var row = allRows[x];
         if ((row.dataset.idx | 0) === idx) {
           row.style.backgroundColor = 'rgb(251,250,207)';
           row.scrollIntoView();
         } else {
           row.style.backgroundColor = null;
@@ -455,17 +455,17 @@ var Stats = (function Stats() {
     return false;
   }
   return {
     // Properties/functions needed by PDFBug.
     id: 'Stats',
     name: 'Stats',
     panel: null,
     manager: null,
-    init: function init() {
+    init: function() {
       this.panel.setAttribute('style', 'padding: 5px;');
       PDFJS.enableStats = true;
     },
     enabled: false,
     active: false,
     // Stats specific functions.
     add: function(pageNumber, stat) {
       if (!stat) {
@@ -529,17 +529,17 @@ var PDFBug = (function PDFBugClosure() {
           var indexA = ids.indexOf(a.id);
           indexA = indexA < 0 ? tools.length : indexA;
           var indexB = ids.indexOf(b.id);
           indexB = indexB < 0 ? tools.length : indexB;
           return indexA - indexB;
         });
       }
     },
-    init: function init() {
+    init: function() {
       /*
        * Basic Layout:
        * PDFBug
        *  Controls
        *  Panels
        *    Panel
        *    Panel
        *    ...
@@ -583,24 +583,24 @@ var PDFBug = (function PDFBugClosure() {
           panel.textContent = tool.name + ' is disabled. To enable add ' +
                               ' "' + tool.id + '" to the pdfBug parameter ' +
                               'and refresh (seperate multiple by commas).';
         }
         buttons.push(panelButton);
       }
       this.selectPanel(0);
     },
-    cleanup: function cleanup() {
+    cleanup: function() {
       for (var i = 0, ii = this.tools.length; i < ii; i++) {
         if (this.tools[i].enabled) {
           this.tools[i].cleanup();
         }
       }
     },
-    selectPanel: function selectPanel(index) {
+    selectPanel: function(index) {
       if (typeof index !== 'number') {
         index = this.tools.indexOf(index);
       }
       if (index === activePanel) {
         return;
       }
       activePanel = index;
       var tools = this.tools;
diff --git a/browser/extensions/pdfjs/content/web/viewer.js b/browser/extensions/pdfjs/content/web/viewer.js
--- a/browser/extensions/pdfjs/content/web/viewer.js
+++ b/browser/extensions/pdfjs/content/web/viewer.js
@@ -318,17 +318,17 @@ var ProgressBar = (function ProgressBarC
 
     // Initialize heights.
     this.div.style.height = this.height + this.units;
     this.percent = 0;
   }
 
   ProgressBar.prototype = {
 
-    updateBar: function ProgressBar_updateBar() {
+    updateBar: function() {
       if (this._indeterminate) {
         this.div.classList.add('indeterminate');
         this.div.style.width = this.width + this.units;
         return;
       }
 
       this.div.classList.remove('indeterminate');
       var progressSize = this.width * this._percent / 100;
@@ -340,37 +340,37 @@ var ProgressBar = (function ProgressBarC
     },
 
     set percent(val) {
       this._indeterminate = isNaN(val);
       this._percent = clamp(val, 0, 100);
       this.updateBar();
     },
 
-    setWidth: function ProgressBar_setWidth(viewer) {
+    setWidth: function(viewer) {
       if (viewer) {
         var container = viewer.parentNode;
         var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
         if (scrollbarWidth > 0) {
           this.bar.setAttribute('style', 'width: calc(100% - ' +
                                          scrollbarWidth + 'px);');
         }
       }
     },
 
-    hide: function ProgressBar_hide() {
+    hide: function() {
       if (!this.visible) {
         return;
       }
       this.visible = false;
       this.bar.classList.add('hidden');
       document.body.classList.remove('loadingInProgress');
     },
 
-    show: function ProgressBar_show() {
+    show: function() {
       if (this.visible) {
         return;
       }
       this.visible = true;
       document.body.classList.add('loadingInProgress');
       this.bar.classList.remove('hidden');
     }
   };
@@ -413,83 +413,83 @@ var Preferences = {
   isInitializedPromiseResolved: false,
   initializedPromise: null,
 
   /**
    * Initialize and fetch the current preference values from storage.
    * @return {Promise} A promise that is resolved when the preferences
    *                   have been initialized.
    */
-  initialize: function preferencesInitialize() {
+  initialize: function() {
     return this.initializedPromise =
         this._readFromStorage(DEFAULT_PREFERENCES).then(function(prefObj) {
       this.isInitializedPromiseResolved = true;
       if (prefObj) {
         this.prefs = prefObj;
       }
     }.bind(this));
   },
 
   /**
    * Stub function for writing preferences to storage.
    * NOTE: This should be overridden by a build-specific function defined below.
    * @param {Object} prefObj The preferences that should be written to storage.
    * @return {Promise} A promise that is resolved when the preference values
    *                   have been written.
    */
-  _writeToStorage: function preferences_writeToStorage(prefObj) {
+  _writeToStorage: function(prefObj) {
     return Promise.resolve();
   },
 
   /**
    * Stub function for reading preferences from storage.
    * NOTE: This should be overridden by a build-specific function defined below.
    * @param {Object} prefObj The preferences that should be read from storage.
    * @return {Promise} A promise that is resolved with an {Object} containing
    *                   the preferences that have been read.
    */
-  _readFromStorage: function preferences_readFromStorage(prefObj) {
+  _readFromStorage: function(prefObj) {
     return Promise.resolve();
   },
 
   /**
    * Reset the preferences to their default values and update storage.
    * @return {Promise} A promise that is resolved when the preference values
    *                   have been reset.
    */
-  reset: function preferencesReset() {
+  reset: function() {
     return this.initializedPromise.then(function() {
       this.prefs = Object.create(DEFAULT_PREFERENCES);
       return this._writeToStorage(DEFAULT_PREFERENCES);
     }.bind(this));
   },
 
   /**
    * Replace the current preference values with the ones from storage.
    * @return {Promise} A promise that is resolved when the preference values
    *                   have been updated.
    */
-  reload: function preferencesReload() {
+  reload: function() {
     return this.initializedPromise.then(function () {
       this._readFromStorage(DEFAULT_PREFERENCES).then(function(prefObj) {
         if (prefObj) {
           this.prefs = prefObj;
         }
       }.bind(this));
     }.bind(this));
   },
 
   /**
    * Set the value of a preference.
    * @param {string} name The name of the preference that should be changed.
    * @param {boolean|number|string} value The new value of the preference.
    * @return {Promise} A promise that is resolved when the value has been set,
    *                   provided that the preference exists and the types match.
    */
-  set: function preferencesSet(name, value) {
+  set: function(name, value) {
     return this.initializedPromise.then(function () {
       if (DEFAULT_PREFERENCES[name] === undefined) {
         throw new Error('preferencesSet: \'' + name + '\' is undefined.');
       } else if (value === undefined) {
         throw new Error('preferencesSet: no value is specified.');
       }
       var valueType = typeof value;
       var defaultType = typeof DEFAULT_PREFERENCES[name];
@@ -513,17 +513,17 @@ var Preferences = {
   },
 
   /**
    * Get the value of a preference.
    * @param {string} name The name of the preference whose value is requested.
    * @return {Promise} A promise that is resolved with a {boolean|number|string}
    *                   containing the value of the preference.
    */
-  get: function preferencesGet(name) {
+  get: function(name) {
     return this.initializedPromise.then(function () {
       var defaultValue = DEFAULT_PREFERENCES[name];
 
       if (defaultValue === undefined) {
         throw new Error('preferencesGet: \'' + name + '\' is undefined.');
       } else {
         var prefValue = this.prefs[name];
 
@@ -600,17 +600,17 @@ var FirefoxCom = (function FirefoxComClo
     }
   };
 })();
 
 var DownloadManager = (function DownloadManagerClosure() {
   function DownloadManager() {}
 
   DownloadManager.prototype = {
-    downloadUrl: function DownloadManager_downloadUrl(url, filename) {
+    downloadUrl: function(url, filename) {
       FirefoxCom.request('download', {
         originalUrl: url,
         filename: filename
       });
     },
 
     downloadData: function DownloadManager_downloadData(data, filename,
                                                         contentType) {
@@ -619,17 +619,17 @@ var DownloadManager = (function Download
       FirefoxCom.request('download', {
         blobUrl: blobUrl,
         originalUrl: blobUrl,
         filename: filename,
         isAttachment: true
       });
     },
 
-    download: function DownloadManager_download(blob, url, filename) {
+    download: function(blob, url, filename) {
       var blobUrl = window.URL.createObjectURL(blob);
 
       FirefoxCom.request('download', {
         blobUrl: blobUrl,
         originalUrl: url,
         filename: filename
       },
         function response(err) {
@@ -700,54 +700,54 @@ var ViewHistory = (function ViewHistoryC
         index = database.files.push({fingerprint: this.fingerprint}) - 1;
       }
       this.file = database.files[index];
       this.database = database;
     }.bind(this));
   }
 
   ViewHistory.prototype = {
-    _writeToStorage: function ViewHistory_writeToStorage() {
+    _writeToStorage: function() {
       return new Promise(function (resolve) {
         var databaseStr = JSON.stringify(this.database);
 
 
         sessionStorage.setItem('pdfjsHistory', databaseStr);
         resolve();
 
       }.bind(this));
     },
 
-    _readFromStorage: function ViewHistory_readFromStorage() {
+    _readFromStorage: function() {
       return new Promise(function (resolve) {
 
         resolve(sessionStorage.getItem('pdfjsHistory'));
 
       });
     },
 
-    set: function ViewHistory_set(name, val) {
+    set: function(name, val) {
       if (!this.isInitializedPromiseResolved) {
         return;
       }
       this.file[name] = val;
       return this._writeToStorage();
     },
 
-    setMultiple: function ViewHistory_setMultiple(properties) {
+    setMultiple: function(properties) {
       if (!this.isInitializedPromiseResolved) {
         return;
       }
       for (var name in properties) {
         this.file[name] = properties[name];
       }
       return this._writeToStorage();
     },
 
-    get: function ViewHistory_get(name, defaultValue) {
+    get: function(name, defaultValue) {
       if (!this.isInitializedPromiseResolved) {
         return defaultValue;
       }
       return this.file[name] || defaultValue;
     }
   };
 
   return ViewHistory;
@@ -815,28 +815,28 @@ var PDFFindBar = (function PDFFindBarClo
     });
 
     this.caseSensitive.addEventListener('click', function() {
       self.dispatchEvent('casesensitivitychange');
     });
   }
 
   PDFFindBar.prototype = {
-    dispatchEvent: function PDFFindBar_dispatchEvent(type, findPrev) {
+    dispatchEvent: function(type, findPrev) {
       var event = document.createEvent('CustomEvent');
       event.initCustomEvent('find' + type, true, true, {
         query: this.findField.value,
         caseSensitive: this.caseSensitive.checked,
         highlightAll: this.highlightAll.checked,
         findPrevious: findPrev
       });
       return window.dispatchEvent(event);
     },
 
-    updateUIState: function PDFFindBar_updateUIState(state, previous) {
+    updateUIState: function(state, previous) {
       var notFound = false;
       var findMsg = '';
       var status = '';
 
       switch (state) {
         case FindStates.FIND_FOUND:
           break;
 
@@ -865,37 +865,37 @@ var PDFFindBar = (function PDFFindBarClo
       } else {
         this.findField.classList.remove('notFound');
       }
 
       this.findField.setAttribute('data-status', status);
       this.findMsg.textContent = findMsg;
     },
 
-    open: function PDFFindBar_open() {
+    open: function() {
       if (!this.opened) {
         this.opened = true;
         this.toggleButton.classList.add('toggled');
         this.bar.classList.remove('hidden');
       }
       this.findField.select();
       this.findField.focus();
     },
 
-    close: function PDFFindBar_close() {
+    close: function() {
       if (!this.opened) {
         return;
       }
       this.opened = false;
       this.toggleButton.classList.remove('toggled');
       this.bar.classList.add('hidden');
       this.findController.active = false;
     },
 
-    toggle: function PDFFindBar_toggle() {
+    toggle: function() {
       if (this.opened) {
         this.close();
       } else {
         this.open();
       }
     }
   };
   return PDFFindBar;
@@ -972,34 +972,34 @@ var PDFFindController = (function PDFFin
     this.handleEvent = this.handleEvent.bind(this);
 
     for (var i = 0, len = events.length; i < len; i++) {
       window.addEventListener(events[i], this.handleEvent);
     }
   }
 
   PDFFindController.prototype = {
-    setFindBar: function PDFFindController_setFindBar(findBar) {
+    setFindBar: function(findBar) {
       this.findBar = findBar;
     },
 
-    reset: function PDFFindController_reset() {
+    reset: function() {
       this.startedTextExtraction = false;
       this.extractTextPromises = [];
       this.active = false;
     },
 
-    normalize: function PDFFindController_normalize(text) {
+    normalize: function(text) {
       var self = this;
       return text.replace(this.normalizationRegex, function (ch) {
         return self.charactersToNormalize[ch];
       });
     },
 
-    calcFindMatch: function PDFFindController_calcFindMatch(pageIndex) {
+    calcFindMatch: function(pageIndex) {
       var pageContent = this.normalize(this.pageContents[pageIndex]);
       var query = this.normalize(this.state.query);
       var caseSensitive = this.state.caseSensitive;
       var queryLen = query.length;
 
       if (queryLen === 0) {
         return; // Do nothing: the matches should be wiped out already.
       }
@@ -1021,17 +1021,17 @@ var PDFFindController = (function PDFFin
       this.pageMatches[pageIndex] = matches;
       this.updatePage(pageIndex);
       if (this.resumePageIdx === pageIndex) {
         this.resumePageIdx = null;
         this.nextPageMatch();
       }
     },
 
-    extractText: function PDFFindController_extractText() {
+    extractText: function() {
       if (this.startedTextExtraction) {
         return;
       }
       this.startedTextExtraction = true;
 
       this.pageContents = [];
       var extractTextPromisesResolves = [];
       var numPages = this.pdfViewer.pagesCount;
@@ -1060,17 +1060,17 @@ var PDFFindController = (function PDFFin
               extractPageText(pageIndex + 1);
             }
           }
         );
       }
       extractPageText(0);
     },
 
-    handleEvent: function PDFFindController_handleEvent(e) {
+    handleEvent: function(e) {
       if (this.state === null || e.type !== 'findagain') {
         this.dirtyMatch = true;
       }
       this.state = e.detail;
       this.updateUIState(FindStates.FIND_PENDING);
 
       this.firstPagePromise.then(function() {
         this.extractText();
@@ -1080,31 +1080,31 @@ var PDFFindController = (function PDFFin
           // Only trigger the find action after 250ms of silence.
           this.findTimeout = setTimeout(this.nextMatch.bind(this), 250);
         } else {
           this.nextMatch();
         }
       }.bind(this));
     },
 
-    updatePage: function PDFFindController_updatePage(index) {
+    updatePage: function(index) {
       if (this.selected.pageIdx === index) {
         // If the page is selected, scroll the page into view, which triggers
         // rendering the page, which adds the textLayer. Once the textLayer is
         // build, it will scroll onto the selected match.
         this.pdfViewer.scrollPageIntoView(index + 1);
       }
 
       var page = this.pdfViewer.getPageView(index);
       if (page.textLayer) {
         page.textLayer.updateMatches();
       }
     },
 
-    nextMatch: function PDFFindController_nextMatch() {
+    nextMatch: function() {
       var previous = this.state.findPrevious;
       var currentPageIndex = this.pdfViewer.currentPageNumber - 1;
       var numPages = this.pdfViewer.pagesCount;
 
       this.active = true;
 
       if (this.dirtyMatch) {
         // Need to recalculate the matches, reset everything.
@@ -1163,17 +1163,17 @@ var PDFFindController = (function PDFFin
         // We went beyond the current page's matches, so we advance to
         // the next page.
         this.advanceOffsetPage(previous);
       }
       // Start searching through the page.
       this.nextPageMatch();
     },
 
-    matchesReady: function PDFFindController_matchesReady(matches) {
+    matchesReady: function(matches) {
       var offset = this.offset;
       var numMatches = matches.length;
       var previous = this.state.findPrevious;
 
       if (numMatches) {
         // There were matches for the page, so initialize the matchIdx.
         this.hadMatch = true;
         offset.matchIdx = (previous ? numMatches - 1 : 0);
@@ -1212,47 +1212,47 @@ var PDFFindController = (function PDFFin
           this.selected.pageIdx === pageIndex) {
         scrollIntoView(elements[beginIdx], {
           top: FIND_SCROLL_OFFSET_TOP,
           left: FIND_SCROLL_OFFSET_LEFT
         });
       }
     },
 
-    nextPageMatch: function PDFFindController_nextPageMatch() {
+    nextPageMatch: function() {
       if (this.resumePageIdx !== null) {
         console.error('There can only be one pending page.');
       }
       do {
         var pageIdx = this.offset.pageIdx;
         var matches = this.pageMatches[pageIdx];
         if (!matches) {
           // The matches don't exist yet for processing by "matchesReady",
           // so set a resume point for when they do exist.
           this.resumePageIdx = pageIdx;
           break;
         }
       } while (!this.matchesReady(matches));
     },
 
-    advanceOffsetPage: function PDFFindController_advanceOffsetPage(previous) {
+    advanceOffsetPage: function(previous) {
       var offset = this.offset;
       var numPages = this.extractTextPromises.length;
       offset.pageIdx = (previous ? offset.pageIdx - 1 : offset.pageIdx + 1);
       offset.matchIdx = null;
 
       this.pagesToSearch--;
       
       if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
         offset.pageIdx = (previous ? numPages - 1 : 0);
         offset.wrapped = true;
       }
     },
 
-    updateMatch: function PDFFindController_updateMatch(found) {
+    updateMatch: function(found) {
       var state = FindStates.FIND_NOTFOUND;
       var wrapped = this.offset.wrapped;
       this.offset.wrapped = false;
     
       if (found) {
         var previousPage = this.selected.pageIdx;
         this.selected.pageIdx = this.offset.pageIdx;
         this.selected.matchIdx = this.offset.matchIdx;
@@ -1264,17 +1264,17 @@ var PDFFindController = (function PDFFin
       }
     
       this.updateUIState(state, this.state.findPrevious);
       if (this.selected.pageIdx !== -1) {
         this.updatePage(this.selected.pageIdx);
       }
     },
 
-    updateUIState: function PDFFindController_updateUIState(state, previous) {
+    updateUIState: function(state, previous) {
       if (this.integratedFind) {
         FirefoxCom.request('updateFindControlState',
                            { result: state, findPrevious: previous });
         return;
       }
       if (this.findBar === null) {
         throw new Error('PDFFindController is not initialized with a ' +
                         'PDFFindBar instance.');
@@ -1290,17 +1290,17 @@ var PDFFindController = (function PDFFin
 var PDFHistory = {
   initialized: false,
   initialDestination: null,
 
   /**
    * @param {string} fingerprint
    * @param {IPDFLinkService} linkService
    */
-  initialize: function pdfHistoryInitialize(fingerprint, linkService) {
+  initialize: function(fingerprint, linkService) {
     this.initialized = true;
     this.reInitialized = false;
     this.allowHashChange = true;
     this.historyUnlocked = true;
 
     this.previousHash = window.location.hash.substring(1);
     this.currentBookmark = '';
     this.currentPage = 0;
@@ -1388,17 +1388,17 @@ var PDFHistory = {
     window.addEventListener('pageshow', function pdfHistoryPageShow(evt) {
       // If the entire viewer (including the PDF file) is cached in the browser,
       // we need to reattach the 'beforeunload' event listener since
       // the 'DOMContentLoaded' event is not fired on 'pageshow'.
       window.addEventListener('beforeunload', pdfHistoryBeforeUnload, false);
     }, false);
   },
 
-  _isStateObjectDefined: function pdfHistory_isStateObjectDefined(state) {
+  _isStateObjectDefined: function(state) {
     return (state && state.uid >= 0 &&
             state.fingerprint && this.fingerprint === state.fingerprint &&
             state.target && state.target.hash) ? true : false;
   },
 
   _pushOrReplaceState: function pdfHistory_pushOrReplaceState(stateObj,
                                                               replace) {
     if (replace) {
@@ -1422,17 +1422,17 @@ var PDFHistory = {
     // first 'hashchange' event and immediately reset allowHashChange.
     // If it is not reset, the user would not be able to change the hash.
 
     var temp = this.allowHashChange;
     this.allowHashChange = true;
     return temp;
   },
 
-  _updatePreviousBookmark: function pdfHistory_updatePreviousBookmark() {
+  _updatePreviousBookmark: function() {
     if (this.updatePreviousBookmark &&
         this.currentBookmark && this.currentPage) {
       this.previousBookmark = this.currentBookmark;
       this.previousPage = this.currentPage;
       this.updatePreviousBookmark = false;
     }
   },
 
@@ -1440,23 +1440,23 @@ var PDFHistory = {
                                                                   pageNum) {
     if (this.initialized) {
       this.currentBookmark = bookmark.substring(1);
       this.currentPage = pageNum | 0;
       this._updatePreviousBookmark();
     }
   },
 
-  updateNextHashParam: function pdfHistoryUpdateNextHashParam(param) {
+  updateNextHashParam: function(param) {
     if (this.initialized) {
       this.nextHashParam = param;
     }
   },
 
-  push: function pdfHistoryPush(params, isInitialBookmark) {
+  push: function(params, isInitialBookmark) {
     if (!(this.initialized && this.historyUnlocked)) {
       return;
     }
     if (params.dest && !params.hash) {
       params.hash = (this.current.hash && this.current.dest &&
                      this.current.dest === params.dest) ?
         this.current.hash :
         this.linkService.getDestinationHash(params.dest).split('#')[1];
@@ -1543,17 +1543,17 @@ var PDFHistory = {
     }
     var params = { hash: this.currentBookmark, page: this.currentPage };
     if (PresentationMode.active) {
       params.hash = null;
     }
     return params;
   },
 
-  _stateObj: function pdfHistory_stateObj(params) {
+  _stateObj: function(params) {
     return { fingerprint: this.fingerprint, uid: this.uid, target: params };
   },
 
   _pushToHistory: function pdfHistory_pushToHistory(params,
                                                     addPrevious, overwrite) {
     if (!this.initialized) {
       return;
     }
@@ -1570,17 +1570,17 @@ var PDFHistory = {
     }
     this._pushOrReplaceState(this._stateObj(params),
                              (overwrite || this.uid === 0));
     this.currentUid = this.uid++;
     this.current = params;
     this.updatePreviousBookmark = true;
   },
 
-  _goTo: function pdfHistory_goTo(state) {
+  _goTo: function(state) {
     if (!(this.initialized && this.historyUnlocked &&
           this._isStateObjectDefined(state))) {
       return;
     }
     if (!this.reInitialized && state.uid < this.currentUid) {
       var previousParams = this._getPreviousParams(true);
       if (previousParams) {
         this._pushToHistory(this.current, false);
@@ -1608,25 +1608,25 @@ var PDFHistory = {
     if (this.previousHash !== currentHash) {
       this.allowHashChange = false;
     }
     this.previousHash = currentHash;
 
     this.historyUnlocked = true;
   },
 
-  back: function pdfHistoryBack() {
+  back: function() {
     this.go(-1);
   },
 
-  forward: function pdfHistoryForward() {
+  forward: function() {
     this.go(1);
   },
 
-  go: function pdfHistoryGo(direction) {
+  go: function(direction) {
     if (this.initialized && this.historyUnlocked) {
       var state = window.history.state;
       if (direction === -1 && state && state.uid > 0) {
         window.history.back();
       } else if (direction === 1 && state && state.uid < (this.uid - 1)) {
         window.history.forward();
       }
     }
@@ -1634,17 +1634,17 @@ var PDFHistory = {
 };
 
 
 var SecondaryToolbar = {
   opened: false,
   previousContainerHeight: null,
   newContainerHeight: null,
 
-  initialize: function secondaryToolbarInitialize(options) {
+  initialize: function(options) {
     this.toolbar = options.toolbar;
     this.presentationMode = options.presentationMode;
     this.documentProperties = options.documentProperties;
     this.buttonContainer = this.toolbar.firstElementChild;
 
     // Define the toolbar buttons.
     this.toggleButton = options.toggleButton;
     this.presentationModeButton = options.presentationModeButton;
@@ -1682,100 +1682,100 @@ var SecondaryToolbar = {
       var element = elements[item].element;
       if (element) {
         element.addEventListener('click', elements[item].handler.bind(this));
       }
     }
   },
 
   // Event handling functions.
-  presentationModeClick: function secondaryToolbarPresentationModeClick(evt) {
+  presentationModeClick: function(evt) {
     this.presentationMode.request();
     this.close();
   },
 
-  openFileClick: function secondaryToolbarOpenFileClick(evt) {
+  openFileClick: function(evt) {
     document.getElementById('fileInput').click();
     this.close();
   },
 
-  printClick: function secondaryToolbarPrintClick(evt) {
+  printClick: function(evt) {
     window.print();
     this.close();
   },
 
-  downloadClick: function secondaryToolbarDownloadClick(evt) {
+  downloadClick: function(evt) {
     PDFViewerApplication.download();
     this.close();
   },
 
-  viewBookmarkClick: function secondaryToolbarViewBookmarkClick(evt) {
+  viewBookmarkClick: function(evt) {
     this.close();
   },
 
-  firstPageClick: function secondaryToolbarFirstPageClick(evt) {
+  firstPageClick: function(evt) {
     PDFViewerApplication.page = 1;
     this.close();
   },
 
-  lastPageClick: function secondaryToolbarLastPageClick(evt) {
+  lastPageClick: function(evt) {
     if (PDFViewerApplication.pdfDocument) {
       PDFViewerApplication.page = PDFViewerApplication.pagesCount;
     }
     this.close();
   },
 
-  pageRotateCwClick: function secondaryToolbarPageRotateCwClick(evt) {
+  pageRotateCwClick: function(evt) {
     PDFViewerApplication.rotatePages(90);
   },
 
-  pageRotateCcwClick: function secondaryToolbarPageRotateCcwClick(evt) {
+  pageRotateCcwClick: function(evt) {
     PDFViewerApplication.rotatePages(-90);
   },
 
-  documentPropertiesClick: function secondaryToolbarDocumentPropsClick(evt) {
+  documentPropertiesClick: function(evt) {
     this.documentProperties.open();
     this.close();
   },
 
   // Misc. functions for interacting with the toolbar.
-  setMaxHeight: function secondaryToolbarSetMaxHeight(container) {
+  setMaxHeight: function(container) {
     if (!container || !this.buttonContainer) {
       return;
     }
     this.newContainerHeight = container.clientHeight;
     if (this.previousContainerHeight === this.newContainerHeight) {
       return;
     }
     this.buttonContainer.setAttribute('style',
       'max-height: ' + (this.newContainerHeight - SCROLLBAR_PADDING) + 'px;');
     this.previousContainerHeight = this.newContainerHeight;
   },
 
-  open: function secondaryToolbarOpen() {
+  open: function() {
     if (this.opened) {
       return;
     }
     this.opened = true;
     this.toggleButton.classList.add('toggled');
     this.toolbar.classList.remove('hidden');
   },
 
-  close: function secondaryToolbarClose(target) {
+  close: function(target) {
     if (!this.opened) {
       return;
     } else if (target && !this.toolbar.contains(target)) {
       return;
     }
     this.opened = false;
     this.toolbar.classList.add('hidden');
     this.toggleButton.classList.remove('toggled');
   },
 
-  toggle: function secondaryToolbarToggle() {
+  toggle: function() {
     if (this.opened) {
       this.close();
     } else {
       this.open();
     }
   }
 };
 
@@ -1784,17 +1784,17 @@ var DELAY_BEFORE_HIDING_CONTROLS = 3000;
 var SELECTOR = 'presentationControls';
 var DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1000; // in ms
 
 var PresentationMode = {
   active: false,
   args: null,
   contextMenuOpen: false,
 
-  initialize: function presentationModeInitialize(options) {
+  initialize: function(options) {
     this.container = options.container;
     this.secondaryToolbar = options.secondaryToolbar;
 
     this.viewer = this.container.firstElementChild;
 
     this.firstPage = options.firstPage;
     this.lastPage = options.lastPage;
     this.pageRotateCw = options.pageRotateCw;
@@ -1829,34 +1829,34 @@ var PresentationMode = {
   /**
    * Initialize a timeout that is used to specify switchInProgress when the
    * browser transitions to fullscreen mode. Since resize events are triggered
    * multiple times during the switch to fullscreen mode, this is necessary in
    * order to prevent the page from being scrolled partially, or completely,
    * out of view when Presentation Mode is enabled.
    * Note: This is only an issue at certain zoom levels, e.g. 'page-width'.
    */
-  _setSwitchInProgress: function presentationMode_setSwitchInProgress() {
+  _setSwitchInProgress: function() {
     if (this.switchInProgress) {
       clearTimeout(this.switchInProgress);
     }
     this.switchInProgress = setTimeout(function switchInProgressTimeout() {
       delete this.switchInProgress;
       this._notifyStateChange();
     }.bind(this), DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);
   },
 
-  _resetSwitchInProgress: function presentationMode_resetSwitchInProgress() {
+  _resetSwitchInProgress: function() {
     if (this.switchInProgress) {
       clearTimeout(this.switchInProgress);
       delete this.switchInProgress;
     }
   },
 
-  request: function presentationModeRequest() {
+  request: function() {
     if (!PDFViewerApplication.supportsFullscreen || this.isFullscreen ||
         !this.viewer.hasChildNodes()) {
       return false;
     }
     this._setSwitchInProgress();
     this._notifyStateChange();
 
     if (this.container.requestFullscreen) {
@@ -1874,26 +1874,26 @@ var PresentationMode = {
     this.args = {
       page: PDFViewerApplication.page,
       previousScale: PDFViewerApplication.currentScaleValue
     };
 
     return true;
   },
 
-  _notifyStateChange: function presentationModeNotifyStateChange() {
+  _notifyStateChange: function() {
     var event = document.createEvent('CustomEvent');
     event.initCustomEvent('presentationmodechanged', true, true, {
       active: PresentationMode.active,
       switchInProgress: !!PresentationMode.switchInProgress
     });
     window.dispatchEvent(event);
   },
 
-  enter: function presentationModeEnter() {
+  enter: function() {
     this.active = true;
     this._resetSwitchInProgress();
     this._notifyStateChange();
 
     // Ensure that the correct page is scrolled into view when entering
     // Presentation Mode, by waiting until fullscreen mode in enabled.
     // Note: This is only necessary in non-Mozilla browsers.
     setTimeout(function enterPresentationModeTimeout() {
@@ -1911,17 +1911,17 @@ var PresentationMode = {
     this.container.setAttribute('contextmenu', 'viewerContextMenu');
 
     // Text selection is disabled in Presentation Mode, thus it's not possible
     // for the user to deselect text that is selected (e.g. with "Select all")
     // when entering Presentation Mode, hence we remove any active selection.
     window.getSelection().removeAllRanges();
   },
 
-  exit: function presentationModeExit() {
+  exit: function() {
     var page = PDFViewerApplication.page;
 
     // Ensure that the correct page is scrolled into view when exiting
     // Presentation Mode, by waiting until fullscreen mode is disabled.
     // Note: This is only necessary in non-Mozilla browsers.
     setTimeout(function exitPresentationModeTimeout() {
       this.active = false;
       this._notifyStateChange();
@@ -1941,42 +1941,42 @@ var PresentationMode = {
     this.container.removeAttribute('contextmenu');
     this.contextMenuOpen = false;
 
     // Ensure that the thumbnail of the current page is visible
     // when exiting presentation mode.
     scrollIntoView(document.getElementById('thumbnailContainer' + page));
   },
 
-  showControls: function presentationModeShowControls() {
+  showControls: function() {
     if (this.controlsTimeout) {
       clearTimeout(this.controlsTimeout);
     } else {
       this.container.classList.add(SELECTOR);
     }
     this.controlsTimeout = setTimeout(function hideControlsTimeout() {
       this.container.classList.remove(SELECTOR);
       delete this.controlsTimeout;
     }.bind(this), DELAY_BEFORE_HIDING_CONTROLS);
   },
 
-  hideControls: function presentationModeHideControls() {
+  hideControls: function() {
     if (!this.controlsTimeout) {
       return;
     }
     this.container.classList.remove(SELECTOR);
     clearTimeout(this.controlsTimeout);
     delete this.controlsTimeout;
   },
 
-  mouseMove: function presentationModeMouseMove(evt) {
+  mouseMove: function(evt) {
     PresentationMode.showControls();
   },
 
-  mouseDown: function presentationModeMouseDown(evt) {
+  mouseDown: function(evt) {
     var self = PresentationMode;
     if (self.contextMenuOpen) {
       self.contextMenuOpen = false;
       evt.preventDefault();
       return;
     }
 
     if (evt.button === 0) {
@@ -1987,17 +1987,17 @@ var PresentationMode = {
       if (!isInternalLink) {
         // Unless an internal link was clicked, advance one page.
         evt.preventDefault();
         PDFViewerApplication.page += (evt.shiftKey ? -1 : 1);
       }
     }
   },
 
-  contextMenu: function presentationModeContextMenu(evt) {
+  contextMenu: function(evt) {
     PresentationMode.contextMenuOpen = true;
   }
 };
 
 (function presentationModeClosure() {
   function presentationModeChange(e) {
     if (PresentationMode.isFullscreen) {
       PresentationMode.enter();
@@ -2067,69 +2067,69 @@ var GrabToPan = (function GrabToPanClosu
     /**
      * Class name of element which can be grabbed
      */
     CSS_CLASS_GRAB: 'grab-to-pan-grab',
 
     /**
      * Bind a mousedown event to the element to enable grab-detection.
      */
-    activate: function GrabToPan_activate() {
+    activate: function() {
       if (!this.active) {
         this.active = true;
         this.element.addEventListener('mousedown', this._onmousedown, true);
         this.element.classList.add(this.CSS_CLASS_GRAB);
         if (this.onActiveChanged) {
           this.onActiveChanged(true);
         }
       }
     },
 
     /**
      * Removes all events. Any pending pan session is immediately stopped.
      */
-    deactivate: function GrabToPan_deactivate() {
+    deactivate: function() {
       if (this.active) {
         this.active = false;
         this.element.removeEventListener('mousedown', this._onmousedown, true);
         this._endPan();
         this.element.classList.remove(this.CSS_CLASS_GRAB);
         if (this.onActiveChanged) {
           this.onActiveChanged(false);
         }
       }
     },
 
-    toggle: function GrabToPan_toggle() {
+    toggle: function() {
       if (this.active) {
         this.deactivate();
       } else {
         this.activate();
       }
     },
 
     /**
      * Whether to not pan if the target element is clicked.
      * Override this method to change the default behaviour.
      *
      * @param node {Element} The target of the event
      * @return {boolean} Whether to not react to the click event.
      */
-    ignoreTarget: function GrabToPan_ignoreTarget(node) {
+    ignoreTarget: function(node) {
       // Use matchesSelector to check whether the clicked element
       // is (a child of) an input element / link
       return node[matchesSelector](
         'a[href], a[href] *, input, textarea, button, button *, select, option'
       );
     },
 
     /**
      * @private
      */
-    _onmousedown: function GrabToPan__onmousedown(event) {
+    _onmousedown: function(event) {
       if (event.button !== 0 || this.ignoreTarget(event.target)) {
         return;
       }
       if (event.originalTarget) {
         try {
           /* jshint expr:true */
           event.originalTarget.tagName;
         } catch (e) {
@@ -2156,17 +2156,17 @@ var GrabToPan = (function GrabToPanClosu
       if (focusedElement && !focusedElement.contains(event.target)) {
         focusedElement.blur();
       }
     },
 
     /**
      * @private
      */
-    _onmousemove: function GrabToPan__onmousemove(event) {
+    _onmousemove: function(event) {
       this.element.removeEventListener('scroll', this._endPan, true);
       if (isLeftMouseReleased(event)) {
         this._endPan();
         return;
       }
       var xDiff = event.clientX - this.clientXStart;
       var yDiff = event.clientY - this.clientYStart;
       this.element.scrollTop = this.scrollTopStart - yDiff;
@@ -2174,17 +2174,17 @@ var GrabToPan = (function GrabToPanClosu
       if (!this.overlay.parentNode) {
         document.body.appendChild(this.overlay);
       }
     },
 
     /**
      * @private
      */
-    _endPan: function GrabToPan__endPan() {
+    _endPan: function() {
       this.element.removeEventListener('scroll', this._endPan, true);
       this.document.removeEventListener('mousemove', this._onmousemove, true);
       this.document.removeEventListener('mouseup', this._endPan, true);
       if (this.overlay.parentNode) {
         this.overlay.parentNode.removeChild(this.overlay);
       }
     }
   };
@@ -2232,17 +2232,17 @@ var GrabToPan = (function GrabToPanClosu
       return event.which === 0;
     }
   }
 
   return GrabToPan;
 })();
 
 var HandTool = {
-  initialize: function handToolInitialize(options) {
+  initialize: function(options) {
     var toggleHandTool = options.toggleHandTool;
     this.handTool = new GrabToPan({
       element: options.container,
       onActiveChanged: function(isActive) {
         if (!toggleHandTool) {
           return;
         }
         if (isActive) {
@@ -2266,29 +2266,29 @@ var HandTool = {
           if (value) {
             this.handTool.activate();
           }
         }.bind(this), function rejected(reason) {});
       }.bind(this));
     }
   },
 
-  toggle: function handToolToggle() {
+  toggle: function() {
     this.handTool.toggle();
     SecondaryToolbar.close();
   },
 
-  enterPresentationMode: function handToolEnterPresentationMode() {
+  enterPresentationMode: function() {
     if (this.handTool.active) {
       this.wasActive = true;
       this.handTool.deactivate();
     }
   },
 
-  exitPresentationMode: function handToolExitPresentationMode() {
+  exitPresentationMode: function() {
     if (this.wasActive) {
       this.wasActive = null;
       this.handTool.activate();
     }
   }
 };
 
 
@@ -2327,17 +2327,17 @@ var OverlayManager = {
     }.bind(this));
   },
 
   /**
    * @param {string} name The name of the overlay that is unregistered.
    * @returns {Promise} A promise that is resolved when the overlay has been
    *                    unregistered.
    */
-  unregister: function overlayManagerUnregister(name) {
+  unregister: function(name) {
     return new Promise(function (resolve) {
       if (!this.overlays[name]) {
         throw new Error('The overlay does not exist.');
       } else if (this.active === name) {
         throw new Error('The overlay cannot be removed while it is active.');
       }
       delete this.overlays[name];
 
@@ -2345,17 +2345,17 @@ var OverlayManager = {
     }.bind(this));
   },
 
   /**
    * @param {string} name The name of the overlay that should be opened.
    * @returns {Promise} A promise that is resolved when the overlay has been
    *                    opened.
    */
-  open: function overlayManagerOpen(name) {
+  open: function(name) {
     return new Promise(function (resolve) {
       if (!this.overlays[name]) {
         throw new Error('The overlay does not exist.');
       } else if (this.active) {
         if (this.overlays[name].canForceClose) {
           this._closeThroughCaller();
         } else if (this.active === name) {
           throw new Error('The overlay is already active.');
@@ -2372,17 +2372,17 @@ var OverlayManager = {
     }.bind(this));
   },
 
   /**
    * @param {string} name The name of the overlay that should be closed.
    * @returns {Promise} A promise that is resolved when the overlay has been
    *                    closed.
    */
-  close: function overlayManagerClose(name) {
+  close: function(name) {
     return new Promise(function (resolve) {
       if (!this.overlays[name]) {
         throw new Error('The overlay does not exist.');
       } else if (!this.active) {
         throw new Error('The overlay is currently not active.');
       } else if (this.active !== name) {
         throw new Error('Another overlay is currently active.');
       }
@@ -2393,28 +2393,28 @@ var OverlayManager = {
       window.removeEventListener('keydown', this._keyDown);
       resolve();
     }.bind(this));
   },
 
   /**
    * @private
    */
-  _keyDown: function overlayManager_keyDown(evt) {
+  _keyDown: function(evt) {
     var self = OverlayManager;
     if (self.active && evt.keyCode === 27) { // Esc key.
       self._closeThroughCaller();
       evt.preventDefault();
     }
   },
 
   /**
    * @private
    */
-  _closeThroughCaller: function overlayManager_closeThroughCaller() {
+  _closeThroughCaller: function() {
     if (this.overlays[this.active].callerCloseMethod) {
       this.overlays[this.active].callerCloseMethod();
     }
     if (this.active) {
       this.close(this.active);
     }
   }
 };
@@ -2424,17 +2424,17 @@ var PasswordPrompt = {
   overlayName: null,
   updatePassword: null,
   reason: null,
   passwordField: null,
   passwordText: null,
   passwordSubmit: null,
   passwordCancel: null,
 
-  initialize: function secondaryToolbarInitialize(options) {
+  initialize: function(options) {
     this.overlayName = options.overlayName;
     this.passwordField = options.passwordField;
     this.passwordText = options.passwordText;
     this.passwordSubmit = options.passwordSubmit;
     this.passwordCancel = options.passwordCancel;
 
     // Attach the event listeners.
     this.passwordSubmit.addEventListener('click',
@@ -2446,39 +2446,39 @@ var PasswordPrompt = {
       if (e.keyCode === 13) { // Enter key
         this.verifyPassword();
       }
     }.bind(this));
 
     OverlayManager.register(this.overlayName, this.close.bind(this), true);
   },
 
-  open: function passwordPromptOpen() {
+  open: function() {
     OverlayManager.open(this.overlayName).then(function () {
       this.passwordField.focus();
 
       var promptString = mozL10n.get('password_label', null,
         'Enter the password to open this PDF file.');
 
       if (this.reason === PDFJS.PasswordResponses.INCORRECT_PASSWORD) {
         promptString = mozL10n.get('password_invalid', null,
           'Invalid password. Please try again.');
       }
 
       this.passwordText.textContent = promptString;
     }.bind(this));
   },
 
-  close: function passwordPromptClose() {
+  close: function() {
     OverlayManager.close(this.overlayName).then(function () {
       this.passwordField.value = '';
     }.bind(this));
   },
 
-  verifyPassword: function passwordPromptVerifyPassword() {
+  verifyPassword: function() {
     var password = this.passwordField.value;
     if (password && password.length > 0) {
       this.close();
       return this.updatePassword(password);
     }
   }
 };
 
@@ -2498,17 +2498,17 @@ var DocumentProperties = {
   modificationDateField: null,
   creatorField: null,
   producerField: null,
   versionField: null,
   pageCountField: null,
   url: null,
   pdfDocument: null,
 
-  initialize: function documentPropertiesInitialize(options) {
+  initialize: function(options) {
     this.overlayName = options.overlayName;
 
     // Set the document property fields.
     this.fileNameField = options.fileNameField;
     this.fileSizeField = options.fileSizeField;
     this.titleField = options.titleField;
     this.authorField = options.authorField;
     this.subjectField = options.subjectField;
@@ -2527,17 +2527,17 @@ var DocumentProperties = {
 
     this.dataAvailablePromise = new Promise(function (resolve) {
       this.resolveDataAvailable = resolve;
     }.bind(this));
 
     OverlayManager.register(this.overlayName, this.close.bind(this));
   },
 
-  getProperties: function documentPropertiesGetProperties() {
+  getProperties: function() {
     if (!OverlayManager.active) {
       // If the dialog was closed before dataAvailablePromise was resolved,
       // don't bother updating the properties.
       return;
     }
     // Get the file size (if it hasn't already been set).
     this.pdfDocument.getDownloadInfo().then(function(data) {
       if (data.length === this.rawFileSize) {
@@ -2570,57 +2570,57 @@ var DocumentProperties = {
       // Show the properties in the dialog.
       for (var item in fields) {
         var element = fields[item];
         this.updateUI(element.field, element.content);
       }
     }.bind(this));
   },
 
-  updateUI: function documentPropertiesUpdateUI(field, content) {
+  updateUI: function(field, content) {
     if (field && content !== undefined && content !== '') {
       field.textContent = content;
     }
   },
 
-  setFileSize: function documentPropertiesSetFileSize(fileSize) {
+  setFileSize: function(fileSize) {
     if (fileSize > 0) {
       this.rawFileSize = fileSize;
     }
   },
 
-  parseFileSize: function documentPropertiesParseFileSize() {
+  parseFileSize: function() {
     var fileSize = this.rawFileSize, kb = fileSize / 1024;
     if (!kb) {
       return;
     } else if (kb < 1024) {
       return mozL10n.get('document_properties_kb', {
         size_kb: (+kb.toPrecision(3)).toLocaleString(),
         size_b: fileSize.toLocaleString()
       }, '{{size_kb}} KB ({{size_b}} bytes)');
     } else {
       return mozL10n.get('document_properties_mb', {
         size_mb: (+(kb / 1024).toPrecision(3)).toLocaleString(),
         size_b: fileSize.toLocaleString()
       }, '{{size_mb}} MB ({{size_b}} bytes)');
     }
   },
 
-  open: function documentPropertiesOpen() {
+  open: function() {
     Promise.all([OverlayManager.open(this.overlayName),
                  this.dataAvailablePromise]).then(function () {
       this.getProperties();
     }.bind(this));
   },
 
-  close: function documentPropertiesClose() {
+  close: function() {
     OverlayManager.close(this.overlayName);
   },
 
-  parseDate: function documentPropertiesParseDate(inputDate) {
+  parseDate: function(inputDate) {
     // This is implemented according to the PDF specification (see
     // http://www.gnupdf.org/Date for an overview), but note that 
     // Adobe Reader doesn't handle changing the date to universal time
     // and doesn't use the user's time zone (they're effectively ignoring
     // the HH' and mm' parts of the date string).
     var dateToParse = inputDate;
     if (dateToParse === undefined) {
       return '';
@@ -2703,33 +2703,33 @@ var PDFRenderingQueue = (function PDFRen
     this.printing = false;
     this.isThumbnailViewEnabled = false;
   }
 
   PDFRenderingQueue.prototype = /** @lends PDFRenderingQueue.prototype */ {
     /**
      * @param {PDFViewer} pdfViewer
      */
-    setViewer: function PDFRenderingQueue_setViewer(pdfViewer) {
+    setViewer: function(pdfViewer) {
       this.pdfViewer = pdfViewer;
     },
 
     /**
      * @param {PDFThumbnailViewer} pdfThumbnailViewer
      */
     setThumbnailViewer:
         function PDFRenderingQueue_setThumbnailViewer(pdfThumbnailViewer) {
       this.pdfThumbnailViewer = pdfThumbnailViewer;
     },
 
     /**
      * @param {IRenderableView} view
      * @returns {boolean}
      */
-    isHighestPriority: function PDFRenderingQueue_isHighestPriority(view) {
+    isHighestPriority: function(view) {
       return this.highestPriorityPage === view.renderingId;
     },
 
     renderHighestPriority: function
         PDFRenderingQueue_renderHighestPriority(currentlyVisiblePages) {
       if (this.idleTimeout) {
         clearTimeout(this.idleTimeout);
         this.idleTimeout = null;
@@ -2795,27 +2795,27 @@ var PDFRenderingQueue = (function PDFRen
       // Everything that needs to be rendered has been.
       return null;
     },
 
     /**
      * @param {IRenderableView} view
      * @returns {boolean}
      */
-    isViewFinished: function PDFRenderingQueue_isViewFinished(view) {
+    isViewFinished: function(view) {
       return view.renderingState === RenderingStates.FINISHED;
     },
 
     /**
      * Render a page or thumbnail view. This calls the appropriate function
      * based on the views state. If the view is already rendered it will return
      * false.
      * @param {IRenderableView} view
      */
-    renderView: function PDFRenderingQueue_renderView(view) {
+    renderView: function(view) {
       var state = view.renderingState;
       switch (state) {
         case RenderingStates.FINISHED:
           return false;
         case RenderingStates.PAUSED:
           this.highestPriorityPage = view.renderingId;
           view.resume();
           break;
@@ -2901,35 +2901,35 @@ var PDFPageView = (function PDFPageViewC
     div.style.height = Math.floor(this.viewport.height) + 'px';
     this.el = div; // TODO replace 'el' property usage
     this.div = div;
 
     container.appendChild(div);
   }
 
   PDFPageView.prototype = {
-    setPdfPage: function PDFPageView_setPdfPage(pdfPage) {
+    setPdfPage: function(pdfPage) {
       this.pdfPage = pdfPage;
       this.pdfPageRotate = pdfPage.rotate;
       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
       this.viewport = pdfPage.getViewport(this.scale * CSS_UNITS,
                                           totalRotation);
       this.stats = pdfPage.stats;
       this.reset();
     },
 
-    destroy: function PDFPageView_destroy() {
+    destroy: function() {
       this.zoomLayer = null;
       this.reset();
       if (this.pdfPage) {
         this.pdfPage.destroy();
       }
     },
 
-    reset: function PDFPageView_reset(keepAnnotations) {
+    reset: function(keepAnnotations) {
       if (this.renderTask) {
         this.renderTask.cancel();
       }
       this.resume = null;
       this.renderingState = RenderingStates.INITIAL;
 
       var div = this.div;
       div.style.width = Math.floor(this.viewport.width) + 'px';
@@ -2966,17 +2966,17 @@ var PDFPageView = (function PDFPageViewC
         delete this.canvas;
       }
 
       this.loadingIconDiv = document.createElement('div');
       this.loadingIconDiv.className = 'loadingIcon';
       div.appendChild(this.loadingIconDiv);
     },
 
-    update: function PDFPageView_update(scale, rotation) {
+    update: function(scale, rotation) {
       this.scale = scale || this.scale;
 
       if (typeof rotation !== 'undefined') {
         this.rotation = rotation;
       }
 
       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
       this.viewport = this.viewport.clone({
@@ -3010,23 +3010,23 @@ var PDFPageView = (function PDFPageViewC
         this.cssTransform(this.zoomLayer.firstChild);
       }
       this.reset(true);
     },
 
     /**
      * Called when moved in the parent's container.
      */
-    updatePosition: function PDFPageView_updatePosition() {
+    updatePosition: function() {
       if (this.textLayer) {
         this.textLayer.render(TEXT_LAYER_RENDER_DELAY);
       }
     },
 
-    cssTransform: function PDFPageView_transform(canvas, redrawAnnotations) {
+    cssTransform: function(canvas, redrawAnnotations) {
       // Scale canvas, canvas wrapper, and page container.
       var width = this.viewport.width;
       var height = this.viewport.height;
       var div = this.div;
       canvas.style.width = canvas.parentNode.style.width = div.style.width =
         Math.floor(width) + 'px';
       canvas.style.height = canvas.parentNode.style.height = div.style.height =
         Math.floor(height) + 'px';
@@ -3093,21 +3093,21 @@ var PDFPageView = (function PDFPageViewC
     get width() {
       return this.viewport.width;
     },
 
     get height() {
       return this.viewport.height;
     },
 
-    getPagePoint: function PDFPageView_getPagePoint(x, y) {
+    getPagePoint: function(x, y) {
       return this.viewport.convertToPdfPoint(x, y);
     },
 
-    draw: function PDFPageView_draw() {
+    draw: function() {
       if (this.renderingState !== RenderingStates.INITIAL) {
         console.error('Must be in new state before drawing');
       }
 
       this.renderingState = RenderingStates.RUNNING;
 
       var pdfPage = this.pdfPage;
       var viewport = this.viewport;
@@ -3291,17 +3291,17 @@ var PDFPageView = (function PDFPageViewC
       div.setAttribute('data-loaded', true);
 
       if (self.onBeforeDraw) {
         self.onBeforeDraw();
       }
       return promise;
     },
 
-    beforePrint: function PDFPageView_beforePrint() {
+    beforePrint: function() {
       var pdfPage = this.pdfPage;
 
       var viewport = pdfPage.getViewport(1);
       // Use the same hack we use for high dpi displays for printing to get
       // better output until bug 811002 is fixed in FF.
       var PRINT_OUTPUT_SCALE = 2;
       var canvas = document.createElement('canvas');
       canvas.width = Math.floor(viewport.width) * PRINT_OUTPUT_SCALE;
@@ -3388,27 +3388,27 @@ var TextLayerBuilder = (function TextLay
     this.pageNumber = this.pageIdx + 1;
     this.matches = [];
     this.viewport = options.viewport;
     this.textDivs = [];
     this.findController = options.findController || null;
   }
 
   TextLayerBuilder.prototype = {
-    _finishRendering: function TextLayerBuilder_finishRendering() {
+    _finishRendering: function() {
       this.renderingDone = true;
 
       var event = document.createEvent('CustomEvent');
       event.initCustomEvent('textlayerrendered', true, true, {
         pageNumber: this.pageNumber
       });
       this.textLayerDiv.dispatchEvent(event);
     },
 
-    renderLayer: function TextLayerBuilder_renderLayer() {
+    renderLayer: function() {
       var textLayerFrag = document.createDocumentFragment();
       var textDivs = this.textDivs;
       var textDivsLength = textDivs.length;
       var canvas = document.createElement('canvas');
       var ctx = canvas.getContext('2d');
 
       // No point in rendering many divs as it would make the browser
       // unusable even after the divs are rendered.
@@ -3461,17 +3461,17 @@ var TextLayerBuilder = (function TextLay
       this.updateMatches();
     },
 
     /**
      * Renders the text layer.
      * @param {number} timeout (optional) if specified, the rendering waits
      *   for specified amount of ms.
      */
-    render: function TextLayerBuilder_render(timeout) {
+    render: function(timeout) {
       if (!this.divContentDone || this.renderingDone) {
         return;
       }
 
       if (this.renderTimer) {
         clearTimeout(this.renderTimer);
         this.renderTimer = null;
       }
@@ -3482,17 +3482,17 @@ var TextLayerBuilder = (function TextLay
         var self = this;
         this.renderTimer = setTimeout(function() {
           self.renderLayer();
           self.renderTimer = null;
         }, timeout);
       }
     },
 
-    appendText: function TextLayerBuilder_appendText(geom, styles) {
+    appendText: function(geom, styles) {
       var style = styles[geom.fontName];
       var textDiv = document.createElement('div');
       this.textDivs.push(textDiv);
       if (isAllWhitespace(geom.str)) {
         textDiv.dataset.isWhitespace = true;
         return;
       }
       var tx = PDFJS.Util.transform(this.viewport.transform, geom.transform);
@@ -3540,27 +3540,27 @@ var TextLayerBuilder = (function TextLay
         if (style.vertical) {
           textDiv.dataset.canvasWidth = geom.height * this.viewport.scale;
         } else {
           textDiv.dataset.canvasWidth = geom.width * this.viewport.scale;
         }
       }
     },
 
-    setTextContent: function TextLayerBuilder_setTextContent(textContent) {
+    setTextContent: function(textContent) {
       this.textContent = textContent;
 
       var textItems = textContent.items;
       for (var i = 0, len = textItems.length; i < len; i++) {
         this.appendText(textItems[i], textContent.styles);
       }
       this.divContentDone = true;
     },
 
-    convertMatches: function TextLayerBuilder_convertMatches(matches) {
+    convertMatches: function(matches) {
       var i = 0;
       var iIndex = 0;
       var bidiTexts = this.textContent.items;
       var end = bidiTexts.length - 1;
       var queryLen = (this.findController === null ?
                       0 : this.findController.state.query.length);
       var ret = [];
 
@@ -3600,17 +3600,17 @@ var TextLayerBuilder = (function TextLay
           offset: matchIdx - iIndex
         };
         ret.push(match);
       }
 
       return ret;
     },
 
-    renderMatches: function TextLayerBuilder_renderMatches(matches) {
+    renderMatches: function(matches) {
       // Early exit if there is nothing to render.
       if (matches.length === 0) {
         return;
       }
 
       var bidiTexts = this.textContent.items;
       var textDivs = this.textDivs;
       var prevEnd = null;
@@ -3693,17 +3693,17 @@ var TextLayerBuilder = (function TextLay
         prevEnd = end;
       }
 
       if (prevEnd) {
         appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
       }
     },
 
-    updateMatches: function TextLayerBuilder_updateMatches() {
+    updateMatches: function() {
       // Only show matches when all rendering is done.
       if (!this.renderingDone) {
         return;
       }
 
       // Clear all matches.
       var matches = this.matches;
       var textDivs = this.textDivs;
@@ -4244,17 +4244,17 @@ var PDFViewer = (function pdfViewer() {
       event.initUIEvent('scalechange', true, true, window, 0);
       event.scale = newScale;
       if (preset) {
         event.presetValue = newValue;
       }
       this.container.dispatchEvent(event);
     },
 
-    _setScale: function pdfViewer_setScale(value, noScroll) {
+    _setScale: function(value, noScroll) {
       if (value === 'custom') {
         return;
       }
       var scale = parseFloat(value);
 
       if (scale > 0) {
         this._setScaleUpdatePages(scale, value, noScroll, false);
       } else {
@@ -4744,25 +4744,25 @@ var PDFThumbnailView = (function PDFThum
     this.ring = ring;
 
     div.appendChild(ring);
     anchor.appendChild(div);
     container.appendChild(anchor);
   }
 
   PDFThumbnailView.prototype = {
-    setPdfPage: function PDFThumbnailView_setPdfPage(pdfPage) {
+    setPdfPage: function(pdfPage) {
       this.pdfPage = pdfPage;
       this.pdfPageRotate = pdfPage.rotate;
       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
       this.viewport = pdfPage.getViewport(1, totalRotation);
       this.reset();
     },
 
-    reset: function PDFThumbnailView_reset() {
+    reset: function() {
       if (this.renderTask) {
         this.renderTask.cancel();
       }
       this.hasImage = false;
       this.resume = null;
       this.renderingState = RenderingStates.INITIAL;
 
       this.pageWidth = this.viewport.width;
@@ -4786,49 +4786,49 @@ var PDFThumbnailView = (function PDFThum
         // Zeroing the width and height causes Firefox to release graphics
         // resources immediately, which can greatly reduce memory consumption.
         this.canvas.width = 0;
         this.canvas.height = 0;
         delete this.canvas;
       }
     },
 
-    update: function PDFThumbnailView_update(rotation) {
+    update: function(rotation) {
       if (typeof rotation !== 'undefined') {
         this.rotation = rotation;
       }
       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
       this.viewport = this.viewport.clone({
         scale: 1,
         rotation: totalRotation
       });
       this.reset();
     },
 
     /**
      * @private
      */
-    _getPageDrawContext: function PDFThumbnailView_getPageDrawContext() {
+    _getPageDrawContext: function() {
       var canvas = document.createElement('canvas');
       canvas.id = this.renderingId;
 
       canvas.width = this.canvasWidth;
       canvas.height = this.canvasHeight;
       canvas.className = 'thumbnailImage';
       canvas.setAttribute('aria-label', mozL10n.get('thumb_page_canvas',
         {page: this.id}, 'Thumbnail of Page {{page}}'));
 
       this.canvas = canvas;
       this.div.setAttribute('data-loaded', true);
       this.ring.appendChild(canvas);
 
       return canvas.getContext('2d');
     },
 
-    draw: function PDFThumbnailView_draw() {
+    draw: function() {
       if (this.renderingState !== RenderingStates.INITIAL) {
         console.error('Must be in new state before drawing');
       }
       if (this.hasImage) {
         return Promise.resolve(undefined);
       }
       this.hasImage = true;
       this.renderingState = RenderingStates.RUNNING;
@@ -4887,17 +4887,17 @@ var PDFThumbnailView = (function PDFThum
         },
         function pdfPageRenderError(error) {
           thumbnailDrawCallback(error);
         }
       );
       return promise;
     },
 
-    setImage: function PDFThumbnailView_setImage(pageView) {
+    setImage: function(pageView) {
       var img = pageView.canvas;
       if (this.hasImage || !img) {
         return;
       }
       if (!this.pdfPage) {
         this.setPdfPage(pageView.pdfPage);
       }
       this.hasImage = true;
@@ -4968,28 +4968,28 @@ var PDFThumbnailViewer = (function PDFTh
     this.scroll = watchScroll(this.container, this._scrollUpdated.bind(this));
     this._resetView();
   }
 
   PDFThumbnailViewer.prototype = {
     /**
      * @private
      */
-    _scrollUpdated: function PDFThumbnailViewer_scrollUpdated() {
+    _scrollUpdated: function() {
       this.renderingQueue.renderHighestPriority();
     },
 
-    getThumbnail: function PDFThumbnailViewer_getThumbnail(index) {
+    getThumbnail: function(index) {
       return this.thumbnails[index];
     },
 
     /**
      * @private
      */
-    _getVisibleThumbs: function PDFThumbnailViewer_getVisibleThumbs() {
+    _getVisibleThumbs: function() {
       return getVisibleElements(this.container, this.thumbnails);
     },
 
     scrollThumbnailIntoView:
         function PDFThumbnailViewer_scrollThumbnailIntoView(page) {
       var selected = document.querySelector('.thumbnail.selected');
       if (selected) {
         selected.classList.remove('selected');
@@ -5017,37 +5017,37 @@ var PDFThumbnailViewer = (function PDFTh
     set pagesRotation(rotation) {
       this._pagesRotation = rotation;
       for (var i = 0, l = this.thumbnails.length; i < l; i++) {
         var thumb = this.thumbnails[i];
         thumb.update(rotation);
       }
     },
 
-    cleanup: function PDFThumbnailViewer_cleanup() {
+    cleanup: function() {
       var tempCanvas = PDFThumbnailView.tempImageCache;
       if (tempCanvas) {
         // Zeroing the width and height causes Firefox to release graphics
         // resources immediately, which can greatly reduce memory consumption.
         tempCanvas.width = 0;
         tempCanvas.height = 0;
       }
       PDFThumbnailView.tempImageCache = null;
     },
 
     /**
      * @private
      */
-    _resetView: function PDFThumbnailViewer_resetView() {
+    _resetView: function() {
       this.thumbnails = [];
       this._pagesRotation = 0;
       this._pagesRequests = [];
     },
 
-    setDocument: function PDFThumbnailViewer_setDocument(pdfDocument) {
+    setDocument: function(pdfDocument) {
       if (this.pdfDocument) {
         // cleanup of the elements and views
         var thumbsView = this.container;
         while (thumbsView.hasChildNodes()) {
           thumbsView.removeChild(thumbsView.lastChild);
         }
         this._resetView();
       }
@@ -5140,36 +5140,36 @@ var PDFOutlineView = (function PDFOutlin
    */
   function PDFOutlineView(options) {
     this.container = options.container;
     this.outline = options.outline;
     this.linkService = options.linkService;
   }
 
   PDFOutlineView.prototype = {
-    reset: function PDFOutlineView_reset() {
+    reset: function() {
       var container = this.container;
       while (container.firstChild) {
         container.removeChild(container.firstChild);
       }
     },
 
     /**
      * @private
      */
-    _bindLink: function PDFOutlineView_bindLink(element, item) {
+    _bindLink: function(element, item) {
       var linkService = this.linkService;
       element.href = linkService.getDestinationHash(item.dest);
       element.onclick = function goToDestination(e) {
         linkService.navigateTo(item.dest);
         return false;
       };
     },
 
-    render: function PDFOutlineView_render() {
+    render: function() {
       var outline = this.outline;
 
       this.reset();
 
       if (!outline) {
         return;
       }
 
@@ -5219,34 +5219,34 @@ var PDFAttachmentView = (function PDFAtt
    */
   function PDFAttachmentView(options) {
     this.container = options.container;
     this.attachments = options.attachments;
     this.downloadManager = options.downloadManager;
   }
 
   PDFAttachmentView.prototype = {
-    reset: function PDFAttachmentView_reset() {
+    reset: function() {
       var container = this.container;
       while (container.firstChild) {
         container.removeChild(container.firstChild);
       }
     },
 
     /**
      * @private
      */
-    _bindLink: function PDFAttachmentView_bindLink(button, content, filename) {
+    _bindLink: function(button, content, filename) {
       button.onclick = function downloadFile(e) {
         this.downloadManager.downloadData(content, filename, '');
         return false;
       }.bind(this);
     },
 
-    render: function PDFAttachmentView_render() {
+    render: function() {
       var attachments = this.attachments;
 
       this.reset();
 
       if (!attachments) {
         return;
       }
 
@@ -5291,17 +5291,17 @@ var PDFViewerApplication = {
   mouseScrollTimeStamp: 0,
   mouseScrollDelta: 0,
   preferenceSidebarViewOnLoad: SidebarView.NONE,
   preferencePdfBugEnabled: false,
   isViewerEmbedded: (window.parent !== window),
   url: '',
 
   // called once when the document is loaded
-  initialize: function pdfViewInitialize() {
+  initialize: function() {
     var pdfRenderingQueue = new PDFRenderingQueue();
     pdfRenderingQueue.onIdle = this.cleanup.bind(this);
     this.pdfRenderingQueue = pdfRenderingQueue;
 
     var container = document.getElementById('viewerContainer');
     var viewer = document.getElementById('viewer');
     this.pdfViewer = new PDFViewer({
       container: container,
@@ -5437,27 +5437,27 @@ var PDFViewerApplication = {
       // TODO move more preferences and other async stuff here
     ]).catch(function (reason) { });
 
     return initializedPromise.then(function () {
       PDFViewerApplication.initialized = true;
     });
   },
 
-  zoomIn: function pdfViewZoomIn(ticks) {
+  zoomIn: function(ticks) {
     var newScale = this.pdfViewer.currentScale;
     do {
       newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);
       newScale = Math.ceil(newScale * 10) / 10;
       newScale = Math.min(MAX_SCALE, newScale);
     } while (--ticks && newScale < MAX_SCALE);
     this.setScale(newScale, true);
   },
 
-  zoomOut: function pdfViewZoomOut(ticks) {
+  zoomOut: function(ticks) {
     var newScale = this.pdfViewer.currentScale;
     do {
       newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);
       newScale = Math.floor(newScale * 10) / 10;
       newScale = Math.max(MIN_SCALE, newScale);
     } while (--ticks && newScale > MIN_SCALE);
     this.setScale(newScale, true);
   },
@@ -5522,17 +5522,17 @@ var PDFViewerApplication = {
   },
 
   get loadingBar() {
     var bar = new ProgressBar('#loadingBar', {});
 
     return PDFJS.shadow(this, 'loadingBar', bar);
   },
 
-  initPassiveLoading: function pdfViewInitPassiveLoading() {
+  initPassiveLoading: function() {
     function FirefoxComDataRangeTransport(length, initialData) {
       PDFJS.PDFDataRangeTransport.call(this, length, initialData);
     }
     FirefoxComDataRangeTransport.prototype =
       Object.create(PDFJS.PDFDataRangeTransport.prototype);
     FirefoxComDataRangeTransport.prototype.requestDataRange =
         function FirefoxComDataRangeTransport_requestDataRange(begin, end) {
       FirefoxCom.request('requestDataRange', { begin: begin, end: end });
@@ -5583,32 +5583,32 @@ var PDFViewerApplication = {
           }
           PDFViewerApplication.open(args.data, 0);
           break;
       }
     });
     FirefoxCom.requestSync('initPassiveLoading', null);
   },
 
-  setTitleUsingUrl: function pdfViewSetTitleUsingUrl(url) {
+  setTitleUsingUrl: function(url) {
     this.url = url;
     try {
       this.setTitle(decodeURIComponent(getFileName(url)) || url);
     } catch (e) {
       // decodeURIComponent may throw URIError,
       // fall back to using the unprocessed url in that case
       this.setTitle(url);
     }
   },
 
-  setTitle: function pdfViewSetTitle(title) {
+  setTitle: function(title) {
     document.title = title;
   },
 
-  close: function pdfViewClose() {
+  close: function() {
     var errorWrapper = document.getElementById('errorWrapper');
     errorWrapper.setAttribute('hidden', 'true');
 
     if (!this.pdfDocument) {
       return;
     }
 
     this.pdfDocument.destroy();
@@ -5693,17 +5693,17 @@ var PDFViewerApplication = {
       }
     );
 
     if (args && args.length) {
       DocumentProperties.setFileSize(args.length);
     }
   },
 
-  download: function pdfViewDownload() {
+  download: function() {
     function downloadByUrl() {
       downloadManager.downloadUrl(url, filename);
     }
 
     var url = this.url.split('#')[0];
     var filename = getPDFFileNameFromURL(url);
     var downloadManager = new DownloadManager();
     downloadManager.onerror = function (err) {
@@ -5726,33 +5726,33 @@ var PDFViewerApplication = {
       function getDataSuccess(data) {
         var blob = PDFJS.createBlob(data, 'application/pdf');
         downloadManager.download(blob, url, filename);
       },
       downloadByUrl // Error occurred try downloading with just the url.
     ).then(null, downloadByUrl);
   },
 
-  fallback: function pdfViewFallback(featureId) {
+  fallback: function(featureId) {
     // Only trigger the fallback once so we don't spam the user with messages
     // for one PDF.
     if (this.fellback)
       return;
     this.fellback = true;
     var url = this.url.split('#')[0];
     FirefoxCom.request('fallback', { featureId: featureId, url: url },
       function response(download) {
         if (!download) {
           return;
         }
         PDFViewerApplication.download();
       });
   },
 
-  navigateTo: function pdfViewNavigateTo(dest) {
+  navigateTo: function(dest) {
     var destString = '';
     var self = this;
 
     var goToDestination = function(destRef) {
       self.pendingRefStr = null;
       // dest array looks like that: <page-ref> </XYZ|FitXXX> <args..>
       var pageNumber = destRef instanceof Object ?
         self.pagesRefMap[destRef.num + ' ' + destRef.gen + ' R'] :
@@ -5785,17 +5785,17 @@ var PDFViewerApplication = {
       dest = destination;
       if (!(destination instanceof Array)) {
         return; // invalid destination
       }
       goToDestination(destination[0]);
     });
   },
 
-  executeNamedAction: function pdfViewExecuteNamedAction(action) {
+  executeNamedAction: function(action) {
     // See PDF reference, table 8.45 - Named action
     switch (action) {
       case 'GoToPage':
         document.getElementById('pageNumber').focus();
         break;
 
       case 'GoBack':
         PDFHistory.back();
@@ -5827,17 +5827,17 @@ var PDFViewerApplication = {
         this.page = 1;
         break;
 
       default:
         break; // No action according to spec
     }
   },
 
-  getDestinationHash: function pdfViewGetDestinationHash(dest) {
+  getDestinationHash: function(dest) {
     if (typeof dest === 'string') {
       return this.getAnchorUrl('#' + escape(dest));
     }
     if (dest instanceof Array) {
       var destRef = dest[0]; // see navigateTo method for dest format
       var pageNumber = destRef instanceof Object ?
         this.pagesRefMap[destRef.num + ' ' + destRef.gen + ' R'] :
         (destRef + 1);
@@ -5862,28 +5862,28 @@ var PDFViewerApplication = {
     return '';
   },
 
   /**
    * Prefix the full url on anchor links to make sure that links are resolved
    * relative to the current URL instead of the one defined in <base href>.
    * @param {String} anchor The anchor hash, including the #.
    */
-  getAnchorUrl: function getAnchorUrl(anchor) {
+  getAnchorUrl: function(anchor) {
     return this.url.split('#')[0] + anchor;
   },
 
   /**
    * Show the error box.
    * @param {String} message A message that is human readable.
    * @param {Object} moreInfo (optional) Further information about the error
    *                            that is more technical.  Should have a 'message'
    *                            and optionally a 'stack' property.
    */
-  error: function pdfViewError(message, moreInfo) {
+  error: function(message, moreInfo) {
     var moreInfoText = mozL10n.get('error_version_info',
       {version: PDFJS.version || '?', build: PDFJS.build || '?'},
       'PDF.js v{{version}} (build: {{build}})') + '\n';
     if (moreInfo) {
       moreInfoText +=
         mozL10n.get('error_message', {message: moreInfo.message},
         'Message: {{message}}');
       if (moreInfo.stack) {
@@ -5903,17 +5903,17 @@ var PDFViewerApplication = {
         }
       }
     }
 
     console.error(message + '\n' + moreInfoText);
     this.fallback();
   },
 
-  progress: function pdfViewProgress(level) {
+  progress: function(level) {
     var percent = Math.round(level * 100);
     // When we transition from full request to range requests, it's possible
     // that we discard some of the loaded data. This can cause the loading
     // bar to move backwards. So prevent this by only updating the bar if it
     // increases.
     if (percent > this.loadingBar.percent || isNaN(percent)) {
       this.loadingBar.percent = percent;
 
@@ -5932,17 +5932,17 @@ var PDFViewerApplication = {
         this.disableAutoFetchLoadingBarTimeout = setTimeout(function () {
           this.loadingBar.hide();
           this.disableAutoFetchLoadingBarTimeout = null;
         }.bind(this), DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);
       }
     }
   },
 
-  load: function pdfViewLoad(pdfDocument, scale) {
+  load: function(pdfDocument, scale) {
     var self = this;
     scale = scale || UNKNOWN_SCALE;
 
     this.findController.reset();
 
     this.pdfDocument = pdfDocument;
 
     DocumentProperties.url = this.url;
@@ -6163,17 +6163,17 @@ var PDFViewerApplication = {
         type: 'documentInfo',
         version: versionId,
         generator: generatorId,
         formType: formType
       }));
     });
   },
 
-  setInitialView: function pdfViewSetInitialView(storedHash, scale) {
+  setInitialView: function(storedHash, scale) {
     this.isInitialViewSet = true;
 
     // When opening a new file (when one is already loaded in the viewer):
     // Reset 'currentPageNumber', since otherwise the page's scale will be wrong
     // if 'currentPageNumber' is larger than the number of pages in the file.
     document.getElementById('pageNumber').value =
       this.pdfViewer.currentPageNumber = 1;
 
@@ -6193,29 +6193,29 @@ var PDFViewerApplication = {
 
     if (this.pdfViewer.currentScale === UNKNOWN_SCALE) {
       // Scale was not initialized: invalid bookmark or scale was not specified.
       // Setting the default one.
       this.setScale(DEFAULT_SCALE, true);
     }
   },
 
-  cleanup: function pdfViewCleanup() {
+  cleanup: function() {
     this.pdfViewer.cleanup();
     this.pdfThumbnailViewer.cleanup();
     this.pdfDocument.cleanup();
   },
 
-  forceRendering: function pdfViewForceRendering() {
+  forceRendering: function() {
     this.pdfRenderingQueue.printing = this.printing;
     this.pdfRenderingQueue.isThumbnailViewEnabled = this.sidebarOpen;
     this.pdfRenderingQueue.renderHighestPriority();
   },
 
-  setHash: function pdfViewSetHash(hash) {
+  setHash: function(hash) {
     if (!this.isInitialViewSet) {
       this.initialBookmark = hash;
       return;
     }
 
     var validFitZoomValues = ['Fit','FitB','FitH','FitBH',
       'FitV','FitBV','FitR'];
 
@@ -6271,17 +6271,17 @@ var PDFViewerApplication = {
     } else if (/^\d+$/.test(hash)) { // page number
       this.page = hash;
     } else { // named destination
       PDFHistory.updateNextHashParam(unescape(hash));
       this.navigateTo(unescape(hash));
     }
   },
 
-  switchSidebarView: function pdfViewSwitchSidebarView(view, openSidebar) {
+  switchSidebarView: function(view, openSidebar) {
     if (openSidebar && !this.sidebarOpen) {
       document.getElementById('sidebarToggle').click();
     }
     var thumbsView = document.getElementById('thumbnailView');
     var outlineView = document.getElementById('outlineView');
     var attachmentsView = document.getElementById('attachmentsView');
 
     var thumbsButton = document.getElementById('viewThumbnail');
@@ -6330,29 +6330,29 @@ var PDFViewerApplication = {
         if (attachmentsButton.getAttribute('disabled')) {
           return;
         }
         break;
     }
   },
 
   // Helper function to parse query string (e.g. ?param1=value&parm2=...).
-  parseQueryString: function pdfViewParseQueryString(query) {
+  parseQueryString: function(query) {
     var parts = query.split('&');
     var params = {};
     for (var i = 0, ii = parts.length; i < ii; ++i) {
       var param = parts[i].split('=');
       var key = param[0].toLowerCase();
       var value = param.length > 1 ? param[1] : null;
       params[decodeURIComponent(key)] = decodeURIComponent(value);
     }
     return params;
   },
 
-  beforePrint: function pdfViewSetupBeforePrint() {
+  beforePrint: function() {
     if (!this.supportsPrinting) {
       var printMessage = mozL10n.get('printing_not_supported', null,
           'Warning: Printing is not fully supported by this browser.');
       this.error(printMessage);
       return;
     }
 
     var alertNotReady = false;
@@ -6383,33 +6383,33 @@ var PDFViewerApplication = {
       this.pdfViewer.getPageView(i).beforePrint();
     }
 
       FirefoxCom.request('reportTelemetry', JSON.stringify({
         type: 'print'
       }));
   },
 
-  afterPrint: function pdfViewSetupAfterPrint() {
+  afterPrint: function() {
     var div = document.getElementById('printContainer');
     while (div.hasChildNodes()) {
       div.removeChild(div.lastChild);
     }
 
     this.printing = false;
     this.forceRendering();
   },
 
   setScale: function (value, resetAutoSettings) {
     this.updateScaleControls = !!resetAutoSettings;
     this.pdfViewer.currentScaleValue = value;
     this.updateScaleControls = true;
   },
 
-  rotatePages: function pdfViewRotatePages(delta) {
+  rotatePages: function(delta) {
     var pageNumber = this.page;
     this.pageRotation = (this.pageRotation + 360 + delta) % 360;
     this.pdfViewer.pagesRotation = this.pageRotation;
     this.pdfThumbnailViewer.pagesRotation = this.pageRotation;
 
     this.forceRendering();
 
     this.pdfViewer.scrollPageIntoView(pageNumber);
@@ -6417,17 +6417,17 @@ var PDFViewerApplication = {
 
   /**
    * This function flips the page in presentation mode if the user scrolls up
    * or down with large enough motion and prevents page flipping too often.
    *
    * @this {PDFView}
    * @param {number} mouseScrollDelta The delta value from the mouse event.
    */
-  mouseScroll: function pdfViewMouseScroll(mouseScrollDelta) {
+  mouseScroll: function(mouseScrollDelta) {
     var MOUSE_SCROLL_COOLDOWN_TIME = 50;
 
     var currentTime = (new Date()).getTime();
     var storedTime = this.mouseScrollTimeStamp;
 
     // In case one page has already been flipped there is a cooldown time
     // which has to expire before next page can be scrolled on to.
     if (currentTime > storedTime &&
@@ -6473,17 +6473,17 @@ var PDFViewerApplication = {
   },
 
   /**
    * This function clears the member attributes used with mouse scrolling in
    * presentation mode.
    *
    * @this {PDFView}
    */
-  clearMouseScrollState: function pdfViewClearMouseScrollState() {
+  clearMouseScrollState: function() {
     this.mouseScrollTimeStamp = 0;
     this.mouseScrollDelta = 0;
   }
 };
 
 
 function webViewerLoad(evt) {
   PDFViewerApplication.initialize().then(webViewerInitialized);
diff --git a/browser/extensions/shumway/content/ShumwayBootstrapUtils.jsm b/browser/extensions/shumway/content/ShumwayBootstrapUtils.jsm
--- a/browser/extensions/shumway/content/ShumwayBootstrapUtils.jsm
+++ b/browser/extensions/shumway/content/ShumwayBootstrapUtils.jsm
@@ -55,29 +55,29 @@ function getStringPref(pref, def) {
 function log(str) {
   var msg = 'ShumwayBootstrapUtils.jsm: ' + str;
   Services.console.logStringMessage(msg);
 }
 
 // Register/unregister a constructor as a factory.
 function Factory() {}
 Factory.prototype = {
-  register: function register(targetConstructor) {
+  register: function(targetConstructor) {
     var proto = targetConstructor.prototype;
     this._classID = proto.classID;
 
     var factory = XPCOMUtils._getFactory(targetConstructor);
     this._factory = factory;
 
     var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     registrar.registerFactory(proto.classID, proto.classDescription,
       proto.contractID, factory);
   },
 
-  unregister: function unregister() {
+  unregister: function() {
     var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     registrar.unregisterFactory(this._classID, this._factory);
   }
 };
 
 let converterFactory = new Factory();
 let overlayConverterFactory = new Factory();
 
diff --git a/browser/extensions/shumway/content/ShumwayStreamConverter.jsm b/browser/extensions/shumway/content/ShumwayStreamConverter.jsm
--- a/browser/extensions/shumway/content/ShumwayStreamConverter.jsm
+++ b/browser/extensions/shumway/content/ShumwayStreamConverter.jsm
@@ -291,40 +291,40 @@ function ChromeActions(url, window, docu
 
 ChromeActions.prototype = {
   getBoolPref: function (data) {
     if (!/^shumway\./.test(data.pref)) {
       return null;
     }
     return getBoolPref(data.pref, data.def);
   },
-  getCompilerSettings: function getCompilerSettings() {
+  getCompilerSettings: function() {
     return {
       appCompiler: getBoolPref('shumway.appCompiler', true),
       sysCompiler: getBoolPref('shumway.sysCompiler', false),
       verifier: getBoolPref('shumway.verifier', true)
     };
   },
   addProfilerMarker: function (marker) {
     if ('nsIProfiler' in Ci) {
       let profiler = Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
       profiler.AddMarker(marker);
     }
   },
-  getPluginParams: function getPluginParams() {
+  getPluginParams: function() {
     return {
       url: this.url,
       baseUrl : this.baseUrl,
       movieParams: this.movieParams,
       objectParams: this.objectParams,
       isOverlay: this.isOverlay,
       isPausedAtStart: this.isPausedAtStart
      };
   },
-  _canDownloadFile: function canDownloadFile(data, callback) {
+  _canDownloadFile: function(data, callback) {
     var url = data.url, checkPolicyFile = data.checkPolicyFile;
 
     // TODO flash cross-origin request
     if (url === this.url) {
       // allow downloading for the original file
       return callback({success: true});
     }
 
@@ -368,17 +368,17 @@ ChromeActions.prototype = {
 
       var allowed = policy.allowAccessFrom.some(function (i) {
         return domainMatches(parsedBaseUrl.host, i.domain) &&
           (!i.secure || parsedBaseUrl.scheme.toLowerCase() === 'https');
       });
       return callback({success: allowed});
     }.bind(this));
   },
-  loadFile: function loadFile(data) {
+  loadFile: function(data) {
     function notifyLoadFileListener(data) {
       if (!win.wrappedJSObject.onLoadFileCallback) {
         return;
       }
       win.wrappedJSObject.onLoadFileCallback(data);
     }
 
     var url = data.url;
@@ -633,31 +633,31 @@ RequestListener.prototype.receive = func
 
 var ActivationQueue = {
   nonActive: [],
   initializing: -1,
   activationTimeout: null,
   get currentNonActive() {
     return this.nonActive[this.initializing];
   },
-  enqueue: function ActivationQueue_enqueue(actions) {
+  enqueue: function(actions) {
     this.nonActive.push(actions);
     if (this.nonActive.length === 1) {
       this.activateNext();
     }
   },
-  findLastOnPage: function ActivationQueue_findLastOnPage(baseUrl) {
+  findLastOnPage: function(baseUrl) {
     for (var i = this.nonActive.length - 1; i >= 0; i--) {
       if (this.nonActive[i].baseUrl === baseUrl) {
         return this.nonActive[i];
       }
     }
     return null;
   },
-  activateNext: function ActivationQueue_activateNext() {
+  activateNext: function() {
     function weightInstance(actions) {
       // set of heuristics for find the most important instance to load
       var weight = 0;
       // using linear distance to the top-left of the view area
       if (actions.embedTag) {
         var window = actions.window;
         var clientRect = actions.embedTag.getBoundingClientRect();
         weight -= Math.abs(clientRect.left - window.scrollX) +
diff --git a/browser/extensions/shumway/content/ShumwayUtils.jsm b/browser/extensions/shumway/content/ShumwayUtils.jsm
--- a/browser/extensions/shumway/content/ShumwayUtils.jsm
+++ b/browser/extensions/shumway/content/ShumwayUtils.jsm
@@ -38,46 +38,46 @@ function getBoolPref(pref, def) {
 function log(str) {
   dump(str + '\n');
 }
 
 let ShumwayUtils = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
   _registered: false,
 
-  init: function init() {
+  init: function() {
     this.migratePreferences();
     if (this.enabled)
       this._ensureRegistered();
     else
       this._ensureUnregistered();
 
     Cc["@mozilla.org/parentprocessmessagemanager;1"]
       .getService(Ci.nsIMessageBroadcaster)
       .addMessageListener('Shumway:Chrome:isEnabled', this);
 
     // Listen for when shumway is completely disabled.
     Services.prefs.addObserver(PREF_DISABLED, this, false);
   },
 
-  migratePreferences: function migratePreferences() {
+  migratePreferences: function() {
     // At one point we had shumway.disabled set to true by default,
     // and we are trying to replace it with shumway.swf.whitelist:
     // checking if the user already changed it before to reset
     // the whitelist to '*'.
     if (Services.prefs.prefHasUserValue(PREF_DISABLED) &&
         !Services.prefs.prefHasUserValue(PREF_WHITELIST) &&
         !getBoolPref(PREF_DISABLED, false)) {
       // The user is already using Shumway -- enabling all web sites.
       Services.prefs.setCharPref(PREF_WHITELIST, '*');
     }
   },
 
   // nsIObserver
-  observe: function observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (this.enabled)
       this._ensureRegistered();
     else
       this._ensureUnregistered();
   },
 
   receiveMessage: function(message) {
     switch (message.name) {
@@ -89,34 +89,34 @@ let ShumwayUtils = {
   /**
    * shumway is only enabled if the global switch enabling is true.
    * @return {boolean} Wether or not it's enabled.
    */
   get enabled() {
     return !getBoolPref(PREF_DISABLED, true);
   },
 
-  _ensureRegistered: function _ensureRegistered() {
+  _ensureRegistered: function() {
     if (this._registered)
       return;
 
     // Load the component and register it.
     Cu.import('resource://shumway/ShumwayBootstrapUtils.jsm');
     ShumwayBootstrapUtils.register();
 
     this._registered = true;
 
     log('Shumway is registered');
 
     let globalMM = Cc['@mozilla.org/globalmessagemanager;1']
       .getService(Ci.nsIFrameScriptLoader);
     globalMM.broadcastAsyncMessage('Shumway:Child:refreshSettings');
   },
 
-  _ensureUnregistered: function _ensureUnregistered() {
+  _ensureUnregistered: function() {
     if (!this._registered)
       return;
 
     // Remove the contract/component.
     ShumwayBootstrapUtils.unregister();
     Cu.unload('resource://shumway/ShumwayBootstrapUtils.jsm');
 
     this._registered = false;
diff --git a/browser/extensions/shumway/content/shumway.player.js b/browser/extensions/shumway/content/shumway.player.js
--- a/browser/extensions/shumway/content/shumway.player.js
+++ b/browser/extensions/shumway/content/shumway.player.js
@@ -8212,17 +8212,17 @@ Errors = Shumway.AVM2.Errors;
             void 0 === a && (a = !1);
             var f = [];
             e.forEach(function(b, e) {
               (b.isMethod() || b.isGetter() || b.isSetter()) && b.methodInfo.isNative() && f.push(b);
             });
             f.forEach(function(e, a) {
               var g = e.methodInfo, n = e.name.getName();
               b.writeLn("// " + n + " :: " + (g.parameters.length ? h(g) : "void") + " -> " + (g.returnType ? g.returnType.getName() : "any"));
-              b.enter((e.isGetter() ? '"get ' + n + '"' : e.isSetter() ? '"set ' + n + '"' : n) + ": function " + n + "(" + h(g, !0) + ") {");
+              b.enter((e.isGetter() ? '"get ' + n + '"' : e.isSetter() ? '"set ' + n + '"' : n) + ": function(g, !0) + ") {");
               b.writeLn('  notImplemented("' + m + "." + n + '");');
               b.leave("}" + (a === f.length - 1 ? "" : ",\n"));
             });
           }
           var b = this.writer, e = a.classInfo, n = e.instanceInfo, m = n.name.getName();
           a = a.metadata ? a.metadata.native : null;
           if (!a) {
             return!1;
@@ -8249,17 +8249,17 @@ Errors = Shumway.AVM2.Errors;
             }), methods:b.filter(function(b) {
               return(b.isMethod() || b.isGetter() || b.isSetter()) && !0 === b.methodInfo.isNative();
             })};
           }
           function b(b, a) {
             function g(b, f) {
               var n = b.methodInfo, c = b.name.getName(), p = "// (" + (n.parameters.length ? h(n) : "void") + ") -> " + (n.returnType ? n.returnType.getName() : "any"), d = c;
               b.isGetter() ? d = "get" : b.isSetter() && (d = "set");
-              e.enter(d + ": function " + c + "(" + h(n, !0) + ") { " + p);
+              e.enter(d + ": function(n, !0) + ") { " + p);
               e.writeLn('notImplemented("' + m + "." + c + '");');
               a || (b.isGetter() ? e.writeLn("return this._" + c + ";") : b.isSetter() && e.writeLn("this._" + c + " = " + n.parameters[0].name + ";"));
               e.leave("}" + (f ? "," : ""));
             }
             void 0 === a && (a = !1);
             b = f(b);
             var n = [], c = Object.create(null);
             b.methods.forEach(function(b, e) {
diff --git a/browser/fuel/fuelApplication.js b/browser/fuel/fuelApplication.js
--- a/browser/fuel/fuelApplication.js
+++ b/browser/fuel/fuelApplication.js
@@ -42,24 +42,24 @@ var Utilities = {
 
   get windowMediator() {
     let windowMediator = Cc["@mozilla.org/appshell/window-mediator;1"].
                          getService(Ci.nsIWindowMediator);
     this.__defineGetter__("windowMediator", function() windowMediator);
     return this.windowMediator;
   },
 
-  makeURI: function fuelutil_makeURI(aSpec) {
+  makeURI: function(aSpec) {
     if (!aSpec)
       return null;
     var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
     return ios.newURI(aSpec, null, null);
   },
 
-  free: function fuelutil_free() {
+  free: function() {
     delete this.bookmarks;
     delete this.bookmarksObserver;
     delete this.annotations;
     delete this.history;
     delete this.windowMediator;
   }
 };
 
@@ -96,38 +96,38 @@ Window.prototype = {
   get _tabbrowser() {
     return this._window.gBrowser;
   },
 
   /*
    * Helper used to setup event handlers on the XBL element. Note that the events
    * are actually dispatched to tabs, so we capture them.
    */
-  _watch: function win_watch(aType) {
+  _watch: function(aType) {
     this._tabbrowser.tabContainer.addEventListener(aType, this,
                                                    /* useCapture = */ true);
   },
 
-  handleEvent: function win_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     this._events.dispatch(aEvent.type, getBrowserTab(this, aEvent.originalTarget.linkedBrowser));
   },
 
   get tabs() {
     var tabs = [];
     var browsers = this._tabbrowser.browsers;
     for (var i=0; i<browsers.length; i++)
       tabs.push(getBrowserTab(this, browsers[i]));
     return tabs;
   },
 
   get activeTab() {
     return getBrowserTab(this, this._tabbrowser.selectedBrowser);
   },
 
-  open: function win_open(aURI) {
+  open: function(aURI) {
     return getBrowserTab(this, this._tabbrowser.addTab(aURI.spec).linkedBrowser);
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.fuelIWindow])
 };
 
 //=================================================
 // BrowserTab implementation
@@ -185,58 +185,58 @@ BrowserTab.prototype = {
 
   get document() {
     return this._browser.contentDocument;
   },
 
   /*
    * Helper used to setup event handlers on the XBL element
    */
-  _watch: function bt_watch(aType) {
+  _watch: function(aType) {
     this._browser.addEventListener(aType, this,
                                    /* useCapture = */ true);
   },
 
-  handleEvent: function bt_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (aEvent.type == "load") {
       if (!(aEvent.originalTarget instanceof Ci.nsIDOMDocument))
         return;
 
       if (aEvent.originalTarget.defaultView instanceof Ci.nsIDOMWindow &&
           aEvent.originalTarget.defaultView.frameElement)
         return;
     }
     this._events.dispatch(aEvent.type, this);
   },
   /*
    * Helper used to determine the index offset of the browsertab
    */
-  _getTab: function bt_gettab() {
+  _getTab: function() {
     var tabs = this._tabbrowser.tabs;
     return tabs[this.index] || null;
   },
 
-  load: function bt_load(aURI) {
+  load: function(aURI) {
     this._browser.loadURI(aURI.spec, null, null);
   },
 
-  focus: function bt_focus() {
+  focus: function() {
     this._tabbrowser.selectedTab = this._getTab();
     this._tabbrowser.focus();
   },
 
-  close: function bt_close() {
+  close: function() {
     this._tabbrowser.removeTab(this._getTab());
   },
 
-  moveBefore: function bt_movebefore(aBefore) {
+  moveBefore: function(aBefore) {
     this._tabbrowser.moveTabTo(this._getTab(), aBefore.index);
   },
 
-  moveToEnd: function bt_moveend() {
+  moveToEnd: function() {
     this._tabbrowser.moveTabTo(this._getTab(), this._tabbrowser.browsers.length);
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.fuelIBrowserTab])
 };
 
 
 //=================================================
@@ -245,31 +245,31 @@ function Annotations(aId) {
   this._id = aId;
 }
 
 Annotations.prototype = {
   get names() {
     return Utilities.annotations.getItemAnnotationNames(this._id);
   },
 
-  has: function ann_has(aName) {
+  has: function(aName) {
     return Utilities.annotations.itemHasAnnotation(this._id, aName);
   },
 
-  get: function ann_get(aName) {
+  get: function(aName) {
     if (this.has(aName))
       return Utilities.annotations.getItemAnnotation(this._id, aName);
     return null;
   },
 
-  set: function ann_set(aName, aValue, aExpiration) {
+  set: function(aName, aValue, aExpiration) {
     Utilities.annotations.setItemAnnotation(this._id, aName, aValue, 0, aExpiration);
   },
 
-  remove: function ann_remove(aName) {
+  remove: function(aName) {
     if (aName)
       Utilities.annotations.removeItemAnnotation(this._id, aName);
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.fuelIAnnotations])
 };
 
 
@@ -301,83 +301,83 @@ function BookmarksObserver() {
   Utilities.bookmarks.addObserver(this, /* ownsWeak = */ true);
 }
 
 BookmarksObserver.prototype = {
   onBeginUpdateBatch: function () {},
   onEndUpdateBatch: function () {},
   onItemVisited: function () {},
 
-  onItemAdded: function bo_onItemAdded(aId, aFolder, aIndex, aItemType, aURI) {
+  onItemAdded: function(aId, aFolder, aIndex, aItemType, aURI) {
     this._rootEvents.dispatch("add", aId);
     this._dispatchToEvents("addchild", aId, this._folderEventsDict[aFolder]);
   },
 
-  onItemRemoved: function bo_onItemRemoved(aId, aFolder, aIndex) {
+  onItemRemoved: function(aId, aFolder, aIndex) {
     this._rootEvents.dispatch("remove", aId);
     this._dispatchToEvents("remove", aId, this._eventsDict[aId]);
     this._dispatchToEvents("removechild", aId, this._folderEventsDict[aFolder]);
   },
 
-  onItemChanged: function bo_onItemChanged(aId, aProperty, aIsAnnotationProperty, aValue) {
+  onItemChanged: function(aId, aProperty, aIsAnnotationProperty, aValue) {
     this._rootEvents.dispatch("change", aProperty);
     this._dispatchToEvents("change", aProperty, this._eventsDict[aId]);
   },
 
-  onItemMoved: function bo_onItemMoved(aId, aOldParent, aOldIndex, aNewParent, aNewIndex) {
+  onItemMoved: function(aId, aOldParent, aOldIndex, aNewParent, aNewIndex) {
     this._dispatchToEvents("move", aId, this._eventsDict[aId]);
   },
 
-  _dispatchToEvents: function bo_dispatchToEvents(aEvent, aData, aEvents) {
+  _dispatchToEvents: function(aEvent, aData, aEvents) {
     if (aEvents) {
       aEvents.dispatch(aEvent, aData);
     }
   },
 
-  _addListenerToDict: function bo_addListenerToDict(aId, aEvent, aListener, aDict) {
+  _addListenerToDict: function(aId, aEvent, aListener, aDict) {
     var events = aDict[aId];
     if (!events) {
       events = new Events();
       aDict[aId] = events;
     }
     events.addListener(aEvent, aListener);
   },
 
-  _removeListenerFromDict: function bo_removeListenerFromDict(aId, aEvent, aListener, aDict) {
+  _removeListenerFromDict: function(aId, aEvent, aListener, aDict) {
     var events = aDict[aId];
     if (!events) {
       return;
     }
     events.removeListener(aEvent, aListener);
     if (events._listeners.length == 0) {
       delete aDict[aId];
     }
   },
 
-  addListener: function bo_addListener(aId, aEvent, aListener) {
+  addListener: function(aId, aEvent, aListener) {
     this._addListenerToDict(aId, aEvent, aListener, this._eventsDict);
   },
 
-  removeListener: function bo_removeListener(aId, aEvent, aListener) {
+  removeListener: function(aId, aEvent, aListener) {
     this._removeListenerFromDict(aId, aEvent, aListener, this._eventsDict);
   },
 
-  addFolderListener: function addFolderListener(aId, aEvent, aListener) {
+  addFolderListener: function(aId, aEvent, aListener) {
     this._addListenerToDict(aId, aEvent, aListener, this._folderEventsDict);
   },
 
-  removeFolderListener: function removeFolderListener(aId, aEvent, aListener) {
+  removeFolderListener: function(aId, aEvent, aListener) {
     this._removeListenerFromDict(aId, aEvent, aListener, this._folderEventsDict);
   },
 
-  addRootListener: function addRootListener(aEvent, aListener) {
+  addRootListener: function(aEvent, aListener) {
     this._rootEvents.addListener(aEvent, aListener);
   },
 
-  removeRootListener: function removeRootListener(aEvent, aListener) {
+  removeRootListener: function(aEvent, aListener) {
     this._rootEvents.removeListener(aEvent, aListener);
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsINavBookmarkObserver,
                                          Ci.nsISupportsWeakReference])
 };
 
 //=================================================
@@ -401,20 +401,20 @@ function Bookmark(aId, aParent, aType) {
   this._id = aId;
   this._parent = aParent;
   this._type = aType || "bookmark";
   this._annotations = new Annotations(this._id);
 
   // Our _events object forwards to bookmarksObserver.
   var self = this;
   this._events = {
-    addListener: function bookmarkevents_al(aEvent, aListener) {
+    addListener: function(aEvent, aListener) {
       Utilities.bookmarksObserver.addListener(self._id, aEvent, aListener);
     },
-    removeListener: function bookmarkevents_rl(aEvent, aListener) {
+    removeListener: function(aEvent, aListener) {
       Utilities.bookmarksObserver.removeListener(self._id, aEvent, aListener);
     },
     QueryInterface: XPCOMUtils.generateQI([Ci.extIEvents])
   };
 
   // For our onItemMoved listener, which updates this._parent.
   Utilities.bookmarks.addObserver(this, /* ownsWeak = */ true);
 }
@@ -472,17 +472,17 @@ Bookmark.prototype = {
   get annotations() {
     return this._annotations;
   },
 
   get events() {
     return this._events;
   },
 
-  remove : function bm_remove() {
+  remove : function() {
     Utilities.bookmarks.removeItem(this._id);
   },
 
   onBeginUpdateBatch: function () {},
   onEndUpdateBatch: function () {},
   onItemAdded: function () {},
   onItemVisited: function () {},
   onItemRemoved: function () {},
@@ -521,30 +521,30 @@ function BookmarkFolder(aId, aParent) {
   //
   //  - Otherwise, events ending with "child" (addchild, removechild) are
   //    handled by a folder listener.
   //
   //  - Other events are handled by a vanilla bookmark listener.
 
   var self = this;
   this._events = {
-    addListener: function bmfevents_al(aEvent, aListener) {
+    addListener: function(aEvent, aListener) {
       if (self._parent) {
         if (/child$/.test(aEvent)) {
           Utilities.bookmarksObserver.addFolderListener(self._id, aEvent, aListener);
         }
         else {
           Utilities.bookmarksObserver.addListener(self._id, aEvent, aListener);
         }
       }
       else {
         Utilities.bookmarksObserver.addRootListener(aEvent, aListener);
       }
     },
-    removeListener: function bmfevents_rl(aEvent, aListener) {
+    removeListener: function(aEvent, aListener) {
       if (self._parent) {
         if (/child$/.test(aEvent)) {
           Utilities.bookmarksObserver.removeFolderListener(self._id, aEvent, aListener);
         }
         else {
           Utilities.bookmarksObserver.removeListener(self._id, aEvent, aListener);
         }
       }
@@ -626,46 +626,46 @@ BookmarkFolder.prototype = {
         items.push(bookmark);
       }
     }
     rootNode.containerOpen = false;
 
     return items;
   },
 
-  addBookmark: function bmf_addbm(aTitle, aUri) {
+  addBookmark: function(aTitle, aUri) {
     var newBookmarkID = Utilities.bookmarks.insertBookmark(this._id, aUri, Utilities.bookmarks.DEFAULT_INDEX, aTitle);
     var newBookmark = new Bookmark(newBookmarkID, this, "bookmark");
     return newBookmark;
   },
 
-  addSeparator: function bmf_addsep() {
+  addSeparator: function() {
     var newBookmarkID = Utilities.bookmarks.insertSeparator(this._id, Utilities.bookmarks.DEFAULT_INDEX);
     var newBookmark = new Bookmark(newBookmarkID, this, "separator");
     return newBookmark;
   },
 
-  addFolder: function bmf_addfolder(aTitle) {
+  addFolder: function(aTitle) {
     var newFolderID = Utilities.bookmarks.createFolder(this._id, aTitle, Utilities.bookmarks.DEFAULT_INDEX);
     var newFolder = new BookmarkFolder(newFolderID, this);
     return newFolder;
   },
 
-  remove: function bmf_remove() {
+  remove: function() {
     Utilities.bookmarks.removeItem(this._id);
   },
 
   // observer
   onBeginUpdateBatch: function () {},
   onEndUpdateBatch : function () {},
   onItemAdded : function () {},
   onItemRemoved : function () {},
   onItemChanged : function () {},
 
-  onItemMoved: function bf_onItemMoved(aId, aOldParent, aOldIndex, aNewParent, aNewIndex) {
+  onItemMoved: function(aId, aOldParent, aOldIndex, aNewParent, aNewIndex) {
     if (this._id == aId) {
       this._parent = new BookmarkFolder(aNewParent, Utilities.bookmarks.getFolderIdForItem(aNewParent));
     }
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.fuelIBookmarkFolder,
                                          Ci.nsINavBookmarkObserver,
                                          Ci.nsISupportsWeakReference])
@@ -711,17 +711,17 @@ BookmarkRoots.prototype = {
 
 //=================================================
 // Factory - Treat Application as a singleton
 // XXX This is required, because we're registered for the 'JavaScript global
 // privileged property' category, whose handler always calls createInstance.
 // See bug 386535.
 var gSingleton = null;
 var ApplicationFactory = {
-  createInstance: function af_ci(aOuter, aIID) {
+  createInstance: function(aOuter, aIID) {
     if (aOuter != null)
       throw Components.results.NS_ERROR_NO_AGGREGATION;
 
     if (gSingleton == null) {
       gSingleton = new Application();
     }
 
     return gSingleton.QueryInterface(aIID);
@@ -773,27 +773,27 @@ function ApplicationPrototype() {
     superPrototype.observe.call(this, aSubject, aTopic, aData);
     if (aTopic == "xpcom-shutdown") {
       this._obs.removeObserver(this, "xpcom-shutdown");
       Utilities.free();
     }
   };
 
   Object.defineProperty(this, "bookmarks", {
-    get: function bookmarks () {
+    get: function() {
       let bookmarks = new BookmarkRoots();
       Object.defineProperty(this, "bookmarks", { value: bookmarks });
       return this.bookmarks;
     },
     enumerable: true,
     configurable: true
   });
 
   Object.defineProperty(this, "windows", {
-    get: function windows() {
+    get: function() {
       var win = [];
       var browserEnum = Utilities.windowMediator.getEnumerator("navigator:browser");
 
       while (browserEnum.hasMoreElements())
         win.push(getWindow(browserEnum.getNext()));
 
       return win;
     },
diff --git a/browser/metro/base/content/BrowserTouchHandler.js b/browser/metro/base/content/BrowserTouchHandler.js
--- a/browser/metro/base/content/BrowserTouchHandler.js
+++ b/browser/metro/base/content/BrowserTouchHandler.js
@@ -4,28 +4,28 @@
  * Receives touch events from our input event capturing in input.js
  * and relays appropriate events to content. Also handles requests
  * from content for UI.
  */
 
 const BrowserTouchHandler = {
   _debugEvents: false,
 
-  init: function init() {
+  init: function() {
     // Misc. events we catch during the bubbling phase
     document.addEventListener("PopupChanged", this, false);
     document.addEventListener("CancelTouchSequence", this, false);
 
     // Messages sent from content.js
     messageManager.addMessageListener("Content:ContextMenu", this);
     messageManager.addMessageListener("Content:SelectionCaret", this);
   },
 
   // Content forwarding the contextmenu command
-  _onContentContextMenu: function _onContentContextMenu(aMessage) {
+  _onContentContextMenu: function(aMessage) {
     // Note, target here is the target of the message manager message,
     // usually the browser.
     // Touch input selection handling
     if (!InputSourceHelper.isPrecise &&
         !SelectionHelperUI.isActive &&
         SelectionHelperUI.canHandleContextMenuMsg(aMessage)) {
       SelectionHelperUI.openEditSession(aMessage.target,
                                         aMessage.json.xPos,
@@ -50,44 +50,44 @@ const BrowserTouchHandler = {
       window.dispatchEvent(event);
     }
   },
 
   /*
    * Called when Content wants to initiate selection management
    * due to a tap in a form input.
    */
-  _onCaretSelectionStarted: function _onCaretSelectionStarted(aMessage) {
+  _onCaretSelectionStarted: function(aMessage) {
     SelectionHelperUI.attachToCaret(aMessage.target,
                                     aMessage.json.xPos,
                                     aMessage.json.yPos);
   },
 
   /*
    * Events
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     // ignore content events we generate
     if (aEvent.target == document)
       return;
 
     if (this._debugEvents)
       Util.dumpLn("BrowserTouchHandler:", aEvent.type);
 
     switch (aEvent.type) {
       case "PopupChanged":
       case "CancelTouchSequence":
         if (!aEvent.detail)
           ContextMenuUI.reset();
         break;
     }
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (this._debugEvents) Util.dumpLn("BrowserTouchHandler:", aMessage.name);
     switch (aMessage.name) {
       // Content forwarding the contextmenu command
       case "Content:ContextMenu":
         this._onContentContextMenu(aMessage);
         break;
       case "Content:SelectionCaret":
         this._onCaretSelectionStarted(aMessage);
diff --git a/browser/metro/base/content/ContentAreaObserver.js b/browser/metro/base/content/ContentAreaObserver.js
--- a/browser/metro/base/content/ContentAreaObserver.js
+++ b/browser/metro/base/content/ContentAreaObserver.js
@@ -79,17 +79,17 @@ var ContentAreaObserver = {
     }
     return (this.height > this.width) ? "portrait" : "landscape";
   },
 
   /*
    * Public apis
    */
 
-  init: function init() {
+  init: function() {
     window.addEventListener("resize", this, false);
 
     // Message manager msgs we listen for
     messageManager.addMessageListener("Content:RepositionInfoResponse", this);
 
     // Observer msgs we listen for
     Services.obs.addObserver(this, "metro_softkeyboard_shown", false);
     Services.obs.addObserver(this, "metro_softkeyboard_hidden", false);
@@ -99,23 +99,23 @@ var ContentAreaObserver = {
 
     // initialize our custom width and height styles
     this._initStyles();
 
     // apply default styling
     this.update();
   },
 
-  shutdown: function shutdown() {
+  shutdown: function() {
     messageManager.removeMessageListener("Content:RepositionInfoResponse", this);
     Services.obs.removeObserver(this, "metro_softkeyboard_shown");
     Services.obs.removeObserver(this, "metro_softkeyboard_hidden");
   },
 
-  update: function cao_update (width, height) {
+  update: function(width, height) {
     let oldWidth = parseInt(this.styles["window-width"].width);
     let oldHeight = parseInt(this.styles["window-height"].height);
 
     let newWidth = width || this.width;
     let newHeight = height || this.height;
 
     if (newHeight == oldHeight && newWidth == oldWidth) {
       return;
@@ -127,17 +127,17 @@ var ContentAreaObserver = {
     this.styles["window-height"].maxHeight = newHeight + "px";
 
     this._updateViewState();
 
     this.updateContentArea(newWidth, this._getContentHeightForWindow(newHeight));
     this._dispatchBrowserEvent("SizeChanged");
   },
 
-  updateContentArea: function cao_updateContentArea (width, height) {
+  updateContentArea: function(width, height) {
     let oldHeight = parseInt(this.styles["content-height"].height);
     let oldWidth = parseInt(this.styles["content-width"].width);
 
     let newWidth = width || this.width;
     let newHeight = height || this.contentHeight;
 
     if (newHeight == oldHeight && newWidth == oldWidth) {
       return;
@@ -147,17 +147,17 @@ var ContentAreaObserver = {
     this.styles["content-height"].maxHeight = newHeight + "px";
     this.styles["content-width"].width = newWidth + "px";
     this.styles["content-width"].maxWidth = newWidth + "px";
 
     this.updateViewableArea(newWidth, this._getViewableHeightForContent(newHeight));
     this._dispatchBrowserEvent("ContentSizeChanged");
   },
 
-  updateViewableArea: function cao_updateViewableArea (width, height) {
+  updateViewableArea: function(width, height) {
     let oldHeight = parseInt(this.styles["viewable-height"].height);
     let oldWidth = parseInt(this.styles["viewable-width"].width);
 
     let newWidth = width || this.width;
     let newHeight = height || this.viewableHeight;
 
     if (newHeight == oldHeight && newWidth == oldWidth) {
       return;
@@ -172,44 +172,44 @@ var ContentAreaObserver = {
 
     // Update the back/tab button states. If the keyboard is up
     // these are hidden.
     BrowserUI._updateButtons();
 
     this._dispatchBrowserEvent("ViewableSizeChanged");
   },
 
-  updateAppBarPosition: function updateAppBarPosition(aForceDown) {
+  updateAppBarPosition: function(aForceDown) {
     // Adjust the app and find bar position above the soft keyboard
     let keyboardHeight = aForceDown ? 0 : Services.metro.keyboardHeight;
     Elements.navbar.style.bottom = keyboardHeight + "px";
     Elements.contextappbar.style.bottom = keyboardHeight + "px";
     Elements.findbar.style.bottom = keyboardHeight + "px";
   },
 
   /*
    * Called by BrowserUI right before we blur the nav bar edit. We use
    * this to get a head start on shuffling app bars around before the
    * soft keyboard transitions down.
    */
-  navBarWillBlur: function navBarWillBlur() {
+  navBarWillBlur: function() {
     this.updateAppBarPosition(true);
   },
 
-  onBrowserCreated: function onBrowserCreated(aBrowser) {
+  onBrowserCreated: function(aBrowser) {
     let notificationBox = aBrowser.parentNode.parentNode;
     notificationBox.classList.add("content-width");
     notificationBox.classList.add("content-height");
   },
 
   /*
    * Event handling
    */
 
-  _onKeyboardDisplayChanging: function _onKeyboardDisplayChanging(aNewState) {
+  _onKeyboardDisplayChanging: function(aNewState) {
     if (aNewState) {
       Elements.stack.setAttribute("keyboardVisible", true);
     } else {
       Elements.stack.removeAttribute("keyboardVisible");
     }
 
     this.updateViewableArea();
 
@@ -222,25 +222,25 @@ var ContentAreaObserver = {
     // need to reposition the browser above the keyboard.
     if (SelectionHelperUI.layerMode === 2 /*kContentLayer*/) {
       Browser.selectedBrowser.messageManager.sendAsyncMessage("Browser:RepositionInfoRequest", {
         viewHeight: this.viewableHeight,
       });
     }
   },
 
-  _onRepositionResponse: function _onRepositionResponse(aJsonMsg) {
+  _onRepositionResponse: function(aJsonMsg) {
     if (!aJsonMsg.reposition || !this.isKeyboardOpened) {
       this.shiftBrowserDeck(0);
       return;
     }
     this.shiftBrowserDeck(aJsonMsg.raiseContent);
   },
 
-  observe: function cao_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     // Note these are fired before the transition starts. Also per MS specs
     // we should not do anything "heavy" here. We have about 100ms before
     // windows just ignores the event and starts the animation.
     switch (aTopic) {
       case "metro_softkeyboard_hidden":
       case "metro_softkeyboard_shown":
         // Mark that we are in a transition state. Auto-complete and other
         // popups will wait for an event before displaying anything.
@@ -252,27 +252,27 @@ var ContentAreaObserver = {
         let state = aTopic == "metro_softkeyboard_shown";
         Util.executeSoon(function () {
           self._onKeyboardDisplayChanging(state);
         });
         break;
     }
   },
 
-  handleEvent: function cao_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case 'resize':
         if (aEvent.target != window)
           return;
         ContentAreaObserver.update();
         break;
     }
   },
 
-  receiveMessage: function sh_receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     switch (aMessage.name) {
       case "Content:RepositionInfoResponse":
         this._onRepositionResponse(aMessage.json);
         break;
     }
   },
 
   /*
@@ -309,31 +309,31 @@ var ContentAreaObserver = {
       self._dispatchWindowEvent("KeyboardChanged", self.isKeyboardOpened);
     }, true);
 
     // selectAtPoint bug 858471
     //Elements.browsers.style.transform = "translateY(" + (-1 * aAmount) + "px)";
     Elements.browsers.style.marginTop = "" + (-1 * aAmount) + "px";
   },
 
-  _dispatchWindowEvent: function _dispatchWindowEvent(aEventName, aDetail) {
+  _dispatchWindowEvent: function(aEventName, aDetail) {
     let event = document.createEvent("UIEvents");
     event.initUIEvent(aEventName, true, false, window, aDetail);
     window.dispatchEvent(event);
   },
 
   _dispatchBrowserEvent: function (aName, aDetail) {
     setTimeout(function() {
       let event = document.createEvent("Events");
       event.initEvent(aName, true, false);
       Elements.browsers.dispatchEvent(event);
     }, 0);
   },
 
-  _initStyles: function _initStyles() {
+  _initStyles: function() {
     let stylesheet = document.styleSheets[0];
     for (let style of ["window-width", "window-height",
                        "content-height", "content-width",
                        "viewable-height", "viewable-width"]) {
       let index = stylesheet.insertRule("." + style + " {}", stylesheet.cssRules.length);
       this.styles[style] = stylesheet.cssRules[index].style;
     }
   },
@@ -342,17 +342,17 @@ var ContentAreaObserver = {
     return windowHeight;
   },
 
   _getViewableHeightForContent: function (contentHeight) {
     let keyboardHeight = Services.metro.keyboardHeight;
     return contentHeight - keyboardHeight;
   },
 
-  _debugDumpDims: function _debugDumpDims() {
+  _debugDumpDims: function() {
     let width = parseInt(this.styles["window-width"].width);
     let height = parseInt(this.styles["window-height"].height);
     Util.dumpLn("window:", width, height);
     width = parseInt(this.styles["content-width"].width);
     height = parseInt(this.styles["content-height"].height);
     Util.dumpLn("content:", width, height);
     width = parseInt(this.styles["viewable-width"].width);
     height = parseInt(this.styles["viewable-height"].height);
diff --git a/browser/metro/base/content/ContextCommands.js b/browser/metro/base/content/ContextCommands.js
--- a/browser/metro/base/content/ContextCommands.js
+++ b/browser/metro/base/content/ContextCommands.js
@@ -29,17 +29,17 @@ var ContextCommands = {
   },
 
   /*
    * Context menu handlers
    */
 
   // Text specific
 
-  cut: function cc_cut() {
+  cut: function() {
     let target = ContextMenuUI.popupState.target;
 
     if (!target) {
       return;
     }
 
     if (target.localName === "browser") {
       // content
@@ -51,17 +51,17 @@ var ContextCommands = {
     } else {
       // chrome
       CommandUpdater.doCommand("cmd_cut");
     }
 
     target.focus();
   },
 
-  copy: function cc_copy() {
+  copy: function() {
     let target = ContextMenuUI.popupState.target;
 
     if (!target) {
       return;
     }
 
     if (target.localName == "browser") {
       // content
@@ -73,17 +73,17 @@ var ContextCommands = {
     } else {
       // chrome
       CommandUpdater.doCommand("cmd_copy");
     }
 
     target.focus();
   },
 
-  paste: function cc_paste() {
+  paste: function() {
     let target = ContextMenuUI.popupState.target;
 
     if (!target) {
       return;
     }
 
     if (target.localName == "browser") {
       // content
@@ -94,48 +94,48 @@ var ContextCommands = {
     } else {
       // chrome
       CommandUpdater.doCommand("cmd_paste");
       target.focus();
     }
     SelectionHelperUI.closeEditSession();
   },
 
-  pasteAndGo: function cc_pasteAndGo() {
+  pasteAndGo: function() {
     let target = ContextMenuUI.popupState.target;
     target.editor.selectAll();
     target.editor.paste(Ci.nsIClipboard.kGlobalClipboard);
     BrowserUI.goToURI();
   },
 
-  select: function cc_select() {
+  select: function() {
     SelectionHelperUI.openEditSession(ContextMenuUI.popupState.target,
                                       ContextMenuUI.popupState.xPos,
                                       ContextMenuUI.popupState.yPos,
                                       true);
   },
 
-  selectAll: function cc_selectAll() {
+  selectAll: function() {
     let target = ContextMenuUI.popupState.target;
     if (target.localName == "browser") {
       // content
       let x = ContextMenuUI.popupState.xPos;
       let y = ContextMenuUI.popupState.yPos;
       let json = {x: x, y: y, command: "select-all" };
       target.messageManager.sendAsyncMessage("Browser:ContextCommand", json);
       SelectionHelperUI.attachEditSession(target, x, y);
     } else {
       // chrome
       target.editor.selectAll();
       target.focus();
     }
   },
 
   // called on display of the search text menu item
-  searchTextSetup: function cc_searchTextSetup(aRichListItem, aSearchString) {
+  searchTextSetup: function(aRichListItem, aSearchString) {
     let defaultURI;
     let defaultName;
     aSearchString = aSearchString.trim();
     try {
       let defaultPB = Services.prefs.getDefaultBranch(null);
       const nsIPLS = Ci.nsIPrefLocalizedString;
       defaultName = defaultPB.getComplexValue("browser.search.defaultenginename", nsIPLS).data;
       let defaultEngine = Services.search.getEngineByName(defaultName);
@@ -153,153 +153,153 @@ var ContextCommands = {
                         .createBundle("chrome://browser/locale/browser.properties")
                         .formatStringFromName("browser.search.contextTextSearchLabel2",
                                               [defaultName, displayString], 2);
     aRichListItem.childNodes[0].setAttribute("value", label);
     aRichListItem.setAttribute("searchString", defaultURI);
     return true;
   },
 
-  searchText: function cc_searchText(aRichListItem) {
+  searchText: function(aRichListItem) {
     let defaultURI = aRichListItem.getAttribute("searchString");
     aRichListItem.childNodes[0].setAttribute("value", "");
     aRichListItem.setAttribute("searchString", "");
     BrowserUI.addAndShowTab(defaultURI, Browser.selectedTab);
   },
 
   // Link specific
 
-  openLinkInNewTab: function cc_openLinkInNewTab() {
+  openLinkInNewTab: function() {
     let url = ContextMenuUI.popupState.linkURL;
     BrowserUI.openLinkInNewTab(url, false, Browser.selectedTab);
   },
 
-  copyLink: function cc_copyLink() {
+  copyLink: function() {
     this.clipboard.copyString(ContextMenuUI.popupState.linkURL,
                               this.docRef);
   },
 
-  bookmarkLink: function cc_bookmarkLink() {
+  bookmarkLink: function() {
     let state = ContextMenuUI.popupState;
     let uri = Util.makeURI(state.linkURL);
     let title = state.linkTitle || state.linkURL;
 
     try {
       Bookmarks.addForURI(uri, title);
     } catch (e) {
       return;
     }
   },
 
   // Image specific
 
-  saveImageToLib: function cc_saveImageToLib() {
+  saveImageToLib: function() {
     this.saveToWinLibrary("Pict");
   },
 
-  copyImage: function cc_copyImage() {
+  copyImage: function() {
     // copy to clibboard
     this.sendCommand("copy-image-contents");
   },
 
-  copyImageSrc: function cc_copyImageSrc() {
+  copyImageSrc: function() {
     this.clipboard.copyString(ContextMenuUI.popupState.mediaURL,
                               this.docRef);
   },
 
-  openImageInNewTab: function cc_openImageInNewTab() {
+  openImageInNewTab: function() {
     BrowserUI.addAndShowTab(ContextMenuUI.popupState.mediaURL, Browser.selectedTab);
   },
 
   // Video specific
 
-  saveVideoToLib: function cc_saveVideoToLib() {
+  saveVideoToLib: function() {
     this.saveToWinLibrary("Vids");
   },
 
-  copyVideoSrc: function cc_copyVideoSrc() {
+  copyVideoSrc: function() {
     this.clipboard.copyString(ContextMenuUI.popupState.mediaURL,
                               this.docRef);
   },
 
-  openVideoInNewTab: function cc_openVideoInNewTab() {
+  openVideoInNewTab: function() {
     BrowserUI.addAndShowTab(ContextMenuUI.popupState.mediaURL, Browser.selectedTab);
   },
 
   // Bookmarks
 
-  editBookmark: function cc_editBookmark() {
+  editBookmark: function() {
     let target = ContextMenuUI.popupState.target;
     target.startEditing();
   },
 
-  removeBookmark: function cc_removeBookmark() {
+  removeBookmark: function() {
     let target = ContextMenuUI.popupState.target;
     target.remove();
   },
 
   // App bar
 
-  errorConsole: function cc_errorConsole() {
+  errorConsole: function() {
     PanelUI.show("console-container");
   },
 
-  jsShell: function cc_jsShell() {
+  jsShell: function() {
     // XXX for debugging, this only works when running on the desktop.
     if (!Services.metro.immersive)
       window.openDialog("chrome://browser/content/shell.xul", "_blank",
                         "all=no,scrollbars=yes,resizable=yes,dialog=no");
   },
 
-  findInPage: function cc_findInPage() {
+  findInPage: function() {
     FindHelperUI.show();
   },
 
-  viewOnDesktop: function cc_viewOnDesktop() {
+  viewOnDesktop: function() {
     Appbar.onViewOnDesktop();
   },
 
   // Checks for MS app store specific meta data, and if present opens
   // the Windows Store to the appropriate app
-  openWindowsStoreLink: function cc_openWindowsStoreLink() {
+  openWindowsStoreLink: function() {
     let storeLink = this.getStoreLink();
     if (storeLink) {
       Browser.selectedBrowser.contentWindow.document.location = storeLink;
     }
   },
 
-  getStoreLink: function cc_getStoreLink() {
+  getStoreLink: function() {
     let metaData = Browser.selectedBrowser.contentWindow.document.getElementsByTagName("meta");
     let msApplicationName = metaData.namedItem("msApplication-PackageFamilyName");
     if (msApplicationName) {
       return "ms-windows-store:PDP?PFN=" + msApplicationName.getAttribute("content");
     }
     return null;
   },
 
-  getPageSource: function cc_getPageSource() {
+  getPageSource: function() {
     let uri = Services.io.newURI(Browser.selectedBrowser.currentURI.spec, null, null);
     if (!uri.schemeIs("view-source")) {
       return "view-source:" + Browser.selectedBrowser.currentURI.spec;
     }
     return null;
   },
 
-  viewPageSource: function cc_viewPageSource() {
+  viewPageSource: function() {
     let uri = this.getPageSource();
     if (uri) {
       BrowserUI.addAndShowTab(uri, Browser.selectedTab);
     }
   },
 
   /*
    * Utilities
    */
 
-  saveToWinLibrary: function cc_saveToWinLibrary(aType) {
+  saveToWinLibrary: function(aType) {
     let popupState = ContextMenuUI.popupState;
     let browser = popupState.target;
 
     // ContentAreaUtils internalSave relies on various desktop related prefs,
     // values, and functionality. We want to be more direct by saving the
     // image to the users Windows Library. If users want to specify the
     // save location they can use the context menu option 'Save (type) To'.
 
@@ -324,41 +324,41 @@ var ContextCommands = {
       targetFile        : saveLocationPath,
       sourceCacheKey    : null,
       sourcePostData    : null,
       bypassCache       : false,
       initiatingWindow  : this.docRef.defaultView
     });
   },
 
-  sendCommand: function sendCommand(aCommand) {
+  sendCommand: function(aCommand) {
     // Send via message manager over to ContextMenuHandler
     let browser = ContextMenuUI.popupState.target;
     browser.messageManager.sendAsyncMessage("Browser:ContextCommand", { command: aCommand });
   },
 
   /*
    * isAccessibleDirectory
    *
    * Test to see if the directory exists and is writable.
    */
-  isAccessibleDirectory: function isAccessibleDirectory(aDirectory) {
+  isAccessibleDirectory: function(aDirectory) {
     return aDirectory && aDirectory.exists() && aDirectory.isDirectory() &&
            aDirectory.isWritable();
   },
 
   /*
    * saveFileAs
    *
    * Browse for a location and then save a file to the local system using
    * standard download prefs.
    *
    * @param aFileUriString path to file
    */
-  saveFileAs: function saveFileAs(aPopupState) {
+  saveFileAs: function(aPopupState) {
     let srcUri = null;
     let mediaURL = aPopupState.mediaURL;
     try {
       srcUri = Util.makeURI(mediaURL, null, null);
     } catch (ex) {
       Util.dumpLn("could not parse:", mediaURL);
       return;
     }
@@ -397,17 +397,17 @@ var ContextCommands = {
       this._contentType = aPopupState.contentType;
       picker.open(ContextCommands);
     }.bind(this));
   },
 
   /*
    * Filepicker callback
    */
-  done: function done(aSuccess) {
+  done: function(aSuccess) {
     let picker = this._picker;
     this._picker = null;
 
     if (aSuccess == Ci.nsIFilePicker.returnCancel)
       return;
 
     let file = picker.file;
     if (file == null)
diff --git a/browser/metro/base/content/ContextUI.js b/browser/metro/base/content/ContextUI.js
--- a/browser/metro/base/content/ContextUI.js
+++ b/browser/metro/base/content/ContextUI.js
@@ -13,17 +13,17 @@ const kContextUITabsShowEvent = "MozCont
 var ContextUI = {
   _expandable: true,
   _hidingId: 0,
 
   /*******************************************
    * init
    */
 
-  init: function init() {
+  init: function() {
     Elements.browsers.addEventListener('URLChanged', this, true);
     Elements.browsers.addEventListener("AlertActive", this, true);
     Elements.browsers.addEventListener("AlertClose", this, true);
     Elements.tabList.addEventListener('TabSelect', this, true);
     Elements.panelUI.addEventListener('ToolPanelShown', this, false);
     Elements.panelUI.addEventListener('ToolPanelHidden', this, false);
 
     Elements.tray.addEventListener("mousemove", this, false);
@@ -149,17 +149,17 @@ var ContextUI = {
     }
 
     return dismissed;
   },
 
   /*
    * Briefly show the tab bar and then hide it. Fires context ui events.
    */
-  peekTabs: function peekTabs(aDelay) {
+  peekTabs: function(aDelay) {
     if (!this.tabbarVisible)
       this.displayTabs();
 
     ContextUI.dismissTabsWithDelay(aDelay);
   },
 
   /*
    * Dismiss tab bar after a delay. Fires context ui events.
@@ -191,56 +191,56 @@ var ContextUI = {
 
   // Display the tab tray
   displayTabs: function () {
     this._clearDelayedTimeout();
     this._setIsExpanded(true);
   },
 
   // Dismiss the navbar if visible.
-  dismissNavbar: function dismissNavbar() {
+  dismissNavbar: function() {
     if (!BrowserUI.isStartTabVisible) {
       Elements.autocomplete.closePopup();
       Elements.navbar.dismiss();
       Elements.chromeState.removeAttribute("navbar");
       ContentAreaObserver.updateContentArea();
     }
   },
 
   // Dismiss the tabstray if visible.
-  dismissTabs: function dimissTabs() {
+  dismissTabs: function() {
     this._clearDelayedTimeout();
     this._setIsExpanded(false);
   },
 
   // Dismiss the appbar if visible.
-  dismissContextAppbar: function dismissContextAppbar() {
+  dismissContextAppbar: function() {
     Elements.contextappbar.dismiss();
   },
 
   /*******************************************
    * Internal utils
    */
 
   // tabtray state
-  _setIsExpanded: function _setIsExpanded(aFlag, setSilently) {
+  _setIsExpanded: function(aFlag, setSilently) {
     // if the tray can't be expanded, don't expand it.
     if (!this.isExpandable || this.tabbarVisible == aFlag)
       return;
 
     if (aFlag)
       Elements.tray.setAttribute("expanded", "true");
     else
       Elements.tray.removeAttribute("expanded");
 
     if (!setSilently)
       this._fire(kContextUITabsShowEvent);
   },
 
-  _clearDelayedTimeout: function _clearDelayedTimeout() {
+  _clearDelayedTimeout: function() {
     if (this._hidingId) {
       clearTimeout(this._hidingId);
       this._hidingId = 0;
       this._delayedHide = false;
     }
   },
 
   _resetDelayedTimeout: function () {
@@ -269,17 +269,17 @@ var ContextUI = {
       this._hasEdgeSwipeStarted = false;
       return;
     }
 
     this._clearDelayedTimeout();
     this.toggleNavUI();
   },
 
-  onDownInput: function onDownInput(aEvent) {
+  onDownInput: function(aEvent) {
     if (!this.isVisible) {
       return;
     }
 
     // Various ui element containers we do not update context ui for.
     let whitelist = [
       // Clicks on tab bar elements should not close the tab bar. the tabbar
       // handles this.
@@ -320,17 +320,17 @@ var ContextUI = {
 
   onMouseLeave: function (aEvent) {
     if (this._delayedHide) {
       this._delayedHide = false;
       this._resetDelayedTimeout();
     }
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "URLChanged":
         // "aEvent.detail" is a boolean value that indicates whether actual URL
         // has changed ignoring URL fragment changes.
         if (aEvent.target == Browser.selectedBrowser && aEvent.detail) {
           this.displayNavbar();
         }
         break;
diff --git a/browser/metro/base/content/NavButtonSlider.js b/browser/metro/base/content/NavButtonSlider.js
--- a/browser/metro/base/content/NavButtonSlider.js
+++ b/browser/metro/base/content/NavButtonSlider.js
@@ -25,33 +25,33 @@ var NavButtonSlider = {
   get plus() {
     return this._plus;
   },
 
   /*
    * custom dragger, see input.js
    */
 
-  freeDrag: function freeDrag() {
+  freeDrag: function() {
     return true;
   },
 
-  isDraggable: function isDraggable(aTarget, aContent) {
+  isDraggable: function(aTarget, aContent) {
     return { x: false, y: true };
   },
 
-  dragStart: function dragStart(aX, aY, aTarget, aScroller) {
+  dragStart: function(aX, aY, aTarget, aScroller) {
     return true;
   },
 
-  dragStop: function dragStop(aDx, aDy, aScroller) {
+  dragStop: function(aDx, aDy, aScroller) {
     return true;
   },
 
-  dragMove: function dragMove(aDx, aDy, aScroller, aIsKenetic, aClientX, aClientY) {
+  dragMove: function(aDx, aDy, aScroller, aIsKenetic, aClientX, aClientY) {
     // Note if aIsKenetic is true this is synthetic movement,
     // we don't want that so return false.
     if (aIsKenetic) {
       return false;
     }
     
     this._updatePosition(aClientY);
 
@@ -59,17 +59,17 @@ var NavButtonSlider = {
     // is used in deciding if we should repaint between drags.
     return true;
   },
 
   /*
    * logic
    */
 
-  init: function init() {
+  init: function() {
     // Touch drag support provided by input.js
     this._back.customDragger = this;
     this._plus.customDragger = this;
     Elements.browsers.addEventListener("ContentSizeChanged", this, true);
     let events = ["mousedown", "mouseup", "mousemove", "click", "touchstart", "touchmove", "touchend"];
     events.forEach(function (value) {
       this._back.addEventListener(value, this, true);
       this._plus.addEventListener(value, this, true);
@@ -105,21 +105,21 @@ var NavButtonSlider = {
     // Check to see if we need to move the slider into view
     if (this._yPos != -1 &&
         (this._topStop > this._yPos || this._bottomStop < this._yPos)) {
       this._back.style.top = "50%";
       this._plus.style.top = "50%";
     }
   },
 
-  _getPosition: function _getPosition() {
+  _getPosition: function() {
     this._yPos = parseInt(getComputedStyle(this._back).top);
   },
 
-  _setPosition: function _setPosition() {
+  _setPosition: function() {
     this._back.style.top = this._yPos + "px";
     this._plus.style.top = this._yPos + "px";
   },
 
   _updatePosition: function (aClientY) {
     if (this._topStop > aClientY || this._bottomStop < aClientY)
       return;
     this._yPos = aClientY;
@@ -133,17 +133,17 @@ var NavButtonSlider = {
     this._yPos = newPos;
     this._setPosition();
   },
 
   /*
    * Events
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "ContentSizeChanged":
         this._updateStops();
         break;
 
       case "touchstart":
         if (aEvent.touches.length != 1)
           break;
diff --git a/browser/metro/base/content/TopSites.js b/browser/metro/base/content/TopSites.js
--- a/browser/metro/base/content/TopSites.js
+++ b/browser/metro/base/content/TopSites.js
@@ -143,16 +143,16 @@ let TopSites = {
       }
     }
     // clear out the cache, we'll fetch and re-render
     this._sites = null;
     this._sitesDirty.clear();
     this.update();
   },
 
-  _linkFromNode: function _linkFromNode(aNode) {
+  _linkFromNode: function(aNode) {
     return {
       url: aNode.getAttribute("value"),
       title: aNode.getAttribute("label")
     };
   }
 };
 
diff --git a/browser/metro/base/content/Util.js b/browser/metro/base/content/Util.js
--- a/browser/metro/base/content/Util.js
+++ b/browser/metro/base/content/Util.js
@@ -7,45 +7,45 @@ let Ci = Components.interfaces;
 
 Components.utils.import("resource:///modules/ContentUtil.jsm");
 
 let Util = {
   /*
    * General purpose utilities
    */
 
-  getWindowUtils: function getWindowUtils(aWindow) {
+  getWindowUtils: function(aWindow) {
     return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
   },
 
   // Put the Mozilla networking code into a state that will kick the
   // auto-connection process.
-  forceOnline: function forceOnline() {
+  forceOnline: function() {
     Services.io.offline = false;
   },
 
   /*
    * Timing utilties
    */
 
   // Executes aFunc after other events have been processed.
-  executeSoon: function executeSoon(aFunc) {
+  executeSoon: function(aFunc) {
     Services.tm.mainThread.dispatch({
       run: function() {
         aFunc();
       }
     }, Ci.nsIThread.DISPATCH_NORMAL);
   },
 
   /*
    * Console printing utilities
    */
 
   // Like dump, but each arg is handled and there's an automatic newline
-  dumpLn: function dumpLn() {
+  dumpLn: function() {
     for (let i = 0; i < arguments.length; i++)
       dump(arguments[i] + " ");
     dump("\n");
   },
 
   /*
    * Element utilities
    */
@@ -72,34 +72,34 @@ let Util = {
           defd.resolve(true);
         }
       }, false);
       pending++;
     });
     return defd.promise;
   },
 
-  isTextInput: function isTextInput(aElement) {
+  isTextInput: function(aElement) {
     return ((aElement instanceof Ci.nsIDOMHTMLInputElement &&
              aElement.mozIsTextField(false)) ||
             aElement instanceof Ci.nsIDOMHTMLTextAreaElement);
   },
 
   /**
    * Checks whether aElement's content can be edited either if it(or any of its
    * parents) has "contenteditable" attribute set to "true" or aElement's
    * ownerDocument is in design mode.
    */
-  isEditableContent: function isEditableContent(aElement) {
+  isEditableContent: function(aElement) {
     return !!aElement && (aElement.isContentEditable ||
                           this.isOwnerDocumentInDesignMode(aElement));
 
   },
 
-  isEditable: function isEditable(aElement) {
+  isEditable: function(aElement) {
     if (!aElement) {
       return false;
     }
 
     if (this.isTextInput(aElement) || this.isEditableContent(aElement)) {
       return true;
     }
 
@@ -118,67 +118,67 @@ let Util = {
   /**
    * Checks whether aElement's owner document has design mode turned on.
    */
   isOwnerDocumentInDesignMode: function(aElement) {
     return !!aElement && !!aElement.ownerDocument &&
            aElement.ownerDocument.designMode == "on";
   },
 
-  isMultilineInput: function isMultilineInput(aElement) {
+  isMultilineInput: function(aElement) {
     return (aElement instanceof Ci.nsIDOMHTMLTextAreaElement);
   },
 
-  isLink: function isLink(aElement) {
+  isLink: function(aElement) {
     return ((aElement instanceof Ci.nsIDOMHTMLAnchorElement && aElement.href) ||
             (aElement instanceof Ci.nsIDOMHTMLAreaElement && aElement.href) ||
             aElement instanceof Ci.nsIDOMHTMLLinkElement ||
             aElement.getAttributeNS(kXLinkNamespace, "type") == "simple");
   },
 
-  isText: function isText(aElement) {
+  isText: function(aElement) {
     return (aElement instanceof Ci.nsIDOMHTMLParagraphElement ||
             aElement instanceof Ci.nsIDOMHTMLDivElement ||
             aElement instanceof Ci.nsIDOMHTMLLIElement ||
             aElement instanceof Ci.nsIDOMHTMLPreElement ||
             aElement instanceof Ci.nsIDOMHTMLHeadingElement ||
             aElement instanceof Ci.nsIDOMHTMLTableCellElement ||
             aElement instanceof Ci.nsIDOMHTMLBodyElement);
   },
 
   /*
    * Rect and nsIDOMRect utilities
    */
 
-  getCleanRect: function getCleanRect() {
+  getCleanRect: function() {
     return {
       left: 0, top: 0, right: 0, bottom: 0
     };
   },
 
-  pointWithinRect: function pointWithinRect(aX, aY, aRect) {
+  pointWithinRect: function(aX, aY, aRect) {
     return (aRect.left < aX && aRect.top < aY &&
             aRect.right > aX && aRect.bottom > aY);
   },
 
-  pointWithinDOMRect: function pointWithinDOMRect(aX, aY, aRect) {
+  pointWithinDOMRect: function(aX, aY, aRect) {
     if (!aRect.width || !aRect.height)
       return false;
     return this.pointWithinRect(aX, aY, aRect);
   },
 
-  isEmptyDOMRect: function isEmptyDOMRect(aRect) {
+  isEmptyDOMRect: function(aRect) {
     if ((aRect.bottom - aRect.top) <= 0 &&
         (aRect.right - aRect.left) <= 0)
       return true;
     return false;
   },
 
   // Dumps the details of a dom rect to the console
-  dumpDOMRect: function dumpDOMRect(aMsg, aRect) {
+  dumpDOMRect: function(aMsg, aRect) {
     try {
       Util.dumpLn(aMsg,
                   "left:" + Math.round(aRect.left) + ",",
                   "top:" + Math.round(aRect.top) + ",",
                   "right:" + Math.round(aRect.right) + ",",
                   "bottom:" + Math.round(aRect.bottom) + ",",
                   "width:" + Math.round(aRect.right - aRect.left) + ",",
                   "height:" + Math.round(aRect.bottom - aRect.top) );
@@ -186,64 +186,64 @@ let Util = {
       Util.dumpLn("dumpDOMRect:", ex.message);
     }
   },
 
   /*
    * DownloadUtils.convertByteUnits returns [size, localized-unit-string]
    * so they are joined for a single download size string.
    */
-  getDownloadSize: function dv__getDownloadSize (aSize) {
+  getDownloadSize: function(aSize) {
     let [size, units] = DownloadUtils.convertByteUnits(aSize);
     if (aSize > 0)
       return size + units;
     else
       return Strings.browser.GetStringFromName("downloadsUnknownSize");
   },
 
   /*
    * URIs and schemes
    */
 
-  makeURI: function makeURI(aURL, aOriginCharset, aBaseURI) {
+  makeURI: function(aURL, aOriginCharset, aBaseURI) {
     return Services.io.newURI(aURL, aOriginCharset, aBaseURI);
   },
 
-  makeURLAbsolute: function makeURLAbsolute(base, url) {
+  makeURLAbsolute: function(base, url) {
     // Note:  makeURI() will throw if url is not a valid URI
     return this.makeURI(url, null, this.makeURI(base)).spec;
   },
 
-  isLocalScheme: function isLocalScheme(aURL) {
+  isLocalScheme: function(aURL) {
     return ((aURL.indexOf("about:") == 0 &&
              aURL != "about:blank" &&
              aURL != "about:empty" &&
              aURL != "about:start") ||
             aURL.indexOf("chrome:") == 0);
   },
 
   // Don't display anything in the urlbar for these special URIs.
-  isURLEmpty: function isURLEmpty(aURL) {
+  isURLEmpty: function(aURL) {
     return (!aURL ||
             aURL == "about:blank" ||
             aURL == "about:empty" ||
             aURL == "about:home" ||
             aURL == "about:newtab" ||
             aURL.startsWith("about:newtab"));
   },
 
   // Title to use for emptyURL tabs.
-  getEmptyURLTabTitle: function getEmptyURLTabTitle() {
+  getEmptyURLTabTitle: function() {
     let browserStrings = Services.strings.createBundle("chrome://browser/locale/browser.properties");
 
     return browserStrings.GetStringFromName("tabs.emptyTabTitle");
   },
 
   // Don't remember these pages in the session store.
-  isURLMemorable: function isURLMemorable(aURL) {
+  isURLMemorable: function(aURL) {
     return !(aURL == "about:blank" ||
              aURL == "about:empty" ||
              aURL == "about:start");
   },
 
   /*
    * Math utilities
    */
@@ -255,17 +255,17 @@ let Util = {
   /*
    * Screen and layout utilities
    */
 
    /*
     * translateToTopLevelWindow - Given an element potentially within
     * a subframe, calculate the offsets up to the top level browser.
     */
-  translateToTopLevelWindow: function translateToTopLevelWindow(aElement) {
+  translateToTopLevelWindow: function(aElement) {
     let offsetX = 0;
     let offsetY = 0;
     let element = aElement;
     while (element &&
            element.ownerDocument &&
            element.ownerDocument.defaultView != content) {
       element = element.ownerDocument.defaultView.frameElement;
       let rect = element.getBoundingClientRect();
@@ -287,17 +287,17 @@ let Util = {
 
   /*
    * aViewHeight - the height of the viewable area in the browser
    * aRect - a bounding rectangle of a selection or element.
    *
    * return - number of pixels for the browser to be shifted up by such
    * that aRect is centered vertically within aViewHeight.
    */
-  centerElementInView: function centerElementInView(aViewHeight, aRect) {
+  centerElementInView: function(aViewHeight, aRect) {
     // If the bottom of the target bounds is higher than the new height,
     // there's no need to adjust. It will be above the keyboard.
     if (aRect.bottom <= aViewHeight) {
       return 0;
     }
 
     // height of the target element
     let targetHeight = aRect.bottom - aRect.top;
@@ -321,17 +321,17 @@ let Util = {
       return distanceToCenter;
     }
   },
 
   /*
    * Local system utilities
    */
 
-  copyImageToClipboard: function Util_copyImageToClipboard(aImageLoadingContent) {
+  copyImageToClipboard: function(aImageLoadingContent) {
     let image = aImageLoadingContent.QueryInterface(Ci.nsIImageLoadingContent);
     if (!image) {
       Util.dumpLn("copyImageToClipboard error: image is not an nsIImageLoadingContent");
       return;
     }
     try {
       let xferable = Cc["@mozilla.org/widget/transferable;1"].createInstance(Ci.nsITransferable);
       xferable.init(null);
@@ -359,66 +359,66 @@ let Util = {
 Util.Timeout = function(aCallback) {
   this._callback = aCallback;
   this._timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
   this._type = null;
 };
 
 Util.Timeout.prototype = {
   // Timer callback. Don't call this manually.
-  notify: function notify() {
+  notify: function() {
     if (this._type == this._timer.TYPE_ONE_SHOT)
       this._type = null;
 
     if (this._callback.notify)
       this._callback.notify();
     else
       this._callback.apply(null);
   },
 
   // Helper function for once and interval.
-  _start: function _start(aDelay, aType, aCallback) {
+  _start: function(aDelay, aType, aCallback) {
     if (aCallback)
       this._callback = aCallback;
     this.clear();
     this._timer.initWithCallback(this, aDelay, aType);
     this._type = aType;
     return this;
   },
 
   // Do the callback once.  Cancels other timeouts on this object.
-  once: function once(aDelay, aCallback) {
+  once: function(aDelay, aCallback) {
     return this._start(aDelay, this._timer.TYPE_ONE_SHOT, aCallback);
   },
 
   // Do the callback every aDelay msecs. Cancels other timeouts on this object.
-  interval: function interval(aDelay, aCallback) {
+  interval: function(aDelay, aCallback) {
     return this._start(aDelay, this._timer.TYPE_REPEATING_SLACK, aCallback);
   },
 
   // Clear any pending timeouts.
-  clear: function clear() {
+  clear: function() {
     if (this.isPending()) {
       this._timer.cancel();
       this._type = null;
     }
     return this;
   },
 
   // If there is a pending timeout, call it and cancel the timeout.
-  flush: function flush() {
+  flush: function() {
     if (this.isPending()) {
       this.notify();
       this.clear();
     }
     return this;
   },
 
   // Return true if we are waiting for a callback.
-  isPending: function isPending() {
+  isPending: function() {
     return this._type !== null;
   }
 };
 
 // Mixin the ContentUtil module exports
 {
   for (let name in ContentUtil) {
     let copy = ContentUtil[name];
diff --git a/browser/metro/base/content/WebProgress.js b/browser/metro/base/content/WebProgress.js
--- a/browser/metro/base/content/WebProgress.js
+++ b/browser/metro/base/content/WebProgress.js
@@ -6,31 +6,31 @@
 const kHeartbeatDuration = 1000;
 // Start and end progress screen css margins as percentages
 const kProgressMarginStart = 30;
 const kProgressMarginEnd = 70;
 
 const WebProgress = {
   get _identityBox() { return document.getElementById("identity-box"); },
 
-  init: function init() {
+  init: function() {
     messageManager.addMessageListener("Content:StateChange", this);
     messageManager.addMessageListener("Content:LocationChange", this);
     messageManager.addMessageListener("Content:SecurityChange", this);
 
     Elements.progress.addEventListener("transitionend", this, true);
     Elements.tabList.addEventListener("TabSelect", this, true);
 
     let urlBar = document.getElementById("urlbar-edit");
     urlBar.addEventListener("input", this, false);
 
     return this;
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let json = aMessage.json;
     let tab = Browser.getTabForBrowser(aMessage.target);
 
     switch (aMessage.name) {
       case "Content:StateChange": {
         if (json.stateFlags & Ci.nsIWebProgressListener.STATE_IS_WINDOW) {
           if (json.stateFlags & Ci.nsIWebProgressListener.STATE_START)
             this._windowStart(json, tab);
@@ -58,48 +58,48 @@ const WebProgress = {
       case "Content:SecurityChange": {
         this._securityChange(json, tab);
         this._progressStep(tab);
         break;
       }
     }
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "transitionend":
         this._progressTransEnd(aEvent);
         break;
       case "TabSelect":
         this._onTabSelect(aEvent);
         break;
       case "input":
         this._onUrlBarInput(aEvent);
         break;
     }
   },
 
-  _securityChange: function _securityChange(aJson, aTab) {
+  _securityChange: function(aJson, aTab) {
     let state = aJson.state;
     let nsIWebProgressListener = Ci.nsIWebProgressListener;
 
     if (state & nsIWebProgressListener.STATE_IDENTITY_EV_TOPLEVEL) {
       aTab._identityState = "verifiedIdentity";
     } else if (state & nsIWebProgressListener.STATE_IS_SECURE) {
       aTab._identityState = "verifiedDomain";
     } else {
       aTab._identityState = "";
     }
 
     if (aTab == Browser.selectedTab) {
       this._identityBox.className = aTab._identityState;
     }
   },
 
-  _locationChange: function _locationChange(aJson, aTab) {
+  _locationChange: function(aJson, aTab) {
     let spec = aJson.location;
     let location = spec.split("#")[0]; // Ignore fragment identifier changes.
 
     if (aTab == Browser.selectedTab) {
       BrowserUI.updateURI();
       BrowserUI.update();
       BrowserUI.updateStartURIAttributes(aJson.location);
     }
@@ -117,44 +117,44 @@ const WebProgress = {
 #endif
     }
 
     let event = document.createEvent("UIEvents");
     event.initUIEvent("URLChanged", true, false, window, locationHasChanged);
     aTab.browser.dispatchEvent(event);
   },
 
-  _networkStart: function _networkStart(aJson, aTab) {
+  _networkStart: function(aJson, aTab) {
     aTab.startLoading();
 
     if (aTab == Browser.selectedTab) {
       // NO_STARTUI_VISIBILITY since the current uri for the tab has not
       // been updated yet. If we're coming off of the start page, this
       // would briefly show StartUI until _locationChange is called.
       BrowserUI.update(BrowserUI.NO_STARTUI_VISIBILITY);
     }
   },
 
-  _networkStop: function _networkStop(aJson, aTab) {
+  _networkStop: function(aJson, aTab) {
     aTab.endLoading();
 
     if (aTab == Browser.selectedTab) {
       BrowserUI.update();
     }
   },
 
-  _windowStart: function _windowStart(aJson, aTab) {
+  _windowStart: function(aJson, aTab) {
     this._progressStart(aJson, aTab);
   },
 
-  _windowStop: function _windowStop(aJson, aTab) {
+  _windowStop: function(aJson, aTab) {
     this._progressStop(aJson, aTab);
   },
 
-  _progressStart: function _progressStart(aJson, aTab) {
+  _progressStart: function(aJson, aTab) {
     // We will get multiple calls from _windowStart, so
     // only process once.
     if (aTab._progressActive)
       return;
 
     aTab._progressActive = true;
 
     // 'Whoosh' in
@@ -172,57 +172,57 @@ const WebProgress = {
 
     // Create a pulse timer to keep things moving even if we don't
     // collect any state changes.
     setTimeout(function() {
       WebProgress._progressStepTimer(aTab);
     }, kHeartbeatDuration, this);
   },
 
-  _stepProgressCount: function _stepProgressCount(aTab) {
+  _stepProgressCount: function(aTab) {
     // Step toward the end margin in smaller slices as we get closer
     let left = kProgressMarginEnd - aTab._progressCount;
     let step = left * .05;
     aTab._progressCount += Math.ceil(step);
 
     // Don't go past the 'whoosh out' margin.
     if (aTab._progressCount > kProgressMarginEnd) {
       aTab._progressCount = kProgressMarginEnd;
     }
   },
 
-  _progressStep: function _progressStep(aTab) {
+  _progressStep: function(aTab) {
     if (!aTab._progressActive)
       return;
     this._stepProgressCount(aTab);
     if (aTab == Browser.selectedTab) {
       Elements.progress.style.width = aTab._progressCount + "%";
     }
   },
 
-  _progressStepTimer: function _progressStepTimer(aTab) {
+  _progressStepTimer: function(aTab) {
     if (!aTab._progressActive)
       return;
     this._progressStep(aTab);
 
     setTimeout(function() {
       WebProgress._progressStepTimer(aTab);
     }, kHeartbeatDuration, this);
   },
 
-  _progressStop: function _progressStop(aJson, aTab) {
+  _progressStop: function(aJson, aTab) {
     aTab._progressActive = false;
     // 'Whoosh out' and fade
     if (aTab == Browser.selectedTab) {
       Elements.progress.style.width = "100%";
       Elements.progress.setAttribute("fade", true);
     }
   },
 
-  _progressTransEnd: function _progressTransEnd(aEvent) {
+  _progressTransEnd: function(aEvent) {
     if (!Elements.progress.hasAttribute("fade"))
       return;
     // Close out fade finished, reset
     if (aEvent.propertyName == "opacity") {
       Elements.progress.style.width = "0px";
       Elements.progressContainer.setAttribute("collapsed", true);
     }
   },
diff --git a/browser/metro/base/content/appbar.js b/browser/metro/base/content/appbar.js
--- a/browser/metro/base/content/appbar.js
+++ b/browser/metro/base/content/appbar.js
@@ -6,17 +6,17 @@
 var Appbar = {
   get starButton()    { return document.getElementById('star-button'); },
   get pinButton()     { return document.getElementById('pin-button'); },
   get menuButton()    { return document.getElementById('menu-button'); },
 
   // track selected/active richgrid/tilegroup - the context for contextual action buttons
   activeTileset: null,
 
-  init: function Appbar_init() {
+  init: function() {
     // fired from appbar bindings
     Elements.contextappbar.addEventListener('MozAppbarShowing', this, false);
     Elements.contextappbar.addEventListener('MozAppbarDismissing', this, false);
 
     // fired when a context sensitive item (bookmarks) changes state
     window.addEventListener('MozContextActionsChange', this, false);
 
     // browser events we need to update button state on
@@ -39,17 +39,17 @@ var Appbar = {
   observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "metro_on_async_tile_created":
         this._updatePinButton();
         break;
     }
   },
 
-  handleEvent: function Appbar_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case 'URLChanged':
       case 'TabSelect':
         this.update();
         this.flushActiveTileset(aEvent.lastTab);
         break;
 
       case 'MozAppbarShowing':
@@ -75,37 +75,37 @@ var Appbar = {
         let nodeName = aEvent.target.nodeName;
         if ('richgrid' === nodeName) {
           this._onTileSelectionChanged(aEvent);
         }
         break;
     }
   },
 
-  flushActiveTileset: function flushActiveTileset(aTab) {
+  flushActiveTileset: function(aTab) {
     try {
       let tab = aTab || Browser.selectedTab;
       // Switching away from or loading a site into a startui tab that has actions
       // pending, we consider this confirmation that the user wants to flush changes.
       if (this.activeTileset && tab && tab.browser && tab.browser.currentURI.spec == kStartURI) {
         ContextUI.dismiss();
       }
     } catch (ex) {}
   },
 
-  shutdown: function shutdown() {
+  shutdown: function() {
     this.flushActiveTileset();
   },
 
   /*
    * Called from various places when the visible content
    * has changed such that button states may need to be
    * updated.
    */
-  update: function update() {
+  update: function() {
     this._updatePinButton();
     this._updateStarButton();
   },
 
   onPinButton: function() {
     if (this.pinButton.checked) {
       Browser.pinSite();
     } else {
diff --git a/browser/metro/base/content/apzc.js b/browser/metro/base/content/apzc.js
--- a/browser/metro/base/content/apzc.js
+++ b/browser/metro/base/content/apzc.js
@@ -30,45 +30,45 @@ var APZCObserver = {
     let os = Services.obs;
     os.addObserver(this, "apzc-transform-begin", false);
 
     Elements.tabList.addEventListener("TabSelect", this, true);
     Elements.browsers.addEventListener("pageshow", this, true);
     messageManager.addMessageListener("Content:ZoomToRect", this);
   },
 
-  shutdown: function shutdown() {
+  shutdown: function() {
     if (!this._enabled) {
       return;
     }
 
     let os = Services.obs;
     os.removeObserver(this, "apzc-transform-begin");
 
     Elements.tabList.removeEventListener("TabSelect", this, true);
     Elements.browsers.removeEventListener("pageshow", this, true);
     messageManager.removeMessageListener("Content:ZoomToRect", this);
   },
 
-  handleEvent: function APZC_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case 'TabSelect':
         this._resetDisplayPort();
         break;
 
       case 'pageshow':
         if (aEvent.target != Browser.selectedBrowser.contentDocument) {
           break;
         }
         this._resetDisplayPort();
         break;
     }
   },
 
-  observe: function ao_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (aTopic == "apzc-transform-begin") {
       // When we're panning, hide the main scrollbars by setting imprecise
       // input (which sets a property on the browser which hides the scrollbar
       // via CSS).  This reduces jittering from left to right. We may be able
       // to get rid of this once we implement axis locking in /gfx APZC.
       if (InputSourceHelper.isPrecise) {
         InputSourceHelper._imprecise();
       }
diff --git a/browser/metro/base/content/bindings/browser.js b/browser/metro/base/content/bindings/browser.js
--- a/browser/metro/base/content/bindings/browser.js
+++ b/browser/metro/base/content/bindings/browser.js
@@ -22,28 +22,28 @@ let WebProgressListener = {
                 Ci.nsIWebProgress.NOTIFY_STATE_WINDOW |
                 Ci.nsIWebProgress.NOTIFY_STATE_NETWORK |
                 Ci.nsIWebProgress.NOTIFY_STATE_DOCUMENT;
 
     let webProgress = docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebProgress);
     webProgress.addProgressListener(this, flags);
   },
 
-  onStateChange: function onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+  onStateChange: function(aWebProgress, aRequest, aStateFlags, aStatus) {
     if (content != aWebProgress.DOMWindow)
       return;
 
     sendAsyncMessage("Content:StateChange", {
       contentWindowId: this.contentWindowId,
       stateFlags: aStateFlags,
       status: aStatus
     });
   },
 
-  onLocationChange: function onLocationChange(aWebProgress, aRequest, aLocationURI, aFlags) {
+  onLocationChange: function(aWebProgress, aRequest, aLocationURI, aFlags) {
     if (content != aWebProgress.DOMWindow)
       return;
 
     let spec = aLocationURI ? aLocationURI.spec : "";
     let location = spec.split("#")[0];
 
     let charset = content.document.characterSet;
 
@@ -68,20 +68,20 @@ let WebProgressListener = {
       removeEventListener("MozAfterPaint", arguments.callee, true);
 
       self._firstPaint = true;
       let scrollOffset = ContentScroll.getScrollOffset(content);
       sendAsyncMessage("Browser:FirstPaint", scrollOffset);
     }, true);
   },
 
-  onStatusChange: function onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {
+  onStatusChange: function(aWebProgress, aRequest, aStatus, aMessage) {
   },
 
-  onSecurityChange: function onSecurityChange(aWebProgress, aRequest, aState) {
+  onSecurityChange: function(aWebProgress, aRequest, aState) {
     if (content != aWebProgress.DOMWindow)
       return;
 
     let serialization = SecurityUI.getSSLStatusAsString();
 
     sendAsyncMessage("Content:SecurityChange", {
       contentWindowId: this.contentWindowId,
       SSLStatusAsString: serialization,
@@ -90,17 +90,17 @@ let WebProgressListener = {
   },
 
   get contentWindowId() {
     return content.QueryInterface(Ci.nsIInterfaceRequestor)
                   .getInterface(Ci.nsIDOMWindowUtils)
                   .currentInnerWindowID;
   },
 
-  QueryInterface: function QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIWebProgressListener) ||
         aIID.equals(Ci.nsISupportsWeakReference) ||
         aIID.equals(Ci.nsISupports)) {
         return this;
     }
 
     throw Components.results.NS_ERROR_NO_INTERFACE;
   }
@@ -193,17 +193,17 @@ let WebNavigation =  {
     this._webNavigation.reload(flags);
   },
 
   stop: function(message) {
     let flags = message.json.flags || this._webNavigation.STOP_ALL;
     this._webNavigation.stop(flags);
   },
 
-  _restoreHistory: function _restoreHistory(aTabData, aCount) {
+  _restoreHistory: function(aTabData, aCount) {
     // We need to wait for the sessionHistory to be initialized and there
     // is no good way to do this. We'll try a wait loop like desktop
     try {
       if (!this._webNavigation.sessionHistory)
         throw new Error();
     } catch (ex) {
       if (aCount < 10) {
         let self = this;
@@ -234,17 +234,17 @@ let WebNavigation =  {
 
     // We need to force set the active history item and cause it to reload since
     // we stop the load above
     let activeIndex = (aTabData.index || aTabData.entries.length) - 1;
     history.getEntryAtIndex(activeIndex, true);
     history.QueryInterface(Ci.nsISHistory).reloadCurrentEntry();
   },
 
-  _deserializeHistoryEntry: function _deserializeHistoryEntry(aEntry, aIdMap, aDocIdentMap) {
+  _deserializeHistoryEntry: function(aEntry, aIdMap, aDocIdentMap) {
     let shEntry = Cc["@mozilla.org/browser/session-history-entry;1"].createInstance(Ci.nsISHEntry);
 
     shEntry.setURI(Services.io.newURI(aEntry.url, null, null));
     shEntry.setTitle(aEntry.title || aEntry.url);
     if (aEntry.subframe)
       shEntry.setIsSubFrame(aEntry.subframe || false);
     shEntry.loadType = Ci.nsIDocShellLoadInfo.loadHistory;
     if (aEntry.contentType)
@@ -336,17 +336,17 @@ let WebNavigation =  {
 
         shEntry.AddChild(this._deserializeHistoryEntry(aEntry.children[i], aIdMap, childDocIdents), i);
       }
     }
     
     return shEntry;
   },
 
-  sendHistory: function sendHistory() {
+  sendHistory: function() {
     // We need to package up the session history and send it to the sessionstore
     let entries = [];
     let history = docShell.QueryInterface(Ci.nsIWebNavigation).sessionHistory;
     for (let i = 0; i < history.count; i++) {
       let entry = this._serializeHistoryEntry(history.getEntryAtIndex(i, false));
 
       // If someone directly navigates to one of these URLs and they switch to Desktop,
       // we need to make the page load-able.
@@ -354,17 +354,17 @@ let WebNavigation =  {
         entry.url = "about:newtab";
       }
       entries.push(entry);
     }
     let index = history.index + 1;
     sendAsyncMessage("Content:SessionHistory", { entries: entries, index: index });
   },
 
-  _serializeHistoryEntry: function _serializeHistoryEntry(aEntry) {
+  _serializeHistoryEntry: function(aEntry) {
     let entry = { url: aEntry.URI.spec };
 
     if (Util.isURLEmpty(entry.url)) {
       entry.title = Util.getEmptyURLTabTitle();
     } else {
       entry.title = aEntry.title;
     }
 
@@ -704,23 +704,23 @@ ContentActive.init();
  * show the prompts.
  */
 let IndexedDB = {
   _permissionsPrompt: "indexedDB-permissions-prompt",
   _permissionsResponse: "indexedDB-permissions-response",
 
   waitingObservers: [],
 
-  init: function IndexedDBPromptHelper_init() {
+  init: function() {
     let os = Services.obs;
     os.addObserver(this, this._permissionsPrompt, false);
     addMessageListener("IndexedDB:Response", this);
   },
 
-  observe: function IndexedDBPromptHelper_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (aTopic != this._permissionsPrompt) {
       throw new Error("Unexpected topic!");
     }
 
     let requestor = aSubject.QueryInterface(Ci.nsIInterfaceRequestor);
     let observer = requestor.getInterface(Ci.nsIObserver);
 
     let contentWindow = requestor.getInterface(Ci.nsIDOMWindow);
diff --git a/browser/metro/base/content/bindings/browser.xml b/browser/metro/base/content/bindings/browser.xml
--- a/browser/metro/base/content/bindings/browser.xml
+++ b/browser/metro/base/content/bindings/browser.xml
@@ -344,17 +344,17 @@
           // Resolution set by the apzc and is symmetric.
           return resx.value;
         ]]></getter>
       </property>
 
       <field name="_messageListenerLocal"><![CDATA[
         ({
           self: this,
-          receiveMessage: function receiveMessage(aMessage) {
+          receiveMessage: function(aMessage) {
             let self = this.self;
             let json = aMessage.json;
 
             switch (aMessage.name) {
               case "DOMPopupBlocked":
                 self.onPopupBlocked(aMessage);
                 break;
 
@@ -893,32 +893,32 @@
         ]]>
       </constructor>
 
       <field name="scrollSync">true</field>
 
       <field name="_messageListenerRemote"><![CDATA[
         ({
           self: this,
-          receiveMessage: function receiveMessage(aMessage) {
+          receiveMessage: function(aMessage) {
             let self = this.self;
             let json = aMessage.json;
 
             switch (aMessage.name) {
               case "scroll":
 	        if (!json.isRoot)
 		  return;
                 if (!self.scrollSync)
                   return;
                 this.doScroll(json.scrollOffset.x, json.scrollOffset.y, 0);
                 break;
            }
          },
 
-         doScroll: function doScroll(aX, aY, aCount) {
+         doScroll: function(aX, aY, aCount) {
             let self = this.self;
 
             // Use floor so that we always guarantee top-left corner of content is visible.
             let view = self.getRootView();
             view.scrollTo(Math.floor(aX * self.scale), Math.floor(aY * self.scale));
 
             let position = view.getPosition();
             if ((position.x != aX * self.scale || position.y != aY * self.scale) && aCount < 3) {
@@ -1185,17 +1185,17 @@
               this._updateCacheViewport();
           },
 
           scrollTo: function(x, y) {
             let contentView = this._contentView;
             this.scrollBy(x - contentView.scrollX, y - contentView.scrollY);
           },
 
-          _setScale: function _setScale(scale) {
+          _setScale: function(scale) {
             this._scale = scale;
             this._contentView.setScale(scale, scale);
           },
 
           getPosition: function() {
             let contentView = this._contentView;
             return { x: contentView.scrollX, y: contentView.scrollY };
           }
diff --git a/browser/metro/base/content/bookmarks.js b/browser/metro/base/content/bookmarks.js
--- a/browser/metro/base/content/bookmarks.js
+++ b/browser/metro/base/content/bookmarks.js
@@ -14,17 +14,17 @@ var Bookmarks = {
 
   logging: false,
   log: function(msg) {
     if (this.logging) {
       Services.console.logStringMessage(msg);
     }
   },
 
-  addForURI: function bh_addForURI(aURI, aTitle, callback) {
+  addForURI: function(aURI, aTitle, callback) {
     this.isURIBookmarked(aURI, function (isBookmarked) {
       if (isBookmarked)
         return;
 
       let bookmarkTitle = aTitle || aURI.spec;
       let bookmarkService = PlacesUtils.bookmarks;
       let bookmarkId = bookmarkService.insertBookmark(Bookmarks.metroRoot,
                                                       aURI,
@@ -40,25 +40,25 @@ var Bookmarks = {
         callback(bookmarkId);
     });
   },
 
   _isMetroBookmark: function(aItemId) {
     return PlacesUtils.bookmarks.getFolderIdForItem(aItemId) == Bookmarks.metroRoot;
   },
 
-  isURIBookmarked: function bh_isURIBookmarked(aURI, callback) {
+  isURIBookmarked: function(aURI, callback) {
     if (!callback)
       return;
     PlacesUtils.asyncGetBookmarkIds(aURI, aItemIds => {
       callback(aItemIds && aItemIds.length > 0 && aItemIds.some(this._isMetroBookmark));
     });
   },
 
-  removeForURI: function bh_removeForURI(aURI, callback) {
+  removeForURI: function(aURI, callback) {
     // XXX blargle xpconnect! might not matter, but a method on
     // nsINavBookmarksService that takes an array of items to
     // delete would be faster. better yet, a method that takes a URI!
     PlacesUtils.asyncGetBookmarkIds(aURI, (aItemIds) => {
       aItemIds.forEach((aItemId) => {
         if (this._isMetroBookmark(aItemId)) {
           PlacesUtils.bookmarks.removeItem(aItemId);
         }
diff --git a/browser/metro/base/content/browser-ui.js b/browser/metro/base/content/browser-ui.js
--- a/browser/metro/base/content/browser-ui.js
+++ b/browser/metro/base/content/browser-ui.js
@@ -224,29 +224,29 @@ var BrowserUI = {
       WindowsPrefSync.uninit();
     }
     this.stopDebugServer();
   },
 
   /************************************
    * Devtools Debugger
    */
-  runDebugServer: function runDebugServer(aPort) {
+  runDebugServer: function(aPort) {
     let port = aPort || Services.prefs.getIntPref(debugServerPortChanged);
     if (!DebuggerServer.initialized) {
       DebuggerServer.init();
       DebuggerServer.addBrowserActors();
       DebuggerServer.addActors('chrome://browser/content/dbg-metro-actors.js');
     }
     let listener = DebuggerServer.createListener();
     listener.portOrPath = port;
     listener.open();
   },
 
-  stopDebugServer: function stopDebugServer() {
+  stopDebugServer: function() {
     if (DebuggerServer.initialized) {
       DebuggerServer.destroy();
     }
   },
 
   // If the server is not on, port changes have nothing to effect. The new value
   //    will be picked up if the server is started.
   // To be consistent with desktop fx, if the port is changed while the server
@@ -261,17 +261,17 @@ var BrowserUI = {
   /*********************************
    * Content visibility
    */
 
   get isContentShowing() {
     return Elements.contentShowing.getAttribute("disabled") != true;
   },
 
-  showContent: function showContent(aURI) {
+  showContent: function(aURI) {
     ContextUI.dismissTabs();
     ContextUI.dismissContextAppbar();
     FlyoutPanelsUI.hide();
     PanelUI.hide();
   },
 
   /*********************************
    * Crash reporting
@@ -282,17 +282,17 @@ var BrowserUI = {
     Cu.import("resource://gre/modules/CrashSubmit.jsm", this);
     return this.CrashSubmit;
   },
 
   get lastCrashID() {
     return Cc["@mozilla.org/xre/runtime;1"].getService(Ci.nsIXULRuntime).lastRunCrashID;
   },
 
-  startupCrashCheck: function startupCrashCheck() {
+  startupCrashCheck: function() {
 #ifdef MOZ_CRASHREPORTER
     if (!CrashReporter.enabled) {
       return;
     }
 
     // Ensure that CrashReporter state matches pref
     CrashReporter.submitReports = Services.prefs.getBoolPref("app.crashreporter.autosubmit");
 
@@ -328,17 +328,17 @@ var BrowserUI = {
     let cleanURI = Util.isURLEmpty(uri) ? "" : uri;
     this._edit.value = cleanURI;
   },
 
   get isStartTabVisible() {
     return this.isStartURI();
   },
 
-  isStartURI: function isStartURI(aURI) {
+  isStartURI: function(aURI) {
     aURI = aURI || Browser.selectedBrowser.currentURI.spec;
     return aURI.startsWith(kStartURI) || aURI == "about:start" || aURI == "about:home";
   },
 
   updateStartURIAttributes: function (aURI) {
     let wasStart = Elements.windowState.hasAttribute("startpage");
     aURI = aURI || Browser.selectedBrowser.currentURI.spec;
     if (this.isStartURI(aURI)) {
@@ -401,17 +401,17 @@ var BrowserUI = {
                        Ci.nsIURIFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS;
       let uri = gURIFixup.createFixupURI(aURI, fixupFlags);
       gHistSvc.markPageAsTyped(uri);
 
       BrowserUI._titleChanged(Browser.selectedBrowser);
     });
   },
 
-  doOpenSearch: function doOpenSearch(aName) {
+  doOpenSearch: function(aName) {
     // save the current value of the urlbar
     let searchValue = this._edit.value;
     let engine = Services.search.getEngineByName(aName);
     let submission = engine.getSubmission(searchValue, null);
 
     this._edit.value = submission.uri.spec;
 
     // Make sure we're online before attempting to load
@@ -473,30 +473,30 @@ var BrowserUI = {
         charset: aOwner.browser.characterSet,
       };
     }
     let tab = Browser.addTab(aURI, aBringFront, aOwner, params);
     Elements.tabList.strip.ensureElementIsVisible(tab.chromeTab);
     return tab;
   },
 
-  setOnTabAnimationEnd: function setOnTabAnimationEnd(aCallback) {
+  setOnTabAnimationEnd: function(aCallback) {
     Elements.tabs.addEventListener("animationend", function onAnimationEnd() {
       Elements.tabs.removeEventListener("animationend", onAnimationEnd);
       aCallback();
     });
   },
 
-  closeTab: function closeTab(aTab) {
+  closeTab: function(aTab) {
     // If no tab is passed in, assume the current tab
     let tab = aTab || Browser.selectedTab;
     Browser.closeTab(tab);
   },
 
-  animateClosingTab: function animateClosingTab(tabToClose) {
+  animateClosingTab: function(tabToClose) {
     tabToClose.chromeTab.setAttribute("closing", "true");
 
     let wasCollapsed = !ContextUI.tabbarVisible;
     if (wasCollapsed) {
       ContextUI.displayTabs();
     }
 
     this.setOnTabAnimationEnd(function() {
@@ -507,122 +507,122 @@ var BrowserUI = {
   },
 
   /**
     * Re-open a closed tab.
     * @param aIndex
     *        The index of the tab (via nsSessionStore.getClosedTabData)
     * @returns a reference to the reopened tab.
     */
-  undoCloseTab: function undoCloseTab(aIndex) {
+  undoCloseTab: function(aIndex) {
     var tab = null;
     aIndex = aIndex || 0;
     var ss = Cc["@mozilla.org/browser/sessionstore;1"].
                 getService(Ci.nsISessionStore);
     if (ss.getClosedTabCount(window) > (aIndex)) {
       tab = ss.undoCloseTab(window, aIndex);
     }
     return tab;
   },
 
   // Useful for when we've received an event to close a particular DOM window.
   // Since we don't have windows, we want to close the corresponding tab.
-  closeTabForBrowser: function closeTabForBrowser(aBrowser) {
+  closeTabForBrowser: function(aBrowser) {
     // Find the relevant tab, and close it.
     let browsers = Browser.browsers;
     for (let i = 0; i < browsers.length; i++) {
       if (browsers[i] == aBrowser) {
         Browser.closeTab(Browser.getTabAtIndex(i));
         return { preventDefault: true };
       }
     }
 
     return {};
   },
 
-  selectTab: function selectTab(aTab) {
+  selectTab: function(aTab) {
     Browser.selectedTab = aTab;
   },
 
-  selectTabAndDismiss: function selectTabAndDismiss(aTab) {
+  selectTabAndDismiss: function(aTab) {
     this.selectTab(aTab);
     ContextUI.dismissTabsWithDelay(kChangeTabAnimationDelay);
   },
 
-  selectTabAtIndex: function selectTabAtIndex(aIndex) {
+  selectTabAtIndex: function(aIndex) {
     // count backwards for aIndex < 0
     if (aIndex < 0)
       aIndex += Browser._tabs.length;
 
     if (aIndex >= 0 && aIndex < Browser._tabs.length)
       Browser.selectedTab = Browser._tabs[aIndex];
   },
 
-  selectNextTab: function selectNextTab() {
+  selectNextTab: function() {
     if (Browser._tabs.length == 1 || !Browser.selectedTab) {
      return;
     }
 
     let tabIndex = Browser._tabs.indexOf(Browser.selectedTab) + 1;
     if (tabIndex >= Browser._tabs.length) {
       tabIndex = 0;
     }
 
     Browser.selectedTab = Browser._tabs[tabIndex];
   },
 
-  selectPreviousTab: function selectPreviousTab() {
+  selectPreviousTab: function() {
     if (Browser._tabs.length == 1 || !Browser.selectedTab) {
       return;
     }
 
     let tabIndex = Browser._tabs.indexOf(Browser.selectedTab) - 1;
     if (tabIndex < 0) {
       tabIndex = Browser._tabs.length - 1;
     }
 
     Browser.selectedTab = Browser._tabs[tabIndex];
   },
 
   // Used for when we're about to open a modal dialog,
   // and want to ensure the opening tab is in front.
-  selectTabForBrowser: function selectTabForBrowser(aBrowser) {
+  selectTabForBrowser: function(aBrowser) {
     for (let i = 0; i < Browser.tabs.length; i++) {
       if (Browser._tabs[i].browser == aBrowser) {
         Browser.selectedTab = Browser.tabs[i];
         break;
       }
     }
   },
 
-  updateUIFocus: function _updateUIFocus() {
+  updateUIFocus: function() {
     if (Elements.contentShowing.getAttribute("disabled") == "true" && Browser.selectedBrowser)
       Browser.selectedBrowser.messageManager.sendAsyncMessage("Browser:Blur", { });
   },
 
-  blurFocusedElement: function blurFocusedElement() {
+  blurFocusedElement: function() {
     let focusedElement = document.commandDispatcher.focusedElement;
     if (focusedElement)
       focusedElement.blur();
   },
 
-  blurNavBar: function blurNavBar() {
+  blurNavBar: function() {
     if (this._edit.focused) {
       this._edit.blur();
 
       // Advanced notice to CAO, so we can shuffle the nav bar in advance
       // of the keyboard transition.
       ContentAreaObserver.navBarWillBlur();
 
       return true;
     }
     return false;
   },
 
-  observe: function BrowserUI_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "handle-xul-text-link":
         let handled = aSubject.QueryInterface(Ci.nsISupportsPRBool);
         if (!handled.data) {
           this.addAndShowTab(aData, Browser.selectedTab);
           handled.data = true;
         }
         break;
@@ -702,65 +702,65 @@ var BrowserUI = {
       tabCaption = Util.getEmptyURLTabTitle();
     }
 
     let tab = Browser.getTabForBrowser(aBrowser);
     if (tab)
       tab.chromeTab.updateTitle(tabCaption);
   },
 
-  _updateButtons: function _updateButtons() {
+  _updateButtons: function() {
     let browser = Browser.selectedBrowser;
     if (!browser) {
       return;
     }
     if (browser.canGoBack) {
       this._back.removeAttribute("disabled");
     } else {
       this._back.setAttribute("disabled", true);
     }
     if (browser.canGoForward) {
       this._forward.removeAttribute("disabled");
     } else {
       this._forward.setAttribute("disabled", true);
     }
   },
 
-  _updateToolbar: function _updateToolbar() {
+  _updateToolbar: function() {
     if (Browser.selectedTab.isLoading()) {
       Elements.loadingState.setAttribute("loading", true);
     } else {
       Elements.loadingState.removeAttribute("loading");
     }
   },
 
-  _closeOrQuit: function _closeOrQuit() {
+  _closeOrQuit: function() {
     // Close active dialog, if we have one. If not then close the application.
     if (!BrowserUI.isContentShowing()) {
       BrowserUI.showContent();
     } else {
       // Check to see if we should really close the window
       if (Browser.closing()) {
         window.close();
         let appStartup = Cc["@mozilla.org/toolkit/app-startup;1"].getService(Ci.nsIAppStartup);
         appStartup.quit(Ci.nsIAppStartup.eForceQuit);
       }
     }
   },
 
-  _onPreciseInput: function _onPreciseInput() {
+  _onPreciseInput: function() {
     document.getElementById("bcast_preciseInput").setAttribute("input", "precise");
     let uri = Util.makeURI("chrome://browser/content/cursor.css");
     if (StyleSheetSvc.sheetRegistered(uri, Ci.nsIStyleSheetService.AGENT_SHEET)) {
       StyleSheetSvc.unregisterSheet(uri,
                                     Ci.nsIStyleSheetService.AGENT_SHEET);
     }
   },
 
-  _onImpreciseInput: function _onImpreciseInput() {
+  _onImpreciseInput: function() {
     document.getElementById("bcast_preciseInput").setAttribute("input", "imprecise");
     let uri = Util.makeURI("chrome://browser/content/cursor.css");
     if (!StyleSheetSvc.sheetRegistered(uri, Ci.nsIStyleSheetService.AGENT_SHEET)) {
       StyleSheetSvc.loadAndRegisterSheet(uri,
                                          Ci.nsIStyleSheetService.AGENT_SHEET);
     }
   },
 
@@ -771,17 +771,17 @@ var BrowserUI = {
     };
     return dimensions;
   },
 
   /*********************************
    * Event handling
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     var target = aEvent.target;
     switch (aEvent.type) {
       // Window events
       case "keypress":
         if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE)
           this.handleEscape(aEvent);
         break;
       case "MozPrecisePointer":
@@ -830,28 +830,28 @@ var BrowserUI = {
       return;
     }
 
     if (ContextUI.dismiss()) {
       return;
     }
   },
 
-  handleBackspace: function handleBackspace() {
+  handleBackspace: function() {
     switch (Services.prefs.getIntPref("browser.backspace_action")) {
       case 0:
         CommandUpdater.doCommand("cmd_back");
         break;
       case 1:
         CommandUpdater.doCommand("cmd_scrollPageUp");
         break;
     }
   },
 
-  handleShiftBackspace: function handleShiftBackspace() {
+  handleShiftBackspace: function() {
     switch (Services.prefs.getIntPref("browser.backspace_action")) {
       case 0:
         CommandUpdater.doCommand("cmd_forward");
         break;
       case 1:
         CommandUpdater.doCommand("cmd_scrollPageDown");
         break;
     }
@@ -878,17 +878,17 @@ var BrowserUI = {
       dump ('BrowserUI openFile exception: ' + ex + '\n');
     }
   },
 
   savePage: function() {
     Browser.savePage();
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let browser = aMessage.target;
     let json = aMessage.json;
     switch (aMessage.name) {
       case "DOMTitleChanged":
         this._titleChanged(browser);
         break;
       case "DOMWillOpenModalDialog":
         this.selectTabForBrowser(browser);
@@ -912,17 +912,17 @@ var BrowserUI = {
         }
         break;
       }
     }
 
     return {};
   },
 
-  shouldCaptureThumbnails: function shouldCaptureThumbnails(aTab) {
+  shouldCaptureThumbnails: function(aTab) {
     // Capture only if it's the currently selected tab.
     if (aTab != Browser.selectedTab) {
       return false;
     }
     // Skip private tabs
     if (aTab.isPrivate) {
       return false;
     }
@@ -1275,62 +1275,62 @@ var PanelUI = {
   uninit: function() {
     for each (let viewName in this.views) {
       let view = window[viewName];
       if (view.uninit)
         view.uninit();
     }
   },
 
-  switchPane: function switchPane(aPanelId) {
+  switchPane: function(aPanelId) {
     BrowserUI.blurFocusedElement();
 
     let panel = aPanelId ? document.getElementById(aPanelId) : this._panels.selectedPanel;
     let oldPanel = this._panels.selectedPanel;
 
     if (oldPanel != panel) {
       this._panels.selectedPanel = panel;
 
       this._fire("ToolPanelHidden", oldPanel);
     }
 
     this._fire("ToolPanelShown", panel);
   },
 
-  isPaneVisible: function isPaneVisible(aPanelId) {
+  isPaneVisible: function(aPanelId) {
     return this.isVisible && this._panels.selectedPanel.id == aPanelId;
   },
 
-  show: function show(aPanelId) {
+  show: function(aPanelId) {
     Elements.panelUI.hidden = false;
     Elements.contentShowing.setAttribute("disabled", "true");
 
     this.switchPane(aPanelId);
   },
 
-  hide: function hide() {
+  hide: function() {
     if (!this.isVisible)
       return;
 
     Elements.panelUI.hidden = true;
     Elements.contentShowing.removeAttribute("disabled");
     BrowserUI.blurFocusedElement();
 
     this._fire("ToolPanelHidden", this._panels);
   },
 
-  toggle: function toggle() {
+  toggle: function() {
     if (this.isVisible) {
       this.hide();
     } else {
       this.show();
     }
   },
 
-  _fire: function _fire(aName, anElement) {
+  _fire: function(aName, anElement) {
     let event = document.createEvent("Events");
     event.initEvent(aName, true, true);
     anElement.dispatchEvent(event);
   }
 };
 
 var DialogUI = {
   _popup: null,
@@ -1338,31 +1338,31 @@ var DialogUI = {
   init: function() {
     window.addEventListener("mousedown", this, true);
   },
 
   /*******************************************
    * Popups
    */
 
-  pushPopup: function pushPopup(aPanel, aElements, aParent) {
+  pushPopup: function(aPanel, aElements, aParent) {
     this._hidePopup();
     this._popup =  { "panel": aPanel,
                      "elements": (aElements instanceof Array) ? aElements : [aElements] };
     this._dispatchPopupChanged(true, aPanel);
   },
 
-  popPopup: function popPopup(aPanel) {
+  popPopup: function(aPanel) {
     if (!this._popup || aPanel != this._popup.panel)
       return;
     this._popup = null;
     this._dispatchPopupChanged(false, aPanel);
   },
 
-  _hidePopup: function _hidePopup() {
+  _hidePopup: function() {
     if (!this._popup)
       return;
     let panel = this._popup.panel;
     if (panel.hide)
       panel.hide();
   },
 
   /*******************************************
@@ -1375,23 +1375,23 @@ var DialogUI = {
         if (!this._isEventInsidePopup(aEvent))
           this._hidePopup();
         break;
       default:
         break;
     }
   },
 
-  _dispatchPopupChanged: function _dispatchPopupChanged(aVisible, aElement) {
+  _dispatchPopupChanged: function(aVisible, aElement) {
     let event = document.createEvent("UIEvents");
     event.initUIEvent("PopupChanged", true, true, window, aVisible);
     aElement.dispatchEvent(event);
   },
 
-  _isEventInsidePopup: function _isEventInsidePopup(aEvent) {
+  _isEventInsidePopup: function(aEvent) {
     if (!this._popup)
       return false;
     let elements = this._popup.elements;
     let targetNode = aEvent.target;
     while (targetNode && elements.indexOf(targetNode) == -1) {
       if (targetNode instanceof Element && targetNode.hasAttribute("for"))
         targetNode = document.getElementById(targetNode.getAttribute("for"));
       else
diff --git a/browser/metro/base/content/browser.js b/browser/metro/base/content/browser.js
--- a/browser/metro/base/content/browser.js
+++ b/browser/metro/base/content/browser.js
@@ -48,17 +48,17 @@ var Browser = {
   _tabId: 0,
   windowUtils: window.QueryInterface(Ci.nsIInterfaceRequestor)
                      .getInterface(Ci.nsIDOMWindowUtils),
 
   get defaultBrowserWidth() {
     return window.innerWidth;
   },
 
-  startup: function startup() {
+  startup: function() {
     var self = this;
 
     try {
       messageManager.loadFrameScript("chrome://browser/content/Util.js", true);
       messageManager.loadFrameScript("chrome://browser/content/contenthandlers/Content.js", true);
       messageManager.loadFrameScript("chrome://browser/content/contenthandlers/FormHelper.js", true);
       messageManager.loadFrameScript("chrome://browser/content/library/SelectionPrototype.js", true);
       messageManager.loadFrameScript("chrome://browser/content/contenthandlers/SelectionHandler.js", true);
@@ -220,17 +220,17 @@ var Browser = {
 
       // Broadcast a UIReady message so add-ons know we are finished with startup
       let event = document.createEvent("Events");
       event.initEvent("UIReady", true, false);
       window.dispatchEvent(event);
     }.bind(this));
   },
 
-  shutdown: function shutdown() {
+  shutdown: function() {
     APZCObserver.shutdown();
     BrowserUI.uninit();
     ClickEventHandler.uninit();
     ContentAreaObserver.shutdown();
     Appbar.shutdown();
 
     messageManager.removeMessageListener("Browser:FormSubmit", this);
     messageManager.removeMessageListener("scroll", this);
@@ -238,17 +238,17 @@ var Browser = {
     messageManager.removeMessageListener("Browser:BlockedSite", this);
 
     Services.obs.removeObserver(SessionHistoryObserver, "browser:purge-session-history");
 
     window.controllers.removeController(this);
     window.controllers.removeController(BrowserUI);
   },
 
-  getHomePage: function getHomePage(aOptions) {
+  getHomePage: function(aOptions) {
     aOptions = aOptions || { useDefault: false };
 
     let url = kStartURI;
     try {
       let prefs = aOptions.useDefault ? Services.prefs.getDefaultBranch(null) : Services.prefs;
       url = prefs.getComplexValue("browser.startup.homepage", Ci.nsIPrefLocalizedString).data;
     }
     catch(e) { }
@@ -261,17 +261,17 @@ var Browser = {
   },
 
   /**
    * Load a URI in the current tab, or a new tab if necessary.
    * @param aURI String
    * @param aParams Object with optional properties that will be passed to loadURIWithFlags:
    *    flags, referrerURI, charset, postData.
    */
-  loadURI: function loadURI(aURI, aParams) {
+  loadURI: function(aURI, aParams) {
     let browser = this.selectedBrowser;
 
     // We need to keep about: pages opening in new "local" tabs. We also want to spawn
     // new "remote" tabs if opening web pages from a "local" about: page.
     dump("loadURI=" + aURI + "\ncurrentURI=" + browser.currentURI.spec + "\n");
 
     let params = aParams || {};
     try {
@@ -288,17 +288,17 @@ var Browser = {
 
   /**
    * Determine if the given URL is a shortcut/keyword and, if so, expand it
    * @param aURL String
    * @param aPostDataRef Out param contains any required post data for a search
    * @return {Promise}
    * @result the expanded shortcut, or the original URL if not a shortcut
    */
-  getShortcutOrURI: function getShortcutOrURI(aURL, aPostDataRef) {
+  getShortcutOrURI: function(aURL, aPostDataRef) {
     return Task.spawn(function() {
       if (!aURL)
         throw new Task.Result(aURL);
 
       let shortcutURL = null;
       let keyword = aURL;
       let param = "";
 
@@ -416,54 +416,54 @@ var Browser = {
           let prompts = Array.slice(els);
           return prompts;
       },
     };
 
     return promptBox;
   },
 
-  getBrowserForWindowId: function getBrowserForWindowId(aWindowId) {
+  getBrowserForWindowId: function(aWindowId) {
     for (let i = 0; i < this.browsers.length; i++) {
       if (this.browsers[i].contentWindowId == aWindowId)
         return this.browsers[i];
     }
     return null;
   },
 
   getBrowserForWindow: function(aWindow) {
     let windowID = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                           .getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
     return this.getBrowserForWindowId(windowID);
   },
 
-  getTabForBrowser: function getTabForBrowser(aBrowser) {
+  getTabForBrowser: function(aBrowser) {
     let tabs = this._tabs;
     for (let i = 0; i < tabs.length; i++) {
       if (tabs[i].browser == aBrowser)
         return tabs[i];
     }
     return null;
   },
 
-  getTabAtIndex: function getTabAtIndex(index) {
+  getTabAtIndex: function(index) {
     if (index >= this._tabs.length || index < 0)
       return null;
     return this._tabs[index];
   },
 
-  getTabFromChrome: function getTabFromChrome(chromeTab) {
+  getTabFromChrome: function(chromeTab) {
     for (var t = 0; t < this._tabs.length; t++) {
       if (this._tabs[t].chromeTab == chromeTab)
         return this._tabs[t];
     }
     return null;
   },
 
-  createTabId: function createTabId() {
+  createTabId: function() {
     return this._tabId++;
   },
 
   /**
    * Create a new tab and add it to the tab list.
    *
    * If you are opening a new foreground tab in response to a user action, use
    * BrowserUI.addAndShowTab which will also show the tab strip.
@@ -473,17 +473,17 @@ var Browser = {
    * @param aOwner Tab object (optional) The "parent" of the new tab.
    *   This is the tab responsible for opening the new tab.  When the new tab
    *   is closed, we will return to a parent or "sibling" tab if possible.
    * @param aParams Object (optional) with optional properties:
    *   index: Number specifying where in the tab list to insert the new tab.
    *   private: If true, the new tab should be have Private Browsing active.
    *   flags, postData, charset, referrerURI: See loadURIWithFlags.
    */
-  addTab: function browser_addTab(aURI, aBringFront, aOwner, aParams) {
+  addTab: function(aURI, aBringFront, aOwner, aParams) {
     let params = aParams || {};
 
     if (aOwner && !('index' in params)) {
       // Position the new tab to the right of its owner...
       params.index = this._tabs.indexOf(aOwner) + 1;
       // ...and to the right of any siblings.
       while (this._tabs[params.index] && this._tabs[params.index].owner == aOwner) {
         params.index++;
@@ -500,17 +500,17 @@ var Browser = {
 
     if (aBringFront)
       this.selectedTab = newTab;
 
     this._announceNewTab(newTab);
     return newTab;
   },
 
-  closeTab: function closeTab(aTab, aOptions) {
+  closeTab: function(aTab, aOptions) {
     let tab = aTab instanceof XULElement ? this.getTabFromChrome(aTab) : aTab;
     if (!tab) {
       return;
     }
 
     if (aOptions && "forceClose" in aOptions && aOptions.forceClose) {
       this._doCloseTab(tab);
       return;
@@ -529,17 +529,17 @@ var Browser = {
    */
   _announceNewTab: function (aTab) {
     let event = document.createEvent("UIEvents");
     event.initUIEvent("TabOpen", true, false, window, 0);
     aTab.chromeTab.dispatchEvent(event);
     aTab.browser.messageManager.sendAsyncMessage("Browser:TabOpen");
   },
 
-  _doCloseTab: function _doCloseTab(aTab) {
+  _doCloseTab: function(aTab) {
     if (this._tabs.length === 1) {
       Browser.addTab(this.getHomePage());
     }
 
     let nextTab = this.getNextTab(aTab);
 
     // Tabs owned by the closed tab are now orphaned.
     this._tabs.forEach(function(item, index, array) {
@@ -565,17 +565,17 @@ var Browser = {
 
     this.selectedTab = nextTab;
 
     event = document.createEvent("Events");
     event.initEvent("TabRemove", true, false);
     container.dispatchEvent(event);
   },
 
-  getNextTab: function getNextTab(aTab) {
+  getNextTab: function(aTab) {
     let tabIndex = this._tabs.indexOf(aTab);
     if (tabIndex == -1)
       return null;
 
     if (this._selectedTab == aTab || this._selectedTab.chromeTab.hasAttribute("closing")) {
       let nextTabIndex = tabIndex + 1;
       let nextTab = null;
 
@@ -659,25 +659,25 @@ var Browser = {
 
   isCommandEnabled: function(cmd) {
     return false;
   },
 
   doCommand: function(cmd) {
   },
 
-  getNotificationBox: function getNotificationBox(aBrowser) {
+  getNotificationBox: function(aBrowser) {
     let browser = aBrowser || this.selectedBrowser;
     return browser.parentNode.parentNode;
   },
 
   /**
    * Handle cert exception message from content.
    */
-  _handleCertException: function _handleCertException(aMessage) {
+  _handleCertException: function(aMessage) {
     let json = aMessage.json;
     if (json.action == "leave") {
       // Get the start page from the *default* pref branch, not the user's
       let url = Browser.getHomePage({ useDefault: true });
       this.loadURI(url);
     } else {
       // Handle setting an cert exception and reloading the page
       try {
@@ -696,17 +696,17 @@ var Browser = {
       // Automatically reload after the exception was added
       aMessage.target.reload();
     }
   },
 
   /**
    * Handle blocked site message from content.
    */
-  _handleBlockedSite: function _handleBlockedSite(aMessage) {
+  _handleBlockedSite: function(aMessage) {
     let formatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"].getService(Ci.nsIURLFormatter);
     let json = aMessage.json;
     switch (json.action) {
       case "leave": {
         // Get the start page from the *default* pref branch, not the user's
         let url = Browser.getHomePage({ useDefault: true });
         this.loadURI(url);
         break;
@@ -726,17 +726,17 @@ var Browser = {
         // It's a phishing site, just link to the generic information page
         let url = Services.urlFormatter.formatURLPref("app.support.baseURL");
         this.loadURI(url + "phishing-malware");
         break;
       }
     }
   },
 
-  pinSite: function browser_pinSite() {
+  pinSite: function() {
     // Get a path to our app tile
     var file = Components.classes["@mozilla.org/file/directory_service;1"].
            getService(Components.interfaces.nsIProperties).
            get("CurProcD", Components.interfaces.nsIFile);
     // Get rid of the current working directory's metro subidr
     file = file.parent;
     file.append("tileresources");
     file.append("VisualElements_logo.png");
@@ -759,66 +759,66 @@ var Browser = {
                        createInstance(Ci.nsIStringInputStream);
     stringStream.data = Browser.selectedBrowser.currentURI.spec;
     hasher.updateFromStream(stringStream, -1);
     let hashASCII = hasher.finish(true);
     // Replace '/' with a valid filesystem character
     return ("FFTileID_" + hashASCII).replace(/\//g, '_');
   },
 
-  unpinSite: function browser_unpinSite() {
+  unpinSite: function() {
     if (!Services.metro.immersive)
       return;
 
     Services.metro.unpinTileAsync(this._currentPageTileID);
   },
 
-  isSitePinned: function browser_isSitePinned() {
+  isSitePinned: function() {
     if (!Services.metro.immersive)
       return false;
 
     return Services.metro.isTilePinned(this._currentPageTileID);
   },
 
-  starSite: function browser_starSite(callback) {
+  starSite: function(callback) {
     let uri = this.selectedBrowser.currentURI;
     let title = this.selectedBrowser.contentTitle;
 
     Bookmarks.addForURI(uri, title, callback);
   },
 
-  unstarSite: function browser_unstarSite(callback) {
+  unstarSite: function(callback) {
     let uri = this.selectedBrowser.currentURI;
     Bookmarks.removeForURI(uri, callback);
   },
 
-  isSiteStarredAsync: function browser_isSiteStarredAsync(callback) {
+  isSiteStarredAsync: function(callback) {
     let uri = this.selectedBrowser.currentURI;
     Bookmarks.isURIBookmarked(uri, callback);
   },
 
   /**
    * Convenience function for getting the scrollbox position off of a
    * scrollBoxObject interface.  Returns the actual values instead of the
    * wrapping objects.
    *
    * @param scroller a scrollBoxObject on which to call scroller.getPosition()
    */
-  getScrollboxPosition: function getScrollboxPosition(scroller) {
+  getScrollboxPosition: function(scroller) {
     let x = {};
     let y = {};
     scroller.getPosition(x, y);
     return new Point(x.value, y.value);
   },
 
-  forceChromeReflow: function forceChromeReflow() {
+  forceChromeReflow: function() {
     let dummy = getComputedStyle(document.documentElement, "").width;
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let json = aMessage.json;
     let browser = aMessage.target;
 
     switch (aMessage.name) {
       case "DOMLinkAdded": {
         // checks for an icon to use for a web app
         // apple-touch-icon size is 57px and default size is 16px
         let rel = json.rel.toLowerCase().split(" ");
@@ -874,46 +874,46 @@ Browser.MainDragger = function MainDragg
   this._verticalScrollbar = document.getElementById("vertical-scroller");
   this._scrollScales = { x: 0, y: 0 };
 
   Elements.browsers.addEventListener("PanBegin", this, false);
   Elements.browsers.addEventListener("PanFinished", this, false);
 };
 
 Browser.MainDragger.prototype = {
-  isDraggable: function isDraggable(target, scroller) {
+  isDraggable: function(target, scroller) {
     return { x: true, y: true };
   },
 
-  dragStart: function dragStart(clientX, clientY, target, scroller) {
+  dragStart: function(clientX, clientY, target, scroller) {
     let browser = getBrowser();
     let bcr = browser.getBoundingClientRect();
     this._contentView = browser.getViewAt(clientX - bcr.left, clientY - bcr.top);
   },
 
-  dragStop: function dragStop(dx, dy, scroller) {
+  dragStop: function(dx, dy, scroller) {
     if (this._contentView && this._contentView._updateCacheViewport)
       this._contentView._updateCacheViewport();
     this._contentView = null;
   },
 
-  dragMove: function dragMove(dx, dy, scroller, aIsKinetic) {
+  dragMove: function(dx, dy, scroller, aIsKinetic) {
     let doffset = new Point(dx, dy);
 
     this._panContent(doffset);
 
     if (aIsKinetic && doffset.x != 0)
       return false;
 
     this._updateScrollbars();
 
     return !doffset.equals(dx, dy);
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     let browser = getBrowser();
     switch (aEvent.type) {
       case "PanBegin": {
         let width = ContentAreaObserver.width, height = ContentAreaObserver.height;
         let contentWidth = browser.contentDocumentWidth * browser.scale;
         let contentHeight = browser.contentDocumentHeight * browser.scale;
 
         // Allow a small margin on both sides to prevent adding scrollbars
@@ -932,66 +932,66 @@ Browser.MainDragger.prototype = {
         this._hideScrollbars();
 
         // Update the scroll position of the content
         browser._updateCSSViewport();
         break;
     }
   },
 
-  _panContent: function md_panContent(aOffset) {
+  _panContent: function(aOffset) {
     if (this._contentView && !this._contentView.isRoot()) {
       this._panContentView(this._contentView, aOffset);
       // XXX we may need to have "escape borders" for iframe panning
       // XXX does not deal with scrollables within scrollables
     }
     // Do content panning
     this._panContentView(getBrowser().getRootView(), aOffset);
   },
 
   /** Pan scroller by the given amount. Updates doffset with leftovers. */
-  _panContentView: function _panContentView(contentView, doffset) {
+  _panContentView: function(contentView, doffset) {
     let pos0 = contentView.getPosition();
     contentView.scrollBy(doffset.x, doffset.y);
     let pos1 = contentView.getPosition();
     doffset.subtract(pos1.x - pos0.x, pos1.y - pos0.y);
   },
 
-  _updateScrollbars: function _updateScrollbars() {
+  _updateScrollbars: function() {
     let scaleX = this._scrollScales.x, scaleY = this._scrollScales.y;
     let contentScroll = Browser.getScrollboxPosition(Browser.contentScrollboxScroller);
 
     if (scaleX)
       this._horizontalScrollbar.style.MozTransform =
         "translateX(" + Math.round(contentScroll.x * scaleX) + "px)";
 
     if (scaleY) {
       let y = Math.round(contentScroll.y * scaleY);
       let x = 0;
 
       this._verticalScrollbar.style.MozTransform =
         "translate(" + x + "px," + y + "px)";
     }
   },
 
-  _showScrollbars: function _showScrollbars() {
+  _showScrollbars: function() {
     this._updateScrollbars();
     let scaleX = this._scrollScales.x, scaleY = this._scrollScales.y;
     if (scaleX) {
       this._horizontalScrollbar.width = ContentAreaObserver.width * scaleX;
       this._horizontalScrollbar.setAttribute("panning", "true");
     }
 
     if (scaleY) {
       this._verticalScrollbar.height = ContentAreaObserver.height * scaleY;
       this._verticalScrollbar.setAttribute("panning", "true");
     }
   },
 
-  _hideScrollbars: function _hideScrollbars() {
+  _hideScrollbars: function() {
     this._scrollScales.x = 0;
     this._scrollScales.y = 0;
     this._horizontalScrollbar.removeAttribute("panning");
     this._verticalScrollbar.removeAttribute("panning");
     this._horizontalScrollbar.removeAttribute("width");
     this._verticalScrollbar.removeAttribute("height");
     this._horizontalScrollbar.style.MozTransform = "";
     this._verticalScrollbar.style.MozTransform = "";
@@ -1003,17 +1003,17 @@ function nsBrowserAccess() { }
 
 nsBrowserAccess.prototype = {
   QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIBrowserDOMWindow) || aIID.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_NOINTERFACE;
   },
 
-  _getOpenAction: function _getOpenAction(aURI, aOpener, aWhere, aContext) {
+  _getOpenAction: function(aURI, aOpener, aWhere, aContext) {
     let where = aWhere;
     /*
      * aWhere:
      * OPEN_DEFAULTWINDOW: default action
      * OPEN_CURRENTWINDOW: current window/tab
      * OPEN_NEWWINDOW: not allowed, converted to newtab below
      * OPEN_NEWTAB: open a new tab
      * OPEN_SWITCHTAB: open in an existing tab if it matches, otherwise open
@@ -1033,17 +1033,17 @@ nsBrowserAccess.prototype = {
     }
     if (where == Ci.nsIBrowserDOMWindow.OPEN_NEWWINDOW) {
       Util.dumpLn("Invalid request - we can't open links in new windows.");
       where = Ci.nsIBrowserDOMWindow.OPEN_NEWTAB;
     }
     return where;
   },
 
-  _getBrowser: function _getBrowser(aURI, aOpener, aWhere, aContext) {
+  _getBrowser: function(aURI, aOpener, aWhere, aContext) {
     let isExternal = (aContext == Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
     // We don't allow externals apps opening chrome docs
     if (isExternal && aURI && aURI.schemeIs("chrome"))
       return null;
 
     let location;
     let browser;
     let loadflags = isExternal ?
@@ -1069,51 +1069,51 @@ nsBrowserAccess.prototype = {
         browser.loadURIWithFlags(aURI.spec, loadflags, referrer, null, null);
       }
       browser.focus();
     } catch(e) { }
 
     return browser;
   },
 
-  openURI: function browser_openURI(aURI, aOpener, aWhere, aContext) {
+  openURI: function(aURI, aOpener, aWhere, aContext) {
     let browser = this._getBrowser(aURI, aOpener, aWhere, aContext);
     return browser ? browser.contentWindow : null;
   },
 
-  openURIInFrame: function browser_openURIInFrame(aURI, aParams, aWhere, aContext) {
+  openURIInFrame: function(aURI, aParams, aWhere, aContext) {
     let browser = this._getBrowser(aURI, null, aWhere, aContext);
     return browser ? browser.QueryInterface(Ci.nsIFrameLoaderOwner) : null;
   },
 
   isTabContentWindow: function(aWindow) {
     return Browser.browsers.some(function (browser) browser.contentWindow == aWindow);
   },
 };
 
 /**
  * Handler for blocked popups, triggered by DOMUpdatePageReport events in browser.xml
  */
 var PopupBlockerObserver = {
-  init: function init() {
+  init: function() {
     Elements.browsers.addEventListener("mousedown", this, true);
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "mousedown":
         let box = Browser.getNotificationBox();
         let notification = box.getNotificationWithValue("popup-blocked");
         if (notification && !notification.contains(aEvent.target))
           box.removeNotification(notification);
         break;
     }
   },
 
-  onUpdatePageReport: function onUpdatePageReport(aEvent) {
+  onUpdatePageReport: function(aEvent) {
     var cBrowser = Browser.selectedBrowser;
     if (aEvent.originalTarget != cBrowser)
       return;
 
     if (!cBrowser.pageReport)
       return;
 
     let result = Services.perms.testExactPermission(Browser.selectedBrowser.currentURI, "popup");
@@ -1165,26 +1165,26 @@ var PopupBlockerObserver = {
         }
       }
       // Record the fact that we've reported this blocked popup, so we don't
       // show it again.
       cBrowser.pageReport.reported = true;
     }
   },
 
-  allowPopupsForSite: function allowPopupsForSite(aAllow) {
+  allowPopupsForSite: function(aAllow) {
     var currentURI = Browser.selectedBrowser.currentURI;
     Services.perms.add(currentURI, "popup", aAllow
                        ?  Ci.nsIPermissionManager.ALLOW_ACTION
                        :  Ci.nsIPermissionManager.DENY_ACTION);
 
     Browser.getNotificationBox().removeCurrentNotification();
   },
 
-  showPopupsForSite: function showPopupsForSite() {
+  showPopupsForSite: function() {
     let uri = Browser.selectedBrowser.currentURI;
     let pageReport = Browser.selectedBrowser.pageReport;
     if (pageReport) {
       for (let i = 0; i < pageReport.length; ++i) {
         var popupURIspec = pageReport[i].popupWindowURI.spec;
 
         // Sometimes the popup URI that we get back from the pageReport
         // isn't useful (for instance, netscape.com's popup URI ends up
@@ -1199,17 +1199,17 @@ var PopupBlockerObserver = {
 
         Browser.addTab(popupURIspec, false, Browser.selectedTab);
       }
     }
   }
 };
 
 var SessionHistoryObserver = {
-  observe: function sho_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (aTopic != "browser:purge-session-history")
       return;
 
     let newTab = Browser.addTab("about:start", true);
     let tab = Browser._tabs[0];
     while(tab != newTab) {
       Browser.closeTab(tab, { forceClose: true } );
       tab = Browser._tabs[0];
@@ -1278,34 +1278,34 @@ Tab.prototype = {
   get isPrivate() {
     return this._private;
   },
 
   get pageShowPromise() {
     return this._eventDeferred ? this._eventDeferred.promise : null;
   },
 
-  startLoading: function startLoading() {
+  startLoading: function() {
     if (this._loading) {
       let stack = new Error().stack;
       throw "Already Loading!\n" + stack;
     }
     this._loading = true;
   },
 
-  endLoading: function endLoading() {
+  endLoading: function() {
     this._loading = false;
     this.updateFavicon();
   },
 
-  isLoading: function isLoading() {
+  isLoading: function() {
     return this._loading;
   },
 
-  create: function create(aURI, aParams, aOwner) {
+  create: function(aURI, aParams, aOwner) {
     this._eventDeferred = Promise.defer();
 
     this._chromeTab = Elements.tabList.addTab(aParams.index);
     if (this.isPrivate) {
       this._chromeTab.setAttribute("private", "true");
     }
 
     this._id = Browser.createTabId();
@@ -1376,29 +1376,29 @@ Tab.prototype = {
 
   _delayUpdateThumbnail: function() {
     clearTimeout(this._updateThumbnailTimeout);
     this._updateThumbnailTimeout = setTimeout(() => {
       this.updateThumbnail();
     }, kTabThumbnailDelayCapture);
   },
 
-  destroy: function destroy() {
+  destroy: function() {
     this._browser.messageManager.removeMessageListener("Content:StateChange", this);
     this._browser.removeEventListener("DOMWindowCreated", this, false);
     this._browser.removeEventListener("StartUIChange", this, false);
     Elements.browsers.removeEventListener("SizeChanged", this, false);
     clearTimeout(this._updateThumbnailTimeout);
 
     Elements.tabList.removeTab(this._chromeTab);
     this._chromeTab = null;
     this._destroyBrowser();
   },
 
-  resurrect: function resurrect() {
+  resurrect: function() {
     let dead = this._browser;
     let active = this.active;
 
     // Hold onto the session store data
     let session = { data: dead.__SS_data, extra: dead.__SS_extdata };
 
     // We need this data to correctly create and position the new browser
     // If this browser is already a zombie, fallback to the session data
@@ -1412,36 +1412,36 @@ Tab.prototype = {
       this.active = true;
 
     // Reattach session store data and flag this browser so it is restored on select
     browser.__SS_data = session.data;
     browser.__SS_extdata = session.extra;
     browser.__SS_restore = true;
   },
 
-  _copyHistoryFrom: function _copyHistoryFrom(tab) {
+  _copyHistoryFrom: function(tab) {
     let otherHistory = tab._browser._webNavigation.sessionHistory;
     let history = this._browser._webNavigation.sessionHistory;
 
     // Ensure that history is initialized
     history.QueryInterface(Ci.nsISHistoryInternal);
 
     for (let i = 0, length = otherHistory.index; i <= length; i++)
       history.addEntry(otherHistory.getEntryAtIndex(i, false), true);
   },
 
-  _loadUsingParams: function _loadUsingParams(aBrowser, aURI, aParams) {
+  _loadUsingParams: function(aBrowser, aURI, aParams) {
     let flags = aParams.flags || Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
     let postData = ("postData" in aParams && aParams.postData) ? aParams.postData.value : null;
     let referrerURI = "referrerURI" in aParams ? aParams.referrerURI : null;
     let charset = "charset" in aParams ? aParams.charset : null;
     aBrowser.loadURIWithFlags(aURI, flags, referrerURI, charset, postData);
   },
 
-  _createBrowser: function _createBrowser(aURI, aInsertBefore) {
+  _createBrowser: function(aURI, aInsertBefore) {
     if (this._browser)
       throw "Browser already exists";
 
     // Create a notification box around the browser. Note this includes
     // the input overlay we use to shade content from input events when
     // we're intercepting touch input.
     let notification = this._notification = document.createElement("notificationbox");
 
@@ -1475,38 +1475,38 @@ Tab.prototype = {
     }
 
     // stop about:blank from loading
     browser.stop();
 
     return browser;
   },
 
-  _destroyBrowser: function _destroyBrowser() {
+  _destroyBrowser: function() {
     if (this._browser) {
       let notification = this._notification;
       notification.removeEventListener("AlertClose", this);
       let browser = this._browser;
       browser.active = false;
 
       this._notification = null;
       this._browser = null;
       this._loading = false;
 
       Elements.browsers.removeChild(notification);
     }
   },
 
-  updateThumbnail: function updateThumbnail() {
+  updateThumbnail: function() {
     if (!this.isPrivate) {
       PageThumbs.captureToCanvas(this.browser.contentWindow, this._chromeTab.thumbnailCanvas);
     }
   },
 
-  updateFavicon: function updateFavicon() {
+  updateFavicon: function() {
     this._chromeTab.updateFavicon(this._browser.mIconURL);
   },
 
   set active(aActive) {
     if (!this._browser)
       return;
 
     let notification = this._notification;
diff --git a/browser/metro/base/content/console.js b/browser/metro/base/content/console.js
--- a/browser/metro/base/content/console.js
+++ b/browser/metro/base/content/console.js
@@ -16,17 +16,17 @@ let ConsolePanelView = {
   get enabled() {
     return Services.prefs.getBoolPref(this._enabledPref);
   },
 
   get follow() {
     return document.getElementById("console-follow-checkbox").checked;
   },
 
-  init: function cv_init() {
+  init: function() {
     if (this._list)
       return;
 
     this._list = document.getElementById("console-box");
     this._evalTextbox = document.getElementById("console-eval-textbox");
     this._bundle = Strings.browser;
 
     this._count = 0;
@@ -40,17 +40,17 @@ let ConsolePanelView = {
         Services.prefs.clearUserPref("browser.console.showInPanel");
       }
     } catch(ex) {
       // likely don't have an old pref
     }
     Services.prefs.addObserver(this._enabledPref, this, false);
   },
 
-  show: function show() {
+  show: function() {
     if (this._inited)
       return;
     this._inited = true;
 
     this.init(); // In case the panel is selected before init has been called.
 
     Services.console.registerListener(this);
 
@@ -60,17 +60,17 @@ let ConsolePanelView = {
     this._evalFrame = document.createElement("iframe");
     this._evalFrame.id = "console-evaluator";
     this._evalFrame.collapsed = true;
     document.getElementById("console-container").appendChild(this._evalFrame);
 
     this._evalFrame.addEventListener("load", this.loadOrDisplayResult.bind(this), true);
   },
 
-  uninit: function cv_uninit() {
+  uninit: function() {
     if (this._inited)
       Services.console.unregisterListener(this);
 
     Services.prefs.removeObserver(this._enabledPref, this, false);
   },
 
   observe: function(aSubject, aTopic, aData) {
     if (aTopic == "nsPref:changed") {
@@ -88,17 +88,17 @@ let ConsolePanelView = {
       let pref = Services.prefs;
       return this._showChromeErrors = pref.getBoolPref("javascript.options.showInConsole");
     }
     catch(ex) {
       return this._showChromeErrors = false;
     }
   },
 
-  appendItem: function cv_appendItem(aObject) {
+  appendItem: function(aObject) {
     let index = -1;
     try {
       // Try to QI it to a script error to get more info
       let scriptError = aObject.QueryInterface(Ci.nsIScriptError);
 
       // filter chrome urls
       if (!this.showChromeErrors && scriptError.sourceName.substr(0, 9) == "chrome://")
         return;
@@ -131,17 +131,17 @@ let ConsolePanelView = {
     let truncatedString = aString.substring(0, this.fieldMaxLength);
     let Ci = Components.interfaces;
     let ellipsis = Services.prefs.getComplexValue("intl.ellipsis",
                                                   Ci.nsIPrefLocalizedString).data;
     truncatedString = truncatedString + ellipsis;
     return truncatedString;
   },
 
-  appendError: function cv_appendError(aObject) {
+  appendError: function(aObject) {
     let row = this.createConsoleRow();
     let nsIScriptError = Ci.nsIScriptError;
 
     // Is this error actually just a non-fatal warning?
     let warning = aObject.flags & nsIScriptError.warningFlag != 0;
 
     let typetext = warning ? "typeWarning" : "typeError";
     row.setAttribute("typetext", this._bundle.GetStringFromName(typetext));
@@ -172,49 +172,49 @@ let ConsolePanelView = {
       row.collapsed = true;
     }
 
     row.setAttribute("onclick", "ConsolePanelView.onRowClick(this)");
     this.appendConsoleRow(row);
     return this._list.getIndexOfItem(row);
   },
 
-  appendMessage: function cv_appendMessage (aMessage) {
+  appendMessage: function(aMessage) {
     let row = this.createConsoleRow();
     row.setAttribute("type", "message");
     row.setAttribute("msg", aMessage);
 
     let mode = document.getElementById("console-filter").value;
     if (mode != "all" && mode != "message")
       row.collapsed = true;
 
     this.appendConsoleRow(row);
     return this._list.getIndexOfItem(row);
   },
 
-  createConsoleRow: function cv_createConsoleRow() {
+  createConsoleRow: function() {
     let row = document.createElement("richlistitem");
     row.setAttribute("class", "console-row");
     return row;
   },
 
-  appendConsoleRow: function cv_appendConsoleRow(aRow) {
+  appendConsoleRow: function(aRow) {
     this._list.appendChild(aRow);
     if (++this._count > this.limit) {
       this.deleteFirst();
     }
   },
 
-  deleteFirst: function cv_deleteFirst() {
+  deleteFirst: function() {
     let node = this._list.firstChild;
     this._list.removeChild(node);
     --this._count;
   },
 
-  appendInitialItems: function cv_appendInitialItems() {
+  appendInitialItems: function() {
     this._list.collapsed = true;
     let messages = Services.console.getMessageArray();
 
     // In case getMessageArray returns 0-length array as null
     if (!messages)
       messages = [];
 
     let limit = messages.length - this.limit;
@@ -230,17 +230,17 @@ let ConsolePanelView = {
 
     // Populate with messages after latest "clear"
     while (++i < messages.length) {
       this.appendItem(messages[i]);
     }
     this._list.collapsed = false;
   },
 
-  clearConsole: function cv_clearConsole() {
+  clearConsole: function() {
     if (this._count == 0) // already clear
       return;
     this._count = 0;
 
     let newRows = this._list.cloneNode(false);
     this._list.parentNode.replaceChild(newRows, this._list);
     this._list = newRows;
     this.selectedItem = null;
@@ -262,33 +262,33 @@ let ConsolePanelView = {
         }
         copyText += text + "\r\n";
       }
     }
     let clip = Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
     clip.copyString(copyText, document);
   },
 
-  changeMode: function cv_changeMode() {
+  changeMode: function() {
     let mode = document.getElementById("console-filter").value;
     if (this._list.getAttribute("mode") != mode) {
       let rows = this._list.childNodes;
       for (let i=0; i < rows.length; i++) {
         let row = rows[i];
         if (mode == "all" || row.getAttribute ("type") == mode)
           row.collapsed = false;
         else
           row.collapsed = true;
       }
       this._list.mode = mode;
       this._list.scrollToIndex(0);
     }
   },
 
-  onContextMenu: function cv_onContextMenu(aEvent) {
+  onContextMenu: function(aEvent) {
     let row = aEvent.target;
     let text = ["msg", "href", "line", "code", "col"].map(function(attr) row.getAttribute(attr))
                .filter(function(x) x).join("\r\n");
 
     ContextMenuUI.showContextMenu({
       target: row,
       json: {
         types: ["copy"],
@@ -303,49 +303,49 @@ let ConsolePanelView = {
     if (aRow.hasAttribute("code")) {
       aRow.setAttribute("hideCode", "false");
     }
     if (aRow.hasAttribute("col")) {
       aRow.setAttribute("hideCaret", "false");
     }
   },
 
-  onEvalKeyPress: function cv_onEvalKeyPress(aEvent) {
+  onEvalKeyPress: function(aEvent) {
     if (aEvent.keyCode == 13)
       this.evaluateTypein();
   },
 
-  onConsoleBoxKeyPress: function cv_onConsoleBoxKeyPress(aEvent) {
+  onConsoleBoxKeyPress: function(aEvent) {
     if ((aEvent.charCode == 99 || aEvent.charCode == 67) && aEvent.ctrlKey && this._list && this._list.selectedItem) {
       let clipboard = Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
       clipboard.copyString(this._list.selectedItem.getAttribute("msg"), document);
     }
   },
 
-  evaluateTypein: function cv_evaluateTypein() {
+  evaluateTypein: function() {
     this._evalCode = this._evalTextbox.value;
     this.loadOrDisplayResult();
   },
 
-  loadOrDisplayResult: function cv_loadOrDisplayResult() {
+  loadOrDisplayResult: function() {
     if (this._evalCode) {
       this._evalFrame.contentWindow.location = "javascript: " + this._evalCode.replace(/%/g, "%25");
       this._evalCode = "";
       return;
     }
 
     let resultRange = this._evalFrame.contentDocument.createRange();
     resultRange.selectNode(this._evalFrame.contentDocument.documentElement);
     let result = resultRange.toString();
     if (result)
       Services.console.logStringMessage(result);
       // or could use appendMessage which doesn't persist
   },
 
-  repeatChar: function cv_repeatChar(aChar, aCol) {
+  repeatChar: function(aChar, aCol) {
     if (--aCol <= 0)
       return "";
 
     for (let i = 2; i < aCol; i += i)
       aChar += aChar;
 
     return aChar + aChar.slice(0, aCol - aChar.length);
   }
diff --git a/browser/metro/base/content/contenthandlers/ConsoleAPIObserver.js b/browser/metro/base/content/contenthandlers/ConsoleAPIObserver.js
--- a/browser/metro/base/content/contenthandlers/ConsoleAPIObserver.js
+++ b/browser/metro/base/content/contenthandlers/ConsoleAPIObserver.js
@@ -8,34 +8,34 @@ let Cc = Components.classes;
 dump("### ConsoleAPIObserver.js loaded\n");
 
 /*
  * ConsoleAPIObserver
  *
  */ 
 
 var ConsoleAPIObserver = {
-  init: function init() {
+  init: function() {
     addMessageListener("Browser:TabOpen", this);
     addMessageListener("Browser:TabClose", this);
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let json = aMessage.json;
     switch (aMessage.name) {
       case "Browser:TabOpen":
         Services.obs.addObserver(this, "console-api-log-event", false);
         break;
       case "Browser:TabClose":
         Services.obs.removeObserver(this, "console-api-log-event");
         break;
     }
   },
 
-  observe: function observe(aMessage, aTopic, aData) {
+  observe: function(aMessage, aTopic, aData) {
     let contentWindowId = content.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
     aMessage = aMessage.wrappedJSObject;
     if (aMessage.ID != contentWindowId)
       return;
 
     let mappedArguments = Array.map(aMessage.arguments, this.formatResult, this);
     let joinedArguments = Array.join(mappedArguments, " ");
 
@@ -58,24 +58,24 @@ var ConsoleAPIObserver = {
       });
 
       Services.console.logStringMessage(body);
     } else {
       Services.console.logStringMessage(joinedArguments);
     }
   },
 
-  getResultType: function getResultType(aResult) {
+  getResultType: function(aResult) {
     let type = aResult === null ? "null" : typeof aResult;
     if (type == "object" && aResult.constructor && aResult.constructor.name)
       type = aResult.constructor.name;
     return type.toLowerCase();
   },
 
-  formatResult: function formatResult(aResult) {
+  formatResult: function(aResult) {
     let output = "";
     let type = this.getResultType(aResult);
     switch (type) {
       case "string":
       case "boolean":
       case "date":
       case "error":
       case "number":
@@ -89,17 +89,17 @@ var ConsoleAPIObserver = {
       default:
         output = aResult.toString();
         break;
     }
 
     return output;
   },
 
-  abbreviateSourceURL: function abbreviateSourceURL(aSourceURL) {
+  abbreviateSourceURL: function(aSourceURL) {
     // Remove any query parameters.
     let hookIndex = aSourceURL.indexOf("?");
     if (hookIndex > -1)
       aSourceURL = aSourceURL.substring(0, hookIndex);
 
     // Remove a trailing "/".
     if (aSourceURL[aSourceURL.length - 1] == "/")
       aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
diff --git a/browser/metro/base/content/contenthandlers/Content.js b/browser/metro/base/content/contenthandlers/Content.js
--- a/browser/metro/base/content/contenthandlers/Content.js
+++ b/browser/metro/base/content/contenthandlers/Content.js
@@ -119,17 +119,17 @@ this.getOverflowContentBoundingRect = ge
 let Content = {
   _debugEvents: false,
 
   get formAssistant() {
     delete this.formAssistant;
     return this.formAssistant = new FormAssistant();
   },
 
-  init: function init() {
+  init: function() {
     // Asyncronous messages sent from the browser
     addMessageListener("Browser:Blur", this);
     addMessageListener("Browser:SaveAs", this);
     addMessageListener("Browser:MozApplicationCache:Fetch", this);
     addMessageListener("Browser:SetCharset", this);
     addMessageListener("Browser:CanUnload", this);
     addMessageListener("Browser:PanBegin", this);
     addMessageListener("Gesture:SingleTap", this);
@@ -154,17 +154,17 @@ let Content = {
 
     docShell.useGlobalHistory = true;
   },
 
   /*******************************************
    * Events
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (this._debugEvents) Util.dumpLn("Content:", aEvent.type);
     switch (aEvent.type) {
       case "MozApplicationManifest": {
         let doc = aEvent.originalTarget;
         sendAsyncMessage("Browser:MozApplicationManifest", {
           location: doc.documentURIObject.spec,
           manifest: doc.documentElement.getAttribute("manifest"),
           charset: doc.characterSet
@@ -210,17 +210,17 @@ let Content = {
         break;
 
       case "touchstart":
         this._onTouchStart(aEvent);
         break;
     }
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (this._debugEvents) Util.dumpLn("Content:", aMessage.name);
     let json = aMessage.json;
     let x = json.x;
     let y = json.y;
 
     switch (aMessage.name) {
       case "Browser:Blur":
         gFocusManager.clearFocus(content);
@@ -265,30 +265,30 @@ let Content = {
         break;
     }
   },
 
   /******************************************************
    * Event handlers
    */
 
-  _onTouchStart: function _onTouchStart(aEvent) {
+  _onTouchStart: function(aEvent) {
     let element = aEvent.target;
 
     // There is no need to have a feedback for disabled element
     let isDisabled = element instanceof HTMLOptionElement ?
       (element.disabled || element.parentNode.disabled) : element.disabled;
     if (isDisabled)
       return;
 
     // Set the target element to active
     this._doTapHighlight(element);
   },
 
-  _onClickCapture: function _onClickCapture(aEvent) {
+  _onClickCapture: function(aEvent) {
     let element = aEvent.target;
 
     ContextMenuHandler.reset();
 
     // Only show autocomplete after the item is clicked
     if (!this.lastClickElement || this.lastClickElement != element) {
       this.lastClickElement = element;
       if (aEvent.mozInputSource == Ci.nsIDOMMouseEvent.MOZ_SOURCE_MOUSE &&
@@ -311,17 +311,17 @@ let Content = {
         yPos: aEvent.clientY + offsetY
       });
     } else {
       SelectionHandler.closeSelection();
     }
   },
 
   // Checks clicks we care about - events bubbling up from about pages.
-  _onClickBubble: function _onClickBubble(aEvent) {
+  _onClickBubble: function(aEvent) {
     // Don't trust synthetic events
     if (!aEvent.isTrusted)
       return;
 
     let ot = aEvent.originalTarget;
     let errorDoc = ot.ownerDocument;
     if (!errorDoc)
       return;
@@ -493,32 +493,32 @@ let Content = {
       element: element,
       contentWindow: element.ownerDocument.defaultView,
       offset: offset,
       utils: utils
     };
   },
 
 
-  _maybeNotifyErrorPage: function _maybeNotifyErrorPage() {
+  _maybeNotifyErrorPage: function() {
     // Notify browser that an error page is being shown instead
     // of the target location. Necessary to get proper thumbnail
     // updates on chrome for error pages.
     if (content.location.href !== content.document.documentURI)
       sendAsyncMessage("Browser:ErrorPage", null);
   },
 
   _highlightElement: null,
 
-  _doTapHighlight: function _doTapHighlight(aElement) {
+  _doTapHighlight: function(aElement) {
     gDOMUtils.setContentState(aElement, kStateActive);
     this._highlightElement = aElement;
   },
 
-  _cancelTapHighlight: function _cancelTapHighlight(aElement) {
+  _cancelTapHighlight: function(aElement) {
     gDOMUtils.setContentState(content.document.documentElement, kStateActive);
     this._highlightElement = null;
   },
 };
 
 Content.init();
 
 var FormSubmitObserver = {
@@ -526,47 +526,47 @@ var FormSubmitObserver = {
     addMessageListener("Browser:TabOpen", this);
     addMessageListener("Browser:TabClose", this);
 
     addEventListener("pageshow", this, false);
 
     Services.obs.addObserver(this, "invalidformsubmit", false);
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     let target = aEvent.originalTarget;
     let isRootDocument = (target == content.document || target.ownerDocument == content.document);
     if (!isRootDocument)
       return;
 
     // Reset invalid submit state on each pageshow
     if (aEvent.type == "pageshow")
       Content.formAssistant.invalidSubmit = false;
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let json = aMessage.json;
     switch (aMessage.name) {
       case "Browser:TabOpen":
         Services.obs.addObserver(this, "formsubmit", false);
         break;
       case "Browser:TabClose":
         Services.obs.removeObserver(this, "formsubmit");
         break;
     }
   },
 
-  notify: function notify(aFormElement, aWindow, aActionURI, aCancelSubmit) {
+  notify: function(aFormElement, aWindow, aActionURI, aCancelSubmit) {
     // Do not notify unless this is the window where the submit occurred
     if (aWindow == content)
       // We don't need to send any data along
       sendAsyncMessage("Browser:FormSubmit", {});
   },
 
-  notifyInvalidSubmit: function notifyInvalidSubmit(aFormElement, aInvalidElements) {
+  notifyInvalidSubmit: function(aFormElement, aInvalidElements) {
     if (!aInvalidElements.length)
       return;
 
     let element = aInvalidElements.queryElementAt(0, Ci.nsISupports);
     if (!(element instanceof HTMLInputElement ||
           element instanceof HTMLTextAreaElement ||
           element instanceof HTMLSelectElement ||
           element instanceof HTMLButtonElement)) {
diff --git a/browser/metro/base/content/contenthandlers/ContextMenuHandler.js b/browser/metro/base/content/contenthandlers/ContextMenuHandler.js
--- a/browser/metro/base/content/contenthandlers/ContextMenuHandler.js
+++ b/browser/metro/base/content/contenthandlers/ContextMenuHandler.js
@@ -8,52 +8,52 @@ let Cc = Components.classes;
 this.kXLinkNamespace = "http://www.w3.org/1999/xlink";
 
 dump("### ContextMenuHandler.js loaded\n");
 
 var ContextMenuHandler = {
   _types: [],
   _previousState: null,
 
-  init: function ch_init() {
+  init: function() {
     // Events we catch from content during the bubbling phase
     addEventListener("contextmenu", this, false);
     addEventListener("pagehide", this, false);
 
     // Messages we receive from browser
     // Command sent over from browser that only we can handle.
     addMessageListener("Browser:ContextCommand", this, false);
 
     this.popupNode = null;
   },
 
-  handleEvent: function ch_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "contextmenu":
         this._onContentContextMenu(aEvent);
         break;
       case "pagehide":
         this.reset();
         break;
     }
   },
 
-  receiveMessage: function ch_receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     switch (aMessage.name) {
       case "Browser:ContextCommand":
         this._onContextCommand(aMessage);
       break;
     }
   },
 
   /*
    * Handler for commands send over from browser's ContextCommands.js
    * in response to certain context menu actions only we can handle.
    */
-  _onContextCommand: function _onContextCommand(aMessage) {
+  _onContextCommand: function(aMessage) {
     let node = this.popupNode;
     let command = aMessage.json.command;
 
     switch (command) {
       case "cut":
         this._onCut();
         break;
 
@@ -74,52 +74,52 @@ var ContextMenuHandler = {
         break;
     }
   },
 
   /******************************************************
    * Event handlers
    */
 
-  reset: function ch_reset() {
+  reset: function() {
     this.popupNode = null;
     this._target = null;
   },
 
   // content contextmenu handler
-  _onContentContextMenu: function _onContentContextMenu(aEvent) {
+  _onContentContextMenu: function(aEvent) {
     if (aEvent.defaultPrevented)
       return;
 
     // Don't let these bubble up to input.js
     aEvent.stopPropagation();
     aEvent.preventDefault();
 
     this._processPopupNode(aEvent.originalTarget, aEvent.clientX,
                            aEvent.clientY, aEvent.mozInputSource);
   },
 
   /******************************************************
    * ContextCommand handlers
    */
 
-  _onSelectAll: function _onSelectAll() {
+  _onSelectAll: function() {
     if (Util.isTextInput(this._target)) {
       // select all text in the input control
       this._target.select();
     } else if (Util.isEditableContent(this._target)) {
       this._target.ownerDocument.execCommand("selectAll", false);
     } else {
       // select the entire document
       content.getSelection().selectAllChildren(content.document);
     }
     this.reset();
   },
 
-  _onPaste: function _onPaste() {
+  _onPaste: function() {
     // paste text if this is an input control
     if (Util.isTextInput(this._target)) {
       let edit = this._target.QueryInterface(Ci.nsIDOMNSEditableElement);
       if (edit) {
         edit.editor.paste(Ci.nsIClipboard.kGlobalClipboard);
       } else {
         Util.dumpLn("error: target element does not support nsIDOMNSEditableElement");
       }
@@ -130,21 +130,21 @@ var ContextMenuHandler = {
                                                Ci.nsIClipboard.kGlobalClipboard);
       } catch (ex) {
         dump("ContextMenuHandler: exception pasting into contentEditable: " + ex.message + "\n");
       }
     }
     this.reset();
   },
 
-  _onCopyImage: function _onCopyImage() {
+  _onCopyImage: function() {
     Util.copyImageToClipboard(this._target);
   },
 
-  _onCut: function _onCut() {
+  _onCut: function() {
     if (Util.isTextInput(this._target)) {
       let edit = this._target.QueryInterface(Ci.nsIDOMNSEditableElement);
       if (edit) {
         edit.editor.cut();
       } else {
         Util.dumpLn("error: target element does not support nsIDOMNSEditableElement");
       }
     } else if (Util.isEditableContent(this._target)) {
@@ -152,17 +152,17 @@ var ContextMenuHandler = {
         this._target.ownerDocument.execCommand("cut", false);
       } catch (ex) {
         dump("ContextMenuHandler: exception cutting from contentEditable: " + ex.message + "\n");
       }
     }
     this.reset();
   },
 
-  _onCopy: function _onCopy() {
+  _onCopy: function() {
     if (Util.isTextInput(this._target)) {
       let edit = this._target.QueryInterface(Ci.nsIDOMNSEditableElement);
       if (edit) {
         edit.editor.copy();
       } else {
         Util.dumpLn("error: target element does not support nsIDOMNSEditableElement");
       }
     } else if (Util.isEditableContent(this._target)) {
@@ -186,17 +186,17 @@ var ContextMenuHandler = {
    */
 
   /*
    * _processPopupNode - Generate and send a Content:ContextMenu message
    * to browser detailing the underlying content types at this.popupNode.
    * Note the event we receive targets the sub frame (if there is one) of
    * the page.
    */
-  _processPopupNode: function _processPopupNode(aPopupNode, aX, aY, aInputSrc) {
+  _processPopupNode: function(aPopupNode, aX, aY, aInputSrc) {
     if (!aPopupNode)
       return;
 
     let { targetWindow: targetWindow,
           offsetX: offsetX,
           offsetY: offsetY } =
       Util.translateToTopLevelWindow(aPopupNode);
 
@@ -392,57 +392,57 @@ var ContextMenuHandler = {
       let rect = range.getBoundingClientRect();
       if (Util.pointWithinDOMRect(aX, aY, rect)) {
         return true;
       }
     }
     return false;
   },
 
-  _getLinkURL: function ch_getLinkURL(aLink) {
+  _getLinkURL: function(aLink) {
     let href = aLink.href;
     if (href)
       return href;
 
     href = aLink.getAttributeNS(kXLinkNamespace, "href");
     if (!href || !href.match(/\S/)) {
       // Without this we try to save as the current doc,
       // for example, HTML case also throws if empty
       throw "Empty href";
     }
 
     return Util.makeURLAbsolute(aLink.baseURI, href);
   },
 
-  _getURI: function ch_getURI(aURL) {
+  _getURI: function(aURL) {
     try {
       return Util.makeURI(aURL);
     } catch (ex) { }
 
     return null;
   },
 
-  _getProtocol: function ch_getProtocol(aURI) {
+  _getProtocol: function(aURI) {
     if (aURI)
       return aURI.scheme;
     return null;
   },
 
   /**
    * For add-ons to add new types and data to the ContextMenu message.
    *
    * @param aName A string to identify the new type.
    * @param aHandler A function that takes a state object and a target element.
    *    If aHandler returns true, then aName will be added to the list of types.
    *    The function may also modify the state object.
    */
-  registerType: function registerType(aName, aHandler) {
+  registerType: function(aName, aHandler) {
     this._types.push({name: aName, handler: aHandler});
   },
 
   /** Remove all handlers registered for a given type. */
-  unregisterType: function unregisterType(aName) {
+  unregisterType: function(aName) {
     this._types = this._types.filter(function(type) type.name != aName);
   }
 };
 this.ContextMenuHandler = ContextMenuHandler;
 
 ContextMenuHandler.init();
diff --git a/browser/metro/base/content/contenthandlers/FormHelper.js b/browser/metro/base/content/contenthandlers/FormHelper.js
--- a/browser/metro/base/content/contenthandlers/FormHelper.js
+++ b/browser/metro/base/content/contenthandlers/FormHelper.js
@@ -80,17 +80,17 @@ FormAssistant.prototype = {
       // example, in this "fun" case just do nothing if the element is hidden
       if (self._isVisibleElement(gFocusManager.focusedElement)) {
         self._sendJsonMsgWrapper("FormAssist:Show");
       }
     });
     return this._currentElement;
   },
 
-  open: function formHelperOpen(aElement, aEvent) {
+  open: function(aElement, aEvent) {
     // If the click is on an option element we want to check if the parent
     // is a valid target.
     if (aElement instanceof HTMLOptionElement &&
         aElement.parentNode instanceof HTMLSelectElement &&
         !aElement.disabled) {
       aElement = aElement.parentNode;
     }
 
@@ -133,27 +133,27 @@ FormAssistant.prototype = {
       return false;
     }
 
     // Enable the assistant
     this.currentElement = aElement;
     return this._open = true;
   },
 
-  close: function close() {
+  close: function() {
     if (this._open) {
       this._currentElement = null;
       sendAsyncMessage("FormAssist:Hide", { });
       this._open = false;
     }
 
     return this._open;
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (this._debugEvents) Util.dumpLn(aMessage.name);
 
     let currentElement = this.currentElement;
     if ((!this._isAutocomplete(currentElement) &&
          !getWrapperForElement(currentElement)) ||
         !currentElement) {
       return;
     }
@@ -209,17 +209,17 @@ FormAssistant.prototype = {
         break;
 
       case "FormAssist:Update":
         this._sendJsonMsgWrapper("FormAssist:Show");
         break;
     }
   },
 
-  handleEvent: function formHelperHandleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (this._debugEvents) Util.dumpLn(aEvent.type, this.currentElement);
     // focus changes should be taken into account only if the user has done a
     // manual operation like manually clicking
     let shouldIgnoreFocus = (aEvent.type == "focus" && !this._open && !this.focusSync);
     if ((!this._open && aEvent.type != "focus") || shouldIgnoreFocus) {
       return;
     }
 
@@ -288,25 +288,25 @@ FormAssistant.prototype = {
       case "text":
         if (this._isAutocomplete(aEvent.target)) {
           this._sendJsonMsgWrapper("FormAssist:AutoComplete");
         }
         break;
     }
   },
 
-  _executeDelayed: function formHelperExecuteSoon(aCallback) {
+  _executeDelayed: function(aCallback) {
     let self = this;
     let timer = new Util.Timeout(function() {
       aCallback(self);
     });
     timer.once(0);
   },
 
-  _isEditable: function formHelperIsEditable(aElement) {
+  _isEditable: function(aElement) {
     if (!aElement)
       return false;
     let canEdit = false;
 
     if (aElement.isContentEditable || aElement.designMode == "on") {
       canEdit = true;
     } else if (aElement instanceof HTMLIFrameElement &&
                (aElement.contentDocument.body.isContentEditable ||
@@ -314,17 +314,17 @@ FormAssistant.prototype = {
       canEdit = true;
     } else {
       canEdit = aElement.ownerDocument && aElement.ownerDocument.designMode == "on";
     }
 
     return canEdit;
   },
 
-  _getTopLevelEditable: function formHelperGetTopLevelEditable(aElement) {
+  _getTopLevelEditable: function(aElement) {
     if (!(aElement instanceof HTMLIFrameElement)) {
       let element = aElement;
 
       // Retrieve the top element that is editable
       if (element instanceof HTMLHtmlElement)
         element = element.ownerDocument.body;
       else if (element instanceof HTMLDocument)
         element = element.body;
@@ -335,17 +335,17 @@ FormAssistant.prototype = {
       // Return the container frame if we are into a nested editable frame
       if (element && element instanceof HTMLBodyElement && element.ownerDocument.defaultView != content.document.defaultView)
         return element.ownerDocument.defaultView.frameElement;
     }
 
     return aElement;
   },
 
-  _isAutocomplete: function formHelperIsAutocomplete(aElement) {
+  _isAutocomplete: function(aElement) {
     if (aElement instanceof HTMLInputElement) {
       if (aElement.getAttribute("type") == "password")
         return false;
 
       let autocomplete = aElement.getAttribute("autocomplete");
       let allowedValues = ["off", "false", "disabled"];
       if (allowedValues.indexOf(autocomplete) == -1)
         return true;
@@ -354,17 +354,17 @@ FormAssistant.prototype = {
     return false;
   },
 
   /*
    * This function is similar to getListSuggestions from
    * components/satchel/src/nsInputListAutoComplete.js but sadly this one is
    * used by the autocomplete.xml binding which is not in used in fennec
    */
-  _getListSuggestions: function formHelperGetListSuggestions(aElement) {
+  _getListSuggestions: function(aElement) {
     if (!(aElement instanceof HTMLInputElement) || !aElement.list)
       return [];
 
     let suggestions = [];
     let filter = !aElement.hasAttribute("mozNoFilter");
     let lowerFieldValue = aElement.value.toLowerCase();
 
     let options = aElement.list.options;
@@ -381,48 +381,48 @@ FormAssistant.prototype = {
       if (filter && label.toLowerCase().indexOf(lowerFieldValue) == -1)
         continue;
        suggestions.push({ label: label, value: item.value });
     }
 
     return suggestions;
   },
 
-  _isValidElement: function formHelperIsValidElement(aElement) {
+  _isValidElement: function(aElement) {
     if (!aElement.getAttribute)
       return false;
 
     let formExceptions = { button: true, checkbox: true, file: true, image: true, radio: true, reset: true, submit: true };
     if (aElement instanceof HTMLInputElement && formExceptions[aElement.type])
       return false;
 
     if (aElement instanceof HTMLButtonElement ||
         (aElement.getAttribute("role") == "button" && aElement.hasAttribute("tabindex")))
       return false;
 
     return this._isNavigableElement(aElement) && this._isVisibleElement(aElement);
   },
 
-  _isNavigableElement: function formHelperIsNavigableElement(aElement) {
+  _isNavigableElement: function(aElement) {
     if (aElement.disabled || aElement.getAttribute("tabindex") == "-1")
       return false;
 
     if (aElement.getAttribute("role") == "button" && aElement.hasAttribute("tabindex"))
       return true;
 
     if (this._isSelectElement(aElement) || aElement instanceof HTMLTextAreaElement)
       return true;
 
     if (aElement instanceof HTMLInputElement || aElement instanceof HTMLButtonElement)
       return !(aElement.type == "hidden");
 
     return this._isEditable(aElement);
   },
 
-  _isVisibleElement: function formHelperIsVisibleElement(aElement) {
+  _isVisibleElement: function(aElement) {
     if (!aElement || !aElement.ownerDocument) {
       return false;
     }
     let style = aElement.ownerDocument.defaultView.getComputedStyle(aElement, null);
     if (!style)
       return false;
 
     let isVisible = (style.getPropertyValue("visibility") != "hidden");
@@ -434,22 +434,22 @@ FormAssistant.prototype = {
     // assistant is enabled is to return true here, a select is allowed to have
     // an opacity to 0 in order to let web developpers add a custom design on
     // top of it. This is less important to use the form assistant for the
     // other types of fields because even if the form assistant won't fired,
     // the focus will be in and a VKB will popup if needed
     return isVisible && (isOpaque || this._isSelectElement(aElement)) && (rect.height != 0 || rect.width != 0);
   },
 
-  _isSelectElement: function formHelperIsSelectElement(aElement) {
+  _isSelectElement: function(aElement) {
     return (aElement instanceof HTMLSelectElement || aElement instanceof XULMenuListElement);
   },
 
   /** Caret is used to input text for this element. */
-  _getCaretRect: function _formHelperGetCaretRect() {
+  _getCaretRect: function() {
     let element = this.currentElement;
     let focusedElement = gFocusManager.getFocusedElementForWindow(content, true, {});
     if (element && (element.mozIsTextField && element.mozIsTextField(false) ||
         element instanceof HTMLTextAreaElement) && focusedElement == element && this._isVisibleElement(element)) {
       let utils = Util.getWindowUtils(element.ownerDocument.defaultView);
       let rect = utils.sendQueryContentEvent(utils.QUERY_CARET_RECT, element.selectionEnd, 0, 0, 0,
                                              utils.QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK);
       if (rect) {
@@ -457,17 +457,17 @@ FormAssistant.prototype = {
         return new Rect(scroll.x + rect.left, scroll.y + rect.top, rect.width, rect.height);
       }
     }
 
     return new Rect(0, 0, 0, 0);
   },
 
   /** Gets a rect bounding important parts of the element that must be seen when assisting. */
-  _getRect: function _formHelperGetRect(aOptions={}) {
+  _getRect: function(aOptions={}) {
     const kDistanceMax = 100;
     let element = this.currentElement;
     let elRect = getBoundingContentRect(element);
 
     if (aOptions.alignToLabel) {
       let labels = this._getLabels();
       for (let i=0; i<labels.length; i++) {
         let labelRect = labels[i].rect;
@@ -479,17 +479,17 @@ FormAssistant.prototype = {
             return new Rect(labelRect.left, labelRect.top, width, elRect.height).expandToIntegers();
           }
         }
       }
     }
     return elRect;
   },
 
-  _getLabels: function formHelperGetLabels() {
+  _getLabels: function() {
     let associatedLabels = [];
     if (!this.currentElement)
       return associatedLabels;
     let element = this.currentElement;
     let labels = element.ownerDocument.getElementsByTagName("label");
     for (let i=0; i<labels.length; i++) {
       let label = labels[i];
       if ((label.control == element || label.getAttribute("for") == element.id) && this._isVisibleElement(label)) {
diff --git a/browser/metro/base/content/contenthandlers/PluginHelper.js b/browser/metro/base/content/contenthandlers/PluginHelper.js
--- a/browser/metro/base/content/contenthandlers/PluginHelper.js
+++ b/browser/metro/base/content/contenthandlers/PluginHelper.js
@@ -13,17 +13,17 @@ dump("### PluginHelper.js loaded\n");
  * blocked, click-to-play, or replaced by a "preview" extension plugin like
  * Shumway or PDF.js.
  */
 var PluginHelper = {
   init: function () {
     addEventListener("PluginBindingAttached", this, true, true);
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "PluginBindingAttached":
         this.handlePluginBindingAttached(aEvent);
         break;
     }
   },
 
   getPluginMimeType: function (plugin) {
diff --git a/browser/metro/base/content/contenthandlers/SelectionHandler.js b/browser/metro/base/content/contenthandlers/SelectionHandler.js
--- a/browser/metro/base/content/contenthandlers/SelectionHandler.js
+++ b/browser/metro/base/content/contenthandlers/SelectionHandler.js
@@ -3,17 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 let Ci = Components.interfaces;
 let Cc = Components.classes;
 
 dump("### SelectionHandler.js loaded\n");
 
 var SelectionHandler = {
-  init: function init() {
+  init: function() {
     this.type = kContentSelector;
     this.snap = true;
     this.lastYPos = this.lastXPos = null;
     addMessageListener("Browser:SelectionStart", this);
     addMessageListener("Browser:SelectionAttach", this);
     addMessageListener("Browser:SelectionEnd", this);
     addMessageListener("Browser:SelectionMoveStart", this);
     addMessageListener("Browser:SelectionMove", this);
@@ -26,17 +26,17 @@ var SelectionHandler = {
     addMessageListener("Browser:CaretMove", this);
     addMessageListener("Browser:CaretUpdate", this);
     addMessageListener("Browser:SelectionSwitchMode", this);
     addMessageListener("Browser:RepositionInfoRequest", this);
     addMessageListener("Browser:SelectionHandlerPing", this);
     addMessageListener("Browser:ResetLastPos", this);
   },
 
-  shutdown: function shutdown() {
+  shutdown: function() {
     removeMessageListener("Browser:SelectionStart", this);
     removeMessageListener("Browser:SelectionAttach", this);
     removeMessageListener("Browser:SelectionEnd", this);
     removeMessageListener("Browser:SelectionMoveStart", this);
     removeMessageListener("Browser:SelectionMove", this);
     removeMessageListener("Browser:SelectionMoveEnd", this);
     removeMessageListener("Browser:SelectionUpdate", this);
     removeMessageListener("Browser:SelectionClose", this);
@@ -46,28 +46,28 @@ var SelectionHandler = {
     removeMessageListener("Browser:CaretMove", this);
     removeMessageListener("Browser:CaretUpdate", this);
     removeMessageListener("Browser:SelectionSwitchMode", this);
     removeMessageListener("Browser:RepositionInfoRequest", this);
     removeMessageListener("Browser:SelectionHandlerPing", this);
     removeMessageListener("Browser:ResetLastPos", this);
   },
 
-  sendAsync: function sendAsync(aMsg, aJson) {
+  sendAsync: function(aMsg, aJson) {
     sendAsyncMessage(aMsg, aJson);
   },
 
   /*************************************************
    * Browser event handlers
    */
 
   /*
    * Selection start event handler
    */
-  _onSelectionStart: function _onSelectionStart(aJson) {
+  _onSelectionStart: function(aJson) {
     // Init content window information
     if (!this._initTargetInfo(aJson.xPos, aJson.yPos)) {
       this._onFail("failed to get target information");
       return;
     }
 
     // for context menu select command, which doesn't trigger
     // form input focus changes.
@@ -86,32 +86,32 @@ var SelectionHandler = {
       this._onFail("failed to set selection at point");
       return;
     }
 
     // Update the position of our selection monocles
     this._updateSelectionUI("start", true, true);
   },
 
-  _onSelectionAttach: function _onSelectionAttach(aX, aY) {
+  _onSelectionAttach: function(aX, aY) {
     // Init content window information
     if (!this._initTargetInfo(aX, aY)) {
       this._onFail("failed to get frame offset");
       return;
     }
 
     // Update the position of our selection monocles
     this._updateSelectionUI("start", true, true);
   },
 
   /*
    * Switch selection modes. Currently we only support switching
    * from "caret" to "selection".
    */
-  _onSwitchMode: function _onSwitchMode(aMode, aMarker, aX, aY) {
+  _onSwitchMode: function(aMode, aMarker, aX, aY) {
     if (aMode != "selection") {
       this._onFail("unsupported mode switch");
       return;
     }
     
     // Sanity check to be sure we are initialized
     if (!this._targetElement) {
       this._onFail("not initialized");
@@ -144,17 +144,17 @@ var SelectionHandler = {
     // Update the position of the selection marker that is *not*
     // being dragged.
     this._updateSelectionUI("update", aMarker == "end", aMarker == "start");
   },
 
   /*
    * Selection monocle start move event handler
    */
-  _onSelectionMoveStart: function _onSelectionMoveStart(aMsg) {
+  _onSelectionMoveStart: function(aMsg) {
     if (!this._contentWindow) {
       this._onFail("_onSelectionMoveStart was called without proper view set up");
       return;
     }
 
     if (this._selectionMoveActive) {
       this._onFail("mouse is already down on drag start?");
       return;
@@ -173,34 +173,34 @@ var SelectionHandler = {
 
     // Update the position of our selection monocles
     this._updateSelectionUI("update", true, true);
   },
   
   /*
    * Selection monocle move event handler
    */
-  _onSelectionMove: function _onSelectionMove(aMsg) {
+  _onSelectionMove: function(aMsg) {
     if (!this._contentWindow) {
       this._onFail("_onSelectionMove was called without proper view set up");
       return;
     }
 
     if (!this._selectionMoveActive) {
       this._onFail("mouse isn't down for drag move?");
       return;
     }
 
     this._handleSelectionPoint(aMsg, false);
   },
 
   /*
    * Selection monocle move finished event handler
    */
-  _onSelectionMoveEnd: function _onSelectionMoveComplete(aMsg) {
+  _onSelectionMoveEnd: function(aMsg) {
     if (!this._contentWindow) {
       this._onFail("_onSelectionMove was called without proper view set up");
       return;
     }
 
     if (!this._selectionMoveActive) {
       this._onFail("mouse isn't down for drag move?");
       return;
@@ -219,17 +219,17 @@ var SelectionHandler = {
 
    /*
     * _onCaretAttach - called by SelectionHelperUI when the user taps in a
     * form input. Initializes SelectionHandler, updates the location of the
     * caret, and messages back with current monocle position information.
     *
     * @param aX, aY tap location in client coordinates.
     */
-  _onCaretAttach: function _onCaretAttach(aX, aY) {
+  _onCaretAttach: function(aX, aY) {
     // Init content window information
     if (!this._initTargetInfo(aX, aY)) {
       this._onFail("failed to get target information");
       return;
     }
 
     // This should never happen, but we check to make sure
     if (!this._targetIsEditable) {
@@ -250,17 +250,17 @@ var SelectionHandler = {
 
   /*
    * Selection copy event handler
    *
    * Check to see if the incoming click was on our selection rect.
    * if it was, copy to the clipboard. Incoming coordinates are
    * content values.
    */
-  _onSelectionCopy: function _onSelectionCopy(aMsg) {
+  _onSelectionCopy: function(aMsg) {
     let tap = {
       xPos: aMsg.xPos,
       yPos: aMsg.yPos,
     };
 
     let tapInSelection = (tap.xPos > this._cache.selection.left &&
                           tap.xPos < this._cache.selection.right) &&
                          (tap.yPos > this._cache.selection.top &&
@@ -280,28 +280,28 @@ var SelectionHandler = {
     sendSyncMessage("Content:SelectionCopied", { succeeded: success });
   },
 
   /*
    * Selection close event handler
    *
    * @param aClearSelection requests that selection be cleared.
    */
-  _onSelectionClose: function _onSelectionClose(aClearSelection) {
+  _onSelectionClose: function(aClearSelection) {
     if (aClearSelection) {
       this._clearSelection();
     }
     this.closeSelection();
   },
 
   /*
    * Called any time SelectionHelperUI would like us to
    * recalculate the selection bounds.
    */
-  _onSelectionUpdate: function _onSelectionUpdate(aMsg) {
+  _onSelectionUpdate: function(aMsg) {
     if (!this._contentWindow) {
       this._onFail("_onSelectionUpdate was called without proper view set up");
       return;
     }
 
     if (aMsg && aMsg.isInitiatedByAPZC) {
       let {offset: offset} = Content.getCurrentWindowAndOffset(
         this._targetCoordinates.x, this._targetCoordinates.y);
@@ -311,45 +311,45 @@ var SelectionHandler = {
     // Update the position of our selection monocles
     this._updateSelectionUI("update", true, true);
   },
 
   /*
    * Called if for any reason we fail during the selection
    * process. Cancels the selection.
    */
-  _onFail: function _onFail(aDbgMessage) {
+  _onFail: function(aDbgMessage) {
     if (aDbgMessage && aDbgMessage.length > 0)
       Util.dumpLn(aDbgMessage);
     this.sendAsync("Content:SelectionFail");
     this._clearSelection();
     this.closeSelection();
   },
 
   /*
    * _repositionInfoRequest - fired at us by ContentAreaObserver when the
    * soft keyboard is being displayed. CAO wants to make a decision about
    * whether the browser deck needs repositioning.
    */
-  _repositionInfoRequest: function _repositionInfoRequest(aJsonMsg) {
+  _repositionInfoRequest: function(aJsonMsg) {
     let result = this._calcNewContentPosition(aJsonMsg.viewHeight);
 
     // no repositioning needed
     if (result == 0) {
       this.sendAsync("Content:RepositionInfoResponse", { reposition: false });
       return;
     }
 
     this.sendAsync("Content:RepositionInfoResponse", {
       reposition: true,
       raiseContent: result,
     });
   },
 
-  _onPing: function _onPing(aId) {
+  _onPing: function(aId) {
     this.sendAsync("Content:SelectionHandlerPong", { id: aId });
   },
 
   onClickCoords: function (xPos, yPos) {
     this.lastXPos = xPos;
     this.lastYPos = yPos;
   },
 
@@ -357,17 +357,17 @@ var SelectionHandler = {
    * Selection helpers
    */
 
   /*
    * _clearSelection
    *
    * Clear existing selection if it exists and reset our internla state.
    */
-  _clearSelection: function _clearSelection() {
+  _clearSelection: function() {
     this._clearTimers();
     if (this._contentWindow) {
       let selection = this._getSelection();
       if (selection)
         selection.removeAllRanges();
     } else {
       let selection = content.getSelection();
       if (selection)
@@ -375,34 +375,34 @@ var SelectionHandler = {
     }
   },
 
   /*
    * closeSelection
    *
    * Shuts SelectionHandler down.
    */
-  closeSelection: function closeSelection() {
+  closeSelection: function() {
     this._clearTimers();
     this._cache = null;
     this._contentWindow = null;
     this._targetElement = null;
     this._selectionMoveActive = false;
     this._contentOffset = null;
     this._domWinUtils = null;
     this._targetIsEditable = false;
     this._targetCoordinates = null;
     sendSyncMessage("Content:HandlerShutdown", {});
   },
 
   /*
    * Find content within frames - cache the target nsIDOMWindow,
    * client coordinate offset, target element, and dom utils interface.
    */
-  _initTargetInfo: function _initTargetInfo(aX, aY) {
+  _initTargetInfo: function(aX, aY) {
     // getCurrentWindowAndOffset takes client coordinates
     let { element: element,
           contentWindow: contentWindow,
           offset: offset,
           utils: utils } =
       Content.getCurrentWindowAndOffset(aX, aY);
     if (!contentWindow) {
       return false;
@@ -424,17 +424,17 @@ var SelectionHandler = {
    * _calcNewContentPosition - calculates the distance the browser should be
    * raised to move the focused form input out of the way of the soft
    * keyboard.
    *
    * @param aNewViewHeight the new content view height
    * @return 0 if no positioning is required or a positive val equal to the
    * distance content should be raised to center the target element.
    */
-  _calcNewContentPosition: function _calcNewContentPosition(aNewViewHeight) {
+  _calcNewContentPosition: function(aNewViewHeight) {
     // We have no target element but the keyboard is up
     // so lets not cover content that is below the keyboard
     if (!this._cache || !this._cache.element) {
       if (this.lastYPos != null && this.lastYPos > aNewViewHeight) {
         return Services.metro.keyboardHeight;
       }
       return 0;
     }
@@ -475,25 +475,25 @@ var SelectionHandler = {
   /*************************************************
    * Events
    */
 
   /*
    * Scroll + selection advancement timer when the monocle is
    * outside the bounds of an input control.
    */
-  scrollTimerCallback: function scrollTimerCallback() {
+  scrollTimerCallback: function() {
     let result = SelectionHandler.updateTextEditSelection();
     // Update monocle position and speed if we've dragged off to one side
     if (result.trigger) {
       SelectionHandler._updateSelectionUI("update", result.start, result.end);
     }
   },
 
-  receiveMessage: function sh_receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (this._debugEvents && aMessage.name != "Browser:SelectionMove") {
       Util.dumpLn("SelectionHandler:", aMessage.name);
     }
     let json = aMessage.json;
     switch (aMessage.name) {
       case "Browser:SelectionStart":
         this._onSelectionStart(json);
         break;
@@ -564,42 +564,42 @@ var SelectionHandler = {
         break;
     }
   },
 
   /*************************************************
    * Utilities
    */
 
-  _getDocShell: function _getDocShell(aWindow) {
+  _getDocShell: function(aWindow) {
     if (aWindow == null)
       return null;
     return aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                   .getInterface(Ci.nsIWebNavigation)
                   .QueryInterface(Ci.nsIDocShell);
   },
 
-  _getSelectedText: function _getSelectedText() {
+  _getSelectedText: function() {
     let selection = this._getSelection();
     if (selection)
       return selection.toString();
     return "";
   },
 
-  _getSelection: function _getSelection() {
+  _getSelection: function() {
     if (this._targetElement instanceof Ci.nsIDOMNSEditableElement) {
       return this._targetElement
                  .QueryInterface(Ci.nsIDOMNSEditableElement)
                  .editor.selection;
     } else if (this._contentWindow)
       return this._contentWindow.getSelection();
     return null;
   },
 
-  _getSelectController: function _getSelectController() {
+  _getSelectController: function() {
     if (this._targetElement instanceof Ci.nsIDOMNSEditableElement) {
       return this._targetElement
                  .QueryInterface(Ci.nsIDOMNSEditableElement)
                  .editor.selectionController;
     } else {
       let docShell = this._getDocShell(this._contentWindow);
       if (docShell == null)
         return null;
diff --git a/browser/metro/base/content/downloads.js b/browser/metro/base/content/downloads.js
--- a/browser/metro/base/content/downloads.js
+++ b/browser/metro/base/content/downloads.js
@@ -21,34 +21,34 @@ var MetroDownloadsView = {
   _progressNotificationInfo: new Map(),
   _runDownloadBooleanMap: new Map(),
 
   get manager() {
     return Cc["@mozilla.org/download-manager;1"]
              .getService(Ci.nsIDownloadManager);
   },
 
-  _getReferrerOrSource: function dh__getReferrerOrSource(aDownload) {
+  _getReferrerOrSource: function(aDownload) {
     return aDownload.referrer.spec || aDownload.source.spec;
   },
 
-  _getLocalFile: function dh__getLocalFile(aFileURI) {
+  _getLocalFile: function(aFileURI) {
     // XXX it's possible that using a null char-set here is bad
     let spec = ('string' == typeof aFileURI) ? aFileURI : aFileURI.spec;
     let fileUrl;
     try {
       fileUrl = Services.io.newURI(spec, null, null).QueryInterface(Ci.nsIFileURL);
     } catch (ex) {
       Util.dumpLn("_getLocalFile: Caught exception creating newURI from file spec: "+aFileURI.spec+": " + ex.message);
       return;
     }
     return fileUrl.file.clone().QueryInterface(Ci.nsILocalFile);
   },
 
-  init: function dh_init() {
+  init: function() {
     if (this._inited)
       return;
 
     this._inited = true;
 
     Services.obs.addObserver(this, "dl-start", true);
     Services.obs.addObserver(this, "dl-done", true);
     Services.obs.addObserver(this, "dl-run", true);
@@ -62,17 +62,17 @@ var MetroDownloadsView = {
 
     this._downloadProgressIndicator = document.getElementById("download-progress");
 
     if (this.manager.activeDownloadCount) {
       setTimeout (this._restartWithActiveDownloads.bind(this), 0);
     }
   },
 
-  uninit: function dh_uninit() {
+  uninit: function() {
     if (this._inited) {
       Services.obs.removeObserver(this, "dl-start");
       Services.obs.removeObserver(this, "dl-done");
       Services.obs.removeObserver(this, "dl-run");
       Services.obs.removeObserver(this, "dl-failed");
       if (Elements && Elements.tabList)
         Elements.tabList.removeEventListener("TabClose", this);
     }
@@ -133,45 +133,45 @@ var MetroDownloadsView = {
           break;
       }
     }
     if (this.manager.activeDownloadCount) {
       ContextUI.displayNavbar();
     }
   },
 
-  openDownload: function dh_openDownload(aDownload) {
+  openDownload: function(aDownload) {
     let fileURI = aDownload.target
 
     if (!(fileURI && fileURI.spec)) {
       Util.dumpLn("Cant open download "+id+", fileURI is invalid");
       return;
     }
 
     let file = this._getLocalFile(fileURI);
     try {
       file && Services.metro.launchInDesktop(aDownload.target.spec, "");
     } catch (ex) {
       Util.dumpLn("Failed to open download, with id: "+id+", download target URI spec: " + fileURI.spec);
       Util.dumpLn("Failed download source:"+(aDownload.source && aDownload.source.spec));
     }
   },
 
-  removeDownload: function dh_removeDownload(aDownload) {
+  removeDownload: function(aDownload) {
     // aDownload is the XUL element here,
     // and .target currently returns the target attribute (string value)
     let id = aDownload.getAttribute("downloadId");
     let download = this.manager.getDownload(id);
 
     if (download) {
       this.manager.removeDownload(id);
     }
   },
 
-  cancelDownload: function dh_cancelDownload(aDownload) {
+  cancelDownload: function(aDownload) {
     let fileURI = aDownload.target;
     if (!(fileURI && fileURI.spec)) {
       Util.dumpLn("Cant remove download file for: "+aDownload.id+", fileURI is invalid");
     }
 
     try {
       let file = this._getLocalFile(fileURI);
       if (file && file.exists())
@@ -189,54 +189,54 @@ var MetroDownloadsView = {
       }
     } catch (ex) {
       Util.dumpLn("Failed to cancel download, with id: "+aDownload.id+", download target URI spec: " + fileURI.spec);
       Util.dumpLn("Failed download source:"+(aDownload.source && aDownload.source.spec));
     }
   },
 
   // Cancels all downloads.
-  cancelDownloads: function dh_cancelDownloads() {
+  cancelDownloads: function() {
     for (let [guid, info] of this._progressNotificationInfo) {
       this.cancelDownload(info.download);
     }
     this._downloadCount = 0;
     this._progressNotificationInfo.clear();
     this._runDownloadBooleanMap.clear();
   },
 
-  pauseDownload: function dh_pauseDownload(aDownload) {
+  pauseDownload: function(aDownload) {
     let id = aDownload.getAttribute("downloadId");
     this.manager.pauseDownload(id);
   },
 
-  resumeDownload: function dh_resumeDownload(aDownload) {
+  resumeDownload: function(aDownload) {
     let id = aDownload.getAttribute("downloadId");
     this.manager.resumeDownload(id);
   },
 
-  showPage: function dh_showPage(aDownload) {
+  showPage: function(aDownload) {
     let id = aDownload.getAttribute("downloadId");
     let download = this.manager.getDownload(id);
     let uri = this._getReferrerOrSource(download);
     if (uri)
       BrowserUI.addAndShowTab(uri, Browser.selectedTab);
   },
 
-  showAlert: function dh_showAlert(aName, aMessage, aTitle, aObserver) {
+  showAlert: function(aName, aMessage, aTitle, aObserver) {
     var notifier = Cc["@mozilla.org/alerts-service;1"]
                      .getService(Ci.nsIAlertsService);
 
     if (!aTitle)
       aTitle = Strings.browser.GetStringFromName("alertDownloads");
 
     notifier.showAlertNotification("", aTitle, aMessage, true, "", aObserver, aName);
   },
 
-  showNotification: function dh_showNotification(title, msg, buttons, priority) {
+  showNotification: function(title, msg, buttons, priority) {
     let notification = this._notificationBox.appendNotification(msg,
                                               title,
                                               URI_GENERIC_ICON_DOWNLOAD,
                                               priority,
                                               buttons);
     return notification;
   },
 
@@ -357,32 +357,32 @@ var MetroDownloadsView = {
   _resetCompletedDownloads: function () {
     this._progressNotificationInfo.clear();
     this._downloadCount = 0;
     this._lastDownload = null;
     this._downloadProgressIndicator.reset();
     this._removeNotification("download-complete");
   },
 
-  _updateCircularProgressMeter: function dv_updateCircularProgressMeter() {
+  _updateCircularProgressMeter: function() {
     if (!this._progressNotificationInfo) {
       return;
     }
 
     let totPercent = 0;
     for (let [guid, info] of this._progressNotificationInfo) {
       // info.download => nsIDownload
       totPercent += info.download.percentComplete;
     }
 
     let percentComplete = totPercent / this._progressNotificationInfo.size;
     this._downloadProgressIndicator.updateProgress(percentComplete);
   },
 
-  _computeDownloadProgressString: function dv_computeDownloadProgressString() {
+  _computeDownloadProgressString: function() {
     let totTransferred = 0, totSize = 0, totSecondsLeft = 0;
     let guid, info;
     for ([guid, info] of this._progressNotificationInfo) {
       let size = info.download.size;
       let amountTransferred = info.download.amountTransferred;
       let speed = info.download.speed;
 
       totTransferred += amountTransferred;
@@ -409,26 +409,26 @@ var MetroDownloadsView = {
     let numDownloads = this._downloadCount;
     return PluralForm.get(numDownloads,
                           Strings.browser.GetStringFromName("alertDownloadMultiple"))
                           .replace("#1", numDownloads)
                           .replace("#2", progress)
                           .replace("#3", timeLeft);
   },
 
-  _saveDownloadData: function dv_saveDownloadData(aDownload) {
+  _saveDownloadData: function(aDownload) {
     if (!this._progressNotificationInfo.get(aDownload.guid)) {
       this._progressNotificationInfo.set(aDownload.guid, {});
     }
     let infoObj = this._progressNotificationInfo.get(aDownload.guid);
     infoObj.download = aDownload;
     this._progressNotificationInfo.set(aDownload.guid, infoObj);
   },
 
-  onDownloadButton: function dv_onDownloadButton() {
+  onDownloadButton: function() {
     let progressNotification = this._getNotificationWithValue("download-progress");
     let wasProgressVisible = (progressNotification &&
                               progressNotification.parentNode == this._notificationBox);
     let completeNotification = this._getNotificationWithValue("download-complete");
     let wasCompleteVisible = (completeNotification &&
                               completeNotification.parentNode == this._notificationBox);
 
     this._removeNotification("download-complete");
@@ -442,17 +442,17 @@ var MetroDownloadsView = {
   },
 
   _removeNotification: function (aValue) {
     let notification = this._getNotificationWithValue(aValue);
     return notification &&
            notification.parentNode.removeNotification(notification);
   },
 
-  updateInfobar: function dv_updateInfobar() {
+  updateInfobar: function() {
     let message = this._computeDownloadProgressString();
     this._updateCircularProgressMeter();
 
     let notn = this._progressNotification;
     if (!notn) {
       let cancelButtonText =
               Strings.browser.GetStringFromName("downloadCancel");
 
@@ -472,27 +472,27 @@ var MetroDownloadsView = {
              this._notificationBox.PRIORITY_WARNING_LOW);
 
       ContextUI.displayNavbar();
     } else {
       notn.label = message;
     }
   },
 
-  updateDownload: function dv_updateDownload(aDownload) {
+  updateDownload: function(aDownload) {
     this._saveDownloadData(aDownload);
     let notn = this._progressNotification;
     if (notn) {
       notn.label =
         this._computeDownloadProgressString(aDownload);
     }
     this._updateCircularProgressMeter();
   },
 
-  watchDownload: function dv_watchDownload(aDownload) {
+  watchDownload: function(aDownload) {
     this._saveDownloadData(aDownload);
     this._downloadCount++;
     this._downloadsInProgress++;
     if (!this._progressNotificationInfo.get(aDownload.guid)) {
       this._progressNotificationInfo.set(aDownload.guid, {});
     }
     if (!this._progressAlert) {
       this._progressAlert = new AlertDownloadProgressListener();
@@ -595,22 +595,22 @@ function DownloadProgressListener(aDownl
   this._downloads = aDownloads;
 }
 
 DownloadProgressListener.prototype = {
   _downloads: null,
 
   //////////////////////////////////////////////////////////////////////////////
   //// nsIDownloadProgressListener
-  onDownloadStateChange: function dPL_onDownloadStateChange(aState, aDownload) {
+  onDownloadStateChange: function(aState, aDownload) {
     // TODO: Use DownloadProgressListener instead of observers in the Downloads object.
     this._downloads.updateDownload(aDownload);
   },
 
-  onProgressChange: function dPL_onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress, aDownload) {
+  onProgressChange: function(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress, aDownload) {
     // TODO <jwilde>: Add more detailed progress information.
     this._downloads.updateDownload(aDownload);
   },
 
   onStateChange: function(aWebProgress, aRequest, aState, aStatus, aDownload) { },
   onSecurityChange: function(aWebProgress, aRequest, aState, aDownload) { },
 
   //////////////////////////////////////////////////////////////////////////////
diff --git a/browser/metro/base/content/exceptions.js b/browser/metro/base/content/exceptions.js
--- a/browser/metro/base/content/exceptions.js
+++ b/browser/metro/base/content/exceptions.js
@@ -17,41 +17,41 @@ function SSLExceptions() {
                           .getService(Ci.nsICertOverrideService);
 }
 
 
 SSLExceptions.prototype = {
   _overrideService: null,
   _sslStatus: null,
 
-  getInterface: function SSLE_getInterface(aIID) {
+  getInterface: function(aIID) {
     return this.QueryInterface(aIID);
   },
-  QueryInterface: function SSLE_QueryInterface(aIID) {
+  QueryInterface: function(aIID) {
     if (aIID.equals(Ci.nsIBadCertListener2) ||
         aIID.equals(Ci.nsISupports))
       return this;
 
     throw Components.results.NS_ERROR_NO_INTERFACE;
   },
 
   /**
     To collect the SSL status we intercept the certificate error here
     and store the status for later use.
   */
-  notifyCertProblem: function SSLE_notifyCertProblem(socketInfo, sslStatus, targetHost) {
+  notifyCertProblem: function(socketInfo, sslStatus, targetHost) {
     this._sslStatus = sslStatus.QueryInterface(Ci.nsISSLStatus);
     return true; // suppress error UI
   },
 
   /**
     Attempt to download the certificate for the location specified to get the SSLState
     for the certificate and the errors.
    */
-  _checkCert: function SSLE_checkCert(aURI) {
+  _checkCert: function(aURI) {
     this._sslStatus = null;
   
     var req = new XMLHttpRequest();
     try {
       if(aURI) {
         req.open("GET", aURI.prePath, false);
         req.channel.notificationCallbacks = this;
         req.send(null);
@@ -66,17 +66,17 @@ SSLExceptions.prototype = {
     }
 
     return this._sslStatus;
   },
 
   /**
     Internal method to create an override.
   */
-  _addOverride: function SSLE_addOverride(aURI, aWindow, temporary) {
+  _addOverride: function(aURI, aWindow, temporary) {
     var SSLStatus = this._checkCert(aURI);
     var certificate = SSLStatus.serverCert;
 
     var flags = 0;
 
     // in private browsing do not store exceptions permanently ever
     if (PrivateBrowsingUtils.isWindowPrivate(aWindow)) {
       temporary = true;
@@ -96,20 +96,20 @@ SSLExceptions.prototype = {
       flags,
       temporary);
   },
 
   /**
     Creates a permanent exception to override all overridable errors for
     the given URL.
   */
-  addPermanentException: function SSLE_addPermanentException(aURI, aWindow) {
+  addPermanentException: function(aURI, aWindow) {
     this._addOverride(aURI, aWindow, false);
   },
 
   /**
     Creates a temporary exception to override all overridable errors for
     the given URL.
   */
-  addTemporaryException: function SSLE_addTemporaryException(aURI, aWindow) {
+  addTemporaryException: function(aURI, aWindow) {
     this._addOverride(aURI, aWindow, true);
   }
 };
diff --git a/browser/metro/base/content/flyoutpanels/PrefsFlyoutPanel.js b/browser/metro/base/content/flyoutpanels/PrefsFlyoutPanel.js
--- a/browser/metro/base/content/flyoutpanels/PrefsFlyoutPanel.js
+++ b/browser/metro/base/content/flyoutpanels/PrefsFlyoutPanel.js
@@ -4,17 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 'use strict';
 
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 let PrefsFlyoutPanel = {
   _isInitialized: false,
   _hasShown: false,
-  init: function pv_init() {
+  init: function() {
     if (this._isInitialized) {
       Cu.reportError("Attempting to re-initialize PreferencesPanelView");
       return;
     }
 
     Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
     this._isInitialized = true;
     let self = this;
diff --git a/browser/metro/base/content/flyoutpanels/SearchFlyoutPanel.js b/browser/metro/base/content/flyoutpanels/SearchFlyoutPanel.js
--- a/browser/metro/base/content/flyoutpanels/SearchFlyoutPanel.js
+++ b/browser/metro/base/content/flyoutpanels/SearchFlyoutPanel.js
@@ -7,26 +7,26 @@
 
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 let SearchFlyoutPanel = {
   _isInitialized: false,
   _hasShown: false,
-  init: function pv_init() {
+  init: function() {
     if (this._isInitialized) {
       Cu.reportError("Attempting to re-initialize PreferencesPanelView");
       return;
     }
     this._topmostElement = document.getElementById("search-flyoutpanel");
     this._isInitialized = true;
   },
 
-  checked: function checked(aId) {
+  checked: function(aId) {
     aId = aId.replace("search-", "");
     Services.search.defaultEngine = this._engines[parseInt(aId)];
     this.updateSearchEngines();
   },
 
   updateSearchEngines: function () {
     // Clear the list
     let setting = document.getElementById("search-options");
diff --git a/browser/metro/base/content/flyoutpanels/SettingsCharm.js b/browser/metro/base/content/flyoutpanels/SettingsCharm.js
--- a/browser/metro/base/content/flyoutpanels/SettingsCharm.js
+++ b/browser/metro/base/content/flyoutpanels/SettingsCharm.js
@@ -6,27 +6,27 @@ var SettingsCharm = {
   _entries: new Map(),
   _nextId: 0,
 
   /**
    * Add a new item to the "Settings" menu in the Windows 8 charms.
    * @param aEntry Object with a "label" property (string that will appear in the UI)
    *    and an "onselected" property (function to be called when the user chooses this entry)
    */
-  addEntry: function addEntry(aEntry) {
+  addEntry: function(aEntry) {
     try {
       let id = Services.metro.addSettingsPanelEntry(aEntry.label);
       this._entries.set(id, aEntry);
     } catch (e) {
       // addSettingsPanelEntry does not work on non-Metro platforms
       Cu.reportError(e);
     }
   },
 
-  init: function SettingsCharm_init() {
+  init: function() {
     Services.obs.addObserver(this, "metro-settings-entry-selected", false);
 
     // Options
     this.addEntry({
         label: Strings.browser.GetStringFromName("optionsCharm"),
         onselected: function() FlyoutPanelsUI.show('PrefsFlyoutPanel')
     });
 
@@ -67,20 +67,20 @@ var SettingsCharm = {
         onselected: function() {
           let url = Services.urlFormatter.formatURLPref("app.support.baseURL") +
             "firefox-help";
           BrowserUI.addAndShowTab(url, Browser.selectedTab);
         }
     });
   },
 
-  observe: function SettingsCharm_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (aTopic == "metro-settings-entry-selected") {
       let entry = this._entries.get(parseInt(aData, 10));
       if (entry)
         entry.onselected();
     }
   },
 
-  uninit: function SettingsCharm_uninit() {
+  uninit: function() {
     Services.obs.removeObserver(this, "metro-settings-entry-selected");
   }
 };
diff --git a/browser/metro/base/content/flyoutpanels/SyncFlyoutPanel.js b/browser/metro/base/content/flyoutpanels/SyncFlyoutPanel.js
--- a/browser/metro/base/content/flyoutpanels/SyncFlyoutPanel.js
+++ b/browser/metro/base/content/flyoutpanels/SyncFlyoutPanel.js
@@ -177,42 +177,42 @@ let SyncFlyoutPanel = {
 
     // Set up our back button to do the appropriate action
     this._onBackButton = function() {
       self.abortEasySetup();
       self.showInitialScreen();
     };
 
     this._setupJpake = new Weave.JPAKEClient({
-      displayPIN: function displayPIN(aPin) {
+      displayPIN: function(aPin) {
         self._elements.setupCode1.value = aPin.slice(0, 4);
         self._elements.setupCode2.value = aPin.slice(4, 8);
         self._elements.setupCode3.value = aPin.slice(8);
       },
 
-      onPairingStart: function onPairingStart() {
+      onPairingStart: function() {
         self._elements.setupThrobber.collapsed = false;
         self._elements.setupThrobber.enabled = true;
       },
 
-      onComplete: function onComplete(aCredentials) {
+      onComplete: function(aCredentials) {
         Weave.Service.identity.account = aCredentials.account;
         Weave.Service.identity.basicPassword = aCredentials.password;
         Weave.Service.identity.syncKey = aCredentials.synckey;
         Weave.Service.serverURL = aCredentials.serverURL;
         Weave.Service.persistLogin();
         Weave.Service.scheduler.scheduleNextSync(0);
 
         if (self._currentlyVisibleContainer == self._elements.easySetup) {
           self.showSetupSuccess();
         }
         self._cleanUpEasySetup();
       },
 
-      onAbort: function onAbort(aError) {
+      onAbort: function(aError) {
         if (aError == "jpake.error.userabort") {
           Services.obs.notifyObservers(null, "browser:sync:setup:userabort", "");
           self._cleanUpEasySetup();
           return;
         } else if (aError == "jpake.error.network") {
           Services.obs.notifyObservers(null, "browser:sync:setup:networkerror", "");
         }
 
diff --git a/browser/metro/base/content/helperui/AlertsHelper.js b/browser/metro/base/content/helperui/AlertsHelper.js
--- a/browser/metro/base/content/helperui/AlertsHelper.js
+++ b/browser/metro/base/content/helperui/AlertsHelper.js
@@ -1,31 +1,31 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 var AlertsHelper = {
   _listener: null,
 
-  showAlertNotification: function ah_show(aImageURL, aTitle, aText, aTextClickable, aCookie, aListener) {
+  showAlertNotification: function(aImageURL, aTitle, aText, aTextClickable, aCookie, aListener) {
     if (aListener) {
       Services.obs.addObserver(this, "metro_native_toast_clicked", false);
       Services.obs.addObserver(this, "metro_native_toast_dismissed", false);
       Services.obs.addObserver(this, "metro_native_toast_shown", false);
     }
     this._listener = aListener;
 
     if (Services.metro.foreground) {
       // Firefox is in the foreground, no need for a notification.
       return;
     }
     Services.metro.showNativeToast(aTitle, aText, aImageURL, aCookie);
   },
 
-  closeAlert: function ah_close() {
+  closeAlert: function() {
     if (this._listener) {
       Services.obs.removeObserver(this, "metro_native_toast_shown");
       Services.obs.removeObserver(this, "metro_native_toast_clicked");
       Services.obs.removeObserver(this, "metro_native_toast_dismissed");
       this._listener = null;
     }
   },
 
diff --git a/browser/metro/base/content/helperui/ChromeSelectionHandler.js b/browser/metro/base/content/helperui/ChromeSelectionHandler.js
--- a/browser/metro/base/content/helperui/ChromeSelectionHandler.js
+++ b/browser/metro/base/content/helperui/ChromeSelectionHandler.js
@@ -10,31 +10,31 @@ let Ci = Components.interfaces;
 
 var ChromeSelectionHandler = {
   _mode: this._SELECTION_MODE,
 
   /*************************************************
    * Messaging wrapper
    */
 
-  sendAsync: function sendAsync(aMsg, aJson) {
+  sendAsync: function(aMsg, aJson) {
     SelectionHelperUI.receiveMessage({ 
       name: aMsg,
       json: aJson
     });
   },
 
   /*************************************************
    * Browser event handlers
    */
 
   /*
    * General selection start method for both caret and selection mode.
    */
-  _onSelectionAttach: function _onSelectionAttach(aJson) {
+  _onSelectionAttach: function(aJson) {
     // Clear previous ChromeSelectionHandler state.
     this._deactivate();
 
     // Initialize ChromeSelectionHandler state.
     this._domWinUtils = Util.getWindowUtils(window);
     this._contentWindow = window;
     this._targetElement = aJson.target;
     this._targetIsEditable = Util.isTextInput(this._targetElement) ||
@@ -67,17 +67,17 @@ var ChromeSelectionHandler = {
     }
 
     this._targetElement.addEventListener("blur", this, false);
   },
 
   /*
    * Selection monocle start move event handler
    */
-  _onSelectionMoveStart: function _onSelectionMoveStart(aMsg) {
+  _onSelectionMoveStart: function(aMsg) {
     if (!this.targetIsEditable) {
       this._onFail("_onSelectionMoveStart with bad targetElement.");
       return;
     }
 
     if (this._selectionMoveActive) {
       this._onFail("mouse is already down on drag start?");
       return;
@@ -96,34 +96,34 @@ var ChromeSelectionHandler = {
 
     // Update the position of our selection monocles
     this._updateSelectionUI("update", true, true);
   },
   
   /*
    * Selection monocle move event handler
    */
-  _onSelectionMove: function _onSelectionMove(aMsg) {
+  _onSelectionMove: function(aMsg) {
     if (!this.targetIsEditable) {
       this._onFail("_onSelectionMove with bad targetElement.");
       return;
     }
 
     if (!this._selectionMoveActive) {
       this._onFail("mouse isn't down for drag move?");
       return;
     }
 
     this._handleSelectionPoint(aMsg, false);
   },
 
   /*
    * Selection monocle move finished event handler
    */
-  _onSelectionMoveEnd: function _onSelectionMoveComplete(aMsg) {
+  _onSelectionMoveEnd: function(aMsg) {
     if (!this.targetIsEditable) {
       this._onFail("_onSelectionMoveEnd with bad targetElement.");
       return;
     }
 
     if (!this._selectionMoveActive) {
       this._onFail("mouse isn't down for drag move?");
       return;
@@ -134,32 +134,32 @@ var ChromeSelectionHandler = {
     
     // Clear any existing scroll timers
     this._clearTimers();
 
     // Update the position of our selection monocles
     this._updateSelectionUI("end", true, true);
   },
 
-  _onSelectionUpdate: function _onSelectionUpdate() {
+  _onSelectionUpdate: function() {
     if (!this._targetHasFocus()) {
       this._closeSelection();
       return;
     }
     this._updateSelectionUI("update",
                             this._mode == this._SELECTION_MODE,
                             this._mode == this._SELECTION_MODE,
                             this._mode == this._CARET_MODE);
   },
 
   /*
    * Switch selection modes. Currently we only support switching
    * from "caret" to "selection".
    */
-  _onSwitchMode: function _onSwitchMode(aMode, aMarker, aX, aY) {
+  _onSwitchMode: function(aMode, aMarker, aX, aY) {
     if (aMode != "selection") {
       this._onFail("unsupported mode switch");
       return;
     }
     
     // Sanity check to be sure we are initialized
     if (!this._targetElement) {
       this._onFail("not initialized");
@@ -184,108 +184,108 @@ var ChromeSelectionHandler = {
     this._updateSelectionUI("update", aMarker == "end", aMarker == "start");
   },
 
   /*
    * Selection close event handler
    *
    * @param aClearSelection requests that selection be cleared.
    */
-  _onSelectionClose: function _onSelectionClose(aClearSelection) {
+  _onSelectionClose: function(aClearSelection) {
     if (aClearSelection) {
       this._clearSelection();
     }
     this._closeSelection();
   },
 
   /*
    * Called if for any reason we fail during the selection
    * process. Cancels the selection.
    */
-  _onFail: function _onFail(aDbgMessage) {
+  _onFail: function(aDbgMessage) {
     if (aDbgMessage && aDbgMessage.length > 0)
       Util.dumpLn(aDbgMessage);
     this.sendAsync("Content:SelectionFail");
     this._clearSelection();
     this._closeSelection();
   },
 
   /*
    * Empty conversion routines to match those in
    * browser. Called by SelectionHelperUI when
    * sending and receiving coordinates in messages.
    */
 
-  ptClientToBrowser: function ptClientToBrowser(aX, aY, aIgnoreScroll, aIgnoreScale) {
+  ptClientToBrowser: function(aX, aY, aIgnoreScroll, aIgnoreScale) {
     return { x: aX, y: aY }
   },
 
-  rectBrowserToClient: function rectBrowserToClient(aRect, aIgnoreScroll, aIgnoreScale) {
+  rectBrowserToClient: function(aRect, aIgnoreScroll, aIgnoreScale) {
     return {
       left: aRect.left,
       right: aRect.right,
       top: aRect.top,
       bottom: aRect.bottom
     }
   },
 
-  ptBrowserToClient: function ptBrowserToClient(aX, aY, aIgnoreScroll, aIgnoreScale) {
+  ptBrowserToClient: function(aX, aY, aIgnoreScroll, aIgnoreScale) {
     return { x: aX, y: aY }
   },
 
-  ctobx: function ctobx(aCoord) {
+  ctobx: function(aCoord) {
     return aCoord;
   },
 
-  ctoby: function ctoby(aCoord) {
+  ctoby: function(aCoord) {
     return aCoord;
   },
 
-  btocx: function btocx(aCoord) {
+  btocx: function(aCoord) {
     return aCoord;
   },
 
-  btocy: function btocy(aCoord) {
+  btocy: function(aCoord) {
     return aCoord;
   },
 
 
   /*************************************************
    * Selection helpers
    */
 
   /*
    * _clearSelection
    *
    * Clear existing selection if it exists and reset our internal state.
    */
-  _clearSelection: function _clearSelection() {
+  _clearSelection: function() {
     let selection = this._getSelection();
     if (selection) {
       selection.removeAllRanges();
     }
   },
 
   /*
    * _closeSelection
    *
    * Shuts ChromeSelectionHandler and SelectionHelperUI down.
    */
-  _closeSelection: function _closeSelection() {
+  _closeSelection: function() {
     this._deactivate();
     this.sendAsync("Content:HandlerShutdown", {});
   },
 
   /*
    * _deactivate
    *
    * Resets ChromeSelectionHandler state, previously initialized in
    * general selection start-method |_onSelectionAttach()|.
    */
-  _deactivate: function _deactivate() {
+  _deactivate: function() {
     // Remove our selection notification listener.
     let selection = this._getSelection();
     if (selection) {
       try {
         selection.QueryInterface(Ci.nsISelectionPrivate).removeSelectionListener(this);
       } catch(e) {
         // Fail safe during multiple _deactivate() calls.
       }
@@ -323,31 +323,31 @@ var ChromeSelectionHandler = {
   /*************************************************
    * Events
    */
 
   /*
    * Scroll + selection advancement timer when the monocle is
    * outside the bounds of an input control.
    */
-  scrollTimerCallback: function scrollTimerCallback() {
+  scrollTimerCallback: function() {
     let result = ChromeSelectionHandler.updateTextEditSelection();
     // Update monocle position and speed if we've dragged off to one side
     if (result.trigger) {
       ChromeSelectionHandler._updateSelectionUI("update", result.start, result.end);
     }
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (aEvent.type == "blur" && !this._targetHasFocus()) {
       this._closeSelection();
     }
   },
 
-  msgHandler: function msgHandler(aMsg, aJson) {
+  msgHandler: function(aMsg, aJson) {
     if (this._debugEvents && "Browser:SelectionMove" != aMsg) {
       Util.dumpLn("ChromeSelectionHandler:", aMsg);
     }
     switch(aMsg) {
       case "Browser:SelectionDebug":
         this._onSelectionDebug(aJson);
         break;
 
@@ -392,32 +392,32 @@ var ChromeSelectionHandler = {
         break;
     }
   },
 
   /*************************************************
    * Utilities
    */
 
-  _getSelection: function _getSelection() {
+  _getSelection: function() {
     let targetElementEditor = this._getTargetElementEditor();
 
     return targetElementEditor ? targetElementEditor.selection : null;
   },
 
-  _getTargetElementValue: function _getTargetElementValue() {
+  _getTargetElementValue: function() {
     if (this._targetElement instanceof Ci.nsIDOMXULTextBoxElement) {
       return this._targetElement.inputField.value;
     } else if (Util.isTextInput(this._targetElement)) {
       return this._targetElement.value;
     }
     return null;
   },
 
-  _getSelectController: function _getSelectController() {
+  _getSelectController: function() {
     let targetElementEditor = this._getTargetElementEditor();
 
     return targetElementEditor ? targetElementEditor.selectionController : null;
   },
 
   _getTargetElementEditor: function() {
     if (this._targetElement instanceof Ci.nsIDOMXULTextBoxElement) {
       return this._targetElement.QueryInterface(Ci.nsIDOMXULTextBoxElement)
diff --git a/browser/metro/base/content/helperui/FindHelperUI.js b/browser/metro/base/content/helperui/FindHelperUI.js
--- a/browser/metro/base/content/helperui/FindHelperUI.js
+++ b/browser/metro/base/content/helperui/FindHelperUI.js
@@ -38,33 +38,33 @@ var FindHelperUI = {
       if (!val)
         this._textbox.removeAttribute("status");
       else
         this._textbox.setAttribute("status", val);
       this.updateCommands(this._textbox.value);
     }
   },
 
-  init: function findHelperInit() {
+  init: function() {
     this._textbox = document.getElementById("findbar-textbox");
     this._container = Elements.findbar;
 
     this._cmdPrevious = document.getElementById(this.commands.previous);
     this._cmdNext = document.getElementById(this.commands.next);
 
     this._textbox.addEventListener("keydown", this);
 
     // Listen for events where form assistant should be closed
     Elements.tabList.addEventListener("TabSelect", this, true);
     Elements.browsers.addEventListener("URLChanged", this, true);
     window.addEventListener("MozAppbarShowing", this);
     window.addEventListener("MozFlyoutPanelShowing", this, false);
   },
 
-  handleEvent: function findHelperHandleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "TabSelect":
         this.hide();
         break;
 
       case "URLChanged":
         if (aEvent.detail && aEvent.target == getBrowser())
           this.hide();
@@ -81,17 +81,17 @@ var FindHelperUI = {
       case "MozFlyoutPanelShowing":
         if (aEvent.target != this._container) {
           this.hide();
         }
         break;
     }
   },
 
-  show: function findHelperShow() {
+  show: function() {
     if (BrowserUI.isStartTabVisible) {
       return;
     }
     if (this._open) {
       setTimeout(() => {
         this._textbox.select();
         this._textbox.focus();
       }, 0);
@@ -113,17 +113,17 @@ var FindHelperUI = {
 
       this._open = true;
     }, 0);
 
     // Prevent the view to scroll automatically while searching
     Browser.selectedBrowser.scrollSync = false;
   },
 
-  hide: function findHelperHide() {
+  hide: function() {
     if (!this._open)
       return;
 
     ContentAreaObserver.shiftBrowserDeck(0);
 
     let onTransitionEnd = () => {
       this._container.removeEventListener("transitionend", onTransitionEnd, true);
       this._textbox.value = "";
@@ -137,62 +137,62 @@ var FindHelperUI = {
       Browser.selectedBrowser.scrollSync = true;
     };
 
     this._textbox.blur();
     this._container.addEventListener("transitionend", onTransitionEnd, true);
     this._container.dismiss();
   },
 
-  search: function findHelperSearch(aValue) {
+  search: function(aValue) {
     if (!this._finder) {
       this._finder = Browser.selectedBrowser.finder;
       this._finder.addResultListener(this);
     }
     this._searchString = aValue;
     if (aValue != "") {
       this._finder.fastFind(aValue, false, false);
     } else {
       this.updateCommands();
     }
   },
 
-  searchAgain: function findHelperSearchAgain(aValue, aFindBackwards) {
+  searchAgain: function(aValue, aFindBackwards) {
     // This can happen if the user taps next/previous after re-opening the search bar
     if (!this._finder) {
       this.search(aValue);
       return;
     }
 
     this._finder.findAgain(aFindBackwards, false, false);
   },
 
-  goToPrevious: function findHelperGoToPrevious() {
+  goToPrevious: function() {
     this.searchAgain(this._searchString, true);
   },
 
-  goToNext: function findHelperGoToNext() {
+  goToNext: function() {
     this.searchAgain(this._searchString, false);
   },
 
   onFindResult: function(aData) {
     this._status = aData.result;
     if (aData.rect) {
       this._zoom(aData.rect, Browser.selectedBrowser.contentDocumentHeight);
     }
     this.updateCommands();
   },
 
-  updateCommands: function findHelperUpdateCommands() {
+  updateCommands: function() {
     let disabled = (this._status == Ci.nsITypeAheadFind.FIND_NOTFOUND) || (this._searchString == "");
     this._cmdPrevious.setAttribute("disabled", disabled);
     this._cmdNext.setAttribute("disabled", disabled);
   },
 
-  _zoom: function _findHelperZoom(aElementRect, aContentHeight) {
+  _zoom: function(aElementRect, aContentHeight) {
     // The rect we get here is the content rect including scroll offset
     // in the page.
 
     // If the text falls below the find bar and keyboard shift content up.
     let browserShift = 0;
     // aElementRect.y is the top left origin of the selection rect.
     if ((aElementRect.y + aElementRect.height) >
         (aContentHeight - this._container.boxObject.height)) {
diff --git a/browser/metro/base/content/helperui/FormHelperUI.js b/browser/metro/base/content/helperui/FormHelperUI.js
--- a/browser/metro/base/content/helperui/FormHelperUI.js
+++ b/browser/metro/base/content/helperui/FormHelperUI.js
@@ -13,17 +13,17 @@ var FormHelperUI = {
   _currentBrowser: null,
   _currentElement: null,
   _currentCaretRect: null,
   _currentElementRect: null,
   _open: false,
 
   type: "form",
 
-  init: function formHelperInit() {
+  init: function() {
     // Listen for form assistant messages from content
     messageManager.addMessageListener("FormAssist:Show", this);
     messageManager.addMessageListener("FormAssist:Hide", this);
     messageManager.addMessageListener("FormAssist:Update", this);
     messageManager.addMessageListener("FormAssist:AutoComplete", this);
 
     // Listen for events where form assistant should be closed or updated
     let tabs = Elements.tabList;
@@ -36,17 +36,17 @@ var FormHelperUI = {
     Elements.browsers.addEventListener("PanBegin", this, false);
     Elements.browsers.addEventListener("PanFinished", this, false);
   },
 
   /*
    * Open of the form helper proper. Currently doesn't display anything
    * on metro since the nav buttons are off.
    */
-  show: function formHelperShow(aElement) {
+  show: function(aElement) {
     // Delay the operation until all resize operations generated by the
     // keyboard apparition are done.
     if (!InputSourceHelper.isPrecise && aElement.editable &&
         ContentAreaObserver.isKeyboardTransitioning) {
       this._waitForKeyboard(aElement);
       return;
     }
 
@@ -72,17 +72,17 @@ var FormHelperUI = {
     this._showAutoCompleteSuggestions(this._currentElement);
 
     // Prevent the view to scroll automatically while typing
     this._currentBrowser.scrollSync = false;
 
     this._open = true;
   },
 
-  hide: function formHelperHide() {
+  hide: function() {
     this._open = false;
 
     SelectHelperUI.hide();
     AutofillMenuUI.hide();
 
     // Restore the scroll synchonisation
     if (this._currentBrowser)
       this._currentBrowser.scrollSync = true;
@@ -91,17 +91,17 @@ var FormHelperUI = {
     this._currentElementRect = null;
     this._currentCaretRect = null;
 
     this._updateContainerForSelect(this._currentElement, null);
     if (this._currentBrowser)
       this._currentBrowser.messageManager.sendAsyncMessage("FormAssist:Closed", { });
   },
 
-  _onShowRequest: function _onShowRequest(aJsonMsg) {
+  _onShowRequest: function(aJsonMsg) {
     if (aJsonMsg.current.choices) {
       // Note, aJsonMsg.current.rect is translated from browser to client
       // in the SelectHelperUI code.
       SelectHelperUI.show(aJsonMsg.current.choices, aJsonMsg.current.title,
                           aJsonMsg.current.rect);
     } else {
       this._currentBrowser = getBrowser();
       this._currentElementRect =
@@ -109,17 +109,17 @@ var FormHelperUI = {
       this.show(aJsonMsg.current);
     }
   },
 
   /*
    * Events
    */
 
-  handleEvent: function formHelperHandleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (this._debugEvents) Util.dumpLn(aEvent.type);
 
     if (!this._open)
       return;
 
     switch (aEvent.type) {
       case "TabSelect":
       case "TabClose":
@@ -130,17 +130,17 @@ var FormHelperUI = {
 
       case "URLChanged":
         if (aEvent.detail && aEvent.target == getBrowser())
           this.hide();
         break;
     }
   },
 
-  receiveMessage: function formHelperReceiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (this._debugEvents) Util.dumpLn(aMessage.name);
     let json = aMessage.json;
 
     switch (aMessage.name) {
       case "FormAssist:Show":
         this._onShowRequest(json);
         break;
 
@@ -149,17 +149,17 @@ var FormHelperUI = {
         break;
 
       case "FormAssist:AutoComplete":
         this.show(json.current);
         break;
     }
   },
 
-  doAutoComplete: function formHelperDoAutoComplete(aData) {
+  doAutoComplete: function(aData) {
     this._currentBrowser.messageManager.sendAsyncMessage("FormAssist:AutoComplete",
       { value: aData });
   },
 
   /*
    * Retrieves autocomplete suggestions asynchronously for an element from the
    * form autocomplete service and updates and displays the autocompletepopup.
    *
@@ -223,27 +223,27 @@ var FormHelperUI = {
     this._formAutoCompleteService.autoCompleteSearchAsync(aElement.name || aElement.id,
                                                           aSearchString, aElement, null,
                                                           resultsAvailable);
   },
   
   /*
    * Setup for displaying the selection choices menu
    */
-  _updateContainerForSelect: function _formHelperUpdateContainerForSelect(aLastElement, aCurrentElement) {
+  _updateContainerForSelect: function(aLastElement, aCurrentElement) {
     let lastHasChoices = aLastElement && (aLastElement.choices != null);
     let currentHasChoices = aCurrentElement && (aCurrentElement.choices != null);
 
     if (currentHasChoices)
       SelectHelperUI.show(aCurrentElement.choices, aCurrentElement.title, aCurrentElement.rect);
     else if (lastHasChoices)
       SelectHelperUI.hide();
   },
 
-  _waitForKeyboard: function formHelperWaitForKeyboard(aElement) {
+  _waitForKeyboard: function(aElement) {
     let self = this;
     window.addEventListener("KeyboardChanged", function(aEvent) {
       window.removeEventListener("KeyboardChanged", arguments.callee, false);
       self._currentBrowser.messageManager.sendAsyncMessage("FormAssist:Update", {});
     }, false);
   }
 };
 
diff --git a/browser/metro/base/content/helperui/ItemPinHelper.js b/browser/metro/base/content/helperui/ItemPinHelper.js
--- a/browser/metro/base/content/helperui/ItemPinHelper.js
+++ b/browser/metro/base/content/helperui/ItemPinHelper.js
@@ -9,51 +9,51 @@ function ItemPinHelper(aUnpinnedPrefName
   this._prefKey = aUnpinnedPrefName;
 }
 
 // Cache preferences on a static variable shared
 // by all instances registered to the same pref key.
 ItemPinHelper._prefValue = {};
 
 ItemPinHelper.prototype = {
-  _getPrefValue: function _getPrefValue() {
+  _getPrefValue: function() {
     if (ItemPinHelper._prefValue[this._prefKey])
       return ItemPinHelper._prefValue[this._prefKey];
 
     try {
       // getComplexValue throws if pref never set. Really.
       let prefValue = Services.prefs.getComplexValue(this._prefKey, Ci.nsISupportsString);
       ItemPinHelper._prefValue[this._prefKey] = JSON.parse(prefValue.data);
     } catch(e) {
       ItemPinHelper._prefValue[this._prefKey] = [];
     }
 
     return ItemPinHelper._prefValue[this._prefKey];
   },
 
-  _setPrefValue: function _setPrefValue(aNewValue) {
+  _setPrefValue: function(aNewValue) {
     let stringified = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
     stringified.data = JSON.stringify(aNewValue);
 
     Services.prefs.setComplexValue(this._prefKey, Ci.nsISupportsString, stringified);
     ItemPinHelper._prefValue[this._prefKey] = aNewValue;
   },
 
-  isPinned: function isPinned(aItemId) {
+  isPinned: function(aItemId) {
     // Bookmarks are visible on StartUI (pinned) by default
     return this._getPrefValue().indexOf(aItemId) === -1;
   },
 
-  setUnpinned: function setPinned(aItemId) {
+  setUnpinned: function(aItemId) {
     let unpinned = this._getPrefValue();
     unpinned.push(aItemId);
     this._setPrefValue(unpinned);
   },
 
-  setPinned: function unsetPinned(aItemId) {
+  setPinned: function(aItemId) {
     let unpinned = this._getPrefValue();
 
     let index = unpinned.indexOf(aItemId);
     unpinned.splice(index, 1);
 
     this._setPrefValue(unpinned);
   },
 }
diff --git a/browser/metro/base/content/helperui/MenuUI.js b/browser/metro/base/content/helperui/MenuUI.js
--- a/browser/metro/base/content/helperui/MenuUI.js
+++ b/browser/metro/base/content/helperui/MenuUI.js
@@ -18,64 +18,64 @@ var AutofillMenuUI = {
     if (!this.__menuPopup) {
       this.__menuPopup = new MenuPopup(this._panel, this._popup);
       this.__menuPopup._wantTypeBehind = true;
       this.__menuPopup.controller = this;
     }
     return this.__menuPopup;
   },
 
-  _firePopupEvent: function _firePopupEvent(aEventName) {
+  _firePopupEvent: function(aEventName) {
     let menupopup = this._currentControl.menupopup;
     if (menupopup.hasAttribute(aEventName)) {
       let func = new Function("event", menupopup.getAttribute(aEventName));
       func.call(this);
     }
   },
 
-  _emptyCommands: function _emptyCommands() {
+  _emptyCommands: function() {
     while (this.commands.firstChild)
       this.commands.removeChild(this.commands.firstChild);
   },
 
-  _positionOptions: function _positionOptions() {
+  _positionOptions: function() {
     return {
       bottomAligned: false,
       leftAligned: true,
       xPos: this._anchorRect.x,
       yPos: this._anchorRect.y + this._anchorRect.height,
       maxWidth: this._anchorRect.width,
       maxHeight: 350,
       source: Ci.nsIDOMMouseEvent.MOZ_SOURCE_TOUCH
     };
   },
 
-  show: function show(aAnchorRect, aSuggestionsList) {
+  show: function(aAnchorRect, aSuggestionsList) {
     this.commands.addEventListener("select", this, true);
 
     this._anchorRect = aAnchorRect;
     this._emptyCommands();
     for (let idx = 0; idx < aSuggestionsList.length; idx++) {
       let item = document.createElement("richlistitem");
       let label = document.createElement("label");
       label.setAttribute("value", aSuggestionsList[idx].label);
       item.setAttribute("value", aSuggestionsList[idx].value);
       item.setAttribute("data", aSuggestionsList[idx].value);
       item.appendChild(label);
       this.commands.appendChild(item);
     }
     this._menuPopup.show(this._positionOptions());
   },
 
-  selectByIndex: function mn_selectByIndex(aIndex) {
+  selectByIndex: function(aIndex) {
     this._menuPopup.hide();
     FormHelperUI.doAutoComplete(this.commands.childNodes[aIndex].getAttribute("data"));
   },
 
-  hide: function hide () {
+  hide: function() {
     this.commands.removeEventListener("select", this, true);
 
     this._menuPopup.hide();
   },
 
   handleEvent: function (aEvent) {
     switch (aEvent.type) {
       case "select":
@@ -128,17 +128,17 @@ var ContextMenuUI = {
    *  aMessage.json - json data structure described below.
    *  aMessage.target - target element on which to evoke
    *
    * @returns true if the context menu was displayed,
    * false otherwise.
    *
    * json: TBD
    */
-  showContextMenu: function ch_showContextMenu(aMessage) {
+  showContextMenu: function(aMessage) {
     this._popupState = aMessage.json;
     this._popupState.target = aMessage.target;
     let contentTypes = this._popupState.types;
 
     /*
      * Types in ContextMenuHandler:
      * image
      * link
@@ -213,25 +213,25 @@ var ContextMenuUI = {
     this._menuPopup.show(Util.extend({}, this._defaultPositionOptions, {
       xPos: coords.x,
       yPos: coords.y,
       source: aMessage.json.source
     }));
     return true;
   },
 
-  hide: function hide () {
+  hide: function() {
     for (let command of this.commands.querySelectorAll("richlistitem[selected]")) {
       command.removeAttribute("selected");
     }
     this._menuPopup.hide();
     this._popupState = null;
   },
 
-  reset: function reset() {
+  reset: function() {
     this._popupState = null;
   }
 };
 
 var MenuControlUI = {
   _currentControl: null,
   __menuPopup: null,
 
@@ -242,30 +242,30 @@ var MenuControlUI = {
   get _menuPopup() {
     if (!this.__menuPopup) {
       this.__menuPopup = new MenuPopup(this._panel, this._popup);
       this.__menuPopup.controller = this;
     }
     return this.__menuPopup;
   },
 
-  _firePopupEvent: function _firePopupEvent(aEventName) {
+  _firePopupEvent: function(aEventName) {
     let menupopup = this._currentControl.menupopup;
     if (menupopup.hasAttribute(aEventName)) {
       let func = new Function("event", menupopup.getAttribute(aEventName));
       func.call(this);
     }
   },
 
-  _emptyCommands: function _emptyCommands() {
+  _emptyCommands: function() {
     while (this.commands.firstChild)
       this.commands.removeChild(this.commands.firstChild);
   },
 
-  _positionOptions: function _positionOptions() {
+  _positionOptions: function() {
     let position = this._currentControl.menupopup.position || "after_start";
     let rect = this._currentControl.getBoundingClientRect();
 
     let options = {};
 
     // TODO: Detect text direction and flip for RTL.
 
     switch (position) {
@@ -295,17 +295,17 @@ var MenuControlUI = {
         break;
 
       // TODO: Support other popup positions.
     }
 
     return options;
   },
 
-  show: function show(aMenuControl) {
+  show: function(aMenuControl) {
     this._currentControl = aMenuControl;
     this._panel.setAttribute("for", aMenuControl.id);
     this._firePopupEvent("onpopupshowing");
 
     this._emptyCommands();
     let children = this._currentControl.menupopup.children;
     for (let i = 0; i < children.length; i++) {
       let child = children[i];
@@ -331,17 +331,17 @@ var MenuControlUI = {
       item.appendChild(label);
 
       this.commands.appendChild(item);
     }
 
     this._menuPopup.show(this._positionOptions());
   },
 
-  selectByIndex: function mn_selectByIndex(aIndex) {
+  selectByIndex: function(aIndex) {
     this._currentControl.selectedIndex = aIndex;
 
     // Dispatch a xul command event to the attached menulist
     if (this._currentControl.dispatchEvent) {
       let evt = document.createEvent("XULCommandEvent");
       evt.initCommandEvent("command", true, true, window, 0, false, false, false, false, null);
       this._currentControl.dispatchEvent(evt);
     }
@@ -368,17 +368,17 @@ MenuPopup.prototype = {
   },
 
   hide: function () {
     if (this.visible) {
       this._animateHide();
     }
   },
 
-  _position: function _position(aPositionOptions) {
+  _position: function(aPositionOptions) {
     let aX = aPositionOptions.xPos;
     let aY = aPositionOptions.yPos;
     let aSource = aPositionOptions.source;
 
     // Set these first so they are set when we do misc. calculations below.
     if (aPositionOptions.maxWidth) {
       this._popup.style.maxWidth = aPositionOptions.maxWidth + "px";
     }
@@ -488,23 +488,23 @@ MenuPopup.prototype = {
       deferred.resolve();
     });
 
     this._panel.setAttribute("hiding", "true");
     this._panel.removeAttribute("showing");
     return deferred.promise;
   },
 
-  _dispatch: function _dispatch(aName) {
+  _dispatch: function(aName) {
     let event = document.createEvent("Events");
     event.initEvent(aName, true, false);
     this._panel.dispatchEvent(event);
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "keypress":
         // this.commands is not holding focus and not processing key events.
         // Proxying events so that they're handled properly.
 
         // Avoid recursion
         if (aEvent.mine)
           break;
diff --git a/browser/metro/base/content/helperui/OfflineApps.js b/browser/metro/base/content/helperui/OfflineApps.js
--- a/browser/metro/base/content/helperui/OfflineApps.js
+++ b/browser/metro/base/content/helperui/OfflineApps.js
@@ -67,15 +67,15 @@ var OfflineApps = {
     aTarget.messageManager.sendAsyncMessage("Browser:MozApplicationCache:Fetch", aRequest);
   },
 
   disallowSite: function(aRequest) {
     let currentURI = Services.io.newURI(aRequest.location, aRequest.charset, null);
     Services.perms.add(currentURI, "offline-app", Ci.nsIPermissionManager.DENY_ACTION);
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (aMessage.name == "Browser:MozApplicationManifest") {
       this.offlineAppRequested(aMessage.json, aMessage.target);
     }
   }
 };
 
diff --git a/browser/metro/base/content/helperui/SelectHelperUI.js b/browser/metro/base/content/helperui/SelectHelperUI.js
--- a/browser/metro/base/content/helperui/SelectHelperUI.js
+++ b/browser/metro/base/content/helperui/SelectHelperUI.js
@@ -22,17 +22,17 @@ var SelectHelperUI = {
   },
 
   get _menuPopup() {
     let popup = document.getElementById("select-popup");
     delete this._menuPopup;
     return this._menuPopup = new MenuPopup(this._container, popup);
   },
 
-  show: function selectHelperShow(aList, aTitle, aRect) {
+  show: function(aList, aTitle, aRect) {
     if (this._list) {
       this.reset();
     }
 
     this._list = aList;
 
     this._listbox.setAttribute("seltype", aList.multiple ? "multiple" : "single");
 
@@ -85,51 +85,51 @@ var SelectHelperUI = {
     this._listbox.clearSelection();
     for (let item of selectedItems) {
       this._listbox.addItemToSelection(item);
       item.setAttribute("oldstate", "true");
     }
     this._listbox.ensureElementIsVisible(firstSelected);
   },
 
-  reset: function selectHelperReset() {
+  reset: function() {
     this._updateControl();
     while (this._listbox.hasChildNodes())
       this._listbox.removeChild(this._listbox.lastChild);
     this._list = null;
   },
 
-  hide: function selectHelperHide() {
+  hide: function() {
     if (!this._list)
       return;
 
     this._container.removeEventListener("click", this, false);
     window.removeEventListener("MozPrecisePointer", this, false);
     this._menuPopup.hide();
     this.reset();
   },
 
-  _positionOptions: function _positionOptions(aRect) {
+  _positionOptions: function(aRect) {
     let browser = Browser.selectedBrowser;
     let p0 = browser.ptBrowserToClient(aRect.left, aRect.top);
     let p1 = browser.ptBrowserToClient(aRect.right, aRect.bottom);
 
     return {
       xPos: p0.x,
       yPos: p1.y,
       bottomAligned: false,
       leftAligned: true
     };
   },
 
-  _updateControl: function _selectHelperUpdateControl() {
+  _updateControl: function() {
     Browser.selectedBrowser.messageManager.sendAsyncMessage("FormAssist:ChoiceChange", { });
   },
 
-  handleEvent: function selectHelperHandleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "MozPrecisePointer":
         this.hide();
       break;
       case "click":
         let item = aEvent.target;
         if (item && item.hasOwnProperty("optionIndex")) {
           if (this._list.multiple) {
@@ -152,17 +152,17 @@ var SelectHelperUI = {
           }
           // Let the form element know we've added or removed a selected item.
           this.onSelect(item.optionIndex, item.selected);
         }
         break;
     }
   },
 
-  onSelect: function selectHelperOnSelect(aIndex, aSelected) {
+  onSelect: function(aIndex, aSelected) {
     Browser.selectedBrowser.messageManager.sendAsyncMessage("FormAssist:ChoiceSelect", {
       index: aIndex,
       selected: aSelected
     });
     if (!this._list.multiple) {
       this.hide();
     }
   }
diff --git a/browser/metro/base/content/helperui/SelectionHelperUI.js b/browser/metro/base/content/helperui/SelectionHelperUI.js
--- a/browser/metro/base/content/helperui/SelectionHelperUI.js
+++ b/browser/metro/base/content/helperui/SelectionHelperUI.js
@@ -48,41 +48,41 @@ MarkerDragger.prototype = {
   get shutdown() {
     return this._shutdown;
   },
 
   get dragging() {
     return this._dragging;
   },
 
-  freeDrag: function freeDrag() {
+  freeDrag: function() {
     return true;
   },
 
-  isDraggable: function isDraggable(aTarget, aContent) {
+  isDraggable: function(aTarget, aContent) {
     return { x: true, y: true };
   },
 
-  dragStart: function dragStart(aX, aY, aTarget, aScroller) {
+  dragStart: function(aX, aY, aTarget, aScroller) {
     if (this._shutdown)
       return false;
     this._dragging = true;
     this.marker.dragStart(aX, aY);
     return true;
   },
 
-  dragStop: function dragStop(aDx, aDy, aScroller) {
+  dragStop: function(aDx, aDy, aScroller) {
     if (this._shutdown)
       return false;
     this._dragging = false;
     this.marker.dragStop(aDx, aDy);
     return true;
   },
 
-  dragMove: function dragMove(aDx, aDy, aScroller, aIsKenetic, aClientX, aClientY) {
+  dragMove: function(aDx, aDy, aScroller, aIsKenetic, aClientX, aClientY) {
     // Note if aIsKenetic is true this is synthetic movement,
     // we don't want that so return false.
     if (this._shutdown || aIsKenetic)
       return false;
     this.marker.moveBy(aDx, aDy, aClientX, aClientY);
     // return true if we moved, false otherwise. The result
     // is used in deciding if we should repaint between drags.
     return true;
@@ -140,65 +140,65 @@ Marker.prototype = {
 
   // Indicates that marker's position doesn't reflect real selection boundary
   // but rather boundary of input control while actual selection boundaries are
   // not visible (ex. due scrolled content).
   get restrictedToBounds() {
     return this._restrictedToBounds;
   },
 
-  shutdown: function shutdown() {
+  shutdown: function() {
     this._element.hidden = true;
     this._element.customDragger.shutdown = true;
     delete this._element.customDragger;
     this._selectionHelperUI = null;
     this._element = null;
   },
 
-  setTrackBounds: function setTrackBounds(aVerticalPlane, aHorizontalPlane) {
+  setTrackBounds: function(aVerticalPlane, aHorizontalPlane) {
     // monocle boundaries
     this._hPlane = aHorizontalPlane;
     this._vPlane = aVerticalPlane;
   },
 
-  show: function show() {
+  show: function() {
     this._element.hidden = false;
   },
 
-  hide: function hide() {
+  hide: function() {
     this._element.hidden = true;
   },
 
   get visible() {
     return this._element.hidden == false;
   },
 
-  position: function position(aX, aY, aRestrictedToBounds) {
+  position: function(aX, aY, aRestrictedToBounds) {
     this._xPos = aX;
     this._yPos = aY;
     this._restrictedToBounds = !!aRestrictedToBounds;
     this._setPosition();
   },
 
-  _setPosition: function _setPosition() {
+  _setPosition: function() {
     this._element.left = this._xPos + "px";
     this._element.top = this._yPos + "px";
   },
 
-  dragStart: function dragStart(aX, aY) {
+  dragStart: function(aX, aY) {
     this._xDrag = 0;
     this._yDrag = 0;
     this._selectionHelperUI.markerDragStart(this);
   },
 
-  dragStop: function dragStop(aDx, aDy) {
+  dragStop: function(aDx, aDy) {
     this._selectionHelperUI.markerDragStop(this);
   },
 
-  moveBy: function moveBy(aDx, aDy, aClientX, aClientY) {
+  moveBy: function(aDx, aDy, aClientX, aClientY) {
     this._xPos -= aDx;
     this._yPos -= aDy;
     this._xDrag -= aDx;
     this._yDrag -= aDy;
     // Add a bit of hysteresis to our directional detection so "big fingers"
     // are detected accurately.
     let direction = "tbd";
     if (Math.abs(this._xDrag) > kDragHysteresisDistance ||
@@ -207,30 +207,30 @@ Marker.prototype = {
     }
     // We may swap markers in markerDragMove. If markerDragMove
     // returns true keep processing, otherwise get out of here.
     if (this._selectionHelperUI.markerDragMove(this, direction)) {
       this._setPosition();
     }
   },
 
-  hitTest: function hitTest(aX, aY) {
+  hitTest: function(aX, aY) {
     // Gets the pointer of the arrow right in the middle of the
     // monocle.
     aY += this._monocleYHitTextAdjust;
     aX += this._monocleXHitTextAdjust;
     if (aX >= (this._xPos - this._monocleRadius) &&
         aX <= (this._xPos + this._monocleRadius) &&
         aY >= (this._yPos - this._monocleRadius) &&
         aY <= (this._yPos + this._monocleRadius))
       return true;
     return false;
   },
 
-  swapMonocle: function swapMonocle(aCaret) {
+  swapMonocle: function(aCaret) {
     let targetElement = aCaret._element;
     let targetElementId = aCaret._elementId;
 
     aCaret._element = this._element;
     aCaret._element.customDragger._marker = aCaret;
     aCaret._elementId = this._elementId;
 
     this._xPos = aCaret._xPos;
@@ -386,17 +386,17 @@ var SelectionHelperUI = {
    * pingSelectionHandler
    * 
    * Ping the SelectionHandler and wait for the right response. Insures
    * all previous messages have been received. Useful in checking if
    * selection handler is setup for tests.
    *
    * @return a promise
    */
-  pingSelectionHandler: function pingSelectionHandler() {
+  pingSelectionHandler: function() {
     if (!this.isActive)
       return null;
 
     if (this._pingCount == undefined) {
       this._pingCount = 0;
       this._pingArray = [];
     }
 
@@ -418,17 +418,17 @@ var SelectionHelperUI = {
    * Attempts to select underlying text at a point and begins editing
    * the section.
    *
    * @param aMsgTarget - Browser or chrome message target
    * @param aX, aY - Browser relative client coordinates.
    * @param aSetFocus - (optional) For form inputs, requests that the focus
    * be set to the element.
    */
-  openEditSession: function openEditSession(aMsgTarget, aX, aY, aSetFocus) {
+  openEditSession: function(aMsgTarget, aX, aY, aSetFocus) {
     if (!aMsgTarget || this.isActive)
       return;
     this._init(aMsgTarget);
     this._setupDebugOptions();
     let setFocus = aSetFocus || false;
     // Send this over to SelectionHandler in content, they'll message us
     // back with information on the current selection. SelectionStart
     // takes client coordinates.
@@ -444,17 +444,17 @@ var SelectionHelperUI = {
    *
    * Attaches to existing selection and begins editing.
    *
    * @param aMsgTarget - Browser or chrome message target.
    * @param aX Tap browser relative client X coordinate.
    * @param aY Tap browser relative client Y coordinate.
    * @param aTarget Actual tap target (optional).
    */
-  attachEditSession: function attachEditSession(aMsgTarget, aX, aY, aTarget) {
+  attachEditSession: function(aMsgTarget, aX, aY, aTarget) {
     if (!aMsgTarget || this.isActive)
       return;
     this._init(aMsgTarget);
     this._setupDebugOptions();
 
     // Send this over to SelectionHandler in content, they'll message us
     // back with information on the current selection. SelectionAttach
     // takes client coordinates.
@@ -476,17 +476,17 @@ var SelectionHelperUI = {
    * Once the user starts a drag, the caret marker is hidden, and
    * the start and end markers take over.
    *
    * @param aMsgTarget - Browser or chrome message target.
    * @param aX Tap browser relative client X coordinate.
    * @param aY Tap browser relative client Y coordinate.
    * @param aTarget Actual tap target (optional).
    */
-  attachToCaret: function attachToCaret(aMsgTarget, aX, aY, aTarget) {
+  attachToCaret: function(aMsgTarget, aX, aY, aTarget) {
     if (!this.isActive) {
       this._init(aMsgTarget);
       this._setupDebugOptions();
     } else {
       this._hideMonocles();
     }
 
     this._lastCaretAttachment = {
@@ -502,32 +502,32 @@ var SelectionHelperUI = {
     });
   },
 
   /*
    * canHandleContextMenuMsg
    *
    * Determines if we can handle a ContextMenuHandler message.
    */
-  canHandleContextMenuMsg: function canHandleContextMenuMsg(aMessage) {
+  canHandleContextMenuMsg: function(aMessage) {
     if (aMessage.json.types.indexOf("content-text") != -1)
       return true;
     return false;
   },
 
   /*
    * closeEditSession(aClearSelection)
    *
    * Closes an active edit session and shuts down. Does not clear existing
    * selection regions if they exist.
    *
    * @param aClearSelection bool indicating if the selection handler should also
    * clear any selection. optional, the default is false.
    */
-  closeEditSession: function closeEditSession(aClearSelection) {
+  closeEditSession: function(aClearSelection) {
     if (!this.isActive) {
       return;
     }
     // This will callback in _selectionHandlerShutdown in
     // which we will call _shutdown().
     let clearSelection = aClearSelection || false;
     this._sendAsyncMessage("Browser:SelectionClose", {
       clearSelection: clearSelection
@@ -569,17 +569,17 @@ var SelectionHelperUI = {
 
   init: function () {
     let os = Services.obs;
     os.addObserver(this, "attach_edit_session_to_content", false);
     os.addObserver(this, "apzc-transform-begin", false);
     os.addObserver(this, "apzc-transform-end", false);
   },
 
-  _init: function _init(aMsgTarget) {
+  _init: function(aMsgTarget) {
     // store the target message manager
     this._msgTarget = aMsgTarget;
 
     // Init our list of available monocle ids
     this._setupMonocleIdArray();
 
     // Init selection rect info
     this._activeSelectionRect = Util.getCleanRect();
@@ -610,17 +610,17 @@ var SelectionHelperUI = {
 
     Elements.tabList.addEventListener("TabSelect", this, true);
 
     Elements.navbar.addEventListener("transitionend", this, true);
 
     this.overlay.enabled = true;
   },
 
-  _shutdown: function _shutdown() {
+  _shutdown: function() {
     messageManager.removeMessageListener("Content:SelectionRange", this);
     messageManager.removeMessageListener("Content:SelectionCopied", this);
     messageManager.removeMessageListener("Content:SelectionFail", this);
     messageManager.removeMessageListener("Content:SelectionDebugRect", this);
     messageManager.removeMessageListener("Content:HandlerShutdown", this);
     messageManager.removeMessageListener("Content:SelectionHandlerPong", this);
     messageManager.removeMessageListener("Content:SelectionSwap", this);
 
@@ -656,17 +656,17 @@ var SelectionHelperUI = {
 
   /*
    * _swapCaretMarker
    *
    * Swap two drag markers - used when transitioning from caret mode
    * to selection mode. We take the current caret marker (which is in a
    * drag state) and swap it out with one of the selection markers.
    */
-  _swapCaretMarker: function _swapCaretMarker(aDirection) {
+  _swapCaretMarker: function(aDirection) {
     let targetMark = null;
     if (aDirection == "start")
       targetMark = this.startMark;
     else
       targetMark = this.endMark;
     let caret = this.caretMark;
     targetMark.swapMonocle(caret);
     let id = caret._elementId;
@@ -675,17 +675,17 @@ var SelectionHelperUI = {
     this._selectionMarkIds.push(id);
   },
 
   /*
    * _transitionFromCaretToSelection
    *
    * Transitions from caret mode to text selection mode.
    */
-  _transitionFromCaretToSelection: function _transitionFromCaretToSelection(aDirection) {
+  _transitionFromCaretToSelection: function(aDirection) {
     // Get selection markers initialized if they aren't already
     { let mark = this.startMark; mark = this.endMark; }
 
     // Swap the caret marker out for the start or end marker depending
     // on direction.
     this._swapCaretMarker(aDirection);
 
     let targetMark = null;
@@ -721,17 +721,17 @@ var SelectionHelperUI = {
   },
 
   /*
    * _setupDebugOptions
    *
    * Sends a message over to content instructing it to
    * turn on various debug features.
    */
-  _setupDebugOptions: function _setupDebugOptions() {
+  _setupDebugOptions: function() {
     // Debug options for selection
     let debugOpts = { dumpRanges: false, displayRanges: false, dumpEvents: false };
     try {
       if (Services.prefs.getBoolPref(kDebugSelectionDumpPref))
         debugOpts.displayRanges = true;
     } catch (ex) {}
     try {
       if (Services.prefs.getBoolPref(kDebugSelectionDisplayPref))
@@ -752,62 +752,62 @@ var SelectionHelperUI = {
     }
   },
 
   /*
    * _sendAsyncMessage
    *
    * Helper for sending a message to SelectionHandler.
    */
-  _sendAsyncMessage: function _sendAsyncMessage(aMsg, aJson) {
+  _sendAsyncMessage: function(aMsg, aJson) {
     if (!this._msgTarget) {
       if (this._debugEvents)
         Util.dumpLn("SelectionHelperUI sendAsyncMessage could not send", aMsg);
       return;
     }
     if (this._msgTarget && this._msgTarget instanceof SelectionPrototype) {
       this._msgTarget.msgHandler(aMsg, aJson);
     } else {
       this._msgTarget.messageManager.sendAsyncMessage(aMsg, aJson);
     }
   },
 
-  _checkForActiveDrag: function _checkForActiveDrag() {
+  _checkForActiveDrag: function() {
     return (this.startMark.dragging || this.endMark.dragging ||
             this.caretMark.dragging);
   },
 
-  _hitTestSelection: function _hitTestSelection(aEvent) {
+  _hitTestSelection: function(aEvent) {
     // Ignore if the double tap isn't on our active selection rect.
     if (this._activeSelectionRect &&
         Util.pointWithinRect(aEvent.clientX, aEvent.clientY, this._activeSelectionRect)) {
       return true;
     }
     return false;
   },
 
   /*
    * _setCaretPositionAtPoint - sets the current caret position.
    *
    * @param aX, aY - browser relative client coordinates
    */
-  _setCaretPositionAtPoint: function _setCaretPositionAtPoint(aX, aY) {
+  _setCaretPositionAtPoint: function(aX, aY) {
     let json = this._getMarkerBaseMessage("caret");
     json.caret.xPos = aX;
     json.caret.yPos = aY;
     this._sendAsyncMessage("Browser:CaretUpdate", json);
   },
 
   /*
    * _shutdownAllMarkers
    *
    * Helper for shutting down all markers and
    * freeing the objects associated with them.
    */
-  _shutdownAllMarkers: function _shutdownAllMarkers() {
+  _shutdownAllMarkers: function() {
     if (this._startMark)
       this._startMark.shutdown();
     if (this._endMark)
       this._endMark.shutdown();
     if (this._caretMark)
       this._caretMark.shutdown();
 
     this._startMark = null;
@@ -815,35 +815,35 @@ var SelectionHelperUI = {
     this._caretMark = null;
   },
 
   /*
    * _setupMonocleIdArray
    *
    * Helper for initing the array of monocle anon ids.
    */
-  _setupMonocleIdArray: function _setupMonocleIdArray() {
+  _setupMonocleIdArray: function() {
     this._selectionMarkIds = ["selectionhandle-mark1",
                               "selectionhandle-mark2",
                               "selectionhandle-mark3"];
   },
 
-  _hideMonocles: function _hideMonocles() {
+  _hideMonocles: function() {
     if (this._startMark) {
       this.startMark.hide();
     }
     if (this._endMark) {
       this.endMark.hide();
     }
     if (this._caretMark) {
       this.caretMark.hide();
     }
   },
 
-  _showMonocles: function _showMonocles(aSelection) {
+  _showMonocles: function(aSelection) {
     if (!aSelection) {
       if (this._checkMonocleVisibility(this.caretMark.xPos, this.caretMark.yPos)) {
         this.caretMark.show();
       }
     } else {
       if (this._checkMonocleVisibility(this.endMark.xPos, this.endMark.yPos)) {
         this.endMark.show();
       }
@@ -876,98 +876,98 @@ var SelectionHelperUI = {
    */
   _onClick: function(aEvent) {
     if (this.layerMode == kChromeLayer && this._targetIsEditable) {
       this.attachToCaret(this._msgTarget, aEvent.clientX, aEvent.clientY,
           aEvent.target);
     }
   },
 
-  _onKeypress: function _onKeypress() {
+  _onKeypress: function() {
     this.closeEditSession();
   },
 
-  _onResize: function _onResize() {
+  _onResize: function() {
     this._sendAsyncMessage("Browser:SelectionUpdate", {});
   },
 
   /*
    * _onDeckOffsetChanging - fired by ContentAreaObserver before the browser
    * deck is shifted for form input access in response to a soft keyboard
    * display.
    */
-  _onDeckOffsetChanging: function _onDeckOffsetChanging(aEvent) {
+  _onDeckOffsetChanging: function(aEvent) {
     // Hide the monocles temporarily
     this._hideMonocles();
   },
 
   /*
    * _onDeckOffsetChanged - fired by ContentAreaObserver after the browser
    * deck is shifted for form input access in response to a soft keyboard
    * display.
    */
-  _onDeckOffsetChanged: function _onDeckOffsetChanged(aEvent) {
+  _onDeckOffsetChanged: function(aEvent) {
     // Update the monocle position and display
     this.attachToCaret(null, this._lastCaretAttachment.xPos,
         this._lastCaretAttachment.yPos, this._lastCaretAttachment.target);
   },
 
   /*
    * Detects when the nav bar transitions, so we can enable selection at the
    * appropriate location once the transition is complete, or shutdown
    * selection down when the nav bar is hidden.
    */
-  _onNavBarTransitionEvent: function _onNavBarTransitionEvent(aEvent) {
+  _onNavBarTransitionEvent: function(aEvent) {
     // Ignore when selection is in content
     if (this.layerMode == kContentLayer) {
       return;
     }
 
     // After tansitioning up, show the monocles
     if (Elements.navbar.isShowing) {
       this._showAfterUpdate = true;
       this._sendAsyncMessage("Browser:SelectionUpdate", {});
     }
   },
 
-  _onKeyboardChangedEvent: function _onKeyboardChangedEvent() {
+  _onKeyboardChangedEvent: function() {
     if (!this.isActive || this.layerMode == kContentLayer) {
       return;
     }
     this._sendAsyncMessage("Browser:SelectionUpdate", {});
   },
 
   /*
    * Event handlers for message manager
    */
 
-  _onDebugRectRequest: function _onDebugRectRequest(aMsg) {
+  _onDebugRectRequest: function(aMsg) {
     this.overlay.addDebugRect(aMsg.left, aMsg.top, aMsg.right, aMsg.bottom,
                               aMsg.color, aMsg.fill, aMsg.id);
   },
 
-  _selectionHandlerShutdown: function _selectionHandlerShutdown() {
+  _selectionHandlerShutdown: function() {
     this._shutdown();
   },
 
-  _selectionSwap: function _selectionSwap() {
+  _selectionSwap: function() {
     [this.startMark.tag, this.endMark.tag] = [this.endMark.tag,
         this.startMark.tag];
     [this._startMark, this._endMark] = [this.endMark, this.startMark];
   },
 
   /*
    * Message handlers
    */
 
-  _onSelectionCopied: function _onSelectionCopied(json) {
+  _onSelectionCopied: function(json) {
     this.closeEditSession(true);
   },
 
-  _onSelectionRangeChange: function _onSelectionRangeChange(json) {
+  _onSelectionRangeChange: function(json) {
     let haveSelectionRect = true;
 
     if (json.updateStart) {
       let x = this._msgTarget.btocx(json.start.xPos, true);
       let y = this._msgTarget.btocy(json.start.yPos, true);
       this.startMark.position(x, y, json.start.restrictedToBounds);
     }
 
@@ -1004,41 +1004,41 @@ var SelectionHelperUI = {
 
     // If this is the end of a selection move show the appropriate
     // monocle images. src=(start, update, end, caret)
     if (json.src == "start" || json.src == "end") {
       this._showMonocles(true);
     }
   },
 
-  _onSelectionFail: function _onSelectionFail() {
+  _onSelectionFail: function() {
     Util.dumpLn("failed to get a selection.");
     this.closeEditSession();
   },
 
   /*
    * _onPong
    *
    * Handles the closure of promise we return when we send a ping
    * to SelectionHandler in pingSelectionHandler. Testing use.
    */
-  _onPong: function _onPong(aId) {
+  _onPong: function(aId) {
     let ping = this._pingArray.pop();
     if (ping.id != aId) {
       ping.deferred.reject(
         new Error("Selection module's pong doesn't match our last ping."));
     }
     ping.deferred.resolve();
    },
 
   /*
    * Events
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     if (this._debugEvents && aEvent.type != "touchmove") {
       Util.dumpLn("SelectionHelperUI:", aEvent.type);
     }
     switch (aEvent.type) {
       case "click":
         this._onClick(aEvent);
         break;
 
@@ -1083,17 +1083,17 @@ var SelectionHelperUI = {
         break;
 
       case "KeyboardChanged":
         this._onKeyboardChangedEvent();
         break;
     }
   },
 
-  receiveMessage: function sh_receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     if (this._debugEvents) Util.dumpLn("SelectionHelperUI:", aMessage.name);
     let json = aMessage.json;
     switch (aMessage.name) {
       case "Content:SelectionFail":
         this._onSelectionFail();
         break;
       case "Content:SelectionRange":
         this._onSelectionRangeChange(json);
@@ -1115,17 +1115,17 @@ var SelectionHelperUI = {
         break;
     }
   },
 
   /*
    * Callbacks from markers
    */
 
-  _getMarkerBaseMessage: function _getMarkerBaseMessage(aMarkerTag) {
+  _getMarkerBaseMessage: function(aMarkerTag) {
     return {
       change: aMarkerTag,
       start: {
         xPos: this._msgTarget.ctobx(this.startMark.xPos, true),
         yPos: this._msgTarget.ctoby(this.startMark.yPos, true),
         restrictedToBounds: this.startMark.restrictedToBounds
       },
       end: {
@@ -1135,38 +1135,38 @@ var SelectionHelperUI = {
       },
       caret: {
         xPos: this._msgTarget.ctobx(this.caretMark.xPos, true),
         yPos: this._msgTarget.ctoby(this.caretMark.yPos, true)
       },
     };
   },
 
-  markerDragStart: function markerDragStart(aMarker) {
+  markerDragStart: function(aMarker) {
     let json = this._getMarkerBaseMessage(aMarker.tag);
     if (aMarker.tag == "caret") {
       // Cache for when we start the drag in _transitionFromCaretToSelection.
       if (!this._cachedCaretPos) {
         this._cachedCaretPos = this._getMarkerBaseMessage(aMarker.tag).caret;
       }
       return;
     }
     this._sendAsyncMessage("Browser:SelectionMoveStart", json);
   },
 
-  markerDragStop: function markerDragStop(aMarker) {
+  markerDragStop: function(aMarker) {
     let json = this._getMarkerBaseMessage(aMarker.tag);
     if (aMarker.tag == "caret") {
       this._cachedCaretPos = null;
       return;
     }
     this._sendAsyncMessage("Browser:SelectionMoveEnd", json);
   },
 
-  markerDragMove: function markerDragMove(aMarker, aDirection) {
+  markerDragMove: function(aMarker, aDirection) {
     if (aMarker.tag == "caret") {
       // If direction is "tbd" the drag monocle hasn't determined which
       // direction the user is dragging.
       if (aDirection != "tbd") {
         // We are going to transition from caret browsing mode to selection
         // mode on drag. So swap the caret monocle for a start or end monocle
         // depending on the direction of the drag, and start selecting text.
         this._transitionFromCaretToSelection(aDirection);
diff --git a/browser/metro/base/content/input.js b/browser/metro/base/content/input.js
--- a/browser/metro/base/content/input.js
+++ b/browser/metro/base/content/input.js
@@ -68,17 +68,17 @@ const kAsyncPanZoomEnabled = "layers.asy
  * the defaultDragger prototype property.
  */
 
 var TouchModule = {
   _debugEvents: false,
   _isCancelled: false,
   _isCancellable: false,
 
-  init: function init() {
+  init: function() {
     this._dragData = new DragData();
 
     this._dragger = null;
 
     this._targetScrollbox = null;
     this._targetScrollInterface = null;
 
     this._kinetic = new KineticController(this._dragBy.bind(this),
@@ -98,17 +98,17 @@ var TouchModule = {
     Services.obs.addObserver(this, "Gesture:SingleTap", false);
     Services.obs.addObserver(this, "Gesture:DoubleTap", false);
   },
 
   /*
    * Events
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "contextmenu":
         this._onContextMenu(aEvent);
         break;
 
       case "CancelTouchSequence":
         this.cancelPending();
         break;
@@ -148,17 +148,17 @@ var TouchModule = {
             }
             aEvent.stopPropagation();
             break;
         }
       }
     }
   },
 
-  _handleKeyDown: function _handleKeyDown(aEvent) {
+  _handleKeyDown: function(aEvent) {
     const TABKEY = 9;
     if (aEvent.keyCode == TABKEY && !InputSourceHelper.isPrecise) {
       if (Util.isEditable(aEvent.target) &&
           aEvent.target.selectionStart != aEvent.target.selectionEnd) {
         SelectionHelperUI.closeEditSession(false);
       }
       setTimeout(function() {
         let element = Browser.selectedBrowser.contentDocument.activeElement;
@@ -175,56 +175,56 @@ var TouchModule = {
               SelectionHelperUI.attachEditSession(Browser.selectedBrowser,
                                                   rect.left + rect.width / 2,
                                                   rect.top + rect.height / 2);
         }
       }, 50);
     }
   },
 
-  observe: function BrowserUI_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "Gesture:SingleTap":
       case "Gesture:DoubleTap":
         Browser.selectedBrowser.messageManager.sendAsyncMessage(aTopic, JSON.parse(aData));
         break;
     }
   },
 
 
-  sample: function sample(aTimeStamp) {
+  sample: function(aTimeStamp) {
     this._waitingForPaint = false;
   },
 
   /**
    * This gets invoked by the input handler if another module grabs.  We should
    * reset our state or something here.  This is probably doing the wrong thing
    * in its current form.
    */
-  cancelPending: function cancelPending() {
+  cancelPending: function() {
     this._doDragStop();
 
     // Kinetic panning may have already been active or drag stop above may have
     // made kinetic panning active.
     this._kinetic.end();
 
     this._targetScrollbox = null;
     this._targetScrollInterface = null;
   },
 
-  _onContextMenu: function _onContextMenu(aEvent) {
+  _onContextMenu: function(aEvent) {
     // bug 598965 - chrome UI should stop to be pannable once the
     // context menu has appeared.
     if (ContextMenuUI.popupState) {
       this.cancelPending();
     }
   },
 
   /** Begin possible pan and send tap down event. */
-  _onTouchStart: function _onTouchStart(aEvent) {
+  _onTouchStart: function(aEvent) {
     if (aEvent.touches.length > 1)
       return;
 
     this._isCancelled = false;
     this._isCancellable = true;
 
     if (aEvent.defaultPrevented) {
       this._isCancelled = true;
@@ -272,33 +272,33 @@ var TouchModule = {
         if (dragger.freeDrag)
           dragData.alwaysFreeDrag = dragger.freeDrag();
         this._doDragStart(aEvent, draggable);
       }
     }
   },
 
   /** Send tap up event and any necessary full taps. */
-  _onTouchEnd: function _onTouchEnd(aEvent) {
+  _onTouchEnd: function(aEvent) {
     if (aEvent.touches.length > 0 || this._isCancelled || !this._targetScrollbox)
       return;
 
     // onMouseMove will not record the delta change if we are waiting for a
     // paint. Since this is the last input for this drag, we override the flag.
     this._waitingForPaint = false;
     this._onTouchMove(aEvent);
 
     let dragData = this._dragData;
     this._doDragStop();
   },
 
   /**
    * If we're in a drag, do what we have to do to drag on.
    */
-  _onTouchMove: function _onTouchMove(aEvent) {
+  _onTouchMove: function(aEvent) {
     if (aEvent.touches.length > 1)
       return;
 
     if (this._isCancellable) {
       // only the first touchmove is cancellable.
       this._isCancellable = false;
       if (aEvent.defaultPrevented) {
         this._isCancelled = true;
@@ -350,29 +350,29 @@ var TouchModule = {
         }
       }
     }
   },
 
   /**
    * Inform our dragger of a dragStart.
    */
-  _doDragStart: function _doDragStart(aEvent, aDraggable) {
+  _doDragStart: function(aEvent, aDraggable) {
     let touch = aEvent.changedTouches[0];
     let dragData = this._dragData;
     dragData.setDragStart(touch.screenX, touch.screenY, aDraggable);
     this._kinetic.addData(0, 0);
     this._dragStartTime = Date.now();
     if (!this._kinetic.isActive()) {
       this._dragger.dragStart(touch.clientX, touch.clientY, touch.target, this._targetScrollInterface);
     }
   },
 
   /** Finish a drag. */
-  _doDragStop: function _doDragStop() {
+  _doDragStop: function() {
     let dragData = this._dragData;
     if (!dragData.dragging)
       return;
 
     dragData.endDrag();
 
     // Note: it is possible for kinetic scrolling to be active from a
     // mousedown/mouseup event previous to this one. In this case, we
@@ -398,17 +398,17 @@ var TouchModule = {
   },
 
   /**
    * Used by _onTouchMove() above and by KineticController's timer to do the
    * actual dragMove signalling to the dragger.  We'd put this in _onTouchMove()
    * but then KineticController would be adding to its own data as it signals
    * the dragger of dragMove()s.
    */
-  _dragBy: function _dragBy(dX, dY, aIsKinetic) {
+  _dragBy: function(dX, dY, aIsKinetic) {
     let dragged = true;
     let dragData = this._dragData;
     if (!this._waitingForPaint || aIsKinetic) {
       let dragData = this._dragData;
       dragged = this._dragger.dragMove(dX, dY, this._targetScrollInterface, aIsKinetic,
                                        dragData._mouseX, dragData._mouseY);
       if (dragged && !this._waitingForPaint) {
         this._waitingForPaint = true;
@@ -419,32 +419,32 @@ var TouchModule = {
     }
     if (!dragData.isPan())
       this._kinetic.pause();
 
     return dragged;
   },
 
   /** Callback for kinetic scroller. */
-  _kineticStop: function _kineticStop() {
+  _kineticStop: function() {
     // Kinetic panning could finish while user is panning, so don't finish
     // the pan just yet.
     let dragData = this._dragData;
     if (!dragData.dragging) {
       if (this._dragger)
         this._dragger.dragStop(0, 0, this._targetScrollInterface);
       this._dragger = null;
 
       let event = document.createEvent("Events");
       event.initEvent("PanFinished", true, false);
       this._targetScrollbox.dispatchEvent(event);
     }
   },
 
-  toString: function toString() {
+  toString: function() {
     return '[TouchModule] {'
       + '\n\tdragData=' + this._dragData + ', '
       + 'dragger=' + this._dragger + ', '
       + '\n\ttargetScroller=' + this._targetScrollInterface + '}';
   },
 };
 
 var ScrollUtils = {
@@ -458,17 +458,17 @@ var ScrollUtils = {
   /**
    * Walk up (parentward) the DOM tree from elem in search of a scrollable element.
    * Return the element and its scroll interface if one is found, two nulls otherwise.
    *
    * This function will cache the pointer to the scroll interface on the element itself,
    * so it is safe to call it many times without incurring the same XPConnect overhead
    * as in the initial call.
    */
-  getScrollboxFromElement: function getScrollboxFromElement(elem) {
+  getScrollboxFromElement: function(elem) {
     let scrollbox = null;
     let qinterface = null;
 
     // if element is content or the startui page, get the browser scroll interface
     if (elem.ownerDocument == Browser.selectedBrowser.contentDocument) {
       elem = Browser.selectedBrowser;
     }
     for (; elem; elem = elem.parentNode) {
@@ -495,59 +495,59 @@ var ScrollUtils = {
       } catch (e) { /* we aren't here to deal with your exceptions, we'll just keep
                        traversing until we find something more well-behaved, as we
                        prefer default behaviour to whiny scrollers. */ }
     }
     return [scrollbox, qinterface, (scrollbox ? (scrollbox.customDragger || this._defaultDragger) : null)];
   },
 
   /** Determine if the distance moved can be considered a pan */
-  isPan: function isPan(aPoint, aPoint2) {
+  isPan: function(aPoint, aPoint2) {
     return (Math.abs(aPoint.x - aPoint2.x) > this.tapRadius ||
             Math.abs(aPoint.y - aPoint2.y) > this.tapRadius);
   },
 
   /**
    * The default dragger object used by TouchModule when dragging a scrollable
    * element that provides no customDragger.  Simply performs the expected
    * regular scrollBy calls on the scroller.
    */
   _defaultDragger: {
-    isDraggable: function isDraggable(target, scroller) {
+    isDraggable: function(target, scroller) {
       let rect = target.getBoundingClientRect();
       return { x: (scroller.scrolledWidth > rect.width   || scroller.positionX != 0),
                y: (scroller.scrolledHeight > rect.height || scroller.positionY != 0) };
     },
 
-    dragStart: function dragStart(cx, cy, target, scroller) {
+    dragStart: function(cx, cy, target, scroller) {
       scroller.element.addEventListener("PanBegin", this._showScrollbars, false);
     },
 
-    dragStop: function dragStop(dx, dy, scroller) {
+    dragStop: function(dx, dy, scroller) {
       scroller.element.removeEventListener("PanBegin", this._showScrollbars, false);
       return this.dragMove(dx, dy, scroller);
     },
 
-    dragMove: function dragMove(dx, dy, scroller) {
+    dragMove: function(dx, dy, scroller) {
         try {
         let oldX = scroller.positionX,
             oldY = scroller.positionY;
 
           scroller.scrollBy(dx, dy);
 
         let newX = scroller.positionX,
             newY = scroller.positionY;
 
         return (newX != oldX) || (newY != oldY);
 
         } catch (e) { /* we have no time for whiny scrollers! */ }
       return false;
     },
 
-    _showScrollbars: function _showScrollbars(aEvent) {
+    _showScrollbars: function(aEvent) {
       let scrollbox = aEvent.target;
       scrollbox.setAttribute("panning", "true");
 
       let hideScrollbars = function() {
         scrollbox.removeEventListener("PanFinished", hideScrollbars, false);
         scrollbox.removeEventListener("CancelTouchSequence", hideScrollbars, false);
         scrollbox.removeAttribute("panning");
       }
@@ -565,52 +565,52 @@ var ScrollUtils = {
  */
 function DragData() {
   this._domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
   this._lockRevertThreshold = Util.displayDPI * kAxisLockRevertThreshold;
   this.reset();
 };
 
 DragData.prototype = {
-  reset: function reset() {
+  reset: function() {
     this.dragging = false;
     this.sX = null;
     this.sY = null;
     this.locked = false;
     this.stayLocked = false;
     this.alwaysFreeDrag = false;
     this.lockedX = null;
     this.lockedY = null;
     this._originX = null;
     this._originY = null;
     this.prevPanX = null;
     this.prevPanY = null;
     this._isPan = false;
   },
 
   /** Depending on drag data, locks sX,sY to X-axis or Y-axis of start position. */
-  _lockAxis: function _lockAxis(sX, sY) {
+  _lockAxis: function(sX, sY) {
     if (this.locked) {
       if (this.lockedX !== null)
         sX = this.lockedX;
       else if (this.lockedY !== null)
         sY = this.lockedY;
       return [sX, sY];
     }
     else {
       return [this._originX, this._originY];
     }
   },
 
-  setMousePosition: function setMousePosition(aEvent) {
+  setMousePosition: function(aEvent) {
     this._mouseX = aEvent.clientX;
     this._mouseY = aEvent.clientY;
   },
 
-  setDragPosition: function setDragPosition(sX, sY) {
+  setDragPosition: function(sX, sY) {
     // Check if drag is now a pan.
     if (!this._isPan) {
       this._isPan = ScrollUtils.isPan(new Point(this._originX, this._originY), new Point(sX, sY));
       if (this._isPan) {
         this._resetActive();
       }
     }
 
@@ -660,61 +660,61 @@ DragData.prototype = {
     let [prevX, prevY] = this._lockAxis(this.sX, this.sY);
     this.prevPanX = prevX;
     this.prevPanY = prevY;
 
     this.sX = sX;
     this.sY = sY;
   },
 
-  setDragStart: function setDragStart(screenX, screenY, aDraggable) {
+  setDragStart: function(screenX, screenY, aDraggable) {
     this.sX = this._originX = screenX;
     this.sY = this._originY = screenY;
     this.dragging = true;
 
     // If the target area is pannable only in one direction lock it early
     // on the right axis
     this.lockedX = !aDraggable.x ? screenX : null;
     this.lockedY = !aDraggable.y ? screenY : null;
     this.stayLocked = this.lockedX || this.lockedY;
     this.locked = this.stayLocked;
   },
 
-  endDrag: function endDrag() {
+  endDrag: function() {
     this._resetActive();
     this.dragging = false;
   },
 
   /** Returns true if drag should pan scrollboxes.*/
-  isPan: function isPan() {
+  isPan: function() {
     return this._isPan;
   },
 
   /** Return true if drag should be parsed as a click. */
-  isClick: function isClick() {
+  isClick: function() {
     return !this._isPan;
   },
 
   /**
    * Returns the screen position for a pan. This factors in axis locking.
    * @return Array of screen X and Y coordinates
    */
-  panPosition: function panPosition() {
+  panPosition: function() {
     return this._lockAxis(this.sX, this.sY);
   },
 
   /** dismiss the active state of the pan element */
-  _resetActive: function _resetActive() {
+  _resetActive: function() {
     let target = document.documentElement;
     // If the target is active, toggle (turn off) the active flag. Otherwise do nothing.
     if (this._domUtils.getContentState(target) & kStateActive)
       this._domUtils.setContentState(target, kStateActive);
   },
 
-  toString: function toString() {
+  toString: function() {
     return '[DragData] { sX,sY=' + this.sX + ',' + this.sY + ', dragging=' + this.dragging + ' }';
   }
 };
 
 
 /**
  * KineticController - a class to take drag position data and use it
  * to do kinetic panning of a scrollable object.
@@ -747,28 +747,28 @@ function KineticController(aPanBy, aEndC
   this._polynomialC = Services.prefs.getIntPref("browser.ui.kinetic.polynomialC") / 1000000;
   // Number of milliseconds that can contain a swipe. Movements earlier than this are disregarded.
   this._swipeLength = Services.prefs.getIntPref("browser.ui.kinetic.swipeLength");
 
   this._reset();
 }
 
 KineticController.prototype = {
-  _reset: function _reset() {
+  _reset: function() {
     this._active = false;
     this._paused = false;
     this.momentumBuffer = [];
     this._velocity.set(0, 0);
   },
 
-  isActive: function isActive() {
+  isActive: function() {
     return this._active;
   },
 
-  _startTimer: function _startTimer() {
+  _startTimer: function() {
     let self = this;
 
     let lastp = this._position;  // track last position vector because pan takes deltas
     let v0 = this._velocity;  // initial velocity
     let a = this._acceleration;  // acceleration
     let c = this._exponentialC;
     let p = new Point(0, 0);
     let dx, dy, t, realt;
@@ -784,17 +784,17 @@ KineticController.prototype = {
       return v0 * Math.exp(-t / c) * -c + a * t * t + v0 * c;
     }
 
     this._calcV = function(v0, a, t) {
       return v0 * Math.exp(-t / c) + 2 * a * t;
     }
 
     let callback = {
-      sample: function kineticHandleEvent(timeStamp) {
+      sample: function(timeStamp) {
         // Someone called end() on us between timer intervals
         // or we are paused.
         if (!self.isActive() || self._paused)
           return;
 
         // To make animation end fast enough but to keep smoothness, average the ideal
         // time frame (smooth animation) with the actual time lapse (end fast enough).
         // Animation will never take longer than 2 times the ideal length of time.
@@ -840,17 +840,17 @@ KineticController.prototype = {
       }
     };
 
     this._active = true;
     this._paused = false;
     mozRequestAnimationFrame(callback);
   },
 
-  start: function start() {
+  start: function() {
     function sign(x) {
       return x ? ((x > 0) ? 1 : -1) : 0;
     }
 
     function clampFromZero(x, closerToZero, furtherFromZero) {
       if (x >= 0)
         return Math.max(closerToZero, Math.min(furtherFromZero, x));
       return Math.min(-closerToZero, Math.max(-furtherFromZero, x));
@@ -907,29 +907,29 @@ KineticController.prototype = {
     this.momentumBuffer = [];
 
     if (!this.isActive() || this._paused)
       this._startTimer();
 
     return true;
   },
 
-  pause: function pause() {
+  pause: function() {
     this._paused = true;
   },
 
-  end: function end() {
+  end: function() {
     if (this.isActive()) {
       if (this._beforeEnd)
         this._beforeEnd();
       this._reset();
     }
   },
 
-  addData: function addData(dx, dy) {
+  addData: function(dx, dy) {
     let mbLength = this.momentumBuffer.length;
     let now = Date.now();
 
     if (this.isActive()) {
       // Stop active movement when dragging in other direction.
       if (dx * this._velocity.x < 0 || dy * this._velocity.y < 0)
         this.end();
     }
@@ -941,31 +941,31 @@ KineticController.prototype = {
 
 /*
  * Simple gestures support
  */
 
 var GestureModule = {
   _debugEvents: false,
 
-  init: function init() {
+  init: function() {
     window.addEventListener("MozSwipeGesture", this, true);
   },
 
   /*
    * Events
    *
    * Dispatch events based on the type of mouse gesture event. For now, make
    * sure to stop propagation of every gesture event so that web content cannot
    * receive gesture events.
    *
    * @param nsIDOMEvent information structure
    */
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     try {
       aEvent.stopPropagation();
       aEvent.preventDefault();
       if (this._debugEvents) Util.dumpLn("GestureModule:", aEvent.type);
       switch (aEvent.type) {
         case "MozSwipeGesture":
           if (this._onSwipe(aEvent)) {
             let event = document.createEvent("Events");
@@ -976,42 +976,42 @@ var GestureModule = {
       }
     } catch (e) {
       Util.dumpLn("Error while handling gesture event", aEvent.type,
                   "\nPlease report error at:", e);
       Cu.reportError(e);
     }
   },
 
-  _onSwipe: function _onSwipe(aEvent) {
+  _onSwipe: function(aEvent) {
     switch (aEvent.direction) {
       case Ci.nsIDOMSimpleGestureEvent.DIRECTION_LEFT:
         return this._tryCommand("cmd_forward");
       case Ci.nsIDOMSimpleGestureEvent.DIRECTION_RIGHT:
         return this._tryCommand("cmd_back");
     }
     return false;
   },
 
-  _tryCommand: function _tryCommand(aId) {
+  _tryCommand: function(aId) {
      if (document.getElementById(aId).getAttribute("disabled") == "true")
        return false;
      CommandUpdater.doCommand(aId);
      return true;
   },
 };
 
 /**
  * Helper to track when the user is using a precise pointing device (pen/mouse)
  * versus an imprecise one (touch).
  */
 var InputSourceHelper = {
   isPrecise: false,
 
-  init: function ish_init() {
+  init: function() {
     Services.obs.addObserver(this, "metro_precise_input", false);
     Services.obs.addObserver(this, "metro_imprecise_input", false);
   },
 
   _precise: function () {
     if (!this.isPrecise) {
       this.isPrecise = true;
       this._fire("MozPrecisePointer");
@@ -1020,28 +1020,28 @@ var InputSourceHelper = {
 
   _imprecise: function () {
     if (this.isPrecise) {
       this.isPrecise = false;
       this._fire("MozImprecisePointer");
     }
   },
 
-  observe: function BrowserUI_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "metro_precise_input":
         this._precise();
         break;
       case "metro_imprecise_input":
         this._imprecise();
         break;
     }
   },
 
-  fireUpdate: function fireUpdate() {
+  fireUpdate: function() {
     if (this.isPrecise) {
       this._fire("MozPrecisePointer");
     } else {
       this._fire("MozImprecisePointer");
     }
   },
 
   _fire: function (name) {
diff --git a/browser/metro/base/content/jsshell/shell.html b/browser/metro/base/content/jsshell/shell.html
--- a/browser/metro/base/content/jsshell/shell.html
+++ b/browser/metro/base/content/jsshell/shell.html
@@ -202,17 +202,17 @@ load : function load(url)
 
 clear : function clear()
 {
   var CHILDREN_TO_PRESERVE = 3;
   while (_out.childNodes[CHILDREN_TO_PRESERVE]) 
     _out.removeChild(_out.childNodes[CHILDREN_TO_PRESERVE]);
 },
 
-print : function print(s) { println(s, "print"); },
+print : function(s) { println(s, "print"); },
 
 // the normal function, "print", shouldn't return a value
 // (suggested by brendan; later noticed it was a problem when showing others)
 pr : function pr(s) 
 { 
   shellCommands.print(s); // need to specify shellCommands so it doesn't try window.print()!
   return s;
 },
diff --git a/browser/metro/base/content/library/SelectionPrototype.js b/browser/metro/base/content/library/SelectionPrototype.js
--- a/browser/metro/base/content/library/SelectionPrototype.js
+++ b/browser/metro/base/content/library/SelectionPrototype.js
@@ -111,45 +111,45 @@ SelectionPrototype.prototype = {
 
   /*
    * sendAsync
    *
    * Wrapper over sendAsyncMessage in content, waps direct invocation on
    * SelectionHelperUI in chrome. Should be overriden by objects that inherit
    * our behavior. 
    */
-  sendAsync: function sendAsync(aMsg, aJson) {
+  sendAsync: function(aMsg, aJson) {
     Util.dumpLn("Base sendAsync called on SelectionPrototype. This is a no-op.");
   },
 
   /*************************************************
    * Common browser event handlers
    */
 
    /*
     * _onCaretPositionUpdate - sets the current caret location based on
     * a client coordinates. Messages back with updated monocle position
     * information.
     *
     * @param aX, aY drag location in client coordinates.
     */
-  _onCaretPositionUpdate: function _onCaretPositionUpdate(aX, aY) {
+  _onCaretPositionUpdate: function(aX, aY) {
     this._onCaretMove(aX, aY);
 
     // Update the position of our selection monocles
     this._updateSelectionUI("caret", false, false, true);
   },
 
    /*
     * _onCaretMove - updates the current caret location based on a client
     * coordinates.
     *
     * @param aX, aY drag location in client coordinates.
     */
-  _onCaretMove: function _onCaretMove(aX, aY) {
+  _onCaretMove: function(aX, aY) {
     if (!this._targetIsEditable) {
       this._onFail("Unexpected, caret position isn't supported with non-inputs.");
       return;
     }
 
     // SelectionHelperUI sends text input tap coordinates and a caret move
     // event at the start of a monocle drag. caretPositionFromPoint isn't
     // going to give us correct info if the coord is outside the edit bounds,
@@ -162,26 +162,26 @@ SelectionPrototype.prototype = {
       let offset = cp.offset;
       input.selectionStart = input.selectionEnd = offset;
     }
   },
 
   /*
    * Turning on or off various debug features.
    */
-  _onSelectionDebug: function _onSelectionDebug(aMsg) {
+  _onSelectionDebug: function(aMsg) {
     this._debugOptions = aMsg;
     this._debugEvents = aMsg.dumpEvents;
   },
 
   /*
    * Selection Changed notification listener. This allows us to respond to selection changes
    * introduced programmatically by Gecko events, target-page support code, etc.
    */
-  notifySelectionChanged: function notifySelectionChanged(aDocument, aSelection, aReason) {
+  notifySelectionChanged: function(aDocument, aSelection, aReason) {
     // Ignore user generated selectionChange notifications during monocle/marker movement.
     if ((typeof SelectionHelperUI != "undefined") && SelectionHelperUI.hasActiveDrag) {
       return;
     }
 
     // Ignore selectionChange notifications, unless reason is mouseup, or unknown.
     if (!(aReason & Ci.nsISelectionListener.MOUSEUP_REASON) &&
         (aReason != Ci.nsISelectionListener.NO_REASON)) {
@@ -510,49 +510,49 @@ SelectionPrototype.prototype = {
   },
 
   /*
    * _backupRangeList, _restoreRangeList, and _freeRangeList
    *
    * Utilities that manage a cloned copy of the existing selection.
    */
 
-  _backupRangeList: function _backupRangeList() {
+  _backupRangeList: function() {
     this._rangeBackup = new Array();
     for (let idx = 0; idx < this._getSelection().rangeCount; idx++) {
       this._rangeBackup.push(this._getSelection().getRangeAt(idx).cloneRange());
     }
   },
 
-  _restoreRangeList: function _restoreRangeList() {
+  _restoreRangeList: function() {
     if (this._rangeBackup == null)
       return;
 
     // Remove every previously created selection range
     this._getSelection().removeAllRanges();
 
     for (let idx = 0; idx < this._rangeBackup.length; idx++) {
       this._getSelection().addRange(this._rangeBackup[idx]);
     }
     this._freeRangeList();
   },
 
-  _freeRangeList: function _restoreRangeList() {
+  _freeRangeList: function() {
     this._rangeBackup = null;
   },
 
   /*
    * Constrains a selection point within a text input control bounds.
    *
    * @param aPoint - client coordinate point
    * @param aMargin - added inner margin to respect, defaults to 0.
    * @param aOffset - amount to push the resulting point inward, defaults to 0.
    * @return new constrained point struct
    */
-  _constrainPointWithinControl: function _cpwc(aPoint, aMargin, aOffset) {
+  _constrainPointWithinControl: function(aPoint, aMargin, aOffset) {
     let margin = aMargin || 0;
     let offset = aOffset || 0;
     let bounds = this._getTargetBrowserRect();
     let point = { xPos: aPoint.xPos, yPos: aPoint.yPos };
     if (point.xPos <= (bounds.left + margin))
       point.xPos = bounds.left + offset;
     if (point.xPos >= (bounds.right - margin))
       point.xPos = bounds.right - offset;
@@ -565,17 +565,17 @@ SelectionPrototype.prototype = {
 
   /*
    * _pointOrientationToRect(aPoint, aRect)
    *
    * Returns a table representing which sides of target aPoint is offset
    * from: { left: offset, top: offset, right: offset, bottom: offset }
    * Works on client coordinates.
    */
-  _pointOrientationToRect: function _pointOrientationToRect(aPoint) {
+  _pointOrientationToRect: function(aPoint) {
     let bounds = this._getTargetBrowserRect();
     let result = { left: 0, right: 0, top: 0, bottom: 0 };
     if (aPoint.xPos <= bounds.left)
       result.left = bounds.left - aPoint.xPos;
     if (aPoint.xPos >= bounds.right)
       result.right = aPoint.xPos - bounds.right;
     if (aPoint.yPos <= bounds.top)
       result.top = bounds.top - aPoint.yPos;
@@ -592,17 +592,17 @@ SelectionPrototype.prototype = {
    * appropriately.
    *
    * @param aClientPoint raw pointer position
    * @return { speed: 0.0 -> 1.0,
    *           trigger: true/false if out of bounds,
    *           start: true/false if updated position,
    *           end: true/false if updated position }
    */
-  updateTextEditSelection: function updateTextEditSelection(aClientPoint) {
+  updateTextEditSelection: function(aClientPoint) {
     if (aClientPoint == undefined) {
       aClientPoint = this._rawSelectionPoint;
     }
     this._rawSelectionPoint = aClientPoint;
 
     let orientation = this._pointOrientationToRect(aClientPoint);
     let result = { speed: 1, trigger: false, start: false, end: false };
     let ml = Util.isMultilineInput(this._targetElement);
@@ -626,37 +626,37 @@ SelectionPrototype.prototype = {
     if (result.speed > 100)
       result.speed = 100;
     if (result.speed < 1)
       result.speed = 1;
     result.speed /= 100;
     return result;
   },
 
-  _setTextEditUpdateInterval: function _setTextEditUpdateInterval(aSpeedValue) {
+  _setTextEditUpdateInterval: function(aSpeedValue) {
     let timeout = (75 - (aSpeedValue * 75));
     if (!this._scrollTimer)
       this._scrollTimer = new Util.Timeout();
     this._scrollTimer.interval(timeout, this.scrollTimerCallback);
   },
 
-  _clearTimers: function _clearTimers() {
+  _clearTimers: function() {
     if (this._scrollTimer) {
       this._scrollTimer.clear();
     }
   },
 
   /*
    * _addEditSelection - selection control call wrapper for text inputs.
    * Adds selection on the anchor or focus side of selection in a text
    * input. Scrolls the location into view as well.
    *
    * @param const selection node identifier
    */
-  _addEditSelection: function _addEditSelection(aLocation) {
+  _addEditSelection: function(aLocation) {
     let selCtrl = this._getSelectController();
     try {
       if (aLocation == kSelectionNodeAnchor) {
         let start = Math.max(this._targetElement.selectionStart - 1, 0);
         this._targetElement.setSelectionRange(start, this._targetElement.selectionEnd,
                                               "backward");
       } else {
         let end = Math.min(this._targetElement.selectionEnd + 1,
@@ -666,17 +666,17 @@ SelectionPrototype.prototype = {
                                               "forward");
       }
       selCtrl.scrollSelectionIntoView(Ci.nsISelectionController.SELECTION_NORMAL,
                                       Ci.nsISelectionController.SELECTION_FOCUS_REGION,
                                       Ci.nsISelectionController.SCROLL_SYNCHRONOUS);
     } catch (ex) { Util.dumpLn(ex);}
   },
 
-  _updateInputFocus: function _updateInputFocus(aMarker) {
+  _updateInputFocus: function(aMarker) {
     try {
       let selCtrl = this._getSelectController();
       this._targetElement.setSelectionRange(this._targetElement.selectionStart,
                                             this._targetElement.selectionEnd,
                                             aMarker == "start" ?
                                               "backward" : "forward");
       selCtrl.scrollSelectionIntoView(Ci.nsISelectionController.SELECTION_NORMAL,
                                       Ci.nsISelectionController.SELECTION_FOCUS_REGION,
@@ -688,17 +688,17 @@ SelectionPrototype.prototype = {
    * _queryHalfLineHeight(aMarker, aSelection)
    *
    * Y offset applied to the coordinates of the selection position we send
    * to dom utils. The selection marker sits below text, but we want the
    * selection position to be on the text above the monocle. Since text
    * height can vary across the entire selection range, we need the correct
    * height based on the line the marker in question is moving on.
    */
-  _queryHalfLineHeight: function _queryHalfLineHeight(aMarker, aSelection) {
+  _queryHalfLineHeight: function(aMarker, aSelection) {
     let rects = aSelection.getRangeAt(0).getClientRects();
     if (!rects.length) {
       return 0;
     }
 
     // We are assuming here that these rects are ordered correctly.
     // From looking at the range code it appears they will be.
     let height = 0;
@@ -714,17 +714,17 @@ SelectionPrototype.prototype = {
   },
 
   /*
    * _setContinuousSelection()
    *
    * Smooths a selection with multiple ranges into a single
    * continuous range.
    */
-  _setContinuousSelection: function _setContinuousSelection() {
+  _setContinuousSelection: function() {
     let selection = this._getSelection();
     try {
       if (selection.rangeCount > 1) {
         let startRange = selection.getRangeAt(0);
         if (this. _debugOptions.displayRanges) {
           let clientRect = startRange.getBoundingClientRect();
           this._setDebugRect(clientRect, "red", false);
         }
@@ -785,17 +785,17 @@ SelectionPrototype.prototype = {
    *
    * Tests to see if aFramePoint intersects the current selection and if so,
    * collapses selection down to the opposite start or end point leaving a
    * character of selection at the collapse point.
    *
    * @param aMarker the marker that is being relocated. ("start" or "end")
    * @param aFramePoint position of the marker.
    */
-  _shrinkSelectionFromPoint: function _shrinkSelectionFromPoint(aMarker, aFramePoint) {
+  _shrinkSelectionFromPoint: function(aMarker, aFramePoint) {
     let result = false;
     try {
       let selection = this._getSelection();
       for (let range = 0; range < selection.rangeCount; range++) {
         // relative to frame
         let rects = selection.getRangeAt(range).getClientRects();
         for (let idx = 0; idx < rects.length; idx++) {
           // Util.dumpLn("[" + idx + "]", aFramePoint.xPos, aFramePoint.yPos, rects[idx].left,
@@ -837,17 +837,17 @@ SelectionPrototype.prototype = {
 
   /*
    * _updateUIMarkerRects(aSelection)
    *
    * Extracts the rects of the current selection, clips them to any text
    * input bounds, and stores them in the cache table we send over to
    * SelectionHelperUI.
    */
-  _updateUIMarkerRects: function _updateUIMarkerRects(aSelection) {
+  _updateUIMarkerRects: function(aSelection) {
     this._cache = this._extractUIRects(aSelection.getRangeAt(0));
     if (this. _debugOptions.dumpRanges)  {
        Util.dumpLn("start:", "(" + this._cache.start.xPos + "," +
                    this._cache.start.yPos + ")");
        Util.dumpLn("end:", "(" + this._cache.end.xPos + "," +
                    this._cache.end.yPos + ")");
        Util.dumpLn("caret:", "(" + this._cache.caret.xPos + "," +
                    this._cache.caret.yPos + ")");
@@ -856,17 +856,17 @@ SelectionPrototype.prototype = {
   },
 
   /*
    * _extractUIRects - Extracts selection and target element information
    * used by SelectionHelperUI. Returns client relative coordinates.
    *
    * @return table containing various ui rects and information
    */
-  _extractUIRects: function _extractUIRects(aRange) {
+  _extractUIRects: function(aRange) {
     let seldata = {
       start: {}, end: {}, caret: {},
       selection: { left: 0, top: 0, right: 0, bottom: 0 },
       element: { left: 0, top: 0, right: 0, bottom: 0 }
     };
 
     // When in an iframe, aRange coordinates are relative to the frame origin.
     let rects = aRange.getClientRects();
@@ -939,29 +939,29 @@ SelectionPrototype.prototype = {
     return restrictionWasRequired;
   },
 
   /*
    * Selection bounds will fall outside the bound of a control if the control
    * can scroll. Clip UI cache data to the bounds of the target so monocles
    * don't draw outside the control.
    */
-  _restrictSelectionRectToEditBounds: function _restrictSelectionRectToEditBounds() {
+  _restrictSelectionRectToEditBounds: function() {
     if (!this._targetIsEditable)
       return;
 
     let targetRectangle = this._getTargetBrowserRect();
     this._cache.start.restrictedToBounds = this._restrictPointToRectangle(
         this._cache.start, targetRectangle);
     this._cache.end.restrictedToBounds = this._restrictPointToRectangle(
         this._cache.end, targetRectangle);
     this._restrictPointToRectangle(this._cache.caret, targetRectangle);
   },
 
-  _restrictCoordinateToEditBounds: function _restrictCoordinateToEditBounds(aX, aY) {
+  _restrictCoordinateToEditBounds: function(aX, aY) {
     let result = {
       xPos: aX,
       yPos: aY
     };
     if (!this._targetIsEditable)
       return result;
     let bounds = this._getTargetBrowserRect();
     if (aX <= bounds.left)
@@ -978,61 +978,61 @@ SelectionPrototype.prototype = {
   /*************************************************
    * Utilities
    */
 
   /*
    * Returns bounds of the element relative to the inner sub frame it sits
    * in.
    */
-  _getTargetClientRect: function _getTargetClientRect() {
+  _getTargetClientRect: function() {
     return this._targetElement.getBoundingClientRect();
   },
 
   /*
    * Returns bounds of the element relative to the top level browser.
    */
-  _getTargetBrowserRect: function _getTargetBrowserRect() {
+  _getTargetBrowserRect: function() {
     let client = this._getTargetClientRect();
     return {
       left: client.left +  this._contentOffset.x,
       top: client.top +  this._contentOffset.y,
       right: client.right +  this._contentOffset.x,
       bottom: client.bottom +  this._contentOffset.y
     };
   },
 
-  _clientPointToFramePoint: function _clientPointToFramePoint(aClientPoint) {
+  _clientPointToFramePoint: function(aClientPoint) {
     let point = {
       xPos: aClientPoint.xPos - this._contentOffset.x,
       yPos: aClientPoint.yPos - this._contentOffset.y
     };
     return point;
   },
 
   /*************************************************
    * Debug routines
    */
 
-  _debugDumpSelection: function _debugDumpSelection(aNote, aSel) {
+  _debugDumpSelection: function(aNote, aSel) {
     Util.dumpLn("--" + aNote + "--");
     Util.dumpLn("anchor:", aSel.anchorNode, aSel.anchorOffset);
     Util.dumpLn("focus:", aSel.focusNode, aSel.focusOffset);
   },
 
-  _debugDumpChildNodes: function _dumpChildNodes(aNode, aSpacing) {
+  _debugDumpChildNodes: function(aNode, aSpacing) {
     for (let idx = 0; idx < aNode.childNodes.length; idx++) {
       let node = aNode.childNodes.item(idx);
       for (let spaceIdx = 0; spaceIdx < aSpacing; spaceIdx++) dump(" ");
       Util.dumpLn("[" + idx + "]", node);
       this._debugDumpChildNodes(node, aSpacing + 1);
     }
   },
 
-  _setDebugElementRect: function _setDebugElementRect(e, aScrollOffset, aColor) {
+  _setDebugElementRect: function(e, aScrollOffset, aColor) {
     try {
       if (e == null) {
         Util.dumpLn("_setDebugElementRect(): passed in null element");
         return;
       }
       if (e.offsetWidth == 0 || e.offsetHeight== 0) {
         Util.dumpLn("_setDebugElementRect(): passed in flat rect");
         return;
@@ -1056,29 +1056,29 @@ SelectionPrototype.prototype = {
    * Example:
    * let rect = { left: aPoint.xPos - 1, top: aPoint.yPos - 1,
    *              right: aPoint.xPos + 1, bottom: aPoint.yPos + 1 };
    * this._setDebugRect(rect, "red");
    *
    * In SelectionHelperUI, you'll need to turn on displayDebugLayer
    * in init().
    */
-  _setDebugRect: function _setDebugRect(aRect, aColor, aFill, aId) {
+  _setDebugRect: function(aRect, aColor, aFill, aId) {
     this.sendAsync("Content:SelectionDebugRect",
       { left:aRect.left, top:aRect.top,
         right:aRect.right, bottom:aRect.bottom,
         color:aColor, fill: aFill, id: aId });
   },
 
   /*
    * Adds a small debug rect at the point specified. Params are in
    * client coordinates.
    *
    * In SelectionHelperUI, you'll need to turn on displayDebugLayer
    * in init().
    */
-  _setDebugPoint: function _setDebugPoint(aX, aY, aColor) {
+  _setDebugPoint: function(aX, aY, aColor) {
     let rect = { left: aX - 2, top: aY - 2,
                  right: aX + 2, bottom: aY + 2 };
     this._setDebugRect(rect, aColor, true);
   },
 };
 this.SelectionPrototype = SelectionPrototype;
diff --git a/browser/metro/base/content/pages/config.js b/browser/metro/base/content/pages/config.js
--- a/browser/metro/base/content/pages/config.js
+++ b/browser/metro/base/content/pages/config.js
@@ -56,60 +56,60 @@ var NewPrefDialog = {
         this._prefTypeSelectElt.selectedIndex = 2;
         break;
     }
 
     this._newPrefItem.setAttribute("typestyle", aType);
   },
 
   // Init the NewPrefDialog
-  init: function AC_init() {
+  init: function() {
     this._prefsShield = document.getElementById("prefs-shield");
 
     this._newPrefsDialog = document.getElementById("new-pref-container");
     this._newPrefItem = document.getElementById("new-pref-item");
     this._prefNameInputElt = document.getElementById("new-pref-name");
     this._prefTypeSelectElt = document.getElementById("new-pref-type");
 
     this._booleanValue = document.getElementById("new-pref-value-boolean");
     this._stringValue = document.getElementById("new-pref-value-string");
     this._intValue = document.getElementById("new-pref-value-int");
 
     this._positiveButton = document.getElementById("positive-button");
   },
 
   // Called to update positive button to display text ("Create"/"Change), and enabled/disabled status
   // As new pref name is initially displayed, re-focused, or modifed during user input
-  _updatePositiveButton: function AC_updatePositiveButton(aPrefName) {
+  _updatePositiveButton: function(aPrefName) {
     this._positiveButton.textContent = gStringBundle.GetStringFromName("newPref.createButton");
     this._positiveButton.setAttribute("disabled", true);
     if (aPrefName == "") {
       return;
     }
 
     // If item already in list, it's being changed, else added
     let item = document.querySelector(".pref-item[name=\"" + CSS.escape(aPrefName) + "\"]");
     if (item) {
       this._positiveButton.textContent = gStringBundle.GetStringFromName("newPref.changeButton");
     } else {
       this._positiveButton.removeAttribute("disabled");
     }
   },
 
   // When we want to cancel/hide an existing, or show a new pref dialog
-  toggleShowHide: function AC_toggleShowHide() {
+  toggleShowHide: function() {
     if (this._newPrefsDialog.classList.contains("show")) {
       this.hide();
     } else {
       this._show();
     }
   },
 
   // When we want to show the new pref dialog / shield the prefs list
-  _show: function AC_show() {
+  _show: function() {
     this._newPrefsDialog.classList.add("show");
     this._prefsShield.setAttribute("shown", true);
 
     // Initial default field values
     this._prefNameInputElt.value = "";
     this._updatePositiveButton(this._prefNameInputElt.value);
 
     this.type = "boolean";
@@ -118,33 +118,33 @@ var NewPrefDialog = {
     this._intValue.value = "";
 
     this._prefNameInputElt.focus();
 
     window.addEventListener("keypress", this.handleKeypress, false);
   },
 
   // When we want to cancel/hide the new pref dialog / un-shield the prefs list
-  hide: function AC_hide() {
+  hide: function() {
     this._newPrefsDialog.classList.remove("show");
     this._prefsShield.removeAttribute("shown");
 
     window.removeEventListener("keypress", this.handleKeypress, false);
   },
 
   // Watch user key input so we can provide Enter key action, commit input values
-  handleKeypress: function AC_handleKeypress(aEvent) {
+  handleKeypress: function(aEvent) {
     // Close our VKB on new pref enter key press
     if (aEvent.keyCode == KeyEvent.DOM_VK_RETURN)
       aEvent.target.blur();
   },
 
   // New prefs create dialog only allows creating a non-existing preference, doesn't allow for
   // Changing an existing one on-the-fly, tap existing/displayed line item pref for that
-  create: function AC_create(aEvent) {
+  create: function(aEvent) {
     if (this._positiveButton.getAttribute("disabled") == "true") {
       return;
     }
 
     switch(this.type) {
       case "boolean":
         Services.prefs.setBoolPref(this._prefNameInputElt.value, (this._booleanValue.value == "true") ? true : false);
         break;
@@ -155,28 +155,28 @@ var NewPrefDialog = {
         Services.prefs.setIntPref(this._prefNameInputElt.value, this._intValue.value);
         break;
     }
 
     this.hide();
   },
 
   // Display proper positive button text/state on new prefs name input focus
-  focusName: function AC_focusName(aEvent) {
+  focusName: function(aEvent) {
     this._updatePositiveButton(aEvent.target.value);
   },
 
   // Display proper positive button text/state as user changes new prefs name
-  updateName: function AC_updateName(aEvent) {
+  updateName: function(aEvent) {
     this._updatePositiveButton(aEvent.target.value);
   },
 
   // In new prefs dialog, bool prefs are <input type="text">, as they aren't yet tied to an
   // Actual Services.prefs.*etBoolPref()
-  toggleBoolValue: function AC_toggleBoolValue() {
+  toggleBoolValue: function() {
     this._booleanValue.value = (this._booleanValue.value == "true" ? "false" : "true");
   }
 }
 
 
 /* ============================== AboutConfig ==============================
  *
  * Main AboutConfig object and methods
@@ -189,17 +189,17 @@ var AboutConfig = {
   filterInput: null,
   _filterPrevInput: null,
   _filterChangeTimer: null,
   _prefsContainer: null,
   _loadingContainer: null,
   _list: null,
 
   // Init the main AboutConfig dialog
-  init: function AC_init() {
+  init: function() {
     this.filterInput = document.getElementById("filter-input");
     this._prefsContainer = document.getElementById("prefs-container");
     this._loadingContainer = document.getElementById("loading-container");
 
     let list = Services.prefs.getChildList("");
     this._list = list.sort().map( function AC_getMapPref(aPref) {
       return new Pref(aPref);
     }, this);
@@ -207,42 +207,42 @@ var AboutConfig = {
     // Display the current prefs list (retains searchFilter value)
     this.bufferFilterInput();
 
     // Setup the prefs observers
     Services.prefs.addObserver("", this, false);
   },
 
   // Uninit the main AboutConfig dialog
-  uninit: function AC_uninit() {
+  uninit: function() {
     // Remove the prefs observer
     Services.prefs.removeObserver("", this);
   },
 
   // Clear the filterInput value, to display the entire list
-  clearFilterInput: function AC_clearFilterInput() {
+  clearFilterInput: function() {
     this.filterInput.value = "";
     this.bufferFilterInput();
   },
 
   // Buffer down rapid changes in filterInput value from keyboard
-  bufferFilterInput: function AC_bufferFilterInput() {
+  bufferFilterInput: function() {
     if (this._filterChangeTimer) {
       clearTimeout(this._filterChangeTimer);
     }
 
     this._filterChangeTimer = setTimeout((function() {
       this._filterChangeTimer = null;
       // Display updated prefs list when filterInput value settles
       this._displayNewList();
     }).bind(this), FILTER_CHANGE_TRIGGER);
   },
 
   // Update displayed list when filterInput value changes
-  _displayNewList: function AC_displayNewList() {
+  _displayNewList: function() {
     // This survives the search filter value past a page refresh
     this.filterInput.setAttribute("value", this.filterInput.value);
 
     // Don't start new filter search if same as last
     if (this.filterInput.value == this._filterPrevInput) {
       return;
     }
     this._filterPrevInput = this.filterInput.value;
@@ -255,30 +255,30 @@ var AboutConfig = {
 
     // Pause for screen to settle, then ensure at top
     setTimeout((function() {
       window.scrollTo(0, 0);
     }).bind(this), INITIAL_PAGE_DELAY);
   },
 
   // Clear the displayed preferences list
-  _clearPrefsContainer: function AC_clearPrefsContainer() {
+  _clearPrefsContainer: function() {
     // Quick clear the prefsContainer list
     let empty = this._prefsContainer.cloneNode(false);
     this._prefsContainer.parentNode.replaceChild(empty, this._prefsContainer);
     this._prefsContainer = empty;
 
     // Quick clear the prefs li.HTML list
     this._list.forEach(function(item) {
       delete item.li;
     });
   },
 
   // Get a small manageable block of prefs items, and add them to the displayed list
-  _addMorePrefsToContainer: function AC_addMorePrefsToContainer() {
+  _addMorePrefsToContainer: function() {
     // Create filter regex
     let filterExp = this.filterInput.value ?
       new RegExp(this.filterInput.value, "i") : null;
 
     // Get a new block for the display list
     let prefsBuffer = [];
     for (let i = 0; i < this._list.length && prefsBuffer.length < PREFS_BUFFER_MAX; i++) {
       if (!this._list[i].li && this._list[i].test(filterExp)) {
@@ -306,17 +306,17 @@ var AboutConfig = {
     } else {
       // If no more could be displayed, hide the throbber, and stop noticing scroll events
       this._loadingContainer.style.display = "none";
       window.onscroll = null;
     }
   },
 
   // If scrolling at the bottom, maybe add some more entries
-  onScroll: function AC_onScroll(aEvent) {
+  onScroll: function(aEvent) {
     if (this._prefsContainer.scrollHeight - (window.pageYOffset + window.innerHeight) < PAGE_SCROLL_TRIGGER) {
       if (!this._filterChangeTimer) {
         this._addMorePrefsToContainer();
       }
     }
   },
 
   // Return currently selected list item node
@@ -340,40 +340,40 @@ var AboutConfig = {
     // Set any current selection
     if (aSelection) {
       aSelection.classList.add("selected");
       aSelection.addEventListener("keypress", this.handleKeypress, false);
     }
   },
 
   // Watch user key input so we can provide Enter key action, commit input values
-  handleKeypress: function AC_handleKeypress(aEvent) {
+  handleKeypress: function(aEvent) {
     if (aEvent.keyCode == KeyEvent.DOM_VK_RETURN)
       aEvent.target.blur();
   },
 
   // Return the target list item node of an action event
-  getLINodeForEvent: function AC_getLINodeForEvent(aEvent) {
+  getLINodeForEvent: function(aEvent) {
     let node = aEvent.target;
     while (node && node.nodeName != "li") {
       node = node.parentNode;
     }
 
     return node;
   },
 
   // Return a pref of a list item node
-  _getPrefForNode: function AC_getPrefForNode(aNode) {
+  _getPrefForNode: function(aNode) {
     let pref = aNode.getAttribute("name");
 
     return new Pref(pref);
   },
 
   // When list item name or value are tapped
-  selectOrToggleBoolPref: function AC_selectOrToggleBoolPref(aEvent) {
+  selectOrToggleBoolPref: function(aEvent) {
     let node = this.getLINodeForEvent(aEvent);
 
     // If not already selected, just do so
     if (this.selected != node) {
       this.selected = node;
       return;
     }
 
@@ -382,17 +382,17 @@ var AboutConfig = {
     if (pref.type != Services.prefs.PREF_BOOL) {
       return;
     }
 
     this.toggleBoolPref(aEvent);
   },
 
   // When finalizing list input values due to blur
-  setIntOrStringPref: function AC_setIntOrStringPref(aEvent) {
+  setIntOrStringPref: function(aEvent) {
     let node = this.getLINodeForEvent(aEvent);
 
     // Skip if locked
     let pref = this._getPrefForNode(node);
     if (pref.locked) {
       return;
     }
 
@@ -401,59 +401,59 @@ var AboutConfig = {
       return;
     }
 
     // String and Int inputs change / commit on blur
     pref.value = aEvent.target.value;
   },
 
   // When we reset a pref to it's default value (note resetting a user created pref will delete it)
-  resetDefaultPref: function AC_resetDefaultPref(aEvent) {
+  resetDefaultPref: function(aEvent) {
     let node = this.getLINodeForEvent(aEvent);
 
     // If not already selected, do so
     if (this.selected != node) {
       this.selected = node;
     }
 
     // Reset will handle any locked condition
     let pref = this._getPrefForNode(node);
     pref.reset();
   },
 
   // When we want to toggle a bool pref
-  toggleBoolPref: function AC_toggleBoolPref(aEvent) {
+  toggleBoolPref: function(aEvent) {
     let node = this.getLINodeForEvent(aEvent);
 
     // Skip if locked, or not boolean
     let pref = this._getPrefForNode(node);
     if (pref.locked) {
       return;
     }
 
     // Toggle, and blur to remove field focus
     pref.value = !pref.value;
     aEvent.target.blur();
   },
 
   // When Int inputs have their Up or Down arrows toggled
-  incrOrDecrIntPref: function AC_incrOrDecrIntPref(aEvent, aInt) {
+  incrOrDecrIntPref: function(aEvent, aInt) {
     let node = this.getLINodeForEvent(aEvent);
 
     // Skip if locked
     let pref = this._getPrefForNode(node);
     if (pref.locked) {
       return;
     }
 
     pref.value += aInt;
   },
 
   // Observe preference changes
-  observe: function AC_observe(aSubject, aTopic, aPrefName) {
+  observe: function(aSubject, aTopic, aPrefName) {
     let pref = new Pref(aPrefName);
 
     // Ignore uninteresting changes, and avoid "private" preferences
     if (aTopic != "nsPref:changed") {
       return;
     }
 
     // If pref type invalid, refresh display as user reset/removed an item from the list
@@ -529,26 +529,26 @@ Pref.prototype = {
   get default() {
     return !Services.prefs.prefHasUserValue(this.name);
   },
 
   get locked() {
     return Services.prefs.prefIsLocked(this.name);
   },
 
-  reset: function AC_reset() {
+  reset: function() {
     Services.prefs.clearUserPref(this.name);
   },
 
-  test: function AC_test(aValue) {
+  test: function(aValue) {
     return aValue ? aValue.test(this.name) : true;
   },
 
   // Get existing or create new LI node for the pref
-  getOrCreateNewLINode: function AC_getOrCreateNewLINode() {
+  getOrCreateNewLINode: function() {
     if (!this.li) {
       this.li = document.createElement("li");
 
       this.li.className = "pref-item";
       this.li.setAttribute("name", this.name);
 
       // Click callback to ensure list item selected even on no-action tap events
       this.li.addEventListener("click",
@@ -588,17 +588,17 @@ Pref.prototype = {
       // Delay providing the list item values, until the LI is returned and added to the document
       setTimeout(this._valueSetup.bind(this), INNERHTML_VALUE_DELAY);
     }
 
     return this.li;
   },
 
   // Initialize list item object values
-  _valueSetup: function AC_valueSetup() {
+  _valueSetup: function() {
 
     this.li.setAttribute("type", this.type);
     this.li.setAttribute("value", this.value);
 
     let valDiv = this.li.querySelector(".pref-value");
     valDiv.value = this.value;
 
     switch(this.type) {
diff --git a/browser/metro/base/content/sanitizeUI.js b/browser/metro/base/content/sanitizeUI.js
--- a/browser/metro/base/content/sanitizeUI.js
+++ b/browser/metro/base/content/sanitizeUI.js
@@ -17,17 +17,17 @@ var SanitizeUI = {
   },
 
   init: function () {
     this._sanitizer = new Sanitizer();
     this._privData.addEventListener("CheckboxStateChange", this, true);
   },
 
   _clearNotificationTimeout: null,
-  onSanitize: function onSanitize() {
+  onSanitize: function() {
     let button = document.getElementById("prefs-clear-data");
     let clearNotificationDeck = document.getElementById("clear-notification");
     let clearNotificationEmpty = document.getElementById("clear-notification-empty");
     let clearNotificationClearing = document.getElementById("clear-notification-clearing");
     let clearNotificationDone = document.getElementById("clear-notification-done");
     let allCheckboxes = SanitizeUI._privData.querySelectorAll("checkbox");
     let allSelected = SanitizeUI._privData.querySelectorAll(
       "#prefs-privdata-history[checked], " +
@@ -64,17 +64,17 @@ var SanitizeUI = {
       clearTimeout(SanitizeUI._clearNotificationTimeout);
       SanitizeUI._clearNotificationTimeout = setTimeout(function() {
         clearNotificationDeck.selectedPanel = clearNotificationEmpty;
       }, 4000);
     }, 0);
   },
 
   /* Disable the clear button when nothing is selected */
-  _onCheckboxChange: function _onCheckboxChange() {
+  _onCheckboxChange: function() {
     let anySelected = SanitizeUI._privData.querySelector(
       "#prefs-privdata-history[checked], " +
       "#prefs-privdata-other[checked] + #prefs-privdata-subitems .privdata-subitem-item[checked]");
 
     let clearButton = document.getElementById("prefs-clear-data");
     clearButton.disabled = !anySelected;
   },
 
diff --git a/browser/metro/base/content/startui/BookmarksView.js b/browser/metro/base/content/startui/BookmarksView.js
--- a/browser/metro/base/content/startui/BookmarksView.js
+++ b/browser/metro/base/content/startui/BookmarksView.js
@@ -59,49 +59,49 @@ BookmarksView.prototype = Util.extend(Ob
   get root() {
     return this._root;
   },
 
   set root(aRoot) {
     this._root = aRoot;
   },
 
-  destruct: function bv_destruct() {
+  destruct: function() {
     this._bookmarkService.removeObserver(this._changes);
     if (StartUI.chromeWin) {
       StartUI.chromeWin.removeEventListener('MozAppbarDismissing', this, false);
       StartUI.chromeWin.removeEventListener('BookmarksNeedsRefresh', this, false);
     }
     View.prototype.destruct.call(this);
   },
 
   refreshView: function () {
     this.clearBookmarks();
     this.getBookmarks();
   },
 
-  handleItemClick: function bv_handleItemClick(aItem) {
+  handleItemClick: function(aItem) {
     let url = aItem.getAttribute("value");
     StartUI.goToURI(url);
   },
 
-  _getItemForBookmarkId: function bv__getItemForBookmark(aBookmarkId) {
+  _getItemForBookmarkId: function(aBookmarkId) {
     return this._set.querySelector("richgriditem[anonid='" + aBookmarkId + "']");
   },
 
-  _getBookmarkIdForItem: function bv__getBookmarkForItem(aItem) {
+  _getBookmarkIdForItem: function(aItem) {
     return +aItem.getAttribute("anonid");
   },
 
-  _updateItemWithAttrs: function dv__updateItemWithAttrs(anItem, aAttrs) {
+  _updateItemWithAttrs: function(anItem, aAttrs) {
     for (let name in aAttrs)
       anItem.setAttribute(name, aAttrs[name]);
   },
 
-  getBookmarks: function bv_getBookmarks(aRefresh) {
+  getBookmarks: function(aRefresh) {
     let options = this._navHistoryService.getNewQueryOptions();
     options.queryType = options.QUERY_TYPE_BOOKMARKS;
     options.excludeQueries = true; // Don't include "smart folders"
     options.sortingMode = this._sort;
 
     let limit = this.maxTiles;
 
     let query = this._navHistoryService.getNewQuery();
@@ -152,52 +152,52 @@ BookmarksView.prototype = Util.extend(Ob
       while (this._set.itemCount > limit)
         this._set.removeItemAt(this._set.itemCount - 1, true);
     }
     this._set.arrangeItems();
     this._inBatch = false;
     rootNode.containerOpen = false;
   },
 
-  inCurrentView: function bv_inCurrentView(aParentId, aItemId) {
+  inCurrentView: function(aParentId, aItemId) {
     if (this._root && aParentId != this._root)
       return false;
 
     return !!this._getItemForBookmarkId(aItemId);
   },
 
-  clearBookmarks: function bv_clearBookmarks() {
+  clearBookmarks: function() {
     if ('clearAll' in this._set)
       this._set.clearAll();
   },
 
-  addBookmark: function bv_addBookmark(aBookmarkId, aPos) {
+  addBookmark: function(aBookmarkId, aPos) {
     let index = this._bookmarkService.getItemIndex(aBookmarkId);
     let uri = this._bookmarkService.getBookmarkURI(aBookmarkId);
     let title = this._bookmarkService.getItemTitle(aBookmarkId) || uri.spec;
     let item = this._set.insertItemAt(aPos || index, title, uri.spec, this._inBatch);
     item.setAttribute("anonid", aBookmarkId);
     this._setContextActions(item);
     this._updateFavicon(item, uri);
   },
 
-  _setContextActions: function bv__setContextActions(aItem) {
+  _setContextActions: function(aItem) {
     let itemId = this._getBookmarkIdForItem(aItem);
     aItem.setAttribute("data-contextactions", "delete," + (this._pinHelper.isPinned(itemId) ? "hide" : "pin"));
     if (aItem.refresh) aItem.refresh();
   },
 
   _sendNeedsRefresh: function bv__sendNeedsRefresh(){
     // Event sent when all view instances need to refresh.
     let event = document.createEvent("Events");
     event.initEvent("BookmarksNeedsRefresh", true, false);
     window.dispatchEvent(event);
   },
 
-  updateBookmark: function bv_updateBookmark(aBookmarkId) {
+  updateBookmark: function(aBookmarkId) {
     let item = this._getItemForBookmarkId(aBookmarkId);
 
     if (!item)
       return;
 
     let oldIndex = this._set.getIndexOfItem(item);
     let index = this._bookmarkService.getItemIndex(aBookmarkId);
 
@@ -212,23 +212,23 @@ BookmarksView.prototype = Util.extend(Ob
 
     item.setAttribute("anonid", aBookmarkId);
     item.setAttribute("value", uri.spec);
     item.setAttribute("label", title);
 
     this._updateFavicon(item, uri);
   },
 
-  removeBookmark: function bv_removeBookmark(aBookmarkId) {
+  removeBookmark: function(aBookmarkId) {
     let item = this._getItemForBookmarkId(aBookmarkId);
     let index = this._set.getIndexOfItem(item);
     this._set.removeItemAt(index, this._inBatch);
   },
 
-  doActionOnSelectedTiles: function bv_doActionOnSelectedTiles(aActionName, aEvent) {
+  doActionOnSelectedTiles: function(aActionName, aEvent) {
     let tileGroup = this._set;
     let selectedTiles = tileGroup.selectedItems;
 
     switch (aActionName){
       case "delete":
         Array.forEach(selectedTiles, function(aNode) {
           if (!this._toRemove) {
             this._toRemove = [];
@@ -281,17 +281,17 @@ BookmarksView.prototype = Util.extend(Ob
       default:
         return;
     }
 
     // Send refresh event so all view are in sync.
     this._sendNeedsRefresh();
   },
 
-  handleEvent: function bv_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type){
       case "MozAppbarDismissing":
         // If undo wasn't pressed, time to do definitive actions.
         if (this._toRemove) {
           for (let bookmarkId of this._toRemove) {
             this._bookmarkService.removeItem(bookmarkId);
           }
           this._toRemove = null;
@@ -310,23 +310,23 @@ BookmarksView.prototype = Util.extend(Ob
     }
   }
 });
 
 let BookmarksStartView = {
   _view: null,
   get _grid() { return document.getElementById("start-bookmarks-grid"); },
 
-  init: function init() {
+  init: function() {
     this._view = new BookmarksView(this._grid, Bookmarks.metroRoot, true);
     this._view.getBookmarks();
     this._grid.removeAttribute("fade");
   },
 
-  uninit: function uninit() {
+  uninit: function() {
     if (this._view) {
       this._view.destruct();
     }
   },
 };
 
 /**
  * Observes bookmark changes and keeps a linked BookmarksView updated.
@@ -338,43 +338,43 @@ function BookmarkChangeListener(aView) {
 }
 
 BookmarkChangeListener.prototype = {
   //////////////////////////////////////////////////////////////////////////////
   //// nsINavBookmarkObserver
   onBeginUpdateBatch: function () { },
   onEndUpdateBatch: function () { },
 
-  onItemAdded: function bCL_onItemAdded(aItemId, aParentId, aIndex, aItemType, aURI, aTitle, aDateAdded, aGUID, aParentGUID) {
+  onItemAdded: function(aItemId, aParentId, aIndex, aItemType, aURI, aTitle, aDateAdded, aGUID, aParentGUID) {
     this._view.getBookmarks(true);
   },
 
-  onItemChanged: function bCL_onItemChanged(aItemId, aProperty, aIsAnnotationProperty, aNewValue, aLastModified, aItemType, aParentId, aGUID, aParentGUID) {
+  onItemChanged: function(aItemId, aProperty, aIsAnnotationProperty, aNewValue, aLastModified, aItemType, aParentId, aGUID, aParentGUID) {
     let itemIndex = PlacesUtils.bookmarks.getItemIndex(aItemId);
     if (!this._view.inCurrentView(aParentId, aItemId))
       return;
 
     this._view.updateBookmark(aItemId);
   },
 
-  onItemMoved: function bCL_onItemMoved(aItemId, aOldParentId, aOldIndex, aNewParentId, aNewIndex, aItemType, aGUID, aOldParentGUID, aNewParentGUID) {
+  onItemMoved: function(aItemId, aOldParentId, aOldIndex, aNewParentId, aNewIndex, aItemType, aGUID, aOldParentGUID, aNewParentGUID) {
     let wasInView = this._view.inCurrentView(aOldParentId, aItemId);
     let nowInView = this._view.inCurrentView(aNewParentId, aItemId);
 
     if (!wasInView && nowInView)
       this._view.addBookmark(aItemId);
 
     if (wasInView && !nowInView)
       this._view.removeBookmark(aItemId);
 
     this._view.getBookmarks(true);
   },
 
   onBeforeItemRemoved: function (aItemId, aItemType, aParentId, aGUID, aParentGUID) { },
-  onItemRemoved: function bCL_onItemRemoved(aItemId, aParentId, aIndex, aItemType, aURI, aGUID, aParentGUID) {
+  onItemRemoved: function(aItemId, aParentId, aIndex, aItemType, aURI, aGUID, aParentGUID) {
     if (!this._view.inCurrentView(aParentId, aItemId))
       return;
 
     this._view.removeBookmark(aItemId);
     this._view.getBookmarks(true);
   },
 
   onItemVisited: function(aItemId, aVisitId, aTime, aTransitionType, aURI, aParentId, aGUID, aParentGUID) { },
diff --git a/browser/metro/base/content/startui/HistoryView.js b/browser/metro/base/content/startui/HistoryView.js
--- a/browser/metro/base/content/startui/HistoryView.js
+++ b/browser/metro/base/content/startui/HistoryView.js
@@ -28,36 +28,36 @@ HistoryView.prototype = Util.extend(Obje
   _set: null,
   _toRemove: null,
 
   // For View's showing property
   get vbox() {
     return document.getElementById("start-history");
   },
 
-  destruct: function destruct() {
+  destruct: function() {
     this._historyService.removeObserver(this);
     if (StartUI.chromeWin) {
       StartUI.chromeWin.removeEventListener('MozAppbarDismissing', this, false);
       StartUI.chromeWin.removeEventListener('HistoryNeedsRefresh', this, false);
     }
     View.prototype.destruct.call(this);
   },
 
   refreshView: function () {
     this.onClearHistory();
     this.populateGrid();
   },
 
-  handleItemClick: function tabview_handleItemClick(aItem) {
+  handleItemClick: function(aItem) {
     let url = aItem.getAttribute("value");
     StartUI.goToURI(url);
   },
 
-  populateGrid: function populateGrid(aRefresh) {
+  populateGrid: function(aRefresh) {
     this._inBatch++; // always batch up grid updates to avoid redundant arrangeItems calls
     let query = this._navHistoryService.getNewQuery();
     let options = this._navHistoryService.getNewQueryOptions();
     options.excludeQueries = true;
     options.queryType = options.QUERY_TYPE_HISTORY;
     options.resultType = options.RESULTS_AS_URI;
     options.sortingMode = options.SORT_BY_DATE_DESCENDING;
 
@@ -107,23 +107,23 @@ HistoryView.prototype = Util.extend(Obje
     }
 
     rootNode.containerOpen = false;
     this._set.arrangeItems();
     if (this._inBatch > 0)
       this._inBatch--;
   },
 
-  addItemToSet: function addItemToSet(aURI, aTitle, aIcon, aPos) {
+  addItemToSet: function(aURI, aTitle, aIcon, aPos) {
     let item = this._set.insertItemAt(aPos || 0, aTitle, aURI, this._inBatch);
     this._setContextActions(item);
     this._updateFavicon(item, aURI);
   },
 
-  _setContextActions: function bv__setContextActions(aItem) {
+  _setContextActions: function(aItem) {
     let uri = aItem.getAttribute("value");
     aItem.setAttribute("data-contextactions", "delete," + (this._pinHelper.isPinned(uri) ? "hide" : "pin"));
     if ("refresh" in aItem) aItem.refresh();
   },
 
   _sendNeedsRefresh: function bv__sendNeedsRefresh(){
     // Event sent when all views need to refresh.
     let event = document.createEvent("Events");
@@ -134,17 +134,17 @@ HistoryView.prototype = Util.extend(Obje
   removeHistory: function (aUri) {
     let items = this._set.getItemsByUrl(aUri);
     for (let item of items)
       this._set.removeItem(item, true);
     if (!this._inBatch)
       this._set.arrangeItems();
   },
 
-  doActionOnSelectedTiles: function bv_doActionOnSelectedTiles(aActionName, aEvent) {
+  doActionOnSelectedTiles: function(aActionName, aEvent) {
     let tileGroup = this._set;
     let selectedTiles = tileGroup.selectedItems;
 
     // just arrange the grid once at the end of any action handling
     this._inBatch = true;
 
     switch (aActionName){
       case "delete":
@@ -202,17 +202,17 @@ HistoryView.prototype = Util.extend(Obje
         return;
     }
 
     this._inBatch = false;
     // Send refresh event so all view are in sync.
     this._sendNeedsRefresh();
   },
 
-  handleEvent: function bv_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type){
       case "MozAppbarDismissing":
         // If undo wasn't pressed, time to do definitive actions.
         if (this._toRemove) {
           for (let uri of this._toRemove) {
             this._historyService.removePage(NetUtil.newURI(uri));
           }
 
@@ -304,20 +304,20 @@ HistoryView.prototype = Util.extend(Obje
     throw Cr.NS_ERROR_NO_INTERFACE;
   }
 });
 
 let HistoryStartView = {
   _view: null,
   get _grid() { return document.getElementById("start-history-grid"); },
 
-  init: function init() {
+  init: function() {
     this._view = new HistoryView(this._grid, true);
     this._view.populateGrid();
     this._grid.removeAttribute("fade");
   },
 
-  uninit: function uninit() {
+  uninit: function() {
     if (this._view) {
       this._view.destruct();
     }
   }
 };
diff --git a/browser/metro/base/content/startui/RemoteTabsView.js b/browser/metro/base/content/startui/RemoteTabsView.js
--- a/browser/metro/base/content/startui/RemoteTabsView.js
+++ b/browser/metro/base/content/startui/RemoteTabsView.js
@@ -40,33 +40,33 @@ function RemoteTabsView(aSet, aSetUIAcce
     this.setUIAccessVisible(false);
   }
 }
 
 RemoteTabsView.prototype = Util.extend(Object.create(View.prototype), {
   _set: null,
   _uiAccessElements: [],
 
-  handleItemClick: function tabview_handleItemClick(aItem) {
+  handleItemClick: function(aItem) {
     let url = aItem.getAttribute("value");
     StartUI.goToURI(url);
   },
 
   observe: function(subject, topic, data) {
     switch (topic) {
       case "weave:service:sync:finish":
         this.populateGrid();
         break;
       case "weave:service:start-over":
         this.setUIAccessVisible(false);
         break;
     }
   },
 
-  setUIAccessVisible: function setUIAccessVisible(aVisible) {
+  setUIAccessVisible: function(aVisible) {
     for (let elem of this._uiAccessElements) {
       elem.hidden = !aVisible;
     }
   },
 
   getIcon: function (iconUri, defaultIcon) {
     try {
       let iconURI = Weave.Utils.makeURI(iconUri);
@@ -74,17 +74,17 @@ RemoteTabsView.prototype = Util.extend(O
     } catch(ex) {
       // Do nothing.
     }
 
     // Just give the provided default icon or the system's default.
     return defaultIcon || PlacesUtils.favicons.defaultFavicon.spec;
   },
 
-  populateGrid: function populateGrid() {
+  populateGrid: function() {
 
     let tabsEngine = Weave.Service.engineManager.get("tabs");
     let list = this._set;
     let seenURLs = new Set();
     let localURLs = tabsEngine.getOpenURLs();
 
     // Clear grid, We don't know what has happened to tabs since last sync
     // Also can result in duplicate tabs(bug 864614)
@@ -107,37 +107,37 @@ RemoteTabsView.prototype = Util.extend(O
         item.setAttribute("iconURI", this.getIcon(icon));
 
       }, this);
     }
     this.setUIAccessVisible(show);
     this._set.arrangeItems();
   },
 
-  destruct: function destruct() {
+  destruct: function() {
     Weave.Svc.Obs.remove("weave:engine:sync:finish", this);
     Weave.Svc.Obs.remove("weave:service:logout:start-over", this);
     View.prototype.destruct.call(this);
   },
 
-  isSyncEnabled: function isSyncEnabled() {
+  isSyncEnabled: function() {
     return (Weave.Status.checkSetup() != Weave.CLIENT_NOT_CONFIGURED);
   }
 
 });
 
 let RemoteTabsStartView = {
   _view: null,
   get _grid() { return document.getElementById("start-remotetabs-grid"); },
 
-  init: function init() {
+  init: function() {
     let vbox = document.getElementById("start-remotetabs");
     let uiList = [vbox];
     this._view = new RemoteTabsView(this._grid, uiList);
     this._grid.removeAttribute("fade");
   },
 
-  uninit: function uninit() {
+  uninit: function() {
     if (this._view) {
       this._view.destruct();
     }
   },
 };
diff --git a/browser/metro/base/content/startui/StartUI.js b/browser/metro/base/content/startui/StartUI.js
--- a/browser/metro/base/content/startui/StartUI.js
+++ b/browser/metro/base/content/startui/StartUI.js
@@ -9,17 +9,17 @@ Cu.import("resource://gre/modules/Servic
 var StartUI = {
   get startUI() { return document.getElementById("start-container"); },
 
   get chromeWin() {
     // XXX Not e10s friendly. We use this in a few places.
     return Services.wm.getMostRecentWindow('navigator:browser');
   },
 
-  init: function init() {
+  init: function() {
     this.startUI.addEventListener("click", this, false);
     this.startUI.addEventListener("MozMousePixelScroll", this, false);
 
     // Update the input type on our local broadcaster
     document.getElementById("bcast_preciseInput").setAttribute("input",
       this.chromeWin.InputSourceHelper.isPrecise ? "precise" : "imprecise");
 
     let firstRunCount = Services.prefs.getIntPref("browser.firstrun.count");
@@ -59,43 +59,43 @@ var StartUI = {
     }
     Services.obs.removeObserver(this, "metro_viewstate_changed");
   },
 
   goToURI: function (aURI) {
     this.chromeWin.BrowserUI.goToURI(aURI);
   },
 
-  onClick: function onClick(aEvent) {
+  onClick: function(aEvent) {
     // If someone clicks / taps in empty grid space, take away
     // focus from the nav bar edit so the soft keyboard will hide.
     this.chromeWin.BrowserUI.blurNavBar();
 
     if (aEvent.button == 0) {
       this.chromeWin.ContextUI.dismissTabs();
     }
   },
 
-  onNarrowTitleClick: function onNarrowTitleClick(sectionId) {
+  onNarrowTitleClick: function(sectionId) {
     let section = document.getElementById(sectionId);
 
     if (section.hasAttribute("expanded"))
       return;
 
     for (let expandedSection of this.startUI.querySelectorAll(".meta-section[expanded]"))
       expandedSection.removeAttribute("expanded")
 
     section.setAttribute("expanded", "true");
   },
 
   _adjustDOMforViewState: function(aState) {
     document.getElementById("bcast_windowState").setAttribute("viewstate", aState);
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "MozPrecisePointer":
         document.getElementById("bcast_preciseInput").setAttribute("input", "precise");
         break;
       case "MozImprecisePointer":
         document.getElementById("bcast_preciseInput").setAttribute("input", "imprecise");
         break;
       case "click":
diff --git a/browser/metro/base/content/startui/TopSitesView.js b/browser/metro/base/content/startui/TopSitesView.js
--- a/browser/metro/base/content/startui/TopSitesView.js
+++ b/browser/metro/base/content/startui/TopSitesView.js
@@ -33,26 +33,26 @@ TopSitesView.prototype = Util.extend(Obj
   // isUpdating used only for testing currently
   isUpdating: false,
 
   // For View's showing property
   get vbox() {
     return document.getElementById("start-topsites");
   },
 
-  destruct: function destruct() {
+  destruct: function() {
     Services.obs.removeObserver(this, "Metro:RefreshTopsiteThumbnail");
     NewTabUtils.allPages.unregister(this);
     if (StartUI.chromeWin) {
       StartUI.chromeWin.removeEventListener('MozAppbarDismissing', this, false);
     }
     View.prototype.destruct.call(this);
   },
 
-  handleItemClick: function tabview_handleItemClick(aItem) {
+  handleItemClick: function(aItem) {
     let url = aItem.getAttribute("value");
     StartUI.goToURI(url);
   },
 
   doActionOnSelectedTiles: function(aActionName, aEvent) {
     let tileGroup = this._set;
     let selectedTiles = tileGroup.selectedItems;
     let sites = Array.map(selectedTiles, TopSites._linkFromNode);
@@ -183,17 +183,17 @@ TopSitesView.prototype = Util.extend(Obj
     if (aTileNode.refresh) {
       aTileNode.refresh();
     }
     if (aArrangeGrid) {
       this._set.arrangeItems();
     }
   },
 
-  populateGrid: function populateGrid() {
+  populateGrid: function() {
     this.isUpdating = true;
 
     let sites = TopSites.getSites();
 
     let tileset = this._set;
     tileset.clearAll(true);
 
     if (!this.maxTiles) {
@@ -206,30 +206,30 @@ TopSitesView.prototype = Util.extend(Obj
     for (let site of sites) {
       let slot = tileset.nextSlot();
       this.updateTile(slot, site);
     }
     tileset.arrangeItems();
     this.isUpdating = false;
   },
 
-  forceReloadOfThumbnail: function forceReloadOfThumbnail(url) {
+  forceReloadOfThumbnail: function(url) {
     let nodes = this._set.querySelectorAll('richgriditem[value="'+url+'"]');
     for (let item of nodes) {
       if ("isBound" in item && item.isBound) {
         item.refreshBackgroundImage();
       }
     }
   },
 
-  isFirstRun: function isFirstRun() {
+  isFirstRun: function() {
     return Services.prefs.getBoolPref("browser.firstrun.show.localepicker");
   },
 
-  _adjustDOMforViewState: function _adjustDOMforViewState(aState) {
+  _adjustDOMforViewState: function(aState) {
     if (!this._set)
       return;
     if (!aState)
       aState = this._set.getAttribute("viewstate");
 
     View.prototype._adjustDOMforViewState.call(this, aState);
 
     // Don't show thumbnails in snapped view.
@@ -302,19 +302,19 @@ TopSitesView.prototype = Util.extend(Obj
   }
 
 });
 
 let TopSitesStartView = {
   _view: null,
   get _grid() { return document.getElementById("start-topsites-grid"); },
 
-  init: function init() {
+  init: function() {
     this._view = new TopSitesView(this._grid);
     this._grid.removeAttribute("fade");
   },
 
-  uninit: function uninit() {
+  uninit: function() {
     if (this._view) {
       this._view.destruct();
     }
   },
 };
diff --git a/browser/metro/base/tests/mochiperf/browser_apzc.js b/browser/metro/base/tests/mochiperf/browser_apzc.js
--- a/browser/metro/base/tests/mochiperf/browser_apzc.js
+++ b/browser/metro/base/tests/mochiperf/browser_apzc.js
@@ -37,17 +37,17 @@ function tearDown() {
 /*
  * short up/down touch scroll. This test isn't affected by
  * skate or stationary apzc prefs provided the display port
  * is twice the height of the screen. Measures apzc/composition
  * perf since the display port (should) only render once.
  */
 gTests.push({
   desc: "short up/down touch scroll",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/scroll_test.html");
     yield hideContextUI();
     yield hideNavBar();
 
     let stopwatch = new StopWatch();
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     var touchdrag = new TouchDragAndHold();
@@ -75,17 +75,17 @@ gTests.push({
 });
 
 /*
  * Long scroll a page of text, which will include repainting
  * content.
  */
 gTests.push({
   desc: "touch scroll",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/scroll_test_tall.html");
     yield hideContextUI();
     yield hideNavBar();
 
     let stopwatch = new StopWatch();
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     var touchdrag = new TouchDragAndHold();
@@ -112,17 +112,17 @@ gTests.push({
 
 /*
  * Fling a page of text downward over a set of iterations
  * taking measurements for each fling. Content will repaint
  * and includes measurements that cover fling logic/prefs.
  */
 gTests.push({
   desc: "fling scroll",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/scroll_test_tall.html");
     yield hideContextUI();
     yield hideNavBar();
 
     let stopwatch = new StopWatch();
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     var touchdrag = new TouchDragAndHold();
@@ -181,17 +181,17 @@ gTests.push({
  * touch scroll the about:start page back and forth averaging
  * values across the entire set. Generally about:start should
  * only need to be painted once. Exercises composition and apzc.
  */
 gTests.push({
   desc: "touch scroll start",
   setUp: setup,
   tearDown: tearDown,
-  run: function run() {
+  run: function() {
     let stopwatch = new StopWatch();
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
 
     var touchdrag = new TouchDragAndHold();
     touchdrag.useNativeEvents = true;
     touchdrag.stepTimeout = 5;
     touchdrag.numSteps = 20;
diff --git a/browser/metro/base/tests/mochiperf/browser_deck_01.js b/browser/metro/base/tests/mochiperf/browser_deck_01.js
--- a/browser/metro/base/tests/mochiperf/browser_deck_01.js
+++ b/browser/metro/base/tests/mochiperf/browser_deck_01.js
@@ -4,17 +4,17 @@
 "use strict";
 
 function test() {
   runTests();
 }
 
 gTests.push({
   desc: "deck offset",
-  run: function run() {
+  run: function() {
     yield addTab("about:mozilla");
     yield hideContextUI();
     yield hideNavBar();
     yield waitForMs(3000);
 
     let shiftDataSet = new Array();
     let paintDataSet = new Array();
     let stopwatch = new StopWatch();
diff --git a/browser/metro/base/tests/mochiperf/browser_firstx.js b/browser/metro/base/tests/mochiperf/browser_firstx.js
--- a/browser/metro/base/tests/mochiperf/browser_firstx.js
+++ b/browser/metro/base/tests/mochiperf/browser_firstx.js
@@ -4,17 +4,17 @@
 "use strict";
 
 function test() {
   runTests();
 }
 
 gTests.push({
   desc: "first x metrics",
-  run: function run() {
+  run: function() {
     PerfTest.declareTest("5F2A456E-2BB2-4073-A751-936F222FEAE0",
                          "startup perf metrics", "browser", "ux",
                          "Tracks various metrics reported by nsIAppStartup.getStartupInfo(). Values are in msec.");
 
     let startup = Cc["@mozilla.org/toolkit/app-startup;1"].getService(Ci.nsIAppStartup).getStartupInfo();
     PerfTest.declareNumericalResults([
       { value: startup['start'] - startup.process, desc: "start" },
       { value: startup['main'] - startup.process, desc: "main", shareAxis: 0 },
diff --git a/browser/metro/base/tests/mochiperf/browser_layers_01.js b/browser/metro/base/tests/mochiperf/browser_layers_01.js
--- a/browser/metro/base/tests/mochiperf/browser_layers_01.js
+++ b/browser/metro/base/tests/mochiperf/browser_layers_01.js
@@ -4,17 +4,17 @@
 "use strict";
 
 function test() {
   runTests();
 }
 
 gTests.push({
   desc: "rotating divs",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/divs_test.html", true);
     yield hideContextUI();
     yield hideNavBar();
 
     let stopwatch = new StopWatch();
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     yield waitForEvent(win, "teststarted", 5000);
diff --git a/browser/metro/base/tests/mochiperf/browser_miscgfx_01.js b/browser/metro/base/tests/mochiperf/browser_miscgfx_01.js
--- a/browser/metro/base/tests/mochiperf/browser_miscgfx_01.js
+++ b/browser/metro/base/tests/mochiperf/browser_miscgfx_01.js
@@ -10,17 +10,17 @@ function test() {
 
 function tapRadius() {
   let dpi = Util.displayDPI;
   return Services.prefs.getIntPref("ui.dragThresholdX") / 240 * dpi; // 27.999998728434246
 }
 
 gTests.push({
   desc: "scrollBy",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/scroll_test.html");
     yield hideContextUI();
     yield hideNavBar();
 
     let stopwatch = new StopWatch();
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     let deferExit = Promise.defer();
@@ -45,17 +45,17 @@ gTests.push({
     stopwatch.start();
     win.mozRequestAnimationFrame(step);
     yield deferExit.promise;
   }
 });
 
 gTests.push({
   desc: "canvas perf test",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/ripples.html");
     yield hideContextUI();
     yield hideNavBar();
 
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     let recordingHandle = domUtils.startFrameTimeRecording();
     PerfTest.declareTest("6A455F96-2B2C-4B3C-B387-1AF2F1747CCF",
@@ -68,17 +68,17 @@ gTests.push({
     let intervals = domUtils.stopFrameTimeRecording(recordingHandle);
     let msec = stopwatch.stop();
     PerfTest.declareFrameRateResult(intervals.length, msec, "fps");
   }
 });
 
 gTests.push({
   desc: "video perf test",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/tidevideo.html");
     let win = Browser.selectedTab.browser.contentWindow;
     let domUtils = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
     let video = win.document.getElementById("videoelement");
     video.pause();
     yield hideContextUI();
     yield hideNavBar();
     yield waitForMs(1000);
diff --git a/browser/metro/base/tests/mochiperf/browser_msgmgr_01.js b/browser/metro/base/tests/mochiperf/browser_msgmgr_01.js
--- a/browser/metro/base/tests/mochiperf/browser_msgmgr_01.js
+++ b/browser/metro/base/tests/mochiperf/browser_msgmgr_01.js
@@ -7,43 +7,43 @@ function test() {
   runTests();
 }
 
 var EchoServer = {
   _deferred: null,
   _stopwatch: null,
   _browser: null,
 
-  timeAsyncMessage: function timeAsyncMessage(aJson) {
+  timeAsyncMessage: function(aJson) {
     if (this._stopwatch == null) {
       this._stopwatch = new StopWatch(false);
     }
     this._deferred = Promise.defer();
     messageManager.addMessageListener("Test:EchoResponse", this);
     this._stopwatch.start();
     this._browser.messageManager.sendAsyncMessage("Test:EchoRequest", aJson);
     return this._deferred.promise;
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let json = aMessage.json;
     switch (aMessage.name) {
       case "Test:EchoResponse":
         let msec = this._stopwatch.stop();
         messageManager.removeMessageListener("Test:EchoResponse", this);
         this._deferred.resolve(msec);
         break;
     }
   },
 };
 
 
 gTests.push({
   desc: "msg manager 1",
-  run: function run() {
+  run: function() {
     yield addTab("about:blank");
     yield hideContextUI();
 
     let browser = Browser.selectedTab.browser;
     EchoServer._browser = browser;
 
     browser.messageManager.loadFrameScript(chromeRoot + "msgmanagerecho.js", true);
 
@@ -62,17 +62,17 @@ gTests.push({
                          "Browser displays about:blank during the test.");
     let result = PerfTest.computeAverage(openDataSet, { stripOutliers: false });
     PerfTest.declareNumericalResult(result, "msec");
   }
 });
 
 gTests.push({
   desc: "msg manager 1",
-  run: function run() {
+  run: function() {
     yield addTab("about:blank");
     yield hideContextUI();
 
     let browser = Browser.selectedTab.browser;
     EchoServer._browser = browser;
 
     browser.messageManager.loadFrameScript(chromeRoot + "msgmanagerecho.js", true);
 
@@ -101,17 +101,17 @@ gTests.push({
                          "Browser displays about:blank during the test.");
     let result = PerfTest.computeAverage(openDataSet, { stripOutliers: false });
     PerfTest.declareNumericalResult(result, "msec");
   }
 });
 
 gTests.push({
   desc: "msg manager 3",
-  run: function run() {
+  run: function() {
     yield addTab(chromeRoot + "res/ripples.html");
     yield hideContextUI();
 
     let browser = Browser.selectedTab.browser;
     EchoServer._browser = browser;
 
     browser.messageManager.loadFrameScript(chromeRoot + "msgmanagerecho.js", true);
 
diff --git a/browser/metro/base/tests/mochiperf/browser_tabs_01.js b/browser/metro/base/tests/mochiperf/browser_tabs_01.js
--- a/browser/metro/base/tests/mochiperf/browser_tabs_01.js
+++ b/browser/metro/base/tests/mochiperf/browser_tabs_01.js
@@ -16,17 +16,17 @@ function timeTab(aUrl) {
     Browser.closeTab(tab, { forceClose: true })
     yield waitForMs(500);
     throw new Task.Result(stopwatch.time());
   });
 }
 
 gTests.push({
   desc: "tab open",
-  run: function run() {
+  run: function() {
     yield addTab("about:blank");
     yield hideContextUI();
     yield waitForMs(5000);
 
     let openDataSet = new Array();
     for (let idx = 0; idx < 20; idx++) {
       let time = yield timeTab("about:blank");
       openDataSet.push(time);
diff --git a/browser/metro/base/tests/mochiperf/head.js b/browser/metro/base/tests/mochiperf/head.js
--- a/browser/metro/base/tests/mochiperf/head.js
+++ b/browser/metro/base/tests/mochiperf/head.js
@@ -37,17 +37,17 @@ var PerfTest = {
    * @param aUUID string for this particular test, case sensitive.
    * @param aName The name of the test.
    * @param aCategory Top level test calegory. For example 'General',
    * 'Graphics', 'Startup', 'Jim's Tests'.
    * @param aSubCategory (optional) sub category name with aCategory.
    * @param aDescription A detailed description (sentence or two) of
    * what the test does.
    */
-  declareTest: function declareTest(aUUID, aName, aCategory, aSubCategory, aDescription) {
+  declareTest: function(aUUID, aName, aCategory, aSubCategory, aDescription) {
     this._uid = aUUID;
     this._print(kDeclareId, this._toJsonStr({
       id: aUUID,
       version: kDataSetVersion,
       name: aName,
       category: aCategory,
       subcategory: aSubCategory,
       description: aDescription,
@@ -58,17 +58,17 @@ var PerfTest = {
   /*
    * declareNumericalResult
    *
    * Declare a simple numerical result.
    *
    * @param aValue numerical value to record
    * @param aDescription string describing the value to display on the y axis.
    */
-  declareNumericalResult: function declareNumericalResult(aValue, aDescription) {
+  declareNumericalResult: function(aValue, aDescription) {
     this._print(kResultsId, this._toJsonStr({
       id: this._uid,
       version: kDataSetVersion,
       results: {
         r0: {
           value: aValue,
           desc: aDescription
         }
@@ -80,17 +80,17 @@ var PerfTest = {
    * declareFrameRateResult
    *
    * Declare a frame rate for a result.
    *
    * @param aFrameCount numerical frame count
    * @param aRunMs run time in miliseconds
    * @param aDescription string describing the value to display on the y axis.
    */
-  declareFrameRateResult: function declareFrameRateResult(aFrameCount, aRunMs, aDescription) {
+  declareFrameRateResult: function(aFrameCount, aRunMs, aDescription) {
     this._print(kResultsId, this._toJsonStr({
       id: this._uid,
       version: kDataSetVersion,
       results: {
         r0: {
           value: (aFrameCount / (aRunMs / 1000.0)),
           desc: aDescription
         }
@@ -106,17 +106,17 @@ var PerfTest = {
    * @param aArray an array of datapoint objects of the form:
    *
    *  [ { value: (value), desc: "description/units" }, .. ]
    *
    *  optional values:
    *    shareAxis - the 0 based index of a previous data point this point
    *    should share a y axis with.
    */
-  declareNumericalResults: function declareNumericalResults(aArray) {
+  declareNumericalResults: function(aArray) {
     let collection = new Object();
     for (let idx = 0; idx < aArray.length; idx++) {
       collection['r' + idx] = { value: aArray[idx].value, desc: aArray[idx].desc };
       if (aArray[idx].shareAxis != undefined) {
         collection['r' + idx].shareAxis = aArray[idx].shareAxis;
       }
     }
     let dataset = {
@@ -126,39 +126,39 @@ var PerfTest = {
     };
     this._print(kResultsId, this._toJsonStr(dataset));
   },
 
   /******************************************************
    * Perf tests
    */
 
-  perfBoundsCheck: function perfBoundsCheck(aLow, aHigh, aValue, aTestMessage) {
+  perfBoundsCheck: function(aLow, aHigh, aValue, aTestMessage) {
     ok(aValue < aLow || aValue > aHigh, aTestMessage);
   },
 
   /******************************************************
    * Math utilities
    */
 
-  computeMedian: function computeMedian(aArray, aOptions) {
+  computeMedian: function(aArray, aOptions) {
     aArray.sort(function (a, b) {
       return a - b;
     });
  
     var idx = Math.floor(aArray.length / 2);
  
     if(aArray.length % 2) {
         return aArray[idx];
     } else {
         return (aArray[idx-1] + aArray[idx]) / 2;
     }
   },
 
-  computeAverage: function computeAverage(aArray, aOptions) {
+  computeAverage: function(aArray, aOptions) {
     let idx;
     let count = 0, total = 0;
     let highIdx = -1, lowIdx = -1;
     let high = 0, low = 0;
     if (aOptions.stripOutliers) {
       for (idx = 0; idx < aArray.length; idx++) {
         if (high < aArray[idx]) {
           highIdx = idx;
@@ -174,23 +174,23 @@ var PerfTest = {
       if (idx != high && idx != low) {
         total += aArray[idx];
         count++;
       }
     }
     return total / count;
   },
 
-  computeHighLowBands: function computeHighLow(aArray, aPercentage) {
+  computeHighLowBands: function(aArray, aPercentage) {
     let bandCount = Math.ceil(aArray.length * aPercentage);
     let lowGroup = 0, highGroup = 0;
     let idx;
 
-    function compareNumbers(a, b) {
-      return a - b;
+    function compareNumbers(a, b) {
+      return a - b;
     }
     aArray.sort(compareNumbers);
     for (idx = 0; idx < bandCount; idx++) {
       lowGroup += aArray[idx];
     }
     let top = aArray.length - 1;
     for (idx = top; idx > (top - bandCount); idx--) {
       highGroup += aArray[idx];
@@ -201,25 +201,25 @@ var PerfTest = {
       ave: this.computeAverage(aArray, {})
     };
   },
 
   /******************************************************
    * Internal
    */
 
-  _print: function _print() {
+  _print: function() {
     let str = kInfoHeader;
     for (let idx = 0; idx < arguments.length; idx++) {
       str += arguments[idx];
     }
     info(str);
   },
 
-  _toJsonStr: function _toJsonStr(aTable) {
+  _toJsonStr: function(aTable) {
     return window.JSON.stringify(aTable);
   },
 };
 
 /*
  * StopWatch - timing helper
  */
 
@@ -228,41 +228,41 @@ function StopWatch(aStart) {
     this.start();
   }
 }
 
 StopWatch.prototype = {
   /*
    * Start timing. Resets existing clock.
    */
-  start: function start() {
+  start: function() {
     this.reset();
     this._userStartTime = window.performance.now();
   },
 
   /*
    * Stop timing.
    */
-  stop: function stop() {
+  stop: function() {
     this._userStopTime = window.performance.now();
     return this.time();
   },
 
   /*
    * Resets both start and end time.
    */
-  reset: function reset() {
+  reset: function() {
     this._userStartTime = this._userStopTime = 0;
   },
 
   /*
    * Returns the total time ellapsed in milliseconds. Returns zero if
    * no time has been accumulated.
    */
-  time: function time() {
+  time: function() {
     if (!this._userStartTime) {
       return 0;
     }
     if (!this._userStopTime) {
       return (window.performance.now() - this._userStartTime);
     }
     return this._userStopTime - this._userStartTime;
   },
diff --git a/browser/metro/base/tests/mochiperf/msgmanagerecho.js b/browser/metro/base/tests/mochiperf/msgmanagerecho.js
--- a/browser/metro/base/tests/mochiperf/msgmanagerecho.js
+++ b/browser/metro/base/tests/mochiperf/msgmanagerecho.js
@@ -4,21 +4,21 @@
 
 /*
  * TestEchoReceiver - receives json data, reserializes it and send it back.
  */ 
 
 "use strict";
 
 var TestEchoReceiver = {
-  init: function init() {
+  init: function() {
     addMessageListener("Test:EchoRequest", this);
   },
 
-  receiveMessage: function receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let json = aMessage.json;
     switch (aMessage.name) {
       case "Test:EchoRequest":
         sendAsyncMessage("Test:EchoResponse", json);
         break;
     }
   },
 
diff --git a/browser/metro/base/tests/mochitest/browser_bookmarks.js b/browser/metro/base/tests/mochitest/browser_bookmarks.js
--- a/browser/metro/base/tests/mochitest/browser_bookmarks.js
+++ b/browser/metro/base/tests/mochitest/browser_bookmarks.js
@@ -30,17 +30,17 @@ function tearDown() {
   PanelUI.hide();
   BookmarksTestHelper.restore();
 }
 
 gTests.push({
   desc: "Test bookmarks StartUI hide",
   setUp: setup,
   tearDown: tearDown,
-  run: function testBookmarksStartHide() {
+  run: function() {
     let hideButton = document.getElementById("hide-selected-button");
 
     // --------- hide item 2
 
     let item = gStartView._getItemForBookmarkId(2);
 
     let promise = waitForEvent(Elements.contextappbar, "transitionend", null, Elements.contextappbar);
     sendContextMenuClickToElement(window, item, 10, 10);
@@ -85,17 +85,17 @@ gTests.push({
     ok(gStartView._set.itemCount === gStartView.maxTiles - 1, "Grid repopulated");
   }
 });
 
 gTests.push({
   desc: "Test bookmarks StartUI delete",
   setUp: setup,
   tearDown: tearDown,
-  run: function testBookmarksStartDelete() {
+  run: function() {
     let restoreButton = document.getElementById("restore-selected-button");
     let deleteButton = document.getElementById("delete-selected-button");
 
     // --------- delete item 2 and restore
 
     let item = gStartView._getItemForBookmarkId(2);
     let initialLocation = gStartView._set.getIndexOfItem(item);
 
diff --git a/browser/metro/base/tests/mochitest/browser_colorUtils.js b/browser/metro/base/tests/mochitest/browser_colorUtils.js
--- a/browser/metro/base/tests/mochitest/browser_colorUtils.js
+++ b/browser/metro/base/tests/mochitest/browser_colorUtils.js
@@ -25,17 +25,17 @@ gTests.push({
     });
     // add a fresh cache entry
     ColorUtils.iconColorCache.set('http://test.new/favicon.ico', {
       "foreground":"rgb(255,255,255)",
       "background":"rgb(78,78,84)",
       "timestamp":Date.now()
     });
   },
-  run: function testIconColorCachePurge() {
+  run: function() {
     let dayMs = 86400000;
     let ColorUtils = this.ColorUtils;
     let cachePurgeSpy = spyOnMethod(ColorUtils.iconColorCache, 'purge');
 
     // notify observers, indicating a day has passed since last notification
     Services.obs.notifyObservers(null, "idle-daily", dayMs);
     is(cachePurgeSpy.callCount, 1);
     cachePurgeSpy.restore();
diff --git a/browser/metro/base/tests/mochitest/browser_context_menu_tests.js b/browser/metro/base/tests/mochitest/browser_context_menu_tests.js
--- a/browser/metro/base/tests/mochitest/browser_context_menu_tests.js
+++ b/browser/metro/base/tests/mochitest/browser_context_menu_tests.js
@@ -25,17 +25,17 @@ function checkContextMenuPositionRange(a
     "Left position is " + aElement.left + ", expected between " + aMinLeft + " and " + aMaxLeft);
 
   ok(aElement.top > aMinTop && aElement.top < aMaxTop,
     "Top position is " + aElement.top + ", expected between " + aMinTop + " and " + aMaxTop);
 }
 
 gTests.push({
   desc: "text context menu",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_02.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_02.html");
 
     purgeEventQueue();
     emptyClipboard();
 
     let win = Browser.selectedTab.browser.contentWindow;
 
@@ -302,17 +302,17 @@ gTests.push({
 
     Browser.closeTab(Browser.selectedTab, { forceClose: true });
     purgeEventQueue();
   }
 });
 
 gTests.push({
   desc: "checks for context menu positioning when browser shifts",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_02.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_02.html");
 
     purgeEventQueue();
     emptyClipboard();
 
     let browserwin = Browser.selectedTab.browser.contentWindow;
 
@@ -360,26 +360,26 @@ var observeLogger = {
   QueryInterface: function (aIID) {
     if (!aIID.equals(Ci.nsIObserver) &&
         !aIID.equals(Ci.nsISupportsWeakReference) &&
         !aIID.equals(Ci.nsISupports)) {
       throw Components.results.NS_ERROR_NO_INTERFACE;
     }
     return this;
   },
-  init: function init() {
+  init: function() {
     Services.obs.addObserver(observeLogger, "dl-start", true);
     Services.obs.addObserver(observeLogger, "dl-done", true);
     Services.obs.addObserver(observeLogger, "dl-failed", true);
     Services.obs.addObserver(observeLogger, "dl-scanning", true);
     Services.obs.addObserver(observeLogger, "dl-blocked", true);
     Services.obs.addObserver(observeLogger, "dl-dirty", true);
     Services.obs.addObserver(observeLogger, "dl-cancel", true);
   },
-  shutdown: function shutdown() {
+  shutdown: function() {
     Services.obs.removeObserver(observeLogger, "dl-start");
     Services.obs.removeObserver(observeLogger, "dl-done");
     Services.obs.removeObserver(observeLogger, "dl-failed");
     Services.obs.removeObserver(observeLogger, "dl-scanning");
     Services.obs.removeObserver(observeLogger, "dl-blocked");
     Services.obs.removeObserver(observeLogger, "dl-dirty");
     Services.obs.removeObserver(observeLogger, "dl-cancel");
   }
@@ -392,17 +392,17 @@ gTests.push({
   setUp: function() {
     // XXX code used to diagnose bug 880739
     //observeLogger.init();
   },
   tearDown: function() {
     // XXX code used to diagnose bug 880739
     //observeLogger.shutdown();
   },
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_01.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_01.html");
 
     let win = Browser.selectedTab.browser.contentWindow;
 
     purgeEventQueue();
 
     yield hideContextUI();
@@ -540,17 +540,17 @@ gTests.push({
     ok(imagetab != null, "tab created");
 
     Browser.closeTab(imagetab, { forceClose: true });
   }
 });
 
 gTests.push({
   desc: "tests for subframe positioning",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_03.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_03.html");
 
     let win = Browser.selectedTab.browser.contentWindow;
 
     // Sometimes the context ui is visible, sometimes it isn't.
     try {
       yield waitForCondition(function () {
@@ -707,17 +707,17 @@ gTests.push({
   setUp: reopenSetUp,
   tearDown: reopenTearDown,
   run: getReopenTest(sendContextMenuClickToElement, sendTap)
 });
 
 gTests.push({
   desc: "Bug 947505 - Right-click in a designMode document should display a " +
         "context menu",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_02.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_02.html");
 
     purgeEventQueue();
     emptyClipboard();
     ContextUI.dismiss();
 
     yield waitForCondition(() => !ContextUI.navbarVisible);
@@ -786,17 +786,17 @@ gTests.push({
     Browser.closeTab(Browser.selectedTab, { forceClose: true });
   }
 });
 
 gTests.push({
   desc: "Bug 961702 - 'Copy' context menu action does not copy rich content " +
         "while document in design mode (or inside container that allows to " +
         "edit its content)",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_05.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_05.html");
 
     purgeEventQueue();
     emptyClipboard();
     ContextUI.dismiss();
 
     yield waitForCondition(() => !ContextUI.navbarVisible);
@@ -872,17 +872,17 @@ gTests.push({
 
     Browser.closeTab(Browser.selectedTab, { forceClose: true });
   }
 });
 
 gTests.push({
   desc: "Bug 963067 - 'Cut' in the cut, copy, paste menu is always active " +
         "after a browser launch.",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_02.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_02.html");
 
     purgeEventQueue();
     emptyClipboard();
 
     ContextUI.dismiss();
     yield waitForCondition(() => !ContextUI.navbarVisible);
@@ -909,17 +909,17 @@ gTests.push({
 
     Browser.closeTab(Browser.selectedTab, { forceClose: true });
   }
 });
 
 gTests.push({
   desc: "Bug 867499 - Selecting 'copy' from context menu for selected text " +
         "dismisses selection.",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_context_menu_tests_02.html");
     yield addTab(chromeRoot + "browser_context_menu_tests_02.html");
 
     emptyClipboard();
     ContextUI.dismiss();
 
     yield waitForCondition(() => !ContextUI.navbarVisible);
 
diff --git a/browser/metro/base/tests/mochitest/browser_context_ui.js b/browser/metro/base/tests/mochitest/browser_context_ui.js
--- a/browser/metro/base/tests/mochitest/browser_context_ui.js
+++ b/browser/metro/base/tests/mochitest/browser_context_ui.js
@@ -23,17 +23,17 @@ function fireTabURLChanged(tab, hasLocat
 }
 
 function getpage(idx) {
   return "http://mochi.test:8888/metro/browser/metro/base/tests/mochitest/" + "res/blankpage" + idx + ".html";
 }
 
 gTests.push({
   desc: "Context UI on about:start",
-  run: function testAboutStart() {
+  run: function() {
     let tab = yield addTab("about:start");
 
     yield waitForCondition(function () {
       return BrowserUI.isStartTabVisible;
       });
 
     is(BrowserUI.isStartTabVisible, true, "Start UI is displayed on about:start");
     is(ContextUI.navbarVisible, true, "Navbar is displayed on about:start");
@@ -61,17 +61,17 @@ gTests.push({
     is(BrowserUI.isStartTabVisible, true, "Start UI is still visible");
 
     Browser.closeTab(tab, { forceClose: true });
   }
 });
 
 gTests.push({
   desc: "Context UI on a web page (about:)",
-  run: function testAbout() {
+  run: function() {
     let tab = yield addTab("about:");
     ContextUI.dismiss();
     is(BrowserUI.isStartTabVisible, false, "Start UI is not visible on about:");
     is(ContextUI.navbarVisible, false, "Navbar is not initially visible on about:");
     is(ContextUI.tabbarVisible, false, "Tabbar is not initially visible on about:");
 
     doEdgeUIGesture();
     is(ContextUI.navbarVisible, true, "Navbar is visible after one swipe");
@@ -84,17 +84,17 @@ gTests.push({
     is(BrowserUI.isStartTabVisible, false, "Start UI is still not visible");
 
     Browser.closeTab(tab, { forceClose: true });
   }
 });
 
 gTests.push({
   desc: "Control-L keyboard shortcut",
-  run: function testAbout() {
+  run: function() {
     let tab = yield addTab("about:");
     ContextUI.dismiss();
     is(ContextUI.navbarVisible, false, "Navbar is not initially visible");
     is(ContextUI.tabbarVisible, false, "Tab bar is not initially visible");
 
     EventUtils.synthesizeKey('l', { accelKey: true });
     is(ContextUI.navbarVisible, true, "Navbar is visible");
     is(ContextUI.tabbarVisible, false, "Tab bar is not visible");
diff --git a/browser/metro/base/tests/mochitest/browser_history.js b/browser/metro/base/tests/mochitest/browser_history.js
--- a/browser/metro/base/tests/mochitest/browser_history.js
+++ b/browser/metro/base/tests/mochitest/browser_history.js
@@ -41,17 +41,17 @@ function tearDown() {
 function uriFromIndex(aIndex) {
   return "http://mock-history-" + aIndex + ".com.br/"
 }
 
 gTests.push({
   desc: "Test history StartUI hide",
   setUp: setup,
   tearDown: tearDown,
-  run: function testHistoryStartHide() {
+  run: function() {
     let hideButton = document.getElementById("hide-selected-button");
 
     // --------- hide item 2
 
     let item = gStartView._set.getItemsByUrl(uriFromIndex(2))[0];
 
     let promise = waitForEvent(Elements.contextappbar, "transitionend", null, Elements.contextappbar);
     sendContextMenuClickToElement(window, item, 10, 10);
@@ -97,17 +97,17 @@ gTests.push({
     ok(gStartView._set.itemCount === gStartView.maxTiles - 1, "Grid repopulated");
   }
 });
 
 gTests.push({
   desc: "Test history StartUI delete",
   setUp: setup,
   tearDown: tearDown,
-  run: function testHistoryStartDelete() {
+  run: function() {
     let restoreButton = document.getElementById("restore-selected-button");
     let deleteButton = document.getElementById("delete-selected-button");
 
     // --------- delete item 2 and restore
 
     let item = gStartView._set.getItemsByUrl(uriFromIndex(2))[0];
     let initialLocation = gStartView._set.getIndexOfItem(item);
 
diff --git a/browser/metro/base/tests/mochitest/browser_prefs_ui.js b/browser/metro/base/tests/mochitest/browser_prefs_ui.js
--- a/browser/metro/base/tests/mochitest/browser_prefs_ui.js
+++ b/browser/metro/base/tests/mochitest/browser_prefs_ui.js
@@ -30,38 +30,38 @@ let newFactory = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIFactory])
 };
 
 var SanitizeHelper = {
   _originalSanitizer: null,
 
   MockSanitizer: {
     clearCalled: [],
-    clearItem: function clearItem(aItemName) {
+    clearItem: function(aItemName) {
       info("Clear item called for: " + aItemName);
       this.clearCalled.push(aItemName);
     }
   },
 
-  setUp: function setUp() {
+  setUp: function() {
     SanitizeHelper._originalSanitizer = SanitizeUI._sanitizer;
     SanitizeUI._sanitizer = SanitizeHelper.MockSanitizer;
 
     let registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     this.gAppInfoClassID = registrar.contractIDToCID(CONTRACT_ID);
     this.gIncOldFactory = Cm.getClassObject(Cc[CONTRACT_ID], Ci.nsIFactory);
     registrar.unregisterFactory(this.gAppInfoClassID, this.gIncOldFactory);
     let components = [MockAppInfo];
     registrar.registerFactory(this.gAppInfoClassID, "", CONTRACT_ID, newFactory);
     this.gIncOldFactory = Cm.getClassObject(Cc[CONTRACT_ID], Ci.nsIFactory);
 
     this.oldPrompt = Services.prompt;
   },
 
-  tearDown: function tearDown() {
+  tearDown: function() {
     SanitizeUI._sanitizer = SanitizeHelper._originalSanitizer;
 
     if (this.gIncOldFactory) {
       var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
       registrar.unregisterFactory(this.gAppInfoClassID, newFactory);
       registrar.registerFactory(this.gAppInfoClassID, "", CONTRACT_ID, this.gIncOldFactory);
     }
     this.gIncOldFactory = null;
@@ -75,17 +75,17 @@ function getAllSelected() {
     "#prefs-privdata-history[checked], " +
       "#prefs-privdata-other[checked] + #prefs-privdata-subitems .privdata-subitem-item[checked]");
 }
 
 gTests.push({
   setUp: SanitizeHelper.setUp,
   tearDown: SanitizeHelper.tearDown,
   desc: "Test sanitizer UI",
-  run: function testSanitizeUI() {
+  run: function() {
     // We want to be able to simulate that a specific button
     // of the 'clear private data' prompt was pressed.
     Services.prompt = {
       confirmEx: function() {
         return this.retVal;
       }
     };
 
@@ -169,17 +169,17 @@ function checkDNTPrefs(aExpectedEnabled,
   let valueTestMsg = "testing privacy.donottrackheader.value, expected "
     + aExpectedValue + " got " + currentValue;
 
   ok(aExpectedValue === currentValue, valueTestMsg);
 }
 
 gTests.push({
   desc: "Test do not track settings",
-  run: function testDNT() {
+  run: function() {
     let noTrack = document.getElementById("prefs-dnt-notrack");
     let noPref = document.getElementById("prefs-dnt-nopref");
     let okTrack = document.getElementById("prefs-dnt-oktrack");
 
     // Show options flyout
     let promise = waitForEvent(FlyoutPanelsUI.PrefsFlyoutPanel._topmostElement, "PopupChanged", 2000);
     FlyoutPanelsUI.show('PrefsFlyoutPanel');
     yield promise;
diff --git a/browser/metro/base/tests/mochitest/browser_remotetabs.js b/browser/metro/base/tests/mochitest/browser_remotetabs.js
--- a/browser/metro/base/tests/mochitest/browser_remotetabs.js
+++ b/browser/metro/base/tests/mochitest/browser_remotetabs.js
@@ -12,17 +12,17 @@ Components.utils.import("resource://serv
 //// Test(s)
 
 function test() {
   runTests();
 }
 
 gTests.push({
   desc: "Test sync tabs from other devices UI",
-  run: function run() {
+  run: function() {
     if (BrowserUI.isStartTabVisible)
       return;
 
     yield addTab("about:start");
     yield waitForCondition(() => BrowserUI.isStartTabVisible);
     yield hideContextUI();
 
     is(Weave.Status.checkSetup(), Weave.CLIENT_NOT_CONFIGURED, "Sync should be disabled on start");
diff --git a/browser/metro/base/tests/mochitest/browser_selection_basic.js b/browser/metro/base/tests/mochitest/browser_selection_basic.js
--- a/browser/metro/base/tests/mochitest/browser_selection_basic.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_basic.js
@@ -28,17 +28,17 @@ function setUpAndTearDown() {
   InputSourceHelper.isPrecise = false;
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_basic.html");
     yield addTab(chromeRoot + "browser_selection_basic.html");
 
     yield waitForCondition(function () {
         return !BrowserUI.isStartTabVisible;
       }, 10000, 100);
 
     yield hideContextUI();
@@ -46,32 +46,32 @@ gTests.push({
     gWindow = Browser.selectedTab.browser.contentWindow;
   },
 });
 
 gTests.push({
   desc: "tap-hold to select",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     sendContextMenuClick(30, 20);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     is(getTrimmedSelection(gWindow).toString(), "There", "selection test");
   },
 });
 
 gTests.push({
   desc: "appbar interactions",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     sendContextMenuClick(100, 20);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     is(SelectionHelperUI.isActive, true, "selection active");
     is(getTrimmedSelection(gWindow).toString(), "nothing", "selection test");
@@ -85,17 +85,17 @@ gTests.push({
     ok(!ContextUI.isVisible, true, "appbar hidden");
   },
 });
 
 gTests.push({
   desc: "simple drag selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     yield waitForMs(100);
     sendContextMenuClick(100, 20);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     is(SelectionHelperUI.isActive, true, "selection active");
@@ -116,17 +116,17 @@ gTests.push({
     is(getTrimmedSelection(gWindow).toString(), "nothing so VERY", "selection test");
   },
 });
 
 gTests.push({
   desc: "expand / collapse selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     sendContextMenuClick(30, 20);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     is(SelectionHelperUI.isActive, true, "initial active");
     is(getTrimmedSelection(gWindow).toString(), "There", "initial selection test");
@@ -162,17 +162,17 @@ gTests.push({
       is(getTrimmedSelection(gWindow).toString(), "There was", "short selection test");
     }
   },
 });
 
 gTests.push({
   desc: "expand / collapse selection scolled content",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     let scrollPromise = waitForEvent(gWindow, "scroll");
     gWindow.scrollBy(0, 200);
     yield scrollPromise;
     ok(scrollPromise && !(scrollPromise instanceof Error), "scrollPromise error");
 
     sendContextMenuClick(106, 20);
 
     yield waitForCondition(function () {
@@ -231,17 +231,17 @@ gTests.push({
         return !SelectionHelperUI.hasActiveDrag;
       }, kCommonWaitMs, kCommonPollMs);
     yield SelectionHelperUI.pingSelectionHandler();
 
     is(getTrimmedSelection(gWindow).toString(),
       "moment down went",
       "selection test");
   },
-  tearDown: function tearDown() {
+  tearDown: function() {
     let scrollPromise = waitForEvent(gWindow, "scroll");
     gWindow.scrollBy(0, -200);
     yield scrollPromise;
     emptyClipboard();
     if (gWindow)
       clearSelection(gWindow);
     if (gFrame)
       clearSelection(gFrame);
@@ -250,17 +250,17 @@ gTests.push({
       }, kCommonWaitMs, kCommonPollMs);
     yield hideContextUI();
   },
 });
 
 gTests.push({
   desc: "tap on selection clears selection in content",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
 
     sendContextMenuClick(30, 20);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     sendTap(gWindow, 30, 20);
@@ -270,17 +270,17 @@ gTests.push({
       }, kCommonWaitMs, kCommonPollMs);
   },
   tearDown: setUpAndTearDown,
 });
 
 gTests.push({
   desc: "tap off selection clears selection in content",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
 
     sendContextMenuClick(30, 20);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     sendTap(gWindow, 30, 100);
@@ -290,17 +290,17 @@ gTests.push({
       }, kCommonWaitMs, kCommonPollMs);
   },
   tearDown: setUpAndTearDown,
 });
 
 gTests.push({
   desc: "bug 903737 - right click targeting",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     yield hideContextUI();
     let range = gWindow.document.createRange();
     range.selectNode(gWindow.document.getElementById("seldiv"));
     gWindow.getSelection().addRange(range);
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, gWindow.document.getElementById("seldiv"));
     yield promise;
     promise = waitForEvent(document, "popuphidden");
@@ -317,17 +317,17 @@ gTests.push({
   },
   tearDown: setUpAndTearDown,
 });
 
 gTests.push({
   desc: "Bug 960886 - selection monocles being spilled over to other tabs " +
         "when switching.",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     let initialTab = Browser.selectedTab;
 
     // Create additional tab to which we will switch later
     info(chromeRoot + "browser_selection_basic.html");
     let lastTab = yield addTab(chromeRoot + "browser_selection_basic.html");
 
     // Switch back to the initial tab
     let tabSelectPromise = waitForEvent(Elements.tabList, "TabSelect");
diff --git a/browser/metro/base/tests/mochitest/browser_selection_caretfocus.js b/browser/metro/base/tests/mochitest/browser_selection_caretfocus.js
--- a/browser/metro/base/tests/mochitest/browser_selection_caretfocus.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_caretfocus.js
@@ -21,17 +21,17 @@ function setUpAndTearDown() {
   InputSourceHelper.isPrecise = false;
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_caretfocus.html");
     yield addTab(chromeRoot + "browser_selection_caretfocus.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
     });
 
     yield hideContextUI();
@@ -52,17 +52,17 @@ function tapText(aIndex) {
   sendElementTap(gWindow, element, 100, 10);
   return element;
 }
 
 gTests.push({
   desc: "focus navigation",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     for (let iteration = 0; iteration < 3; iteration++) {
       for (let input = 1; input <= 6; input++) {
         let element = tapText(input);
         if (input == 6) {
           // div
           yield waitForCondition(function () {
             return !SelectionHelperUI.isActive;
           });
diff --git a/browser/metro/base/tests/mochitest/browser_selection_contenteditable.js b/browser/metro/base/tests/mochitest/browser_selection_contenteditable.js
--- a/browser/metro/base/tests/mochitest/browser_selection_contenteditable.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_contenteditable.js
@@ -10,17 +10,17 @@ const kCommonWaitMs = 5000;
 const kCommonPollMs = 100;
 
 ///////////////////////////////////////////////////
 // content editable tests
 ///////////////////////////////////////////////////
 
 gTests.push({
   desc: "normalize browser",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_contenteditable.html");
     yield addTab(chromeRoot + "browser_selection_contenteditable.html");
     yield waitForCondition(function () {
         return !BrowserUI.isStartTabVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     yield hideContextUI();
 
@@ -28,17 +28,17 @@ gTests.push({
 
     InputSourceHelper.isPrecise = false;
     InputSourceHelper.fireUpdate();
   },
 });
 
 gTests.push({
   desc: "simple test to make sure content editable selection works",
-  run: function test() {
+  run: function() {
     let div = gWindow.document.getElementById("testdiv");
     ok(div, "have the div");
 
     sendElementTap(gWindow, div, 284); // end of 'outlook.com'
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isCaretUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
diff --git a/browser/metro/base/tests/mochitest/browser_selection_frame_content.js b/browser/metro/base/tests/mochitest/browser_selection_frame_content.js
--- a/browser/metro/base/tests/mochitest/browser_selection_frame_content.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_frame_content.js
@@ -28,17 +28,17 @@ function setUpAndTearDown() {
   InputSourceHelper.isPrecise = false;
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_frame_content.html");
     yield addTab(chromeRoot + "browser_selection_frame_content.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
       }, 10000, 100);
 
     yield hideContextUI();
@@ -47,17 +47,17 @@ gTests.push({
     gFrame = gWindow.document.getElementById("frame1");
   },
 });
 
 gTests.push({
   desc: "iframe basic selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gFrame.focus();
 
     sendContextMenuClick(165, 35);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
@@ -67,17 +67,17 @@ gTests.push({
     is(getTrimmedSelection(gFrame).toString(), "Alice", "selection test");
   },
 });
 
 gTests.push({
   desc: "iframe expand / collapse selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gFrame.focus();
     
     sendContextMenuClick(162, 180);
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
@@ -112,17 +112,17 @@ gTests.push({
     is(SelectionHelperUI.isActive, true, "selection active");
     is(getTrimmedSelection(gFrame).toString(), "Alice was beginning to get very", "selection test");
   },
 });
 
 gTests.push({
   desc: "scrolled iframe selection",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gFrame.focus();
 
     let scrollPromise = waitForEvent(gFrame.contentDocument.defaultView, "scroll");
     gFrame.contentDocument.defaultView.scrollBy(0, 200);
     yield scrollPromise;
 
     sendContextMenuClick(30, 240);
 
@@ -152,34 +152,34 @@ gTests.push({
     let string = "";
     yield waitForCondition(function () {
       string = SpecialPowers.getClipboardData("text/unicode");
       return string === "started";
     });
     is(string, "started", "copy text");
 
   },
-  tearDown: function tearDown() {
+  tearDown: function() {
     emptyClipboard();
     let scrollPromise = waitForEvent(gFrame.contentDocument.defaultView, "scroll");
     gFrame.contentDocument.defaultView.scrollBy(0, -200);
     yield scrollPromise;
     clearSelection(gWindow);
     clearSelection(gFrame);
     yield waitForCondition(function () {
         return !SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
     yield hideContextUI();
   },
 });
 
 gTests.push({
   desc: "iframe within scrolled page selection",
   setUp: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gFrame.focus();
 
     let scrollPromise = waitForEvent(gWindow, "scroll");
     gWindow.scrollBy(0, 200);
     yield scrollPromise;
 
     scrollPromise = waitForEvent(gFrame.contentDocument.defaultView, "scroll");
     gFrame.contentDocument.defaultView.scrollBy(0, 200);
@@ -189,17 +189,17 @@ gTests.push({
 
     yield waitForCondition(function () {
         return SelectionHelperUI.isSelectionUIVisible;
       }, kCommonWaitMs, kCommonPollMs);
 
     is(SelectionHelperUI.isActive, true, "selection active");
     is(getTrimmedSelection(gFrame).toString(), "moment", "selection test");
   },
-  tearDown: function tearDown() {
+  tearDown: function() {
     emptyClipboard();
     clearSelection(gWindow);
     clearSelection(gFrame);
     let scrollPromise = waitForEvent(gFrame.contentDocument.defaultView, "scroll");
     gFrame.contentDocument.defaultView.scrollBy(0, -200);
     yield scrollPromise;
     scrollPromise = waitForEvent(gWindow, "scroll");
     gWindow.scrollBy(0, -200);
diff --git a/browser/metro/base/tests/mochitest/browser_selection_frame_in_scrollable_container.js b/browser/metro/base/tests/mochitest/browser_selection_frame_in_scrollable_container.js
--- a/browser/metro/base/tests/mochitest/browser_selection_frame_in_scrollable_container.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_frame_in_scrollable_container.js
@@ -27,17 +27,17 @@ function setUpAndTearDown() {
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "Selection monocles for frame content that is located inside " +
         "scrollable container.",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     let urlToLoad = chromeRoot +
         "browser_selection_frame_in_scrollable_container.html";
     info(urlToLoad);
     yield addTab(urlToLoad);
 
     ContextUI.dismiss();
     yield waitForCondition(() => !ContextUI.navbarVisible);
 
diff --git a/browser/metro/base/tests/mochitest/browser_selection_frame_inputs.js b/browser/metro/base/tests/mochitest/browser_selection_frame_inputs.js
--- a/browser/metro/base/tests/mochitest/browser_selection_frame_inputs.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_frame_inputs.js
@@ -30,17 +30,17 @@ function setUpAndTearDown() {
   InputSourceHelper.isPrecise = false;
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_frame_inputs.html");
     yield addTab(chromeRoot + "browser_selection_frame_inputs.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
       }, 10000, 100);
 
     yield hideContextUI();
@@ -54,17 +54,17 @@ gTests.push({
     ok(gInput != null, "gInput");
   },
 });
 
 gTests.push({
   desc: "basic selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gInput.focus();
     gInput.selectionStart = gInput.selectionEnd = 0;
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, gFrame, 135, 10);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
@@ -88,17 +88,17 @@ gTests.push({
     checkMonoclePositionRange("end", rect.left + 165, rect.left + 175, rect.top + 20, rect.top + 30);
   },
 });
 
 gTests.push({
   desc: "drag selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gInput.focus();
     gInput.selectionStart = gInput.selectionEnd = 0;
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, gFrame, 135, 10);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
diff --git a/browser/metro/base/tests/mochitest/browser_selection_frame_textarea.js b/browser/metro/base/tests/mochitest/browser_selection_frame_textarea.js
--- a/browser/metro/base/tests/mochitest/browser_selection_frame_textarea.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_frame_textarea.js
@@ -30,17 +30,17 @@ function setUpAndTearDown() {
   InputSourceHelper.isPrecise = false;
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_frame_textarea.html");
     yield addTab(chromeRoot + "browser_selection_frame_textarea.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
       }, 10000, 100);
 
     yield hideContextUI();
@@ -53,17 +53,17 @@ gTests.push({
     ok(gTextArea != null, "gTextArea");
   },
 });
 
 gTests.push({
   desc: "basic selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gTextArea.focus();
     gTextArea.selectionStart = gTextArea.selectionEnd = 0;
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, gFrame, 220, 80);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
@@ -86,17 +86,17 @@ gTests.push({
     checkMonoclePositionRange("end", 320, 340, 675, 690);
   },
 });
 
 gTests.push({
   desc: "drag selection 1",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gTextArea.focus();
     gTextArea.selectionStart = gTextArea.selectionEnd = 0;
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, gFrame, 220, 80);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
@@ -163,17 +163,17 @@ gTests.push({
     });
   },
 });
 
 gTests.push({
   desc: "drag selection 2",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gTextArea.focus();
     gTextArea.selectionStart = gTextArea.selectionEnd = 0;
 
     let scrollPromise = waitForEvent(gWindow, "scroll");
     gWindow.scrollBy(0, 200);
     yield scrollPromise;
 
     let promise = waitForEvent(document, "popupshown");
diff --git a/browser/metro/base/tests/mochitest/browser_selection_inputs.js b/browser/metro/base/tests/mochitest/browser_selection_inputs.js
--- a/browser/metro/base/tests/mochitest/browser_selection_inputs.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_inputs.js
@@ -33,17 +33,17 @@ function setUpAndTearDown() {
   25px tall text input
   300px wide
 */
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_inputs.html");
     yield addTab(chromeRoot + "browser_selection_inputs.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
       });
 
     yield hideContextUI();
@@ -52,17 +52,17 @@ gTests.push({
     gInput = gWindow.document.getElementById("a");
   },
 });
 
 gTests.push({
   desc: "basic text input selection",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gInput.blur();
     gInput.selectionStart = gInput.selectionEnd = 0;
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClick(200, 17);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
@@ -83,17 +83,17 @@ gTests.push({
     is(gWindow.document.activeElement, gInput, "input focused");
   },
 });
 
 gTests.push({
   desc: "drag left to scroll",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gInput.selectionStart = gInput.selectionEnd = gInput.value.length;
     yield waitForEvent(window, "scroll");
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClick(190, 17);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
@@ -130,17 +130,17 @@ gTests.push({
     yield SelectionHelperUI.pingSelectionHandler();
   },
 });
 
 gTests.push({
   desc: "drag right to scroll and bug 862025",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     gInput.selectionStart = gInput.selectionEnd = 0;
     yield waitForEvent(window, "scroll");
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClick(230, 17);
     yield promise;
 
     checkContextUIMenuItemVisibility(["context-select",
@@ -195,17 +195,17 @@ gTests.push({
   },
 });
 
 gTests.push({
   desc: "Bug 858206 - Drag selection monocles should not push other monocles " +
         "out of the way.",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     let inputOriginalValue = gInput.value;
 
     gInput.value = "The rabbit-hole went straight on";
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, gInput, 150);
     yield promise;
 
diff --git a/browser/metro/base/tests/mochitest/browser_selection_textarea.js b/browser/metro/base/tests/mochitest/browser_selection_textarea.js
--- a/browser/metro/base/tests/mochitest/browser_selection_textarea.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_textarea.js
@@ -27,17 +27,17 @@ function setUpAndTearDown() {
   InputSourceHelper.isPrecise = false;
   InputSourceHelper.fireUpdate();
 }
 
 gTests.push({
   desc: "normalize browser",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     info(chromeRoot + "browser_selection_textarea.html");
     yield addTab(chromeRoot + "browser_selection_textarea.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
       }, 10000, 100);
 
     yield hideContextUI();
@@ -45,17 +45,17 @@ gTests.push({
     gWindow = Browser.selectedTab.browser.contentWindow;
   },
 });
 
 gTests.push({
   desc: "textarea selection and drag",
   setUp: setUpAndTearDown,
   tearDown: setUpAndTearDown,
-  run: function test() {
+  run: function() {
     // work around for buggy context menu display
     yield waitForMs(100);
 
     let textarea = gWindow.document.getElementById("inputtext");
     textarea.focus();
 
     let promise = waitForEvent(document, "popupshown");
     sendContextMenuClickToElement(gWindow, textarea, 20, 10);
diff --git a/browser/metro/base/tests/mochitest/browser_selection_urlbar.js b/browser/metro/base/tests/mochitest/browser_selection_urlbar.js
--- a/browser/metro/base/tests/mochitest/browser_selection_urlbar.js
+++ b/browser/metro/base/tests/mochitest/browser_selection_urlbar.js
@@ -12,34 +12,34 @@ const kCommonWaitMs = 5000;
 const kCommonPollMs = 100;
 
 ///////////////////////////////////////////////////
 // text area tests
 ///////////////////////////////////////////////////
 
 gTests.push({
   desc: "normalize browser",
-  run: function test() {
+  run: function() {
     info(chromeRoot + "res/textblock01.html");
     yield addTab(chromeRoot + "res/textblock01.html");
 
     yield waitForCondition(function () {
       return !BrowserUI.isStartTabVisible;
       });
 
     yield hideContextUI();
 
     InputSourceHelper.isPrecise = false;
     InputSourceHelper.fireUpdate();
   },
 });
 
 gTests.push({
   desc: "nav bar display",
-  run: function test() {
+  run: function() {
     gWindow = window;
 
     yield showNavBar();
 
     let edit = document.getElementById("urlbar-edit");
 
     sendElementTap(window, edit, 100, 10);
 
@@ -318,17 +318,17 @@ gTests.push({
     chromeHandlerSpy.restore();
     inputField.blur();
   }
 });
 
 gTests.push({
   desc: "Bug 858206 - Drag selection monocles should not push other monocles " +
         "out of the way.",
-  run: function test() {
+  run: function() {
     yield showNavBar();
 
     let edit = document.getElementById("urlbar-edit");
     edit.value = "about:mozilla";
 
     let editRectangle = edit.getBoundingClientRect();
 
     sendTap(window, editRectangle.left, editRectangle.top);
diff --git a/browser/metro/base/tests/mochitest/browser_test.js b/browser/metro/base/tests/mochitest/browser_test.js
--- a/browser/metro/base/tests/mochitest/browser_test.js
+++ b/browser/metro/base/tests/mochitest/browser_test.js
@@ -18,13 +18,13 @@ gTests.push({
       }, 25);
       return defd.promise;
     }
   }
 });
 
 gTests.push({
   desc: "addTab",
-  run: function testAddTab() {
+  run: function() {
     let tab = yield addTab("http://example.com/");
     is(tab, Browser.selectedTab, "The new tab is selected");
   }
 });
diff --git a/browser/metro/base/tests/mochitest/browser_topsites.js b/browser/metro/base/tests/mochitest/browser_topsites.js
--- a/browser/metro/base/tests/mochitest/browser_topsites.js
+++ b/browser/metro/base/tests/mochitest/browser_topsites.js
@@ -20,37 +20,37 @@ let TopSitesTestHelper = {
       if (BrowserUI.isStartTabVisible)
         return;
 
       yield addTab("about:start");
 
       yield waitForCondition(() => BrowserUI.isStartTabVisible);
     });
   },
-  mockLinks: function th_mockLinks(aLinks) {
+  mockLinks: function(aLinks) {
     // create link objects where index. corresponds to grid position
     // falsy values are set to null
     let links = (typeof aLinks == "string") ?
                 aLinks.split(/\s*,\s*/) : aLinks;
 
     links = links.map(function (id) {
       return (id) ? {url: "http://example.com/#" + id, title: id} : null;
     });
     return links;
   },
-  siteFromNode: function th_siteFromNode(aNode) {
+  siteFromNode: function(aNode) {
     return {
       url: aNode.getAttribute("value"),
       title: aNode.getAttribute("label")
     }
   },
-  clearHistory: function th_clearHistory() {
+  clearHistory: function() {
     PlacesUtils.history.removeAllPages();
   },
-  fillHistory: function th_fillHistory(aLinks) {
+  fillHistory: function(aLinks) {
     return Task.spawn(function(){
       let numLinks = aLinks.length;
       let transitionLink = Ci.nsINavHistoryService.TRANSITION_LINK;
 
       let updateDeferred = Promise.defer();
 
       for (let link of aLinks.reverse()) {
         let place = {
@@ -83,17 +83,17 @@ let TopSitesTestHelper = {
    * Allows to specify the list of pinned links (that have a fixed position in
    * the grid.
    * @param aLinksPattern the pattern (see below)
    *
    * Example: setPinnedLinks("foo,,bar")
    * Result: 'http://example.com/#foo' is pinned in the first cell. 'http://example.com/#bar' is
    *         pinned in the third cell.
    */
-  setPinnedLinks: function th_setPinnedLinks(aLinks) {
+  setPinnedLinks: function(aLinks) {
     let links = TopSitesTestHelper.mockLinks(aLinks);
 
     // (we trust that NewTabUtils works, and test our consumption of it)
     // clear all existing pins
     Array.forEach(NewTabUtils.pinnedLinks.links, function(aLink){
       if(aLink)
         NewTabUtils.pinnedLinks.unpin(aLink);
     });
@@ -114,17 +114,17 @@ let TopSitesTestHelper = {
    * Example: setLinks("dougal,florence,zebedee")
    * Result: [{url: "http://example.com/#dougal", title: "dougal"},
    *          {url: "http://example.com/#florence", title: "florence"}
    *          {url: "http://example.com/#zebedee", title: "zebedee"}]
    * Example: setLinks("dougal,florence,zebedee","dougal,,zebedee")
    * Result: http://example.com/#dougal is pinned at index 0, http://example.com/#florence at index 2
    */
 
-  setLinks: function th_setLinks(aLinks, aPinnedLinks) {
+  setLinks: function(aLinks, aPinnedLinks) {
     let links = TopSitesTestHelper.mockLinks(aLinks);
     if (links.filter(function(aLink){
       return !aLink;
     }).length) {
       throw new Error("null link objects in setLinks");
     }
 
     return Task.spawn(function() {
@@ -136,32 +136,32 @@ let TopSitesTestHelper = {
         TopSitesTestHelper.setPinnedLinks(aPinnedLinks);
       }
 
       // reset the TopSites state, have it update its cache with the new data fillHistory put there
       yield TopSites.prepareCache(true);
     });
   },
 
-  updatePagesAndWait: function th_updatePagesAndWait() {
+  updatePagesAndWait: function() {
     let deferredUpdate = Promise.defer();
     let updater = {
       update: function() {
         NewTabUtils.allPages.unregister(updater);
         deferredUpdate.resolve(true);
       }
     };
     NewTabUtils.allPages.register(updater);
     setTimeout(function() {
       NewTabUtils.allPages.update();
     }, 0);
     return deferredUpdate.promise;
   },
 
-  tearDown: function th_tearDown() {
+  tearDown: function() {
     TopSitesTestHelper.clearHistory();
   }
 };
 
 
 //////////////////////////////////////////////////////////////////////////
 
 
diff --git a/browser/metro/base/tests/mochitest/browser_ui_telemetry.js b/browser/metro/base/tests/mochitest/browser_ui_telemetry.js
--- a/browser/metro/base/tests/mochitest/browser_ui_telemetry.js
+++ b/browser/metro/base/tests/mochitest/browser_ui_telemetry.js
@@ -17,17 +17,17 @@ function getTelemetryPayload() {
 
 gTests.push({
   desc: "Setup",
   run: () => { yield TelemetrySession.setup(); }
 });
 
 gTests.push({
   desc: "Test browser-ui telemetry",
-  run: function testBrowserUITelemetry() {
+  run: function() {
     // startup should have registered simple measures function
     is(getTelemetryPayload().info.appName, "MetroFirefox");
 
     let simpleMeasurements = getTelemetryPayload().simpleMeasurements;
     ok(simpleMeasurements, "simpleMeasurements are truthy");
     ok(simpleMeasurements.UITelemetry["metro-ui"]["window-width"], "window-width measurement was captured");
     ok(simpleMeasurements.UITelemetry["metro-ui"]["window-height"], "window-height measurement was captured");
   }
diff --git a/browser/metro/base/tests/mochitest/browser_urlbar.js b/browser/metro/base/tests/mochitest/browser_urlbar.js
--- a/browser/metro/base/tests/mochitest/browser_urlbar.js
+++ b/browser/metro/base/tests/mochitest/browser_urlbar.js
@@ -106,17 +106,17 @@ function setUp() {
 function tearDown() {
   Browser.closeTab(Browser.selectedTab, { forceClose: true });
 }
 
 gTests.push({
   desc: "search engines update",
   setUp: setUp,
   tearDown: tearDown,
-  run: function testSearchEngine() {
+  run: function() {
     // If the XBL hasn't initialized yet, open the popup so that it will.
     if (gEdit.popup._searches == undefined) {
       gEdit.openPopup();
       gEdit.closePopup();
     }
     yield waitForCondition(() => gEdit.popup._searches.itemCount);
 
     let numSearches = gEdit.popup._searches.itemCount;
@@ -133,17 +133,17 @@ gTests.push({
     ok(!getEngineItem(), "added search engine item");
   }
 });
 
 gTests.push({
   desc: "display autocomplete while typing, handle enter",
   setUp: setUp,
   tearDown: tearDown,
-  run: function testUrlbarTyping() {
+  run: function() {
     sendElementTap(window, gEdit);
     ok(gEdit.isEditing, "focus urlbar: in editing mode");
     ok(!gEdit.popup.popupOpen, "focus urlbar: popup not open yet");
 
     EventUtils.sendString("about:blank", window);
     let opened = yield waitForCondition(() => gEdit.popup.popupOpen);
     ok(opened, "type in urlbar: popup opens");
 
@@ -198,17 +198,17 @@ gTests.push({
     ok(!gEdit.isEditing, "hit enter in urlbar: not in editing mode");
   }
 });
 
 gTests.push({
   desc: "display and select a search with keyboard",
   setUp: setUp,
   tearDown: tearDown,
-  run: function testSearchKeyboard() {
+  run: function() {
     yield addMockSearchDefault();
 
     yield waitForCondition(() => !Browser.selectedTab.isLoading());
 
     sendElementTap(window, gEdit);
     ok(gEdit.isEditing, "focus urlbar: in editing mode");
     ok(!gEdit.popup.popupOpen, "focus urlbar: popup not open yet");
 
@@ -245,17 +245,17 @@ gTests.push({
     yield removeMockSearchDefault();
   }
 });
 
 gTests.push({
   desc: "display and select a search with touch",
   setUp: setUp,
   tearDown: tearDown,
-  run: function testUrlbarSearchesTouch() {
+  run: function() {
     yield addMockSearchDefault();
 
     yield waitForCondition(() => !Browser.selectedTab.isLoading());
 
     sendElementTap(window, gEdit);
     ok(gEdit.isEditing, "focus urlbar: in editing mode");
     ok(!gEdit.popup.popupOpen, "focus urlbar: popup not open yet");
 
@@ -275,17 +275,17 @@ gTests.push({
 
     yield removeMockSearchDefault();
   }
 });
 
 gTests.push({
   desc: "bug 897131 - url bar update after content tap + edge swipe",
   tearDown: tearDown,
-  run: function testUrlbarTyping() {
+  run: function() {
     let tab = yield addTab("about:mozilla");
     yield showNavBar();
 
     sendElementTap(window, gEdit);
     ok(gEdit.isEditing, "focus urlbar: in editing mode");
     ok(!gEdit.popup.popupOpen, "focus urlbar: popup not open yet");
 
     EventUtils.sendString("about:blank", window);
@@ -305,17 +305,17 @@ gTests.push({
     ok(ContextUI.navbarVisible, "navbar visible");
     is(gEdit.value, "about:mozilla", "url bar text refreshed");
   }
 });
 
 gTests.push({
   desc: "Bug 916383 - Invisible autocomplete items selectable by keyboard when 'your results' not shown",
   tearDown: tearDown,
-  run: function testBug916383() {
+  run: function() {
     yield addTab("about:start");
     yield showNavBar();
 
     sendElementTap(window, gEdit);
 
     let bookmarkItem = Browser.selectedBrowser.contentWindow.BookmarksStartView._grid.querySelector("richgriditem");
     // Get the first bookmark item label to make sure it will show up in 'your results'
     let label = bookmarkItem.getAttribute("label");
@@ -346,17 +346,17 @@ gTests.push({
     EventUtils.synthesizeKey("VK_TAB", { shiftKey: true }, window);
     is(gEdit.popup._searches.selectedIndex, 0, "shift-tab: first search selected");
   }
 });
 
 gTests.push({
   desc: "Bug 891667 - Use up arrow too",
   tearDown: tearDown,
-  run: function testBug891667() {
+  run: function() {
     yield addTab("about:start");
     yield showNavBar();
 
     sendElementTap(window, gEdit);
 
     let bookmarkItem = Browser.selectedBrowser.contentWindow.BookmarksStartView._grid.querySelector("richgriditem");
     // Get the first bookmark item label to make sure it will show up in 'your results'
     let label = bookmarkItem.getAttribute("label");
diff --git a/browser/metro/base/tests/mochitest/head.js b/browser/metro/base/tests/mochitest/head.js
--- a/browser/metro/base/tests/mochitest/head.js
+++ b/browser/metro/base/tests/mochitest/head.js
@@ -852,17 +852,17 @@ TouchDragAndHold.prototype = {
   set numSteps(aValue) {
     this._numSteps = aValue;
   },
 
   set nativePointerId(aValue) {
     this._pointerId = aValue;
   },
 
-  callback: function callback() {
+  callback: function() {
     if (this._win == null)
       return;
 
     if (this._debug) {
       SelectionHelperUI.debugDisplayDebugPoint(this._currentPoint.xPos,
         this._currentPoint.yPos, 5, "#FF0000", true);
     }
 
@@ -892,17 +892,17 @@ TouchDragAndHold.prototype = {
       EventUtils.synthesizeTouchAtPoint(this._currentPoint.xPos, this._currentPoint.yPos,
                                         { type: "touchmove" }, this._win);
     }
 
     let self = this;
     setTimeout(function () { self.callback(); }, this._timeoutStep);
   },
 
-  start: function start(aWindow, aStartX, aStartY, aEndX, aEndY) {
+  start: function(aWindow, aStartX, aStartY, aEndX, aEndY) {
     this._defer = Promise.defer();
     this._win = aWindow;
     this._utils = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                          .getInterface(Ci.nsIDOMWindowUtils);
     this._endPoint = { xPos: aEndX, yPos: aEndY };
     this._currentPoint = { xPos: aStartX, yPos: aStartY };
     this._step = { steps: 0, x: (aEndX - aStartX) / this._numSteps, y: (aEndY - aStartY) / this._numSteps };
     if (this._debug) {
@@ -916,33 +916,33 @@ TouchDragAndHold.prototype = {
     } else {
       EventUtils.synthesizeTouchAtPoint(aStartX, aStartY, { type: "touchstart" }, aWindow);
     }
     let self = this;
     setTimeout(function () { self.callback(); }, this._timeoutStep);
     return this._defer.promise;
   },
 
-  move: function move(aEndX, aEndY) {
+  move: function(aEndX, aEndY) {
     if (this._win == null)
       return;
     if (this._debug) {
       info("[0] continuation to " + aEndX + " x " + aEndY);
     }
     this._defer = Promise.defer();
     this._step = { steps: 0,
                    x: (aEndX - this._endPoint.xPos) / this._numSteps,
                    y: (aEndY - this._endPoint.yPos) / this._numSteps };
     this._endPoint = { xPos: aEndX, yPos: aEndY };
     let self = this;
     setTimeout(function () { self.callback(); }, this._timeoutStep);
     return this._defer.promise;
   },
 
-  end: function end() {
+  end: function() {
     if (this._debug) {
       info("[" + this._step.steps + "] touchend " + this._endPoint.xPos + " x " + this._endPoint.yPos);
       SelectionHelperUI.debugClearDebugPoints();
     }
     if (this._native) {
       this._utils.sendNativeTouchPoint(this._pointerId, this._dui.TOUCH_REMOVE,
                                        this._endPoint.xPos, this._endPoint.yPos,
                                        1, 90);
diff --git a/browser/metro/base/tests/mochitest/helpers/BookmarksHelper.js b/browser/metro/base/tests/mochitest/helpers/BookmarksHelper.js
--- a/browser/metro/base/tests/mochitest/helpers/BookmarksHelper.js
+++ b/browser/metro/base/tests/mochitest/helpers/BookmarksHelper.js
@@ -61,17 +61,17 @@ var BookmarksTestHelper = {
   _originalPinHelper: null,
   MockPinHelper: {
     isPinned: function (aItem) BookmarksTestHelper._nodes[aItem].pinned,
     setUnpinned: function (aItem) BookmarksTestHelper._nodes[aItem].pinned = false,
     setPinned: function (aItem) BookmarksTestHelper._nodes[aItem].pinned = true,
   },
 
   _originalUpdateFavicon: null,
-  setup: function setup() {
+  setup: function() {
     this._startView = Browser.selectedBrowser.contentWindow.BookmarksStartView._view;
 
     // Just enough items so that there will be one less then the limit
     // after removing 4 items.
     this.createNodes(this._startView.maxTiles + 3);
 
     this._originalNavHistoryService = this._startView._navHistoryService;
     this._startView._navHistoryService = this.MockNavHistoryService;
diff --git a/browser/metro/base/tests/mochitest/helpers/HistoryHelper.js b/browser/metro/base/tests/mochitest/helpers/HistoryHelper.js
--- a/browser/metro/base/tests/mochitest/helpers/HistoryHelper.js
+++ b/browser/metro/base/tests/mochitest/helpers/HistoryHelper.js
@@ -58,17 +58,17 @@ var HistoryTestHelper = {
 
   _originalPinHelper: null,
   MockPinHelper: {
     isPinned: function (aItem) HistoryTestHelper._nodes[aItem].pinned,
     setUnpinned: function (aItem) HistoryTestHelper._nodes[aItem].pinned = false,
     setPinned: function (aItem) HistoryTestHelper._nodes[aItem].pinned = true,
   },
 
-  setup: function setup() {
+  setup: function() {
     this._startView = Browser.selectedBrowser.contentWindow.HistoryStartView._view;
 
     // Just enough items so that there will be one less then the limit
     // after removing 4 items.
     this.createNodes(this._startView.maxTiles + 3);
 
     this._originalNavHistoryService = this._startView._navHistoryService;
     this._startView._navHistoryService = this.MockNavHistoryService;
diff --git a/browser/metro/components/BrowserCLH.js b/browser/metro/components/BrowserCLH.js
--- a/browser/metro/components/BrowserCLH.js
+++ b/browser/metro/components/BrowserCLH.js
@@ -124,17 +124,17 @@ function isLocaleAvailable(aLocale) {
 }
 
 function BrowserCLH() { }
 
 BrowserCLH.prototype = {
   //
   // nsICommandLineHandler
   //
-  handle: function fs_handle(aCmdLine) {
+  handle: function(aCmdLine) {
 #ifdef DEBUG
     for (var idx = 0; idx <  aCmdLine.length; idx++) {
       dump(aCmdLine.getArgument(idx) + "\n");
     }
 #endif
     // Instantiate the search service so the search engine cache is created now
     // instead when the application is running. The install process will register
     // this component by using the --silent command line flag, thereby creating
diff --git a/browser/metro/components/ContentDispatchChooser.js b/browser/metro/components/ContentDispatchChooser.js
--- a/browser/metro/components/ContentDispatchChooser.js
+++ b/browser/metro/components/ContentDispatchChooser.js
@@ -11,17 +11,17 @@ Cu.import("resource://gre/modules/Servic
 function ContentDispatchChooser() {}
 
 ContentDispatchChooser.prototype =
 {
   classID: Components.ID("5a072a22-1e66-4100-afc1-07aed8b62fc5"),
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIContentDispatchChooser]),
 
-  ask: function ask(aHandler, aWindowContext, aURI, aReason) {
+  ask: function(aHandler, aWindowContext, aURI, aReason) {
     let window = null;
     try {
       if (aWindowContext)
         window = aWindowContext.getInterface(Ci.nsIDOMWindow);
     } catch (e) { /* it's OK to not have a window */ }
 
     let bundle = Services.strings.createBundle("chrome://mozapps/locale/handling/handling.properties");
 
diff --git a/browser/metro/components/ContentPermissionPrompt.js b/browser/metro/components/ContentPermissionPrompt.js
--- a/browser/metro/components/ContentPermissionPrompt.js
+++ b/browser/metro/components/ContentPermissionPrompt.js
@@ -22,45 +22,45 @@ const kIcons = {
 
 function ContentPermissionPrompt() {}
 
 ContentPermissionPrompt.prototype = {
   classID: Components.ID("{C6E8C44D-9F39-4AF7-BCC0-76E38A8310F5}"),
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIContentPermissionPrompt]),
 
-  getChromeWindow: function getChromeWindow(aWindow) {
+  getChromeWindow: function(aWindow) {
      let chromeWin = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                             .getInterface(Ci.nsIWebNavigation)
                             .QueryInterface(Ci.nsIDocShellTreeItem)
                             .rootTreeItem
                             .QueryInterface(Ci.nsIInterfaceRequestor)
                             .getInterface(Ci.nsIDOMWindow)
                             .QueryInterface(Ci.nsIDOMChromeWindow);
      return chromeWin;
   },
 
-  getChromeWindowForRequest: function getChromeWindowForRequest(aRequest) {
+  getChromeWindowForRequest: function(aRequest) {
     if (aRequest.window)
       return this.getChromeWindow(aRequest.window.top).wrappedJSObject;
     return aRequest.element.ownerDocument.defaultView;
   },
 
-  getNotificationBoxForRequest: function getNotificationBoxForRequest(request) {
+  getNotificationBoxForRequest: function(request) {
     let chromeWin = this.getChromeWindowForRequest(request);
     if (request.window) {
       let requestingWindow = request.window.top;
       let windowID = request.window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
       let browser = chromeWin.Browser.getBrowserForWindowId(windowID);
       return chromeWin.getNotificationBox(browser);
     }
     return chromeWin.Browser.getNotificationBox(request.element);
   },
 
-  handleExistingPermission: function handleExistingPermission(request, type) {
+  handleExistingPermission: function(request, type) {
     let result = Services.perms.testExactPermissionFromPrincipal(request.principal, type);
     if (result == Ci.nsIPermissionManager.ALLOW_ACTION) {
       request.allow();
       return true;
     }
     if (result == Ci.nsIPermissionManager.DENY_ACTION) {
       request.cancel();
       return true;
diff --git a/browser/metro/components/DownloadManagerUI.js b/browser/metro/components/DownloadManagerUI.js
--- a/browser/metro/components/DownloadManagerUI.js
+++ b/browser/metro/components/DownloadManagerUI.js
@@ -11,31 +11,31 @@ Components.utils.import("resource://gre/
 // Download Manager UI
 // -----------------------------------------------------------------------
 
 function DownloadManagerUI() { }
 
 DownloadManagerUI.prototype = {
   classID: Components.ID("{93db15b1-b408-453e-9a2b-6619e168324a}"),
 
-  show: function show(aWindowContext, aID, aReason, aUsePrivateUI) {
+  show: function(aWindowContext, aID, aReason, aUsePrivateUI) {
     if (!aReason)
       aReason = Ci.nsIDownloadManagerUI.REASON_USER_INTERACTED;
 
     let browser = Services.wm.getMostRecentWindow("navigator:browser");
     if (browser)
       browser.showDownloadManager(aWindowContext, aID, aReason);
   },
 
   get visible() {
     // For now there is no Download Manager UI.
     return false;
   },
 
-  getAttention: function getAttention() {
+  getAttention: function() {
     if (this.visible)
       this.show(null, null, null);
     else
       throw Cr.NS_ERROR_UNEXPECTED;
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIDownloadManagerUI])
 };
diff --git a/browser/metro/components/HelperAppDialog.js b/browser/metro/components/HelperAppDialog.js
--- a/browser/metro/components/HelperAppDialog.js
+++ b/browser/metro/components/HelperAppDialog.js
@@ -30,30 +30,30 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 // -----------------------------------------------------------------------
 
 function HelperAppLauncherDialog() { }
 
 HelperAppLauncherDialog.prototype = {
   classID: Components.ID("{e9d277a0-268a-4ec2-bb8c-10fdf3e44611}"),
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIHelperAppLauncherDialog]),
 
-  show: function hald_show(aLauncher, aContext, aReason) {
+  show: function(aLauncher, aContext, aReason) {
     // Check to see if we can open this file or not
     // If the file is an executable then launchWithApplication will fail in
     // /uriloader nsMIMEInfoWin.cpp code. So always download in that case.
     if (aLauncher.MIMEInfo.hasDefaultHandler && !aLauncher.targetFileIsExecutable) {
       aLauncher.MIMEInfo.preferredAction = Ci.nsIMIMEInfo.useSystemDefault;
       aLauncher.launchWithApplication(null, false);
     } else {
       let wasClicked = false;
       this._showDownloadInfobar(aLauncher);
     }
   },
 
-  _getDownloadSize: function dv__getDownloadSize (aSize) {
+  _getDownloadSize: function(aSize) {
     let displaySize = DownloadUtils.convertByteUnits(aSize);
     // displaySize[0] is formatted size, displaySize[1] is units
     if (aSize > 0)
       return displaySize.join("");
     else {
       let browserBundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
       return browserBundle.GetStringFromName("downloadsUnknownSize");
     }
@@ -65,17 +65,17 @@ HelperAppLauncherDialog.prototype = {
                             .QueryInterface(Ci.nsIDocShellTreeItem)
                             .rootTreeItem
                             .QueryInterface(Ci.nsIInterfaceRequestor)
                             .getInterface(Ci.nsIDOMWindow)
                             .QueryInterface(Ci.nsIDOMChromeWindow);
      return chromeWin;
   },
 
-  _showDownloadInfobar: function do_showDownloadInfobar(aLauncher) {
+  _showDownloadInfobar: function(aLauncher) {
     let browserBundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
 
     let runButtonText =
               browserBundle.GetStringFromName("downloadOpen");
     let saveButtonText =
               browserBundle.GetStringFromName("downloadSave");
     let cancelButtonText =
               browserBundle.GetStringFromName("downloadCancel");
@@ -133,17 +133,17 @@ HelperAppLauncherDialog.prototype = {
                                                     "save-download",
                                                     URI_GENERIC_ICON_DOWNLOAD,
                                                     notificationBox.PRIORITY_WARNING_HIGH,
                                                     buttons);
     let messageContainer = document.getAnonymousElementByAttribute(newBar, "anonid", "messageText");
     messageContainer.appendChild(fragment);
   },
 
-  promptForSaveToFileAsync: function hald_promptForSaveToFileAsync(aLauncher, aContext, aDefaultFile, aSuggestedFileExt, aForcePrompt) {
+  promptForSaveToFileAsync: function(aLauncher, aContext, aDefaultFile, aSuggestedFileExt, aForcePrompt) {
     let file = null;
     let prefs = Services.prefs;
 
     Task.spawn(function() {
       if (!aForcePrompt) {
         // Check to see if the user wishes to auto save to the default download
         // folder without prompting. Note that preference might not be set.
         let autodownload = true;
@@ -235,33 +235,33 @@ HelperAppLauncherDialog.prototype = {
           prefs.setComplexValue("browser.download.lastDir", Ci.nsILocalFile, newDir);
           file = this.validateLeafName(newDir, file.leafName, null);
         }
         aLauncher.saveDestinationAvailable(file);
       }.bind(this));
     }.bind(this));
   },
 
-  validateLeafName: function hald_validateLeafName(aLocalFile, aLeafName, aFileExt) {
+  validateLeafName: function(aLocalFile, aLeafName, aFileExt) {
     if (!(aLocalFile && this.isUsableDirectory(aLocalFile)))
       return null;
 
     // Remove any leading periods, since we don't want to save hidden files
     // automatically.
     aLeafName = aLeafName.replace(/^\.+/, "");
 
     if (aLeafName == "")
       aLeafName = "unnamed" + (aFileExt ? "." + aFileExt : "");
     aLocalFile.append(aLeafName);
 
     this.makeFileUnique(aLocalFile);
     return aLocalFile;
   },
 
-  makeFileUnique: function hald_makeFileUnique(aLocalFile) {
+  makeFileUnique: function(aLocalFile) {
     try {
       // Note - this code is identical to that in
       //   toolkit/content/contentAreaUtils.js.
       // If you are updating this code, update that code too! We can't share code
       // here since this is called in a js component.
       var collisionCount = 0;
       while (aLocalFile.exists()) {
         collisionCount++;
@@ -289,14 +289,14 @@ HelperAppLauncherDialog.prototype = {
       if (aLocalFile.leafName == "" || aLocalFile.isDirectory()) {
         aLocalFile.append("unnamed");
         if (aLocalFile.exists())
           aLocalFile.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0600);
       }
     }
   },
 
-  isUsableDirectory: function hald_isUsableDirectory(aDirectory) {
+  isUsableDirectory: function(aDirectory) {
     return aDirectory.exists() && aDirectory.isDirectory() && aDirectory.isWritable();
   },
 };
 
 this.NSGetFactory = XPCOMUtils.generateNSGetFactory([HelperAppLauncherDialog]);
diff --git a/browser/metro/components/PromptService.js b/browser/metro/components/PromptService.js
--- a/browser/metro/components/PromptService.js
+++ b/browser/metro/components/PromptService.js
@@ -16,17 +16,17 @@ function PromptService() {
 
 PromptService.prototype = {
   classID: Components.ID("{9a61149b-2276-4a0a-b79c-be994ad106cf}"),
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIPromptFactory, Ci.nsIPromptService, Ci.nsIPromptService2]),
 
   /* ----------  nsIPromptFactory  ---------- */
 
-  getPrompt: function getPrompt(domWin, iid) {
+  getPrompt: function(domWin, iid) {
     if (!domWin) {
       let chromeWin = Services.wm.getMostRecentWindow("navigator:browser");
       if (!chromeWin) {
         let msg = "PromptService.js: Attempted create a prompt but no DOM Window specified and failed to find one";
         Cu.reportError(msg);
         throw(msg);
       }
       domWin = chromeWin.getBrowser().contentWindow;
diff --git a/browser/metro/components/SafeBrowsing.js b/browser/metro/components/SafeBrowsing.js
--- a/browser/metro/components/SafeBrowsing.js
+++ b/browser/metro/components/SafeBrowsing.js
@@ -37,17 +37,17 @@ function SafeBrowsing() {
 SafeBrowsing.prototype = {
   classID: Components.ID("{aadaed90-6c03-42d0-924a-fc61198ff283}"),
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsISessionStore,
                                          Ci.nsIDOMEventListener,
                                          Ci.nsIObserver,
                                          Ci.nsISupportsWeakReference]),
 
-  observe: function sb_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "app-startup":
         Services.obs.addObserver(this, "final-ui-startup", true);
         Services.obs.addObserver(this, "xpcom-shutdown", true);
         break;
       case "final-ui-startup":
         Services.obs.removeObserver(this, "final-ui-startup");
         this._startup();
@@ -60,17 +60,17 @@ SafeBrowsing.prototype = {
         if (aData == kPhishWardenEnabledPref)
           this.maybeToggleUpdateChecking(this.phishing);
         else if (aData == kMalwareWardenEnabledPref)
           this.maybeToggleUpdateChecking(this.malware);
         break;
     }
   },
 
-  _startup: function sb_startup() {
+  _startup: function() {
     this.listManager = Cc["@mozilla.org/url-classifier/listmanager;1"].getService(Ci.nsIUrlListManager);
 
     // Add a test chunk to the database
     let testData = "itisatrap.org/firefox/its-an-attack.html";
     let testUpdate =
       "n:1000\ni:test-malware-simple\nad:1\n" +
       "a:1:32:" + testData.length + "\n" +
       testData;
@@ -106,62 +106,62 @@ SafeBrowsing.prototype = {
 
     this.registerBlackTable("goog-malware-shavar", this.malware);
     this.maybeToggleUpdateChecking(this.malware);
 
     this.registerBlackTable("goog-phish-shavar", this.phishing);
     this.maybeToggleUpdateChecking(this.phishing);
   },
 
-  _shutdown: function sb_shutdown() {
+  _shutdown: function() {
     Services.prefs.removeObserver(kPhishWardenEnabledPref, this);
     Services.prefs.removeObserver(kMalwareWardenEnabledPref, this);
 
     this.listManager = null;
   },
 
-  enableBlacklistTableUpdates: function sb_enableBlacklistTableUpdates(aWarden) {
+  enableBlacklistTableUpdates: function(aWarden) {
     for (let i = 0; i < aWarden.blackTables.length; ++i) {
       this.listManager.enableUpdate(aWarden.blackTables[i]);
     }
   },
 
-  disableBlacklistTableUpdates: function sb_disableBlacklistTableUpdates(aWarden) {
+  disableBlacklistTableUpdates: function(aWarden) {
     for (let i = 0; i < aWarden.blackTables.length; ++i) {
       this.listManager.disableUpdate(aWarden.blackTables[i]);
     }
   },
 
-  enableWhitelistTableUpdates: function sb_enableWhitelistTableUpdates(aWarden) {
+  enableWhitelistTableUpdates: function(aWarden) {
     for (let i = 0; i < this.whiteTables.length; ++i) {
       this.listManager.enableUpdate(this.whiteTables[i]);
     }
   },
 
-  disableWhitelistTableUpdates: function sb_disableWhitelistTableUpdates(aWarden) {
+  disableWhitelistTableUpdates: function(aWarden) {
     for (let i = 0; i < aWarden.whiteTables.length; ++i) {
       this.listManager.disableUpdate(aWarden.whiteTables[i]);
     }
   },
 
-  registerBlackTable: function sb_registerBlackTable(aTableName, aWarden) {
+  registerBlackTable: function(aTableName, aWarden) {
     let result = this.listManager.registerTable(aTableName, false);
     if (result)
       aWarden.blackTables.push(aTableName);
     return result;
   },
 
-  registerWhiteTable: function sb_registerWhiteTable(aTableName, aWarden) {
+  registerWhiteTable: function(aTableName, aWarden) {
     let result = this.listManager.registerTable(aTableName, false);
     if (result)
       aWarden.whiteTables.push(aTableName);
     return result;
   },
 
-  maybeToggleUpdateChecking: function sb_maybeToggleUpdateChecking(aWarden) {
+  maybeToggleUpdateChecking: function(aWarden) {
     let enabled = Services.prefs.getBoolPref(aWarden.pref);
     if (enabled)
       this.enableBlacklistTableUpdates(aWarden);
     else
       this.disableBlacklistTableUpdates(aWarden);
   }
 }
 
diff --git a/browser/metro/components/SessionStore.js b/browser/metro/components/SessionStore.js
--- a/browser/metro/components/SessionStore.js
+++ b/browser/metro/components/SessionStore.js
@@ -56,17 +56,17 @@ SessionStore.prototype = {
   _lastSessionTime: 0,
   _interval: 10000,
   _maxTabsUndo: 1,
   _shouldRestore: false,
 
   // Tab telemetry variables
   _maxTabsOpen: 1,
 
-  init: function ss_init() {
+  init: function() {
     // Get file references
     this._sessionFile = Services.dirsvc.get("ProfD", Ci.nsILocalFile);
     this._sessionFileBackup = this._sessionFile.clone();
     this._sessionCache = this._sessionFile.clone();
     this._sessionFile.append("sessionstore.js");
     this._sessionFileBackup.append("sessionstore.bak");
     this._sessionCache.append("sessionstoreCache");
 
@@ -170,32 +170,32 @@ SessionStore.prototype = {
 
     // Do we need to restore session just this once, in case of a restart?
     if (Services.prefs.getBoolPref("browser.sessionstore.resume_session_once")) {
       Services.prefs.setBoolPref("browser.sessionstore.resume_session_once", false);
       this._shouldRestore = true;
     }
   },
 
-  _clearDisk: function ss_clearDisk() {
+  _clearDisk: function() {
     if (this._sessionFile.exists()) {
       try {
         this._sessionFile.remove(false);
       } catch (ex) { dump(ex + '\n'); } // couldn't remove the file - what now?
     }
     if (this._sessionFileBackup.exists()) {
       try {
         this._sessionFileBackup.remove(false);
       } catch (ex) { dump(ex + '\n'); } // couldn't remove the file - what now?
     }
 
     this._clearCache();
   },
 
-  _clearCache: function ss_clearCache() {
+  _clearCache: function() {
     // First, let's get a list of files we think should be active
     let activeFiles = [];
     this._forEachBrowserWindow(function(aWindow) {
       let tabs = aWindow.Browser.tabs;
       for (let i = 0; i < tabs.length; i++) {
         let browser = tabs[i].browser;
         if (browser.__SS_extdata && "thumbnail" in browser.__SS_extdata)
           activeFiles.push(browser.__SS_extdata.thumbnail);
@@ -221,17 +221,17 @@ SessionStore.prototype = {
 
   _getTabStats: function() {
     return {
       currTabCount: this._currTabCount,
       maxTabCount: this._maxTabsOpen
     };
   },
 
-  observe: function ss_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     let self = this;
     let observerService = Services.obs;
     switch (aTopic) {
       case "app-startup":
         observerService.addObserver(this, "final-ui-startup", true);
         observerService.addObserver(this, "domwindowopened", true);
         observerService.addObserver(this, "domwindowclosed", true);
         observerService.addObserver(this, "browser-lastwindow-close-granted", true);
@@ -347,17 +347,17 @@ SessionStore.prototype = {
 
   updateTabTelemetryVars: function(window) {
     this._currTabCount = window.Browser.tabs.length;
       if (this._currTabCount > this._maxTabsOpen) {
         this._maxTabsOpen = this._currTabCount;
       }
   },
 
-  handleEvent: function ss_handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     let window = aEvent.currentTarget.ownerDocument.defaultView;
     switch (aEvent.type) {
       case "load":
         browser = aEvent.currentTarget;
         if (aEvent.target == browser.contentDocument && browser.__SS_tabFormData) {
           browser.messageManager.sendAsyncMessage("SessionStore:restoreSessionTabData", {
             formdata: browser.__SS_tabFormData.formdata,
             scroll: browser.__SS_tabFormData.scroll
@@ -385,33 +385,33 @@ SessionStore.prototype = {
       case "TabSelect": {
         let browser = aEvent.originalTarget.linkedBrowser;
         this.onTabSelect(window, browser);
         break;
       }
     }
   },
 
-  receiveMessage: function ss_receiveMessage(aMessage) {
+  receiveMessage: function(aMessage) {
     let browser = aMessage.target;
     switch (aMessage.name) {
       case "SessionStore:collectFormdata":
         browser.__SS_data.formdata = aMessage.json.data;
         break;
       case "SessionStore:collectScrollPosition":
         browser.__SS_data.scroll = aMessage.json.data;
         break;
       default:
         let window = aMessage.target.ownerDocument.defaultView;
         this.onTabLoad(window, aMessage.target, aMessage);
         break;
     }
   },
 
-  onWindowOpen: function ss_onWindowOpen(aWindow) {
+  onWindowOpen: function(aWindow) {
     // Return if window has already been initialized
     if (aWindow && aWindow.__SSID && this._windows[aWindow.__SSID])
       return;
 
     // Ignore non-browser windows and windows opened while shutting down
     if (aWindow.document.documentElement.getAttribute("windowtype") != "navigator:browser" || this._loadState == STATE_QUITTING)
       return;
 
@@ -440,17 +440,17 @@ SessionStore.prototype = {
     // Notification of tab add/remove/selection
     let tabContainer = aWindow.document.getElementById("tabs");
     tabContainer.addEventListener("TabOpen", this, true);
     tabContainer.addEventListener("TabClose", this, true);
     tabContainer.addEventListener("TabRemove", this, true);
     tabContainer.addEventListener("TabSelect", this, true);
   },
 
-  onWindowClose: function ss_onWindowClose(aWindow) {
+  onWindowClose: function(aWindow) {
     // Ignore windows not tracked by SessionStore
     if (!aWindow.__SSID || !this._windows[aWindow.__SSID])
       return;
 
     let tabContainer = aWindow.document.getElementById("tabs");
     tabContainer.removeEventListener("TabOpen", this, true);
     tabContainer.removeEventListener("TabClose", this, true);
     tabContainer.removeEventListener("TabRemove", this, true);
@@ -469,44 +469,44 @@ SessionStore.prototype = {
 
     let tabs = aWindow.Browser.tabs;
     for (let i = 0; i < tabs.length; i++)
       this.onTabRemove(aWindow, tabs[i].browser, true);
 
     delete aWindow.__SSID;
   },
 
-  onTabAdd: function ss_onTabAdd(aWindow, aBrowser, aNoNotification) {
+  onTabAdd: function(aWindow, aBrowser, aNoNotification) {
     aBrowser.messageManager.addMessageListener("pageshow", this);
     aBrowser.messageManager.addMessageListener("Content:SessionHistory", this);
     aBrowser.messageManager.addMessageListener("SessionStore:collectFormdata", this);
     aBrowser.messageManager.addMessageListener("SessionStore:collectScrollPosition", this);
 
     if (!aNoNotification)
       this.saveStateDelayed();
     this._updateCrashReportURL(aWindow);
   },
 
-  onTabRemove: function ss_onTabRemove(aWindow, aBrowser, aNoNotification) {
+  onTabRemove: function(aWindow, aBrowser, aNoNotification) {
     aBrowser.messageManager.removeMessageListener("pageshow", this);
     aBrowser.messageManager.removeMessageListener("Content:SessionHistory", this);
     aBrowser.messageManager.removeMessageListener("SessionStore:collectFormdata", this);
     aBrowser.messageManager.removeMessageListener("SessionStore:collectScrollPosition", this);
 
     // If this browser is being restored, skip any session save activity
     if (aBrowser.__SS_restore)
       return;
 
     delete aBrowser.__SS_data;
 
     if (!aNoNotification)
       this.saveStateDelayed();
   },
 
-  onTabClose: function ss_onTabClose(aWindow, aBrowser) {
+  onTabClose: function(aWindow, aBrowser) {
     if (this._maxTabsUndo == 0)
       return;
 
     if (aWindow.Browser.tabs.length > 0) {
       // Bundle this browser's data and extra data and save in the closedTabs
       // window property
       //
       // NB: The access to aBrowser.__SS_extdata throws during automation (in
@@ -519,17 +519,17 @@ SessionStore.prototype = {
 
       this._windows[aWindow.__SSID]._closedTabs.unshift({ state: data });
       let length = this._windows[aWindow.__SSID]._closedTabs.length;
       if (length > this._maxTabsUndo)
         this._windows[aWindow.__SSID]._closedTabs.splice(this._maxTabsUndo, length - this._maxTabsUndo);
     }
   },
 
-  onTabLoad: function ss_onTabLoad(aWindow, aBrowser, aMessage) {
+  onTabLoad: function(aWindow, aBrowser, aMessage) {
     // If this browser is being restored, skip any session save activity
     if (aBrowser.__SS_restore)
       return;
 
     // Ignore a transient "about:blank"
     if (!aBrowser.canGoBack && aBrowser.currentURI.spec == "about:blank")
       return;
 
@@ -540,17 +540,17 @@ SessionStore.prototype = {
 
     // Save out the state as quickly as possible
     if (aMessage.name == "pageshow")
       this.saveStateNow();
 
     this._updateCrashReportURL(aWindow);
   },
 
-  onTabSelect: function ss_onTabSelect(aWindow, aBrowser) {
+  onTabSelect: function(aWindow, aBrowser) {
     if (this._loadState != STATE_RUNNING)
       return;
 
     let index = aWindow.Elements.browsers.selectedIndex;
     this._windows[aWindow.__SSID].selected = parseInt(index) + 1; // 1-based
 
     // Restore the resurrected browser
     if (aBrowser.__SS_restore) {
@@ -566,67 +566,67 @@ SessionStore.prototype = {
       }
 
       delete aBrowser.__SS_restore;
     }
 
     this._updateCrashReportURL(aWindow);
   },
 
-  saveStateDelayed: function ss_saveStateDelayed() {
+  saveStateDelayed: function() {
     if (!this._saveTimer) {
       // Interval until the next disk operation is allowed
       let minimalDelay = this._lastSaveTime + this._interval - Date.now();
 
       // If we have to wait, set a timer, otherwise saveState directly
       let delay = Math.max(minimalDelay, 2000);
       if (delay > 0) {
         this._saveTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
         this._saveTimer.init(this, delay, Ci.nsITimer.TYPE_ONE_SHOT);
       } else {
         this.saveState();
       }
     }
   },
 
-  saveStateNow: function ss_saveStateNow() {
+  saveStateNow: function() {
     // Kill any queued timer and save immediately
     if (this._saveTimer) {
       this._saveTimer.cancel();
       this._saveTimer = null;
     }
     this.saveState();
   },
 
-  saveState: function ss_saveState() {
+  saveState: function() {
     let data = this._getCurrentState();
     // sanity check before we overwrite the session file
     if (data.windows && data.windows.length && data.selectedWindow) {
       this._writeFile(this._sessionFile, JSON.stringify(data));
 
       this._lastSaveTime = Date.now();
     } else {
       dump("SessionStore: Not saving state with invalid data: " + JSON.stringify(data) + "\n");
     }
   },
 
-  _getCurrentState: function ss_getCurrentState() {
+  _getCurrentState: function() {
     let self = this;
     this._forEachBrowserWindow(function(aWindow) {
       self._collectWindowData(aWindow);
     });
 
     let data = { windows: [] };
     for (let i = 0; i < this._orderedWindows.length; i++)
       data.windows.push(this._windows[this._orderedWindows[i]]);
     data.selectedWindow = this._selectedWindow;
     return data;
   },
 
-  _collectTabData: function ss__collectTabData(aBrowser, aHistory) {
+  _collectTabData: function(aBrowser, aHistory) {
     // If this browser is being restored, skip any session save activity
     if (aBrowser.__SS_restore)
       return;
 
     aHistory = aHistory || { entries: [{ url: aBrowser.currentURI.spec, title: aBrowser.contentTitle }], index: 1 };
 
     let tabData = {};
     tabData.entries = aHistory.entries;
@@ -643,40 +643,40 @@ SessionStore.prototype = {
         let browser = tab.browser;
         let tabData = browser.__SS_data;
         if (browser.__SS_extdata)
           tabData.extData = browser.__SS_extdata;
         return tabData;
       });
   },
 
-  _collectWindowData: function ss__collectWindowData(aWindow) {
+  _collectWindowData: function(aWindow) {
     // Ignore windows not tracked by SessionStore
     if (!aWindow.__SSID || !this._windows[aWindow.__SSID])
       return;
 
     let winData = this._windows[aWindow.__SSID];
 
     let index = aWindow.Elements.browsers.selectedIndex;
     winData.selected = parseInt(index) + 1; // 1-based
 
     let tabData = this._getTabData(aWindow);
     winData.tabs = tabData.concat(this._tabsFromOtherGroups);
   },
 
-  _forEachBrowserWindow: function ss_forEachBrowserWindow(aFunc) {
+  _forEachBrowserWindow: function(aFunc) {
     let windowsEnum = Services.wm.getEnumerator("navigator:browser");
     while (windowsEnum.hasMoreElements()) {
       let window = windowsEnum.getNext();
       if (window.__SSID && !window.closed)
         aFunc.call(this, window);
     }
   },
 
-  _writeFile: function ss_writeFile(aFile, aData) {
+  _writeFile: function(aFile, aData) {
     let stateString = Cc["@mozilla.org/supports-string;1"].createInstance(Ci.nsISupportsString);
     stateString.data = aData;
     Services.obs.notifyObservers(stateString, "sessionstore-state-write", "");
 
     // Don't touch the file if an observer has deleted all state data
     if (!stateString.data)
       return;
 
@@ -695,17 +695,17 @@ SessionStore.prototype = {
         if (Services.startup.shuttingDown) {
           Services.obs.notifyObservers(null, "sessionstore-final-state-write-complete", "");
         }
         Services.obs.notifyObservers(null, "sessionstore-state-write-complete", "");
       }
     });
   },
 
-  _updateCrashReportURL: function ss_updateCrashReportURL(aWindow) {
+  _updateCrashReportURL: function(aWindow) {
 #ifdef MOZ_CRASHREPORTER
     try {
       let currentURI = aWindow.Browser.selectedBrowser.currentURI.clone();
       // if the current URI contains a username/password, remove it
       try {
         currentURI.userPass = "";
       }
       catch (ex) { } // ignore failures on about: URIs
@@ -715,36 +715,36 @@ SessionStore.prototype = {
     catch (ex) {
       // don't make noise when crashreporter is built but not enabled
       if (ex.result != Components.results.NS_ERROR_NOT_INITIALIZED)
         Components.utils.reportError("SessionStore:" + ex);
     }
 #endif
   },
 
-  getBrowserState: function ss_getBrowserState() {
+  getBrowserState: function() {
     let data = this._getCurrentState();
     return JSON.stringify(data);
   },
 
-  getClosedTabCount: function ss_getClosedTabCount(aWindow) {
+  getClosedTabCount: function(aWindow) {
     if (!aWindow || !aWindow.__SSID)
       return 0; // not a browser window, or not otherwise tracked by SS.
 
     return this._windows[aWindow.__SSID]._closedTabs.length;
   },
 
-  getClosedTabData: function ss_getClosedTabData(aWindow) {
+  getClosedTabData: function(aWindow) {
     if (!aWindow.__SSID)
       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
 
     return JSON.stringify(this._windows[aWindow.__SSID]._closedTabs);
   },
 
-  undoCloseTab: function ss_undoCloseTab(aWindow, aIndex) {
+  undoCloseTab: function(aWindow, aIndex) {
     if (!aWindow.__SSID)
       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
 
     let closedTabs = this._windows[aWindow.__SSID]._closedTabs;
     if (!closedTabs)
       return null;
 
     // default to the most-recently closed tab
@@ -766,38 +766,38 @@ SessionStore.prototype = {
     });
 
     // Put back the extra data
     tab.browser.__SS_extdata = closedTab.extData;
 
     return tab.chromeTab;
   },
 
-  forgetClosedTab: function ss_forgetClosedTab(aWindow, aIndex) {
+  forgetClosedTab: function(aWindow, aIndex) {
     if (!aWindow.__SSID)
       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
 
     let closedTabs = this._windows[aWindow.__SSID]._closedTabs;
 
     // default to the most-recently closed tab
     aIndex = aIndex || 0;
     if (!(aIndex in closedTabs))
       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
 
     // remove closed tab from the array
     closedTabs.splice(aIndex, 1);
   },
 
-  getTabValue: function ss_getTabValue(aTab, aKey) {
+  getTabValue: function(aTab, aKey) {
     let browser = aTab.linkedBrowser;
     let data = browser.__SS_extdata || {};
     return data[aKey] || "";
   },
 
-  setTabValue: function ss_setTabValue(aTab, aKey, aStringValue) {
+  setTabValue: function(aTab, aKey, aStringValue) {
     let browser = aTab.linkedBrowser;
 
     // Thumbnails are actually stored in the cache, so do the save and update the URI
     if (aKey == "thumbnail") {
       let file = this._sessionCache.clone();
       file.append("thumbnail-" + browser.contentWindowId);
       file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0600);
 
@@ -812,29 +812,29 @@ SessionStore.prototype = {
     }
 
     if (!browser.__SS_extdata)
       browser.__SS_extdata = {};
     browser.__SS_extdata[aKey] = aStringValue;
     this.saveStateDelayed();
   },
 
-  deleteTabValue: function ss_deleteTabValue(aTab, aKey) {
+  deleteTabValue: function(aTab, aKey) {
     let browser = aTab.linkedBrowser;
     if (browser.__SS_extdata && browser.__SS_extdata[aKey])
       delete browser.__SS_extdata[aKey];
     else
       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
   },
 
-  shouldRestore: function ss_shouldRestore() {
+  shouldRestore: function() {
     return this._shouldRestore || (3 == Services.prefs.getIntPref("browser.startup.page"));
   },
 
-  restoreLastSession: function ss_restoreLastSession(aBringToFront) {
+  restoreLastSession: function(aBringToFront) {
     let self = this;
     function notifyObservers(aMessage) {
       self._clearCache();
       Services.obs.notifyObservers(null, "sessionstore-windows-restored", aMessage || "");
     }
 
     // The previous session data has already been renamed to the backup file
     if (!this._sessionFileBackup.exists()) {
diff --git a/browser/metro/components/Sidebar.js b/browser/metro/components/Sidebar.js
--- a/browser/metro/components/Sidebar.js
+++ b/browser/metro/components/Sidebar.js
@@ -37,17 +37,17 @@ function Sidebar() {
 
     this.inContentProcess = true;
     this.messageManager = Cc["@mozilla.org/childprocessmessagemanager;1"].getService(Ci.nsISyncMessageSender);
   }
 }
 
 Sidebar.prototype = {
   // =========================== utility code ===========================
-  _validateSearchEngine: function validateSearchEngine(engineURL, iconURL) {
+  _validateSearchEngine: function(engineURL, iconURL) {
     try {
       // Make sure we're using HTTP, HTTPS, or FTP.
       if (! /^(https?|ftp):\/\//i.test(engineURL))
         throw "Unsupported search engine URL";
     
       // Make sure we're using HTTP, HTTPS, or FTP and refering to a
       // .gif/.jpg/.jpeg/.png/.ico file for the icon.
       if (iconURL &&
@@ -89,17 +89,17 @@ Sidebar.prototype = {
       dataType = Ci.nsISearchEngine.DATA_XML;
 
     Services.search.addEngine(engineURL, dataType, iconURL, true);
   },
 
   // This function exists to implement window.external.AddSearchProvider(),
   // to match other browsers' APIs.  The capitalization, although nonstandard here,
   // is therefore important.
-  AddSearchProvider: function AddSearchProvider(aDescriptionURL) {
+  AddSearchProvider: function(aDescriptionURL) {
     if (!this._validateSearchEngine(aDescriptionURL, ""))
       return;
 
     if (this.inContentProcess) {
       this.messageManager.sendAsyncMessage("Sidebar:AddSearchProvider",
         { descriptionURL: aDescriptionURL });
       return;
     }
@@ -111,17 +111,17 @@ Sidebar.prototype = {
   // This function exists to implement window.external.IsSearchProviderInstalled(),
   // for compatibility with other browsers.  It will return an integer value
   // indicating whether the given engine is installed for the current user.
   // However, it is currently stubbed out due to security/privacy concerns
   // stemming from difficulties in determining what domain issued the request.
   // See bug 340604 and
   // http://msdn.microsoft.com/en-us/library/aa342526%28VS.85%29.aspx .
   // XXX Implement this!
-  IsSearchProviderInstalled: function IsSearchProviderInstalled(aSearchURL) {
+  IsSearchProviderInstalled: function(aSearchURL) {
     return 0;
   },
 
   // =========================== nsISupports ===========================
   QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),
 
   // XPCOMUtils stuff
   classID: SIDEBAR_CID,
diff --git a/browser/metro/modules/ContentUtil.jsm b/browser/metro/modules/ContentUtil.jsm
--- a/browser/metro/modules/ContentUtil.jsm
+++ b/browser/metro/modules/ContentUtil.jsm
@@ -4,17 +4,17 @@
 "use strict";
 
 this.EXPORTED_SYMBOLS = ["ContentUtil"];
 
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const nsIDOMKeyEvent = Components.interfaces.nsIDOMKeyEvent;
 
 this.ContentUtil = {
-  populateFragmentFromString: function populateFragmentFromString(fragment, str) {
+  populateFragmentFromString: function(fragment, str) {
     let re = /^([^#]*)#(\d+)\b([^#]*)/,
         document = fragment.ownerDocument,
         // the remaining arguments are our {text, className} values
         replacements = Array.slice(arguments, 2),
         match;
 
     // walk over the string, building textNode/spans as nec. with replacement content
     // note that #1,#2 etc. may not appear in numerical order in the string
@@ -49,17 +49,17 @@ this.ContentUtil = {
     if(str)
       fragment.appendChild(document.createTextNode(str));
 
     return fragment;
   },
 
   // Pass several objects in and it will combine them all into the first object and return it.
   // NOTE: Deep copy is not supported
-  extend: function extend() {
+  extend: function() {
     // copy reference to target object
     let target = arguments[0] || {};
     let length = arguments.length;
 
     if (length === 1) {
       return target;
     }
 
diff --git a/browser/metro/modules/CrossSlide.jsm b/browser/metro/modules/CrossSlide.jsm
--- a/browser/metro/modules/CrossSlide.jsm
+++ b/browser/metro/modules/CrossSlide.jsm
@@ -127,17 +127,17 @@ CrossSlideHandler.prototype = {
     }
     if (aCrossAxisDistance < this.thresholds.REARRANGESTART) {
       return CrossSlidingState.SPEED_BUMPING;
     }
     // out of bounds cross-slide
     return -1;
   },
 
-  handleEvent: function handleEvent(aEvent) {
+  handleEvent: function(aEvent) {
     switch (aEvent.type) {
       case "touchstart":
         this._onTouchStart(aEvent);
         break;
       case "touchmove":
         this._onTouchMove(aEvent);
         break;
       case "scroll":
@@ -242,17 +242,17 @@ CrossSlideHandler.prototype = {
     this.drag = null;
   },
 
   /**
    * Dispatches a custom Event on the drag node.
    * @param aEvent The source event.
    * @param aType The event type.
    */
-  _fireProgressEvent: function CrossSliding_fireEvent(aState, aEvent) {
+  _fireProgressEvent: function(aState, aEvent) {
     if (!this.drag)
       return;
     let event = this.node.ownerDocument.createEvent("Events");
     let crossAxisName = this.drag.crossAxis;
     event.initEvent("MozCrossSliding", true, true);
     event.crossSlidingState = aState;
     if ('position' in this.drag) {
       event.position = this.drag.position;
@@ -265,16 +265,16 @@ CrossSlideHandler.prototype = {
     }
     aEvent.target.dispatchEvent(event);
   },
 
   /**
    * Dispatches a custom Event on the given target node.
    * @param aEvent The source event.
    */
-  _fireSelectEvent: function SelectTarget_fireEvent(aEvent) {
+  _fireSelectEvent: function(aEvent) {
     let event = this.node.ownerDocument.createEvent("Events");
     event.initEvent("MozCrossSlideSelect", true, true);
     event.position = this.drag.position;
     aEvent.target.dispatchEvent(event);
   }
 };
 this.CrossSlide.Handler = CrossSlideHandler;
diff --git a/browser/metro/modules/View.jsm b/browser/metro/modules/View.jsm
--- a/browser/metro/modules/View.jsm
+++ b/browser/metro/modules/View.jsm
@@ -61,17 +61,17 @@ View.prototype = {
 
   destruct: function () {
     this._window.removeEventListener("resize", this.onResize);
     if (this._tilePrefName != "unknown") {
       Services.prefs.removeObserver(this._tilePrefName, this);
     }
   },
 
-  _adjustDOMforViewState: function _adjustDOMforViewState(aState) {
+  _adjustDOMforViewState: function(aState) {
     let grid = this._set;
     if (!grid) {
       return;
     }
     if (!aState) {
       aState = grid.getAttribute("viewstate");
     }
     switch (aState) {
@@ -90,24 +90,24 @@ View.prototype = {
         grid.removeAttribute("vertical");
         grid.enableCrossSlide();
     }
     if ("arrangeItems" in grid) {
       grid.arrangeItems();
     }
   },
 
-  _updateFavicon: function pv__updateFavicon(aItem, aUri) {
+  _updateFavicon: function(aItem, aUri) {
     if ("string" == typeof aUri) {
       aUri = makeURI(aUri);
     }
     PlacesUtils.favicons.getFaviconURLForPage(aUri, this._gotIcon.bind(this, aItem));
   },
 
-  _gotIcon: function pv__gotIcon(aItem, aIconUri) {
+  _gotIcon: function(aItem, aIconUri) {
     if (!aIconUri) {
       aItem.removeAttribute("iconURI");
       if (aItem.refresh) {
         aItem.refresh();
       }
       return;
     }
     if ("string" == typeof aIconUri) {
diff --git a/browser/metro/modules/colorUtils.jsm b/browser/metro/modules/colorUtils.jsm
--- a/browser/metro/modules/colorUtils.jsm
+++ b/browser/metro/modules/colorUtils.jsm
@@ -57,17 +57,17 @@ let ColorUtils = {
         break;
     }
   },
 
   /** Takes an icon and returns either an object with foreground and background color properties
    *  or a promise for the same.
    *  The foreground is the contrast color, the background is the primary/dominant one
    */
-  getForegroundAndBackgroundIconColors: function getForegroundAndBackgroundIconColors(aIconURI) {
+  getForegroundAndBackgroundIconColors: function(aIconURI) {
     let colorKey = aIconURI.spec;
     let colorInfo = this._uriColorsMap.get(colorKey);
     if (colorInfo) {
       return colorInfo;
     }
 
     let deferred = Promise.defer();
     let wrappedIcon = aIconURI;
@@ -88,79 +88,79 @@ let ColorUtils = {
     });
     return deferred.promise;
   },
 
   /** returns the best color for text readability on top of aColor
    * return color is in rgb(r,g,b) format, suitable to csss
    * The color bightness algorithm is currently: http://www.w3.org/TR/AERT#color-contrast
    */
-  bestTextColorForContrast: function bestTextColorForContrast(aColor) {
+  bestTextColorForContrast: function(aColor) {
     let r = (aColor & 0xff0000) >> 16;
     let g = (aColor & 0x00ff00) >> 8;
     let b = (aColor & 0x0000ff);
 
     let w3cContrastValue = ((r*299)+(g*587)+(b*114))/1000;
     w3cContrastValue = Math.round(w3cContrastValue);
     let textColor = "rgb(255,255,255)";
 
     if (w3cContrastValue > 125) {
       // bright/light, use black text
       textColor = "rgb(0,0,0)";
     }
     return textColor;
   },
 
-  toCSSRgbColor: function toCSSRgbColor(r, g, b, a) {
+  toCSSRgbColor: function(r, g, b, a) {
     var values = [Math.round(r), Math.round(g), Math.round(b)];
     if (undefined !== a && a < 1) {
       values.push(a);
       return 'rgba('+values.join(',')+')';
     }
     return 'rgb('+values.join(',')+')';
   },
 
   /**
    * converts a decimal(base10) number into CSS rgb color value string
    */
-  convertDecimalToRgbColor: function convertDecimalToRgbColor(aColor) {
+  convertDecimalToRgbColor: function(aColor) {
     let [r,g,b,a] = this.unpackDecimalColorWord(aColor);
     return this.toCSSRgbColor(r,g,b,a);
   },
 
   /**
    * unpack a decimal(base10) word for r,g,b,a values
    */
-  unpackDecimalColorWord: function unpackDecimalColorWord(aColor) {
+  unpackDecimalColorWord: function(aColor) {
     let a = (aColor & 0xff000000) >> 24;
     let r = (aColor & 0x00ff0000) >> 16;
     let g = (aColor & 0x0000ff00) >> 8;
     let b = (aColor & 0x000000ff);
     // NB: falsy alpha treated as undefined, fully opaque
     return a ? [r,g,b,a/255] : [r,g,b];
   },
 
   /**
    * create a decimal(base10) word for r,g,b values
    */
-  createDecimalColorWord: function createDecimalColorWord(r, g, b, a) {
+  createDecimalColorWord: function(r, g, b, a) {
     let rgb = 0;
     rgb |= b;
     rgb |= (g << 8);
     rgb |= (r << 16);
     // pack alpha value if one is given
     if (undefined !== a && a < 1)
       rgb |= (Math.round(a*255) << 24);
     return rgb;
   },
 
   /**
    * Add 2 rgb(a) colors to get a flat color
    */
-  addRgbColors: function addRgbColors(color1, color2) {
+  addRgbColors: function(color1, color2) {
     let [r1, g1, b1] = this.unpackDecimalColorWord(color1);
     let [r2, g2, b2, alpha] = this.unpackDecimalColorWord(color2);
 
     let color = {};
     // early return if 2nd color is opaque
     if (!alpha || alpha >= 1)
       return color2;
 
diff --git a/browser/modules/DirectoryLinksProvider.jsm b/browser/modules/DirectoryLinksProvider.jsm
--- a/browser/modules/DirectoryLinksProvider.jsm
+++ b/browser/modules/DirectoryLinksProvider.jsm
@@ -133,31 +133,31 @@ let DirectoryLinksProvider = {
     catch (e) {}
 
     return "en-US";
   },
 
   /**
    * Set appropriate default ping behavior controlled by enhanced pref
    */
-  _setDefaultEnhanced: function DirectoryLinksProvider_setDefaultEnhanced() {
+  _setDefaultEnhanced: function() {
     if (!Services.prefs.prefHasUserValue(PREF_NEWTAB_ENHANCED)) {
       let enhanced = true;
       try {
         // Default to not enhanced if DNT is set to tell websites to not track
         if (Services.prefs.getBoolPref("privacy.donottrackheader.enabled")) {
           enhanced = false;
         }
       }
       catch(ex) {}
       Services.prefs.setBoolPref(PREF_NEWTAB_ENHANCED, enhanced);
     }
   },
 
-  observe: function DirectoryLinksProvider_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     if (aTopic == "nsPref:changed") {
       switch (aData) {
         // Re-set the default in case the user clears the pref
         case this._observedPrefs.enhanced:
           this._setDefaultEnhanced();
           break;
 
         case this._observedPrefs.linksURL:
@@ -168,31 +168,31 @@ let DirectoryLinksProvider = {
         case this._observedPrefs.matchOSLocale:
         case this._observedPrefs.prefSelectedLocale:
           this._fetchAndCacheLinksIfNecessary(true);
           break;
       }
     }
   },
 
-  _addPrefsObserver: function DirectoryLinksProvider_addObserver() {
+  _addPrefsObserver: function() {
     for (let pref in this._observedPrefs) {
       let prefName = this._observedPrefs[pref];
       Services.prefs.addObserver(prefName, this, false);
     }
   },
 
-  _removePrefsObserver: function DirectoryLinksProvider_removeObserver() {
+  _removePrefsObserver: function() {
     for (let pref in this._observedPrefs) {
       let prefName = this._observedPrefs[pref];
       Services.prefs.removeObserver(prefName, this);
     }
   },
 
-  _fetchAndCacheLinks: function DirectoryLinksProvider_fetchAndCacheLinks(uri) {
+  _fetchAndCacheLinks: function(uri) {
     // Replace with the same display locale used for selecting links data
     uri = uri.replace("%LOCALE%", this.locale);
 
     let deferred = Promise.defer();
     let xmlHttp = new XMLHttpRequest();
 
     let self = this;
     xmlHttp.onload = function(aResponse) {
@@ -226,17 +226,17 @@ let DirectoryLinksProvider = {
     }
     return deferred.promise;
   },
 
   /**
    * Downloads directory links if needed
    * @return promise resolved immediately if no download needed, or upon completion
    */
-  _fetchAndCacheLinksIfNecessary: function DirectoryLinksProvider_fetchAndCacheLinksIfNecessary(forceDownload=false) {
+  _fetchAndCacheLinksIfNecessary: function(forceDownload=false) {
     if (this._downloadDeferred) {
       // fetching links already - just return the promise
       return this._downloadDeferred.promise;
     }
 
     if (forceDownload || this._needsDownload) {
       this._downloadDeferred = Promise.defer();
       this._fetchAndCacheLinks(this._linksURL).then(() => {
@@ -268,17 +268,17 @@ let DirectoryLinksProvider = {
     }
     return false;
   },
 
   /**
    * Reads directory links file and parses its content
    * @return a promise resolved to valid list of links or [] if read or parse fails
    */
-  _readDirectoryLinksFile: function DirectoryLinksProvider_readDirectoryLinksFile() {
+  _readDirectoryLinksFile: function() {
     return OS.File.read(this._directoryFilePath).then(binaryData => {
       let output;
       try {
         let locale = this.locale;
         let json = gTextDecoder.decode(binaryData);
         let list = JSON.parse(json);
         output = list[locale];
       }
@@ -295,17 +295,17 @@ let DirectoryLinksProvider = {
 
   /**
    * Report some action on a newtab page (view, click)
    * @param sites Array of sites shown on newtab page
    * @param action String of the behavior to report
    * @param triggeringSiteIndex optional Int index of the site triggering action
    * @return download promise
    */
-  reportSitesAction: function DirectoryLinksProvider_reportSitesAction(sites, action, triggeringSiteIndex) {
+  reportSitesAction: function(sites, action, triggeringSiteIndex) {
     let newtabEnhanced = false;
     let pingEndPoint = "";
     try {
       newtabEnhanced = Services.prefs.getBoolPref(PREF_NEWTAB_ENHANCED);
       pingEndPoint = Services.prefs.getCharPref(PREF_DIRECTORY_PING);
     }
     catch (ex) {}
 
@@ -354,26 +354,26 @@ let DirectoryLinksProvider = {
 
     // Use this as an opportunity to potentially fetch new links
     return this._fetchAndCacheLinksIfNecessary();
   },
 
   /**
    * Get the enhanced link object for a link (whether history or directory)
    */
-  getEnhancedLink: function DirectoryLinksProvider_getEnhancedLink(link) {
+  getEnhancedLink: function(link) {
     // Use the provided link if it's already enhanced
     return link.enhancedImageURI && link ||
            this._enhancedLinks.get(NewTabUtils.extractSite(link.url));
   },
 
   /**
    * Check if a url's scheme is in a Set of allowed schemes
    */
-  isURLAllowed: function DirectoryLinksProvider_isURLAllowed(url, allowed) {
+  isURLAllowed: function(url, allowed) {
     // Assume no url is an allowed url
     if (!url) {
       return true;
     }
 
     let scheme = "";
     try {
       // A malformed url will not be allowed
@@ -382,17 +382,17 @@ let DirectoryLinksProvider = {
     catch(ex) {}
     return allowed.has(scheme);
   },
 
   /**
    * Gets the current set of directory links.
    * @param aCallback The function that the array of links is passed to.
    */
-  getLinks: function DirectoryLinksProvider_getLinks(aCallback) {
+  getLinks: function(aCallback) {
     this._readDirectoryLinksFile().then(rawLinks => {
       // Reset the cache of enhanced images for this new set of links
       this._enhancedLinks.clear();
 
       return rawLinks.filter(link => {
         // Make sure the link url is allowed and images too if they exist
         return this.isURLAllowed(link.url, ALLOWED_LINK_SCHEMES) &&
                this.isURLAllowed(link.imageURI, ALLOWED_IMAGE_SCHEMES) &&
@@ -408,17 +408,17 @@ let DirectoryLinksProvider = {
         return link;
       });
     }).catch(ex => {
       Cu.reportError(ex);
       return [];
     }).then(aCallback);
   },
 
-  init: function DirectoryLinksProvider_init() {
+  init: function() {
     this._setDefaultEnhanced();
     this._addPrefsObserver();
     // setup directory file path and last download timestamp
     this._directoryFilePath = OS.Path.join(OS.Constants.Path.localProfileDir, DIRECTORY_LINKS_FILE);
     this._lastDownloadMS = 0;
     return Task.spawn(function() {
       // get the last modified time of the links file if it exists
       let doesFileExists = yield OS.File.exists(this._directoryFilePath);
@@ -429,31 +429,31 @@ let DirectoryLinksProvider = {
       // fetch directory on startup without force
       yield this._fetchAndCacheLinksIfNecessary();
     }.bind(this));
   },
 
   /**
    * Return the object to its pre-init state
    */
-  reset: function DirectoryLinksProvider_reset() {
+  reset: function() {
     delete this.__linksURL;
     this._removePrefsObserver();
     this._removeObservers();
   },
 
-  addObserver: function DirectoryLinksProvider_addObserver(aObserver) {
+  addObserver: function(aObserver) {
     this._observers.add(aObserver);
   },
 
-  removeObserver: function DirectoryLinksProvider_removeObserver(aObserver) {
+  removeObserver: function(aObserver) {
     this._observers.delete(aObserver);
   },
 
-  _callObservers: function DirectoryLinksProvider__callObservers(aMethodName, aArg) {
+  _callObservers: function(aMethodName, aArg) {
     for (let obs of this._observers) {
       if (typeof(obs[aMethodName]) == "function") {
         try {
           obs[aMethodName](this, aArg);
         } catch (err) {
           Cu.reportError(err);
         }
       }
diff --git a/browser/modules/NetworkPrioritizer.jsm b/browser/modules/NetworkPrioritizer.jsm
--- a/browser/modules/NetworkPrioritizer.jsm
+++ b/browser/modules/NetworkPrioritizer.jsm
@@ -60,44 +60,44 @@ function _handleEvent(aEvent) {
       WindowHelper.removeWindow(aEvent.currentTarget);
       break;
   }
 }
 
 
 // Methods that impact a browser. Put into single object for organization.
 let BrowserHelper = {
-  onOpen: function NP_BH_onOpen(aBrowser) {
+  onOpen: function(aBrowser) {
     // If the tab is in the focused window, leave priority as it is
     if (aBrowser.ownerDocument.defaultView != _lastFocusedWindow)
       this.decreasePriority(aBrowser);
   },
 
-  onSelect: function NP_BH_onSelect(aBrowser) {
+  onSelect: function(aBrowser) {
     let windowEntry = WindowHelper.getEntry(aBrowser.ownerDocument.defaultView);
     if (windowEntry.lastSelectedBrowser)
       this.decreasePriority(windowEntry.lastSelectedBrowser);
     this.increasePriority(aBrowser);
 
     windowEntry.lastSelectedBrowser = aBrowser;
   },
 
-  increasePriority: function NP_BH_increasePriority(aBrowser) {
+  increasePriority: function(aBrowser) {
     aBrowser.adjustPriority(PRIORITY_DELTA);
   },
 
-  decreasePriority: function NP_BH_decreasePriority(aBrowser) {
+  decreasePriority: function(aBrowser) {
     aBrowser.adjustPriority(PRIORITY_DELTA * -1);
   }
 };
 
 
 // Methods that impact a window. Put into single object for organization.
 let WindowHelper = {
-  addWindow: function NP_WH_addWindow(aWindow) {
+  addWindow: function(aWindow) {
     // Build internal data object
     _windows.push({ window: aWindow, lastSelectedBrowser: null });
 
     // Add event listeners
     TAB_EVENTS.forEach(function(event) {
       aWindow.gBrowser.tabContainer.addEventListener(event, _handleEvent, false);
     });
     WINDOW_EVENTS.forEach(function(event) {
@@ -110,70 +110,70 @@ let WindowHelper = {
       this.handleFocusedWindow(aWindow);
     else
       this.decreasePriority(aWindow);
 
     // Select the selected tab
     BrowserHelper.onSelect(aWindow.gBrowser.selectedBrowser);
   },
 
-  removeWindow: function NP_WH_removeWindow(aWindow) {
+  removeWindow: function(aWindow) {
     if (aWindow == _lastFocusedWindow)
       _lastFocusedWindow = null;
 
     // Delete this window from our tracking
     _windows.splice(this.getEntryIndex(aWindow), 1);
 
     // Remove the event listeners
     TAB_EVENTS.forEach(function(event) {
       aWindow.gBrowser.tabContainer.removeEventListener(event, _handleEvent, false);
     });
     WINDOW_EVENTS.forEach(function(event) {
       aWindow.removeEventListener(event, _handleEvent, false);
     });
   },
 
-  onActivate: function NP_WH_onActivate(aWindow, aHasFocus) {
+  onActivate: function(aWindow, aHasFocus) {
     // If this window was the last focused window, we don't need to do anything
     if (aWindow == _lastFocusedWindow)
       return;
 
     // handleFocusedWindow will deprioritize the current window
     this.handleFocusedWindow(aWindow);
 
     // Lastly we should increase priority for this window
     this.increasePriority(aWindow);
   },
 
-  handleFocusedWindow: function NP_WH_handleFocusedWindow(aWindow) {
+  handleFocusedWindow: function(aWindow) {
     // If we have a last focused window, we need to deprioritize it first
     if (_lastFocusedWindow)
       this.decreasePriority(_lastFocusedWindow);
 
     // aWindow is now focused
     _lastFocusedWindow = aWindow;
   },
 
   // Auxiliary methods
-  increasePriority: function NP_WH_increasePriority(aWindow) {
+  increasePriority: function(aWindow) {
     aWindow.gBrowser.browsers.forEach(function(aBrowser) {
       BrowserHelper.increasePriority(aBrowser);
     });
   },
 
-  decreasePriority: function NP_WH_decreasePriority(aWindow) {
+  decreasePriority: function(aWindow) {
     aWindow.gBrowser.browsers.forEach(function(aBrowser) {
       BrowserHelper.decreasePriority(aBrowser);
     });
   },
 
-  getEntry: function NP_WH_getEntry(aWindow) {
+  getEntry: function(aWindow) {
     return _windows[this.getEntryIndex(aWindow)];
   },
 
-  getEntryIndex: function NP_WH_getEntryAtIndex(aWindow) {
+  getEntryIndex: function(aWindow) {
     // Assumes that every object has a unique window & it's in the array
     for (let i = 0; i < _windows.length; i++)
       if (_windows[i].window == aWindow)
         return i;
   }
 };
 
diff --git a/browser/modules/PluginContent.jsm b/browser/modules/PluginContent.jsm
--- a/browser/modules/PluginContent.jsm
+++ b/browser/modules/PluginContent.jsm
@@ -513,17 +513,17 @@ PluginContent.prototype = {
   },
 
   // Forward a link click callback to the chrome process.
   forwardCallback: function (name) {
     this.global.sendAsyncMessage("PluginContent:LinkClickCallback", { name: name });
   },
 
 #ifdef MOZ_CRASHREPORTER
-  submitReport: function submitReport(pluginDumpID, browserDumpID, plugin) {
+  submitReport: function(pluginDumpID, browserDumpID, plugin) {
     let keyVals = {};
     if (plugin) {
       let userComment = this.getPluginUI(plugin, "submitComment").value.trim();
       if (userComment)
         keyVals.PluginUserComment = userComment;
       if (this.getPluginUI(plugin, "submitURLOptIn").checked)
         keyVals.PluginContentURL = plugin.ownerDocument.URL;
     }
diff --git a/browser/modules/RecentWindow.jsm b/browser/modules/RecentWindow.jsm
--- a/browser/modules/RecentWindow.jsm
+++ b/browser/modules/RecentWindow.jsm
@@ -22,17 +22,17 @@ this.RecentWindow = {
    * Get the most recent browser window.
    *
    * @param aOptions an object accepting the arguments for the search.
    *        * private: true to restrict the search to private windows
    *            only, false to restrict the search to non-private only.
    *            Omit the property to search in both groups.
    *        * allowPopups: true if popup windows are permissable.
    */
-  getMostRecentBrowserWindow: function RW_getMostRecentBrowserWindow(aOptions) {
+  getMostRecentBrowserWindow: function(aOptions) {
     let checkPrivacy = typeof aOptions == "object" &&
                        "private" in aOptions;
 
     let allowPopups = typeof aOptions == "object" && !!aOptions.allowPopups;
 
     function isSuitableBrowserWindow(win) {
       return (!win.closed &&
               (allowPopups || win.toolbar.visible) &&
diff --git a/browser/modules/SignInToWebsite.jsm b/browser/modules/SignInToWebsite.jsm
--- a/browser/modules/SignInToWebsite.jsm
+++ b/browser/modules/SignInToWebsite.jsm
@@ -20,32 +20,32 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/identity/LogUtils.jsm");
 
 function log(...aMessageArgs) {
   Logger.log.apply(Logger, ["SignInToWebsiteUX"].concat(aMessageArgs));
 }
 
 this.SignInToWebsiteUX = {
 
-  init: function SignInToWebsiteUX_init() {
+  init: function() {
 
     Services.obs.addObserver(this, "identity-request", false);
     Services.obs.addObserver(this, "identity-auth", false);
     Services.obs.addObserver(this, "identity-auth-complete", false);
     Services.obs.addObserver(this, "identity-login-state-changed", false);
   },
 
-  uninit: function SignInToWebsiteUX_uninit() {
+  uninit: function() {
     Services.obs.removeObserver(this, "identity-request");
     Services.obs.removeObserver(this, "identity-auth");
     Services.obs.removeObserver(this, "identity-auth-complete");
     Services.obs.removeObserver(this, "identity-login-state-changed");
   },
 
-  observe: function SignInToWebsiteUX_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     log("observe: received", aTopic, "with", aData, "for", aSubject);
     let options = null;
     if (aSubject) {
       options = aSubject.wrappedJSObject;
     }
     switch(aTopic) {
       case "identity-request":
         this.requestLogin(options);
@@ -69,17 +69,17 @@ this.SignInToWebsiteUX = {
         Logger.reportError("SignInToWebsiteUX", "Unknown observer notification:", aTopic);
         break;
     }
   },
 
   /**
    * The website is requesting login so the user must choose an identity to use.
    */
-  requestLogin: function SignInToWebsiteUX_requestLogin(aOptions) {
+  requestLogin: function(aOptions) {
     let windowID = aOptions.rpId;
     log("requestLogin", aOptions);
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     // message is not shown in the UI but is required
     let message = aOptions.origin;
     let mainAction = {
       label: chromeWin.gNavigatorBundle.getString("identity.next.label"),
@@ -102,24 +102,24 @@ this.SignInToWebsiteUX = {
     chromeWin.PopupNotifications.show(browserEl, "identity-request", message,
                                       "identity-notification-icon", mainAction,
                                       [], options);
   },
 
   /**
    * Get the list of possible identities to login to the given origin.
    */
-  getIdentitiesForSite: function SignInToWebsiteUX_getIdentitiesForSite(aOrigin) {
+  getIdentitiesForSite: function(aOrigin) {
     return IdentityService.RP.getIdentitiesForSite(aOrigin);
   },
 
   /**
    * User chose a new or existing identity from the doorhanger after a request() call
    */
-  selectIdentity: function SignInToWebsiteUX_selectIdentity(aRpId, aIdentity) {
+  selectIdentity: function(aRpId, aIdentity) {
     log("selectIdentity: rpId: ", aRpId, " identity: ", aIdentity);
     IdentityService.selectIdentity(aRpId, aIdentity);
   },
 
   // Private
 
   /**
    * Return the chrome window and <browser> for the given outer window ID.
@@ -138,45 +138,45 @@ this.SignInToWebsiteUX = {
     return [null, null];
   },
 
   /**
    * Open UI with a content frame displaying aAuthURI so that the user can authenticate with their
    * IDP.  Then tell Identity.jsm the identifier for the window so that it knows that the DOM API
    * calls are for this authentication flow.
    */
-  _openAuthenticationUI: function _openAuthenticationUI(aAuthURI, aContext) {
+  _openAuthenticationUI: function(aAuthURI, aContext) {
     // Open a tab/window with aAuthURI with an identifier (aID) attached so that the DOM APIs know this is an auth. window.
     let chromeWin = Services.wm.getMostRecentWindow('navigator:browser');
     let features = "chrome=false,width=640,height=480,centerscreen,location=yes,resizable=yes,scrollbars=yes,status=yes";
     log("aAuthURI: ", aAuthURI);
     let authWin = Services.ww.openWindow(chromeWin, "about:blank", "", features, null);
     let windowID = authWin.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
     log("authWin outer id: ", windowID);
 
     let provId = aContext.provId;
     // Tell the ID service about the id before loading the url
     IdentityService.IDP.setAuthenticationFlow(windowID, provId);
 
     authWin.location = aAuthURI;
   },
 
-  _closeAuthenticationUI: function _closeAuthenticationUI(aAuthId) {
+  _closeAuthenticationUI: function(aAuthId) {
     log("_closeAuthenticationUI:", aAuthId);
     let [chromeWin, browserEl] = this._getUIForWindowID(aAuthId);
     if (chromeWin)
       chromeWin.close();
     else
       Logger.reportError("SignInToWebsite", "Could not close window with ID", aAuthId);
   },
 
   /**
    * Show a doorhanger indicating the currently logged-in user.
    */
-  _showLoggedInUI: function _showLoggedInUI(aIdentity, aContext) {
+  _showLoggedInUI: function(aIdentity, aContext) {
     let windowID = aContext.rpId;
     log("_showLoggedInUI for ", windowID);
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     let message = chromeWin.gNavigatorBundle.getFormattedString("identity.loggedIn.description",
                                                           [aIdentity]);
     let mainAction = {
       label: chromeWin.gNavigatorBundle.getString("identity.loggedIn.signOut.label"),
@@ -194,32 +194,32 @@ this.SignInToWebsiteUX = {
                                                   "identity-notification-icon", mainAction,
                                                   secondaryActions, options);
     loggedInNot.rpId = windowID;
   },
 
   /**
    * Remove the doorhanger indicating the currently logged-in user.
    */
-  _removeLoggedInUI: function _removeLoggedInUI(aContext) {
+  _removeLoggedInUI: function(aContext) {
     let windowID = aContext.rpId;
     log("_removeLoggedInUI for ", windowID);
     if (!windowID)
       throw "_removeLoggedInUI: Invalid RP ID";
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     let loggedInNot = chromeWin.PopupNotifications.getNotification("identity-logged-in", browserEl);
     if (loggedInNot)
       chromeWin.PopupNotifications.remove(loggedInNot);
   },
 
   /**
    * Remove the doorhanger indicating the currently logged-in user.
    */
-  _removeRequestUI: function _removeRequestUI(aContext) {
+  _removeRequestUI: function(aContext) {
     let windowID = aContext.rpId;
     log("_removeRequestUI for ", windowID);
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     let requestNot = chromeWin.PopupNotifications.getNotification("identity-request", browserEl);
     if (requestNot)
       chromeWin.PopupNotifications.remove(requestNot);
   },
diff --git a/browser/modules/Social.jsm b/browser/modules/Social.jsm
--- a/browser/modules/Social.jsm
+++ b/browser/modules/Social.jsm
@@ -76,17 +76,17 @@ function promiseGetAnnotation(aURI) {
 }
 
 this.Social = {
   initialized: false,
   lastEventReceived: 0,
   providers: [],
   _disabledForSafeMode: false,
 
-  init: function Social_init() {
+  init: function() {
     this._disabledForSafeMode = Services.appinfo.inSafeMode && this.enabled;
     let deferred = Promise.defer();
 
     if (this.initialized) {
       deferred.resolve(true);
       return deferred.promise;
     }
     this.initialized = true;
@@ -146,17 +146,17 @@ this.Social = {
     this.providers = providers;
     Services.obs.notifyObservers(null, "social:providers-changed", null);
   },
 
   get enabled() {
     return !this._disabledForSafeMode && this.providers.length > 0;
   },
 
-  toggleNotifications: function SocialNotifications_toggle() {
+  toggleNotifications: function() {
     let prefValue = Services.prefs.getBoolPref("social.toast-notifications.enabled");
     Services.prefs.setBoolPref("social.toast-notifications.enabled", !prefValue);
   },
 
   _getProviderFromOrigin: function (origin) {
     for (let p of this.providers) {
       if (p.origin == origin) {
         return p;
@@ -344,17 +344,17 @@ SocialErrorListener.prototype = {
 
   remove: function() {
     this.iframe.docShell.QueryInterface(Ci.nsIInterfaceRequestor)
                                      .getInterface(Ci.nsIWebProgress)
                                      .removeProgressListener(this);
     delete this.iframe.socialErrorListener;
   },
 
-  onStateChange: function SPL_onStateChange(aWebProgress, aRequest, aState, aStatus) {
+  onStateChange: function(aWebProgress, aRequest, aState, aStatus) {
     let failure = false;
     if ((aState & Ci.nsIWebProgressListener.STATE_STOP)) {
       if (aRequest instanceof Ci.nsIHttpChannel) {
         try {
           // Change the frame to an error page on 4xx (client errors)
           // and 5xx (server errors).  responseStatus throws if it is not set.
           failure = aRequest.responseStatus >= 400 &&
                     aRequest.responseStatus < 600;
@@ -373,35 +373,35 @@ SocialErrorListener.prototype = {
         let provider = Social._getProviderFromOrigin(origin);
         provider.errorState = "content-error";
       }
       this.setErrorMessage(aWebProgress.QueryInterface(Ci.nsIDocShell)
                               .chromeEventHandler);
     }
   },
 
-  onLocationChange: function SPL_onLocationChange(aWebProgress, aRequest, aLocation, aFlags) {
+  onLocationChange: function(aWebProgress, aRequest, aLocation, aFlags) {
     if (aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE) {
       aRequest.cancel(Components.results.NS_BINDING_ABORTED);
       let origin = this.iframe.getAttribute("origin");
       if (origin) {
         let provider = Social._getProviderFromOrigin(origin);
         if (!provider.errorState)
           provider.errorState = "content-error";
       }
       schedule(function() {
         this.setErrorMessage(aWebProgress.QueryInterface(Ci.nsIDocShell)
                               .chromeEventHandler);
       }.bind(this));
     }
   },
 
-  onProgressChange: function SPL_onProgressChange() {},
-  onStatusChange: function SPL_onStatusChange() {},
-  onSecurityChange: function SPL_onSecurityChange() {},
+  onProgressChange: function() {},
+  onStatusChange: function() {},
+  onSecurityChange: function() {},
 };
 
 
 function sizeSocialPanelToContent(panel, iframe, requestedSize) {
   let doc = iframe.contentDocument;
   if (!doc || !doc.body) {
     return;
   }
@@ -455,30 +455,30 @@ function sizeSocialPanelToContent(panel,
     panel.style.height = height + "px";
 }
 
 function DynamicResizeWatcher() {
   this._mutationObserver = null;
 }
 
 DynamicResizeWatcher.prototype = {
-  start: function DynamicResizeWatcher_start(panel, iframe, requestedSize) {
+  start: function(panel, iframe, requestedSize) {
     this.stop(); // just in case...
     let doc = iframe.contentDocument;
     this._mutationObserver = new iframe.contentWindow.MutationObserver((mutations) => {
       sizeSocialPanelToContent(panel, iframe, requestedSize);
     });
     // Observe anything that causes the size to change.
     let config = {attributes: true, characterData: true, childList: true, subtree: true};
     this._mutationObserver.observe(doc, config);
     // and since this may be setup after the load event has fired we do an
     // initial resize now.
     sizeSocialPanelToContent(panel, iframe, requestedSize);
   },
-  stop: function DynamicResizeWatcher_stop() {
+  stop: function() {
     if (this._mutationObserver) {
       try {
         this._mutationObserver.disconnect();
       } catch (ex) {
         // may get "TypeError: can't access dead object" which seems strange,
         // but doesn't seem to indicate a real problem, so ignore it...
       }
       this._mutationObserver = null;
diff --git a/browser/modules/WindowsJumpLists.jsm b/browser/modules/WindowsJumpLists.jsm
--- a/browser/modules/WindowsJumpLists.jsm
+++ b/browser/modules/WindowsJumpLists.jsm
@@ -143,17 +143,17 @@ this.WinTaskbarJumpList =
   _builder: null,
   _tasks: null,
   _shuttingDown: false,
 
   /**
    * Startup, shutdown, and update
    */ 
 
-  startup: function WTBJL_startup() {
+  startup: function() {
     // exit if this isn't win7 or higher.
     if (!this._initTaskbar())
       return;
 
     // Win shell shortcut maintenance. If we've gone through an update,
     // this will update any pinned taskbar shortcuts. Not specific to
     // jump lists, but this was a convienent place to call it. 
     try {
@@ -170,58 +170,58 @@ this.WinTaskbarJumpList =
 
     // observer for private browsing and our prefs branch
     this._initObs();
 
     // jump list refresh timer
     this._updateTimer();
   },
 
-  update: function WTBJL_update() {
+  update: function() {
     // are we disabled via prefs? don't do anything!
     if (!this._enabled)
       return;
 
     // do what we came here to do, update the taskbar jumplist
     this._buildList();
   },
 
-  _shutdown: function WTBJL__shutdown() {
+  _shutdown: function() {
     this._shuttingDown = true;
 
     // Correctly handle a clear history on shutdown.  If there are no
     // entries be sure to empty all history lists.  Luckily Places caches
     // this value, so it's a pretty fast call.
     if (!PlacesUtils.history.hasHistoryEntries) {
       this.update();
     }
 
     this._free();
   },
 
-  _shortcutMaintenance: function WTBJL__maintenace() {
+  _shortcutMaintenance: function() {
     _winShellService.shortcutMaintenance();
   },
 
   /**
    * List building
    *
    * @note Async builders must add their mozIStoragePendingStatement to
    *       _pendingStatements object, using a different LIST_TYPE entry for
    *       each statement. Once finished they must remove it and call
    *       commitBuild().  When there will be no more _pendingStatements,
    *       commitBuild() will commit for real.
    */
 
   _pendingStatements: {},
-  _hasPendingStatements: function WTBJL__hasPendingStatements() {
+  _hasPendingStatements: function() {
     return Object.keys(this._pendingStatements).length > 0;
   },
 
-  _buildList: function WTBJL__buildList() {
+  _buildList: function() {
     if (this._hasPendingStatements()) {
       // We were requested to update the list while another update was in
       // progress, this could happen at shutdown, idle or privatebrowsing.
       // Abort the current list building.
       for (let listType in this._pendingStatements) {
         this._pendingStatements[listType].cancel();
         delete this._pendingStatements[listType];
       }
@@ -250,55 +250,55 @@ this.WinTaskbarJumpList =
 
     this._commitBuild();
   },
 
   /**
    * Taskbar api wrappers
    */ 
 
-  _startBuild: function WTBJL__startBuild() {
+  _startBuild: function() {
     var removedItems = Cc["@mozilla.org/array;1"].
                        createInstance(Ci.nsIMutableArray);
     this._builder.abortListBuild();
     if (this._builder.initListBuild(removedItems)) { 
       // Prior to building, delete removed items from history.
       this._clearHistory(removedItems);
       return true;
     }
     return false;
   },
 
-  _commitBuild: function WTBJL__commitBuild() {
+  _commitBuild: function() {
     if (!this._hasPendingStatements() && !this._builder.commitListBuild()) {
       this._builder.abortListBuild();
     }
   },
 
-  _buildTasks: function WTBJL__buildTasks() {
+  _buildTasks: function() {
     var items = Cc["@mozilla.org/array;1"].
                 createInstance(Ci.nsIMutableArray);
     this._tasks.forEach(function (task) {
       if ((this._shuttingDown && !task.close) || (!this._shuttingDown && !task.open))
         return;
       var item = this._getHandlerAppItem(task.title, task.description,
                                          task.args, task.iconIndex, null);
       items.appendElement(item, false);
     }, this);
     
     if (items.length > 0)
       this._builder.addListToBuild(this._builder.JUMPLIST_CATEGORY_TASKS, items);
   },
 
-  _buildCustom: function WTBJL__buildCustom(title, items) {
+  _buildCustom: function(title, items) {
     if (items.length > 0)
       this._builder.addListToBuild(this._builder.JUMPLIST_CATEGORY_CUSTOMLIST, items, title);
   },
 
-  _buildFrequent: function WTBJL__buildFrequent() {
+  _buildFrequent: function() {
     // If history is empty, just bail out.
     if (!PlacesUtils.history.hasHistoryEntries) {
       return;
     }
 
     // Windows supports default frequent and recent lists,
     // but those depend on internal windows visit tracking
     // which we don't populate. So we build our own custom
@@ -328,17 +328,17 @@ this.WinTaskbarJumpList =
                                                faviconPageUri);
         items.appendElement(shortcut, false);
         this._frequentHashList.push(aResult.uri);
       },
       this
     );
   },
 
-  _buildRecent: function WTBJL__buildRecent() {
+  _buildRecent: function() {
     // If history is empty, just bail out.
     if (!PlacesUtils.history.hasHistoryEntries) {
       return;
     }
 
     var items = Cc["@mozilla.org/array;1"].
                 createInstance(Ci.nsIMutableArray);
     // Frequent items will be skipped, so we select a double amount of
@@ -373,17 +373,17 @@ this.WinTaskbarJumpList =
                                                faviconPageUri);
         items.appendElement(shortcut, false);
         count++;
       },
       this
     );
   },
 
-  _deleteActiveJumpList: function WTBJL__deleteAJL() {
+  _deleteActiveJumpList: function() {
     this._builder.deleteActiveList();
   },
 
   /**
    * Jump list item creation helpers
    */
 
   _getHandlerAppItem: function WTBJL__getHandlerAppItem(name, description, 
@@ -403,17 +403,17 @@ this.WinTaskbarJumpList =
     var item = Cc["@mozilla.org/windows-jumplistshortcut;1"].
                createInstance(Ci.nsIJumpListShortcut);
     item.app = handlerApp;
     item.iconIndex = iconIndex;
     item.faviconPageUri = faviconPageUri;
     return item;
   },
 
-  _getSeparatorItem: function WTBJL__getSeparatorItem() {
+  _getSeparatorItem: function() {
     var item = Cc["@mozilla.org/windows-jumplistseparator;1"].
                createInstance(Ci.nsIJumpListSeparator);
     return item;
   },
 
   /**
    * Nav history helpers
    */
@@ -443,17 +443,17 @@ this.WinTaskbarJumpList =
           "Async execution error (" + aError.result + "): " + aError.message);
       },
       handleCompletion: function (aReason) {
         aCallback.call(WinTaskbarJumpList, null);
       },
     });
   },
 
-  _clearHistory: function WTBJL__clearHistory(items) {
+  _clearHistory: function(items) {
     if (!items)
       return;
     var URIsToRemove = [];
     var e = items.enumerate();
     while (e.hasMoreElements()) {
       let oldItem = e.getNext().QueryInterface(Ci.nsIJumpListShortcut);
       if (oldItem) {
         try { // in case we get a bad uri
@@ -466,94 +466,94 @@ this.WinTaskbarJumpList =
       PlacesUtils.bhistory.removePages(URIsToRemove, URIsToRemove.length, true);
     }
   },
 
   /**
    * Prefs utilities
    */ 
 
-  _refreshPrefs: function WTBJL__refreshPrefs() {
+  _refreshPrefs: function() {
     this._enabled = _prefs.getBoolPref(PREF_TASKBAR_ENABLED);
     this._showFrequent = _prefs.getBoolPref(PREF_TASKBAR_FREQUENT);
     this._showRecent = _prefs.getBoolPref(PREF_TASKBAR_RECENT);
     this._showTasks = _prefs.getBoolPref(PREF_TASKBAR_TASKS);
     this._maxItemCount = _prefs.getIntPref(PREF_TASKBAR_ITEMCOUNT);
   },
 
   /**
    * Init and shutdown utilities
    */ 
 
-  _initTaskbar: function WTBJL__initTaskbar() {
+  _initTaskbar: function() {
     this._builder = _taskbarService.createJumpListBuilder();
     if (!this._builder || !this._builder.available)
       return false;
 
     return true;
   },
 
-  _initObs: function WTBJL__initObs() {
+  _initObs: function() {
     // If the browser is closed while in private browsing mode, the "exit"
     // notification is fired on quit-application-granted.
     // History cleanup can happen at profile-change-teardown.
     Services.obs.addObserver(this, "profile-before-change", false);
     Services.obs.addObserver(this, "browser:purge-session-history", false);
     _prefs.addObserver("", this, false);
   },
  
-  _freeObs: function WTBJL__freeObs() {
+  _freeObs: function() {
     Services.obs.removeObserver(this, "profile-before-change");
     Services.obs.removeObserver(this, "browser:purge-session-history");
     _prefs.removeObserver("", this);
   },
 
-  _updateTimer: function WTBJL__updateTimer() {
+  _updateTimer: function() {
     if (this._enabled && !this._shuttingDown && !this._timer) {
       this._timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
       this._timer.initWithCallback(this,
                                    _prefs.getIntPref(PREF_TASKBAR_REFRESH)*1000,
                                    this._timer.TYPE_REPEATING_SLACK);
     }
     else if ((!this._enabled || this._shuttingDown) && this._timer) {
       this._timer.cancel();
       delete this._timer;
     }
   },
 
   _hasIdleObserver: false,
-  _updateIdleObserver: function WTBJL__updateIdleObserver() {
+  _updateIdleObserver: function() {
     if (this._enabled && !this._shuttingDown && !this._hasIdleObserver) {
       _idle.addIdleObserver(this, IDLE_TIMEOUT_SECONDS);
       this._hasIdleObserver = true;
     }
     else if ((!this._enabled || this._shuttingDown) && this._hasIdleObserver) {
       _idle.removeIdleObserver(this, IDLE_TIMEOUT_SECONDS);
       this._hasIdleObserver = false;
     }
   },
 
-  _free: function WTBJL__free() {
+  _free: function() {
     this._freeObs();
     this._updateTimer();
     this._updateIdleObserver();
     delete this._builder;
   },
 
   /**
    * Notification handlers
    */
 
-  notify: function WTBJL_notify(aTimer) {
+  notify: function(aTimer) {
     // Add idle observer on the first notification so it doesn't hit startup.
     this._updateIdleObserver();
     this.update();
   },
 
-  observe: function WTBJL_observe(aSubject, aTopic, aData) {
+  observe: function(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "nsPref:changed":
         if (this._enabled == true && !_prefs.getBoolPref(PREF_TASKBAR_ENABLED))
           this._deleteActiveJumpList();
         this._refreshPrefs();
         this._updateTimer();
         this._updateIdleObserver();
         this.update();
diff --git a/browser/modules/WindowsPreviewPerTab.jsm b/browser/modules/WindowsPreviewPerTab.jsm
--- a/browser/modules/WindowsPreviewPerTab.jsm
+++ b/browser/modules/WindowsPreviewPerTab.jsm
@@ -651,17 +651,17 @@ this.AeroPeek = {
 
     this.cacheLifespan = this.prefs.getIntPref(CACHE_EXPIRATION_TIME_PREF_NAME);
 
     this.maxpreviews = this.prefs.getIntPref(DISABLE_THRESHOLD_PREF_NAME);
 
     this.enabled = this._prefenabled = this.prefs.getBoolPref(TOGGLE_PREF_NAME);
   },
 
-  destroy: function destroy() {
+  destroy: function() {
     this._enabled = false;
 
     this.prefs.removeObserver(TOGGLE_PREF_NAME, this);
     this.prefs.removeObserver(DISABLE_THRESHOLD_PREF_NAME, this);
     this.prefs.removeObserver(CACHE_EXPIRATION_TIME_PREF_NAME, this);
 
     if (this.cacheTimer)
       this.cacheTimer.cancel();
diff --git a/browser/modules/test/unit/social/head.js b/browser/modules/test/unit/social/head.js
--- a/browser/modules/test/unit/social/head.js
+++ b/browser/modules/test/unit/social/head.js
@@ -42,17 +42,17 @@ function createAppInfo(id, name, version
     platformVersion: platformVersion ? platformVersion : "1.0",
     platformBuildID: "2007010101",
 
     // nsIXULRuntime
     inSafeMode: false,
     logConsoleErrors: true,
     OS: "XPCShell",
     XPCOMABI: "noarch-spidermonkey",
-    invalidateCachesOnRestart: function invalidateCachesOnRestart() {
+    invalidateCachesOnRestart: function() {
       // Do nothing
     },
 
     // nsICrashReporter
     annotations: {},
 
     annotateCrashReport: function(key, data) {
       this.annotations[key] = data;
