# HG changeset patch
# Parent b9c1fd61076fd218df8e2706818e90d99db05dff
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1037519 - Allow matching pseudo-elements in inIDOMUtils.selectorMatchesElement;r=bz

diff --git a/layout/inspector/inDOMUtils.cpp b/layout/inspector/inDOMUtils.cpp
--- a/layout/inspector/inDOMUtils.cpp
+++ b/layout/inspector/inDOMUtils.cpp
@@ -352,38 +352,68 @@ inDOMUtils::GetSpecificity(nsIDOMCSSStyl
   *aSpecificity = sel->mWeight;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDOMUtils::SelectorMatchesElement(nsIDOMElement* aElement,
                                    nsIDOMCSSStyleRule* aRule,
                                    uint32_t aSelectorIndex,
+                                   const nsAString& aPseudo,
                                    bool* aMatches)
 {
   nsCOMPtr<Element> element = do_QueryInterface(aElement);
   NS_ENSURE_ARG_POINTER(element);
 
   ErrorResult rv;
   nsCSSSelectorList* tail = GetSelectorAtIndex(aRule, aSelectorIndex, rv);
   if (rv.Failed()) {
     return rv.ErrorCode();
   }
 
   // We want just the one list item, not the whole list tail
   nsAutoPtr<nsCSSSelectorList> sel(tail->Clone(false));
 
+  nsCOMPtr<nsIAtom> pseudoElt;
+  if (!aPseudo.IsEmpty()) {
+    pseudoElt = do_GetAtom(aPseudo);
+
+    // printf("Pseudo is not null %s\n", NS_LossyConvertUTF16toASCII(pseudoElt->GetUTF16String()).get());
+    // printf("Pseudo type for selector %s\n", NS_LossyConvertUTF16toASCII(nsCSSPseudoElements::GetPseudoAtom(sel->mSelectors->PseudoType())->GetUTF16String()).get());
+
+    if (sel->mSelectors->PseudoType() !=
+        nsCSSPseudoElements::GetPseudoType(pseudoElt)) {
+      printf("Bailing out 1\n");
+      *aMatches = false;
+      return NS_OK;
+    } else {
+      // XXX: just testing by setting true
+      *aMatches = true;
+      return NS_OK;
+    }
+  } else {
+    if (sel->mSelectors->IsPseudoElement()) {
+      *aMatches = false;
+      printf("Bailing out 2\n");
+      return NS_OK;
+    }
+
+    // if (sel->mSelectors->PseudoType() !=
+        // nsCSSPseudoClasses::ePseudoClass_NotPseudoClass)
+
+  }
+
   // SelectorListMatches does not handle selectors that begin with a
   // pseudo-element, which you can get from selectors like
   // |input::-moz-placeholder:hover|.  This function doesn't take
   // a pseudo-element nsIAtom*, so we know we can't match.
-  if (sel->mSelectors->IsPseudoElement()) {
-    *aMatches = false;
-    return NS_OK;
-  }
+  // if (sel->mSelectors->IsPseudoElement()) {
+  //   *aMatches = false;
+  //   return NS_OK;
+  // }
 
   element->OwnerDoc()->FlushPendingLinkUpdates();
   // XXXbz what exactly should we do with visited state here?
   TreeMatchContext matchingContext(false,
                                    nsRuleWalker::eRelevantLinkUnvisited,
                                    element->OwnerDoc(),
                                    TreeMatchContext::eNeverMatchVisited);
   *aMatches = nsCSSRuleProcessor::SelectorListMatches(element, matchingContext,
diff --git a/layout/inspector/inIDOMUtils.idl b/layout/inspector/inIDOMUtils.idl
--- a/layout/inspector/inIDOMUtils.idl
+++ b/layout/inspector/inIDOMUtils.idl
@@ -38,17 +38,18 @@ interface inIDOMUtils : nsISupports
   AString getSelectorText(in nsIDOMCSSStyleRule aRule,
                           in unsigned long aSelectorIndex);
   unsigned long long getSpecificity(in nsIDOMCSSStyleRule aRule,
                                     in unsigned long aSelectorIndex);
   // Note: This does not handle scoped selectors correctly, because it has no
   // idea what the right scope is.
   bool selectorMatchesElement(in nsIDOMElement aElement,
                               in nsIDOMCSSStyleRule aRule,
-                              in unsigned long aSelectorIndex);
+                              in unsigned long aSelectorIndex,
+                              [optional] in DOMString aPseudo);
 
   // Utilities for working with CSS properties
   //
   // Returns true if the string names a property that is inherited by default.
   bool isInheritedProperty(in AString aPropertyName);
 
   // Get a list of all our supported property names.  Optionally
   // shorthands can be excluded or property aliases included.
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -470,20 +470,20 @@ var PageStyleActor = protocol.ActorClass
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
         }
 
         let domRule = entry.rule.rawRule;
         let selectors = CssLogic.getSelectors(domRule);
         let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;
-
+        let {pseudoToRead,elementToRead} = CssLogic.getStyleableElementAndPseudo(element);
         entry.matchedSelectors = [];
         for (let i = 0; i < selectors.length; i++) {
-          if (DOMUtils.selectorMatchesElement(element, domRule, i)) {
+          if (DOMUtils.selectorMatchesElement(elementToRead, domRule, i, pseudoToRead)) {
             entry.matchedSelectors.push(selectors[i]);
           }
         }
       }
     }
 
     let rules = new Set;
     let sheets = new Set;
