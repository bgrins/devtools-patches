# HG changeset patch
# Parent c219edfd51877c853c264a1a3a6c258351c179de
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1037519 - Allow matching pseudo-elements in inIDOMUtils.selectorMatchesElement;r=bz

diff --git a/layout/inspector/inDOMUtils.cpp b/layout/inspector/inDOMUtils.cpp
--- a/layout/inspector/inDOMUtils.cpp
+++ b/layout/inspector/inDOMUtils.cpp
@@ -352,38 +352,92 @@ inDOMUtils::GetSpecificity(nsIDOMCSSStyl
   *aSpecificity = sel->mWeight;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDOMUtils::SelectorMatchesElement(nsIDOMElement* aElement,
                                    nsIDOMCSSStyleRule* aRule,
                                    uint32_t aSelectorIndex,
+                                   const nsAString& aPseudo,
                                    bool* aMatches)
 {
   nsCOMPtr<Element> element = do_QueryInterface(aElement);
   NS_ENSURE_ARG_POINTER(element);
 
   ErrorResult rv;
   nsCSSSelectorList* tail = GetSelectorAtIndex(aRule, aSelectorIndex, rv);
   if (rv.Failed()) {
     return rv.ErrorCode();
   }
 
   // We want just the one list item, not the whole list tail
   nsAutoPtr<nsCSSSelectorList> sel(tail->Clone(false));
 
+  nsAutoPtr<nsCSSSelectorList> sel2(tail->Clone(true));
+
+
+  nsAutoString  buffer;
+  nsRefPtr<StyleRule> rule = GetRuleFromDOMRule(aRule, rv);
+  // sel->ToString(buffer, rule->GetStyleSheet());
+  sel->mSelectors->ToString(buffer, rule->GetStyleSheet(), false);
+  printf("Checking selector1: %s\n", NS_LossyConvertUTF16toASCII(buffer).get());
+
+  nsAutoString  buffer2;
+  // sel2->ToString(buffer2, rule->GetStyleSheet());
+  sel2->mSelectors->ToString(buffer2, rule->GetStyleSheet(), false);
+  printf("Checking selector2: %s\n", NS_LossyConvertUTF16toASCII(buffer2).get());
+
+
+  nsCOMPtr<nsIAtom> pseudoElt;
+  if (!aPseudo.IsEmpty()) {
+    pseudoElt = do_GetAtom(aPseudo);
+
+    // printf("Pseudo is not null %s\n", NS_LossyConvertUTF16toASCII(pseudoElt->GetUTF16String()).get());
+    // printf("Pseudo type for selector %s\n", NS_LossyConvertUTF16toASCII(nsCSSPseudoElements::GetPseudoAtom(sel->m(Sel)ectors->PseudoType())->GetUTF16String()).get());
+    //nsCSSPseudoElements::Type pseudoType =
+    //       nsCSSPseudoElements::ePseudo_NotPseudoElement
+
+
+    if (sel->mSelectors->PseudoType() !=
+        nsCSSPseudoElements::GetPseudoType(pseudoElt)) {
+      *aMatches = false;
+      return NS_OK;
+    } else {
+      if (sel->mSelectors->PseudoType() == nsCSSPseudoElements::ePseudo_before ||
+          sel->mSelectors->PseudoType() == nsCSSPseudoElements::ePseudo_after) {
+        printf("We are dealing with a ::before or ::after \n");
+      }
+
+      sel->mSelectors->SetPseudoType(nsCSSPseudoElements::ePseudo_NotPseudoElement);
+      if (sel->mSelectors->PseudoType() == nsCSSPseudoElements::ePseudo_before ||
+          sel->mSelectors->PseudoType() == nsCSSPseudoElements::ePseudo_after) {
+        printf("We are STILL! dealing with a ::before or ::after \n");
+      }
+      // XXX: just testing by setting true
+      printf("Did match pseudo, now need to check selector\n");
+      // *aMatches = true;
+      // return NS_OK;
+    }
+  } else {
+    if (sel->mSelectors->IsPseudoElement()) {
+      *aMatches = false;
+      printf("Bailing out 2\n");
+      return NS_OK;
+    }
+  }
+
   // SelectorListMatches does not handle selectors that begin with a
   // pseudo-element, which you can get from selectors like
   // |input::-moz-placeholder:hover|.  This function doesn't take
   // a pseudo-element nsIAtom*, so we know we can't match.
-  if (sel->mSelectors->IsPseudoElement()) {
-    *aMatches = false;
-    return NS_OK;
-  }
+  // if (sel->mSelectors->IsPseudoElement()) {
+  //   *aMatches = false;
+  //   return NS_OK;
+  // }
 
   element->OwnerDoc()->FlushPendingLinkUpdates();
   // XXXbz what exactly should we do with visited state here?
   TreeMatchContext matchingContext(false,
                                    nsRuleWalker::eRelevantLinkUnvisited,
                                    element->OwnerDoc(),
                                    TreeMatchContext::eNeverMatchVisited);
   *aMatches = nsCSSRuleProcessor::SelectorListMatches(element, matchingContext,
diff --git a/layout/inspector/inIDOMUtils.idl b/layout/inspector/inIDOMUtils.idl
--- a/layout/inspector/inIDOMUtils.idl
+++ b/layout/inspector/inIDOMUtils.idl
@@ -38,17 +38,18 @@ interface inIDOMUtils : nsISupports
   AString getSelectorText(in nsIDOMCSSStyleRule aRule,
                           in unsigned long aSelectorIndex);
   unsigned long long getSpecificity(in nsIDOMCSSStyleRule aRule,
                                     in unsigned long aSelectorIndex);
   // Note: This does not handle scoped selectors correctly, because it has no
   // idea what the right scope is.
   bool selectorMatchesElement(in nsIDOMElement aElement,
                               in nsIDOMCSSStyleRule aRule,
-                              in unsigned long aSelectorIndex);
+                              in unsigned long aSelectorIndex,
+                              [optional] in DOMString aPseudo);
 
   // Utilities for working with CSS properties
   //
   // Returns true if the string names a property that is inherited by default.
   bool isInheritedProperty(in AString aPropertyName);
 
   // Get a list of all our supported property names.  Optionally
   // shorthands can be excluded or property aliases included.
diff --git a/layout/inspector/tests/mochitest.ini b/layout/inspector/tests/mochitest.ini
--- a/layout/inspector/tests/mochitest.ini
+++ b/layout/inspector/tests/mochitest.ini
@@ -11,8 +11,9 @@ support-files =
 [test_bug557726.html]
 [test_bug609549.xhtml]
 [test_bug806192.html]
 [test_bug856317.html]
 [test_bug877690.html]
 [test_bug1006595.html]
 [test_get_all_style_sheets.html]
 [test_isinheritableproperty.html]
+[test_selectormatcheselement.html]
diff --git a/layout/inspector/tests/test_selectormatcheselement.html b/layout/inspector/tests/test_selectormatcheselement.html
new file mode 100644
--- /dev/null
+++ b/layout/inspector/tests/test_selectormatcheselement.html
@@ -0,0 +1,88 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1037519
+-->
+<head>
+  <title>Test for nsIDOMUtils::selectorMatchesElement</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+    #foo,
+    #bar {
+      color: red;
+    }
+    #foo::before,
+    #bar::before {
+      content: 'foo-before';
+      color: green;
+    }
+    #foo::after,
+    #bar::after {
+      content: 'foo-after';
+      color: blue;
+    }
+  </style>
+</head>
+<body>
+<div id="foo"></div>
+<pre id="test">
+<script type="application/javascript">
+
+function do_test() {
+  var utils = SpecialPowers.Cc["@mozilla.org/inspector/dom-utils;1"]
+    .getService(SpecialPowers.Ci.inIDOMUtils);
+
+  var element = document.querySelector("#foo");
+
+  var elementRules = utils.getCSSStyleRules(element);
+  var elementRule = elementRules.GetElementAt(elementRules.Count() - 1);
+
+  is (utils.selectorMatchesElement(element, elementRule, 0), true,
+    "Matches on #foo");
+  is (utils.selectorMatchesElement(element, elementRule, 1), false,
+    "Doesn't match on #bar");
+  is (utils.selectorMatchesElement(element, elementRule, 0, ":before"), false,
+    "Doesn't match");
+  is (utils.selectorMatchesElement(element, elementRule, 0, ":after"), false,
+    "Doesn't match");
+
+  var beforeRules = utils.getCSSStyleRules(element, ":before");
+  var beforeRule = beforeRules.GetElementAt(beforeRules.Count() - 1);
+
+  is (utils.selectorMatchesElement(element, beforeRule, 0), false,
+    "Doesn't match without ::before");
+  is (utils.selectorMatchesElement(element, beforeRule, 1), false,
+    "Doesn't match without ::before");
+
+  is (utils.selectorMatchesElement(element, beforeRule, 0, ":before"), true,
+    "Matches on #foo::before");
+  is (utils.selectorMatchesElement(element, beforeRule, 1, ":before"), false,
+    "Doesn't match on #bar::before");
+
+  var afterRules = utils.getCSSStyleRules(element, ":after");
+  var afterRule = afterRules.GetElementAt(afterRules.Count() - 1);
+
+  is (utils.selectorMatchesElement(element, afterRule, 0), false,
+    "Doesn't match without ::after");
+  is (utils.selectorMatchesElement(element, afterRule, 1), false,
+    "Doesn't match without ::after");
+
+  dump(utils.getSelectorText(afterRule, 0) + "\n");
+  dump(utils.getSelectorText(afterRule, 1) + "\n");
+  is (utils.selectorMatchesElement(element, afterRule, 0, ":after"), true,
+    "Matches on #foo::after");
+  is (utils.selectorMatchesElement(element, afterRule, 1, ":after"), false,
+    "Doesn't match on #bar::after");
+
+  SimpleTest.finish();
+}
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(do_test);
+
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -470,20 +470,20 @@ var PageStyleActor = protocol.ActorClass
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
         }
 
         let domRule = entry.rule.rawRule;
         let selectors = CssLogic.getSelectors(domRule);
         let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;
-
+        let {pseudoToRead,elementToRead} = CssLogic.getStyleableElementAndPseudo(element);
         entry.matchedSelectors = [];
         for (let i = 0; i < selectors.length; i++) {
-          if (DOMUtils.selectorMatchesElement(element, domRule, i)) {
+          if (DOMUtils.selectorMatchesElement(elementToRead, domRule, i, pseudoToRead)) {
             entry.matchedSelectors.push(selectors[i]);
           }
         }
       }
     }
 
     let rules = new Set;
     let sheets = new Set;
