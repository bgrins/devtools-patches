# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1542045329 28800
#      Mon Nov 12 09:55:29 2018 -0800
# Node ID 3622e8e9a891c6936c35faaaa06997f1e1cf24d9
# Parent  39dba5141dd90c70a861299459d418d230148d9f
Bug 1505734 - Remove CustomizableUI toolbar

Differential Revision: https://phabricator.services.mozilla.com/D11665

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1358,16 +1358,24 @@ var gBrowserInit = {
       }
       initBrowser.removeAttribute("blank");
     }
 
     gBrowser.updateBrowserRemoteness(initBrowser, isRemote, {
       remoteType, sameProcessAsFrameLoader,
     });
 
+    gNavToolbox.palette = document.getElementById("BrowserToolbarPalette");
+    gNavToolbox.palette.remove();
+    let areas = CustomizableUI.areas;
+    areas.splice(areas.indexOf(CustomizableUI.AREA_FIXED_OVERFLOW_PANEL), 1);
+    for (let area of areas) {
+      let node = document.getElementById(area);
+      CustomizableUI.registerToolbarNode(node);
+    }
     BrowserSearch.initPlaceHolder();
 
     // Hack to ensure that the about:home favicon is loaded
     // instantaneously, to avoid flickering and improve perceived performance.
     this._callWithURIToLoad(uriToLoad => {
       if (uriToLoad == "about:home" || uriToLoad == "about:newtab" || uriToLoad == "about:welcome") {
         gBrowser.setIcon(gBrowser.selectedTab, "chrome://branding/content/icon32.png");
       } else if (uriToLoad == "about:privatebrowsing") {
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -715,39 +715,43 @@ var CustomizableUIInternal = {
   },
 
   registerToolbarNode(aToolbar, aExistingChildren) {
     let area = aToolbar.id;
     if (gBuildAreas.has(area) && gBuildAreas.get(area).has(aToolbar)) {
       return;
     }
     let areaProperties = gAreas.get(area);
+    let existingChildren = aExistingChildren ||
+                           Array.from(aToolbar.children)
+                                .filter(child => child.getAttribute("skipintoolbarset") != "true" && child.id)
+                                .map(child => child.id);
 
     // If this area is not registered, try to do it automatically:
     if (!areaProperties) {
       if (!gPendingBuildAreas.has(area)) {
         gPendingBuildAreas.set(area, new Map());
       }
       let pendingNodes = gPendingBuildAreas.get(area);
-      pendingNodes.set(aToolbar, aExistingChildren);
+      pendingNodes.set(aToolbar, existingChildren);
       return;
     }
 
     this.beginBatchUpdate();
     try {
       let placements = gPlacements.get(area);
       if (!placements && areaProperties.get("type") == CustomizableUI.TYPE_TOOLBAR) {
         this.restoreStateForArea(area);
         placements = gPlacements.get(area);
       }
 
       // Check that the current children and the current placements match. If
       // not, mark it as dirty:
-      if (aExistingChildren.length != placements.length ||
-          aExistingChildren.every((id, i) => id == placements[i])) {
+      if (existingChildren.length != placements.length ||
+        existingChildren.every((id, i) => id == placements[i])) {
         gDirtyAreaCache.add(area);
       }
 
       if (areaProperties.has("overflowable")) {
         aToolbar.overflowable = new OverflowableToolbar(aToolbar);
       }
 
       this.registerBuildArea(area, aToolbar);
@@ -3132,25 +3136,23 @@ var CustomizableUI = {
   },
   /**
    * Register a concrete node for a registered area. This method is automatically
    * called from any toolbar in the main browser window that has its
    * "customizable" attribute set to true. There should normally be no need to
    * call it yourself.
    *
    * Note that ideally, you should register your toolbar using registerArea
-   * before any of the toolbars have their XBL bindings constructed (which
-   * will happen when they're added to the DOM and are not hidden). If you
-   * don't, the node will be saved for processing when you call
-   * registerArea. Note that CustomizableUI won't restore state in the area,
+   * before calling this. If you don't, the node will be saved for processing when
+   * you call registerArea. Note that CustomizableUI won't restore state in the area,
    * allow the user to customize it in customize mode, or otherwise deal
    * with it, until the area has been registered.
    */
-  registerToolbarNode(aToolbar, aExistingChildren) {
-    CustomizableUIInternal.registerToolbarNode(aToolbar, aExistingChildren);
+  registerToolbarNode(aToolbar) {
+    CustomizableUIInternal.registerToolbarNode(aToolbar);
   },
   /**
    * Register the menu panel node. This method should not be called by anyone
    * apart from the built-in PanelUI.
    * @param aPanelContents the panel contents DOM node being registered.
    * @param aArea the area for which to register this node.
    */
   registerMenuPanel(aPanelContents, aArea) {
diff --git a/browser/components/customizableui/content/toolbar.xml b/browser/components/customizableui/content/toolbar.xml
--- a/browser/components/customizableui/content/toolbar.xml
+++ b/browser/components/customizableui/content/toolbar.xml
@@ -4,43 +4,16 @@
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <bindings id="browserToolbarBindings"
           xmlns="http://www.mozilla.org/xbl"
           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
           xmlns:xbl="http://www.mozilla.org/xbl">
 
   <binding id="toolbar">
-    <implementation>
-      <constructor><![CDATA[
-          let scope = {};
-          ChromeUtils.import("resource:///modules/CustomizableUI.jsm", scope);
-          let CustomizableUI = scope.CustomizableUI;
-
-          // Searching for the toolbox palette in the toolbar binding because
-          // toolbars are constructed first.
-          let toolbox = this.closest("toolbox");
-          if (toolbox && !toolbox.palette) {
-            for (let node of toolbox.children) {
-              if (node.localName == "toolbarpalette") {
-                // Hold on to the palette but remove it from the document.
-                toolbox.palette = node;
-                toolbox.removeChild(node);
-                break;
-              }
-            }
-          }
-
-          // pass the current set of children for comparison with placements:
-          let children = Array.from(this.children)
-                              .filter(node => node.getAttribute("skipintoolbarset") != "true" && node.id)
-                              .map(node => node.id);
-          CustomizableUI.registerToolbarNode(this, children);
-      ]]></constructor>
-    </implementation>
   </binding>
 
   <!-- The toolbar-drag binding is almost a verbatim copy of its toolkit counterpart,
        but it inherits from the customizableui's toolbar binding instead of toolkit's.
        This functionality will move into CustomizableUI proper as part of our move
        away from XBL. -->
   <binding id="toolbar-drag"
            extends="chrome://browser/content/customizableui/toolbar.xml#toolbar">
diff --git a/browser/components/customizableui/test/browser_940013_registerToolbarNode_calls_registerArea.js b/browser/components/customizableui/test/browser_940013_registerToolbarNode_calls_registerArea.js
--- a/browser/components/customizableui/test/browser_940013_registerToolbarNode_calls_registerArea.js
+++ b/browser/components/customizableui/test/browser_940013_registerToolbarNode_calls_registerArea.js
@@ -12,16 +12,17 @@ registerCleanupFunction(cleanup);
 // wait for the registerArea call
 add_task(async function() {
   ok(CustomizableUI.inDefaultState, "Everything should be in its default state.");
   let btn = createDummyXULButton(kButtonId);
   let toolbar = document.createXULElement("toolbar");
   toolbar.id = kToolbarId;
   toolbar.setAttribute("customizable", true);
   gNavToolbox.appendChild(toolbar);
+  CustomizableUI.registerToolbarNode(toolbar);
   ok(!CustomizableUI.areas.includes(kToolbarId),
      "Toolbar should not yet have been registered automatically.");
   CustomizableUI.registerArea(kToolbarId, {defaultPlacements: [kButtonId]});
   ok(CustomizableUI.areas.includes(kToolbarId),
      "Toolbar should have been registered now.");
   is(CustomizableUI.getAreaType(kToolbarId), CustomizableUI.TYPE_TOOLBAR,
      "Area should be registered as toolbar");
   assertAreaPlacements(kToolbarId, [kButtonId]);
diff --git a/browser/components/customizableui/test/browser_995164_registerArea_during_customize_mode.js b/browser/components/customizableui/test/browser_995164_registerArea_during_customize_mode.js
--- a/browser/components/customizableui/test/browser_995164_registerArea_during_customize_mode.js
+++ b/browser/components/customizableui/test/browser_995164_registerArea_during_customize_mode.js
@@ -68,16 +68,17 @@ add_task(async function() {
     onAreaNodeRegistered(aArea, aNode) {
       if (aNode == otherTB) {
         wasInformedCorrectlyOfAreaAppearing = true;
       }
     },
   };
   CustomizableUI.addListener(listener);
   otherWin.gNavToolbox.appendChild(otherTB);
+  CustomizableUI.registerToolbarNode(otherTB);
   ok(wasInformedCorrectlyOfAreaAppearing, "Should have been told area was registered.");
   CustomizableUI.removeListener(listener);
 
   ok(otherTB.querySelector(`#${kNonPlacedWidgetId}`), "Button is on other toolbar, too.");
 
   simulateItemDrag(button, gNavToolbox.palette);
   ok(!CustomizableUI.getPlacementOfWidget(kNonPlacedWidgetId), "Button moved to the palette");
   ok(gNavToolbox.palette.querySelector(`#${kNonPlacedWidgetId}`), "Button really is in palette.");
diff --git a/browser/components/customizableui/test/browser_bootstrapped_custom_toolbar.js b/browser/components/customizableui/test/browser_bootstrapped_custom_toolbar.js
--- a/browser/components/customizableui/test/browser_bootstrapped_custom_toolbar.js
+++ b/browser/components/customizableui/test/browser_bootstrapped_custom_toolbar.js
@@ -12,16 +12,17 @@ const kWidgetID = "characterencoding-but
 function createTestBar() {
   let testBar = document.createXULElement("toolbar");
   testBar.id = kTestBarID;
   testBar.setAttribute("customizable", "true");
   CustomizableUI.registerArea(kTestBarID, {
     type: CustomizableUI.TYPE_TOOLBAR,
   });
   gNavToolbox.appendChild(testBar);
+  CustomizableUI.registerToolbarNode(testBar);
   return testBar;
 }
 
 /**
  * Helper function that does the following:
  *
  * 1) Creates a custom toolbar and registers it
  *    with CustomizableUI.
diff --git a/browser/components/customizableui/test/head.js b/browser/components/customizableui/test/head.js
--- a/browser/components/customizableui/test/head.js
+++ b/browser/components/customizableui/test/head.js
@@ -45,16 +45,17 @@ function createToolbarWithPlacements(id,
   let tb = document.createElementNS(kNSXUL, "toolbar");
   tb.id = id;
   tb.setAttribute("customizable", "true");
   CustomizableUI.registerArea(id, {
     type: CustomizableUI.TYPE_TOOLBAR,
     defaultPlacements: placements,
   });
   gNavToolbox.appendChild(tb);
+  CustomizableUI.registerToolbarNode(tb);
   return tb;
 }
 
 function createOverflowableToolbarWithPlacements(id, placements) {
   gAddedToolbars.add(id);
 
   let tb = document.createElementNS(kNSXUL, "toolbar");
   tb.id = id;
@@ -85,16 +86,17 @@ function createOverflowableToolbarWithPl
 
   tb.setAttribute("customizable", "true");
   tb.setAttribute("overflowable", "true");
   tb.setAttribute("overflowpanel", overflowPanel.id);
   tb.setAttribute("overflowtarget", overflowList.id);
   tb.setAttribute("overflowbutton", chevron.id);
 
   gNavToolbox.appendChild(tb);
+  CustomizableUI.registerToolbarNode(tb);
   return tb;
 }
 
 function removeCustomToolbars() {
   CustomizableUI.reset();
   for (let toolbarId of gAddedToolbars) {
     CustomizableUI.unregisterArea(toolbarId, true);
     let tb = document.getElementById(toolbarId);
