# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  bb568e9bb8504fc68a5ee12f883193661b3342e7
Bug 1291049 - remove some _setIMmediate calls

diff --git a/addon-sdk/source/lib/sdk/lang/functional/concurrent.js b/addon-sdk/source/lib/sdk/lang/functional/concurrent.js
--- a/addon-sdk/source/lib/sdk/lang/functional/concurrent.js
+++ b/addon-sdk/source/lib/sdk/lang/functional/concurrent.js
@@ -8,27 +8,27 @@
 
 "use strict";
 
 module.metadata = {
   "stability": "unstable"
 };
 
 const { arity, name, derive, invoke } = require("./helpers");
-const { setTimeout, clearTimeout, setImmediate } = require("../../timers");
+const { setTimeout, clearTimeout, _setImmediate } = require("../../timers");
 
 /**
  * Takes a function and returns a wrapped one instead, calling which will call
  * original function in the next turn of event loop. This is basically utility
  * to do `setImmediate(function() { ... })`, with a difference that returned
  * function is reused, instead of creating a new one each time. This also allows
  * to use this functions as event listeners.
  */
 const defer = f => derive(function(...args) {
-  setImmediate(invoke, f, args, this);
+  _setImmediate(invoke, f, args, this);
 }, f);
 exports.defer = defer;
 // Exporting `remit` alias as `defer` may conflict with promises.
 exports.remit = defer;
 
 /**
  * Much like setTimeout, invokes function after wait milliseconds. If you pass
  * the optional arguments, they will be forwarded on to the function when it is
diff --git a/addon-sdk/source/lib/sdk/output/system.js b/addon-sdk/source/lib/sdk/output/system.js
--- a/addon-sdk/source/lib/sdk/output/system.js
+++ b/addon-sdk/source/lib/sdk/output/system.js
@@ -1,17 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const { Cc, Ci, Cr } = require("chrome");
 const { Input, start, stop, receive, outputs } = require("../event/utils");
 const { id: addonID } = require("../self");
-const { setImmediate } = require("../timers");
+const { _setImmediate } = require("../timers");
 const { notifyObservers } = Cc['@mozilla.org/observer-service;1'].
                              getService(Ci.nsIObserverService);
 
 const NOT_AN_INPUT = "OutputPort can be used only for sending messages";
 
 // `OutputPort` creates a port to which messages can be send. Those
 // messages are actually disptached as `subject`'s of the observer
 // notifications. This is handy for communicating between different
@@ -60,12 +60,12 @@ OutputPort.receive = ({topic, sync}, mes
   // object so that observers could receive it.
   const subject = message === null ? null :
                   message instanceof Ci.nsISupports ? message :
                   message.wrappedJSObject ? message :
                   {wrappedJSObject: message};
   if (sync)
     notifyObservers(subject, topic, null);
   else
-    setImmediate(notifyObservers, subject, topic, null);
+    _setImmediate(notifyObservers, subject, topic, null);
 };
 OutputPort.prototype[receive] = OutputPort.receive;
 exports.OutputPort = OutputPort;
diff --git a/addon-sdk/source/lib/sdk/timers.js b/addon-sdk/source/lib/sdk/timers.js
--- a/addon-sdk/source/lib/sdk/timers.js
+++ b/addon-sdk/source/lib/sdk/timers.js
@@ -68,17 +68,17 @@ var dispatcher = _ => {
     if (immediate) {
       immediates.delete(id);
       try { immediate(); }
       catch (error) { console.exception(error); }
     }
   }
 }
 
-function setImmediate(callback, ...params) {
+function _setImmediate(callback, ...params) {
   let id = ++ lastID;
   // register new immediate timer with curried params.
   immediates.set(id, _ => callback.apply(callback, params));
   // if dispatch loop is not scheduled schedule one. Own scheduler
   if (!dispatcher.scheduled) {
     dispatcher.scheduled = true;
     threadManager.currentThread.dispatch(dispatcher,
                                          Ci.nsIThread.DISPATCH_NORMAL);
@@ -86,17 +86,17 @@ function setImmediate(callback, ...param
   return id;
 }
 
 function clearImmediate(id) {
   immediates.delete(id);
 }
 
 // Bind timers so that toString-ing them looks same as on native timers.
-exports.setImmediate = setImmediate.bind(null);
+exports._setImmediate = _setImmediate.bind(null);
 exports.clearImmediate = clearImmediate.bind(null);
 exports.setTimeout = setTimer.bind(null, TYPE_ONE_SHOT);
 exports.setInterval = setTimer.bind(null, TYPE_REPEATING_SLACK);
 exports.clearTimeout = unsetTimer.bind(null);
 exports.clearInterval = unsetTimer.bind(null);
 
 // all timers are cleared out on unload.
 unload(function() {
diff --git a/addon-sdk/source/lib/sdk/windows/firefox.js b/addon-sdk/source/lib/sdk/windows/firefox.js
--- a/addon-sdk/source/lib/sdk/windows/firefox.js
+++ b/addon-sdk/source/lib/sdk/windows/firefox.js
@@ -14,17 +14,16 @@ const { emit, emitOnObject, setListeners
 const { once } = require('../dom/events');
 const { EventTarget } = require('../event/target');
 const { getSelectedTab } = require('../tabs/utils');
 const { Cc, Ci } = require('chrome');
 const { Options } = require('../tabs/common');
 const system = require('../system/events');
 const { ignoreWindow, isPrivate, isWindowPBSupported } = require('../private-browsing/utils');
 const { data, isPrivateBrowsingSupported } = require('../self');
-const { setImmediate } = require('../timers');
 
 const supportPrivateWindows = isPrivateBrowsingSupported && isWindowPBSupported;
 
 const modelsFor = new WeakMap();
 const viewsFor = new WeakMap();
 
 const Window = Class({
   implements: [EventTarget],
diff --git a/addon-sdk/source/test/event/helpers.js b/addon-sdk/source/test/event/helpers.js
--- a/addon-sdk/source/test/event/helpers.js
+++ b/addon-sdk/source/test/event/helpers.js
@@ -1,17 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const { on, once, off, emit, count } = require("sdk/event/core");
 
-const { setImmediate, setTimeout } = require("sdk/timers");
+const { _setImmediate, setTimeout } = require("sdk/timers");
 const { defer } = require("sdk/core/promise");
 
 /**
  * Utility function that returns a promise once the specified event's `type`
  * is emitted on the given `target`, or the delay specified is passed.
  *
  * @param {Object|Number} [target]
  *    The delay to wait, or the object that receives the event.
@@ -25,17 +25,17 @@ const { defer } = require("sdk/core/prom
  * @returns {Promise}
  *    A promise resolved once the delay given is passed, or the object
  *    receives the event specified
  */
 const wait = function(target, type, capture) {
   let { promise, resolve, reject } = defer();
 
   if (!arguments.length) {
-    setImmediate(resolve);
+    _setImmediate(resolve);
   }
   else if (typeof(target) === "number") {
     setTimeout(resolve, target);
   }
   else if (typeof(target.once) === "function") {
     target.once(type, resolve);
   }
   else if (typeof(target.addEventListener) === "function") {
