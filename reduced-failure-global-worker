# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  1aa4c60fbfdbf868dc9f6775053b686889fb379a
Bug 1224073 - Reduced test case for errors failing in worker debugger

diff --git a/devtools/server/actors/utils/make-debugger.js b/devtools/server/actors/utils/make-debugger.js
--- a/devtools/server/actors/utils/make-debugger.js
+++ b/devtools/server/actors/utils/make-debugger.js
@@ -78,23 +78,27 @@ module.exports = function makeDebugger({
     for (let global of findDebuggees(this)) {
       safeAddDebuggee(this, global);
     }
   };
 
   return dbg;
 };
 
-const reportDebuggerHookException = e => reportException("Debugger Hook", e);
+const reportDebuggerHookException = e => {
+  dump("Debugger Hook " + e + "\n");
+  reportException("Debugger Hook", e);
+}
 
 /**
  * Add |global| as a debuggee to |dbg|, handling error cases.
  */
 function safeAddDebuggee(dbg, global) {
   try {
     let wrappedGlobal = dbg.addDebuggee(global);
     if (wrappedGlobal) {
       dbg.emit("newGlobal", wrappedGlobal);
     }
   } catch (e) {
+    dump("ERRROR " + e + "\n");
     // Ignoring attempt to add the debugger's compartment as a debuggee.
   }
 }
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -783,16 +783,19 @@ WebConsoleActor.prototype =
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response packet to send to with the unique id in the
    *         `resultID` field.
    */
   onEvaluateJSAsync: function WCA_onEvaluateJSAsync(aRequest)
   {
+    // this.reducedFailure(aRequest.text);
+    // return;
+
     // We want to be able to run console commands without waiting
     // for the first to return (see Bug 1088861).
 
     // First, send a response packet with the id only.
     let resultID = Date.now();
     this.conn.send({
       from: this.actorID,
       resultID: resultID
@@ -835,25 +838,34 @@ WebConsoleActor.prototype =
 
     let result, errorMessage, errorGrip = null;
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
+
         let error = evalResult.throw;
         errorGrip = this.createValueGrip(error);
-        // XXXworkers: Calling unsafeDereference() returns an object with no
-        // toString method in workers. See Bug 1215120.
-        let unsafeDereference = error && (typeof error === "object") &&
-                                error.unsafeDereference();
-        errorMessage = unsafeDereference && unsafeDereference.toString
-          ? unsafeDereference.toString()
-          : "" + error;
+        if (isWorker) {
+          let dbgWindow = this.dbg.makeGlobalObjectReference(this.evalWindow);
+          let evalErrorString = dbgWindow.executeInGlobalWithBindings("_self.toString()",
+                                                                      {_self: error});
+          errorMessage = evalErrorString.return;
+        } else {
+          // XXXworkers: Calling unsafeDereference() returns an object with no
+          // toString method in workers. See Bug 1215120.
+          let unsafeDereference = error && (typeof error === "object") &&
+                                  error.unsafeDereference();
+          errorMessage = unsafeDereference && unsafeDereference.toString
+            ? unsafeDereference.toString()
+            : "" + error;
+
+        }
       }
     }
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
     let resultGrip;
     try {
       resultGrip = this.createValueGrip(result);
@@ -1051,16 +1063,46 @@ WebConsoleActor.prototype =
         // Make sure the helpers can be used during eval.
         desc.value = aDebuggerGlobal.makeDebuggeeValue(desc.value);
       }
       Object.defineProperty(helpers.sandbox, name, desc);
     }
     return helpers;
   },
 
+  reducedFailure: function() {
+    dump("\n\n\nRunning reducedFailure - isWorker? " + isWorker + "\n")
+    let dbg = this.dbg;
+    let dbgWindow = dbg.makeGlobalObjectReference(this.evalWindow);
+    dump("1\n")
+    let result = dbgWindow.executeInGlobalWithBindings("throw new Error('Bug 1224073')",
+                                                       Object.create(null));
+    dump("2\n")
+    let error = result.throw;
+    let result2 = dbgWindow.executeInGlobalWithBindings("_self.toString()",
+                                                       {_self: error});
+
+    dump(result2.return + "\n\n");
+    // let errorGrip = this.createValueGrip(error);
+
+    // XXXworkers: Calling unsafeDereference() returns an object with no
+    // toString method in workers. See Bug 1215120.
+
+
+    let unsafeDereference = error && (typeof error === "object") &&
+                            error.unsafeDereference();
+    // let errorMessage = unsafeDereference && unsafeDereference.toString();
+    let errorMessage = unsafeDereference && unsafeDereference.toString
+      ? unsafeDereference.toString()
+      : "" + error;
+    dump("3\n")
+
+    dump ("Finished reducedFailure.  Error message: '" + errorMessage + "'\n\n\n");
+  },
+
   /**
    * Evaluates a string using the debugger API.
    *
    * To allow the variables view to update properties from the Web Console we
    * provide the "bindObjectActor" mechanism: the Web Console tells the
    * ObjectActor ID for which it desires to evaluate an expression. The
    * Debugger.Object pointed at by the actor ID is bound such that it is
    * available during expression evaluation (executeInGlobalWithBindings()).
diff --git a/js/src/vm/Debugger.cpp b/js/src/vm/Debugger.cpp
--- a/js/src/vm/Debugger.cpp
+++ b/js/src/vm/Debugger.cpp
@@ -1060,23 +1060,26 @@ Debugger::newCompletionValue(JSContext* 
         return true;
 
       default:
         MOZ_CRASH("bad status passed to Debugger::newCompletionValue");
     }
 
     /* Common tail for JSTRAP_RETURN and JSTRAP_THROW. */
     RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
+
     if (!obj ||
         !wrapDebuggeeValue(cx, &value) ||
         !NativeDefineProperty(cx, obj, key, value, nullptr, nullptr, JSPROP_ENUMERATE))
     {
-        return false;
-    }
-
+    printf("New completion value false");
+        return false;
+    }
+
+    printf("New completion value true");
     result.setObject(*obj);
     return true;
 }
 
 bool
 Debugger::receiveCompletionValue(Maybe<AutoCompartment>& ac, bool ok,
                                  HandleValue val,
                                  MutableHandleValue vp)
@@ -6800,16 +6803,17 @@ DebuggerGenericEval(JSContext* cx, const
 
         RootedObject dynamicScope(cx);
         if (!CreateScopeObjectsForScopeChain(cx, scopeChain, env, &dynamicScope))
             return false;
 
         env = dynamicScope;
     }
 
+    printf("Hi Brian \n");
     /* Run the code and produce the completion value. */
     RootedValue rval(cx);
     AbstractFramePtr frame = iter ? iter->abstractFramePtr() : NullFramePtr();
     jsbytecode* pc = iter ? iter->pc() : nullptr;
     AutoStableStringChars stableChars(cx);
     if (!stableChars.initTwoByte(cx, linear))
         return false;
 
