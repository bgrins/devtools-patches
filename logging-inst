# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2d3f230a14b1c7856fed9a84c7ea41a3a0aac942

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -18,17 +18,17 @@ if (window.MozXULElement) {
   return;
 }
 
 const MozElements = {};
 window.MozElements = MozElements;
 
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
-const instrumentClasses = false; // Flip this to get logging for perf data at startup
+const instrumentClasses = true; // Flip this to get logging for perf data at startup
 const instrumentedClasses = new Set();
 const baseClasses = new WeakSet();
 
 // Wrap the normal customElements.define to give us a chance to modify the
 // class so we can instrument function calls in local development:
 let define = window.customElements.define;
 window.customElements.define = function(name, c, opts) {
   instrumentCustomElementClass(c);
@@ -88,38 +88,43 @@ function instrumentIndividualClass(c) {
     return function() {
       if (!data[name]) {
         data[name] = {time: 0, calls: 0};
       }
       data[name].calls++;
       let n = performance.now();
       let r = fn.apply(this, arguments);
       data[name].time += performance.now() - n;
+      if (name == "attributeChangedCallback") {
+        console.log("Calling", c.name, arguments, name, data[name].calls, r);
+
+      }
       return r;
     };
   }
   function wrapPropertyDescriptor(obj, name) {
     let prop = Object.getOwnPropertyDescriptor(obj, name);
+    if (name == "attributeChangedCallback") {
+      console.log("Warpping", prop, name);
+
+    }
     if (prop.get) {
       prop.get = wrapFunction(`<get> ${name}`, prop.get);
     }
     if (prop.set) {
       prop.set = wrapFunction(`<set> ${name}`, prop.set);
     }
     if (prop.writable && prop.value && prop.value.apply) {
       prop.value = wrapFunction(name, prop.value);
     }
     Object.defineProperty(obj, name, prop);
   }
 
   // Handle static properties
   for (let name of Object.getOwnPropertyNames((c))) {
-    if (name == "implementCustomInterface") {
-      continue;
-    }
     wrapPropertyDescriptor(c, name);
   }
 
   // Handle instance properties
   for (let name of Object.getOwnPropertyNames(c.prototype)) {
     wrapPropertyDescriptor(c.prototype, name);
   }
 
