# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5ec40eb1a1049bfe86d03e20ba28f6dbc05a0dac

diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -25,16 +25,17 @@ var gContextMenuContentData = null;
 function setContextMenuContentData(data) {
   gContextMenuContentData = data;
 }
 
 function openContextMenu(aMessage) {
   let data = aMessage.data;
   let browser = aMessage.target;
   let spellInfo = data.spellInfo;
+  console.trace(data);
 
   // ContextMenu.jsm sends us the target as a CPOW only so that
   // we can send that CPOW back down to the content process and
   // have it resolve to a DOM node. The parent should not attempt
   // to access any properties on this CPOW (in fact, doing so
   // will throw an exception).
   data.context.targetAsCPOW = aMessage.objects.targetAsCPOW;
 
diff --git a/devtools/client/framework/toolbox-hosts.js b/devtools/client/framework/toolbox-hosts.js
--- a/devtools/client/framework/toolbox-hosts.js
+++ b/devtools/client/framework/toolbox-hosts.js
@@ -67,18 +67,30 @@ BottomHost.prototype = {
     this.frame.setAttribute("type", "content");
     this.frame.flex = 1; // Required to be able to shrink when the window shrinks
     this.frame.className = "devtools-toolbox-bottom-iframe";
     this.frame.height = Math.min(
       Services.prefs.getIntPref(this.heightPref),
       this._browserContainer.clientHeight - MIN_PAGE_SIZE
     );
 
+    // this.frame.messageManager.addMessageListener("contextmenu", {
+    //   receiveMessage(aMessage) {
+    //     let data = aMessage.data;
+    //     let browser = aMessage.target;
+    //     console.log(data, browser);
+    //     gBrowser.openContextMenu(aMessage);
+    //   },
+    // });
+
+
     this._browserContainer.appendChild(this._splitter);
     this._browserContainer.appendChild(this.frame);
+    this.frame.messageManager.addMessageListener(
+      "contextmenu", message => console.log(message));
 
     this.frame.tooltip = "aHTMLTooltip";
 
     // we have to load something so we can switch documents if we have to
     this.frame.setAttribute("src", "about:blank");
 
     const frame = await new Promise(resolve => {
       const domHelper = new DOMHelpers(this.frame.contentWindow);
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -1823,17 +1823,17 @@ Toolbox.prototype = {
       // Retrieve the tool definition (from the global or the per-toolbox tool maps)
       const definition = this.getToolDefinition(id);
 
       if (!definition) {
         reject(new Error("no such tool id " + id));
         return;
       }
 
-      iframe = this.doc.createXULElement("browser");
+      iframe = this.doc.createXULElement("iframe");
       iframe.className = "toolbox-panel-iframe";
       iframe.id = "toolbox-panel-iframe-" + id;
       iframe.setAttribute("flex", 1);
       iframe.setAttribute("forceOwnRefreshDriver", "");
       iframe.tooltip = "aHTMLTooltip";
       iframe.style.visibility = "hidden";
 
       gDevTools.emit(id + "-init", this, iframe);
diff --git a/toolkit/components/satchel/AutoCompletePopup.jsm b/toolkit/components/satchel/AutoCompletePopup.jsm
--- a/toolkit/components/satchel/AutoCompletePopup.jsm
+++ b/toolkit/components/satchel/AutoCompletePopup.jsm
@@ -150,16 +150,17 @@ this.AutoCompletePopup = {
     }
   },
 
   // Along with being called internally by the receiveMessage handler,
   // this function is also called directly by the login manager, which
   // uses a single message to fill in the autocomplete results. See
   // "PasswordManager:autoCompleteLogins".
   showPopupWithResults({ browser, rect, dir, results }) {
+    console.log(browser, rect, dir, results);
     if (!results.length || this.openedPopup) {
       // We shouldn't ever be showing an empty popup, and if we
       // already have a popup open, the old one needs to close before
       // we consider opening a new one.
       return;
     }
 
     let window = browser.ownerGlobal;
@@ -227,16 +228,17 @@ this.AutoCompletePopup = {
     }
   },
 
   removeLogin(login) {
     Services.logins.removeLogin(login);
   },
 
   receiveMessage(message) {
+    console.log(message.target, message.name, message.target.autoCompletePopup);
     if (!message.target.autoCompletePopup) {
       // Returning false to pacify ESLint, but this return value is
       // ignored by the messaging infrastructure.
       return false;
     }
 
     switch (message.name) {
       case "FormAutoComplete:SelectBy": {
