# HG changeset patch
# Parent 603396e6332e899ef6b114dd225714f044778b10
# User Michael Ratcliffe <mratcliffe@mozilla.com>
# Date 1410185583 -3600

Bug 1030318 - Fix browser_toolbox_options_disable_cache.js with e10s r=bgrins

diff --git a/browser/devtools/framework/test/browser.ini b/browser/devtools/framework/test/browser.ini
--- a/browser/devtools/framework/test/browser.ini
+++ b/browser/devtools/framework/test/browser.ini
@@ -15,17 +15,16 @@ support-files =
 [browser_target_remote.js]
 [browser_two_tabs.js]
 [browser_toolbox_dynamic_registration.js]
 [browser_toolbox_highlight.js]
 [browser_toolbox_hosts.js]
 [browser_toolbox_options.js]
 [browser_toolbox_options_disable_buttons.js]
 [browser_toolbox_options_disable_cache.js]
-skip-if = e10s # Bug 1030318
 [browser_toolbox_options_disable_js.js]
 # [browser_toolbox_raise.js] # Bug 962258
 # skip-if = os == "win"
 [browser_toolbox_ready.js]
 [browser_toolbox_select_event.js]
 [browser_toolbox_sidebar.js]
 [browser_toolbox_tabsswitch_shortcuts.js]
 [browser_toolbox_tool_ready.js]
diff --git a/browser/devtools/framework/test/browser_toolbox_options_disable_cache.js b/browser/devtools/framework/test/browser_toolbox_options_disable_cache.js
--- a/browser/devtools/framework/test/browser_toolbox_options_disable_cache.js
+++ b/browser/devtools/framework/test/browser_toolbox_options_disable_cache.js
@@ -48,21 +48,21 @@ let test = asyncTest(function*() {
   yield tabs[2].toolbox.destroy();
   tabs[2].target = TargetFactory.forTab(tabs[2].tab);
   yield checkCacheEnabled(tabs[2], true);
 
   // Open toolbox in tab 2 and ensure the cache is then disabled.
   tabs[2].toolbox = yield gDevTools.showToolbox(tabs[2].target, "options");
   yield checkCacheEnabled(tabs[2], false);
 
-  // Check the checkbox in tab 2 and ensure cache is enabled for all tabs.
+  // Clear the checkbox in tab 2 and ensure cache is enabled for all tabs.
   yield setDisableCacheCheckboxChecked(tabs[2], false);
   yield checkCacheStateForAllTabs([true, true, true, true]);
 
-  yield finishUp();
+  finishUp();
 });
 
 function* initTab(tabX, startToolbox) {
   tabX.tab = yield addTab(TEST_URI);
   tabX.target = TargetFactory.forTab(tabX.tab);
 
   if (startToolbox) {
     tabX.toolbox = yield gDevTools.showToolbox(tabX.target, "options");
@@ -99,28 +99,27 @@ function* checkCacheEnabled(tabX, expect
 }
 
 function* setDisableCacheCheckboxChecked(tabX, state) {
   gBrowser.selectedTab = tabX.tab;
 
   let panel = tabX.toolbox.getCurrentPanel();
   let cbx = panel.panelDoc.getElementById("devtools-disable-cache");
 
-  cbx.scrollIntoView();
-
-  // After uising scrollIntoView() we need to wait for the browser to scroll.
-  yield waitForTick();
+  yield scrollIntoView(cbx);
 
   if (cbx.checked !== state) {
     info("Setting disable cache checkbox to " + state + " for " + tabX.title);
-    EventUtils.synthesizeMouseAtCenter(cbx, {}, panel.panelWin);
+
+    EventUtils.synthesizeMouseAtCenter(cbx, {}, cbx.ownerGlobal);
+    info("Checkbox checked: " + cbx.checked);
 
     // We need to wait for all checkboxes to be updated and the docshells to
     // apply the new cache settings.
-    yield waitForTick();
+    yield wait(1000);
   }
 }
 
 function reloadTab(tabX) {
   let def = promise.defer();
   let browser = gBrowser.selectedBrowser;
 
   // once() doesn't work here so we use a standard handler instead.
@@ -132,31 +131,19 @@ function reloadTab(tabX) {
 
   info("Reloading tab " + tabX.title);
   let mm = getFrameScript();
   mm.sendAsyncMessage("devtools:test:reload");
 
   return def.promise;
 }
 
-function* destroyTab(tabX) {
-  let toolbox = gDevTools.getToolbox(tabX.target);
-
-  let onceDestroyed = promise.resolve();
-  if (toolbox) {
-    onceDestroyed = gDevTools.once("toolbox-destroyed");
-  }
-
-  info("Removing tab " + tabX.title);
+function destroyTab(tabX) {
   gBrowser.removeTab(tabX.tab);
-  info("Removed tab " + tabX.title);
-
-  info("Waiting for toolbox-destroyed");
-  yield onceDestroyed;
 }
 
-function* finishUp() {
+function finishUp() {
   for (let tab of tabs) {
-    yield destroyTab(tab);
+    destroyTab(tab);
   }
 
   tabs = null;
 }
diff --git a/browser/devtools/framework/test/head.js b/browser/devtools/framework/test/head.js
--- a/browser/devtools/framework/test/head.js
+++ b/browser/devtools/framework/test/head.js
@@ -3,16 +3,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 let TargetFactory = gDevTools.TargetFactory;
 
 const { console } = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 const { Promise: promise } = Cu.import("resource://gre/modules/Promise.jsm", {});
 const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 
+const SCROLL_INTO_VIEW_TIMEOUT = 250;
+
 let TargetFactory = devtools.TargetFactory;
 
 // All test are asynchronous
 waitForExplicitFinish();
 
 // Uncomment this pref to dump all devtools emitted events to the console.
 // Services.prefs.setBoolPref("devtools.dump.emit", true);
 
@@ -117,13 +119,52 @@ function once(target, eventName, useCapt
       }, useCapture);
       break;
     }
   }
 
   return deferred.promise;
 }
 
-function waitForTick() {
+/**
+ * This shouldn't be used in the tests unless absolutely necessary, but is
+ * useful when writing new tests or debugging existing tests in order to
+ * introduce delays in the test steps
+ * @param {Number} ms The time to wait
+ * @return A promise that resolves when the time is passed
+ */
+function wait(ms) {
+  let def = promise.defer();
+  setTimeout(def.resolve, ms);
+  return def.promise;
+}
+
+/**
+ * element.scrollIntoView() does not fire an event on scroll... event the scroll
+ * event is fired when scrolling begins. On e10s builds this event is fired even
+ * earlier so we need to wait a while to ensure that scrolling is complete.
+ *
+ * @param  {HTMLElement} element
+ *         Element to scroll to.
+ */
+function scrollIntoView(element) {
   let deferred = promise.defer();
-  executeSoon(deferred.resolve);
+  let scrollableParent = findScrollableParent(element);
+
+  setTimeout(deferred.resolve, SCROLL_INTO_VIEW_TIMEOUT);
+
+  element.scrollIntoView();
+
   return deferred.promise;
 }
+
+/**
+ * Find the closest scrollable element.
+ *
+ * @param  {HTMLElement} element
+ */
+function findScrollableParent(element) {
+  if (element.clientHeight < element.scrollHeight ||
+      element.clientWidth < element.scrollWidth) {
+    return element;
+  }
+  return findScrollableParent(element.parentNode);
+}
diff --git a/browser/devtools/markupview/test/browser_markupview_highlight_hover_01.js b/browser/devtools/markupview/test/browser_markupview_highlight_hover_01.js
--- a/browser/devtools/markupview/test/browser_markupview_highlight_hover_01.js
+++ b/browser/devtools/markupview/test/browser_markupview_highlight_hover_01.js
@@ -28,11 +28,11 @@ let test = asyncTest(function*() {
   ok(isHighlighterVisible(), "the highlighter is still visible");
   yield updated;
 });
 
 function waitForTheBrieflyShowBoxModelTimeout() {
   let deferred = promise.defer();
   // Note that the current timeout is 1 sec and is neither configurable nor
   // exported anywhere we can access, so hard-coding the timeout
-  content.setTimeout(deferred.resolve, 1500);
+  setTimeout(deferred.resolve, 1500);
   return deferred.promise;
 }
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -431,17 +431,17 @@ function searchUsingSelectorSearch(selec
 /**
  * This shouldn't be used in the tests, but is useful when writing new tests or
  * debugging existing tests in order to introduce delays in the test steps
  * @param {Number} ms The time to wait
  * @return A promise that resolves when the time is passed
  */
 function wait(ms) {
   let def = promise.defer();
-  content.setTimeout(def.resolve, ms);
+  setTimeout(def.resolve, ms);
   return def.promise;
 }
 
 /**
  * Wait for all current promises to be resolved. See this as executeSoon that
  * can be used with yield.
  */
 function promiseNextTick() {
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -332,17 +332,17 @@ function once(target, eventName, useCapt
 /**
  * This shouldn't be used in the tests, but is useful when writing new tests or
  * debugging existing tests in order to introduce delays in the test steps
  * @param {Number} ms The time to wait
  * @return A promise that resolves when the time is passed
  */
 function wait(ms) {
   let def = promise.defer();
-  content.setTimeout(def.resolve, ms);
+  setTimeout(def.resolve, ms);
   return def.promise;
 }
 
 /**
  * Wait for a content -> chrome message on the message manager (the window
  * messagemanager is used).
  * @param {String} name The message name
  * @return {Promise} A promise that resolves to the response data when the
