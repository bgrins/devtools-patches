# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  baf08f90919f0b0ba3cbf0af1c5c4e52da60da8b
Bug 1608278 - Automated rewrite away from assigning properties to `this` in JSM files - Round 1

This patch was generated with a script. It doesn't include all files (see --ignore-pattern below),
especially ones that use the preprocessor or were just too complicated for this version of the
script to deal with.

This was run with https://github.com/bgrins/jsm-rewrites/blob/d2bbd6c459294b65955442e45b5a7f5dba11e639/no-this-property-assign.js
and the following command:

hg revert --all && cp .gitignore .rgignore && rg -l -g '*.jsm' --iglob '!toolkit/components/osfile/*' '' | jscodeshift --stdin --transform ~/Code/jsm-rewrites/no-this-property-assign.js --ignore-pattern ./toolkit/modules/AppConstants.jsm --ignore-pattern ./layout/tools/reftest/manifest.jsm --ignore-pattern ./layout/tools/reftest/reftest.jsm --ignore-pattern ./toolkit/components/reader/Readerable.jsm  --ignore-pattern ./mobile/android/modules/Sanitizer.jsm --ignore-pattern ./js/xpconnect/tests/unit/syntax_error.jsm --ignore-pattern ./browser/components/enterprisepolicies/schemas/schema.jsm --ignore-pattern ./python/mozbuild/mozbuild/test/backend/data/build/qux.jsm --ignore-pattern ./python/mozbuild/mozbuild/test/backend/data/build/baz.jsm && ./mach eslint --outgoing --fix

diff --git a/browser/components/aboutlogins/LoginBreaches.jsm b/browser/components/aboutlogins/LoginBreaches.jsm
--- a/browser/components/aboutlogins/LoginBreaches.jsm
+++ b/browser/components/aboutlogins/LoginBreaches.jsm
@@ -17,17 +17,17 @@ const { XPCOMUtils } = ChromeUtils.impor
 );
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   LoginHelper: "resource://gre/modules/LoginHelper.jsm",
   RemoteSettings: "resource://services-settings/remote-settings.js",
   RemoteSettingsClient: "resource://services-settings/RemoteSettingsClient.jsm",
 });
 
-this.LoginBreaches = {
+const LoginBreaches = {
   REMOTE_SETTINGS_COLLECTION: "fxmonitor-breaches",
 
   async recordDismissal(loginGuid) {
     await Services.logins.initializationPromise;
     const storageJSON =
       Services.logins.wrappedJSObject._storage.wrappedJSObject;
 
     return storageJSON.recordBreachAlertDismissal(loginGuid);
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -4439,18 +4439,18 @@ var CustomizableUI = {
 
     parent.appendChild(aSubview);
   },
 
   getCustomizationTarget(aElement) {
     return CustomizableUIInternal.getCustomizationTarget(aElement);
   },
 };
-Object.freeze(this.CustomizableUI);
-Object.freeze(this.CustomizableUI.windows);
+Object.freeze(CustomizableUI);
+Object.freeze(CustomizableUI.windows);
 
 /**
  * All external consumers of widgets are really interacting with these wrappers
  * which provide a common interface.
  */
 
 /**
  * WidgetGroupWrapper is the common interface for interacting with an entire
diff --git a/browser/components/downloads/DownloadsCommon.jsm b/browser/components/downloads/DownloadsCommon.jsm
--- a/browser/components/downloads/DownloadsCommon.jsm
+++ b/browser/components/downloads/DownloadsCommon.jsm
@@ -657,20 +657,20 @@ var DownloadsCommon = {
       s.unblockButtonConfirmBlock,
       null,
       {}
     );
     return [firstButtonAction, "cancel", "confirmBlock"][rv];
   },
 };
 
-XPCOMUtils.defineLazyGetter(this.DownloadsCommon, "log", () => {
+XPCOMUtils.defineLazyGetter(DownloadsCommon, "log", () => {
   return DownloadsLogger.log.bind(DownloadsLogger);
 });
-XPCOMUtils.defineLazyGetter(this.DownloadsCommon, "error", () => {
+XPCOMUtils.defineLazyGetter(DownloadsCommon, "error", () => {
   return DownloadsLogger.error.bind(DownloadsLogger);
 });
 
 /**
  * Returns true if we are executing on Windows Vista or a later version.
  */
 XPCOMUtils.defineLazyGetter(DownloadsCommon, "isWinVistaOrHigher", function() {
   let os = Services.appinfo.OS;
diff --git a/browser/components/downloads/DownloadsViewUI.jsm b/browser/components/downloads/DownloadsViewUI.jsm
--- a/browser/components/downloads/DownloadsViewUI.jsm
+++ b/browser/components/downloads/DownloadsViewUI.jsm
@@ -107,17 +107,17 @@ var DownloadsViewUI = {
       return "";
     }
 
     let [size, unit] = DownloadUtils.convertByteUnits(download.target.size);
     return DownloadsCommon.strings.sizeWithUnits(size, unit);
   },
 };
 
-this.DownloadsViewUI.BaseView = class {
+DownloadsViewUI.BaseView = class {
   canClearDownloads(nodeContainer) {
     // Downloads can be cleared if there's at least one removable download in
     // the list (either a history download or a completed session download).
     // Because history downloads are always removable and are listed after the
     // session downloads, check from bottom to top.
     for (let elt = nodeContainer.lastChild; elt; elt = elt.previousSibling) {
       // Stopped, paused, and failed downloads with partial data are removed.
       let download = elt._shell.download;
@@ -137,19 +137,19 @@ this.DownloadsViewUI.BaseView = class {
  * from the JavaScript API for downloads, and commands are executed using a
  * combination of Download methods and DownloadsCommon.jsm helper functions.
  *
  * Specialized versions of this shell must be defined, and they are required to
  * implement the "download" property or getter. Currently these objects are the
  * HistoryDownloadElementShell and the DownloadsViewItem for the panel. The
  * history view may use a HistoryDownload object in place of a Download object.
  */
-this.DownloadsViewUI.DownloadElementShell = function() {};
+DownloadsViewUI.DownloadElementShell = function() {};
 
-this.DownloadsViewUI.DownloadElementShell.prototype = {
+DownloadsViewUI.DownloadElementShell.prototype = {
   /**
    * The richlistitem for the download, initialized by the derived object.
    */
   element: null,
 
   /**
    * Manages the "active" state of the shell. By default all the shells are
    * inactive, thus their UI is not updated. They must be activated when
diff --git a/browser/components/enterprisepolicies/helpers/BookmarksPolicies.jsm b/browser/components/enterprisepolicies/helpers/BookmarksPolicies.jsm
--- a/browser/components/enterprisepolicies/helpers/BookmarksPolicies.jsm
+++ b/browser/components/enterprisepolicies/helpers/BookmarksPolicies.jsm
@@ -58,19 +58,19 @@ XPCOMUtils.defineLazyGetter(this, "log",
     prefix: "BookmarksPolicies.jsm",
     // tip: set maxLogLevel to "debug" and use log.debug() to create detailed
     // messages during development. See LOG_LEVELS in Console.jsm for details.
     maxLogLevel: "error",
     maxLogLevelPref: PREF_LOGLEVEL,
   });
 });
 
-this.EXPORTED_SYMBOLS = ["BookmarksPolicies"];
+const EXPORTED_SYMBOLS = ["BookmarksPolicies"];
 
-this.BookmarksPolicies = {
+const BookmarksPolicies = {
   // These prefixes must only contain characters
   // allowed by PlacesUtils.isValidGuid
   BOOKMARK_GUID_PREFIX: "PolB-",
   FOLDER_GUID_PREFIX: "PolF-",
 
   /*
    * Process the bookmarks specified by the policy engine.
    *
diff --git a/browser/components/fxmonitor/FirefoxMonitor.jsm b/browser/components/fxmonitor/FirefoxMonitor.jsm
--- a/browser/components/fxmonitor/FirefoxMonitor.jsm
+++ b/browser/components/fxmonitor/FirefoxMonitor.jsm
@@ -17,17 +17,17 @@ XPCOMUtils.defineLazyModuleGetters(this,
   RemoteSettings: "resource://services-settings/remote-settings.js",
   Services: "resource://gre/modules/Services.jsm",
 });
 
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const STYLESHEET = "chrome://browser/content/fxmonitor/FirefoxMonitor.css";
 const ICON = "chrome://browser/content/fxmonitor/monitor32.svg";
 
-this.FirefoxMonitor = {
+const FirefoxMonitor = {
   // Map of breached site host -> breach metadata.
   domainMap: new Map(),
 
   // Reference to the extension object from the WebExtension context.
   // Used for getting URIs for resources packaged in the extension.
   extension: null,
 
   // Whether we've started observing for the user visiting a breached site.
diff --git a/browser/components/migration/ESEDBReader.jsm b/browser/components/migration/ESEDBReader.jsm
--- a/browser/components/migration/ESEDBReader.jsm
+++ b/browser/components/migration/ESEDBReader.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-var EXPORTED_SYMBOLS = ["ESEDBReader"]; /* exported ESEDBReader */
+var EXPORTED_SYMBOLS = ["ESEDBReader"];/* exported ESEDBReader */
 
 const { ctypes } = ChromeUtils.import("resource://gre/modules/ctypes.jsm");
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 XPCOMUtils.defineLazyGetter(this, "log", () => {
   let ConsoleAPI = ChromeUtils.import("resource://gre/modules/Console.jsm", {})
@@ -105,19 +105,16 @@ ESE.JET_COLUMNDEF = new ctypes.StructTyp
   { grbit: ESE.JET_GRBIT },
 ]);
 
 // Track open databases
 let gOpenDBs = new Map();
 
 // Track open libraries
 let gLibs = {};
-this.ESE = ESE; // Required for tests.
-this.KERNEL = KERNEL; // ditto
-this.gLibs = gLibs; // ditto
 
 function convertESEError(errorCode) {
   switch (errorCode) {
     case -1213 /* JET_errPageSizeMismatch */:
     case -1002 /* JET_errInvalidName*/:
     case -1507 /* JET_errColumnNotFound */:
       // The DB format has changed and we haven't updated this migration code:
       return "The database format has changed, error code: " + errorCode;
diff --git a/browser/components/newtab/common/Actions.jsm b/browser/components/newtab/common/Actions.jsm
--- a/browser/components/newtab/common/Actions.jsm
+++ b/browser/components/newtab/common/Actions.jsm
@@ -1,28 +1,26 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
-this.MAIN_MESSAGE_TYPE = "ActivityStream:Main";
-this.CONTENT_MESSAGE_TYPE = "ActivityStream:Content";
-this.PRELOAD_MESSAGE_TYPE = "ActivityStream:PreloadedBrowser";
-this.UI_CODE = 1;
-this.BACKGROUND_PROCESS = 2;
+const MAIN_MESSAGE_TYPE = "ActivityStream:Main";
+const CONTENT_MESSAGE_TYPE = "ActivityStream:Content";
+const PRELOAD_MESSAGE_TYPE = "ActivityStream:PreloadedBrowser";
+const UI_CODE = 1;
+const BACKGROUND_PROCESS = 2;
 
 /**
  * globalImportContext - Are we in UI code (i.e. react, a dom) or some kind of background process?
  *                       Use this in action creators if you need different logic
  *                       for ui/background processes.
  */
 const globalImportContext =
   typeof Window === "undefined" ? BACKGROUND_PROCESS : UI_CODE;
-// Export for tests
-this.globalImportContext = globalImportContext;
 
 // Create an object that avoids accidental differing key/value pairs:
 // {
 //   INIT: "INIT",
 //   UNINIT: "UNINIT"
 // }
 const actionTypes = {};
 for (const type of [
@@ -421,20 +419,17 @@ function WebExtEvent(type, data, importC
     throw new Error(
       'WebExtEvent actions should include a property "source", the id of the webextension that should receive the event.'
     );
   }
   const action = { type, data };
   return importContext === UI_CODE ? AlsoToMain(action) : action;
 }
 
-this.actionTypes = actionTypes;
-this.ASRouterActions = ASRouterActions;
-
-this.actionCreators = {
+const actionCreators = {
   BroadcastToContent,
   UserEvent,
   ASRouterUserEvent,
   UndesiredEvent,
   PerfEvent,
   ImpressionStats,
   AlsoToOneContent,
   OnlyToOneContent,
@@ -444,17 +439,17 @@ this.actionCreators = {
   SetPref,
   WebExtEvent,
   DiscoveryStreamImpressionStats,
   DiscoveryStreamLoadedContent,
   DiscoveryStreamSpocsFill,
 };
 
 // These are helpers to test for certain kinds of actions
-this.actionUtils = {
+const actionUtils = {
   isSendToMain(action) {
     if (!action.meta) {
       return false;
     }
     return (
       action.meta.to === MAIN_MESSAGE_TYPE &&
       action.meta.from === CONTENT_MESSAGE_TYPE
     );
diff --git a/browser/components/newtab/common/Dedupe.jsm b/browser/components/newtab/common/Dedupe.jsm
--- a/browser/components/newtab/common/Dedupe.jsm
+++ b/browser/components/newtab/common/Dedupe.jsm
@@ -1,13 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-this.Dedupe = class Dedupe {
+class Dedupe {
   constructor(createKey) {
     this.createKey = createKey || this.defaultCreateKey;
   }
 
   defaultCreateKey(item) {
     return item;
   }
 
diff --git a/browser/components/newtab/common/PerfService.jsm b/browser/components/newtab/common/PerfService.jsm
--- a/browser/components/newtab/common/PerfService.jsm
+++ b/browser/components/newtab/common/PerfService.jsm
@@ -115,10 +115,10 @@ function _PerfService(options) {
       throw new Error(`No marks with the name ${name}`);
     }
 
     let mostRecentEntry = entries[entries.length - 1];
     return this._perf.timeOrigin + mostRecentEntry.startTime;
   },
 };
 
-this.perfService = new _PerfService();
+const perfService = new _PerfService();
 const EXPORTED_SYMBOLS = ["_PerfService", "perfService"];
diff --git a/browser/components/newtab/common/Reducers.jsm b/browser/components/newtab/common/Reducers.jsm
--- a/browser/components/newtab/common/Reducers.jsm
+++ b/browser/components/newtab/common/Reducers.jsm
@@ -744,21 +744,17 @@ function Search(prevState = INITIAL_STAT
       return Object.assign({ ...prevState, fakeFocus: true });
     case at.SHOW_SEARCH:
       return Object.assign({ ...prevState, hide: false, fakeFocus: false });
     default:
       return prevState;
   }
 }
 
-this.INITIAL_STATE = INITIAL_STATE;
-this.TOP_SITES_DEFAULT_ROWS = TOP_SITES_DEFAULT_ROWS;
-this.TOP_SITES_MAX_SITES_PER_ROW = TOP_SITES_MAX_SITES_PER_ROW;
-
-this.reducers = {
+const reducers = {
   TopSites,
   App,
   ASRouter,
   Snippets,
   Prefs,
   Dialog,
   Sections,
   Pocket,
diff --git a/browser/components/newtab/lib/ASRouter.jsm b/browser/components/newtab/lib/ASRouter.jsm
--- a/browser/components/newtab/lib/ASRouter.jsm
+++ b/browser/components/newtab/lib/ASRouter.jsm
@@ -494,18 +494,16 @@ const MessageLoaderUtils = {
       }
     }
     if (dirty) {
       await storage.set(MessageLoaderUtils.REMOTE_LOADER_CACHE_KEY, cache);
     }
   },
 };
 
-this.MessageLoaderUtils = MessageLoaderUtils;
-
 /**
  * @class _ASRouter - Keeps track of all messages, UI surfaces, and
  * handles blocking, rotation, etc. Inspecting ASRouter.state will
  * tell you what the current displayed message is in all UI surfaces.
  *
  * Note: This is written as a constructor rather than just a plain object
  * so that it can be more easily unit tested.
  */
@@ -2190,23 +2188,21 @@ class _ASRouter {
         this.forceAttribution(action.data);
         break;
       default:
         Cu.reportError("Unknown message received");
         break;
     }
   }
 }
-this._ASRouter = _ASRouter;
-this.TRAILHEAD_CONFIG = TRAILHEAD_CONFIG;
 
 /**
  * ASRouter - singleton instance of _ASRouter that controls all messages
  * in the new tab page.
  */
-this.ASRouter = new _ASRouter();
+const ASRouter = new _ASRouter();
 
 const EXPORTED_SYMBOLS = [
   "_ASRouter",
   "ASRouter",
   "MessageLoaderUtils",
   "TRAILHEAD_CONFIG",
 ];
diff --git a/browser/components/newtab/lib/ASRouterFeed.jsm b/browser/components/newtab/lib/ASRouterFeed.jsm
--- a/browser/components/newtab/lib/ASRouterFeed.jsm
+++ b/browser/components/newtab/lib/ASRouterFeed.jsm
@@ -40,11 +40,10 @@ class ASRouterFeed {
         this.enable();
         break;
       case at.UNINIT:
         this.disable();
         break;
     }
   }
 }
-this.ASRouterFeed = ASRouterFeed;
 
 const EXPORTED_SYMBOLS = ["ASRouterFeed"];
diff --git a/browser/components/newtab/lib/ASRouterPreferences.jsm b/browser/components/newtab/lib/ASRouterPreferences.jsm
--- a/browser/components/newtab/lib/ASRouterPreferences.jsm
+++ b/browser/components/newtab/lib/ASRouterPreferences.jsm
@@ -248,22 +248,18 @@ class _ASRouterPreferences {
       for (const targetingPref of TARGETING_PREFERENCES) {
         Services.prefs.removeObserver(targetingPref, this);
       }
     }
     Object.assign(this, DEFAULT_STATE);
     this._callbacks.clear();
   }
 }
-this._ASRouterPreferences = _ASRouterPreferences;
 
-this.ASRouterPreferences = new _ASRouterPreferences();
-this.TEST_PROVIDERS = TEST_PROVIDERS;
-this.TARGETING_PREFERENCES = TARGETING_PREFERENCES;
-this.getTrailheadConfigFromPref = getTrailheadConfigFromPref;
+const ASRouterPreferences = new _ASRouterPreferences();
 
 const EXPORTED_SYMBOLS = [
   "_ASRouterPreferences",
   "ASRouterPreferences",
   "TEST_PROVIDERS",
   "TARGETING_PREFERENCES",
   "getTrailheadConfigFromPref",
 ];
diff --git a/browser/components/newtab/lib/ASRouterTargeting.jsm b/browser/components/newtab/lib/ASRouterTargeting.jsm
--- a/browser/components/newtab/lib/ASRouterTargeting.jsm
+++ b/browser/components/newtab/lib/ASRouterTargeting.jsm
@@ -556,17 +556,17 @@ const TargetingGetters = {
   get scores() {
     return ASRouterPreferences.personalizedCfrScores;
   },
   get scoreThreshold() {
     return ASRouterPreferences.personalizedCfrThreshold;
   },
 };
 
-this.ASRouterTargeting = {
+const ASRouterTargeting = {
   Environment: TargetingGetters,
 
   ERROR_TYPES: {
     MALFORMED_EXPRESSION: "MALFORMED_EXPRESSION",
     ATTRIBUTE_ERROR: "JEXL_ATTRIBUTE_GETTER_ERROR",
     OTHER_ERROR: "OTHER_ERROR",
   },
 
@@ -745,18 +745,14 @@ this.ASRouterTargeting = {
 
         matching.push(candidate);
       }
     }
     return matching;
   },
 };
 
-// Export for testing
-this.getSortedMessages = getSortedMessages;
-this.QueryCache = QueryCache;
-this.CachedTargetingGetter = CachedTargetingGetter;
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   "ASRouterTargeting",
   "QueryCache",
   "CachedTargetingGetter",
   "getSortedMessages",
 ];
diff --git a/browser/components/newtab/lib/ASRouterTriggerListeners.jsm b/browser/components/newtab/lib/ASRouterTriggerListeners.jsm
--- a/browser/components/newtab/lib/ASRouterTriggerListeners.jsm
+++ b/browser/components/newtab/lib/ASRouterTriggerListeners.jsm
@@ -80,17 +80,17 @@ function createMatchPatternSet(patterns,
   }
   return new MatchPatternSet([]);
 }
 
 /**
  * A Map from trigger IDs to singleton trigger listeners. Each listener must
  * have idempotent `init` and `uninit` methods.
  */
-this.ASRouterTriggerListeners = new Map([
+const ASRouterTriggerListeners = new Map([
   [
     "openArticleURL",
     {
       id: "openArticleURL",
       _initialized: false,
       _triggerHandler: null,
       _hosts: new Set(),
       _matchPatternSet: null,
diff --git a/browser/components/newtab/lib/AboutPreferences.jsm b/browser/components/newtab/lib/AboutPreferences.jsm
--- a/browser/components/newtab/lib/AboutPreferences.jsm
+++ b/browser/components/newtab/lib/AboutPreferences.jsm
@@ -63,17 +63,17 @@ const CUSTOM_CSS = `
   font-weight: 600;
 }
 #homeContentsGroup [data-subcategory] > vbox menulist {
   margin-top: 0;
   margin-bottom: 0;
 }
 `;
 
-this.AboutPreferences = class AboutPreferences {
+class AboutPreferences {
   init() {
     Services.obs.addObserver(this, PREFERENCES_LOADED_EVENT);
   }
 
   uninit() {
     Services.obs.removeObserver(this, PREFERENCES_LOADED_EVENT);
   }
 
@@ -283,10 +283,9 @@ this.AboutPreferences = class AboutPrefe
       });
     });
 
     // Update the visibility of the Restore Defaults btn based on checked prefs
     gHomePane.toggleRestoreDefaultsBtn();
   }
 };
 
-this.PREFERENCES_LOADED_EVENT = PREFERENCES_LOADED_EVENT;
 const EXPORTED_SYMBOLS = ["AboutPreferences", "PREFERENCES_LOADED_EVENT"];
diff --git a/browser/components/newtab/lib/ActivityStream.jsm b/browser/components/newtab/lib/ActivityStream.jsm
--- a/browser/components/newtab/lib/ActivityStream.jsm
+++ b/browser/components/newtab/lib/ActivityStream.jsm
@@ -619,17 +619,17 @@ const FEEDS_DATA = [
 
 const FEEDS_CONFIG = new Map();
 for (const config of FEEDS_DATA) {
   const pref = `feeds.${config.name}`;
   FEEDS_CONFIG.set(pref, config.factory);
   PREFS_CONFIG.set(pref, config);
 }
 
-this.ActivityStream = class ActivityStream {
+class ActivityStream {
   /**
    * constructor - Initializes an instance of ActivityStream
    */
   constructor() {
     this.initialized = false;
     this.store = new Store();
     this.feeds = FEEDS_CONFIG;
     this._defaultPrefs = new DefaultPrefs(PREFS_CONFIG);
diff --git a/browser/components/newtab/lib/ActivityStreamMessageChannel.jsm b/browser/components/newtab/lib/ActivityStreamMessageChannel.jsm
--- a/browser/components/newtab/lib/ActivityStreamMessageChannel.jsm
+++ b/browser/components/newtab/lib/ActivityStreamMessageChannel.jsm
@@ -28,17 +28,17 @@ const DEFAULT_OPTIONS = {
       }, but no dispatcher was defined.\n`
     );
   },
   pageURL: ABOUT_NEW_TAB_URL,
   outgoingMessageName: "ActivityStream:MainToContent",
   incomingMessageName: "ActivityStream:ContentToMain",
 };
 
-this.ActivityStreamMessageChannel = class ActivityStreamMessageChannel {
+class ActivityStreamMessageChannel {
   /**
    * ActivityStreamMessageChannel - This module connects a Redux store to a RemotePageManager in Firefox.
    *                  Call .createChannel to start the connection, and .destroyChannel to destroy it.
    *                  You should use the BroadcastToContent, AlsoToOneContent, and AlsoToMain action creators
    *                  in common/Actions.jsm to help you create actions that will be automatically routed
    *                  to the correct location.
    *
    * @param  {object} options
@@ -311,10 +311,9 @@ this.ActivityStreamMessageChannel = clas
     Object.assign(action, msg.data);
     // target is used to access a browser reference that came from the content
     // and should only be used in feeds (not reducers)
     action._target = msg.target;
     this.onActionFromContent(action, portID);
   }
 };
 
-this.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
 const EXPORTED_SYMBOLS = ["ActivityStreamMessageChannel", "DEFAULT_OPTIONS"];
diff --git a/browser/components/newtab/lib/ActivityStreamPrefs.jsm b/browser/components/newtab/lib/ActivityStreamPrefs.jsm
--- a/browser/components/newtab/lib/ActivityStreamPrefs.jsm
+++ b/browser/components/newtab/lib/ActivityStreamPrefs.jsm
@@ -7,17 +7,17 @@ const { AppConstants } = ChromeUtils.imp
   "resource://gre/modules/AppConstants.jsm"
 );
 const { Preferences } = ChromeUtils.import(
   "resource://gre/modules/Preferences.jsm"
 );
 
 const ACTIVITY_STREAM_PREF_BRANCH = "browser.newtabpage.activity-stream.";
 
-this.Prefs = class Prefs extends Preferences {
+class Prefs extends Preferences {
   /**
    * Prefs - A wrapper around Preferences that always sets the branch to
    *         ACTIVITY_STREAM_PREF_BRANCH
    */
   constructor(branch = ACTIVITY_STREAM_PREF_BRANCH) {
     super({ branch });
     this._branchObservers = new Map();
   }
@@ -32,17 +32,17 @@ this.Prefs = class Prefs extends Prefere
     const observer = (subject, topic, pref) => {
       listener.onPrefChanged(pref, this.get(pref));
     };
     this._prefBranch.addObserver("", observer);
     this._branchObservers.set(listener, observer);
   }
 };
 
-this.DefaultPrefs = class DefaultPrefs extends Preferences {
+class DefaultPrefs extends Preferences {
   /**
    * DefaultPrefs - A helper for setting and resetting default prefs for the add-on
    *
    * @param  {Map} config A Map with {string} key of the pref name and {object}
    *                      value with the following pref properties:
    *         {string} .title (optional) A description of the pref
    *         {bool|string|number} .value The default value for the pref
    * @param  {string} branch (optional) The pref branch (defaults to ACTIVITY_STREAM_PREF_BRANCH)
diff --git a/browser/components/newtab/lib/ActivityStreamStorage.jsm b/browser/components/newtab/lib/ActivityStreamStorage.jsm
--- a/browser/components/newtab/lib/ActivityStreamStorage.jsm
+++ b/browser/components/newtab/lib/ActivityStreamStorage.jsm
@@ -3,17 +3,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 ChromeUtils.defineModuleGetter(
   this,
   "IndexedDB",
   "resource://gre/modules/IndexedDB.jsm"
 );
 
-this.ActivityStreamStorage = class ActivityStreamStorage {
+class ActivityStreamStorage {
   /**
    * @param storeNames Array of strings used to create all the required stores
    */
   constructor({ storeNames, telemetry }) {
     if (!storeNames) {
       throw new Error("storeNames required");
     }
 
diff --git a/browser/components/newtab/lib/BookmarkPanelHub.jsm b/browser/components/newtab/lib/BookmarkPanelHub.jsm
--- a/browser/components/newtab/lib/BookmarkPanelHub.jsm
+++ b/browser/components/newtab/lib/BookmarkPanelHub.jsm
@@ -319,17 +319,15 @@ class _BookmarkPanelHub {
   _sendTelemetry(ping) {
     this._dispatch({
       type: "DOORHANGER_TELEMETRY",
       data: { action: "cfr_user_event", source: "CFR", ...ping },
     });
   }
 }
 
-this._BookmarkPanelHub = _BookmarkPanelHub;
-
 /**
  * BookmarkPanelHub - singleton instance of _BookmarkPanelHub that can initiate
  * message requests and render messages.
  */
-this.BookmarkPanelHub = new _BookmarkPanelHub();
+const BookmarkPanelHub = new _BookmarkPanelHub();
 
 const EXPORTED_SYMBOLS = ["BookmarkPanelHub", "_BookmarkPanelHub"];
diff --git a/browser/components/newtab/lib/CFRMessageProvider.jsm b/browser/components/newtab/lib/CFRMessageProvider.jsm
--- a/browser/components/newtab/lib/CFRMessageProvider.jsm
+++ b/browser/components/newtab/lib/CFRMessageProvider.jsm
@@ -812,11 +812,10 @@ const CFR_MESSAGES = [
   },
 ];
 
 const CFRMessageProvider = {
   getMessages() {
     return CFR_MESSAGES.filter(msg => !msg.exclude);
   },
 };
-this.CFRMessageProvider = CFRMessageProvider;
 
 const EXPORTED_SYMBOLS = ["CFRMessageProvider"];
diff --git a/browser/components/newtab/lib/CFRPageActions.jsm b/browser/components/newtab/lib/CFRPageActions.jsm
--- a/browser/components/newtab/lib/CFRPageActions.jsm
+++ b/browser/components/newtab/lib/CFRPageActions.jsm
@@ -1115,12 +1115,9 @@ const CFRPageActions = {
       if (win.closed || !PageActionMap.has(win)) {
         continue;
       }
       PageActionMap.get(win).reloadL10n();
     }
   },
 };
 
-this.PageAction = PageAction;
-this.CFRPageActions = CFRPageActions;
-
 const EXPORTED_SYMBOLS = ["CFRPageActions", "PageAction"];
diff --git a/browser/components/newtab/lib/DiscoveryStreamFeed.jsm b/browser/components/newtab/lib/DiscoveryStreamFeed.jsm
--- a/browser/components/newtab/lib/DiscoveryStreamFeed.jsm
+++ b/browser/components/newtab/lib/DiscoveryStreamFeed.jsm
@@ -63,17 +63,17 @@ const PREF_TOPSTORIES = "feeds.section.t
 const PREF_SPOCS_CLEAR_ENDPOINT = "discoverystream.endpointSpocsClear";
 const PREF_SHOW_SPONSORED = "showSponsored";
 const PREF_SPOC_IMPRESSIONS = "discoverystream.spoc.impressions";
 const PREF_FLIGHT_BLOCKS = "discoverystream.flight.blocks";
 const PREF_REC_IMPRESSIONS = "discoverystream.rec.impressions";
 
 let getHardcodedLayout;
 
-this.DiscoveryStreamFeed = class DiscoveryStreamFeed {
+class DiscoveryStreamFeed {
   constructor() {
     // Internal state for checking if we've intialized all our data
     this.loaded = false;
 
     // Persistent cache for remote endpoint data.
     this.cache = new PersistentCache(CACHE_KEY, true);
     this.locale = Services.locale.appLocaleAsLangTag;
     this._impressionId = this.getOrCreateImpressionId();
diff --git a/browser/components/newtab/lib/DownloadsManager.jsm b/browser/components/newtab/lib/DownloadsManager.jsm
--- a/browser/components/newtab/lib/DownloadsManager.jsm
+++ b/browser/components/newtab/lib/DownloadsManager.jsm
@@ -16,17 +16,17 @@ XPCOMUtils.defineLazyModuleGetters(this,
   DownloadsCommon: "resource:///modules/DownloadsCommon.jsm",
   DownloadsViewUI: "resource:///modules/DownloadsViewUI.jsm",
   FileUtils: "resource://gre/modules/FileUtils.jsm",
   NewTabUtils: "resource://gre/modules/NewTabUtils.jsm",
 });
 
 const DOWNLOAD_CHANGED_DELAY_TIME = 1000; // time in ms to delay timer for downloads changed events
 
-this.DownloadsManager = class DownloadsManager {
+class DownloadsManager {
   constructor(store) {
     this._downloadData = null;
     this._store = null;
     this._downloadItems = new Map();
     this._downloadTimer = null;
   }
 
   setTimeout(callback, delay) {
@@ -183,9 +183,9 @@ this.DownloadsManager = class DownloadsM
         });
         break;
       case at.UNINIT:
         this.uninit();
         break;
     }
   }
 };
-this.EXPORTED_SYMBOLS = ["DownloadsManager"];
+const EXPORTED_SYMBOLS = ["DownloadsManager"];
diff --git a/browser/components/newtab/lib/FaviconFeed.jsm b/browser/components/newtab/lib/FaviconFeed.jsm
--- a/browser/components/newtab/lib/FaviconFeed.jsm
+++ b/browser/components/newtab/lib/FaviconFeed.jsm
@@ -126,17 +126,17 @@ async function fetchIconFromRedirects(ur
         PlacesUtils.favicons.FAVICON_LOAD_NON_PRIVATE,
         null,
         Services.scriptSecurityManager.getSystemPrincipal()
       );
     }
   }
 }
 
-this.FaviconFeed = class FaviconFeed {
+class FaviconFeed {
   constructor() {
     this._queryForRedirects = new Set();
   }
 
   /**
    * fetchIcon attempts to fetch a rich icon for the given url from two sources.
    * First, it looks up the tippy top feed, if it's still missing, then it queries
    * the places for rich icon with its most recent visit in order to deal with
diff --git a/browser/components/newtab/lib/GroupsConfigurationProvider.jsm b/browser/components/newtab/lib/GroupsConfigurationProvider.jsm
--- a/browser/components/newtab/lib/GroupsConfigurationProvider.jsm
+++ b/browser/components/newtab/lib/GroupsConfigurationProvider.jsm
@@ -5,11 +5,10 @@
 
 const MESSAGES = [];
 
 const GroupsConfigurationProvider = {
   getMessages() {
     return MESSAGES;
   },
 };
-this.GroupsConfigurationProvider = GroupsConfigurationProvider;
 
 const EXPORTED_SYMBOLS = ["GroupsConfigurationProvider"];
diff --git a/browser/components/newtab/lib/HighlightsFeed.jsm b/browser/components/newtab/lib/HighlightsFeed.jsm
--- a/browser/components/newtab/lib/HighlightsFeed.jsm
+++ b/browser/components/newtab/lib/HighlightsFeed.jsm
@@ -59,17 +59,17 @@ const MANY_EXTRA_LENGTH =
   HIGHLIGHTS_MAX_LENGTH * 5 +
   TOP_SITES_DEFAULT_ROWS * TOP_SITES_MAX_SITES_PER_ROW;
 const SECTION_ID = "highlights";
 const SYNC_BOOKMARKS_FINISHED_EVENT = "weave:engine:sync:applied";
 const BOOKMARKS_RESTORE_SUCCESS_EVENT = "bookmarks-restore-success";
 const BOOKMARKS_RESTORE_FAILED_EVENT = "bookmarks-restore-failed";
 const RECENT_DOWNLOAD_THRESHOLD = 36 * 60 * 60 * 1000;
 
-this.HighlightsFeed = class HighlightsFeed {
+class HighlightsFeed {
   constructor() {
     this.dedupe = new Dedupe(this._dedupeKey);
     this.linksCache = new LinksCache(
       NewTabUtils.activityStreamLinks,
       "getHighlights",
       ["image"]
     );
     PageThumbs.addExpirationFilter(this);
diff --git a/browser/components/newtab/lib/LinksCache.jsm b/browser/components/newtab/lib/LinksCache.jsm
--- a/browser/components/newtab/lib/LinksCache.jsm
+++ b/browser/components/newtab/lib/LinksCache.jsm
@@ -13,17 +13,17 @@ const EXPORTED_SYMBOLS = ["LinksCache"];
 // https://github.com/mozilla/activity-stream/pull/3695#discussion_r144678214
 const EXPIRATION_TIME = 4.5 * 60 * 1000; // 4.5 minutes
 
 /**
  * Cache link results from a provided object property and refresh after some
  * amount of time has passed. Allows for migrating data from previously cached
  * links to the new links with the same url.
  */
-this.LinksCache = class LinksCache {
+class LinksCache {
   /**
    * Create a links cache for a given object property.
    *
    * @param {object} linkObject Object containing the link property
    * @param {string} linkProperty Name of property on object to access
    * @param {array} properties Optional properties list to migrate to new links.
    * @param {function} shouldRefresh Optional callback receiving the old and new
    *                                 options to refresh even when not expired.
diff --git a/browser/components/newtab/lib/NaiveBayesTextTagger.jsm b/browser/components/newtab/lib/NaiveBayesTextTagger.jsm
--- a/browser/components/newtab/lib/NaiveBayesTextTagger.jsm
+++ b/browser/components/newtab/lib/NaiveBayesTextTagger.jsm
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const { toksToTfIdfVector } = ChromeUtils.import(
   "resource://activity-stream/lib/Tokenize.jsm"
 );
 
-this.NaiveBayesTextTagger = class NaiveBayesTextTagger {
+class NaiveBayesTextTagger {
   constructor(model) {
     this.model = model;
   }
 
   /**
    * Determines if the tokenized text belongs to class according to binary naive Bayes
    * classifier. Returns an object containing the class label ("label"), and
    * the log probability ("logProb") that the text belongs to that class. If
diff --git a/browser/components/newtab/lib/NewTabInit.jsm b/browser/components/newtab/lib/NewTabInit.jsm
--- a/browser/components/newtab/lib/NewTabInit.jsm
+++ b/browser/components/newtab/lib/NewTabInit.jsm
@@ -6,17 +6,17 @@
 const { actionCreators: ac, actionTypes: at } = ChromeUtils.import(
   "resource://activity-stream/common/Actions.jsm"
 );
 
 /**
  * NewTabInit - A placeholder for now. This will send a copy of the state to all
  *              newly opened tabs.
  */
-this.NewTabInit = class NewTabInit {
+class NewTabInit {
   constructor() {
     this._repliedEarlyTabs = new Map();
   }
 
   reply(target) {
     // Skip this reply if we already replied to an early tab
     if (this._repliedEarlyTabs.get(target)) {
       return;
diff --git a/browser/components/newtab/lib/NmfTextTagger.jsm b/browser/components/newtab/lib/NmfTextTagger.jsm
--- a/browser/components/newtab/lib/NmfTextTagger.jsm
+++ b/browser/components/newtab/lib/NmfTextTagger.jsm
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const { toksToTfIdfVector } = ChromeUtils.import(
   "resource://activity-stream/lib/Tokenize.jsm"
 );
 
-this.NmfTextTagger = class NmfTextTagger {
+class NmfTextTagger {
   constructor(model) {
     this.model = model;
   }
 
   /**
    * A multiclass classifier that scores tokenized text against several classes through
    * inference of a nonnegative matrix factorization of TF-IDF vectors and
    * class labels. Returns a map of class labels as string keys to scores.
diff --git a/browser/components/newtab/lib/OnboardingMessageProvider.jsm b/browser/components/newtab/lib/OnboardingMessageProvider.jsm
--- a/browser/components/newtab/lib/OnboardingMessageProvider.jsm
+++ b/browser/components/newtab/lib/OnboardingMessageProvider.jsm
@@ -631,11 +631,10 @@ const OnboardingMessageProvider = {
     } catch (e) {
       Cu.reportError(
         "Failed to get the latest add-on version for Return to AMO"
       );
       return null;
     }
   },
 };
-this.OnboardingMessageProvider = OnboardingMessageProvider;
 
 const EXPORTED_SYMBOLS = ["OnboardingMessageProvider"];
diff --git a/browser/components/newtab/lib/PanelTestProvider.jsm b/browser/components/newtab/lib/PanelTestProvider.jsm
--- a/browser/components/newtab/lib/PanelTestProvider.jsm
+++ b/browser/components/newtab/lib/PanelTestProvider.jsm
@@ -483,11 +483,10 @@ const MESSAGES = () => [
 const PanelTestProvider = {
   getMessages() {
     return MESSAGES().map(message => ({
       ...message,
       targeting: `providerCohorts.panel_local_testing == "SHOW_TEST"`,
     }));
   },
 };
-this.PanelTestProvider = PanelTestProvider;
 
 const EXPORTED_SYMBOLS = ["PanelTestProvider"];
diff --git a/browser/components/newtab/lib/PersistentCache.jsm b/browser/components/newtab/lib/PersistentCache.jsm
--- a/browser/components/newtab/lib/PersistentCache.jsm
+++ b/browser/components/newtab/lib/PersistentCache.jsm
@@ -8,17 +8,17 @@ const { XPCOMUtils } = ChromeUtils.impor
 );
 
 ChromeUtils.defineModuleGetter(this, "OS", "resource://gre/modules/osfile.jsm");
 XPCOMUtils.defineLazyGlobalGetters(this, ["fetch"]);
 
 /**
  * A file (disk) based persistent cache of a JSON serializable object.
  */
-this.PersistentCache = class PersistentCache {
+class PersistentCache {
   /**
    * Create a cache object based on a name.
    *
    * @param {string} name Name of the cache. It will be used to create the filename.
    * @param {boolean} preload (optional). Whether the cache should be preloaded from file. Defaults to false.
    */
   constructor(name, preload = false) {
     this.name = name;
diff --git a/browser/components/newtab/lib/PersonalityProvider.jsm b/browser/components/newtab/lib/PersonalityProvider.jsm
--- a/browser/components/newtab/lib/PersonalityProvider.jsm
+++ b/browser/components/newtab/lib/PersonalityProvider.jsm
@@ -81,17 +81,17 @@ function getHash(aStr) {
     .toLowerCase();
 }
 
 /**
  * V2 provider builds and ranks an interest profile (also called an “interest vector”) off the browse history.
  * This allows Firefox to classify pages into topics, by examining the text found on the page.
  * It does this by looking at the history text content, title, and description.
  */
-this.PersonalityProvider = class PersonalityProvider {
+class PersonalityProvider {
   constructor(
     timeSegments,
     parameterSets,
     maxHistoryQueryResults,
     version,
     scores,
     v2Params
   ) {
diff --git a/browser/components/newtab/lib/PlacesFeed.jsm b/browser/components/newtab/lib/PlacesFeed.jsm
--- a/browser/components/newtab/lib/PlacesFeed.jsm
+++ b/browser/components/newtab/lib/PlacesFeed.jsm
@@ -501,16 +501,14 @@ class PlacesFeed {
       case at.OPEN_LINK: {
         this.openLink(action);
         break;
       }
     }
   }
 }
 
-this.PlacesFeed = PlacesFeed;
-
 // Exported for testing only
 PlacesFeed.HistoryObserver = HistoryObserver;
 PlacesFeed.BookmarksObserver = BookmarksObserver;
 PlacesFeed.PlacesObserver = PlacesObserver;
 
 const EXPORTED_SYMBOLS = ["PlacesFeed"];
diff --git a/browser/components/newtab/lib/PrefsFeed.jsm b/browser/components/newtab/lib/PrefsFeed.jsm
--- a/browser/components/newtab/lib/PrefsFeed.jsm
+++ b/browser/components/newtab/lib/PrefsFeed.jsm
@@ -18,17 +18,17 @@ ChromeUtils.defineModuleGetter(
 );
 
 ChromeUtils.defineModuleGetter(
   this,
   "AppConstants",
   "resource://gre/modules/AppConstants.jsm"
 );
 
-this.PrefsFeed = class PrefsFeed {
+class PrefsFeed {
   constructor(prefMap) {
     this._prefMap = prefMap;
     this._prefs = new Prefs();
   }
 
   onPrefChanged(name, value) {
     const prefItem = this._prefMap.get(name);
     if (prefItem) {
diff --git a/browser/components/newtab/lib/RecipeExecutor.jsm b/browser/components/newtab/lib/RecipeExecutor.jsm
--- a/browser/components/newtab/lib/RecipeExecutor.jsm
+++ b/browser/components/newtab/lib/RecipeExecutor.jsm
@@ -24,17 +24,17 @@ const { tokenize } = ChromeUtils.import(
  *   {"function": "nb_tag", "fields": ["title", "description"]},
  *   {"function": "conditionally_nmf_tag", "fields": ["title", "description"]} ]
  *
  * Recipes are sandboxed by the fact that the step functions must be explicitly
  * whitelisted. Functions whitelisted for builder recipes are specifed in the
  * RecipeExecutor.ITEM_BUILDER_REGISTRY, while combiner functions are whitelisted
  * in RecipeExecutor.ITEM_COMBINER_REGISTRY .
  */
-this.RecipeExecutor = class RecipeExecutor {
+class RecipeExecutor {
   constructor(nbTaggers, nmfTaggers) {
     this.ITEM_BUILDER_REGISTRY = {
       nb_tag: this.naiveBayesTag,
       conditionally_nmf_tag: this.conditionallyNmfTag,
       accept_item_by_field_value: this.acceptItemByFieldValue,
       tokenize_url: this.tokenizeUrl,
       get_url_domain: this.getUrlDomain,
       tokenize_field: this.tokenizeField,
diff --git a/browser/components/newtab/lib/RemoteL10n.jsm b/browser/components/newtab/lib/RemoteL10n.jsm
--- a/browser/components/newtab/lib/RemoteL10n.jsm
+++ b/browser/components/newtab/lib/RemoteL10n.jsm
@@ -82,11 +82,11 @@ class _RemoteL10n {
     return this._l10n;
   }
 
   reloadL10n() {
     this._l10n = null;
   }
 }
 
-this.RemoteL10n = new _RemoteL10n();
+const RemoteL10n = new _RemoteL10n();
 
 const EXPORTED_SYMBOLS = ["RemoteL10n", "_RemoteL10n"];
diff --git a/browser/components/newtab/lib/Screenshots.jsm b/browser/components/newtab/lib/Screenshots.jsm
--- a/browser/components/newtab/lib/Screenshots.jsm
+++ b/browser/components/newtab/lib/Screenshots.jsm
@@ -25,17 +25,17 @@ ChromeUtils.defineModuleGetter(
 ChromeUtils.defineModuleGetter(
   this,
   "Services",
   "resource://gre/modules/Services.jsm"
 );
 
 const GREY_10 = "#F9F9FA";
 
-this.Screenshots = {
+const Screenshots = {
   /**
    * Get a screenshot / thumbnail for a url. Either returns the disk cached
    * image or initiates a background request for the url.
    *
    * @param url {string} The url to get a thumbnail
    * @return {Promise} Resolves a custom object or null if failed
    */
   async getScreenshotForURL(url) {
diff --git a/browser/components/newtab/lib/SearchShortcuts.jsm b/browser/components/newtab/lib/SearchShortcuts.jsm
--- a/browser/components/newtab/lib/SearchShortcuts.jsm
+++ b/browser/components/newtab/lib/SearchShortcuts.jsm
@@ -12,20 +12,19 @@ const SEARCH_SHORTCUTS = [
   { keyword: "@\u767E\u5EA6", shortURL: "baidu", url: "https://baidu.com" },
   { keyword: "@google", shortURL: "google", url: "https://google.com" },
   {
     keyword: "@\u044F\u043D\u0434\u0435\u043A\u0441",
     shortURL: "yandex",
     url: "https://yandex.com",
   },
 ];
-this.SEARCH_SHORTCUTS = SEARCH_SHORTCUTS;
 
 // These can be added via the editor but will not be added organically
-this.CUSTOM_SEARCH_SHORTCUTS = [
+const CUSTOM_SEARCH_SHORTCUTS = [
   ...SEARCH_SHORTCUTS,
   { keyword: "@bing", shortURL: "bing", url: "https://bing.com" },
   {
     keyword: "@duckduckgo",
     shortURL: "duckduckgo",
     url: "https://duckduckgo.com",
   },
   { keyword: "@ebay", shortURL: "ebay", url: "https://ebay.com" },
@@ -33,38 +32,34 @@ this.CUSTOM_SEARCH_SHORTCUTS = [
   {
     keyword: "@wikipedia",
     shortURL: "wikipedia",
     url: "https://wikipedia.org",
   },
 ];
 
 // Note: you must add the activity stream branch to the beginning of this if using outside activity stream
-this.SEARCH_SHORTCUTS_EXPERIMENT = "improvesearch.topSiteSearchShortcuts";
-this.SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF =
-  "improvesearch.topSiteSearchShortcuts.searchEngines";
-this.SEARCH_SHORTCUTS_HAVE_PINNED_PREF =
-  "improvesearch.topSiteSearchShortcuts.havePinned";
+const SEARCH_SHORTCUTS_EXPERIMENT = "improvesearch.topSiteSearchShortcuts";
+const SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF = "improvesearch.topSiteSearchShortcuts.searchEngines";
+const SEARCH_SHORTCUTS_HAVE_PINNED_PREF = "improvesearch.topSiteSearchShortcuts.havePinned";
 
 function getSearchProvider(candidateShortURL) {
   return (
     SEARCH_SHORTCUTS.filter(match => candidateShortURL === match.shortURL)[0] ||
     null
   );
 }
-this.getSearchProvider = getSearchProvider;
 
 // Check topsite against predefined list of valid search engines
 // https://searchfox.org/mozilla-central/rev/ca869724246f4230b272ed1c8b9944596e80d920/toolkit/components/search/nsSearchService.js#939
 async function checkHasSearchEngine(keyword) {
   return (await Services.search.getDefaultEngines()).find(e =>
     e.wrappedJSObject._internalAliases.includes(keyword)
   );
 }
-this.checkHasSearchEngine = checkHasSearchEngine;
 
 const EXPORTED_SYMBOLS = [
   "checkHasSearchEngine",
   "getSearchProvider",
   "SEARCH_SHORTCUTS",
   "CUSTOM_SEARCH_SHORTCUTS",
   "SEARCH_SHORTCUTS_EXPERIMENT",
   "SEARCH_SHORTCUTS_SEARCH_ENGINES_PREF",
diff --git a/browser/components/newtab/lib/SectionsManager.jsm b/browser/components/newtab/lib/SectionsManager.jsm
--- a/browser/components/newtab/lib/SectionsManager.jsm
+++ b/browser/components/newtab/lib/SectionsManager.jsm
@@ -630,11 +630,9 @@ class SectionsFeed {
         SectionsManager.ACTION_DISPATCHED,
         action.type,
         action.data
       );
     }
   }
 }
 
-this.SectionsFeed = SectionsFeed;
-this.SectionsManager = SectionsManager;
 const EXPORTED_SYMBOLS = ["SectionsFeed", "SectionsManager"];
diff --git a/browser/components/newtab/lib/SnippetsTestMessageProvider.jsm b/browser/components/newtab/lib/SnippetsTestMessageProvider.jsm
--- a/browser/components/newtab/lib/SnippetsTestMessageProvider.jsm
+++ b/browser/components/newtab/lib/SnippetsTestMessageProvider.jsm
@@ -611,11 +611,10 @@ const SnippetsTestMessageProvider = {
         // Ensures we never actually show test except when triggered by debug tools
         .map(message => ({
           ...message,
           targeting: `providerCohorts.snippets_local_testing == "SHOW_TEST"`,
         }))
     );
   },
 };
-this.SnippetsTestMessageProvider = SnippetsTestMessageProvider;
 
 const EXPORTED_SYMBOLS = ["SnippetsTestMessageProvider"];
diff --git a/browser/components/newtab/lib/Store.jsm b/browser/components/newtab/lib/Store.jsm
--- a/browser/components/newtab/lib/Store.jsm
+++ b/browser/components/newtab/lib/Store.jsm
@@ -21,17 +21,17 @@ const { redux } = ChromeUtils.import(
 
 /**
  * Store - This has a similar structure to a redux store, but includes some extra
  *         functionality to allow for routing of actions between the Main processes
  *         and child processes via a ActivityStreamMessageChannel.
  *         It also accepts an array of "Feeds" on inititalization, which
  *         can listen for any action that is dispatched through the store.
  */
-this.Store = class Store {
+class Store {
   /**
    * constructor - The redux store and message manager are created here,
    *               but no listeners are added until "init" is called.
    */
   constructor() {
     this._middleware = this._middleware.bind(this);
     // Bind each redux method so we can call it directly from the Store. E.g.,
     // store.dispatch() will call store._store.dispatch();
diff --git a/browser/components/newtab/lib/SystemTickFeed.jsm b/browser/components/newtab/lib/SystemTickFeed.jsm
--- a/browser/components/newtab/lib/SystemTickFeed.jsm
+++ b/browser/components/newtab/lib/SystemTickFeed.jsm
@@ -16,17 +16,17 @@ ChromeUtils.defineModuleGetter(
   this,
   "clearInterval",
   "resource://gre/modules/Timer.jsm"
 );
 
 // Frequency at which SYSTEM_TICK events are fired
 const SYSTEM_TICK_INTERVAL = 5 * 60 * 1000;
 
-this.SystemTickFeed = class SystemTickFeed {
+class SystemTickFeed {
   init() {
     this.intervalId = setInterval(
       () => this.store.dispatch({ type: at.SYSTEM_TICK }),
       SYSTEM_TICK_INTERVAL
     );
   }
 
   onAction(action) {
@@ -36,10 +36,9 @@ this.SystemTickFeed = class SystemTickFe
         break;
       case at.UNINIT:
         clearInterval(this.intervalId);
         break;
     }
   }
 };
 
-this.SYSTEM_TICK_INTERVAL = SYSTEM_TICK_INTERVAL;
 const EXPORTED_SYMBOLS = ["SystemTickFeed", "SYSTEM_TICK_INTERVAL"];
diff --git a/browser/components/newtab/lib/TelemetryFeed.jsm b/browser/components/newtab/lib/TelemetryFeed.jsm
--- a/browser/components/newtab/lib/TelemetryFeed.jsm
+++ b/browser/components/newtab/lib/TelemetryFeed.jsm
@@ -96,17 +96,17 @@ const EVENTS_TELEMETRY_PREF = "telemetry
 const STRUCTURED_INGESTION_TELEMETRY_PREF = "telemetry.structuredIngestion";
 const STRUCTURED_INGESTION_ENDPOINT_PREF =
   "telemetry.structuredIngestion.endpoint";
 // List of namespaces for the structured ingestion system.
 // They are defined in https://github.com/mozilla-services/mozilla-pipeline-schemas
 const STRUCTURED_INGESTION_NAMESPACE_AS = "activity-stream";
 const STRUCTURED_INGESTION_NAMESPACE_MS = "messaging-system";
 
-this.TelemetryFeed = class TelemetryFeed {
+class TelemetryFeed {
   constructor(options) {
     this.sessions = new Map();
     this._prefs = new Prefs();
     this._impressionId = this.getOrCreateImpressionId();
     this._aboutHomeSeen = false;
     this._classifySite = classifySite;
     this._addWindowListeners = this._addWindowListeners.bind(this);
     this.handleEvent = this.handleEvent.bind(this);
diff --git a/browser/components/newtab/lib/TippyTopProvider.jsm b/browser/components/newtab/lib/TippyTopProvider.jsm
--- a/browser/components/newtab/lib/TippyTopProvider.jsm
+++ b/browser/components/newtab/lib/TippyTopProvider.jsm
@@ -19,17 +19,17 @@ function getDomain(url) {
     domain = new URL(url).hostname;
   } catch (ex) {}
   if (domain && domain.startsWith("www.")) {
     domain = domain.slice(4);
   }
   return domain;
 }
 
-this.TippyTopProvider = class TippyTopProvider {
+class TippyTopProvider {
   constructor() {
     this._sitesByDomain = new Map();
     this.initialized = false;
   }
 
   async init() {
     // Load the Tippy Top sites from the json manifest.
     try {
diff --git a/browser/components/newtab/lib/ToolbarBadgeHub.jsm b/browser/components/newtab/lib/ToolbarBadgeHub.jsm
--- a/browser/components/newtab/lib/ToolbarBadgeHub.jsm
+++ b/browser/components/newtab/lib/ToolbarBadgeHub.jsm
@@ -363,17 +363,15 @@ class _ToolbarBadgeHub {
     this._clearBadgeTimeout();
     clearInterval(this.state._intervalId);
     this.state = null;
     notificationsByWindow = new WeakMap();
     Services.prefs.removeObserver(this.prefs.WHATSNEW_TOOLBAR_PANEL, this);
   }
 }
 
-this._ToolbarBadgeHub = _ToolbarBadgeHub;
-
 /**
  * ToolbarBadgeHub - singleton instance of _ToolbarBadgeHub that can initiate
  * message requests and render messages.
  */
-this.ToolbarBadgeHub = new _ToolbarBadgeHub();
+const ToolbarBadgeHub = new _ToolbarBadgeHub();
 
 const EXPORTED_SYMBOLS = ["ToolbarBadgeHub", "_ToolbarBadgeHub"];
diff --git a/browser/components/newtab/lib/ToolbarPanelHub.jsm b/browser/components/newtab/lib/ToolbarPanelHub.jsm
--- a/browser/components/newtab/lib/ToolbarPanelHub.jsm
+++ b/browser/components/newtab/lib/ToolbarPanelHub.jsm
@@ -597,17 +597,15 @@ class _ToolbarPanelHub {
       messages: [message],
     });
     win.PanelUI.panel.addEventListener("popuphidden", event =>
       this.removeMessages(event.target.ownerGlobal, WHATS_NEW_PANEL_SELECTOR)
     );
   }
 }
 
-this._ToolbarPanelHub = _ToolbarPanelHub;
-
 /**
  * ToolbarPanelHub - singleton instance of _ToolbarPanelHub that can initiate
  * message requests and render messages.
  */
-this.ToolbarPanelHub = new _ToolbarPanelHub();
+const ToolbarPanelHub = new _ToolbarPanelHub();
 
 const EXPORTED_SYMBOLS = ["ToolbarPanelHub", "_ToolbarPanelHub"];
diff --git a/browser/components/newtab/lib/TopSitesFeed.jsm b/browser/components/newtab/lib/TopSitesFeed.jsm
--- a/browser/components/newtab/lib/TopSitesFeed.jsm
+++ b/browser/components/newtab/lib/TopSitesFeed.jsm
@@ -85,17 +85,17 @@ const SEARCH_FILTERS = [
   "duckduckgo",
 ];
 
 function getShortURLForCurrentSearch() {
   const url = shortURL({ url: Services.search.defaultEngine.searchForm });
   return url;
 }
 
-this.TopSitesFeed = class TopSitesFeed {
+class TopSitesFeed {
   constructor() {
     this._tippyTopProvider = new TippyTopProvider();
     XPCOMUtils.defineLazyGetter(
       this,
       "_currentSearchHostname",
       getShortURLForCurrentSearch
     );
     this.dedupe = new Dedupe(this._dedupeKey);
@@ -829,10 +829,9 @@ this.TopSitesFeed = class TopSitesFeed {
         break;
       case at.UNINIT:
         this.uninit();
         break;
     }
   }
 };
 
-this.DEFAULT_TOP_SITES = DEFAULT_TOP_SITES;
 const EXPORTED_SYMBOLS = ["TopSitesFeed", "DEFAULT_TOP_SITES"];
diff --git a/browser/components/newtab/lib/TopStoriesFeed.jsm b/browser/components/newtab/lib/TopStoriesFeed.jsm
--- a/browser/components/newtab/lib/TopStoriesFeed.jsm
+++ b/browser/components/newtab/lib/TopStoriesFeed.jsm
@@ -57,17 +57,17 @@ const SPOC_IMPRESSION_TRACKING_PREF =
 const DISCOVERY_STREAM_PREF_ENABLED = "discoverystream.enabled";
 const DISCOVERY_STREAM_PREF_ENABLED_PATH =
   "browser.newtabpage.activity-stream.discoverystream.enabled";
 const REC_IMPRESSION_TRACKING_PREF = "feeds.section.topstories.rec.impressions";
 const OPTIONS_PREF = "feeds.section.topstories.options";
 const MAX_LIFETIME_CAP = 500; // Guard against misconfiguration on the server
 const DISCOVERY_STREAM_PREF = "discoverystream.config";
 
-this.TopStoriesFeed = class TopStoriesFeed {
+class TopStoriesFeed {
   constructor(ds) {
     // Use discoverystream config pref default values for fast path and
     // if needed lazy load activity stream top stories feed based on
     // actual user preference when INIT and PREF_CHANGED is invoked
     this.discoveryStreamEnabled =
       ds &&
       ds.value &&
       JSON.parse(ds.value).enabled &&
@@ -928,23 +928,16 @@ this.TopStoriesFeed = class TopStoriesFe
             );
           }
         }
         break;
     }
   }
 };
 
-this.STORIES_UPDATE_TIME = STORIES_UPDATE_TIME;
-this.TOPICS_UPDATE_TIME = TOPICS_UPDATE_TIME;
-this.SECTION_ID = SECTION_ID;
-this.SPOC_IMPRESSION_TRACKING_PREF = SPOC_IMPRESSION_TRACKING_PREF;
-this.REC_IMPRESSION_TRACKING_PREF = REC_IMPRESSION_TRACKING_PREF;
-this.MIN_DOMAIN_AFFINITIES_UPDATE_TIME = MIN_DOMAIN_AFFINITIES_UPDATE_TIME;
-this.DEFAULT_RECS_EXPIRE_TIME = DEFAULT_RECS_EXPIRE_TIME;
 const EXPORTED_SYMBOLS = [
   "TopStoriesFeed",
   "STORIES_UPDATE_TIME",
   "TOPICS_UPDATE_TIME",
   "SECTION_ID",
   "SPOC_IMPRESSION_TRACKING_PREF",
   "MIN_DOMAIN_AFFINITIES_UPDATE_TIME",
   "REC_IMPRESSION_TRACKING_PREF",
diff --git a/browser/components/newtab/lib/UTEventReporting.jsm b/browser/components/newtab/lib/UTEventReporting.jsm
--- a/browser/components/newtab/lib/UTEventReporting.jsm
+++ b/browser/components/newtab/lib/UTEventReporting.jsm
@@ -13,17 +13,17 @@ const { Services } = ChromeUtils.import(
 const EXTRAS_FIELD_NAMES = [
   "addon_version",
   "session_id",
   "page",
   "user_prefs",
   "action_position",
 ];
 
-this.UTEventReporting = class UTEventReporting {
+class UTEventReporting {
   constructor() {
     Services.telemetry.setEventRecordingEnabled("activity_stream", true);
     this.sendUserEvent = this.sendUserEvent.bind(this);
     this.sendSessionEndEvent = this.sendSessionEndEvent.bind(this);
     this.sendTrailheadEnrollEvent = this.sendTrailheadEnrollEvent.bind(this);
   }
 
   _createExtras(data) {
diff --git a/browser/components/newtab/lib/UserDomainAffinityProvider.jsm b/browser/components/newtab/lib/UserDomainAffinityProvider.jsm
--- a/browser/components/newtab/lib/UserDomainAffinityProvider.jsm
+++ b/browser/components/newtab/lib/UserDomainAffinityProvider.jsm
@@ -71,17 +71,17 @@ function merge(...args) {
  * more details)
  *
  * - The data structure was chosen to allow for fast cache lookups during
  * relevance score calculation. While user domain affinities are calculated
  * infrequently (i.e. only once a day), the item relevance score (potentially)
  * needs to be calculated every time the feed updates. Therefore allowing cache
  * lookups of scores[domain][parameterSet] is beneficial
  */
-this.UserDomainAffinityProvider = class UserDomainAffinityProvider {
+class UserDomainAffinityProvider {
   constructor(
     timeSegments = DEFAULT_TIME_SEGMENTS,
     parameterSets = DEFAULT_PARAMETER_SETS,
     maxHistoryQueryResults = DEFAULT_MAX_HISTORY_QUERY_RESULTS,
     version,
     scores
   ) {
     this.timeSegments = timeSegments;
diff --git a/browser/components/newtab/vendor/Redux.jsm b/browser/components/newtab/vendor/Redux.jsm
--- a/browser/components/newtab/vendor/Redux.jsm
+++ b/browser/components/newtab/vendor/Redux.jsm
@@ -2,17 +2,17 @@
  * Redux v.4.0.1
  *
  * This file was imported from https://unpkg.com/redux@4.0.1/dist/redux.js
  * and reformatted as a Javascript Core Module
  */
 var EXPORTED_SYMBOLS = ["redux"];
 var self = this;
 
-this.redux = (function (global, factory) {
+const redux = function (global, factory) {
   var exports = {};
   factory(exports);
   return exports;
   }(this, (function (exports) { 'use strict';
 
   function symbolObservablePonyfill(root) {
     var result;
     var Symbol = root.Symbol;
@@ -682,9 +682,9 @@ this.redux = (function (global, factory)
   exports.combineReducers = combineReducers;
   exports.bindActionCreators = bindActionCreators;
   exports.applyMiddleware = applyMiddleware;
   exports.compose = compose;
   exports.__DO_NOT_USE__ActionTypes = ActionTypes;
 
   Object.defineProperty(exports, '__esModule', { value: true });
 
-  })));
+  }));
diff --git a/browser/components/sessionstore/SessionWorker.jsm b/browser/components/sessionstore/SessionWorker.jsm
--- a/browser/components/sessionstore/SessionWorker.jsm
+++ b/browser/components/sessionstore/SessionWorker.jsm
@@ -13,9 +13,9 @@ ChromeUtils.import("resource://gre/modul
 
 var EXPORTED_SYMBOLS = ["SessionWorker"];
 
 var SessionWorker = new BasePromiseWorker(
   "resource:///modules/sessionstore/SessionWorker.js"
 );
 // As the Session Worker performs I/O, we can receive instances of
 // OS.File.Error, so we need to install a decoder.
-this.SessionWorker.ExceptionHandlers["OS.File.Error"] = OS.File.Error.fromMsg;
+SessionWorker.ExceptionHandlers["OS.File.Error"] = OS.File.Error.fromMsg;
diff --git a/browser/components/translation/BingTranslator.jsm b/browser/components/translation/BingTranslator.jsm
--- a/browser/components/translation/BingTranslator.jsm
+++ b/browser/components/translation/BingTranslator.jsm
@@ -52,17 +52,17 @@ var BingTranslator = function(
   this.sourceLanguage = sourceLanguage;
   this.targetLanguage = targetLanguage;
   this._pendingRequests = 0;
   this._partialSuccess = false;
   this._serviceUnavailable = false;
   this._translatedCharacterCount = 0;
 };
 
-this.BingTranslator.prototype = {
+BingTranslator.prototype = {
   /**
    * Performs the translation, splitting the document into several chunks
    * respecting the data limits of the API.
    *
    * @returns {Promise}          A promise that will resolve when the translation
    *                             task is finished.
    */
   translate() {
diff --git a/browser/components/translation/GoogleTranslator.jsm b/browser/components/translation/GoogleTranslator.jsm
--- a/browser/components/translation/GoogleTranslator.jsm
+++ b/browser/components/translation/GoogleTranslator.jsm
@@ -50,17 +50,17 @@ var GoogleTranslator = function(
   this.translationDocument = translationDocument;
   this.sourceLanguage = sourceLanguage;
   this.targetLanguage = targetLanguage;
   this._pendingRequests = 0;
   this._partialSuccess = false;
   this._translatedCharacterCount = 0;
 };
 
-this.GoogleTranslator.prototype = {
+GoogleTranslator.prototype = {
   /**
    * Performs the translation, splitting the document into several chunks
    * respecting the data limits of the API.
    *
    * @returns {Promise}          A promise that will resolve when the translation
    *                             task is finished.
    */
   async translate() {
diff --git a/browser/components/translation/Translation.jsm b/browser/components/translation/Translation.jsm
--- a/browser/components/translation/Translation.jsm
+++ b/browser/components/translation/Translation.jsm
@@ -500,9 +500,9 @@ var TranslationTelemetry = {
   },
 
   _recordOpportunity(language, success) {
     this.HISTOGRAMS.OPPORTUNITIES().add(success);
     this.HISTOGRAMS.OPPORTUNITIES_BY_LANG().add(language, success);
   },
 };
 
-this.TranslationTelemetry.init();
+TranslationTelemetry.init();
diff --git a/browser/components/translation/TranslationDocument.jsm b/browser/components/translation/TranslationDocument.jsm
--- a/browser/components/translation/TranslationDocument.jsm
+++ b/browser/components/translation/TranslationDocument.jsm
@@ -22,17 +22,17 @@ XPCOMUtils.defineLazyGlobalGetters(this,
  * @param document  The document to be translated
  */
 var TranslationDocument = function(document) {
   this.itemsMap = new Map();
   this.roots = [];
   this._init(document);
 };
 
-this.TranslationDocument.prototype = {
+TranslationDocument.prototype = {
   translatedFrom: "",
   translatedTo: "",
   translationError: false,
   originalShown: true,
 
   /**
    * Initializes the object and populates
    * the roots lists.
diff --git a/browser/components/translation/YandexTranslator.jsm b/browser/components/translation/YandexTranslator.jsm
--- a/browser/components/translation/YandexTranslator.jsm
+++ b/browser/components/translation/YandexTranslator.jsm
@@ -68,17 +68,17 @@ var YandexTranslator = function(
   this.sourceLanguage = sourceLanguage;
   this.targetLanguage = targetLanguage;
   this._pendingRequests = 0;
   this._partialSuccess = false;
   this._serviceUnavailable = false;
   this._translatedCharacterCount = 0;
 };
 
-this.YandexTranslator.prototype = {
+YandexTranslator.prototype = {
   /**
    * Performs the translation, splitting the document into several chunks
    * respecting the data limits of the API.
    *
    * @returns {Promise}          A promise that will resolve when the translation
    *                             task is finished.
    */
   translate() {
diff --git a/browser/components/uitour/UITour.jsm b/browser/components/uitour/UITour.jsm
--- a/browser/components/uitour/UITour.jsm
+++ b/browser/components/uitour/UITour.jsm
@@ -2013,17 +2013,17 @@ var UITour = {
         let global = contextToVisit.currentWindowGlobal;
         let actor = global.getActor("UITour");
         actor.sendAsyncMessage("UITour:SendPageNotification", detail);
       }
     }
   },
 };
 
-this.UITour.init();
+UITour.init();
 
 /**
  * UITour Health Report
  */
 /**
  * Public API to be called by the UITour code
  */
 const UITourHealthReport = {
diff --git a/browser/extensions/formautofill/FormAutofillDoorhanger.jsm b/browser/extensions/formautofill/FormAutofillDoorhanger.jsm
--- a/browser/extensions/formautofill/FormAutofillDoorhanger.jsm
+++ b/browser/extensions/formautofill/FormAutofillDoorhanger.jsm
@@ -17,17 +17,17 @@ const { AppConstants } = ChromeUtils.imp
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const { FormAutofill } = ChromeUtils.import(
   "resource://formautofill/FormAutofill.jsm"
 );
 const { FormAutofillUtils } = ChromeUtils.import(
   "resource://formautofill/FormAutofillUtils.jsm"
 );
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 const GetStringFromName = FormAutofillUtils.stringBundle.GetStringFromName;
 const formatStringFromName =
   FormAutofillUtils.stringBundle.formatStringFromName;
 const brandShortName = FormAutofillUtils.brandBundle.GetStringFromName(
   "brandShortName"
 );
diff --git a/browser/extensions/formautofill/FormAutofillHandler.jsm b/browser/extensions/formautofill/FormAutofillHandler.jsm
--- a/browser/extensions/formautofill/FormAutofillHandler.jsm
+++ b/browser/extensions/formautofill/FormAutofillHandler.jsm
@@ -41,17 +41,17 @@ XPCOMUtils.defineLazyGetter(this, "reaut
     "brandShortName"
   );
   return FormAutofillUtils.stringBundle.formatStringFromName(
     `useCreditCardPasswordPrompt.${AppConstants.platform}`,
     [brandShortName]
   );
 });
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 const { FIELD_STATES } = FormAutofillUtils;
 
 class FormAutofillSection {
   constructor(fieldDetails, winUtils) {
     this.fieldDetails = fieldDetails;
     this.filledRecordGUID = null;
diff --git a/browser/extensions/formautofill/FormAutofillHeuristics.jsm b/browser/extensions/formautofill/FormAutofillHeuristics.jsm
--- a/browser/extensions/formautofill/FormAutofillHeuristics.jsm
+++ b/browser/extensions/formautofill/FormAutofillHeuristics.jsm
@@ -18,17 +18,17 @@ const { FormAutofill } = ChromeUtils.imp
   "resource://formautofill/FormAutofill.jsm"
 );
 ChromeUtils.defineModuleGetter(
   this,
   "FormAutofillUtils",
   "resource://formautofill/FormAutofillUtils.jsm"
 );
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 const PREF_HEURISTICS_ENABLED = "extensions.formautofill.heuristics.enabled";
 const PREF_SECTION_ENABLED = "extensions.formautofill.section.enabled";
 const DEFAULT_SECTION_NAME = "-moz-section-default";
 
 /**
  * A scanner for traversing all elements in a form and retrieving the field
@@ -420,17 +420,17 @@ var LabelUtils = {
     }
     return this._mappedLabels.get(id) || [];
   },
 };
 
 /**
  * Returns the autocomplete information of fields according to heuristics.
  */
-this.FormAutofillHeuristics = {
+const FormAutofillHeuristics = {
   RULES: null,
 
   /**
    * Try to find a contiguous sub-array within an array.
    *
    * @param {Array} array
    * @param {Array} subArray
    *
@@ -1213,38 +1213,38 @@ this.FormAutofillHeuristics = {
     // {REGEX_SEPARATOR, FIELD_NONE, 0},
 
     // Phone: <phone> (Ext: <ext>)?
     // {REGEX_PHONE, FIELD_PHONE, 0},
     // {REGEX_SEPARATOR, FIELD_NONE, 0},
   ],
 };
 
-XPCOMUtils.defineLazyGetter(this.FormAutofillHeuristics, "RULES", () => {
+XPCOMUtils.defineLazyGetter(FormAutofillHeuristics, "RULES", () => {
   let sandbox = {};
   const HEURISTICS_REGEXP = "chrome://formautofill/content/heuristicsRegexp.js";
   Services.scriptloader.loadSubScript(HEURISTICS_REGEXP, sandbox);
   return sandbox.HeuristicsRegExp.RULES;
 });
 
-XPCOMUtils.defineLazyGetter(this.FormAutofillHeuristics, "_prefEnabled", () => {
+XPCOMUtils.defineLazyGetter(FormAutofillHeuristics, "_prefEnabled", () => {
   return Services.prefs.getBoolPref(PREF_HEURISTICS_ENABLED);
 });
 
 Services.prefs.addObserver(PREF_HEURISTICS_ENABLED, () => {
-  this.FormAutofillHeuristics._prefEnabled = Services.prefs.getBoolPref(
+  FormAutofillHeuristics._prefEnabled = Services.prefs.getBoolPref(
     PREF_HEURISTICS_ENABLED
   );
 });
 
 XPCOMUtils.defineLazyGetter(
-  this.FormAutofillHeuristics,
+  FormAutofillHeuristics,
   "_sectionEnabled",
   () => {
     return Services.prefs.getBoolPref(PREF_SECTION_ENABLED);
   }
 );
 
 Services.prefs.addObserver(PREF_SECTION_ENABLED, () => {
-  this.FormAutofillHeuristics._sectionEnabled = Services.prefs.getBoolPref(
+  FormAutofillHeuristics._sectionEnabled = Services.prefs.getBoolPref(
     PREF_SECTION_ENABLED
   );
 });
diff --git a/browser/extensions/formautofill/FormAutofillParent.jsm b/browser/extensions/formautofill/FormAutofillParent.jsm
--- a/browser/extensions/formautofill/FormAutofillParent.jsm
+++ b/browser/extensions/formautofill/FormAutofillParent.jsm
@@ -45,17 +45,17 @@ XPCOMUtils.defineLazyModuleGetters(this,
   CreditCard: "resource://gre/modules/CreditCard.jsm",
   FormAutofillPreferences:
     "resource://formautofill/FormAutofillPreferences.jsm",
   FormAutofillDoorhanger: "resource://formautofill/FormAutofillDoorhanger.jsm",
   FormAutofillUtils: "resource://formautofill/FormAutofillUtils.jsm",
   OSKeyStore: "resource://formautofill/OSKeyStore.jsm",
 });
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 const {
   ENABLED_AUTOFILL_ADDRESSES_PREF,
   ENABLED_AUTOFILL_CREDITCARDS_PREF,
 } = FormAutofill;
 
 const {
diff --git a/browser/extensions/formautofill/FormAutofillPreferences.jsm b/browser/extensions/formautofill/FormAutofillPreferences.jsm
--- a/browser/extensions/formautofill/FormAutofillPreferences.jsm
+++ b/browser/extensions/formautofill/FormAutofillPreferences.jsm
@@ -34,17 +34,17 @@ const {
   MANAGE_ADDRESSES_KEYWORDS,
   EDIT_ADDRESS_KEYWORDS,
   MANAGE_CREDITCARDS_KEYWORDS,
   EDIT_CREDITCARD_KEYWORDS,
 } = FormAutofillUtils;
 // Add credit card enabled flag in telemetry environment for recording the number of
 // users who disable/enable the credit card autofill feature.
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 
 function FormAutofillPreferences() {
   this.bundle = Services.strings.createBundle(BUNDLE_URI);
 }
 
diff --git a/browser/extensions/formautofill/FormAutofillStorage.jsm b/browser/extensions/formautofill/FormAutofillStorage.jsm
--- a/browser/extensions/formautofill/FormAutofillStorage.jsm
+++ b/browser/extensions/formautofill/FormAutofillStorage.jsm
@@ -121,17 +121,17 @@
  * (meaning they will be synced on the next sync), at which time they will gain
  * this new field.
  */
 
 "use strict";
 
 // We expose a singleton from this module. Some tests may import the
 // constructor via a backstage pass.
-this.EXPORTED_SYMBOLS = ["formAutofillStorage"];
+const EXPORTED_SYMBOLS = ["formAutofillStorage"];
 
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const { OS } = ChromeUtils.import("resource://gre/modules/osfile.jsm");
 
 const { FormAutofill } = ChromeUtils.import(
@@ -2165,11 +2165,11 @@ FormAutofillStorage.prototype = {
   },
 
   _finalize() {
     return this._store.finalize();
   },
 };
 
 // The singleton exposed by this module.
-this.formAutofillStorage = new FormAutofillStorage(
+const formAutofillStorage = new FormAutofillStorage(
   OS.Path.join(OS.Constants.Path.profileDir, PROFILE_JSON_FILE_NAME)
 );
diff --git a/browser/extensions/formautofill/FormAutofillUtils.jsm b/browser/extensions/formautofill/FormAutofillUtils.jsm
--- a/browser/extensions/formautofill/FormAutofillUtils.jsm
+++ b/browser/extensions/formautofill/FormAutofillUtils.jsm
@@ -203,17 +203,17 @@ let AddressDataLoader = {
       locales = list.map(key =>
         this._parse(this._addressData[`${defaultLocale.id}--${key}`])
       );
     }
     return { defaultLocale, locales };
   },
 };
 
-this.FormAutofillUtils = {
+const FormAutofillUtils = {
   get AUTOFILL_FIELDS_THRESHOLD() {
     return 3;
   },
 
   ADDRESSES_COLLECTION_NAME,
   CREDITCARDS_COLLECTION_NAME,
   MANAGE_ADDRESSES_KEYWORDS,
   EDIT_ADDRESS_KEYWORDS,
@@ -1092,17 +1092,17 @@ this.FormAutofillUtils = {
 
     elements = root.querySelectorAll("[data-localization-region]");
     for (let element of elements) {
       this.localizeAttributeForElement(element, "data-localization-region");
     }
   },
 };
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 XPCOMUtils.defineLazyGetter(FormAutofillUtils, "stringBundle", function() {
   return Services.strings.createBundle(
     "chrome://formautofill/locale/formautofill.properties"
   );
 });
 
diff --git a/browser/extensions/formautofill/ProfileAutoCompleteResult.jsm b/browser/extensions/formautofill/ProfileAutoCompleteResult.jsm
--- a/browser/extensions/formautofill/ProfileAutoCompleteResult.jsm
+++ b/browser/extensions/formautofill/ProfileAutoCompleteResult.jsm
@@ -24,17 +24,17 @@ ChromeUtils.defineModuleGetter(
 );
 
 XPCOMUtils.defineLazyPreferenceGetter(
   this,
   "insecureWarningEnabled",
   "security.insecure_field_warning.contextual.enabled"
 );
 
-this.log = null;
+const log = null;
 FormAutofill.defineLazyLogGetter(this, EXPORTED_SYMBOLS[0]);
 
 class ProfileAutoCompleteResult {
   constructor(
     searchString,
     focusedFieldName,
     allFieldNames,
     matchingProfiles,
diff --git a/browser/modules/AsanReporter.jsm b/browser/modules/AsanReporter.jsm
--- a/browser/modules/AsanReporter.jsm
+++ b/browser/modules/AsanReporter.jsm
@@ -1,14 +1,14 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-this.EXPORTED_SYMBOLS = ["AsanReporter"];
+const EXPORTED_SYMBOLS = ["AsanReporter"];
 
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   AppConstants: "resource://gre/modules/AppConstants.jsm",
   Log: "resource://gre/modules/Log.jsm",
@@ -28,17 +28,17 @@ const LOGGER_NAME = "asanreporter";
 
 let logger;
 
 XPCOMUtils.defineLazyGetter(this, "asanDumpDir", () => {
   let profileDir = Services.dirsvc.get("ProfD", Ci.nsIFile);
   return OS.Path.join(profileDir.path, "asan");
 });
 
-this.AsanReporter = {
+const AsanReporter = {
   init() {
     if (this.initialized) {
       return;
     }
     this.initialized = true;
 
     // Setup logging
     logger = Log.repository.getLogger(LOGGER_NAME);
diff --git a/browser/modules/BrowserWindowTracker.jsm b/browser/modules/BrowserWindowTracker.jsm
--- a/browser/modules/BrowserWindowTracker.jsm
+++ b/browser/modules/BrowserWindowTracker.jsm
@@ -158,17 +158,17 @@ var WindowHelper = {
 
     _untrackWindowOrder(window);
     _trackWindowOrder(window);
 
     _updateCurrentContentOuterWindowID(window.gBrowser.selectedBrowser);
   },
 };
 
-this.BrowserWindowTracker = {
+const BrowserWindowTracker = {
   /**
    * Get the most recent browser window.
    *
    * @param options an object accepting the arguments for the search.
    *        * private: true to restrict the search to private windows
    *            only, false to restrict the search to non-private only.
    *            Omit the property to search in both groups.
    *        * allowPopups: true if popup windows are permissable.
diff --git a/browser/modules/EveryWindow.jsm b/browser/modules/EveryWindow.jsm
--- a/browser/modules/EveryWindow.jsm
+++ b/browser/modules/EveryWindow.jsm
@@ -37,17 +37,17 @@ function callForEveryWindow(callback) {
   let windowList = Services.wm.getEnumerator("navigator:browser");
   for (let win of windowList) {
     win.delayedStartupPromise.then(() => {
       callback(win);
     });
   }
 }
 
-this.EveryWindow = {
+const EveryWindow = {
   /**
    * Registers init and uninit functions to be called on every window.
    *
    * @param {string} id A unique identifier for the consumer, to be
    *   used for unregistration.
    * @param {function} init The function to be called on every currently
    *   existing window and every future window after delayed startup.
    * @param {function} uninit The function to be called on every window
diff --git a/browser/modules/OpenInTabsUtils.jsm b/browser/modules/OpenInTabsUtils.jsm
--- a/browser/modules/OpenInTabsUtils.jsm
+++ b/browser/modules/OpenInTabsUtils.jsm
@@ -1,32 +1,32 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["OpenInTabsUtils"];
+const EXPORTED_SYMBOLS = ["OpenInTabsUtils"];
 
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "bundle", function() {
   return Services.strings.createBundle(
     "chrome://browser/locale/tabbrowser.properties"
   );
 });
 
 /**
  * Utility functions that can be used when opening multiple tabs, that can be
  * called without any tabbrowser instance.
  */
-this.OpenInTabsUtils = {
+const OpenInTabsUtils = {
   getString(key) {
     return bundle.GetStringFromName(key);
   },
 
   getFormattedString(key, params) {
     return bundle.formatStringFromName(key, params);
   },
 
diff --git a/browser/modules/PageActions.jsm b/browser/modules/PageActions.jsm
--- a/browser/modules/PageActions.jsm
+++ b/browser/modules/PageActions.jsm
@@ -1102,26 +1102,26 @@ Action.prototype = {
     return builtInIDs.includes(this.id);
   },
 
   get _isMozillaAction() {
     return this._isBuiltIn || this.id == "webcompat-reporter_mozilla_org";
   },
 };
 
-this.PageActions.Action = Action;
+PageActions.Action = Action;
 
-this.PageActions.ACTION_ID_BUILT_IN_SEPARATOR = ACTION_ID_BUILT_IN_SEPARATOR;
-this.PageActions.ACTION_ID_TRANSIENT_SEPARATOR = ACTION_ID_TRANSIENT_SEPARATOR;
+PageActions.ACTION_ID_BUILT_IN_SEPARATOR = ACTION_ID_BUILT_IN_SEPARATOR;
+PageActions.ACTION_ID_TRANSIENT_SEPARATOR = ACTION_ID_TRANSIENT_SEPARATOR;
 
 // These are only necessary so that Pocket and the test can use them.
-this.PageActions.ACTION_ID_BOOKMARK = ACTION_ID_BOOKMARK;
-this.PageActions.ACTION_ID_PIN_TAB = ACTION_ID_PIN_TAB;
-this.PageActions.ACTION_ID_BOOKMARK_SEPARATOR = ACTION_ID_BOOKMARK_SEPARATOR;
-this.PageActions.PREF_PERSISTED_ACTIONS = PREF_PERSISTED_ACTIONS;
+PageActions.ACTION_ID_BOOKMARK = ACTION_ID_BOOKMARK;
+PageActions.ACTION_ID_PIN_TAB = ACTION_ID_PIN_TAB;
+PageActions.ACTION_ID_BOOKMARK_SEPARATOR = ACTION_ID_BOOKMARK_SEPARATOR;
+PageActions.PREF_PERSISTED_ACTIONS = PREF_PERSISTED_ACTIONS;
 
 // Sorted in the order in which they should appear in the page action panel.
 // Does not include the page actions of extensions bundled with the browser.
 // They're added by the relevant extension code.
 // NOTE: If you add items to this list (or system add-on actions that we
 // want to keep track of), make sure to also update Histograms.json for the
 // new actions.
 var gBuiltInActions = [
diff --git a/browser/modules/PingCentre.jsm b/browser/modules/PingCentre.jsm
--- a/browser/modules/PingCentre.jsm
+++ b/browser/modules/PingCentre.jsm
@@ -379,15 +379,14 @@ class PingCentre {
         this._onFhrPrefChange
       );
     } catch (e) {
       Cu.reportError(e);
     }
   }
 }
 
-this.PingCentre = PingCentre;
-this.PingCentreConstants = {
+const PingCentreConstants = {
   FHR_UPLOAD_ENABLED_PREF,
   TELEMETRY_PREF,
   LOGGING_PREF,
 };
 const EXPORTED_SYMBOLS = ["PingCentre", "PingCentreConstants"];
diff --git a/devtools/client/framework/browser-toolbox/Launcher.jsm b/devtools/client/framework/browser-toolbox/Launcher.jsm
--- a/devtools/client/framework/browser-toolbox/Launcher.jsm
+++ b/devtools/client/framework/browser-toolbox/Launcher.jsm
@@ -33,37 +33,32 @@ XPCOMUtils.defineLazyGetter(this, "Telem
   return require("devtools/client/shared/telemetry");
 });
 XPCOMUtils.defineLazyGetter(this, "EventEmitter", function() {
   return require("devtools/shared/event-emitter");
 });
 
 const Services = require("Services");
 
-this.EXPORTED_SYMBOLS = ["BrowserToolboxLauncher"];
+const EXPORTED_SYMBOLS = ["BrowserToolboxLauncher"];
 
 var processes = new Set();
 
 /**
  * Constructor for creating a process that will hold a chrome toolbox.
  *
  * @param function onClose [optional]
  *        A function called when the process stops running.
  * @param function onRun [optional]
  *        A function called when the process starts running.
  * @param boolean overwritePreferences [optional]
  *        Set to force overwriting the toolbox profile's preferences with the
  *        current set of preferences.
  */
-this.BrowserToolboxLauncher = function BrowserToolboxLauncher(
-  onClose,
-  onRun,
-  overwritePreferences,
-  binaryPath
-) {
+function BrowserToolboxLauncher(onClose, onRun, overwritePreferences, binaryPath) {
   const emitter = new EventEmitter();
   this.on = emitter.on.bind(emitter);
   this.off = emitter.off.bind(emitter);
   this.once = emitter.once.bind(emitter);
   // Forward any events to the shared emitter.
   this.emit = function(...args) {
     emitter.emit(...args);
     BrowserToolboxLauncher.emit(...args);
diff --git a/devtools/client/shared/SplitView.jsm b/devtools/client/shared/SplitView.jsm
--- a/devtools/client/shared/SplitView.jsm
+++ b/devtools/client/shared/SplitView.jsm
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const { require } = ChromeUtils.import("resource://devtools/shared/Loader.jsm");
 const { KeyCodes } = require("devtools/client/shared/keycodes");
 
-this.EXPORTED_SYMBOLS = ["SplitView"];
+const EXPORTED_SYMBOLS = ["SplitView"];
 
 /* this must be kept in sync with CSS (ie. splitview.css) */
 const LANDSCAPE_MEDIA_QUERY = "(min-width: 701px)";
 
 var bindings = new WeakMap();
 
 /**
  * SplitView constructor
@@ -22,17 +22,17 @@ var bindings = new WeakMap();
  * A split view contains items, each of those having one summary and one details
  * elements.
  * It is adaptive as it behaves similarly to a richlistbox when there the aspect
  * ratio is narrow or as a pair listbox-box otherwise.
  *
  * @param DOMElement aRoot
  * @see appendItem
  */
-this.SplitView = function SplitView(aRoot) {
+function SplitView(aRoot) {
   this._root = aRoot;
   this._controller = aRoot.querySelector(".splitview-controller");
   this._nav = aRoot.querySelector(".splitview-nav");
   this._side = aRoot.querySelector(".splitview-side-details");
   this._activeSummary = null;
 
   this._mql = aRoot.ownerDocument.defaultView.matchMedia(LANDSCAPE_MEDIA_QUERY);
 
diff --git a/devtools/client/shared/widgets/AbstractTreeItem.jsm b/devtools/client/shared/widgets/AbstractTreeItem.jsm
--- a/devtools/client/shared/widgets/AbstractTreeItem.jsm
+++ b/devtools/client/shared/widgets/AbstractTreeItem.jsm
@@ -6,17 +6,17 @@
 const { require, loader } = ChromeUtils.import(
   "resource://devtools/shared/Loader.jsm"
 );
 const { ViewHelpers } = require("devtools/client/shared/widgets/view-helpers");
 const { KeyCodes } = require("devtools/client/shared/keycodes");
 
 loader.lazyRequireGetter(this, "EventEmitter", "devtools/shared/event-emitter");
 
-this.EXPORTED_SYMBOLS = ["AbstractTreeItem"];
+const EXPORTED_SYMBOLS = ["AbstractTreeItem"];
 
 /**
  * A very generic and low-level tree view implementation. It is not intended
  * to be used alone, but as a base class that you can extend to build your
  * own custom implementation.
  *
  * Language:
  *   - An "item" is an instance of an AbstractTreeItem.
@@ -118,17 +118,16 @@ function AbstractTreeItem({ parent, leve
   this._childTreeItems = [];
 
   // Events are always propagated through the root item. Decorating every
   // tree item as an event emitter is a very costly operation.
   if (this == this._rootItem) {
     EventEmitter.decorate(this);
   }
 }
-this.AbstractTreeItem = AbstractTreeItem;
 
 AbstractTreeItem.prototype = {
   _containerNode: null,
   _targetNode: null,
   _arrowNode: null,
   _constructed: false,
   _populated: false,
   _expanded: false,
diff --git a/devtools/client/storage/VariablesView.jsm b/devtools/client/storage/VariablesView.jsm
--- a/devtools/client/storage/VariablesView.jsm
+++ b/devtools/client/storage/VariablesView.jsm
@@ -33,17 +33,17 @@ const HTML_NS = "http://www.w3.org/1999/
 
 XPCOMUtils.defineLazyServiceGetter(
   this,
   "clipboardHelper",
   "@mozilla.org/widget/clipboardhelper;1",
   "nsIClipboardHelper"
 );
 
-this.EXPORTED_SYMBOLS = ["VariablesView", "escapeHTML"];
+const EXPORTED_SYMBOLS = ["VariablesView", "escapeHTML"];
 
 /**
  * A tree view for inspecting scopes, objects and properties.
  * Iterable via "for (let [id, scope] of instance) { }".
  * Requires the devtools common.css and debugger.css skin stylesheets.
  *
  * To allow replacing variable or property values in this view, provide an
  * "eval" function property. To allow replacing variable or property names,
@@ -51,17 +51,17 @@ this.EXPORTED_SYMBOLS = ["VariablesView"
  * provide a "delete" function.
  *
  * @param Node aParentNode
  *        The parent node to hold this view.
  * @param object aFlags [optional]
  *        An object contaning initialization options for this view.
  *        e.g. { lazyEmpty: true, searchEnabled: true ... }
  */
-this.VariablesView = function VariablesView(aParentNode, aFlags = {}) {
+function VariablesView(aParentNode, aFlags = {}) {
   this._store = []; // Can't use a Map because Scope names needn't be unique.
   this._itemsByElement = new WeakMap();
   this._prevHierarchy = new Map();
   this._currHierarchy = new Map();
 
   this._parent = aParentNode;
   this._parent.classList.add("variables-view-container");
   this._parent.classList.add("theme-body");
diff --git a/devtools/client/styleeditor/StyleEditorUI.jsm b/devtools/client/styleeditor/StyleEditorUI.jsm
--- a/devtools/client/styleeditor/StyleEditorUI.jsm
+++ b/devtools/client/styleeditor/StyleEditorUI.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["StyleEditorUI"];
+const EXPORTED_SYMBOLS = ["StyleEditorUI"];
 
 const { loader, require } = ChromeUtils.import(
   "resource://devtools/shared/Loader.jsm"
 );
 const Services = require("Services");
 const { NetUtil } = require("resource://gre/modules/NetUtil.jsm");
 const { OS } = require("resource://gre/modules/osfile.jsm");
 const EventEmitter = require("devtools/shared/event-emitter");
@@ -112,17 +112,16 @@ function StyleEditorUI(toolbox, panelDoc
 
   this._prefObserver = new PrefObserver("devtools.styleeditor.");
   this._prefObserver.on(PREF_MEDIA_SIDEBAR, this._onMediaPrefChanged);
   this._sourceMapPrefObserver = new PrefObserver(
     "devtools.source-map.client-service."
   );
   this._sourceMapPrefObserver.on(PREF_ORIG_SOURCES, this._onNewDocument);
 }
-this.StyleEditorUI = StyleEditorUI;
 
 StyleEditorUI.prototype = {
   get currentTarget() {
     return this._toolbox.targetList.targetFront;
   },
 
   /*
    * Index of selected stylesheet in document.styleSheets
diff --git a/devtools/client/styleeditor/StyleEditorUtil.jsm b/devtools/client/styleeditor/StyleEditorUtil.jsm
--- a/devtools/client/styleeditor/StyleEditorUtil.jsm
+++ b/devtools/client/styleeditor/StyleEditorUtil.jsm
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* All top-level definitions here are exports.  */
 /* eslint no-unused-vars: [2, {"vars": "local"}] */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   "getString",
   "assert",
   "log",
   "text",
   "wire",
   "showFilePicker",
   "optionsPopupMenu",
 ];
diff --git a/devtools/client/styleeditor/StyleSheetEditor.jsm b/devtools/client/styleeditor/StyleSheetEditor.jsm
--- a/devtools/client/styleeditor/StyleSheetEditor.jsm
+++ b/devtools/client/styleeditor/StyleSheetEditor.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["StyleSheetEditor"];
+const EXPORTED_SYMBOLS = ["StyleSheetEditor"];
 
 const { require } = ChromeUtils.import("resource://devtools/shared/Loader.jsm");
 const Editor = require("devtools/client/shared/sourceeditor/editor");
 const promise = require("promise");
 const {
   shortSource,
   prettifyCSS,
 } = require("devtools/shared/inspector/css-logic");
@@ -134,17 +134,16 @@ function StyleSheetEditor(styleSheet, wi
       .getMediaRules()
       .then(this._onMediaRulesChanged, console.error);
   }
   this.cssSheet.on("media-rules-changed", this._onMediaRulesChanged);
   this.cssSheet.on("style-applied", this._onStyleApplied);
   this.savedFile = file;
   this.linkCSSFile();
 }
-this.StyleSheetEditor = StyleSheetEditor;
 
 StyleSheetEditor.prototype = {
   /**
    * Whether there are unsaved changes in the editor
    */
   get unsaved() {
     return this.sourceEditor && !this.sourceEditor.isClean();
   },
diff --git a/devtools/server/startup/content-process.jsm b/devtools/server/startup/content-process.jsm
--- a/devtools/server/startup/content-process.jsm
+++ b/devtools/server/startup/content-process.jsm
@@ -9,17 +9,17 @@
  * process.  Loaded into content processes by the main process during
  * content-process-connector.js' `connectToContentProcess` via the process
  * script `content-process.js`.
  *
  * The actual server startup itself is in this JSM so that code can be cached.
  */
 
 /* exported init */
-this.EXPORTED_SYMBOLS = ["init"];
+const EXPORTED_SYMBOLS = ["init"];
 
 let gLoader;
 
 function setupServer(mm) {
   // Prevent spawning multiple server per process, even if the caller call us
   // multiple times
   if (gLoader) {
     return gLoader;
diff --git a/devtools/shared/Loader.jsm b/devtools/shared/Loader.jsm
--- a/devtools/shared/Loader.jsm
+++ b/devtools/shared/Loader.jsm
@@ -11,17 +11,17 @@
 var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 var { Loader, Require, resolveURI, unload } = ChromeUtils.import(
   "resource://devtools/shared/base-loader.js"
 );
 var { requireRawId } = ChromeUtils.import(
   "resource://devtools/shared/loader-plugin-raw.jsm"
 );
 
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   "DevToolsLoader",
   "require",
   "loader",
   // Export StructuredCloneHolder for its use from builtin-modules
   "StructuredCloneHolder",
 ];
 
 var gNextLoaderID = 0;
@@ -40,20 +40,22 @@ var gNextLoaderID = 0;
  *        If true, the modules will be forced to be loaded in a distinct
  *        compartment. It is typically used to load the modules in a distinct
  *        system compartment, different from the main one, which is shared by
  *        all JSMs, XPCOMs and modules loaded with this flag set to true.
  *        We use this in order to debug modules loaded in this shared system
  *        compartment. The debugger actor has to be running in a distinct
  *        compartment than the context it is debugging.
  */
-this.DevToolsLoader = function DevToolsLoader({
-  invisibleToDebugger = false,
-  freshCompartment = false,
-} = {}) {
+function DevToolsLoader(
+  {
+    invisibleToDebugger = false,
+    freshCompartment = false,
+  } = {}
+) {
   const paths = {
     // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
     devtools: "resource://devtools",
     // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
     acorn: "resource://devtools/shared/acorn",
     // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
     "acorn/util/walk": "resource://devtools/shared/acorn/walk.js",
     // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
@@ -160,22 +162,22 @@ DevToolsLoader.prototype = {
    * loader plugin.
    */
   isLoaderPluginId: function(id) {
     return id.startsWith("raw!");
   },
 };
 
 // Export the standard instance of DevToolsLoader used by the tools.
-this.loader = new DevToolsLoader({
+const loader = new DevToolsLoader({
   /**
    * Sets whether the compartments loaded by this instance should be invisible
    * to the debugger.  Invisibility is needed for loaders that support debugging
    * of chrome code.  This is true of remote target environments, like Fennec or
    * B2G.  It is not the default case for desktop Firefox because we offer the
    * Browser Toolbox for chrome debugging there, which uses its own, separate
    * loader instance.
    * @see devtools/client/framework/browser-toolbox/Launcher.jsm
    */
   invisibleToDebugger: Services.appinfo.name !== "Firefox",
 });
 
-this.require = this.loader.require;
+const require = loader.require;
diff --git a/devtools/shared/heapsnapshot/tests/unit/Census.jsm b/devtools/shared/heapsnapshot/tests/unit/Census.jsm
--- a/devtools/shared/heapsnapshot/tests/unit/Census.jsm
+++ b/devtools/shared/heapsnapshot/tests/unit/Census.jsm
@@ -1,17 +1,17 @@
 // Functions for checking results returned by
 // Debugger.Memory.prototype.takeCensus and
 // HeapSnapshot.prototype.takeCensus. Adapted from js/src/jit-test/lib/census.js.
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["Census"];
+const EXPORTED_SYMBOLS = ["Census"];
 
-this.Census = (function() {
+const Census = (function() {
   const Census = {};
 
   function dumpn(msg) {
     dump("DBG-TEST: Census.jsm: " + msg + "\n");
   }
 
   // Census.walkCensus(subject, name, walker)
   //
diff --git a/devtools/shared/heapsnapshot/tests/unit/Match.jsm b/devtools/shared/heapsnapshot/tests/unit/Match.jsm
--- a/devtools/shared/heapsnapshot/tests/unit/Match.jsm
+++ b/devtools/shared/heapsnapshot/tests/unit/Match.jsm
@@ -1,18 +1,18 @@
 // A little pattern-matching library.
 //
 // Ported from js/src/tests/js1_8_5/reflect-parse/Match.js for use with devtools
 // server xpcshell tests.
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["Match"];
+const EXPORTED_SYMBOLS = ["Match"];
 
-this.Match = (function() {
+const Match = (function() {
   function Pattern(template) {
     // act like a constructor even as a function
     if (!(this instanceof Pattern)) {
       return new Pattern(template);
     }
 
     this.template = template;
   }
diff --git a/devtools/shared/loader-plugin-raw.jsm b/devtools/shared/loader-plugin-raw.jsm
--- a/devtools/shared/loader-plugin-raw.jsm
+++ b/devtools/shared/loader-plugin-raw.jsm
@@ -7,17 +7,17 @@
 const { NetUtil } = ChromeUtils.import("resource://gre/modules/NetUtil.jsm");
 
 /**
  * A function that can be used as part of a require hook for a
  * loader.js Loader.
  * This function handles "raw!" and "theme-loader!" requires.
  * See also: https://github.com/webpack/raw-loader.
  */
-this.requireRawId = function(id, require) {
+const requireRawId = function(id, require) {
   const index = id.indexOf("!");
   const rawId = id.slice(index + 1);
   let uri = require.resolve(rawId);
   // If the original string did not end with ".js", then
   // require.resolve might have added the suffix.  We don't want to
   // add a suffix for a raw load (if needed the caller can specify it
   // manually), so remove it here.
   if (!id.endsWith(".js") && uri.endsWith(".js")) {
@@ -35,9 +35,9 @@ this.requireRawId = function(id, require
   });
   stream.close();
 
   // For the time being it doesn't seem worthwhile to cache the
   // result here.
   return data;
 };
 
-this.EXPORTED_SYMBOLS = ["requireRawId"];
+const EXPORTED_SYMBOLS = ["requireRawId"];
diff --git a/devtools/startup/DevToolsShim.jsm b/devtools/startup/DevToolsShim.jsm
--- a/devtools/startup/DevToolsShim.jsm
+++ b/devtools/startup/DevToolsShim.jsm
@@ -25,34 +25,34 @@ XPCOMUtils.defineLazyGetter(this, "Telem
   const Telemetry = require("devtools/client/shared/telemetry");
 
   return Telemetry;
 });
 
 const DEVTOOLS_ENABLED_PREF = "devtools.enabled";
 const DEVTOOLS_POLICY_DISABLED_PREF = "devtools.policy.disabled";
 
-this.EXPORTED_SYMBOLS = ["DevToolsShim"];
+const EXPORTED_SYMBOLS = ["DevToolsShim"];
 
 function removeItem(array, callback) {
   const index = array.findIndex(callback);
   if (index >= 0) {
     array.splice(index, 1);
   }
 }
 
 /**
  * DevToolsShim is a singleton that provides a set of helpers to interact with DevTools,
  * that work whether Devtools are enabled or not.
  *
  * It can be used to start listening to devtools events before DevTools are ready. As soon
  * as DevTools are enabled, the DevToolsShim will forward all the requests received until
  * then to the real DevTools instance.
  */
-this.DevToolsShim = {
+const DevToolsShim = {
   _gDevTools: null,
   listeners: [],
 
   get telemetry() {
     if (!this._telemetry) {
       this._telemetry = new Telemetry();
       this._telemetry.setEventRecordingEnabled(true);
     }
@@ -312,17 +312,17 @@ const webExtensionsMethods = [
   "createTargetForTab",
   "createWebExtensionInspectedWindowFront",
   "getTargetForTab",
   "getTheme",
   "openBrowserConsole",
 ];
 
 for (const method of webExtensionsMethods) {
-  this.DevToolsShim[method] = function() {
+  DevToolsShim[method] = function() {
     if (!this.isEnabled()) {
       throw new Error(
         "Could not call a DevToolsShim webextension method ('" +
           method +
           "'): DevTools are not initialized."
       );
     }
 
diff --git a/dom/presentation/provider/StateMachineHelper.jsm b/dom/presentation/provider/StateMachineHelper.jsm
--- a/dom/presentation/provider/StateMachineHelper.jsm
+++ b/dom/presentation/provider/StateMachineHelper.jsm
@@ -29,11 +29,8 @@ const CommandType = Object.freeze({
   TERMINATE_ACK: "terminate-ack", // { presentationId: <string> }
   RECONNECT: "reconnect", // { presentationId: <string> }
   RECONNECT_ACK: "reconnect-ack", // { presentationId: <string> }
   // session transport establishment
   OFFER: "offer", // { offer: <json> }
   ANSWER: "answer", // { answer: <json> }
   ICE_CANDIDATE: "ice-candidate", // { candidate: <string> }
 });
-
-this.State = State; // jshint ignore:line
-this.CommandType = CommandType; // jshint ignore:line
diff --git a/dom/push/PushDB.jsm b/dom/push/PushDB.jsm
--- a/dom/push/PushDB.jsm
+++ b/dom/push/PushDB.jsm
@@ -26,17 +26,17 @@ function PushDB(dbName, dbVersion, dbSto
   this._dbStoreName = dbStoreName;
   this._keyPath = keyPath;
   this._model = model;
 
   // set the indexeddb database
   this.initDBHelper(dbName, dbVersion, [dbStoreName]);
 }
 
-this.PushDB.prototype = {
+PushDB.prototype = {
   __proto__: IndexedDBHelper.prototype,
 
   toPushRecord(record) {
     if (!record) {
       return null;
     }
     return new this._model(record);
   },
diff --git a/intl/l10n/Fluent.jsm b/intl/l10n/Fluent.jsm
--- a/intl/l10n/Fluent.jsm
+++ b/intl/l10n/Fluent.jsm
@@ -1205,17 +1205,17 @@ class FluentResource {
     function makeIndent(blank) {
       let value = blank.replace(RE_BLANK_LINES, "\n");
       let length = RE_INDENT.exec(blank)[1].length;
       return {type: "indent", value, length};
     }
   }
 }
 
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   ...Object.keys({
     FluentBundle,
     FluentResource,
     FluentError,
     FluentType,
     FluentNumber,
     FluentDateTime,
   }),
diff --git a/intl/l10n/FluentSyntax.jsm b/intl/l10n/FluentSyntax.jsm
--- a/intl/l10n/FluentSyntax.jsm
+++ b/intl/l10n/FluentSyntax.jsm
@@ -1942,16 +1942,16 @@ const visitor = ({
   Visitor: Visitor,
   Transformer: Transformer
 });
 
 /* eslint object-shorthand: "off",
           comma-dangle: "off",
           no-labels: "off" */
 
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   ...Object.keys({
     FluentParser,
     FluentSerializer,
   }),
   ...Object.keys(ast),
   ...Object.keys(visitor),
 ];
diff --git a/intl/l10n/L10nRegistry.jsm b/intl/l10n/L10nRegistry.jsm
--- a/intl/l10n/L10nRegistry.jsm
+++ b/intl/l10n/L10nRegistry.jsm
@@ -715,29 +715,29 @@ class IndexedFileSource extends FileSour
     super(name, locales, prePath);
     this.indexed = true;
     for (const path of paths) {
       this.cache[path] = true;
     }
   }
 }
 
-this.L10nRegistry = new L10nRegistryService();
+const L10nRegistry = new L10nRegistryService();
 
 /**
  * The low level wrapper around Fetch API. It unifies the error scenarios to
  * always produce a promise rejection.
  *
  * We keep it as a method to make it easier to override for testing purposes.
  *
  * @param {string} url
  *
  * @returns {Promise<string>}
  */
-this.L10nRegistry.load = function(url) {
+L10nRegistry.load = function(url) {
   return fetch(url).then(response => {
     if (!response.ok) {
       return Promise.reject(response.statusText);
     }
     return response.text();
   });
 };
 
@@ -748,17 +748,17 @@ this.L10nRegistry.load = function(url) {
  *
  * Notice: Any changes to this method should be copied
  * to the `generateResourceSetSync` equivalent below.
  *
  * @param {string} url
  *
  * @returns {string}
  */
-this.L10nRegistry.loadSync = function(uri) {
+L10nRegistry.loadSync = function(uri) {
   try {
     let url = Services.io.newURI(uri);
     let data = Cu.readUTF8URI(url);
     return data;
   } catch (e) {
     if (
       e.result == Cr.NS_ERROR_INVALID_ARG ||
       e.result == Cr.NS_ERROR_NOT_INITIALIZED
@@ -780,12 +780,9 @@ this.L10nRegistry.loadSync = function(ur
     } else if (e.result != Cr.NS_ERROR_FILE_NOT_FOUND) {
       Cu.reportError(e);
     }
   }
 
   return false;
 };
 
-this.FileSource = FileSource;
-this.IndexedFileSource = IndexedFileSource;
-
 var EXPORTED_SYMBOLS = ["L10nRegistry", "FileSource", "IndexedFileSource"];
diff --git a/intl/l10n/Localization.jsm b/intl/l10n/Localization.jsm
--- a/intl/l10n/Localization.jsm
+++ b/intl/l10n/Localization.jsm
@@ -637,10 +637,9 @@ function keysFromBundle(method, bundle, 
 var getLocalization = (resourceIds, sync = false) => {
   return new Localization(resourceIds, sync);
 };
 
 var getLocalizationWithCustomGenerateMessages = (resourceIds, generateMessages) => {
   return new Localization(resourceIds, false, generateMessages);
 };
 
-this.Localization = Localization;
 var EXPORTED_SYMBOLS = ["Localization", "getLocalization", "getLocalizationWithCustomGenerateMessages"];
diff --git a/layout/tools/reftest/globals.jsm b/layout/tools/reftest/globals.jsm
--- a/layout/tools/reftest/globals.jsm
+++ b/layout/tools/reftest/globals.jsm
@@ -157,11 +157,11 @@ for (let [key, val] of Object.entries({
     testPrintOutput: null,
 
     manifestsLoaded: {},
     // Only dump the sandbox once, because it doesn't depend on the
     // manifest URL (yet!).
     dumpedConditionSandbox: false,
   }
 })) {
-  this[key] = val;
-  this.EXPORTED_SYMBOLS.push(key);
+  const key = val;
+  EXPORTED_SYMBOLS.push(key);
 }
diff --git a/mobile/android/modules/FxAccountsWebChannel.jsm b/mobile/android/modules/FxAccountsWebChannel.jsm
--- a/mobile/android/modules/FxAccountsWebChannel.jsm
+++ b/mobile/android/modules/FxAccountsWebChannel.jsm
@@ -55,19 +55,19 @@ ChromeUtils.defineModuleGetter(
   "resource://gre/modules/Prompt.jsm"
 );
 ChromeUtils.defineModuleGetter(
   this,
   "UITelemetry",
   "resource://gre/modules/UITelemetry.jsm"
 );
 
-this.FxAccountsWebChannelHelpers = function() {};
+const FxAccountsWebChannelHelpers = function() {};
 
-this.FxAccountsWebChannelHelpers.prototype = {
+FxAccountsWebChannelHelpers.prototype = {
   /**
    * Get the hash of account name of the previously signed in account.
    */
   getPreviousAccountNameHashPref() {
     try {
       return Services.prefs.getStringPref(PREF_LAST_FXA_USER);
     } catch (_) {
       return "";
@@ -111,17 +111,17 @@ this.FxAccountsWebChannelHelpers.prototy
  *     @param {String} options.content_uri
  *     The FxA Content server uri
  *     @param {String} options.channel_id
  *     The ID of the WebChannel
  *     @param {String} options.helpers
  *     Helpers functions. Should only be passed in for testing.
  * @constructor
  */
-this.FxAccountsWebChannel = function(options) {
+const FxAccountsWebChannel = function(options) {
   if (!options) {
     throw new Error("Missing configuration options");
   }
   if (!options.content_uri) {
     throw new Error("Missing 'content_uri' option");
   }
   this._contentUri = options.content_uri;
 
@@ -131,17 +131,17 @@ this.FxAccountsWebChannel = function(opt
   this._webChannelId = options.channel_id;
 
   // options.helpers is only specified by tests.
   this._helpers = options.helpers || new FxAccountsWebChannelHelpers(options);
 
   this._setupChannel();
 };
 
-this.FxAccountsWebChannel.prototype = {
+FxAccountsWebChannel.prototype = {
   /**
    * WebChannel that is used to communicate with content page
    */
   _channel: null,
 
   /**
    * WebChannel ID.
    */
@@ -518,14 +518,14 @@ var singleton;
 // allowing multiple channels would cause such notifications to be sent multiple
 // times.
 var EnsureFxAccountsWebChannel = () => {
   if (!singleton) {
     let contentUri = Services.urlFormatter.formatURLPref(
       "identity.fxaccounts.remote.webchannel.uri"
     );
     // The FxAccountsWebChannel listens for events and updates the Java layer.
-    singleton = new this.FxAccountsWebChannel({
+    singleton = new FxAccountsWebChannel({
       content_uri: contentUri,
       channel_id: WEBCHANNEL_ID,
     });
   }
 };
diff --git a/mobile/android/modules/geckoview/AndroidLog.jsm b/mobile/android/modules/geckoview/AndroidLog.jsm
--- a/mobile/android/modules/geckoview/AndroidLog.jsm
+++ b/mobile/android/modules/geckoview/AndroidLog.jsm
@@ -36,17 +36,17 @@
  *
  * Note: the module automatically prepends "Gecko" to the tag you specify,
  * since all tags used by Fennec code should start with that string; and it
  * truncates tags longer than MAX_TAG_LENGTH characters (not including "Gecko").
  */
 
 if (typeof Components != "undefined") {
   // Specify exported symbols for JSM module loader.
-  this.EXPORTED_SYMBOLS = ["AndroidLog"];
+  const EXPORTED_SYMBOLS = ["AndroidLog"];
   var { ctypes } = ChromeUtils.import("resource://gre/modules/ctypes.jsm");
 }
 
 // From <https://android.googlesource.com/platform/system/core/+/master/include/android/log.h>.
 const ANDROID_LOG_VERBOSE = 2;
 const ANDROID_LOG_DEBUG = 3;
 const ANDROID_LOG_INFO = 4;
 const ANDROID_LOG_WARN = 5;
diff --git a/netwerk/url-classifier/UrlClassifierSkipListService.jsm b/netwerk/url-classifier/UrlClassifierSkipListService.jsm
--- a/netwerk/url-classifier/UrlClassifierSkipListService.jsm
+++ b/netwerk/url-classifier/UrlClassifierSkipListService.jsm
@@ -1,13 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-this.UrlClassifierSkipListService = function() {};
+const UrlClassifierSkipListService = function() {};
 
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 ChromeUtils.defineModuleGetter(
   this,
   "RemoteSettings",
   "resource://services-settings/remote-settings.js"
 );
diff --git a/remote/domains/parent/network/ChannelEventSink.jsm b/remote/domains/parent/network/ChannelEventSink.jsm
--- a/remote/domains/parent/network/ChannelEventSink.jsm
+++ b/remote/domains/parent/network/ChannelEventSink.jsm
@@ -101,9 +101,8 @@ ChannelEventSinkFactory.getService = fun
   // Make sure the ChannelEventSink service is registered before accessing it
   ChannelEventSinkFactory.register();
 
   return Cc[SINK_CONTRACT_ID].getService(Ci.nsIChannelEventSink)
     .wrappedJSObject;
 };
 
 var EXPORTED_SYMBOLS = ["ChannelEventSinkFactory"];
-this.ChannelEventSinkFactory = ChannelEventSinkFactory;
diff --git a/remote/domains/parent/network/NetworkObserver.jsm b/remote/domains/parent/network/NetworkObserver.jsm
--- a/remote/domains/parent/network/NetworkObserver.jsm
+++ b/remote/domains/parent/network/NetworkObserver.jsm
@@ -626,9 +626,8 @@ function getNetworkErrorStatusText(statu
       default:
         return "SSL_ERROR_UNKNOWN";
     }
   }
   return "<unknown error>";
 }
 
 var EXPORTED_SYMBOLS = ["NetworkObserver"];
-this.NetworkObserver = NetworkObserver;
diff --git a/security/manager/ssl/tests/unit/test_der.js b/security/manager/ssl/tests/unit/test_der.js
--- a/security/manager/ssl/tests/unit/test_der.js
+++ b/security/manager/ssl/tests/unit/test_der.js
@@ -113,33 +113,51 @@ function run_simple_tests() {
   let invalidLengthSEQUENCE1 = new DER.DERDecoder([0x30, 0x81, 0x01, 0x00]);
   throws(
     () => invalidLengthSEQUENCE1.readTagAndGetContents(DER.SEQUENCE),
     /invalid length/,
     "should get 'invalid length' error"
   );
 
   // Similarly, 0x82 0x00 0x01 could be encoded as just 0x01, which is shorter.
-  let invalidLengthSEQUENCE2 = new DER.DERDecoder([0x30, 0x82, 0x00, 0x01, 0x00]);
+  let invalidLengthSEQUENCE2 = new DER.DERDecoder([
+    0x30,
+    0x82,
+    0x00,
+    0x01,
+    0x00,
+  ]);
   throws(
     () => invalidLengthSEQUENCE2.readTagAndGetContents(DER.SEQUENCE),
     /invalid length/,
     "should get 'invalid length' error"
   );
 
   // Lengths requiring 4 bytes to encode are not supported.
-  let unsupportedLengthSEQUENCE = new DER.DERDecoder([0x30, 0x83, 0x01, 0x01, 0x01]);
+  let unsupportedLengthSEQUENCE = new DER.DERDecoder([
+    0x30,
+    0x83,
+    0x01,
+    0x01,
+    0x01,
+  ]);
   throws(
     () => unsupportedLengthSEQUENCE.readTagAndGetContents(DER.SEQUENCE),
     /unsupported length/,
     "should get 'unsupported length' error"
   );
 
   // Indefinite lengths are not supported (and aren't DER anyway).
-  let unsupportedASN1SEQUENCE = new DER.DERDecoder([0x30, 0x80, 0x01, 0x00, 0x00]);
+  let unsupportedASN1SEQUENCE = new DER.DERDecoder([
+    0x30,
+    0x80,
+    0x01,
+    0x00,
+    0x00,
+  ]);
   throws(
     () => unsupportedASN1SEQUENCE.readTagAndGetContents(DER.SEQUENCE),
     /unsupported asn.1/,
     "should get 'unsupported asn.1' error"
   );
 
   let unexpectedTag = new DER.DERDecoder([0x31, 0x01, 0x00]);
   throws(
@@ -279,32 +297,36 @@ function run_compound_tests() {
   );
   let oid = contents.readTagAndGetContents(DER.OBJECT_IDENTIFIER);
   deepEqual(
     oid,
     [0x2b, 0x01, 0x01],
     "OBJECT IDENTIFIER should have expected value"
   );
 
-  let firstNested = new DER.DERDecoder(contents.readTagAndGetContents(DER.SEQUENCE));
+  let firstNested = new DER.DERDecoder(
+    contents.readTagAndGetContents(DER.SEQUENCE)
+  );
   let firstNestedNULL = firstNested.readTagAndGetContents(DER.NULL);
   equal(
     firstNestedNULL.length,
     0,
     "first nested NULL should have expected value (empty array)"
   );
   let firstNestedINTEGER = firstNested.readTagAndGetContents(DER.INTEGER);
   deepEqual(
     firstNestedINTEGER,
     [0x45, 0x46, 0x47],
     "first nested INTEGER should have expected value"
   );
   firstNested.assertAtEnd();
 
-  let secondNested = new DER.DERDecoder(contents.readTagAndGetContents(DER.SEQUENCE));
+  let secondNested = new DER.DERDecoder(
+    contents.readTagAndGetContents(DER.SEQUENCE)
+  );
   let secondNestedINTEGER = secondNested.readTagAndGetContents(DER.INTEGER);
   deepEqual(
     secondNestedINTEGER,
     [0x00, 0xff],
     "second nested INTEGER should have expected value"
   );
   let secondNestedNULL = secondNested.readTagAndGetContents(DER.NULL);
   equal(
diff --git a/services/fxaccounts/Credentials.jsm b/services/fxaccounts/Credentials.jsm
--- a/services/fxaccounts/Credentials.jsm
+++ b/services/fxaccounts/Credentials.jsm
@@ -28,22 +28,21 @@ const STRETCHED_PW_LENGTH_BYTES = 32;
 const HKDF_SALT = CommonUtils.hexToBytes("00");
 const HKDF_LENGTH = 32;
 
 // loglevel preference should be one of: "FATAL", "ERROR", "WARN", "INFO",
 // "CONFIG", "DEBUG", "TRACE" or "ALL". We will be logging error messages by
 // default.
 const PREF_LOG_LEVEL = "identity.fxaccounts.loglevel";
 try {
-  this.LOG_LEVEL =
-    Services.prefs.getPrefType(PREF_LOG_LEVEL) ==
-      Ci.nsIPrefBranch.PREF_STRING &&
-    Services.prefs.getCharPref(PREF_LOG_LEVEL);
+  const LOG_LEVEL = Services.prefs.getPrefType(PREF_LOG_LEVEL) ==
+    Ci.nsIPrefBranch.PREF_STRING &&
+  Services.prefs.getCharPref(PREF_LOG_LEVEL);
 } catch (e) {
-  this.LOG_LEVEL = Log.Level.Error;
+  const LOG_LEVEL = Log.Level.Error;
 }
 
 var log = Log.repository.getLogger("Identity.FxAccounts");
 log.level = LOG_LEVEL;
 log.addAppender(new Log.ConsoleAppender(new Log.BasicFormatter()));
 
 var Credentials = Object.freeze({
   /**
diff --git a/services/fxaccounts/FxAccounts.jsm b/services/fxaccounts/FxAccounts.jsm
--- a/services/fxaccounts/FxAccounts.jsm
+++ b/services/fxaccounts/FxAccounts.jsm
@@ -130,29 +130,29 @@ XPCOMUtils.defineLazyPreferenceGetter(
 // somePromiseBasedFunction: function() {
 //   let currentState = this.currentAccountState;
 //   return someOtherPromiseFunction().then(
 //     data => currentState.resolve(data)
 //   );
 // }
 // If the state has changed between the function being called and the promise
 // being resolved, the .resolve() call will actually be rejected.
-var AccountState = (this.AccountState = function(storageManager) {
+var AccountState = (function(storageManager) {
   this.storageManager = storageManager;
   this.inFlightTokenRequests = new Map();
   this.promiseInitialized = this.storageManager
     .getAccountData()
     .then(data => {
       this.oauthTokens = data && data.oauthTokens ? data.oauthTokens : {};
     })
     .catch(err => {
       log.error("Failed to initialize the storage manager", err);
       // Things are going to fall apart, but not much we can do about it here.
     });
-});
+});;
 
 AccountState.prototype = {
   oauthTokens: null,
   whenVerifiedDeferred: null,
   whenKeysReadyDeferred: null,
 
   // If the storage manager has been nuked then we are no longer current.
   get isCurrent() {
diff --git a/services/fxaccounts/FxAccountsClient.jsm b/services/fxaccounts/FxAccountsClient.jsm
--- a/services/fxaccounts/FxAccountsClient.jsm
+++ b/services/fxaccounts/FxAccountsClient.jsm
@@ -44,17 +44,17 @@ var FxAccountsClient = function(host = S
   this.hawk = new HawkClient(host);
   this.hawk.observerPrefix = "FxA:hawk";
 
   // Manage server backoff state. C.f.
   // https://github.com/mozilla/fxa-auth-server/blob/master/docs/api.md#backoff-protocol
   this.backoffError = null;
 };
 
-this.FxAccountsClient.prototype = {
+FxAccountsClient.prototype = {
   /**
    * Return client clock offset, in milliseconds, as determined by hawk client.
    * Provided because callers should not have to know about hawk
    * implementation.
    *
    * The offset is the number of milliseconds that must be added to the client
    * clock to make it equal to the server clock.  For example, if the client is
    * five minutes ahead of the server, the localtimeOffsetMsec will be -300000.
diff --git a/services/fxaccounts/FxAccountsOAuthGrantClient.jsm b/services/fxaccounts/FxAccountsOAuthGrantClient.jsm
--- a/services/fxaccounts/FxAccountsOAuthGrantClient.jsm
+++ b/services/fxaccounts/FxAccountsOAuthGrantClient.jsm
@@ -67,17 +67,17 @@ var FxAccountsOAuthGrantClient = functio
   let forceHTTPS = !Services.prefs.getBoolPref(ALLOW_HTTP_PREF, false);
   if (forceHTTPS && this.serverURL.protocol != "https:") {
     throw new Error("'serverURL' must be HTTPS");
   }
 
   log.debug("FxAccountsOAuthGrantClient Initialized");
 };
 
-this.FxAccountsOAuthGrantClient.prototype = {
+FxAccountsOAuthGrantClient.prototype = {
   /**
    * Retrieves an OAuth access token for the signed in user
    *
    * @param {Object} assertion BrowserID assertion
    * @param {String} scope OAuth scope
    * @return Promise
    *        Resolves: {Object} Object with access_token property
    */
diff --git a/services/fxaccounts/FxAccountsPairing.jsm b/services/fxaccounts/FxAccountsPairing.jsm
--- a/services/fxaccounts/FxAccountsPairing.jsm
+++ b/services/fxaccounts/FxAccountsPairing.jsm
@@ -164,17 +164,17 @@ class Completed extends State {}
 class Aborted extends State {}
 class Errored extends State {
   init(error) {
     this.error = error;
   }
 }
 
 const flows = new Map();
-this.FxAccountsPairingFlow = class FxAccountsPairingFlow {
+class FxAccountsPairingFlow {
   static get(channelId) {
     return flows.get(channelId);
   }
 
   static finalizeAll() {
     for (const flow of flows) {
       flow.finalize();
     }
diff --git a/services/fxaccounts/FxAccountsProfile.jsm b/services/fxaccounts/FxAccountsProfile.jsm
--- a/services/fxaccounts/FxAccountsProfile.jsm
+++ b/services/fxaccounts/FxAccountsProfile.jsm
@@ -44,17 +44,17 @@ var FxAccountsProfile = function(options
   // just incase this.tearDown isn't called in some cases.
   Services.obs.addObserver(this, ON_PROFILE_CHANGE_NOTIFICATION, true);
   // for testing
   if (options.channel) {
     this.channel = options.channel;
   }
 };
 
-this.FxAccountsProfile.prototype = {
+FxAccountsProfile.prototype = {
   // If we get subsequent requests for a profile within this period, don't bother
   // making another request to determine if it is fresh or not.
   PROFILE_FRESHNESS_THRESHOLD: 120000, // 2 minutes
 
   observe(subject, topic, data) {
     // If we get a profile change notification from our webchannel it means
     // the user has just changed their profile via the web, so we want to
     // ignore our "freshness threshold"
diff --git a/services/fxaccounts/FxAccountsProfileClient.jsm b/services/fxaccounts/FxAccountsProfileClient.jsm
--- a/services/fxaccounts/FxAccountsProfileClient.jsm
+++ b/services/fxaccounts/FxAccountsProfileClient.jsm
@@ -67,17 +67,17 @@ var FxAccountsProfileClient = function(o
     throw new Error("Invalid 'serverURL'");
   }
   this.oauthOptions = {
     scope: SCOPE_PROFILE,
   };
   log.debug("FxAccountsProfileClient: Initialized");
 };
 
-this.FxAccountsProfileClient.prototype = {
+FxAccountsProfileClient.prototype = {
   /**
    * {nsIURI}
    * The server to fetch profile information from.
    */
   serverURL: null,
 
   /**
    * Interface for making remote requests.
diff --git a/services/fxaccounts/FxAccountsStorage.jsm b/services/fxaccounts/FxAccountsStorage.jsm
--- a/services/fxaccounts/FxAccountsStorage.jsm
+++ b/services/fxaccounts/FxAccountsStorage.jsm
@@ -50,17 +50,17 @@ var FxAccountsStorageManager = function(
   }
   this._clearCachedData();
   // See .initialize() below - this protects against it not being called.
   this._promiseInitialized = Promise.reject("initialize not called");
   // A promise to avoid storage races - see _queueStorageOperation
   this._promiseStorageComplete = Promise.resolve();
 };
 
-this.FxAccountsStorageManager.prototype = {
+FxAccountsStorageManager.prototype = {
   _initialized: false,
   _needToReadSecure: true,
 
   // An initialization routine that *looks* synchronous to the callers, but
   // is actually async as everything else waits for it to complete.
   initialize(accountData) {
     if (this._initialized) {
       throw new Error("already initialized");
diff --git a/services/fxaccounts/FxAccountsWebChannel.jsm b/services/fxaccounts/FxAccountsWebChannel.jsm
--- a/services/fxaccounts/FxAccountsWebChannel.jsm
+++ b/services/fxaccounts/FxAccountsWebChannel.jsm
@@ -139,17 +139,17 @@ function getErrorDetails(error) {
  *     @param {String} options.content_uri
  *     The FxA Content server uri
  *     @param {String} options.channel_id
  *     The ID of the WebChannel
  *     @param {String} options.helpers
  *     Helpers functions. Should only be passed in for testing.
  * @constructor
  */
-this.FxAccountsWebChannel = function(options) {
+const FxAccountsWebChannel = function(options) {
   if (!options) {
     throw new Error("Missing configuration options");
   }
   if (!options.content_uri) {
     throw new Error("Missing 'content_uri' option");
   }
   this._contentUri = options.content_uri;
 
@@ -161,17 +161,17 @@ this.FxAccountsWebChannel = function(opt
   // options.helpers is only specified by tests.
   XPCOMUtils.defineLazyGetter(this, "_helpers", () => {
     return options.helpers || new FxAccountsWebChannelHelpers(options);
   });
 
   this._setupChannel();
 };
 
-this.FxAccountsWebChannel.prototype = {
+FxAccountsWebChannel.prototype = {
   /**
    * WebChannel that is used to communicate with content page
    */
   _channel: null,
 
   /**
    * Helpers interface that does the heavy lifting.
    */
@@ -386,26 +386,26 @@ this.FxAccountsWebChannel.prototype = {
       "FxAccountsWebChannel registered: " +
         this._webChannelId +
         " with origin " +
         this._webChannelOrigin.prePath
     );
   },
 };
 
-this.FxAccountsWebChannelHelpers = function(options) {
+const FxAccountsWebChannelHelpers = function(options) {
   options = options || {};
 
   this._fxAccounts = options.fxAccounts || fxAccounts;
   this._weaveXPCOM = options.weaveXPCOM || null;
   this._privateBrowsingUtils =
     options.privateBrowsingUtils || PrivateBrowsingUtils;
 };
 
-this.FxAccountsWebChannelHelpers.prototype = {
+FxAccountsWebChannelHelpers.prototype = {
   // If the last fxa account used for sync isn't this account, we display
   // a modal dialog checking they really really want to do this...
   // (This is sync-specific, so ideally would be in sync's identity module,
   // but it's a little more seamless to do here, and sync is currently the
   // only fxa consumer, so...
   shouldAllowRelink(acctName) {
     return (
       !this._needRelinkWarning(acctName) || this._promptForRelink(acctName)
@@ -733,17 +733,17 @@ var EnsureFxAccountsWebChannel = () => {
     singleton.tearDown();
     singleton = null;
   }
   if (!singleton) {
     try {
       if (contentUri) {
         // The FxAccountsWebChannel listens for events and updates
         // the state machine accordingly.
-        singleton = new this.FxAccountsWebChannel({
+        singleton = new FxAccountsWebChannel({
           content_uri: contentUri,
           channel_id: WEBCHANNEL_ID,
         });
       } else {
         log.warn("FxA WebChannel functionaly is disabled due to no URI pref.");
       }
     } catch (ex) {
       log.error("Failed to create FxA WebChannel", ex);
diff --git a/testing/modules/Assert.jsm b/testing/modules/Assert.jsm
--- a/testing/modules/Assert.jsm
+++ b/testing/modules/Assert.jsm
@@ -31,24 +31,24 @@ ChromeUtils.defineModuleGetter(
  * to override certain behavior on the newly obtained instance. For examples,
  * see the javadoc comments for the `report` member function.
  *
  * The isDefault argument is used by test suites to set reporterFunc as the
  * default used by the global instance, which is called for example by other
  * test-only modules. This is false when the reporter is set by content scripts,
  * because they may still run in the parent process.
  */
-var Assert = (this.Assert = function(reporterFunc, isDefault) {
+var Assert = (function(reporterFunc, isDefault) {
   if (reporterFunc) {
     this.setReporter(reporterFunc);
   }
   if (isDefault) {
     Assert.setReporter(reporterFunc);
   }
-});
+});;
 
 // This allows using the Assert object as an additional global instance.
 Object.setPrototypeOf(Assert, Assert.prototype);
 
 function instanceOf(object, type) {
   return Object.prototype.toString.call(object) == "[object " + type + "]";
 }
 
diff --git a/toolkit/actors/SelectChild.jsm b/toolkit/actors/SelectChild.jsm
--- a/toolkit/actors/SelectChild.jsm
+++ b/toolkit/actors/SelectChild.jsm
@@ -60,17 +60,17 @@ var SelectContentHelper = function(aElem
 };
 
 Object.defineProperty(SelectContentHelper, "open", {
   get() {
     return gOpen;
   },
 });
 
-this.SelectContentHelper.prototype = {
+SelectContentHelper.prototype = {
   init() {
     let win = this.element.ownerGlobal;
     win.addEventListener("pagehide", this, { mozSystemGroup: true });
     this.element.addEventListener("blur", this, { mozSystemGroup: true });
     this.element.addEventListener("transitionend", this, {
       mozSystemGroup: true,
     });
     let MutationObserver = this.element.ownerGlobal.MutationObserver;
diff --git a/toolkit/components/antitracking/AsyncStreamReader.jsm b/toolkit/components/antitracking/AsyncStreamReader.jsm
--- a/toolkit/components/antitracking/AsyncStreamReader.jsm
+++ b/toolkit/components/antitracking/AsyncStreamReader.jsm
@@ -1,17 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 
-this.readAsyncStream = function(stream) {
+const readAsyncStream = function(stream) {
   return new Promise(function(resolve, reject) {
     let result = "";
     let source = Cc["@mozilla.org/binaryinputstream;1"].createInstance(
       Ci.nsIBinaryInputStream
     );
     source.setInputStream(stream);
     function readData() {
       try {
diff --git a/toolkit/components/antitracking/TrackingDBService.jsm b/toolkit/components/antitracking/TrackingDBService.jsm
--- a/toolkit/components/antitracking/TrackingDBService.jsm
+++ b/toolkit/components/antitracking/TrackingDBService.jsm
@@ -110,17 +110,17 @@ async function createDatabase(db) {
 async function removeAllRecords(db) {
   await db.execute(SQL.deleteEventsRecords);
 }
 
 async function removeRecordsSince(db, date) {
   await db.execute(SQL.removeRecordsSince, { date });
 }
 
-this.TrackingDBService = function() {
+const TrackingDBService = function() {
   this._initPromise = this._initialize();
 };
 
 TrackingDBService.prototype = {
   classID: Components.ID("{3c9c43b6-09eb-4ed2-9b87-e29f4221eef0}"),
   QueryInterface: ChromeUtils.generateQI([Ci.nsITrackingDBService]),
   _xpcom_factory: XPCOMUtils.generateSingletonFactory(TrackingDBService),
   // This is the connection to the database, opened in _initialize and closed on _shutdown.
diff --git a/toolkit/components/antitracking/URLDecorationAnnotationsService.jsm b/toolkit/components/antitracking/URLDecorationAnnotationsService.jsm
--- a/toolkit/components/antitracking/URLDecorationAnnotationsService.jsm
+++ b/toolkit/components/antitracking/URLDecorationAnnotationsService.jsm
@@ -1,13 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-this.URLDecorationAnnotationsService = function() {};
+const URLDecorationAnnotationsService = function() {};
 
 ChromeUtils.defineModuleGetter(
   this,
   "RemoteSettings",
   "resource://services-settings/remote-settings.js"
 );
 
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
diff --git a/toolkit/components/asyncshutdown/AsyncShutdown.jsm b/toolkit/components/asyncshutdown/AsyncShutdown.jsm
--- a/toolkit/components/asyncshutdown/AsyncShutdown.jsm
+++ b/toolkit/components/asyncshutdown/AsyncShutdown.jsm
@@ -1045,35 +1045,35 @@ Barrier.prototype = Object.freeze({
 
 // List of well-known phases
 // Ideally, phases should be registered from the component that decides
 // when they start/stop. For compatibility with existing startup/shutdown
 // mechanisms, we register a few phases here.
 
 // Parent process
 if (!isContent) {
-  this.AsyncShutdown.profileChangeTeardown = getPhase(
+  AsyncShutdown.profileChangeTeardown = getPhase(
     "profile-change-teardown"
   );
-  this.AsyncShutdown.profileBeforeChange = getPhase("profile-before-change");
-  this.AsyncShutdown.sendTelemetry = getPhase(
+  AsyncShutdown.profileBeforeChange = getPhase("profile-before-change");
+  AsyncShutdown.sendTelemetry = getPhase(
     "profile-before-change-telemetry"
   );
 }
 
 // Notifications that fire in the parent and content process, but should
 // only have phases in the parent process.
 if (!isContent) {
-  this.AsyncShutdown.quitApplicationGranted = getPhase(
+  AsyncShutdown.quitApplicationGranted = getPhase(
     "quit-application-granted"
   );
 }
 
 // Don't add a barrier for content-child-shutdown because this
 // makes it easier to cause shutdown hangs.
 
 // All processes
-this.AsyncShutdown.webWorkersShutdown = getPhase("web-workers-shutdown");
-this.AsyncShutdown.xpcomWillShutdown = getPhase("xpcom-will-shutdown");
+AsyncShutdown.webWorkersShutdown = getPhase("web-workers-shutdown");
+AsyncShutdown.xpcomWillShutdown = getPhase("xpcom-will-shutdown");
 
-this.AsyncShutdown.Barrier = Barrier;
+AsyncShutdown.Barrier = Barrier;
 
-Object.freeze(this.AsyncShutdown);
+Object.freeze(AsyncShutdown);
diff --git a/toolkit/components/cleardata/ClearDataService.jsm b/toolkit/components/cleardata/ClearDataService.jsm
--- a/toolkit/components/cleardata/ClearDataService.jsm
+++ b/toolkit/components/cleardata/ClearDataService.jsm
@@ -1125,17 +1125,17 @@ const FLAGS_MAP = [
   },
 
   {
     flag: Ci.nsIClearDataService.CLEAR_CONTENT_BLOCKING_RECORDS,
     cleaner: ContentBlockingCleaner,
   },
 ];
 
-this.ClearDataService = function() {
+const ClearDataService = function() {
   this._initialize();
 };
 
 ClearDataService.prototype = Object.freeze({
   classID: Components.ID("{0c06583d-7dd8-4293-b1a5-912205f779aa}"),
   QueryInterface: ChromeUtils.generateQI([Ci.nsIClearDataService]),
   _xpcom_factory: XPCOMUtils.generateSingletonFactory(ClearDataService),
 
diff --git a/toolkit/components/cleardata/ServiceWorkerCleanUp.jsm b/toolkit/components/cleardata/ServiceWorkerCleanUp.jsm
--- a/toolkit/components/cleardata/ServiceWorkerCleanUp.jsm
+++ b/toolkit/components/cleardata/ServiceWorkerCleanUp.jsm
@@ -17,17 +17,17 @@ XPCOMUtils.defineLazyServiceGetter(
 );
 
 if (Services.appinfo.processType === Services.appinfo.PROCESS_TYPE_CONTENT) {
   throw new Error(
     "ServiceWorkerCleanUp.jsm can only be used in the parent process"
   );
 }
 
-this.EXPORTED_SYMBOLS = ["ServiceWorkerCleanUp"];
+const EXPORTED_SYMBOLS = ["ServiceWorkerCleanUp"];
 
 function unregisterServiceWorker(aSW) {
   return new Promise(resolve => {
     let unregisterCallback = {
       unregisterSucceeded: resolve,
       unregisterFailed: resolve, // We don't care about failures.
       QueryInterface: ChromeUtils.generateQI([
         Ci.nsIServiceWorkerUnregisterCallback,
@@ -36,17 +36,17 @@ function unregisterServiceWorker(aSW) {
     serviceWorkerManager.propagateUnregister(
       aSW.principal,
       unregisterCallback,
       aSW.scope
     );
   });
 }
 
-this.ServiceWorkerCleanUp = {
+const ServiceWorkerCleanUp = {
   removeFromHost(aHost) {
     let promises = [];
     let serviceWorkers = serviceWorkerManager.getAllRegistrations();
     for (let i = 0; i < serviceWorkers.length; i++) {
       let sw = serviceWorkers.queryElementAt(
         i,
         Ci.nsIServiceWorkerRegistrationInfo
       );
diff --git a/toolkit/components/corroborator/Corroborate.jsm b/toolkit/components/corroborator/Corroborate.jsm
--- a/toolkit/components/corroborator/Corroborate.jsm
+++ b/toolkit/components/corroborator/Corroborate.jsm
@@ -18,17 +18,17 @@ XPCOMUtils.defineLazyServiceGetters(this
   gCertDB: ["@mozilla.org/security/x509certdb;1", "nsIX509CertDB"],
 });
 
 var EXPORTED_SYMBOLS = ["Corroborate"];
 
 /**
  * Tools for verifying internal files in Mozilla products.
  */
-this.Corroborate = {
+const Corroborate = {
   async init() {
     const appOmniJar = FileUtils.getFile("XCurProcD", [
       AppConstants.OMNIJAR_NAME,
     ]);
     const greOmniJar = FileUtils.getFile("GreD", [AppConstants.OMNIJAR_NAME]);
 
     let corruptOmnijar = true;
     // If an omni jar is missing, we consider that corrupt. Firefox could be running with
diff --git a/toolkit/components/crashes/CrashManager.jsm b/toolkit/components/crashes/CrashManager.jsm
--- a/toolkit/components/crashes/CrashManager.jsm
+++ b/toolkit/components/crashes/CrashManager.jsm
@@ -154,17 +154,17 @@ var CrashManager = function(options) {
   // The timer controlling the expiration of the CrashStore instance.
   this._storeTimer = null;
 
   // This is a semaphore that prevents the store from being freed by our
   // timer-based resource freeing mechanism.
   this._storeProtectedCount = 0;
 };
 
-this.CrashManager.prototype = Object.freeze({
+CrashManager.prototype = Object.freeze({
   // A crash in the main process.
   PROCESS_TYPE_MAIN: "main",
 
   // A crash in a content process.
   PROCESS_TYPE_CONTENT: "content",
 
   // A crash in a plugin process.
   PROCESS_TYPE_PLUGIN: "plugin",
@@ -1518,17 +1518,17 @@ CrashRecord.prototype = Object.freeze({
 });
 
 /**
  * Obtain the global CrashManager instance used by the running application.
  *
  * CrashManager is likely only ever instantiated once per application lifetime.
  * The main reason it's implemented as a reusable type is to facilitate testing.
  */
-XPCOMUtils.defineLazyGetter(this.CrashManager, "Singleton", function() {
+XPCOMUtils.defineLazyGetter(CrashManager, "Singleton", function() {
   if (gCrashManager) {
     return gCrashManager;
   }
 
   gCrashManager = new CrashManager({
     telemetryStoreSizeKey: "CRASH_STORE_COMPRESSED_BYTES",
   });
 
diff --git a/toolkit/components/crashes/CrashManagerTest.jsm b/toolkit/components/crashes/CrashManagerTest.jsm
--- a/toolkit/components/crashes/CrashManagerTest.jsm
+++ b/toolkit/components/crashes/CrashManagerTest.jsm
@@ -43,17 +43,17 @@ var sleep = function(wait) {
     }, wait);
   });
 };
 
 var TestingCrashManager = function(options) {
   CrashManager.call(this, options);
 };
 
-this.TestingCrashManager.prototype = {
+TestingCrashManager.prototype = {
   __proto__: CrashManager.prototype,
 
   createDummyDump(submitted = false, date = new Date(), hr = false) {
     let uuid = Cc["@mozilla.org/uuid-generator;1"]
       .getService(Ci.nsIUUIDGenerator)
       .generateUUID()
       .toString();
     uuid = uuid.substring(1, uuid.length - 1);
diff --git a/toolkit/components/crashes/CrashService.jsm b/toolkit/components/crashes/CrashService.jsm
--- a/toolkit/components/crashes/CrashService.jsm
+++ b/toolkit/components/crashes/CrashService.jsm
@@ -127,17 +127,17 @@ function processExtraFile(extraPath) {
   })();
 }
 
 /**
  * This component makes crash data available throughout the application.
  *
  * It is a service because some background activity will eventually occur.
  */
-this.CrashService = function() {
+const CrashService = function() {
   Services.obs.addObserver(this, "quit-application");
 };
 
 CrashService.prototype = Object.freeze({
   classID: Components.ID("{92668367-1b17-4190-86b2-1061b2179744}"),
   QueryInterface: ChromeUtils.generateQI([Ci.nsICrashService, Ci.nsIObserver]),
 
   async addCrash(processType, crashType, id) {
diff --git a/toolkit/components/crashmonitor/CrashMonitor.jsm b/toolkit/components/crashmonitor/CrashMonitor.jsm
--- a/toolkit/components/crashmonitor/CrashMonitor.jsm
+++ b/toolkit/components/crashmonitor/CrashMonitor.jsm
@@ -218,9 +218,9 @@ var CrashMonitor = {
     if (NOTIFICATIONS.every(elem => elem in CrashMonitorInternal.checkpoints)) {
       // All notifications received, unregister observers
       NOTIFICATIONS.forEach(function(aTopic) {
         Services.obs.removeObserver(this, aTopic);
       }, this);
     }
   },
 };
-Object.freeze(this.CrashMonitor);
+Object.freeze(CrashMonitor);
diff --git a/toolkit/components/downloads/DownloadCore.jsm b/toolkit/components/downloads/DownloadCore.jsm
--- a/toolkit/components/downloads/DownloadCore.jsm
+++ b/toolkit/components/downloads/DownloadCore.jsm
@@ -138,17 +138,17 @@ const kProgressUpdateIntervalMs = 400;
  * Represents a single download, with associated state and actions.  This object
  * is transient, though it can be included in a DownloadList so that it can be
  * managed by the user interface and persisted across sessions.
  */
 var Download = function() {
   this._deferSucceeded = PromiseUtils.defer();
 };
 
-this.Download.prototype = {
+Download.prototype = {
   /**
    * DownloadSource object associated with this download.
    */
   source: null,
 
   /**
    * DownloadTarget object associated with this download.
    */
@@ -1288,17 +1288,17 @@ Download.fromSerializable = function(aSe
   return download;
 };
 
 /**
  * Represents the source of a download, for example a document or an URI.
  */
 var DownloadSource = function() {};
 
-this.DownloadSource.prototype = {
+DownloadSource.prototype = {
   /**
    * String containing the URI for the download source.
    */
   url: null,
 
   /**
    * Indicates whether the download originated from a private window.  This
    * determines the context of the network request that is made to retrieve the
@@ -1407,17 +1407,17 @@ this.DownloadSource.prototype = {
  *                           DownloadCopySaver, this function will determine, if
  *                           provided, if a download can progress or has to be
  *                           cancelled based on the HTTP status code of the
  *                           network channel.
  *        }
  *
  * @return The newly created DownloadSource object.
  */
-this.DownloadSource.fromSerializable = function(aSerializable) {
+DownloadSource.fromSerializable = function(aSerializable) {
   let source = new DownloadSource();
   if (isString(aSerializable)) {
     // Convert String objects to primitive strings at this point.
     source.url = aSerializable.toString();
   } else if (aSerializable instanceof Ci.nsIURI) {
     source.url = aSerializable.spec;
   } else if (aSerializable instanceof Ci.nsIDOMWindow) {
     source.url = aSerializable.location.href;
@@ -1464,17 +1464,17 @@ this.DownloadSource.fromSerializable = f
 };
 
 /**
  * Represents the target of a download, for example a file in the global
  * downloads directory, or a file in the system temporary directory.
  */
 var DownloadTarget = function() {};
 
-this.DownloadTarget.prototype = {
+DownloadTarget.prototype = {
   /**
    * String containing the path of the target file.
    */
   path: null,
 
   /**
    * String containing the path of the ".part" file containing the data
    * downloaded so far, or null to disable the use of a ".part" file to keep
@@ -1560,17 +1560,17 @@ this.DownloadTarget.prototype = {
  *        object with the following properties:
  *        {
  *          path: String containing the path of the target file.
  *          partFilePath: optional string containing the part file path.
  *        }
  *
  * @return The newly created DownloadTarget object.
  */
-this.DownloadTarget.fromSerializable = function(aSerializable) {
+DownloadTarget.fromSerializable = function(aSerializable) {
   let target = new DownloadTarget();
   if (isString(aSerializable)) {
     // Convert String objects to primitive strings at this point.
     target.path = aSerializable.toString();
   } else if (aSerializable instanceof Ci.nsIFile) {
     // Read the "path" property of nsIFile after checking the object type.
     target.path = aSerializable.path;
   } else {
@@ -1665,21 +1665,21 @@ var DownloadError = function(aProperties
 };
 
 /**
  * These constants are used by the reputationCheckVerdict property and indicate
  * the detailed reason why a download is blocked.
  *
  * @note These values should not be changed because they can be serialized.
  */
-this.DownloadError.BLOCK_VERDICT_MALWARE = "Malware";
-this.DownloadError.BLOCK_VERDICT_POTENTIALLY_UNWANTED = "PotentiallyUnwanted";
-this.DownloadError.BLOCK_VERDICT_UNCOMMON = "Uncommon";
+DownloadError.BLOCK_VERDICT_MALWARE = "Malware";
+DownloadError.BLOCK_VERDICT_POTENTIALLY_UNWANTED = "PotentiallyUnwanted";
+DownloadError.BLOCK_VERDICT_UNCOMMON = "Uncommon";
 
-this.DownloadError.prototype = {
+DownloadError.prototype = {
   __proto__: Error.prototype,
 
   /**
    * The result code associated with this error.
    */
   result: false,
 
   /**
@@ -1762,17 +1762,17 @@ this.DownloadError.prototype = {
 /**
  * Creates a new DownloadError object from its serializable representation.
  *
  * @param aSerializable
  *        Serializable representation of a DownloadError object.
  *
  * @return The newly created DownloadError object.
  */
-this.DownloadError.fromSerializable = function(aSerializable) {
+DownloadError.fromSerializable = function(aSerializable) {
   let e = new DownloadError(aSerializable);
   deserializeUnknownProperties(
     e,
     aSerializable,
     property =>
       property != "result" &&
       property != "message" &&
       property != "becauseSourceFailed" &&
@@ -1787,17 +1787,17 @@ this.DownloadError.fromSerializable = fu
   return e;
 };
 
 /**
  * Template for an object that actually transfers the data for the download.
  */
 var DownloadSaver = function() {};
 
-this.DownloadSaver.prototype = {
+DownloadSaver.prototype = {
   /**
    * Download object for raising notifications and reading properties.
    *
    * If the tryToKeepPartialData property of the download object is false, the
    * saver should never try to keep partially downloaded data if the download
    * fails.
    */
   download: null,
@@ -1887,17 +1887,17 @@ this.DownloadSaver.prototype = {
  *
  * @param aSerializable
  *        Serializable representation of a DownloadSaver object.  If no initial
  *        state information for the saver object is needed, can be a string
  *        representing the class of the download operation, for example "copy".
  *
  * @return The newly created DownloadSaver object.
  */
-this.DownloadSaver.fromSerializable = function(aSerializable) {
+DownloadSaver.fromSerializable = function(aSerializable) {
   let serializable = isString(aSerializable)
     ? { type: aSerializable }
     : aSerializable;
   let saver;
   switch (serializable.type) {
     case "copy":
       saver = DownloadCopySaver.fromSerializable(serializable);
       break;
@@ -1913,17 +1913,17 @@ this.DownloadSaver.fromSerializable = fu
   return saver;
 };
 
 /**
  * Saver object that simply copies the entire source file to the target.
  */
 var DownloadCopySaver = function() {};
 
-this.DownloadCopySaver.prototype = {
+DownloadCopySaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
   /**
    * BackgroundFileSaver object currently handling the download.
    */
   _backgroundFileSaver: null,
 
   /**
@@ -2429,17 +2429,17 @@ this.DownloadCopySaver.prototype = {
  * Creates a new DownloadCopySaver object, with its initial state derived from
  * its serializable representation.
  *
  * @param aSerializable
  *        Serializable representation of a DownloadCopySaver object.
  *
  * @return The newly created DownloadCopySaver object.
  */
-this.DownloadCopySaver.fromSerializable = function(aSerializable) {
+DownloadCopySaver.fromSerializable = function(aSerializable) {
   let saver = new DownloadCopySaver();
   if ("entityID" in aSerializable) {
     saver.entityID = aSerializable.entityID;
   }
 
   deserializeUnknownProperties(
     saver,
     aSerializable,
@@ -2454,17 +2454,17 @@ this.DownloadCopySaver.fromSerializable 
  *
  * For more background on the process, see the DownloadLegacyTransfer object.
  */
 var DownloadLegacySaver = function() {
   this.deferExecuted = PromiseUtils.defer();
   this.deferCanceled = PromiseUtils.defer();
 };
 
-this.DownloadLegacySaver.prototype = {
+DownloadLegacySaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
   /**
    * Save the SHA-256 hash in raw bytes of the downloaded file. This may be
    * null when nsExternalHelperAppService (and thus BackgroundFileSaver) is not
    * invoked.
    */
   _sha256Hash: null,
@@ -2796,34 +2796,34 @@ this.DownloadLegacySaver.prototype = {
   },
 };
 
 /**
  * Returns a new DownloadLegacySaver object.  This saver type has a
  * deserializable form only when creating a new object in memory, because it
  * cannot be serialized to disk.
  */
-this.DownloadLegacySaver.fromSerializable = function() {
+DownloadLegacySaver.fromSerializable = function() {
   return new DownloadLegacySaver();
 };
 
 /**
  * This DownloadSaver type creates a PDF file from the current document in a
  * given window, specified using the windowRef property of the DownloadSource
  * object associated with the download.
  *
  * In order to prevent the download from saving a different document than the one
  * originally loaded in the window, any attempt to restart the download will fail.
  *
  * Since this DownloadSaver type requires a live document as a source, it cannot
  * be persisted across sessions, unless the download already succeeded.
  */
 var DownloadPDFSaver = function() {};
 
-this.DownloadPDFSaver.prototype = {
+DownloadPDFSaver.prototype = {
   __proto__: DownloadSaver.prototype,
 
   /**
    * An nsIWebBrowserPrint instance for printing this page.
    * This is null when saving has not started or has completed,
    * or while the operation is being canceled.
    */
   _webBrowserPrint: null,
@@ -2946,11 +2946,11 @@ this.DownloadPDFSaver.prototype = {
  * Creates a new DownloadPDFSaver object, with its initial state derived from
  * its serializable representation.
  *
  * @param aSerializable
  *        Serializable representation of a DownloadPDFSaver object.
  *
  * @return The newly created DownloadPDFSaver object.
  */
-this.DownloadPDFSaver.fromSerializable = function(aSerializable) {
+DownloadPDFSaver.fromSerializable = function(aSerializable) {
   return new DownloadPDFSaver();
 };
diff --git a/toolkit/components/downloads/DownloadHistory.jsm b/toolkit/components/downloads/DownloadHistory.jsm
--- a/toolkit/components/downloads/DownloadHistory.jsm
+++ b/toolkit/components/downloads/DownloadHistory.jsm
@@ -556,17 +556,17 @@ var DownloadHistoryList = function(publi
 
   // Our history result observer is long lived for fast shared views, so free
   // the reference on shutdown to prevent leaks.
   Services.obs.addObserver(() => {
     this.result = null;
   }, "quit-application-granted");
 };
 
-this.DownloadHistoryList.prototype = {
+DownloadHistoryList.prototype = {
   __proto__: DownloadList.prototype,
 
   /**
    * This is set when executing the Places query.
    */
   get result() {
     return this._result;
   },
diff --git a/toolkit/components/downloads/DownloadIntegration.jsm b/toolkit/components/downloads/DownloadIntegration.jsm
--- a/toolkit/components/downloads/DownloadIntegration.jsm
+++ b/toolkit/components/downloads/DownloadIntegration.jsm
@@ -1168,17 +1168,17 @@ var DownloadObserver = {
  * @param aList
  *        DownloadList object linked to this observer.
  */
 var DownloadHistoryObserver = function(aList) {
   this._list = aList;
   PlacesUtils.history.addObserver(this);
 };
 
-this.DownloadHistoryObserver.prototype = {
+DownloadHistoryObserver.prototype = {
   /**
    * DownloadList object linked to this observer.
    */
   _list: null,
 
   QueryInterface: ChromeUtils.generateQI([Ci.nsINavHistoryObserver]),
 
   // nsINavHistoryObserver
@@ -1220,17 +1220,17 @@ var DownloadAutoSaveView = function(aLis
   this._downloadsMap = new Map();
   this._writer = new DeferredTask(() => this._store.save(), kSaveDelayMs);
   AsyncShutdown.profileBeforeChange.addBlocker(
     "DownloadAutoSaveView: writing data",
     () => this._writer.finalize()
   );
 };
 
-this.DownloadAutoSaveView.prototype = {
+DownloadAutoSaveView.prototype = {
   /**
    * DownloadList object linked to this view.
    */
   _list: null,
 
   /**
    * The DownloadStore object used for saving.
    */
diff --git a/toolkit/components/downloads/DownloadList.jsm b/toolkit/components/downloads/DownloadList.jsm
--- a/toolkit/components/downloads/DownloadList.jsm
+++ b/toolkit/components/downloads/DownloadList.jsm
@@ -18,17 +18,17 @@ var EXPORTED_SYMBOLS = [
  * Represents a collection of Download objects that can be viewed and managed by
  * the user interface, and persisted across sessions.
  */
 var DownloadList = function() {
   this._downloads = [];
   this._views = new Set();
 };
 
-this.DownloadList.prototype = {
+DownloadList.prototype = {
   /**
    * Array of Download objects currently in the list.
    */
   _downloads: null,
 
   /**
    * Retrieves a snapshot of the downloads that are currently in the list.  The
    * returned array does not change when downloads are added or removed, though
@@ -247,17 +247,17 @@ this.DownloadList.prototype = {
 var DownloadCombinedList = function(aPublicList, aPrivateList) {
   DownloadList.call(this);
   this._publicList = aPublicList;
   this._privateList = aPrivateList;
   aPublicList.addView(this).catch(Cu.reportError);
   aPrivateList.addView(this).catch(Cu.reportError);
 };
 
-this.DownloadCombinedList.prototype = {
+DownloadCombinedList.prototype = {
   __proto__: DownloadList.prototype,
 
   /**
    * Underlying DownloadList containing public downloads.
    */
   _publicList: null,
 
   /**
@@ -335,17 +335,17 @@ this.DownloadCombinedList.prototype = {
 /**
  * Provides an aggregated view on the contents of a DownloadList.
  */
 var DownloadSummary = function() {
   this._downloads = [];
   this._views = new Set();
 };
 
-this.DownloadSummary.prototype = {
+DownloadSummary.prototype = {
   /**
    * Array of Download objects that are currently part of the summary.
    */
   _downloads: null,
 
   /**
    * Underlying DownloadList whose contents should be summarized.
    */
diff --git a/toolkit/components/downloads/DownloadStore.jsm b/toolkit/components/downloads/DownloadStore.jsm
--- a/toolkit/components/downloads/DownloadStore.jsm
+++ b/toolkit/components/downloads/DownloadStore.jsm
@@ -58,17 +58,17 @@ XPCOMUtils.defineLazyGetter(this, "gText
  * @param aPath
  *        String containing the file path where data should be saved.
  */
 var DownloadStore = function(aList, aPath) {
   this.list = aList;
   this.path = aPath;
 };
 
-this.DownloadStore.prototype = {
+DownloadStore.prototype = {
   /**
    * DownloadList object to be populated or serialized.
    */
   list: null,
 
   /**
    * String containing the file path where data should be saved.
    */
diff --git a/toolkit/components/downloads/DownloadUIHelper.jsm b/toolkit/components/downloads/DownloadUIHelper.jsm
--- a/toolkit/components/downloads/DownloadUIHelper.jsm
+++ b/toolkit/components/downloads/DownloadUIHelper.jsm
@@ -87,17 +87,17 @@ XPCOMUtils.defineLazyGetter(DownloadUIHe
  * @param aParent
  *        The nsIDOMWindow to which prompts should be attached, or null to
  *        attach prompts to the most recently active window.
  */
 var DownloadPrompter = function(aParent) {
   this._prompter = Services.ww.getNewPrompter(aParent);
 };
 
-this.DownloadPrompter.prototype = {
+DownloadPrompter.prototype = {
   /**
    * Constants with the different type of prompts.
    */
   ON_QUIT: "prompt-on-quit",
   ON_OFFLINE: "prompt-on-offline",
   ON_LEAVE_PRIVATE_BROWSING: "prompt-on-leave-private-browsing",
 
   /**
diff --git a/toolkit/components/extensions/ExtensionPreferencesManager.jsm b/toolkit/components/extensions/ExtensionPreferencesManager.jsm
--- a/toolkit/components/extensions/ExtensionPreferencesManager.jsm
+++ b/toolkit/components/extensions/ExtensionPreferencesManager.jsm
@@ -59,27 +59,27 @@ XPCOMUtils.defineLazyGetter(this, "defau
   return new Preferences({ defaultBranch: true });
 });
 
 /* eslint-disable mozilla/balanced-listeners */
 Management.on("uninstall", async (type, { id }) => {
   // Ensure managed preferences are cleared if they were
   // not cleared at the module level.
   await Management.asyncLoadSettingsModules();
-  return this.ExtensionPreferencesManager.removeAll(id);
+  return ExtensionPreferencesManager.removeAll(id);
 });
 
 Management.on("disable", async (type, id) => {
   await Management.asyncLoadSettingsModules();
-  return this.ExtensionPreferencesManager.disableAll(id);
+  return ExtensionPreferencesManager.disableAll(id);
 });
 
 Management.on("enabling", async (type, id) => {
   await Management.asyncLoadSettingsModules();
-  return this.ExtensionPreferencesManager.enableAll(id);
+  return ExtensionPreferencesManager.enableAll(id);
 });
 /* eslint-enable mozilla/balanced-listeners */
 
 const STORE_TYPE = "prefs";
 
 // Definitions of settings, each of which correspond to a different API.
 let settingsMap = new Map();
 
@@ -202,17 +202,17 @@ async function processSetting(id, name, 
       return false;
     }
     setPrefs(name, setting, item);
     return true;
   }
   return false;
 }
 
-this.ExtensionPreferencesManager = {
+const ExtensionPreferencesManager = {
   /**
    * Adds a setting to the settingsMap. This is how an API tells the
    * preferences manager what its setting object is. The preferences
    * manager needs to know this when settings need to be removed
    * automatically.
    *
    * @param {string} name The unique id of the setting.
    * @param {Object} setting
diff --git a/toolkit/components/extensions/ExtensionStorageIDB.jsm b/toolkit/components/extensions/ExtensionStorageIDB.jsm
--- a/toolkit/components/extensions/ExtensionStorageIDB.jsm
+++ b/toolkit/components/extensions/ExtensionStorageIDB.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["ExtensionStorageIDB"];
+const EXPORTED_SYMBOLS = ["ExtensionStorageIDB"];
 
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 const { IndexedDB } = ChromeUtils.import(
   "resource://gre/modules/IndexedDB.jsm"
 );
 
@@ -555,17 +555,17 @@ async function migrateJSONFileData(exten
     histogramCategory: "success",
   });
 }
 
 /**
  * This ExtensionStorage class implements a backend for the storage.local API which
  * uses IndexedDB to store the data.
  */
-this.ExtensionStorageIDB = {
+const ExtensionStorageIDB = {
   BACKEND_ENABLED_PREF,
   IDB_MIGRATED_PREF_BRANCH,
   IDB_MIGRATE_RESULT_HISTOGRAM,
 
   // Map<extension-id, Set<Function>>
   listeners: new Map(),
 
   // Keep track if the IDB backend has been selected or not for a running extension
diff --git a/toolkit/components/extensions/ExtensionStorageSync.jsm b/toolkit/components/extensions/ExtensionStorageSync.jsm
--- a/toolkit/components/extensions/ExtensionStorageSync.jsm
+++ b/toolkit/components/extensions/ExtensionStorageSync.jsm
@@ -650,17 +650,16 @@ class CryptoCollection {
   }
 
   // Used only for testing.
   async _clear() {
     const collection = await this.getCollection();
     await collection.clear();
   }
 }
-this.CryptoCollection = CryptoCollection;
 
 /**
  * An EncryptionRemoteTransformer for extension records.
  *
  * It uses the special "keys" record to find a key for a given
  * extension, thus its name
  * CollectionKeyEncryptionRemoteTransformer.
  *
@@ -1401,13 +1400,12 @@ class ExtensionStorageSync {
     let listeners = this.listeners.get(extension) || new Set();
     if (listeners) {
       for (let listener of listeners) {
         ExtensionCommon.runSafeSyncWithoutClone(listener, changes);
       }
     }
   }
 }
-this.ExtensionStorageSync = ExtensionStorageSync;
 extensionStorageSync = new ExtensionStorageSync(
   _fxaService,
   Services.telemetry
 );
diff --git a/toolkit/components/extensions/ExtensionUtils.jsm b/toolkit/components/extensions/ExtensionUtils.jsm
--- a/toolkit/components/extensions/ExtensionUtils.jsm
+++ b/toolkit/components/extensions/ExtensionUtils.jsm
@@ -30,17 +30,17 @@ XPCOMUtils.defineLazyGetter(this, "idleT
 const appinfo = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime);
 
 let nextId = 0;
 const uniqueProcessID = appinfo.uniqueProcessID;
 // Store the process ID in a 16 bit field left shifted to end of a
 // double's mantissa.
 // Note: We can't use bitwise ops here, since they truncate to a 32 bit
 // integer and we need all 53 mantissa bits.
-const processIDMask = (uniqueProcessID & 0xffff) * 2 ** 37;
+const processIDMask = (uniqueProcessID & 0xffff) * (2 ** 37);
 
 function getUniqueId() {
   // Note: We can't use bitwise ops here, since they truncate to a 32 bit
   // integer and we need all 53 mantissa bits.
   return processIDMask + nextId++;
 }
 
 function promiseTimeout(delay) {
diff --git a/toolkit/components/extensions/MessageChannel.jsm b/toolkit/components/extensions/MessageChannel.jsm
--- a/toolkit/components/extensions/MessageChannel.jsm
+++ b/toolkit/components/extensions/MessageChannel.jsm
@@ -137,18 +137,18 @@ const MESSAGE_RESPONSE = "MessageChannel
 // ESLint can't tell that these are referenced, so tell it that they're
 // exported to make it happy.
 /* exported _deferredResult, _makeDeferred */
 var _deferredResult;
 var _makeDeferred = (resolve, reject) => {
   // We use arrow functions here and refer to the outer variables via
   // `this`, to avoid a lexical name lookup. Yes, it makes a difference.
   // No, I don't like it any more than you do.
-  this._deferredResult.resolve = resolve;
-  this._deferredResult.reject = reject;
+  _deferredResult.resolve = resolve;
+  _deferredResult.reject = reject;
 };
 
 /**
  * Helper to create a new Promise without allocating any closures to
  * receive its resolution functions.
  *
  * I know what you're thinking: "This is crazy. There is no possible way
  * this can be necessary. Just use the ordinary Promise constructor the
@@ -163,19 +163,19 @@ var _makeDeferred = (resolve, reject) =>
  * ourselves for it.
  *
  * (See also bug 1404950.)
  *
  * @returns {object}
  */
 let Deferred = () => {
   let res = {};
-  this._deferredResult = res;
-  res.promise = new Promise(this._makeDeferred);
-  this._deferredResult = null;
+  _deferredResult = res;
+  res.promise = new Promise(_makeDeferred);
+  _deferredResult = null;
   return res;
 };
 
 /**
  * Handles the mapping and dispatching of messages to their registered
  * handlers. There is one broker per message manager and class of
  * messages. Each class of messages is mapped to one native message
  * name, e.g., "MessageChannel:Message", and is dispatched to handlers
@@ -565,17 +565,17 @@ class PendingMessage {
       this.broker.addHandler(this.channelId, this);
       msg = this.message;
       this.message = null;
     }
     return msg;
   }
 }
 
-this.MessageChannel = {
+const MessageChannel = {
   init() {
     Services.obs.addObserver(this, "message-manager-close");
     Services.obs.addObserver(this, "message-manager-disconnect");
 
     this.messageManagers = new FilteringMessageManagerMap(
       MESSAGE_MESSAGES,
       this._handleMessage.bind(this)
     );
diff --git a/toolkit/components/extensions/ProfilerGetSymbols.jsm b/toolkit/components/extensions/ProfilerGetSymbols.jsm
--- a/toolkit/components/extensions/ProfilerGetSymbols.jsm
+++ b/toolkit/components/extensions/ProfilerGetSymbols.jsm
@@ -73,17 +73,17 @@ function getWASMProfilerGetSymbolsModule
   gCachedWASMModuleExpiryTimer = setTimeout(
     clearCachedWASMModule,
     EXPIRY_TIME_IN_MS
   );
 
   return gCachedWASMModulePromise;
 }
 
-this.ProfilerGetSymbols = {
+const ProfilerGetSymbols = {
   /**
    * Obtain symbols for the binary at the specified location.
    *
    * @param {string} binaryPath The absolute path to the binary on the local
    *   file system.
    * @param {string} debugPath The absolute path to the binary's pdb file on the
    *   local file system if on Windows, otherwise the same as binaryPath.
    * @param {string} breakpadId The breakpadId for the binary whose symbols
diff --git a/toolkit/components/extensions/Schemas.jsm b/toolkit/components/extensions/Schemas.jsm
--- a/toolkit/components/extensions/Schemas.jsm
+++ b/toolkit/components/extensions/Schemas.jsm
@@ -3412,17 +3412,17 @@ class SchemaRoot extends Namespace {
     let result = type.normalize(obj, new Context(context));
     if (result.error) {
       return { error: forceString(result.error) };
     }
     return result;
   }
 }
 
-this.Schemas = {
+const Schemas = {
   initialized: false,
 
   REVOKE: Symbol("@@revoke"),
 
   // Maps a schema URL to the JSON contained in that schema file. This
   // is useful for sending the JSON across processes.
   schemaJSON: new Map(),
 
diff --git a/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm b/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm
--- a/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm
+++ b/toolkit/components/passwordmgr/InsecurePasswordUtils.jsm
@@ -35,17 +35,17 @@ ChromeUtils.defineModuleGetter(
 XPCOMUtils.defineLazyGetter(this, "log", () => {
   return LoginHelper.createLogger("InsecurePasswordUtils");
 });
 
 /*
  * A module that provides utility functions for form security.
  *
  */
-this.InsecurePasswordUtils = {
+const InsecurePasswordUtils = {
   _formRootsWarned: new WeakMap(),
 
   /**
    * Gets the ID of the inner window of this DOM window.
    *
    * @param nsIDOMWindow window
    * @return integer
    *         Inner ID for the given window.
@@ -230,13 +230,13 @@ this.InsecurePasswordUtils = {
 
     Services.telemetry
       .getHistogramById("PWMGR_LOGIN_PAGE_SAFETY")
       .add(passwordSafety);
   },
 };
 
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.InsecurePasswordUtils,
+  InsecurePasswordUtils,
   "_ignoreLocalIPAddress",
   "security.insecure_field_warning.ignore_local_ip_address",
   true
 );
diff --git a/toolkit/components/passwordmgr/LoginFormFactory.jsm b/toolkit/components/passwordmgr/LoginFormFactory.jsm
--- a/toolkit/components/passwordmgr/LoginFormFactory.jsm
+++ b/toolkit/components/passwordmgr/LoginFormFactory.jsm
@@ -25,17 +25,17 @@ ChromeUtils.defineModuleGetter(
   "LoginHelper",
   "resource://gre/modules/LoginHelper.jsm"
 );
 
 XPCOMUtils.defineLazyGetter(this, "log", () => {
   return LoginHelper.createLogger("LoginFormFactory");
 });
 
-this.LoginFormFactory = {
+const LoginFormFactory = {
   /**
    * WeakMap of the root element of a LoginForm to the LoginForm representing its fields.
    *
    * This is used to be able to lookup an existing LoginForm for a given root element since multiple
    * calls to LoginFormFactory.createFrom* won't give the exact same object. When batching fills we don't always
    * want to use the most recent list of elements for a LoginForm since we may end up doing multiple
    * fills for the same set of elements when a field gets added between arming and running the
    * DeferredTask.
diff --git a/toolkit/components/passwordmgr/LoginHelper.jsm b/toolkit/components/passwordmgr/LoginHelper.jsm
--- a/toolkit/components/passwordmgr/LoginHelper.jsm
+++ b/toolkit/components/passwordmgr/LoginHelper.jsm
@@ -19,17 +19,17 @@ const EXPORTED_SYMBOLS = ["LoginHelper"]
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 
 /**
  * Contains functions shared by different Login Manager components.
  */
-this.LoginHelper = {
+const LoginHelper = {
   debug: null,
   enabled: null,
   storageEnabled: null,
   formlessCaptureEnabled: null,
   generationAvailable: null,
   generationEnabled: null,
   includeOtherSubdomainsInLookup: null,
   insecureAutofill: null,
diff --git a/toolkit/components/passwordmgr/LoginImport.jsm b/toolkit/components/passwordmgr/LoginImport.jsm
--- a/toolkit/components/passwordmgr/LoginImport.jsm
+++ b/toolkit/components/passwordmgr/LoginImport.jsm
@@ -33,22 +33,22 @@ ChromeUtils.defineModuleGetter(
  * Provides an object that has a method to import login-related data from the
  * previous SQLite storage format.
  *
  * @param aStore
  *        LoginStore object where imported data will be added.
  * @param aPath
  *        String containing the file path of the SQLite login database.
  */
-this.LoginImport = function(aStore, aPath) {
+const LoginImport = function(aStore, aPath) {
   this.store = aStore;
   this.path = aPath;
 };
 
-this.LoginImport.prototype = {
+LoginImport.prototype = {
   /**
    * LoginStore object where imported data will be added.
    */
   store: null,
 
   /**
    * String containing the file path of the SQLite login database.
    */
diff --git a/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm b/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm
--- a/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm
+++ b/toolkit/components/passwordmgr/LoginManagerAuthPrompter.jsm
@@ -264,17 +264,17 @@ LoginManagerAuthPromptFactory.prototype 
           /* Just ignore exceptions from the callback */
         }
       }
     }
   },
 }; // end of LoginManagerAuthPromptFactory implementation
 
 XPCOMUtils.defineLazyGetter(
-  this.LoginManagerAuthPromptFactory.prototype,
+  LoginManagerAuthPromptFactory.prototype,
   "log",
   () => {
     let logger = LoginHelper.createLogger("LoginManagerAuthPromptFactory");
     return logger.log.bind(logger);
   }
 );
 
 /* ==================== LoginManagerAuthPrompter ==================== */
@@ -1377,17 +1377,17 @@ LoginManagerAuthPrompter.prototype = {
         this.callback = null;
         this.context = null;
       },
     };
   },
 }; // end of LoginManagerAuthPrompter implementation
 
 XPCOMUtils.defineLazyGetter(
-  this.LoginManagerAuthPrompter.prototype,
+  LoginManagerAuthPrompter.prototype,
   "log",
   () => {
     let logger = LoginHelper.createLogger("LoginManagerAuthPrompter");
     return logger.log.bind(logger);
   }
 );
 
 const EXPORTED_SYMBOLS = [
diff --git a/toolkit/components/passwordmgr/LoginManagerChild.jsm b/toolkit/components/passwordmgr/LoginManagerChild.jsm
--- a/toolkit/components/passwordmgr/LoginManagerChild.jsm
+++ b/toolkit/components/passwordmgr/LoginManagerChild.jsm
@@ -379,17 +379,17 @@ let gAutoCompleteListener = {
     let hostname = eventTarget.ownerDocument.documentURIObject.host;
     loginManager.sendAsyncMessage("PasswordManager:OpenPreferences", {
       hostname,
       entryPoint: "autocomplete",
     });
   },
 };
 
-this.LoginManagerChild = class LoginManagerChild extends JSWindowActorChild {
+class LoginManagerChild extends JSWindowActorChild {
   constructor() {
     super();
 
     /**
      * WeakMap of the root element of a LoginForm to the DeferredTask to fill its fields.
      *
      * This is used to be able to throttle fills for a LoginForm since onDOMInputPasswordAdded gets
      * dispatched for each password field added to a document but we only want to fill once per
diff --git a/toolkit/components/passwordmgr/LoginManagerContextMenu.jsm b/toolkit/components/passwordmgr/LoginManagerContextMenu.jsm
--- a/toolkit/components/passwordmgr/LoginManagerContextMenu.jsm
+++ b/toolkit/components/passwordmgr/LoginManagerContextMenu.jsm
@@ -23,17 +23,17 @@ ChromeUtils.defineModuleGetter(
 );
 XPCOMUtils.defineLazyGetter(this, "log", () => {
   return LoginHelper.createLogger("LoginManagerContextMenu");
 });
 
 /**
  * Password manager object for the browser contextual menu.
  */
-this.LoginManagerContextMenu = {
+const LoginManagerContextMenu = {
   /**
    * Look for login items and add them to the contextual menu.
    *
    * @param {Object} inputElementIdentifier
    *        An identifier generated for the input element via ContentDOMReference.
    * @param {xul:browser} browser
    *        The browser for the document the context menu was open on.
    * @param {string} formOrigin
diff --git a/toolkit/components/passwordmgr/LoginRecipes.jsm b/toolkit/components/passwordmgr/LoginRecipes.jsm
--- a/toolkit/components/passwordmgr/LoginRecipes.jsm
+++ b/toolkit/components/passwordmgr/LoginRecipes.jsm
@@ -210,17 +210,17 @@ LoginRecipesParent.prototype = {
     if (!hostRecipes) {
       return new Set();
     }
 
     return hostRecipes;
   },
 };
 
-this.LoginRecipesContent = {
+const LoginRecipesContent = {
   _recipeCache: new WeakMap(),
 
   _clearRecipeCache() {
     this._recipeCache = new WeakMap();
   },
 
   /**
    * Locally caches recipes for a given host.
diff --git a/toolkit/components/passwordmgr/OSCrypto.jsm b/toolkit/components/passwordmgr/OSCrypto.jsm
--- a/toolkit/components/passwordmgr/OSCrypto.jsm
+++ b/toolkit/components/passwordmgr/OSCrypto.jsm
@@ -10,17 +10,17 @@
 
 const { AppConstants } = ChromeUtils.import(
   "resource://gre/modules/AppConstants.jsm"
 );
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 const EXPORTED_SYMBOLS = ["OSCrypto"];
 
-this.OSCrypto = {};
+const OSCrypto = {};
 
 if (AppConstants.platform == "win") {
   Services.scriptloader.loadSubScript(
     "resource://gre/modules/OSCrypto_win.js",
     this
   );
 } else {
   throw new Error("OSCrypto.jsm isn't supported on this platform");
diff --git a/toolkit/components/passwordmgr/PasswordGenerator.jsm b/toolkit/components/passwordmgr/PasswordGenerator.jsm
--- a/toolkit/components/passwordmgr/PasswordGenerator.jsm
+++ b/toolkit/components/passwordmgr/PasswordGenerator.jsm
@@ -25,17 +25,17 @@ const MAX_UINT32 = Math.pow(2, 32) - 1;
 // Some characters are removed due to visual similarity:
 const LOWER_CASE_ALPHA = "abcdefghijkmnpqrstuvwxyz"; // no 'l' or 'o'
 const UPPER_CASE_ALPHA = "ABCDEFGHJKLMNPQRSTUVWXYZ"; // no 'I' or 'O'
 const DIGITS = "23456789"; // no '1' or '0'
 const ALL_CHARACTERS = LOWER_CASE_ALPHA + UPPER_CASE_ALPHA + DIGITS;
 
 const REQUIRED_CHARACTER_CLASSES = [LOWER_CASE_ALPHA, UPPER_CASE_ALPHA, DIGITS];
 
-this.PasswordGenerator = {
+const PasswordGenerator = {
   /**
    * @param {Number} length of the password to generate
    * @returns {string} password that was generated
    * @throws Error if `length` is invalid
    * @copyright 2018 The Chromium Authors. All rights reserved.
    * @see https://cs.chromium.org/chromium/src/components/password_manager/core/browser/generation/password_generator.cc?l=93&rcl=a896a3ac4ea731b5ab3d2ab5bd76a139885d5c4f
    */
   generatePassword(length = DEFAULT_PASSWORD_LENGTH) {
diff --git a/toolkit/components/passwordmgr/test/LoginTestUtils.jsm b/toolkit/components/passwordmgr/test/LoginTestUtils.jsm
--- a/toolkit/components/passwordmgr/test/LoginTestUtils.jsm
+++ b/toolkit/components/passwordmgr/test/LoginTestUtils.jsm
@@ -21,17 +21,17 @@ const { TestUtils } = ChromeUtils.import
 );
 
 const LoginInfo = Components.Constructor(
   "@mozilla.org/login-manager/loginInfo;1",
   "nsILoginInfo",
   "init"
 );
 
-this.LoginTestUtils = {
+const LoginTestUtils = {
   setAssertReporter(reporterFunc) {
     Assert = new AssertCls(Cu.waiveXrays(reporterFunc));
   },
 
   /**
    * Forces the storage module to save all data, and the Login Manager service
    * to replace the storage module with a newly initialized instance.
    */
@@ -121,17 +121,17 @@ this.LoginTestUtils = {
 /**
  * This object contains functions that return new instances of nsILoginInfo for
  * every call.  The returned instances can be compared using their "equals" or
  * "matches" methods, or modified for the needs of the specific test being run.
  *
  * Any modification to the test data requires updating the tests accordingly, in
  * particular the search tests.
  */
-this.LoginTestUtils.testData = {
+LoginTestUtils.testData = {
   /**
    * Returns a new nsILoginInfo for use with form submits.
    *
    * @param modifications
    *        Each property of this object replaces the property of the same name
    *        in the returned nsILoginInfo or nsILoginMetaInfo.
    */
   formLogin(modifications) {
@@ -450,31 +450,31 @@ this.LoginTestUtils.testData = {
         null,
         "javascript: username",
         "javascript: password"
       ),
     ];
   },
 };
 
-this.LoginTestUtils.recipes = {
+LoginTestUtils.recipes = {
   getRecipeParent() {
     let { LoginManagerParent } = ChromeUtils.import(
       "resource://gre/modules/LoginManagerParent.jsm"
     );
     if (!LoginManagerParent.recipeParentPromise) {
       return null;
     }
     return LoginManagerParent.recipeParentPromise.then(recipeParent => {
       return recipeParent;
     });
   },
 };
 
-this.LoginTestUtils.masterPassword = {
+LoginTestUtils.masterPassword = {
   masterPassword: "omgsecret!",
 
   _set(enable) {
     let oldPW, newPW;
     if (enable) {
       oldPW = "";
       newPW = this.masterPassword;
     } else {
@@ -507,17 +507,17 @@ this.LoginTestUtils.masterPassword = {
   disable() {
     this._set(false);
   },
 };
 
 /**
  * Utilities related to interacting with login fields in content.
  */
-this.LoginTestUtils.loginField = {
+LoginTestUtils.loginField = {
   checkPasswordMasked(field, expected, msg) {
     let { editor } = field;
     let valueLength = field.value.length;
     Assert.equal(
       editor.autoMaskingEnabled,
       expected,
       `Check autoMaskingEnabled: ${msg}`
     );
@@ -529,22 +529,22 @@ this.LoginTestUtils.loginField = {
         editor.unmaskedEnd,
         valueLength,
         `Unmasked to the end: ${msg}`
       );
     }
   },
 };
 
-this.LoginTestUtils.generation = {
+LoginTestUtils.generation = {
   LENGTH: 15,
   REGEX: /^[a-km-np-zA-HJ-NP-Z2-9]{15}$/,
 };
 
-this.LoginTestUtils.telemetry = {
+LoginTestUtils.telemetry = {
   async waitForEventCount(count, process = "content", category = "pwmgr") {
     let events = await TestUtils.waitForCondition(() => {
       let events = Services.telemetry.snapshotEvents(
         Ci.nsITelemetry.DATASET_PRERELEASE_CHANNELS,
         false
       )[process];
 
       if (!events) {
diff --git a/toolkit/components/pictureinpicture/PictureInPictureTogglePolicy.jsm b/toolkit/components/pictureinpicture/PictureInPictureTogglePolicy.jsm
--- a/toolkit/components/pictureinpicture/PictureInPictureTogglePolicy.jsm
+++ b/toolkit/components/pictureinpicture/PictureInPictureTogglePolicy.jsm
@@ -4,28 +4,28 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 var EXPORTED_SYMBOLS = ["TOGGLE_POLICIES", "TOGGLE_POLICY_STRINGS"];
 
 // These are the possible toggle positions along the right side of
 // a qualified video element.
-this.TOGGLE_POLICIES = {
+const TOGGLE_POLICIES = {
   DEFAULT: 1,
   HIDDEN: 2,
   TOP: 3,
   ONE_QUARTER: 4,
   THREE_QUARTERS: 5,
   BOTTOM: 6,
 };
 
 // These strings are used in the videocontrols.css stylesheet as
 // toggle policy attribute values for setting rules on the position
 // of the toggle.
-this.TOGGLE_POLICY_STRINGS = {
+const TOGGLE_POLICY_STRINGS = {
   [TOGGLE_POLICIES.DEFAULT]: "default",
   [TOGGLE_POLICIES.HIDDEN]: "hidden",
   [TOGGLE_POLICIES.TOP]: "top",
   [TOGGLE_POLICIES.ONE_QUARTER]: "one-quarter",
   [TOGGLE_POLICIES.THREE_QUARTERS]: "three-quarters",
   [TOGGLE_POLICIES.BOTTOM]: "bottom",
 };
diff --git a/toolkit/components/places/SyncedBookmarksMirror.jsm b/toolkit/components/places/SyncedBookmarksMirror.jsm
--- a/toolkit/components/places/SyncedBookmarksMirror.jsm
+++ b/toolkit/components/places/SyncedBookmarksMirror.jsm
@@ -1385,18 +1385,16 @@ class SyncedBookmarksMirror {
         await this.db.execute(`DETACH mirror`);
         this.finalizeAt.removeBlocker(this.finalizeBound);
       })();
     }
     return this.finalizePromise;
   }
 }
 
-this.SyncedBookmarksMirror = SyncedBookmarksMirror;
-
 /** Key names for the key-value `meta` table. */
 SyncedBookmarksMirror.META_KEY = {
   LAST_MODIFIED: "collection/lastModified",
   SYNC_ID: "collection/syncId",
 };
 
 /**
  * An error thrown when the merge was interrupted.
diff --git a/toolkit/components/promiseworker/PromiseWorker.jsm b/toolkit/components/promiseworker/PromiseWorker.jsm
--- a/toolkit/components/promiseworker/PromiseWorker.jsm
+++ b/toolkit/components/promiseworker/PromiseWorker.jsm
@@ -164,17 +164,17 @@ var BasePromiseWorker = function(url) {
    */
   this.launchTimeStamp = null;
 
   /**
    * Timestamps provided by the worker for statistics purposes.
    */
   this.workerTimeStamps = null;
 };
-this.BasePromiseWorker.prototype = {
+BasePromiseWorker.prototype = {
   log() {
     // By Default, ignore all logs.
   },
 
   /**
    * Instantiate the worker lazily.
    */
   get _worker() {
@@ -435,12 +435,12 @@ function WorkerError(data) {
  * @param {object=} data The data to send to the caller thread.
  * @param {object=} meta Additional instructions, as an object
  * that may contain the following fields:
  * - {Array} transfers An array of objects that should be transferred
  *   instead of being copied.
  *
  * @constructor
  */
-this.BasePromiseWorker.Meta = function(data, meta) {
+BasePromiseWorker.Meta = function(data, meta) {
   this.data = data;
   this.meta = meta;
 };
diff --git a/toolkit/components/prompts/src/SharedPromptUtils.jsm b/toolkit/components/prompts/src/SharedPromptUtils.jsm
--- a/toolkit/components/prompts/src/SharedPromptUtils.jsm
+++ b/toolkit/components/prompts/src/SharedPromptUtils.jsm
@@ -74,17 +74,17 @@ var EnableDelayHelper = function({ enabl
   // While the user key-repeats, we want to renew the timer until keyup:
   this.focusTarget.addEventListener("keyup", this, true);
   this.focusTarget.addEventListener("keydown", this, true);
   this.focusTarget.document.addEventListener("unload", this);
 
   this.startOnFocusDelay();
 };
 
-this.EnableDelayHelper.prototype = {
+EnableDelayHelper.prototype = {
   get delayTime() {
     return Services.prefs.getIntPref("security.dialog_enable_delay");
   },
 
   handleEvent(event) {
     if (
       !event.type.startsWith("key") &&
       event.target != this.focusTarget &&
diff --git a/toolkit/components/reflect/reflect.jsm b/toolkit/components/reflect/reflect.jsm
--- a/toolkit/components/reflect/reflect.jsm
+++ b/toolkit/components/reflect/reflect.jsm
@@ -15,9 +15,9 @@ var EXPORTED_SYMBOLS = ["Reflect"];
  * For documentation on the API, see:
  * https://developer.mozilla.org/en/SpiderMonkey/Parser_API
  *
  */
 
 // Initialize the ctypes object. You do not need to do this yourself.
 const init = Cc["@mozilla.org/jsreflect;1"].createInstance();
 init();
-this.Reflect = Reflect;
+const Reflect = Reflect;
diff --git a/toolkit/components/satchel/FormHistory.jsm b/toolkit/components/satchel/FormHistory.jsm
--- a/toolkit/components/satchel/FormHistory.jsm
+++ b/toolkit/components/satchel/FormHistory.jsm
@@ -894,17 +894,17 @@ var DB = {
       }
     }
 
     log("Verified that expected columns are present in DB.");
     return true;
   },
 };
 
-this.FormHistory = {
+const FormHistory = {
   get db() {
     return DB.conn;
   },
 
   get enabled() {
     return Prefs.enabled;
   },
 
diff --git a/toolkit/components/search/SearchSuggestionController.jsm b/toolkit/components/search/SearchSuggestionController.jsm
--- a/toolkit/components/search/SearchSuggestionController.jsm
+++ b/toolkit/components/search/SearchSuggestionController.jsm
@@ -59,17 +59,17 @@ var gFirstPartyDomains = new Map();
  * @param {function} [callback] - Callback for search suggestion results. You can use the promise
  *                                returned by the search method instead if you prefer.
  * @constructor
  */
 function SearchSuggestionController(callback = null) {
   this._callback = callback;
 }
 
-this.SearchSuggestionController.prototype = {
+SearchSuggestionController.prototype = {
   /**
    * The maximum number of local form history results to return. This limit is
    * only enforced if remote results are also returned.
    */
   maxLocalResults: 5,
 
   /**
    * The maximum number of remote search engine results to return.
@@ -495,41 +495,41 @@ this.SearchSuggestionController.prototyp
 };
 
 /**
  * Determines whether the given engine offers search suggestions.
  *
  * @param {nsISearchEngine} engine - The search engine
  * @returns {boolean} True if the engine offers suggestions and false otherwise.
  */
-this.SearchSuggestionController.engineOffersSuggestions = function(engine) {
+SearchSuggestionController.engineOffersSuggestions = function(engine) {
   return engine.supportsResponseType(SEARCH_RESPONSE_SUGGESTION_JSON);
 };
 
 /**
  * The maximum time (ms) to wait before giving up on a remote suggestions.
  */
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.SearchSuggestionController.prototype,
+  SearchSuggestionController.prototype,
   "remoteTimeout",
   REMOTE_TIMEOUT_PREF,
   REMOTE_TIMEOUT_DEFAULT
 );
 
 /**
  * Whether or not remote suggestions are turned on.
  */
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.SearchSuggestionController.prototype,
+  SearchSuggestionController.prototype,
   "suggestionsEnabled",
   BROWSER_SUGGEST_PREF,
   true
 );
 
 /**
  * Whether or not remote suggestions are turned on in private browsing mode.
  */
 XPCOMUtils.defineLazyPreferenceGetter(
-  this.SearchSuggestionController.prototype,
+  SearchSuggestionController.prototype,
   "suggestionsInPrivateBrowsingEnabled",
   BROWSER_SUGGEST_PRIVATE_PREF,
   false
 );
diff --git a/toolkit/components/url-classifier/UrlClassifierLib.jsm b/toolkit/components/url-classifier/UrlClassifierLib.jsm
--- a/toolkit/components/url-classifier/UrlClassifierLib.jsm
+++ b/toolkit/components/url-classifier/UrlClassifierLib.jsm
@@ -25,17 +25,17 @@ const PREF_DISABLE_TEST_BACKOFF =
  * @param fn {string} Reference to the function to be bound
  *
  * @param self {object} Specifies the object which |this| should point to
  * when the function is run. If the value is null or undefined, it will default
  * to the global object.
  *
  * @returns {function} A partially-applied form of the speficied function.
  */
-this.BindToObject = function BindToObject(fn, self, opt_args) {
+function BindToObject(fn, self, opt_args) {
   var boundargs = fn.boundArgs_ || [];
   boundargs = boundargs.concat(
     Array.prototype.slice.call(arguments, 2, arguments.length)
   );
 
   if (fn.boundSelf_) {
     self = fn.boundSelf_;
   }
@@ -61,32 +61,32 @@ this.BindToObject = function BindToObjec
 // back off for TIMEOUT_INCREMENT minutes.  If we get another error
 // immediately after we restart, we double the timeout and add
 // TIMEOUT_INCREMENT minutes, etc.
 //
 // This is similar to the logic used by the search suggestion service.
 
 // HTTP responses that count as an error.  We also include any 5xx response
 // as an error.
-this.HTTP_FOUND = 302;
-this.HTTP_SEE_OTHER = 303;
-this.HTTP_TEMPORARY_REDIRECT = 307;
+const HTTP_FOUND = 302;
+const HTTP_SEE_OTHER = 303;
+const HTTP_TEMPORARY_REDIRECT = 307;
 
 /**
  * @param maxErrors Number of times to request before backing off.
  * @param retryIncrement Time (ms) for each retry before backing off.
  * @param maxRequests Number the number of requests needed to trigger backoff
  * @param requestPeriod Number time (ms) in which maxRequests have to occur to
  *     trigger the backoff behavior (0 to disable maxRequests)
  * @param timeoutIncrement Number time (ms) the starting timeout period
  *     we double this time for consecutive errors
  * @param maxTimeout Number time (ms) maximum timeout period
  * @param tolerance Checking next request tolerance.
  */
-this.RequestBackoff = function RequestBackoff(
+function RequestBackoff(
   maxErrors,
   retryIncrement,
   maxRequests,
   requestPeriod,
   timeoutIncrement,
   maxTimeout,
   tolerance,
   provider = null
diff --git a/toolkit/components/url-classifier/UrlClassifierListManager.jsm b/toolkit/components/url-classifier/UrlClassifierListManager.jsm
--- a/toolkit/components/url-classifier/UrlClassifierListManager.jsm
+++ b/toolkit/components/url-classifier/UrlClassifierListManager.jsm
@@ -23,17 +23,17 @@ const maxDelayMs = 24 * 60 * 60 * 1000;
 const defaultUpdateIntervalMs = 30 * 60 * 1000;
 const PREF_DEBUG_ENABLED = "browser.safebrowsing.debug";
 const PREF_TEST_NOTIFICATIONS =
   "browser.safebrowsing.test-notifications.enabled";
 
 let loggingEnabled = false;
 
 // Log only if browser.safebrowsing.debug is true
-this.log = function log(...stuff) {
+function log(...stuff) {
   if (!loggingEnabled) {
     return;
   }
 
   var d = new Date();
   let msg = "listmanager: " + d.toTimeString() + ": " + stuff.join(" ");
   msg = Services.urlFormatter.trimSensitiveURLs(msg);
   Services.console.logStringMessage(msg);
@@ -41,17 +41,17 @@ this.log = function log(...stuff) {
 };
 
 /**
  * A ListManager keeps track of black and white lists and knows
  * how to update them.
  *
  * @constructor
  */
-this.PROT_ListManager = function PROT_ListManager() {
+function PROT_ListManager() {
   loggingEnabled = Services.prefs.getBoolPref(PREF_DEBUG_ENABLED);
 
   log("Initializing list manager");
   this.updateInterval = defaultUpdateIntervalMs;
 
   // A map of tableNames to objects of type
   // { updateUrl: <updateUrl>, gethashUrl: <gethashUrl> }
   this.tablesData = {};
diff --git a/toolkit/crashreporter/CrashReports.jsm b/toolkit/crashreporter/CrashReports.jsm
--- a/toolkit/crashreporter/CrashReports.jsm
+++ b/toolkit/crashreporter/CrashReports.jsm
@@ -74,11 +74,11 @@ function CrashReports_reportsDir() {
 
 function CrashReports_submittedDir() {
   let submittedDir = Services.dirsvc.get("UAppData", Ci.nsIFile);
   submittedDir.append("Crash Reports");
   submittedDir.append("submitted");
   return submittedDir;
 }
 
-this.CrashReports.pendingDir = CrashReports_pendingDir();
-this.CrashReports.reportsDir = CrashReports_reportsDir();
-this.CrashReports.submittedDir = CrashReports_submittedDir();
+CrashReports.pendingDir = CrashReports_pendingDir();
+CrashReports.reportsDir = CrashReports_reportsDir();
+CrashReports.submittedDir = CrashReports_submittedDir();
diff --git a/toolkit/modules/ActorChild.jsm b/toolkit/modules/ActorChild.jsm
--- a/toolkit/modules/ActorChild.jsm
+++ b/toolkit/modules/ActorChild.jsm
@@ -11,17 +11,17 @@ var EXPORTED_SYMBOLS = ["ActorChild"];
  * ActorManagerParent and implemented in the child process. It currently takes
  * care of setting the `mm`, `content`, and `docShell` properties based on the
  * message manager it's bound to, but may do more in the future.
  *
  * If Fission is being simulated, and the actor is registered as "allFrames",
  * the `content` property of this class will be bound to a specific subframe.
  * Otherwise, the `content` is always the top-level content tied to the `mm`.
  */
-this.ActorChild = class ActorChild {
+class ActorChild {
   constructor(dispatcher) {
     this._dispatcher = dispatcher;
     this.mm = dispatcher.mm;
   }
 
   get content() {
     return this._dispatcher.window;
   }
diff --git a/toolkit/modules/DeferredTask.jsm b/toolkit/modules/DeferredTask.jsm
--- a/toolkit/modules/DeferredTask.jsm
+++ b/toolkit/modules/DeferredTask.jsm
@@ -115,17 +115,17 @@ const Timer = Components.Constructor(
  *        callback.
  */
 var DeferredTask = function(aTaskFn, aDelayMs, aIdleTimeoutMs) {
   this._taskFn = aTaskFn;
   this._delayMs = aDelayMs;
   this._timeoutMs = aIdleTimeoutMs;
 };
 
-this.DeferredTask.prototype = {
+DeferredTask.prototype = {
   /**
    * Function to execute.
    */
   _taskFn: null,
 
   /**
    * Time between executions, in milliseconds.
    */
diff --git a/toolkit/modules/EventEmitter.jsm b/toolkit/modules/EventEmitter.jsm
--- a/toolkit/modules/EventEmitter.jsm
+++ b/toolkit/modules/EventEmitter.jsm
@@ -9,17 +9,17 @@ const { Services } = ChromeUtils.import(
 ChromeUtils.defineModuleGetter(
   this,
   "console",
   "resource://gre/modules/Console.jsm"
 );
 
 var EXPORTED_SYMBOLS = ["EventEmitter"];
 
-let EventEmitter = (this.EventEmitter = function() {});
+let EventEmitter = (function() {});;
 
 let loggingEnabled = Services.prefs.getBoolPref("toolkit.dump.emit");
 Services.prefs.addObserver("toolkit.dump.emit", {
   observe: () => {
     loggingEnabled = Services.prefs.getBoolPref("toolkit.dump.emit");
   },
 });
 
diff --git a/toolkit/modules/FirstStartup.jsm b/toolkit/modules/FirstStartup.jsm
--- a/toolkit/modules/FirstStartup.jsm
+++ b/toolkit/modules/FirstStartup.jsm
@@ -30,17 +30,17 @@ const PROBE_NAME = "firstStartup";
  */
 var FirstStartup = {
   NOT_STARTED: 0,
   IN_PROGRESS: 1,
   TIMED_OUT: 2,
   SUCCESS: 3,
   UNSUPPORTED: 4,
 
-  _state: this.NOT_STARTED,
+  _state: NOT_STARTED,
   /**
    * Initialize and run first-startup services. This will always run synchronously
    * and spin the event loop until either all required services have
    * completed, or until a timeout is reached.
    *
    * In the latter case, services are expected to run post-UI instead as usual.
    */
   init() {
diff --git a/toolkit/modules/Integration.jsm b/toolkit/modules/Integration.jsm
--- a/toolkit/modules/Integration.jsm
+++ b/toolkit/modules/Integration.jsm
@@ -152,17 +152,17 @@ var IntegrationPoint = function() {
         Cr.NS_ERROR_NO_INTERFACE
       );
       Cu.reportError(ex);
       throw ex;
     },
   };
 };
 
-this.IntegrationPoint.prototype = {
+IntegrationPoint.prototype = {
   /**
    * Ordered set of registered functions defining integration overrides.
    */
   _overrideFns: null,
 
   /**
    * Combined integration object. When this reference changes, properties
    * defined directly on this object are copied to the new object.
diff --git a/toolkit/modules/WebChannel.jsm b/toolkit/modules/WebChannel.jsm
--- a/toolkit/modules/WebChannel.jsm
+++ b/toolkit/modules/WebChannel.jsm
@@ -120,17 +120,17 @@ var WebChannel = function(id, originOrPe
     // such as containers or private browsing.
     this._originCheckCallback = requestPrincipal => {
       return originOrPermission.prePath === requestPrincipal.originNoSuffix;
     };
   }
   this._originOrPermission = originOrPermission;
 };
 
-this.WebChannel.prototype = {
+WebChannel.prototype = {
   /**
    * WebChannel id
    */
   id: null,
 
   /**
    * The originOrPermission value passed to the constructor, mainly for
    * debugging and tests.
diff --git a/toolkit/mozapps/extensions/AddonManager.jsm b/toolkit/mozapps/extensions/AddonManager.jsm
--- a/toolkit/mozapps/extensions/AddonManager.jsm
+++ b/toolkit/mozapps/extensions/AddonManager.jsm
@@ -4746,20 +4746,20 @@ AMTelemetry = {
     } catch (err) {
       // If the telemetry throws just log the error so it doesn't break any
       // functionality.
       Cu.reportError(err);
     }
   },
 };
 
-this.AddonManager.init();
+AddonManager.init();
 
 // Setup the AMTelemetry once the AddonManager has been started.
-this.AddonManager.addManagerListener(AMTelemetry);
+AddonManager.addManagerListener(AMTelemetry);
 
 // load the timestamps module into AddonManagerInternal
 ChromeUtils.import(
   "resource://gre/modules/TelemetryTimestamps.jsm",
   AddonManagerInternal
 );
 Object.freeze(AddonManagerInternal);
 Object.freeze(AddonManagerPrivate);
diff --git a/toolkit/mozapps/extensions/Blocklist.jsm b/toolkit/mozapps/extensions/Blocklist.jsm
--- a/toolkit/mozapps/extensions/Blocklist.jsm
+++ b/toolkit/mozapps/extensions/Blocklist.jsm
@@ -351,18 +351,16 @@ const BlocklistTelemetry = {
       "blocklistUpdateError",
       "xml",
       errorType,
       extra
     );
   },
 };
 
-this.BlocklistTelemetry = BlocklistTelemetry;
-
 const Utils = {
   /**
    * Checks whether this entry is valid for the current OS and ABI.
    * If the entry has an "os" property then the current OS must appear in
    * its comma separated list for it to be valid. Similarly for the
    * xpcomabi property.
    *
    * @param {Object} item
@@ -602,17 +600,17 @@ async function targetAppFilter(entry, en
  * }
  *
  * The RemoteSetttings client takes care of filtering out versions that don't apply.
  * The code here stores entries in memory and sends them to the gfx component in
  * serialized text form, using ',', '\t' and '\n' as separators.
  *
  * Note: we assign to the global to allow tests to reach the object directly.
  */
-this.GfxBlocklistRS = {
+const GfxBlocklistRS = {
   _ensureInitialized() {
     if (this._initialized || !gBlocklistEnabled) {
       return;
     }
     this._initialized = true;
     this._client = RemoteSettings(
       Services.prefs.getCharPref(PREF_BLOCKLIST_GFX_COLLECTION),
       {
@@ -776,17 +774,17 @@ this.GfxBlocklistRS = {
  *    ],
  *    "matchFilename":"npjp2\\.dll",
  *    "id":"f254e5bc-12c7-7954-fe6b-8f1fdab0ae88",
  *    "last_modified":1519390914542,
  *  }
  *
  * Note: we assign to the global to allow tests to reach the object directly.
  */
-this.PluginBlocklistRS = {
+const PluginBlocklistRS = {
   _matchProps: {
     matchDescription: "description",
     matchFilename: "filename",
     matchName: "name",
   },
 
   async _ensureEntries() {
     await this.ensureInitialized();
@@ -1213,17 +1211,17 @@ this.PluginBlocklistRS = {
  *     }
  *   ],
  *   "id": "<unique guid>",
  *   "last_modified": 1480349215672,
  * }
  *
  * Note: we assign to the global to allow tests to reach the object directly.
  */
-this.ExtensionBlocklistRS = {
+const ExtensionBlocklistRS = {
   async _ensureEntries() {
     this.ensureInitialized();
     if (!this._entries && gBlocklistEnabled) {
       await this._updateEntries();
     }
   },
 
   async _updateEntries() {
diff --git a/toolkit/mozapps/extensions/internal/XPIDatabase.jsm b/toolkit/mozapps/extensions/internal/XPIDatabase.jsm
--- a/toolkit/mozapps/extensions/internal/XPIDatabase.jsm
+++ b/toolkit/mozapps/extensions/internal/XPIDatabase.jsm
@@ -1390,17 +1390,17 @@ function _findAddon(addonDB, aFilter) {
  *        be returned.
  * @returns {Array<AddonInternal>}
  *        The list of matching add-ons.
  */
 function _filterDB(addonDB, aFilter) {
   return Array.from(addonDB.values()).filter(aFilter);
 }
 
-this.XPIDatabase = {
+const XPIDatabase = {
   // true if the database connection has been opened
   initialized: false,
   // The database file
   jsonFile: FileUtils.getFile(KEY_PROFILEDIR, [FILE_JSON_DB], true),
   rebuildingDatabase: false,
   syncLoadingDB: false,
   // Add-ons from the database in locations which are no longer
   // supported.
@@ -2551,17 +2551,17 @@ this.XPIDatabase = {
     let locale = aAddon.defaultLocale;
     XPIProvider.addTelemetry(aAddon.id, {
       name: locale.name,
       creator: locale.creator,
     });
   },
 };
 
-this.XPIDatabaseReconcile = {
+const XPIDatabaseReconcile = {
   /**
    * Returns a map of ID -> add-on. When the same add-on ID exists in multiple
    * install locations the highest priority location is chosen.
    *
    * @param {Map<String, AddonInternal>} addonMap
    *        The add-on map to flatten.
    * @param {string?} [hideLocation]
    *        An optional location from which to hide any add-ons.
diff --git a/toolkit/mozapps/extensions/internal/XPIInstall.jsm b/toolkit/mozapps/extensions/internal/XPIInstall.jsm
--- a/toolkit/mozapps/extensions/internal/XPIInstall.jsm
+++ b/toolkit/mozapps/extensions/internal/XPIInstall.jsm
@@ -769,17 +769,17 @@ function syncLoadManifest(state, locatio
  * the file when it is no longer needed.
  *
  * @returns {nsIFile}
  *       An nsIFile that points to a randomly named, initially empty file in
  *       the OS temporary files directory
  */
 function getTemporaryFile() {
   let file = FileUtils.getDir(KEY_TEMPDIR, []);
-  let random = Math.round(Math.random() * 36 ** 3).toString(36);
+  let random = Math.round(Math.random() * (36 ** 3)).toString(36);
   file.append(`tmp-${random}.xpi`);
   file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, FileUtils.PERMS_FILE);
   return file;
 }
 
 /**
  * Returns the signedState for a given return code and certificate by verifying
  * it against the expected ID.
