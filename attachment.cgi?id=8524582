# HG changeset patch
# Parent 0b6ef3a5b00941d0aada07383577f467e2d2ec43
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 1084442 - Prevent highlighter from being zoomed in/out and incorrectly positioned when the page is zoomed; r=miker

diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -45,17 +45,17 @@ LayoutHelpers.prototype = {
       box: region
     });
 
     if (!quads) {
       return null;
     }
 
     let [xOffset, yOffset] = this.getFrameOffsets(node);
-    let scale = this.calculateScale(node);
+    let scale = LayoutHelpers.getCurrentZoom(node);
 
     return {
       p1: {
         w: quads.p1.w * scale,
         x: quads.p1.x * scale + xOffset,
         y: quads.p1.y * scale + yOffset,
         z: quads.p1.z * scale
       },
@@ -86,29 +86,16 @@ LayoutHelpers.prototype = {
         width: quads.bounds.width * scale,
         x: quads.bounds.x * scale + xOffset,
         y: quads.bounds.y * scale + yOffset
       }
     };
   },
 
   /**
-   * Get the current zoom factor applied to the container window of a given node
-   * @param {DOMNode}
-   *        The node for which the zoom factor should be calculated
-   * @return {Number}
-   */
-  calculateScale: function(node) {
-    let win = node.ownerDocument.defaultView;
-    let winUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)
-                      .getInterface(Ci.nsIDOMWindowUtils);
-    return winUtils.fullZoom;
-  },
-
-  /**
    * Compute the absolute position and the dimensions of a node, relativalely
    * to the root window.
    *
    * @param {DOMNode} aNode
    *        a DOM element to get the bounds for
    * @param {DOMWindow} aContentWindow
    *        the content window holding the node
    * @return {Object}
@@ -406,17 +393,17 @@ LayoutHelpers.prototype = {
    *        The node for which we are to get the offset
    * @return {Array}
    *         The frame offset [x, y]
    */
   getFrameOffsets: function(node) {
     let xOffset = 0;
     let yOffset = 0;
     let frameWin = node.ownerDocument.defaultView;
-    let scale = this.calculateScale(node);
+    let scale = LayoutHelpers.getCurrentZoom(node);
 
     while (true) {
       // Are we in the top-level window?
       if (this.isTopLevelWindow(frameWin)) {
         break;
       }
 
       let frameElement = this.getFrameElement(frameWin);
@@ -449,17 +436,17 @@ LayoutHelpers.prototype = {
    * @return {Object}
    *         An object with p1,p2,p3,p4 properties being {x,y} objects
    */
   getNodeBounds: function(node) {
     if (!node) {
       return;
     }
 
-    let scale = this.calculateScale(node);
+    let scale = LayoutHelpers.getCurrentZoom(node);
 
     // Find out the offset of the node in its current frame
     let offsetLeft = 0;
     let offsetTop = 0;
     let el = node;
     while (el && el.parentNode) {
       offsetLeft += el.offsetLeft;
       offsetTop += el.offsetTop;
@@ -602,8 +589,30 @@ LayoutHelpers.isShadowAnonymous = functi
   if (!parent) {
     return false;
   }
 
   // If there is a shadowRoot and this is part of it then this
   // is not native anonymous
   return parent.shadowRoot && parent.shadowRoot.contains(node);
 };
+
+/**
+ * Get the current zoom factor applied to the container window of a given node.
+ * Container windows are used as a weakmap key to store the corresponding
+ * nsIDOMWindowUtils instance to avoid querying it every time.
+ *
+ * @param {DOMNode} The node for which the zoom factor should be calculated
+ * @return {Number}
+ */
+let windowUtils = new WeakMap;
+LayoutHelpers.getCurrentZoom = function(node, map = z=>z) {
+  let win = node.ownerDocument.defaultView;
+  let utils = windowUtils.get(win);
+  if (utils) {
+    return utils.fullZoom;
+  }
+
+  utils = win.QueryInterface(Ci.nsIInterfaceRequestor)
+             .getInterface(Ci.nsIDOMWindowUtils);
+  windowUtils.set(win, utils);
+  return utils.fullZoom;
+};
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -21,17 +21,23 @@
 }
 
 :-moz-native-anonymous .highlighter-container [hidden] {
   display: none;
 }
 
 /* Box model highlighter */
 
-:-moz-native-anonymous .box-model-container {
+:-moz-native-anonymous .box-model-root {
+  position: absolute;
+  width: 100%;
+  height: 100%;
+}
+
+:-moz-native-anonymous .box-model-regions {
   opacity: 0.4;
 }
 
 :-moz-native-anonymous .box-model-content {
   fill: #80d4ff;
 }
 
 :-moz-native-anonymous .box-model-padding {
@@ -148,16 +154,22 @@
   color: hsl(210,30%,85%);
   -moz-border-start: 1px solid #5a6169;
   -moz-margin-start: 6px;
   -moz-padding-start: 6px;
 }
 
 /* Css transform highlighter */
 
+:-moz-native-anonymous .css-transform-root {
+  position: absolute;
+  width: 100%;
+  height: 100%;
+}
+
 :-moz-native-anonymous .css-transform-transformed {
   fill: #80d4ff;
   opacity: 0.8;
 }
 
 :-moz-native-anonymous .css-transform-untransformed {
   fill: #66cc52;
   opacity: 0.8;
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -482,16 +482,48 @@ CanvasFrameAnonymousContentHelper.protot
     }
   },
 
   get content() {
     if (Cu.isDeadWrapper(this._content)) {
       return null;
     }
     return this._content;
+  },
+
+  /**
+   * The canvasFrame anonymous content container gets zoomed in/out with the
+   * page. If this is unwanted, i.e. if you want an element which got inserted
+   * with this API to remain unzoomed, then this method can be used.
+   *
+   * Note that the element that the matching element will be scaled down or
+   * up by 1/zoom (using css transform) to cancel the current zoom.
+   * The element's width and height styles can also optionally be set.
+   *
+   * Note that if the matching element already has an inline style attribute, it
+   * *won't* be preserved.
+   *
+   * @param {DOMNode} node This node is used to determine which container window
+   * should be used to read the current zoom value.
+   * @param {String} id The ID of the element inserted with this API.
+   * @param {Boolean} resize Optional. If not provided, the width and height
+   * will be set according to the zoom level.
+   */
+  unzoomElement: function(node, id, resize=true) {
+    let zoom = LayoutHelpers.getCurrentZoom(node);
+    let value = resize ? "width:100%;height:100%" : "";
+
+    if (zoom !== 1) {
+      value = "transform-origin:top left;transform:scale(" + (1/zoom) + ");";
+      if (resize) {
+        value += "width:" + (100*zoom) + "%;height:" + (100*zoom) + "%;";
+      }
+    }
+
+    this.setAttributeForElement(id, "style", value);
   }
 };
 
 /**
  * Base class for auto-refresh-on-change highlighters. Sub classes will have a
  * chance to update whenever the current node's geometry changes.
  *
  * Sub classes must implement the following methods:
@@ -683,39 +715,41 @@ AutoRefreshHighlighter.prototype = {
  * - hideInfoBar {Boolean}
  *   Defaults to false
  * - showOnly {String}
  *   "content", "padding", "border" or "margin"
  *    If set, only this region will be highlighted
  *
  * Structure:
  * <div class="highlighter-container">
- *   <svg class="box-model-root" hidden="true">
- *     <g class="box-model-container">
- *       <polygon class="box-model-margin" points="317,122 747,36 747,181 317,267" />
- *       <polygon class="box-model-border" points="317,128 747,42 747,161 317,247" />
- *       <polygon class="box-model-padding" points="323,127 747,42 747,161 323,246" />
- *       <polygon class="box-model-content" points="335,137 735,57 735,152 335,232" />
- *     </g>
- *     <line class="box-model-guide-top" x1="0" y1="592" x2="99999" y2="592" />
- *     <line class="box-model-guide-right" x1="735" y1="0" x2="735" y2="99999" />
- *     <line class="box-model-guide-bottom" x1="0" y1="612" x2="99999" y2="612" />
- *     <line class="box-model-guide-left" x1="334" y1="0" x2="334" y2="99999" />
- *   </svg>
- *   <div class="highlighter-nodeinfobar-container">
- *     <div class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top" />
- *     <div class="highlighter-nodeinfobar">
- *       <div class="highlighter-nodeinfobar-text" align="center" flex="1">
- *         <span class="highlighter-nodeinfobar-tagname">Node name</span>
- *         <span class="highlighter-nodeinfobar-id">Node id</span>
- *         <span class="highlighter-nodeinfobar-classes">.someClass</span>
- *         <span class="highlighter-nodeinfobar-pseudo-classes">:hover</span>
+ *   <div class="box-model-root">
+ *     <svg class="box-model-elements" hidden="true">
+ *       <g class="box-model-regions">
+ *         <polygon class="box-model-margin" points="..." />
+ *         <polygon class="box-model-border" points="..." />
+ *         <polygon class="box-model-padding" points="..." />
+ *         <polygon class="box-model-content" points="..." />
+ *       </g>
+ *       <line class="box-model-guide-top" x1="..." y1="..." x2="..." y2="..." />
+ *       <line class="box-model-guide-right" x1="..." y1="..." x2="..." y2="..." />
+ *       <line class="box-model-guide-bottom" x1="..." y1="..." x2="..." y2="..." />
+ *       <line class="box-model-guide-left" x1="..." y1="..." x2="..." y2="..." />
+ *     </svg>
+ *     <div class="box-model-nodeinfobar-container">
+ *       <div class="box-model-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top" />
+ *       <div class="box-model-nodeinfobar">
+ *         <div class="box-model-nodeinfobar-text" align="center">
+ *           <span class="box-model-nodeinfobar-tagname">Node name</span>
+ *           <span class="box-model-nodeinfobar-id">Node id</span>
+ *           <span class="box-model-nodeinfobar-classes">.someClass</span>
+ *           <span class="box-model-nodeinfobar-pseudo-classes">:hover</span>
+ *         </div>
  *       </div>
+ *       <div class="box-model-nodeinfobar-arrow box-model-nodeinfobar-arrow-bottom"/>
  *     </div>
- *     <div class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-bottom"/>
  *   </div>
  * </div>
  */
 function BoxModelHighlighter(tabActor) {
   AutoRefreshHighlighter.call(this, tabActor);
   EventEmitter.decorate(this);
 
   this.markup = new CanvasFrameAnonymousContentHelper(this.tabActor,
@@ -748,112 +782,152 @@ BoxModelHighlighter.prototype = Heritage
   },
 
   _buildMarkup: function() {
     let doc = this.win.document;
 
     let highlighterContainer = doc.createElement("div");
     highlighterContainer.className = "highlighter-container";
 
+    // Build the root wrapper, used to adapt to the page zoom.
+    let rootWrapper = createNode(this.win, {
+      parent: highlighterContainer,
+      attributes: {
+        "id": "root",
+        "class": "root"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
     // Building the SVG element with its polygons and lines
 
-    let svgRoot = this._createSVGNode("svg", highlighterContainer, {
-      "id": "root",
-      "class": "root",
-      "width": "100%",
-      "height": "100%",
-      "style": "width:100%;height:100%;",
-      "hidden": "true"
+    let svg = createSVGNode(this.win, {
+      nodeType: "svg",
+      parent: rootWrapper,
+      attributes: {
+        "id": "elements",
+        "width": "100%",
+        "height": "100%",
+        "style": "width:100%;height:100%;",
+        "hidden": "true"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
-    let boxModelContainer = this._createSVGNode("g", svgRoot, {
-      "class": "container"
+    let regions = createSVGNode(this.win, {
+      nodeType: "g",
+      parent: svg,
+      attributes: {
+        "class": "regions"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
     for (let region of BOX_MODEL_REGIONS) {
-      this._createSVGNode("polygon", boxModelContainer, {
-        "class": region,
-        "id": region
+      createSVGNode(this.win, {
+        nodeType: "polygon",
+        parent: regions,
+        attributes: {
+          "class": region,
+          "id": region
+        },
+        prefix: this.ID_CLASS_PREFIX
       });
     }
 
     for (let side of BOX_MODEL_SIDES) {
-      this._createSVGNode("line", svgRoot, {
-        "class": "guide-" + side,
-        "id": "guide-" + side,
-        "stroke-width": GUIDE_STROKE_WIDTH
+      createSVGNode(this.win, {
+        nodeType: "line",
+        parent: svg,
+        attributes: {
+          "class": "guide-" + side,
+          "id": "guide-" + side,
+          "stroke-width": GUIDE_STROKE_WIDTH
+        },
+        prefix: this.ID_CLASS_PREFIX
       });
     }
 
-    highlighterContainer.appendChild(svgRoot);
-
     // Building the nodeinfo bar markup
 
-    let infobarContainer = this._createNode("div", highlighterContainer, {
-      "class": "nodeinfobar-container",
-      "id": "nodeinfobar-container",
-      "position": "top",
-      "hidden": "true"
+    let infobarContainer = createNode(this.win, {
+      parent: rootWrapper,
+      attributes: {
+        "class": "nodeinfobar-container",
+        "id": "nodeinfobar-container",
+        "position": "top",
+        "hidden": "true"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
-    let nodeInfobar = this._createNode("div", infobarContainer, {
-      "class": "nodeinfobar"
+    let nodeInfobar = createNode(this.win, {
+      parent: infobarContainer,
+      attributes: {
+        "class": "nodeinfobar"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
-    let texthbox = this._createNode("div", nodeInfobar, {
-      "class": "nodeinfobar-text"
+    let texthbox = createNode(this.win, {
+      parent: nodeInfobar,
+      attributes: {
+        "class": "nodeinfobar-text"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createNode("span", texthbox, {
-      "class": "nodeinfobar-tagname",
-      "id": "nodeinfobar-tagname"
+    createNode(this.win, {
+      nodeType: "span",
+      parent: texthbox,
+      attributes: {
+        "class": "nodeinfobar-tagname",
+        "id": "nodeinfobar-tagname"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createNode("span", texthbox, {
-      "class": "nodeinfobar-id",
-      "id": "nodeinfobar-id"
+    createNode(this.win, {
+      nodeType: "span",
+      parent: texthbox,
+      attributes: {
+        "class": "nodeinfobar-id",
+        "id": "nodeinfobar-id"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createNode("span", texthbox, {
-      "class": "nodeinfobar-classes",
-      "id": "nodeinfobar-classes"
+    createNode(this.win, {
+      nodeType: "span",
+      parent: texthbox,
+      attributes: {
+        "class": "nodeinfobar-classes",
+        "id": "nodeinfobar-classes"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createNode("span", texthbox, {
-      "class": "nodeinfobar-pseudo-classes",
-      "id": "nodeinfobar-pseudo-classes"
+    createNode(this.win, {
+      nodeType: "span",
+      parent: texthbox,
+      attributes: {
+        "class": "nodeinfobar-pseudo-classes",
+        "id": "nodeinfobar-pseudo-classes"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createNode("span", texthbox, {
-      "class": "nodeinfobar-dimensions",
-      "id": "nodeinfobar-dimensions"
+    createNode(this.win, {
+      nodeType: "span",
+      parent: texthbox,
+      attributes: {
+        "class": "nodeinfobar-dimensions",
+        "id": "nodeinfobar-dimensions"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
     return highlighterContainer;
   },
 
-  _createSVGNode: function(nodeType, parent, attributes={}) {
-    return this._createNode(nodeType, parent, attributes, SVG_NS);
-  },
-
-  _createNode: function(nodeType, parent, attributes={}, namespace=null) {
-    let node;
-    if (namespace) {
-      node = this.win.document.createElementNS(namespace, nodeType);
-    } else {
-      node = this.win.document.createElement(nodeType);
-    }
-
-    for (let name in attributes) {
-      let value = attributes[name];
-      if (name === "class" || name === "id") {
-        value = this.ID_CLASS_PREFIX + value
-      }
-      node.setAttribute(name, value);
-    }
-
-    parent.appendChild(node);
-    return node;
-  },
-
   /**
    * Destroy the nodes. Remove listeners.
    */
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
 
@@ -936,25 +1010,25 @@ BoxModelHighlighter.prototype = Heritage
       this.ID_CLASS_PREFIX + "nodeinfobar-container", "hidden");
     this._updateInfobar();
   },
 
   /**
    * Hide the box model
    */
   _hideBoxModel: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "root", "hidden",
-      "true");
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "elements",
+      "hidden", "true");
   },
 
   /**
    * Show the box model
    */
   _showBoxModel: function() {
-    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "root",
+    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "elements",
       "hidden");
   },
 
   /**
    * Update the box model as per the current node.
    *
    * @return {boolean}
    *         True if the current node has a box model to be highlighted
@@ -986,16 +1060,20 @@ BoxModelHighlighter.prototype = Heritage
 
         if (boxType === this.options.region && !this.options.hideGuides) {
           this._showGuides(p1, p2, p3, p4);
         } else if (this.options.hideGuides) {
           this._hideGuides();
         }
       }
 
+      // Un-zoom the root wrapper if the page was zoomed.
+      let rootId = this.ID_CLASS_PREFIX + "root";
+      this.markup.unzoomElement(this.currentNode, rootId);
+
       return true;
     }
 
     this._hideBoxModel();
     return false;
   },
 
   _nodeNeedsHighlighting: function() {
@@ -1239,86 +1317,113 @@ function CssTransformHighlighter(tabActo
 let MARKER_COUNTER = 1;
 
 CssTransformHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
   ID_CLASS_PREFIX: "css-transform-",
 
   _buildMarkup: function() {
     let doc = this.win.document;
 
-    let container = doc.createElement("div");
-    container.className = "highlighter-container";
+    let container = createNode(this.win, {
+      attributes: {
+        "class": "highlighter-container"
+      }
+    });
 
-    let svgRoot = this._createSVGNode("svg", container, {
-      "class": "root",
-      "id": "root",
-      "hidden": "true",
-      "width": "100%",
-      "height": "100%"
+    // The root wrapper is used to unzoom the highlighter when needed.
+    let rootWrapper = createNode(this.win, {
+      parent: container,
+      attributes: {
+        "id": "root",
+        "class": "root"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
+    let svg = createSVGNode(this.win, {
+      nodeType: "svg",
+      parent: rootWrapper,
+      attributes: {
+        "id": "elements",
+        "hidden": "true",
+        "width": "100%",
+        "height": "100%"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
     // Add a marker tag to the svg root for the arrow tip
     this.markerId = "arrow-marker-" + MARKER_COUNTER;
     MARKER_COUNTER ++;
-    let marker = this._createSVGNode("marker", svgRoot, {
-      "id": this.markerId,
-      "markerWidth": "10",
-      "markerHeight": "5",
-      "orient": "auto",
-      "markerUnits": "strokeWidth",
-      "refX": "10",
-      "refY": "5",
-      "viewBox": "0 0 10 10",
+    let marker = createSVGNode(this.win, {
+      nodeType: "marker",
+      parent: svg,
+      attributes: {
+        "id": this.markerId,
+        "markerWidth": "10",
+        "markerHeight": "5",
+        "orient": "auto",
+        "markerUnits": "strokeWidth",
+        "refX": "10",
+        "refY": "5",
+        "viewBox": "0 0 10 10"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createSVGNode("path", marker, {
-      "d": "M 0 0 L 10 5 L 0 10 z",
-      "fill": "#08C"
+    createSVGNode(this.win, {
+      nodeType: "path",
+      parent: marker,
+      attributes: {
+        "d": "M 0 0 L 10 5 L 0 10 z",
+        "fill": "#08C"
+      }
     });
 
-    let shapesGroup = this._createSVGNode("g", svgRoot);
+    let shapesGroup = createSVGNode(this.win, {
+      nodeType: "g",
+      parent: svg
+    });
 
     // Create the 2 polygons (transformed and untransformed)
-    this._createSVGNode("polygon", shapesGroup, {
-      "id": "untransformed",
-      "class": "untransformed"
+    createSVGNode(this.win, {
+      nodeType: "polygon",
+      parent: shapesGroup,
+      attributes: {
+        "id": "untransformed",
+        "class": "untransformed"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
-    this._createSVGNode("polygon", shapesGroup, {
-      "id": "transformed",
-      "class": "transformed"
+    createSVGNode(this.win, {
+      nodeType: "polygon",
+      parent: shapesGroup,
+      attributes: {
+        "id": "transformed",
+        "class": "transformed"
+      },
+      prefix: this.ID_CLASS_PREFIX
     });
 
     // Create the arrows
     for (let nb of ["1", "2", "3", "4"]) {
-      this._createSVGNode("line", shapesGroup, {
-        "id": "line" + nb,
-        "class": "line",
-        "marker-end": "url(#" + this.markerId + ")"
+      createSVGNode(this.win, {
+        nodeType: "line",
+        parent: shapesGroup,
+        attributes: {
+          "id": "line" + nb,
+          "class": "line",
+          "marker-end": "url(#" + this.markerId + ")"
+        },
+        prefix: this.ID_CLASS_PREFIX
       });
     }
 
-    container.appendChild(svgRoot);
-
     return container;
   },
 
-  _createSVGNode: function(nodeType, parent, attributes={}) {
-    let node = this.win.document.createElementNS(SVG_NS, nodeType);
-
-    for (let name in attributes) {
-      let value = attributes[name];
-      if (name === "class" || name === "id") {
-        value = this.ID_CLASS_PREFIX + value
-      }
-      node.setAttribute(name, value);
-    }
-
-    parent.appendChild(node);
-    return node;
-  },
-
   /**
    * Destroy the nodes. Remove listeners.
    */
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
     this.markup.destroy();
   },
 
@@ -1385,32 +1490,37 @@ CssTransformHighlighter.prototype = Heri
     let untransformedQuad = this.layoutHelpers.getNodeBounds(this.currentNode);
 
     this._setPolygonPoints(quad, "transformed");
     this._setPolygonPoints(untransformedQuad, "untransformed");
     for (let nb of ["1", "2", "3", "4"]) {
       this._setLinePoints(untransformedQuad["p" + nb], quad["p" + nb], "line" + nb);
     }
 
+    // Adapt to the current zoom
+    this.markup.unzoomElement(this.currentNode, this.ID_CLASS_PREFIX + "root");
+
     this._showShapes();
   },
 
   /**
    * Hide the highlighter, the outline and the infobar.
    */
   _hide: function() {
     this._hideShapes();
   },
 
   _hideShapes: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "root", "hidden", "true");
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "elements",
+      "hidden", "true");
   },
 
   _showShapes: function() {
-    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "root", "hidden");
+    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "elements",
+      "hidden");
   }
 });
 
 /**
  * The SelectorHighlighter runs a given selector through querySelectorAll on the
  * document of the provided context node and then uses the BoxModelHighlighter
  * to highlight the matching nodes
  */
@@ -1560,11 +1670,68 @@ function installHelperSheet(win, source,
 
 /**
  * Is the content window in this tabActor a XUL window
  */
 function isXUL(tabActor) {
   return tabActor.window.document.documentElement.namespaceURI === XUL_NS;
 }
 
+/**
+ * Helper function that creates SVG DOM nodes.
+ * @param {Window} This window's document will be used to create the element
+ * @param {Object} Options for the node include:
+ * - nodeType: the type of node, defaults to "box".
+ * - attributes: a {name:value} object to be used as attributes for the node.
+ * - prefix: a string that will be used to prefix the values of the id and class
+ *   attributes.
+ * - parent: if provided, the newly created element will be appended to this
+ *   node.
+ */
+function createSVGNode(win, options) {
+  if (!options.nodeType) {
+    options.nodeType = "box";
+  }
+  options.namespace = SVG_NS;
+  return createNode(win, options);
+}
+
+/**
+ * Helper function that creates DOM nodes.
+ * @param {Window} This window's document will be used to create the element
+ * @param {Object} Options for the node include:
+ * - nodeType: the type of node, defaults to "div".
+ * - namespace: if passed, doc.createElementNS will be used instead of
+ *   doc.creatElement.
+ * - attributes: a {name:value} object to be used as attributes for the node.
+ * - prefix: a string that will be used to prefix the values of the id and class
+ *   attributes.
+ * - parent: if provided, the newly created element will be appended to this
+ *   node.
+ */
+function createNode(win, options) {
+  let type = options.nodeType || "div";
+
+  let node;
+  if (options.namespace) {
+    node = win.document.createElementNS(options.namespace, type);
+  } else {
+    node = win.document.createElement(type);
+  }
+
+  for (let name in options.attributes || {}) {
+    let value = options.attributes[name];
+    if (options.prefix && (name === "class" || name === "id")) {
+      value = options.prefix + value
+    }
+    node.setAttribute(name, value);
+  }
+
+  if (options.parent) {
+    options.parent.appendChild(node);
+  }
+
+  return node;
+}
+
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
 });
