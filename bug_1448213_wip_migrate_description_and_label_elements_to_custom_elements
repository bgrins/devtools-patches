# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1536773841 25200
#      Wed Sep 12 10:37:21 2018 -0700
# Node ID 7d43507433b3ca38c945debf03abc3bb464408b1
# Parent  18859d2fec94f35e924e9093a99169623e0b2d78
Bug 1448213 - WIP - Migrate label-control and text-link bindings to a Custom Element;

Differential Revision: https://phabricator.services.mozilla.com/D5686

diff --git a/browser/components/preferences/containers.js b/browser/components/preferences/containers.js
--- a/browser/components/preferences/containers.js
+++ b/browser/components/preferences/containers.js
@@ -55,19 +55,29 @@ let gContainersManager = {
   },
 
   init(aParams) {
     this.userContextId = aParams.userContextId || null;
     this.identity = aParams.identity;
 
     const iconWrapper = document.getElementById("iconWrapper");
     iconWrapper.appendChild(this.createIconButtons());
+    iconWrapper.prepend(MozXULElement.parseXULToFragment(`
+    <label id="iconLabel" control="icon"
+           data-l10n-id="containers-icon-label"
+           data-l10n-attrs="style"/>
+    `));
 
     const colorWrapper = document.getElementById("colorWrapper");
     colorWrapper.appendChild(this.createColorSwatches());
+    colorWrapper.prepend(MozXULElement.parseXULToFragment(`
+    <label id="colorLabel" control="color"
+           data-l10n-id="containers-color-label"
+           data-l10n-attrs="style"/>
+    `));
 
     if (this.identity.name) {
       const name = document.getElementById("name");
       name.value = this.identity.name;
       this.checkForm();
     }
 
     // This is to prevent layout jank caused by the svgs and outlines rendering at different times
diff --git a/browser/components/preferences/containers.xul b/browser/components/preferences/containers.xul
--- a/browser/components/preferences/containers.xul
+++ b/browser/components/preferences/containers.xul
@@ -29,24 +29,18 @@
   <vbox class="contentPane largeDialogContainer" flex="1" hidden="true" id="containers-content">
     <hbox align="start">
       <label id="nameLabel" control="name"
              data-l10n-id="containers-name-label"
              data-l10n-attrs="style"/>
       <textbox id="name" data-l10n-id="containers-name-text" flex="1" oninput="gContainersManager.checkForm();" />
     </hbox>
     <hbox align="center" id="iconWrapper">
-      <label id="iconLabel" control="icon"
-             data-l10n-id="containers-icon-label"
-             data-l10n-attrs="style"/>
     </hbox>
     <hbox align="center" id="colorWrapper">
-      <label id="colorLabel" control="color"
-             data-l10n-id="containers-color-label"
-             data-l10n-attrs="style"/>
     </hbox>
   </vbox>
   <vbox>
     <hbox class="actionButtons" align="right" flex="1">
       <button id="btnApplyChanges" disabled="true" oncommand="gContainersManager.onApplyChanges();" icon="save"
               data-l10n-id="containers-button-done"/>
     </hbox>
   </vbox>
diff --git a/dom/tests/mochitest/chrome/test_elements_proto.xul b/dom/tests/mochitest/chrome/test_elements_proto.xul
--- a/dom/tests/mochitest/chrome/test_elements_proto.xul
+++ b/dom/tests/mochitest/chrome/test_elements_proto.xul
@@ -12,21 +12,19 @@
 
   <script type="application/javascript">
   <![CDATA[
     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     SimpleTest.waitForExplicitFinish();
 
     addLoadEvent(() => {
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "label")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "label") instanceof XULTextElement,
         `<label> should be of XULTextElement type`);
 
-      is(Object.getPrototypeOf(document.createElementNS(XUL_NS, "description")),
-         XULTextElement.prototype,
+      ok(document.createElementNS(XUL_NS, "description") instanceof XULTextElement,
         `<description> should be of XULTextElement type`);
 
       SimpleTest.finish();
     });
   ]]>
   </script>
 </window>
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -863,17 +863,17 @@ nsTextBoxFrame::CalculateTitleForWidth(g
 // but the mTitle doesn't have the character
 void
 nsTextBoxFrame::UpdateAccessTitle()
 {
     /*
      * Note that if you change appending access key label spec,
      * you need to maintain same logic in following methods. See bug 324159.
      * toolkit/components/prompts/src/CommonDialog.jsm (setLabelForNode)
-     * toolkit/content/widgets/text.xml (formatAccessKey)
+     * toolkit/content/widgets/text.js (formatAccessKey)
      */
     int32_t menuAccessKey;
     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
     if (!menuAccessKey || mAccessKey.IsEmpty())
         return;
 
     if (!AlwaysAppendAccessKey() &&
         FindInReadable(mAccessKey, mTitle, nsCaseInsensitiveStringComparator()))
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -244,16 +244,17 @@ window.MozBaseControl = MozBaseControl;
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/progressmeter.js",
     "chrome://global/content/elements/radio.js",
+    "chrome://global/content/elements/text.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
   for (let [tag, script] of [
     ["findbar", "chrome://global/content/elements/findbar.js"],
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -80,31 +80,31 @@ toolkit.jar:
    content/global/bindings/notification.xml    (widgets/notification.xml)
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
 *  content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
-   content/global/bindings/text.xml            (widgets/text.xml)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js          (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/progressmeter.js    (widgets/progressmeter.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
+   content/global/elements/text.js             (widgets/text.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
 #ifdef XP_MACOSX
    content/global/macWindowMenu.js
 #endif
    content/global/gmp-sources/openh264.json    (gmp-sources/openh264.json)
    content/global/gmp-sources/widevinecdm.json (gmp-sources/widevinecdm.json)
diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
new file mode 100644
--- /dev/null
+++ b/toolkit/content/widgets/text.js
@@ -0,0 +1,396 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+function mergeElement(element) {
+  if (element.previousSibling instanceof Text) {
+    element.previousSibling.appendData(element.textContent);
+  } else {
+    element.parentNode.insertBefore(element.firstChild, element);
+  }
+  element.remove();
+}
+
+function wrapChar(parent, element, index) {
+  var treeWalker = document.createTreeWalker(parent,
+    NodeFilter.SHOW_TEXT,
+    null);
+  var node = treeWalker.nextNode();
+  while (index >= node.length) {
+    index -= node.length;
+    node = treeWalker.nextNode();
+  }
+  if (index) {
+    node = node.splitText(index);
+  }
+  node.parentNode.insertBefore(element, node);
+  if (node.length > 1) {
+    node.splitText(1);
+  }
+  element.appendChild(node);
+}
+
+let gInsertSeparator;
+let gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+let gAlwaysAppendAccessKey = false;
+function setGlobalAccessKeyFormattingState() {
+  if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
+    return;
+  }
+  try {
+    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
+
+    const prefNameInsertSeparator =
+      "intl.menuitems.insertseparatorbeforeaccesskeys";
+    const prefNameAlwaysAppendAccessKey =
+      "intl.menuitems.alwaysappendaccesskeys";
+
+    var val = Services.prefs.getComplexValue(prefNameInsertSeparator,
+      nsIPrefLocalizedString).data;
+    gInsertSeparator = (val == "true");
+
+    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+      nsIPrefLocalizedString).data;
+    gAlwaysAppendAccessKey = (val == "true");
+  } catch (e) {
+    gInsertSeparator = true;
+  }
+  // console.log("setGlobalAccessKeyFormattingState", gInsertSeparator, gUnderlineAccesskey, gAlwaysAppendAccessKey);
+}
+
+/* globals MozElementMixin,XULTextElement */
+class MozTextLabel extends MozElementMixin(XULTextElement) {
+  constructor() {
+    super();
+
+    setGlobalAccessKeyFormattingState();
+
+    this.addEventListener("click", event => {
+      if (!this.isTextLink || (event.button != 0 && event.button != 1)) {
+        return;
+      }
+      this.open(event);
+    }, true);
+
+    this.addEventListener("keypress", event => {
+      if (!this.isTextLink || event.keyCode != 13) {
+        return;
+      }
+      this.click();
+    });
+
+    this.addEventListener("click", (event) => {
+      if (this.disabled || !this.isLabelControl) {
+        return;
+      }
+      var controlElement = this.labeledControlElement;
+      if (!controlElement) {
+        return;
+      }
+      controlElement.focus();
+      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+      if (controlElement.namespaceURI != XUL_NS) {
+        return;
+      }
+      if (controlElement.localName == "checkbox") {
+        controlElement.checked = !controlElement.checked;
+      } else if (controlElement.localName == "radio") {
+        controlElement.control.selectedItem = controlElement;
+      }
+    });
+  }
+
+  static get observedAttributes() {
+    return ["control", "class"];
+  }
+
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (oldValue == newValue) {
+      return;
+    }
+    this.setupAsControlIfNeeded();
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+    this.setupAsControlIfNeeded();
+  }
+
+  get isTextLink() {
+    return this.classList.contains("text-link") || this.hasAttribute("onClick");
+  }
+
+  setupAsControlIfNeeded() {
+    if (!this.isConnectedAndReady) {
+      return;
+    }
+
+    let wasLabelControl = this.isLabelControl;
+    this.isLabelControl = this.hasAttribute("control") ||
+                          this.classList.contains("radio-label") ||
+                          this.classList.contains("checkbox-label") ||
+                          this.classList.contains("toolbarbutton-multiline-text");
+    if (!wasLabelControl && this.isLabelControl) {
+      if (gUnderlineAccesskey) {
+        this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+        this.appendChild(this.accessKeyParens);
+      }
+      this.formatAccessKey(true);
+    }
+
+    if (wasLabelControl && !this.isLabelControl) {
+      this.accessKeyParens.remove();
+    }
+  }
+
+  set accessKey(val) {
+    if (!this.isLabelControl) {
+      this.setAttribute("accesskey", val);
+      return val;
+    }
+
+    // If this label already has an accesskey attribute store it here as well
+    if (this.hasAttribute("accesskey")) {
+      this.setAttribute("accesskey", val);
+    }
+    var control = this.labeledControlElement;
+    if (control) {
+      control.setAttribute("accesskey", val);
+    }
+    this.formatAccessKey(false);
+    return val;
+  }
+
+  get accessKey() {
+    var accessKey = this.getAttribute("accesskey");
+    return accessKey ? accessKey[0] : null;
+  }
+
+  get labeledControlElement() {
+    if (!this.isLabelControl) {
+      return null;
+    }
+
+    var control = this.control;
+    return control ? document.getElementById(control) : null;
+  }
+
+  set control(val) {
+    if (!this.isLabelControl) {
+      // After this gets set, the label will switch to `isLabelControl`
+      this.setAttribute("control", val);
+      return val;
+    }
+
+    var control = this.labeledControlElement;
+    if (control) {
+      control.labelElement = null; // No longer pointed to be this label
+    }
+    this.setAttribute("control", val);
+    this.formatAccessKey(false);
+    return val;
+  }
+
+  get control() {
+    return this.getAttribute("control");
+  }
+
+  set href(val) {
+    this.setAttribute("href", val);
+    return val;
+  }
+
+  get href() {
+    return this.getAttribute("href");
+  }
+
+  open(aEvent) {
+    if (!this.isTextLink) {
+      return;
+    }
+
+    var href = this.href;
+    if (!href || this.disabled || aEvent.defaultPrevented)
+      return;
+
+    var uri = null;
+    try {
+      const nsISSM = Ci.nsIScriptSecurityManager;
+      const secMan =
+        Cc["@mozilla.org/scriptsecuritymanager;1"]
+        .getService(nsISSM);
+
+      uri = Services.io.newURI(href);
+
+      let principal;
+      if (this.getAttribute("useoriginprincipal") == "true") {
+        principal = this.nodePrincipal;
+      } else {
+        principal = secMan.createNullPrincipal({});
+      }
+      try {
+        secMan.checkLoadURIWithPrincipal(principal, uri,
+          nsISSM.DISALLOW_INHERIT_PRINCIPAL);
+      } catch (ex) {
+        var msg = "Error: Cannot open a " + uri.scheme + ": link using \
+                         the text-link binding.";
+        Cu.reportError(msg);
+        return;
+      }
+
+      const cID = "@mozilla.org/uriloader/external-protocol-service;1";
+      const nsIEPS = Ci.nsIExternalProtocolService;
+      var protocolSvc = Cc[cID].getService(nsIEPS);
+
+      // if the scheme is not an exposed protocol, then opening this link
+      // should be deferred to the system's external protocol handler
+      if (!protocolSvc.isExposedProtocol(uri.scheme)) {
+        protocolSvc.loadURI(uri);
+        aEvent.preventDefault();
+        return;
+      }
+
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+
+    aEvent.preventDefault();
+    href = uri ? uri.spec : href;
+
+    // Try handing off the link to the host application, e.g. for
+    // opening it in a tabbed browser.
+    var linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
+      .createInstance(Ci.nsISupportsPRBool);
+    linkHandled.data = false;
+    let { shiftKey, ctrlKey, metaKey, altKey, button } = aEvent;
+    let data = { shiftKey, ctrlKey, metaKey, altKey, button, href };
+    Services.obs
+      .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
+    if (linkHandled.data)
+      return;
+
+    // otherwise, fall back to opening the anchor directly
+    var win = window;
+    if (window.isChromeWindow) {
+      while (win.opener && !win.opener.closed)
+        win = win.opener;
+    }
+    win.open(href);
+  }
+
+  formatAccessKey(firstTime) {
+    if (!this.isLabelControl) {
+      return;
+    }
+
+    var control = this.labeledControlElement;
+    if (!control) {
+      var bindingParent = document.getBindingParent(this);
+      if (!bindingParent) {
+        throw new Error("Label created without control or binding parent");
+      }
+      if ("accessKey" in bindingParent) {
+        control = bindingParent; // For controls that make the <label> an anon child
+      }
+    }
+    if (control) {
+      control.labelElement = this;
+      var controlAccessKey = control.getAttribute("accesskey");
+      if (controlAccessKey) {
+        this.setAttribute("accesskey", controlAccessKey);
+      }
+    }
+
+    if (!gUnderlineAccesskey)
+      return;
+
+    var accessKey = this.accessKey;
+    // No need to remove existing formatting the first time.
+    if (firstTime && !accessKey)
+      return;
+
+    var afterLabel = this.accessKeyParens;
+    afterLabel.textContent = "";
+
+    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
+    if (oldAccessKey) { // Clear old accesskey
+      mergeElement(oldAccessKey);
+    }
+
+    var oldHiddenSpan =
+      this.getElementsByAttribute("class", "hiddenColon").item(0);
+    if (oldHiddenSpan) {
+      mergeElement(oldHiddenSpan);
+    }
+
+    var labelText = this.textContent;
+    if (!accessKey || !labelText || !control) {
+      return;
+    }
+    var accessKeyIndex = -1;
+    if (!gAlwaysAppendAccessKey) {
+      accessKeyIndex = labelText.indexOf(accessKey);
+      if (accessKeyIndex < 0) { // Try again in upper case
+        accessKeyIndex =
+          labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+      }
+    } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+      accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+    }
+
+    const HTML_NS = "http://www.w3.org/1999/xhtml";
+    var span = document.createElementNS(HTML_NS, "span");
+    span.className = "accesskey";
+
+    // Note that if you change the following code, see the comment of
+    // nsTextBoxFrame::UpdateAccessTitle.
+
+    // If accesskey is not in string, append in parentheses
+    if (accessKeyIndex < 0) {
+      // If end is colon, we should insert before colon.
+      // i.e., "label:" -> "label(X):"
+      var colonHidden = false;
+      if (/:$/.test(labelText)) {
+        labelText = labelText.slice(0, -1);
+        var hiddenSpan = document.createElementNS(HTML_NS, "span");
+        hiddenSpan.className = "hiddenColon";
+        hiddenSpan.style.display = "none";
+        // Hide the last colon by using span element.
+        // I.e., label<span style="display:none;">:</span>
+        wrapChar(this, hiddenSpan, labelText.length);
+        colonHidden = true;
+      }
+      // If end is space(U+20),
+      // we should not add space before parentheses.
+      var endIsSpace = false;
+      if (/ $/.test(labelText)) {
+        endIsSpace = true;
+      }
+      if (gInsertSeparator && !endIsSpace)
+        afterLabel.textContent = " (";
+      else
+        afterLabel.textContent = "(";
+      span.textContent = accessKey.toUpperCase();
+      afterLabel.appendChild(span);
+      if (!colonHidden)
+        afterLabel.appendChild(document.createTextNode(")"));
+      else
+        afterLabel.appendChild(document.createTextNode("):"));
+      return;
+    }
+    wrapChar(this, span, accessKeyIndex);
+  }
+}
+
+customElements.define("label", MozTextLabel);
+
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -93,26 +93,20 @@ page {
 
 /******** box *******/
 
 vbox {
   -moz-box-orient: vertical;
 }
 
 /********** label **********/
-
 label.text-link, label[onclick] {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#text-link");
   -moz-user-focus: normal;
 }
 
-label[control], label.radio-label, label.checkbox-label, label.toolbarbutton-multiline-text {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#label-control");
-}
-
 label html|span.accesskey {
   text-decoration: underline;
 }
 
 /********** button **********/
 
 button {
   -moz-binding: url("chrome://global/content/bindings/button.xml#button");
