# HG changeset patch
# Parent b49d65facfdb7b2b1cb778b5462bedbb5b9dc942
# User Brian Grinstead <bgrinstead@mozilla.com>
test adding classes


diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -18,17 +18,17 @@ const NEW_SELECTION_HIGHLIGHTER_TIMER = 
 
 const {UndoStack} = require("devtools/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/markupview/html-editor");
 const promise = require("devtools/toolkit/deprecated-sync-thenables");
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const EventEmitter = require("devtools/toolkit/event-emitter");
-const Heritage = require("sdk/core/heritage");
+const {Class} = require("sdk/core/heritage");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
@@ -1279,55 +1279,61 @@ MarkupView.prototype = {
  * a <ul> for placing child elements, and expansion/collapsing
  * of the element.
  *
  * This should not be instantiated directly, instead use one of:
  *    MarkupReadOnlyContainer
  *    MarkupTextContainer
  *    MarkupElementContainer
  */
-function MarkupContainer() { }
+// function MarkupContainer() { }
 
-MarkupContainer.prototype = {
+let MarkupContainer = Class({
 
   /*
    * Initialize the MarkupContainer.  Should be called while one
    * of the other contain classes is instantiated.
    *
    * @param MarkupView markupView
    *        The markup view that owns this container.
    * @param NodeFront node
    *        The node to display.
    * @param string templateID
    *        Which template to render for this container
    */
   initialize: function(markupView, node, templateID) {
+    console.log("OOOOKKKKK", markupView, node, templateID)
     this.markup = markupView;
     this.node = node;
 
     // The template will fill the following properties
     this.elt = null;
     this.expander = null;
     this.tagState = null;
     this.tagLine = null;
     this.children = null;
-    this.markup.template(templateID, this);
+    this.init();
+    // this.markup.template(templateID, this);
     this.elt.container = this;
 
     // Binding event listeners
     this._onMouseDown = this._onMouseDown.bind(this);
     this.elt.addEventListener("mousedown", this._onMouseDown, false);
 
     this._onToggle = this._onToggle.bind(this);
     this.elt.addEventListener("dblclick", this._onToggle, false);
 
     // Marking the node as shown or hidden
     this.isDisplayed = this.node.isDisplayed;
   },
 
+  init: function() {
+
+  },
+
   toString: function() {
     return "[MarkupContainer for " + this.node + "]";
   },
 
   isPreviewable: function() {
     if (this.node.tagName && !this.node.isPseudoElement) {
       let tagName = this.node.tagName.toLowerCase();
       let srcAttr = this.editor.getAttributeElement("src");
@@ -1527,94 +1533,121 @@ MarkupContainer.prototype = {
       if (firstChild.container) {
         firstChild.container.destroy();
       }
       this.children.removeChild(firstChild);
     }
 
     this.editor.destroy();
   }
-};
+});
 
 /**
  * An implementation of MarkupContainer for Pseudo Elements,
  * Doctype nodes, or any other type generic node that doesn't
  * fit for other editors.
  * Does not allow any editing, just viewing / selecting.
  *
  * @param MarkupView markupView
  *        The markup view that owns this container.
  * @param NodeFront node
  *        The node to display.
  */
-function MarkupReadOnlyContainer(markupView, node) {
-  MarkupContainer.prototype.initialize.call(this, markupView, node, "readonlycontainer");
 
-  this.editor = new GenericEditor(this, node);
-  this.tagLine.appendChild(this.editor.elt);
-}
+let MarkupReadOnlyContainer = Class({
+  extends: MarkupContainer,
+  init: function() {
+    this.markup.template("readonlycontainer", this);
+    this.editor = new GenericEditor(this, this.node);
+    this.tagLine.appendChild(this.editor.elt);
+  }
 
-MarkupReadOnlyContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
+});
+
+// function MarkupReadOnlyContainer(markupView, node) {
+//   MarkupContainer.prototype.initialize.call(this, markupView, node, "readonlycontainer");
+
+//   this.editor = new GenericEditor(this, node);
+//   this.tagLine.appendChild(this.editor.elt);
+// }
+
+// MarkupReadOnlyContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
 
 /**
  * An implementation of MarkupContainer for text node and comment nodes.
  * Allows basic text editing in a textarea.
  *
  * @param MarkupView aMarkupView
  *        The markup view that owns this container.
  * @param NodeFront aNode
  *        The node to display.
  * @param Inspector aInspector
  *        The inspector tool container the markup-view
  */
-function MarkupTextContainer(markupView, node) {
-  MarkupContainer.prototype.initialize.call(this, markupView, node, "textcontainer");
 
-  if (node.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
-    this.editor = new TextEditor(this, node, "text");
-  } else if (node.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
-    this.editor = new TextEditor(this, node, "comment");
-  } else {
-    throw "Invalid node for MarkupTextContainer";
+let MarkupTextContainer = Class({
+  extends: MarkupContainer,
+// function MarkupTextContainer(markupView, node) {
+  // MarkupContainer.prototype.initialize.call(this, markupView, node, "textcontainer");
+
+  init: function() {
+    this.markup.template("textcontainer", this);
+    if (this.node.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
+      this.editor = new TextEditor(this, node, "text");
+    } else if (this.node.nodeType == Ci.nsIDOMNode.COMMENT_NODE) {
+      this.editor = new TextEditor(this, node, "comment");
+    } else {
+      throw "Invalid node for MarkupTextContainer";
+    }
+
+    this.tagLine.appendChild(this.editor.elt);
   }
+});
 
-  this.tagLine.appendChild(this.editor.elt);
-}
-
-MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
+// MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});
 
 /**
  * An implementation of MarkupContainer for Elements that can contain
  * child nodes.
  * Allows editing of tag name, attributes, expanding / collapsing.
  *
  * @param MarkupView markupView
  *        The markup view that owns this container.
  * @param NodeFront node
  *        The node to display.
  */
-function MarkupElementContainer(markupView, node) {
-  MarkupContainer.prototype.initialize.call(this, markupView, node, "elementcontainer");
 
-  if (node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
-    this.editor = new ElementEditor(this, node);
-  } else {
-    throw "Invalid node for MarkupElementContainer";
-  }
+let MarkupElementContainer = Class({
+  extends: MarkupContainer,
+  initialize: function() {
+    MarkupContainer.prototype.initialize.apply(this, arguments);
+  },
+// function MarkupElementContainer(markupView, node) {
+//   MarkupContainer.prototype.initialize.call(this, markupView, node, "elementcontainer");
 
-  this.tagLine.appendChild(this.editor.elt);
+  init: function() {
+    this.markup.template("elementcontainer", this);
 
-  // Expanding/collapsing the node on dblclick of the whole tag-line element
-  this.expander.addEventListener("click", this._onToggle, false);
+    if (this.node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE) {
+      this.editor = new ElementEditor(this, this.node);
+    } else {
+      throw "Invalid node for MarkupElementContainer";
+    }
 
-  // Prepare the image preview tooltip data if any
-  this._prepareImagePreview();
-}
+    this.tagLine.appendChild(this.editor.elt);
 
-MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {
+    // Expanding/collapsing the node on dblclick of the whole tag-line element
+    this.expander.addEventListener("click", this._onToggle, false);
+
+    // Prepare the image preview tooltip data if any
+    this._prepareImagePreview();
+  },
+// }
+
+// MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {
   /**
    * True if the current node has children.  The MarkupView
    * will set this attribute for the MarkupContainer.
    */
   _hasChildren: false,
 
   get hasChildren() {
     return this._hasChildren;
