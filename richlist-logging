# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  249570f5e1ba0dcddb6b0b562a28a03a38a715ef
Bug 1503342 - Throw on access to .children for richlistbox (checked out 249570f5e1ba)

diff --git a/browser/base/content/test/urlbar/head.js b/browser/base/content/test/urlbar/head.js
--- a/browser/base/content/test/urlbar/head.js
+++ b/browser/base/content/test/urlbar/head.js
@@ -301,22 +301,22 @@ function promiseSpeculativeConnection(ht
     }
     return false;
   }, "Waiting for connection setup");
 }
 
 async function waitForAutocompleteResultAt(index) {
   let searchString = gURLBar.controller.searchString;
   await BrowserTestUtils.waitForCondition(
-    () => gURLBar.popup.richlistbox.children.length > index &&
-          gURLBar.popup.richlistbox.children[index].getAttribute("ac-text") == searchString,
+    () => gURLBar.popup.richlistbox.itemChildren.length > index &&
+          gURLBar.popup.richlistbox.itemChildren[index].getAttribute("ac-text") == searchString,
     `Waiting for the autocomplete result for "${searchString}" at [${index}] to appear`);
   // Ensure the addition is complete, for proper mouse events on the entries.
   await new Promise(resolve => window.requestIdleCallback(resolve, {timeout: 1000}));
-  return gURLBar.popup.richlistbox.children[index];
+  return gURLBar.popup.richlistbox.itemChildren[index];
 }
 
 function promiseSuggestionsPresent(msg = "") {
   return TestUtils.waitForCondition(suggestionsPresent,
                                     msg || "Waiting for suggestions");
 }
 
 function suggestionsPresent() {
diff --git a/browser/base/content/test/webextensions/browser_extension_sideloading.js b/browser/base/content/test/webextensions/browser_extension_sideloading.js
--- a/browser/base/content/test/webextensions/browser_extension_sideloading.js
+++ b/browser/base/content/test/webextensions/browser_extension_sideloading.js
@@ -206,17 +206,17 @@ add_task(async function() {
 
   win = await BrowserOpenAddonsMgr(VIEW);
 
   let list = win.document.getElementById("addon-list");
 
   // Make sure XBL bindings are applied
   list.clientHeight;
 
-  let item = list.children.find(_item => _item.value == ID3);
+  let item = list.itemChildren.find(_item => _item.value == ID3);
   ok(item, "Found entry for sideloaded extension in about:addons");
   item.scrollIntoView({behavior: "instant"});
 
   ok(BrowserTestUtils.is_visible(item._enableBtn), "Enable button is visible for sideloaded extension");
   ok(BrowserTestUtils.is_hidden(item._disableBtn), "Disable button is not visible for sideloaded extension");
 
   // When clicking enable we should see the permissions notification
   popupPromise = promisePopupNotificationShown("addon-webext-permissions");
diff --git a/browser/components/search/test/browser_426329.js b/browser/components/search/test/browser_426329.js
--- a/browser/components/search/test/browser_426329.js
+++ b/browser/components/search/test/browser_426329.js
@@ -28,17 +28,17 @@ function checkMenuEntries(expectedValues
   is(actualValues.length, expectedValues.length, "Checking length of expected menu");
   for (var i = 0; i < expectedValues.length; i++)
     is(actualValues[i], expectedValues[i], "Checking menu entry #" + i);
 }
 
 function getMenuEntries() {
   // Could perhaps pull values directly from the controller, but it seems
   // more reliable to test the values that are actually in the richlistbox?
-  return Array.map(searchBar.textbox.popup.richlistbox.children,
+  return Array.map(searchBar.textbox.popup.richlistbox.itemChildren,
                    item => item.getAttribute("ac-value"));
 }
 
 function countEntries(name, value) {
   return new Promise(resolve => {
     let count = 0;
     let obj = name && value ? {fieldname: name, value} : {};
     FormHistory.count(obj,
diff --git a/browser/components/search/test/browser_private_search_perwindowpb.js b/browser/components/search/test/browser_private_search_perwindowpb.js
--- a/browser/components/search/test/browser_private_search_perwindowpb.js
+++ b/browser/components/search/test/browser_private_search_perwindowpb.js
@@ -63,11 +63,11 @@ add_task(async function() {
   windowsToClose.forEach(function(win) {
     win.close();
   });
 });
 
 function getMenuEntries(searchBar) {
   // Could perhaps pull values directly from the controller, but it seems
   // more reliable to test the values that are actually in the richlistbox?
-  return Array.map(searchBar.textbox.popup.richlistbox.children,
+  return Array.map(searchBar.textbox.popup.richlistbox.itemChildren,
                    item => item.getAttribute("ac-value"));
 }
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -191,41 +191,41 @@
             this.selectItem(kids[0]);
           return val;
         ]]>
         </setter>
       </property>
 
       <!-- nsIDOMXULSelectControlElement -->
       <property name="itemCount" readonly="true"
-                onget="return this.children.length"/>
+                onget="return this.itemChildren.length"/>
 
       <!-- nsIDOMXULSelectControlElement -->
       <method name="getIndexOfItem">
         <parameter name="aItem"/>
         <body>
           <![CDATA[
             // don't search the children, if we're looking for none of them
             if (aItem == null)
               return -1;
             if (this._selecting && this._selecting.item == aItem)
               return this._selecting.index;
-            return this.children.indexOf(aItem);
+            return this.itemChildren.indexOf(aItem);
           ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULSelectControlElement -->
       <method name="getItemAtIndex">
         <parameter name="aIndex"/>
         <body>
           <![CDATA[
             if (this._selecting && this._selecting.index == aIndex)
               return this._selecting.item;
-            return this.children[aIndex] || null;
+            return this.itemChildren[aIndex] || null;
           ]]>
         </body>
       </method>
 
       <!-- nsIDOMXULMultiSelectControlElement -->
       <property name="selType"
                 onget="return this.getAttribute('seltype');"
                 onset="this.setAttribute('seltype', val); return val;"/>
@@ -513,40 +513,40 @@
               this._scrollbox.scrollToElement(item);
           ]]>
         </body>
       </method>
 
       <method name="getIndexOfFirstVisibleRow">
         <body>
           <![CDATA[
-            var children = this.children;
+            var children = this.itemChildren;
 
             for (var ix = 0; ix < children.length; ix++)
               if (this._isItemVisible(children[ix]))
                 return ix;
 
             return -1;
           ]]>
         </body>
       </method>
 
       <method name="getRowCount">
         <body>
           <![CDATA[
-            return this.children.length;
+            return this.itemChildren.length;
           ]]>
         </body>
       </method>
 
       <method name="scrollOnePage">
         <parameter name="aDirection"/> <!-- Must be -1 or 1 -->
         <body>
           <![CDATA[
-            var children = this.children;
+            var children = this.itemChildren;
 
             if (children.length == 0)
               return 0;
 
             // If nothing is selected, we just select the first element
             // at the extreme we're moving away from
             if (!this.currentItem)
               return aDirection == -1 ? children.length : 0;
@@ -579,16 +579,25 @@
             return index != this.currentIndex ? index - this.currentIndex : aDirection;
           ]]>
         </body>
       </method>
 
       <property name="children" readonly="true">
         <getter>
           <![CDATA[
+          console.trace();
+          throw new Error("Accessed .children property - fix this");
+          ]]>
+        </getter>
+      </property>
+
+      <property name="itemChildren" readonly="true">
+        <getter>
+          <![CDATA[
             let iface = Ci.nsIDOMXULSelectControlItemElement;
             let children = Array.from(this.childNodes)
                                 .filter(node => node instanceof iface);
             if (this.dir == "reverse" && this._mayReverse) {
               children.reverse();
             }
             return children;
           ]]>
@@ -665,17 +674,17 @@
 
             // if we have no previously current item or if the above check fails to
             // find the previous nodes (which causes it to clear selection)
             if (!this.currentItem && this.selectedCount == 0) {
               this.currentIndex = this._currentIndex ? this._currentIndex - 1 : 0;
 
               // cf. listbox constructor:
               // select items according to their attributes
-              var children = this.children;
+              var children = this.itemChildren;
               for (let i = 0; i < children.length; ++i) {
                 if (children[i].getAttribute("selected") == "true")
                   this.selectedItems.append(children[i]);
               }
             }
 
             if (this.selType != "multiple" && this.selectedCount == 0)
               this.selectedItem = this.currentItem;
diff --git a/toolkit/mozapps/extensions/content/extensions.js b/toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js
+++ b/toolkit/mozapps/extensions/content/extensions.js
@@ -1711,17 +1711,17 @@ var gCategories = {
     category.setAttribute("value", aView);
     category.setAttribute("class", "category");
     category.setAttribute("name", aName);
     category.setAttribute("tooltiptext", aName);
     category.setAttribute("priority", aPriority);
     category.setAttribute("hidden", aStartHidden);
 
     var node;
-    for (node of this.node.children) {
+    for (node of this.node.itemChildren) {
       var nodePriority = parseInt(node.getAttribute("priority"));
       // If the new type's priority is higher than this one then this is the
       // insertion point
       if (aPriority < nodePriority)
         break;
       // If the new type's priority is lower than this one then this is isn't
       // the insertion point
       if (aPriority > nodePriority)
