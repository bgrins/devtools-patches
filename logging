# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  cf2f865f55331bdc70690ca98cd6d396b1f210e6
Radio list gets cleared out in destructor.. even when disconnected

diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -7,16 +7,21 @@
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
 class MozRadiogroup extends MozBaseControl {
   constructor() {
     super();
 
+    let observer = new MutationObserver((m) => {
+      console.log(m);
+    });
+    observer.observe(this, { childList: true, subtree: true });
+
     this.addEventListener("mousedown", (event) => {
       if (this.disabled)
         event.preventDefault();
     });
 
     /**
      * keyboard navigation  Here's how keyboard navigation works in radio groups on Windows:
      * The group takes 'focus'
@@ -106,17 +111,29 @@ class MozRadiogroup extends MozBaseContr
       if (event.originalTarget != this) {
         return;
       }
       this.removeAttribute("focused");
       this.focusedItem = null;
     });
   }
 
+  disconnectedCallback() {
+    if (this.id == "doNotTrackRadioGroup") {
+      console.log("doNotTrackRadioGroup disconnected");
+    }
+  }
+
   connectedCallback() {
+    if (this.id == "doNotTrackRadioGroup") {
+      console.log("doNotTrackRadioGroup connected");
+      if (this._radioChildren) {
+        console.log("CONNECTED WITH CHILDREN!", this, this._radioChildren.length, this.querySelectorAll("radio").length)
+      }
+    }
     this._radioChildren = null;
 
     if (this.getAttribute("disabled") == "true")
       this.disabled = true;
 
     var children = this._getRadioChildren();
     var length = children.length;
     for (var i = 0; i < length; i++) {
@@ -302,16 +319,24 @@ class MozRadiogroup extends MozBaseContr
       // XXX check for display/visibility props too
 
       this.selectedItem = children[i];
       children[i].doCommand();
     }
   }
 
   _getRadioChildren() {
+
+    if (this.id == "doNotTrackRadioGroup") {
+      if (!this._radioChildren) {
+        console.log("_getRadioChildren with no children", this, this._radioChildren && this._radioChildren.length, this.querySelectorAll("radio").length)
+      }
+    }
+
+
     if (this._radioChildren)
       return this._radioChildren;
 
     var radioChildren = [];
 
     if (this.hasChildNodes()) {
       return this._radioChildren = [...this.querySelectorAll("radio")];
     }
@@ -339,16 +364,17 @@ class MozRadiogroup extends MozBaseContr
     return (index >= 0 && index < children.length) ? children[index] : null;
   }
 
   appendItem(label, value) {
     var radio = document.createXULElement("radio");
     radio.setAttribute("label", label);
     radio.setAttribute("value", value);
     this.appendChild(radio);
+    console.log("appenditem null")
     this._radioChildren = null;
     return radio;
   }
 }
 
 MozXULElement.implementCustomInterface(MozRadiogroup, [Ci.nsIDOMXULSelectControlElement]);
 
 customElements.define("radiogroup", MozRadiogroup);
diff --git a/toolkit/content/widgets/radio.xml b/toolkit/content/widgets/radio.xml
--- a/toolkit/content/widgets/radio.xml
+++ b/toolkit/content/widgets/radio.xml
@@ -19,26 +19,30 @@
       </xul:hbox>
     </content>
 
     <implementation implements="nsIDOMXULSelectControlItemElement">
       <constructor>
         <![CDATA[
           // Just clear out the parent's cached list of radio children
           var control = this.control;
-          if (control)
-            control._radioChildren = null;
+          //if (control)
+          //  control._radioChildren = null;
         ]]>
       </constructor>
       <destructor>
         <![CDATA[
           if (!this.control)
             return;
 
           var radioList = this.control._radioChildren;
+          if (this.control.id == "doNotTrackRadioGroup") {
+            console.log("RADIO DESTRUCTORS", radioList.length, this.control.isConnected, this.isConnected);
+          }
+
           if (!radioList)
             return;
           for (var i = 0; i < radioList.length; ++i) {
             if (radioList[i] == this) {
               radioList.splice(i, 1);
               return;
             }
           }
