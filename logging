# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e70096774bb676678e501dce24a57ff0b58b222e

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1166,22 +1166,24 @@ function _loadURIWithFlags(browser, uri,
     }
   }
 }
 
 // Starts a new load in the browser first switching the browser to the correct
 // process
 function LoadInOtherProcess(browser, loadOptions, historyIndex = -1) {
   let tab = gBrowser.getTabForBrowser(browser);
+  dump("\nLoadInOtherProcess: " + browser + " " + tab + "\n");
   SessionStore.navigateAndRestore(tab, loadOptions, historyIndex);
 }
 
 // Called when a docshell has attempted to load a page in an incorrect process.
 // This function is responsible for loading the page in the correct process.
 function RedirectLoad({ target: browser, data }) {
+  dump("\nRedirectLoad: " + browser + " " + data + "\n");
   if (browser.getAttribute("isPreloadBrowser") == "true") {
     browser.removeAttribute("isPreloadBrowser");
     data.loadOptions.newFrameloader = true;
   }
 
   if (data.loadOptions.reloadInFreshProcess) {
     // Convert the fresh process load option into a large allocation remote type
     // to use common processing from this point.
diff --git a/browser/base/content/tab-content.js b/browser/base/content/tab-content.js
--- a/browser/base/content/tab-content.js
+++ b/browser/base/content/tab-content.js
@@ -709,30 +709,33 @@ if (Services.appinfo.processType == Serv
 
 var WebBrowserChrome = {
   onBeforeLinkTraversal(originalTarget, linkURI, linkNode, isAppTab) {
     return BrowserUtils.onBeforeLinkTraversal(originalTarget, linkURI, linkNode, isAppTab);
   },
 
   // Check whether this URI should load in the current process
   shouldLoadURI(aDocShell, aURI, aReferrer, aHasPostData, aTriggeringPrincipal) {
+    dump(`\ntab-content: shouldLoadURI\n`);
     if (!E10SUtils.shouldLoadURI(aDocShell, aURI, aReferrer, aHasPostData)) {
+      dump(`\ntab-content: shouldLoadURI redirecting!\n`);
       E10SUtils.redirectLoad(aDocShell, aURI, aReferrer, aTriggeringPrincipal, false);
       return false;
     }
 
     return true;
   },
 
   shouldLoadURIInThisProcess(aURI) {
     return E10SUtils.shouldLoadURIInThisProcess(aURI);
   },
 
   // Try to reload the currently active or currently loading page in a new process.
   reloadInFreshProcess(aDocShell, aURI, aReferrer, aTriggeringPrincipal, aLoadFlags) {
+    dump(`\ntab-content: reloadInFreshProcess\n`);
     E10SUtils.redirectLoad(aDocShell, aURI, aReferrer, aTriggeringPrincipal, true, aLoadFlags);
     return true;
   },
 
   startPrerenderingDocument(aHref, aReferrer, aTriggeringPrincipal) {
     if (PrerenderContentHandler.initialized) {
       PrerenderContentHandler.startPrerenderingDocument(aHref, aReferrer, aTriggeringPrincipal);
     }
diff --git a/browser/modules/E10SUtils.jsm b/browser/modules/E10SUtils.jsm
--- a/browser/modules/E10SUtils.jsm
+++ b/browser/modules/E10SUtils.jsm
@@ -252,16 +252,18 @@ this.E10SUtils = {
     }
 
     // If the URI can be loaded in the current process then continue
     return this.shouldLoadURIInThisProcess(aURI);
   },
 
   redirectLoad(aDocShell, aURI, aReferrer, aTriggeringPrincipal, aFreshProcess, aFlags) {
     // Retarget the load to the correct process
+    dump(`\nE10SUtils:redirectLoad ${aDocShell} ${aURI} \n`);
+    console.trace();
     let messageManager = aDocShell.QueryInterface(Ci.nsIInterfaceRequestor)
                                   .getInterface(Ci.nsIContentFrameMessageManager);
     let sessionHistory = aDocShell.getInterface(Ci.nsIWebNavigation).sessionHistory;
 
     messageManager.sendAsyncMessage("Browser:LoadURI", {
       loadOptions: {
         uri: aURI.spec,
         flags: aFlags || Ci.nsIWebNavigation.LOAD_FLAGS_NONE,
diff --git a/devtools/client/framework/test/browser_toolbox_target.js b/devtools/client/framework/test/browser_toolbox_target.js
--- a/devtools/client/framework/test/browser_toolbox_target.js
+++ b/devtools/client/framework/test/browser_toolbox_target.js
@@ -11,50 +11,52 @@ add_task(function *() {
   // iframe loads the document to debug
   let iframe = document.createElement("browser");
   iframe.setAttribute("type", "content");
   document.documentElement.appendChild(iframe);
 
   let onLoad = once(iframe, "load", true);
   iframe.setAttribute("src", "data:text/html,document to debug");
   yield onLoad;
-  is(iframe.contentWindow.document.body.innerHTML, "document to debug");
+  is(iframe.contentWindow.document.body.innerHTML, "document to debug", "has html");
+
+  yield new Promise(r=>r);
 
   // toolbox loads the toolbox document
-  let toolboxIframe = document.createElement("iframe");
-  document.documentElement.appendChild(toolboxIframe);
+  // let toolboxIframe = document.createElement("iframe");
+  // document.documentElement.appendChild(toolboxIframe);
 
-  // Important step to define which target to debug
-  toolboxIframe.target = iframe;
+  // // Important step to define which target to debug
+  // toolboxIframe.target = iframe;
 
-  let onToolboxReady = gDevTools.once("toolbox-ready");
+  // let onToolboxReady = gDevTools.once("toolbox-ready");
 
-  onLoad = once(toolboxIframe, "load", true);
-  toolboxIframe.setAttribute("src", "about:devtools-toolbox?target");
-  yield onLoad;
+  // onLoad = once(toolboxIframe, "load", true);
+  // toolboxIframe.setAttribute("src", "about:devtools-toolbox?target");
+  // yield onLoad;
 
-  // Also wait for toolbox-ready, as toolbox document load isn't enough, there
-  // is plenty of asynchronous steps during toolbox load
-  info("Waiting for toolbox-ready");
-  let toolbox = yield onToolboxReady;
+  // // Also wait for toolbox-ready, as toolbox document load isn't enough, there
+  // // is plenty of asynchronous steps during toolbox load
+  // info("Waiting for toolbox-ready");
+  // let toolbox = yield onToolboxReady;
 
-  let onToolboxDestroyed = gDevTools.once("toolbox-destroyed");
-  let onTabActorDetached = once(toolbox.target.client, "tabDetached");
+  // let onToolboxDestroyed = gDevTools.once("toolbox-destroyed");
+  // let onTabActorDetached = once(toolbox.target.client, "tabDetached");
 
-  info("Removing the iframes");
-  toolboxIframe.remove();
+  // info("Removing the iframes");
+  // toolboxIframe.remove();
 
-  // And wait for toolbox-destroyed as toolbox unload is also full of
-  // asynchronous operation that outlast unload event
-  info("Waiting for toolbox-destroyed");
-  yield onToolboxDestroyed;
-  info("Toolbox destroyed");
+  // // And wait for toolbox-destroyed as toolbox unload is also full of
+  // // asynchronous operation that outlast unload event
+  // info("Waiting for toolbox-destroyed");
+  // yield onToolboxDestroyed;
+  // info("Toolbox destroyed");
 
-  // Also wait for tabDetached. Toolbox destroys the Target which calls
-  // TabActor.detach(). But Target doesn't wait for detach's end to resolve.
-  // Whereas it is quite important as it is a significant part of toolbox
-  // cleanup. If we do not wait for it and starts removing debugged document,
-  // the actor is still considered as being attached and continues processing
-  // events.
-  yield onTabActorDetached;
+  // // Also wait for tabDetached. Toolbox destroys the Target which calls
+  // // TabActor.detach(). But Target doesn't wait for detach's end to resolve.
+  // // Whereas it is quite important as it is a significant part of toolbox
+  // // cleanup. If we do not wait for it and starts removing debugged document,
+  // // the actor is still considered as being attached and continues processing
+  // // events.
+  // yield onTabActorDetached;
 
-  iframe.remove();
+  // iframe.remove();
 });
