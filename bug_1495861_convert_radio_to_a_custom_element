# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1539108416 25200
#      Tue Oct 09 11:06:56 2018 -0700
# Node ID 2ac4c6e5fdba478d951843c58c94ee1e7e2f9032
# Parent  ec5a6325325ab4d374a20646cb71e0b271050336
Bug 1495861 - Convert <radio> to a Custom Element

Differential Revision: https://phabricator.services.mozilla.com/D8121

diff --git a/accessible/generic/RootAccessible.cpp b/accessible/generic/RootAccessible.cpp
--- a/accessible/generic/RootAccessible.cpp
+++ b/accessible/generic/RootAccessible.cpp
@@ -145,18 +145,18 @@ const char* const kEventTypes[] = {
     // Fired when value changes immediately, wether or not focused changed.
     "ValueChange", "AlertActive", "TreeRowCountChanged", "TreeInvalidated",
     // add ourself as a OpenStateChange listener (custom event fired in
     // tree.xml)
     "OpenStateChange",
     // add ourself as a CheckboxStateChange listener (custom event fired in
     // HTMLInputElement.cpp)
     "CheckboxStateChange",
-    // add ourself as a RadioStateChange Listener ( custom event fired in in
-    // HTMLInputElement.cpp  & radio.xml)
+    // add ourself as a RadioStateChange Listener (custom event fired in in
+    // HTMLInputElement.cpp & radio.js)
     "RadioStateChange", "popupshown", "popuphiding", "DOMMenuInactive",
     "DOMMenuItemActive", "DOMMenuItemInactive", "DOMMenuBarActive",
     "DOMMenuBarInactive"};
 
 nsresult RootAccessible::AddEventListeners() {
   // EventTarget interface allows to register event listeners to
   // receive untrusted events (synthetic events generated by untrusted code).
   // For example, XBL bindings implementations for elements that are hosted in
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -66,17 +66,16 @@ toolkit.jar:
    content/global/bindings/calendar.js         (widgets/calendar.js)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
 *  content/global/bindings/dialog.xml          (widgets/dialog.xml)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/menu.xml            (widgets/menu.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
-   content/global/bindings/radio.xml           (widgets/radio.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
    content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
    content/global/bindings/text.xml            (widgets/text.xml)
    content/global/elements/text.js             (widgets/text.js)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -1,17 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
-{
+(() => {
 class MozRadiogroup extends MozElements.BaseControl {
   constructor() {
     super();
 
     this.addEventListener("mousedown", (event) => {
       if (this.disabled)
         event.preventDefault();
     });
@@ -110,17 +110,27 @@ class MozRadiogroup extends MozElements.
     });
   }
 
   connectedCallback() {
     if (this.delayConnectedCallback()) {
       return;
     }
 
+    // When this is called via `connectedCallback` there are two main variations:
+    //   1) The radiogroup and radio children are defined in markup.
+    //   2) We are appending a DocumentFragment
+    // In both cases, the <radiogroup> connectedCallback fires first. But in (2),
+    // the children <radio>s won't be upgraded yet, so r.control will be undefined.
+    // To avoid churn in this case where we would have to reinitialize the list as each
+    // child radio gets upgraded as a result of init(), ignore the resulting calls
+    // to radioChildConstructed.
+    this.ignoreRadioChildConstruction = true;
     this.init();
+    this.ignoreRadioChildConstruction = false;
     if (!this.value) {
       this.selectedIndex = 0;
     }
   }
 
   init() {
     this._radioChildren = null;
 
@@ -137,27 +147,28 @@ class MozRadiogroup extends MozElements.
     }
 
     var value = this.value;
     if (value)
       this.value = value;
   }
 
   /**
-   * Called when a new <radio> gets added and XBL construction happens on
-   * it. Sometimes the XBL construction happens after the <radiogroup> has
-   * already been added to the DOM. This can happen due to asynchronous XBL
-   * construction (see Bug 1496137), or just due to normal DOM appending after
-   * the <radiogroup> is created. When this happens, reinitialize the UI if
-   * necessary to make sure the state is consistent.
+   * Called when a new <radio> gets added to an already connected radiogroup.
+   * This can happen due to DOM getting appended after the <radiogroup> is created.
+   * When this happens, reinitialize the UI if necessary to make sure the state is
+   * consistent.
    *
    * @param {DOMNode} child
    *                  The <radio> element that got added
    */
   radioChildConstructed(child) {
+    if (this.ignoreRadioChildConstruction) {
+      return;
+    }
     if (!this._radioChildren || !this._radioChildren.includes(child)) {
       this.init();
     }
   }
 
   set value(val) {
     this.setAttribute("value", val);
     var children = this._getRadioChildren();
@@ -343,34 +354,35 @@ class MozRadiogroup extends MozElements.
       children[i].doCommand();
     }
   }
 
   _getRadioChildren() {
     if (this._radioChildren)
       return this._radioChildren;
 
-    var radioChildren = [];
-
+    let radioChildren = [];
     if (this.hasChildNodes()) {
-      return this._radioChildren = [...this.querySelectorAll("radio")]
-        .filter(r => r.control == this);
+      for (let radio of this.querySelectorAll("radio")) {
+        customElements.upgrade(radio);
+        if (radio.control == this) {
+          radioChildren.push(radio);
+        }
+      }
+    } else {
+      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+      for (let radio of this.ownerDocument.getElementsByAttribute("group", this.id)) {
+        if ((radio.namespaceURI == XUL_NS) &&
+            (radio.localName == "radio")) {
+          customElements.upgrade(radio);
+          radioChildren.push(radio);
+        }
+      }
     }
 
-    // We don't have child nodes.
-    const XUL_NS = "http://www.mozilla.org/keymaster/" +
-      "gatekeeper/there.is.only.xul";
-
-    var elems = this.ownerDocument.getElementsByAttribute("group", this.id);
-    for (var i = 0; i < elems.length; i++) {
-      if ((elems[i].namespaceURI == XUL_NS) &&
-        (elems[i].localName == "radio")) {
-        radioChildren.push(elems[i]);
-      }
-    }
     return this._radioChildren = radioChildren;
   }
 
   getIndexOfItem(item) {
     return this._getRadioChildren().indexOf(item);
   }
 
   getItemAtIndex(index) {
@@ -388,9 +400,118 @@ class MozRadiogroup extends MozElements.
 }
 
 MozXULElement.implementCustomInterface(MozRadiogroup, [
   Ci.nsIDOMXULSelectControlElement,
   Ci.nsIDOMXULRadioGroupElement,
 ]);
 
 customElements.define("radiogroup", MozRadiogroup);
+
+let gRadioFrag = null;
+function getRadioFragment() {
+  if (!gRadioFrag) {
+    gRadioFrag = MozXULElement.parseXULToFragment(`
+    <image class="radio-check"></image>
+    <hbox class="radio-label-box" align="center" flex="1">
+      <image class="radio-icon"></image>
+      <label class="radio-label" flex="1"></label>
+    </hbox>
+    `);
+  }
+  return document.importNode(gRadioFrag, true);
 }
+
+class MozRadio extends MozElements.BaseText {
+  static get inheritedAttributes() {
+    return {
+      ".radio-check": "disabled,selected",
+      ".radio-label": "text=label,accesskey,crop",
+      ".radio-icon": "src",
+    };
+  }
+
+  constructor() {
+    super();
+    this.addEventListener("click", (event) => {
+      if (!this.disabled)
+        this.control.selectedItem = this;
+    });
+
+    this.addEventListener("mousedown", (event) => {
+      if (!this.disabled)
+        this.control.focusedItem = this;
+    });
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    if (!this.connectedOnce) {
+      this.connectedOnce = true;
+      // If the caller didn't provide custom content then append the default:
+      if (!this.firstElementChild) {
+        this.appendChild(getRadioFragment());
+        this.initializeAttributeInheritance();
+      }
+    }
+
+    var control = this.control;
+    if (control) {
+      control.radioChildConstructed(this);
+    }
+  }
+
+  disconnectedCallback() {
+    if (!this.control)
+      return;
+
+    var radioList = this.control._radioChildren;
+    if (!radioList)
+      return;
+    for (var i = 0; i < radioList.length; ++i) {
+      if (radioList[i] == this) {
+        radioList.splice(i, 1);
+        return;
+      }
+    }
+  }
+
+  set value(val) {
+    this.setAttribute("value", val);
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+
+  get selected() {
+    return this.hasAttribute("selected");
+  }
+
+  get radioGroup() {
+    return this.control;
+  }
+
+  get control() {
+    var radiogroup = this.closest("radiogroup");
+    if (radiogroup) {
+      return radiogroup;
+    }
+
+    var group = this.getAttribute("group");
+    if (!group) {
+      return null;
+    }
+
+    var parent = this.ownerDocument.getElementById(group);
+    if (!parent || parent.localName != "radiogroup") {
+      parent = null;
+    }
+    return parent;
+  }
+}
+
+MozXULElement.implementCustomInterface(MozRadio, [Ci.nsIDOMXULSelectControlItemElement]);
+customElements.define("radio", MozRadio);
+})();
diff --git a/toolkit/content/widgets/radio.xml b/toolkit/content/widgets/radio.xml
deleted file mode 100644
--- a/toolkit/content/widgets/radio.xml
+++ /dev/null
@@ -1,96 +0,0 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-
-<bindings id="radioBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
-
-  <binding id="radio"
-    extends="chrome://global/content/bindings/general.xml#basetext">
-    <content>
-      <xul:image class="radio-check" xbl:inherits="disabled,selected"/>
-      <xul:hbox class="radio-label-box" align="center" flex="1">
-        <xul:image class="radio-icon" xbl:inherits="src"/>
-        <xul:label class="radio-label" xbl:inherits="xbl:text=label,accesskey,crop" flex="1"/>
-      </xul:hbox>
-    </content>
-
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-        <![CDATA[
-          // Just clear out the parent's cached list of radio children
-          var control = this.control;
-          window.customElements.upgrade(control);
-          if (control)
-            control.radioChildConstructed(this);
-        ]]>
-      </constructor>
-      <destructor>
-        <![CDATA[
-          if (!this.control)
-            return;
-
-          var radioList = this.control._radioChildren;
-          if (!radioList)
-            return;
-          for (var i = 0; i < radioList.length; ++i) {
-            if (radioList[i] == this) {
-              radioList.splice(i, 1);
-              return;
-            }
-          }
-        ]]>
-      </destructor>
-      <property name="value" onset="this.setAttribute('value', val); return val;"
-                             onget="return this.getAttribute('value');"/>
-      <property name="selected" readonly="true">
-        <getter>
-          <![CDATA[
-            return this.hasAttribute("selected");
-          ]]>
-        </getter>
-      </property>
-      <property name="radioGroup" readonly="true" onget="return this.control"/>
-      <property name="control" readonly="true">
-        <getter>
-        <![CDATA[
-          var radiogroup = this.closest("radiogroup");
-          if (radiogroup) {
-            return radiogroup;
-          }
-
-          var group = this.getAttribute("group");
-          if (!group) {
-            return null;
-          }
-
-          var parent = this.ownerDocument.getElementById(group);
-          if (!parent || parent.localName != "radiogroup") {
-            parent = null;
-          }
-          return parent;
-        ]]>
-        </getter>
-      </property>
-    </implementation>
-    <handlers>
-      <handler event="click" button="0">
-        <![CDATA[
-          if (!this.disabled)
-            this.control.selectedItem = this;
-         ]]>
-      </handler>
-
-      <handler event="mousedown" button="0">
-        <![CDATA[
-          if (!this.disabled)
-            this.control.focusedItem = this;
-         ]]>
-      </handler>
-    </handlers>
-  </binding>
-</bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -181,20 +181,16 @@ popupnotification {
 }
 
 /********** radio **********/
 
 radiogroup {
   -moz-box-orient: vertical;
 }
 
-radio {
-  -moz-binding: url("chrome://global/content/bindings/radio.xml#radio");
-}
-
 /******** groupbox *********/
 
 groupbox {
   -moz-box-orient: vertical;
 }
 
 /******** draggable elements *********/
 
