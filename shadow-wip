# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c5461973d6ee7845b3f560c05e1502429fd63184
Bug 1053898 - WIP - nest shadow dom inside of shadow root in markup view

diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -3081,24 +3081,35 @@ function DocumentWalker(node, rootWin,
   // be skipped due to a filter).
   this.walker.currentNode = this.getStartingNode(node, skipTo);
 }
 
 DocumentWalker.prototype = {
   get whatToShow() {
     return this.walker.whatToShow;
   },
+  get showAnonymousContent() {
+    return this.walker.showAnonymousContent;
+  },
   get currentNode() {
     return this.walker.currentNode;
   },
   set currentNode(val) {
     this.walker.currentNode = val;
   },
 
   parentNode: function () {
+    if (this.showAnonymousContent) {
+      let node = this.walker.currentNode;
+      if (node && node.host) {
+        this.walker.currentNode = node.host;
+        return node.host;
+      }
+    }
+
     return this.walker.parentNode();
   },
 
   nextNode: function () {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
@@ -3112,30 +3123,46 @@ DocumentWalker.prototype = {
   },
 
   firstChild: function () {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
 
+    // This won't properly handle ::before
+    if (this.showAnonymousContent) {
+      if (node.shadowRoot) {
+        this.walker.currentNode = node.shadowRoot;
+        return node.shadowRoot;
+      }
+    }
+
     let firstChild = this.walker.firstChild();
     while (firstChild && this.isSkippedNode(firstChild)) {
       firstChild = this.walker.nextSibling();
     }
 
     return firstChild;
   },
 
   lastChild: function () {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
 
+    // This won't properly handle ::after
+    if (this.showAnonymousContent) {
+      if (node.shadowRoot) {
+        this.walker.currentNode = node.shadowRoot;
+        return node.shadowRoot;
+      }
+    }
+
     let lastChild = this.walker.lastChild();
     while (lastChild && this.isSkippedNode(lastChild)) {
       lastChild = this.walker.previousSibling();
     }
 
     return lastChild;
   },
 
