# HG changeset patch
# User Tomasz Ko≈Çodziejski <tkolodziejski@gmail.com>

Bug 1094622 - Deleting node in inspector now selects previous sibling and not parent. r=bgrins

---
 browser/devtools/markupview/markup-view.js         | 15 +++++----
 .../test/browser_markupview_tag_edit_04.js         | 38 +++++++++++++++-------
 browser/devtools/markupview/test/head.js           |  2 +-
 toolkit/devtools/server/actors/inspector.js        | 32 +++++++++++++++---
 4 files changed, 63 insertions(+), 24 deletions(-)

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
index 94fc46a..966d854 100644
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -521,16 +521,17 @@ MarkupView.prototype = {
     // Retain the node so we can undo this...
     this.walker.retainNode(aNode).then(() => {
       let parent = aNode.parentNode();
-      let sibling = null;
+      let nextSibling = null;
       this.undo.do(() => {
-        if (container.selected) {
-          this.navigate(this.getContainer(parent));
-        }
-        this.walker.removeNode(aNode).then(nextSibling => {
-          sibling = nextSibling;
+        this.walker.removeNode(aNode).then(siblings => {
+          let focusNode = siblings.previousSibling || parent;
+          nextSibling = siblings.nextSibling;
+          if (container.selected) {
+            this.navigate(this.getContainer(focusNode));
+          }
         });
       }, () => {
-        this.walker.insertBefore(aNode, parent, sibling);
+        this.walker.insertBefore(aNode, parent, nextSibling);
       });
     }).then(null, console.error);
   },
diff --git a/browser/devtools/markupview/test/browser_markupview_tag_edit_04.js b/browser/devtools/markupview/test/browser_markupview_tag_edit_04.js
index 2fad76e..6e0a3dc 100644
--- a/browser/devtools/markupview/test/browser_markupview_tag_edit_04.js
+++ b/browser/devtools/markupview/test/browser_markupview_tag_edit_04.js
@@ -4,27 +4,41 @@
 
 "use strict";
 
-// Tests that a node can be deleted from the markup-view with the delete key
+// Tests that a node can be deleted from the markup-view with the delete key.
+// Also checks that after deletion the correct element is highlighted.
+// The previous sibling is preferred, but the parent is a fallback.
 
-const TEST_URL = "data:text/html,<div id='delete-me'></div>";
+const TEST_URL = "data:text/html,<div id='parent'><div id='first'></div><div id='second'></div><div id='third'></div></div>";
 
-let test = asyncTest(function*() {
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
-
-  info("Selecting the test node by clicking on it to make sure it receives focus");
-  let node = content.document.querySelector("#delete-me");
-  yield clickContainer("#delete-me", inspector);
+function* checkDeleteAndSelection(inspector, nodeSelector, focusedNodeSelector) {
+  yield selectNode(nodeSelector, inspector);
+  yield clickContainer(nodeSelector, inspector);
 
-  info("Deleting the element with the keyboard");
+  info("Deleting the element \"" + nodeSelector + "\" with the keyboard");
   let mutated = inspector.once("markupmutation");
   EventUtils.sendKey("delete", inspector.panelWin);
-  yield mutated;
+
+  yield Promise.all([mutated, inspector.once("inspector-updated")]);
+
+  let nodeFront = yield getNodeFront(focusedNodeSelector, inspector);
+  is(inspector.selection.nodeFront, nodeFront,
+    focusedNodeSelector + " should be selected after " + nodeSelector + " node gets deleted.");
 
   info("Checking that it's gone, baby gone!");
-  ok(!content.document.querySelector("#delete-me"), "The test node does not exist");
+  ok(!content.document.querySelector(nodeSelector), "The test node does not exist");
 
   yield undoChange(inspector);
-  ok(content.document.querySelector("#delete-me"), "The test node is back!");
+  ok(content.document.querySelector(nodeSelector), "The test node is back!");
+}
+
+let test = asyncTest(function*() {
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  info("Selecting the test node by clicking on it to make sure it receives focus");
+
+  yield checkDeleteAndSelection(inspector, "#first", "#parent");
+  yield checkDeleteAndSelection(inspector, "#second", "#first");
+  yield checkDeleteAndSelection(inspector, "#third", "#second");
 
   yield inspector.once("inspector-updated");
 });
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
index 8ea892f..b16cb6b 100644
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -252,7 +252,7 @@ let clickContainer = Task.async(function*(selector, inspector) {
   let nodeFront = yield getNodeFront(selector, inspector);
   let container = getContainerForNodeFront(nodeFront, inspector);
 
-  let updated = inspector.once("inspector-updated");
+  let updated = container.selected ? promise.resolve() : inspector.once("inspector-updated");
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {type: "mousedown"},
     inspector.markup.doc.defaultView);
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {type: "mouseup"},
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
index 265cb18..869aba5 100644
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -2132,19 +2132,24 @@ var WalkerActor = protocol.ActorClass({
          node.rawNode.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE) {
       throw Error("Cannot remove document or document elements.");
     }
+    let previousSibling = this.previousSibling(node);
     let nextSibling = this.nextSibling(node);
     if (node.rawNode.parentNode) {
       node.rawNode.parentNode.removeChild(node.rawNode);
       // Mutation events will take care of the rest.
     }
-    return nextSibling;
+    return {
+      previousSibling: previousSibling,
+      nextSibling: nextSibling,
+    };
   }, {
     request: {
       node: Arg(0, "domnode")
     },
-    response: {
+    response: RetVal(types.addDictType("siblings", {
+      previousSibling: RetVal("nullable:domnode"),
       nextSibling: RetVal("nullable:domnode")
-    }
+    })),
   }),
 
   /**
@@ -2876,7 +2881,26 @@ var WalkerFront = exports.WalkerFront = protocol.FrontClass(WalkerActor, {
       walkerActor._orphaned.add(this.conn._transport._serverConnection.getActor(top.actorID));
     }
     return returnNode;
-  }
+  },
+
+  removeNode: protocol.custom(function(node) {
+    return this._removeNode(node).then(siblings => {
+      if (siblings && siblings.previousSibling !== undefined) {
+        return siblings;
+      }
+      // For old server `removeNode` returns `nextSibling`.
+      // So we manually retrieve `previousSibling`.
+      let nextSibling = siblings;
+      return this.previousSibling(nextSibling).then(previousSibling => {
+        return {
+          previousSibling: previousSibling,
+          nextSibling: nextSibling,
+        };
+      });
+    });
+  }, {
+    impl: "_removeNode"
+  }),
 });
 
 /**

