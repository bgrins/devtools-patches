# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a375bdb7fb5d38a5d8829d226a1a3090d2952d5e
Bug 1145784 - Trying out some different things with graph movement

diff --git a/browser/devtools/shared/widgets/Graphs.jsm b/browser/devtools/shared/widgets/Graphs.jsm
--- a/browser/devtools/shared/widgets/Graphs.jsm
+++ b/browser/devtools/shared/widgets/Graphs.jsm
@@ -4,16 +4,17 @@
 "use strict";
 
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 const promise = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
 const {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 const {EventEmitter} = Cu.import("resource://gre/modules/devtools/event-emitter.js", {});
+let {console} = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 
 this.EXPORTED_SYMBOLS = [
   "GraphCursor",
   "GraphArea",
   "GraphAreaDragger",
   "GraphAreaResizer",
   "AbstractCanvasGraph",
   "LineGraphWidget",
@@ -152,16 +153,17 @@ this.AbstractCanvasGraph = function(pare
   this._ready = promise.defer();
 
   this._uid = "canvas-graph-" + Date.now();
   this._renderTargets = new Map();
 
   AbstractCanvasGraph.createIframe(GRAPH_SRC, parent, iframe => {
     this._iframe = iframe;
     this._window = iframe.contentWindow;
+    this._topWindow = this._window.top;
     this._document = iframe.contentDocument;
     this._pixelRatio = sharpness || this._window.devicePixelRatio;
 
     let container = this._container = this._document.getElementById("graph-container");
     container.className = name + "-widget-container graph-widget-container";
 
     let canvas = this._canvas = this._document.getElementById("graph-canvas");
     canvas.className = name + "-widget-canvas graph-widget-canvas";
@@ -189,17 +191,16 @@ this.AbstractCanvasGraph = function(pare
     this._onMouseUp = this._onMouseUp.bind(this);
     this._onMouseWheel = this._onMouseWheel.bind(this);
     this._onMouseOut = this._onMouseOut.bind(this);
     this._onResize = this._onResize.bind(this);
     this.refresh = this.refresh.bind(this);
 
     this._window.addEventListener("mousemove", this._onMouseMove);
     this._window.addEventListener("mousedown", this._onMouseDown);
-    this._window.addEventListener("mouseup", this._onMouseUp);
     this._window.addEventListener("MozMousePixelScroll", this._onMouseWheel);
     this._window.addEventListener("mouseout", this._onMouseOut);
 
     let ownerWindow = this._parent.ownerDocument.defaultView;
     ownerWindow.addEventListener("resize", this._onResize);
 
     this._animationId = this._window.requestAnimationFrame(this._onAnimationFrame);
 
@@ -228,19 +229,20 @@ AbstractCanvasGraph.prototype = {
   },
 
   /**
    * Destroys this graph.
    */
   destroy: Task.async(function *() {
     yield this.ready();
 
+    this._topWindow.removeEventListener("mousemove", this._onMouseMove);
+    this._topWindow.removeEventListener("mouseup", this._onMouseUp);
     this._window.removeEventListener("mousemove", this._onMouseMove);
     this._window.removeEventListener("mousedown", this._onMouseDown);
-    this._window.removeEventListener("mouseup", this._onMouseUp);
     this._window.removeEventListener("MozMousePixelScroll", this._onMouseWheel);
     this._window.removeEventListener("mouseout", this._onMouseOut);
 
     let ownerWindow = this._parent.ownerDocument.defaultView;
     if (ownerWindow) {
       ownerWindow.removeEventListener("resize", this._onResize);
     }
 
@@ -926,52 +928,58 @@ AbstractCanvasGraph.prototype = {
    * Checks whether a region is hovered.
    * @return boolean
    */
   _isHoveringRegion: function() {
     return !!this.getHoveredRegion();
   },
 
   /**
-   * Gets the offset of this graph's container relative to the owner window.
-   *
-   * @return object
-   *         The { left, top } offset.
+   * Given a MouseEvent, make it relative to this._canvas.
+   * @return object {mouseX,mouseY}
    */
-  _getContainerOffset: function() {
-    let node = this._canvas;
-    let x = 0;
-    let y = 0;
+  _getRelativeEventCoordinates: function(e) {
+    let quad = this._canvas.getBoxQuads({
+      relativeTo: this._topWindow.document
+    })[0];
 
-    while (node = node.offsetParent) {
-      x += node.offsetLeft;
-      y += node.offsetTop;
-    }
+    let x = (e.screenX - this._topWindow.screenX) - quad.p1.x;
+    let y = (e.screenY - this._topWindow.screenY) - quad.p1.y;
 
-    return { left: x, top: y };
+    // Don't allow the event coordinates to be bigger than the canvas
+    // or less than 0.
+    let maxX = quad.p2.x - quad.p1.x;
+    let maxY = quad.p3.y - quad.p1.y;
+    let mouseX = Math.max(0, Math.min(x, maxX)) * this._pixelRatio;
+    let mouseY = Math.max(0, Math.min(x, maxY)) * this._pixelRatio;
+
+    return {mouseX,mouseY};
   },
 
   /**
    * Listener for the "mousemove" event on the graph's container.
    */
   _onMouseMove: function(e) {
     let resizer = this._selectionResizer;
     let dragger = this._selectionDragger;
 
+    // Need to stop propagation here, since this function can be bound
+    // to both this._window and this._topWindow.  It's only attached to
+    // this._topWindow during a drag event, though.
+    e.stopPropagation();
+
     // If a mouseup happened outside the toolbox and the current operation
     // is causing the selection changed, then end it.
     if (e.buttons == 0 && (this.hasSelectionInProgress() ||
                            resizer.margin != null ||
                            dragger.origin != null)) {
       return this._onMouseUp(e);
     }
 
-    let offset = this._getContainerOffset();
-    let mouseX = (e.clientX - offset.left) * this._pixelRatio;
-    let mouseY = (e.clientY - offset.top) * this._pixelRatio;
+    let {mouseX,mouseY} = this._getRelativeEventCoordinates(e);
     this._cursor.x = mouseX;
     this._cursor.y = mouseY;
 
     if (resizer.margin != null) {
       this._selection[resizer.margin] = mouseX;
       this._shouldRedraw = true;
       this.emit("selecting");
       return;
@@ -1019,18 +1027,18 @@ AbstractCanvasGraph.prototype = {
     this._shouldRedraw = true;
   },
 
   /**
    * Listener for the "mousedown" event on the graph's container.
    */
   _onMouseDown: function(e) {
     this._isMouseActive = true;
-    let offset = this._getContainerOffset();
-    let mouseX = (e.clientX - offset.left) * this._pixelRatio;
+
+    let {mouseX} = this._getRelativeEventCoordinates(e);
 
     switch (this._canvas.getAttribute("input")) {
       case "hovering-background":
       case "hovering-region":
         if (!this.selectionEnabled) {
           break;
         }
         this._selection.start = mouseX;
@@ -1049,27 +1057,32 @@ AbstractCanvasGraph.prototype = {
       case "hovering-selection-contents":
         this._selectionDragger.origin = mouseX;
         this._selectionDragger.anchor.start = this._selection.start;
         this._selectionDragger.anchor.end = this._selection.end;
         this._canvas.setAttribute("input", "dragging-selection-contents");
         break;
     }
 
+    this._topWindow.addEventListener("mousemove", this._onMouseMove, false);
+    this._topWindow.addEventListener("mouseup", this._onMouseUp, false);
+
     this._shouldRedraw = true;
     this.emit("mousedown");
   },
 
   /**
    * Listener for the "mouseup" event on the graph's container.
    */
   _onMouseUp: function(e) {
     this._isMouseActive = false;
-    let offset = this._getContainerOffset();
-    let mouseX = (e.clientX - offset.left) * this._pixelRatio;
+    this._topWindow.removeEventListener("mousemove", this._onMouseMove, false);
+    this._topWindow.removeEventListener("mouseup", this._onMouseUp, false);
+
+    let {mouseX} = this._getRelativeEventCoordinates(e);
 
     switch (this._canvas.getAttribute("input")) {
       case "hovering-background":
       case "hovering-region":
         if (!this.selectionEnabled) {
           break;
         }
         if (this.getSelectionWidth() < 1) {
@@ -1107,18 +1120,17 @@ AbstractCanvasGraph.prototype = {
   /**
    * Listener for the "wheel" event on the graph's container.
    */
   _onMouseWheel: function(e) {
     if (!this.hasSelection()) {
       return;
     }
 
-    let offset = this._getContainerOffset();
-    let mouseX = (e.clientX - offset.left) * this._pixelRatio;
+    let {mouseX} = this._getRelativeEventCoordinates(e);
     let focusX = mouseX;
 
     let selection = this._selection;
     let vector = 0;
 
     // If the selection is hovered, "zoom" towards or away the cursor,
     // by shrinking or growing the selection.
     if (this._isHoveringSelectionContentsOrBoundaries()) {
@@ -1942,18 +1954,18 @@ BarGraphWidget.prototype = Heritage.exte
 
     this.emit("legend-unhover");
   },
 
   /**
    * Invoked whenever a color node in the legend is pressed.
    */
   _onLegendMouseDown: function(e) {
-    e.preventDefault();
-    e.stopPropagation();
+    // e.preventDefault();
+    // e.stopPropagation();
 
     let type = e.target.dataset.index;
     let rects = this._blocksBoundingRects.filter(e => e.type == type);
     let leftmost = rects[0];
     let rightmost = rects[rects.length - 1];
     if (!leftmost || !rightmost) {
       this.dropSelection();
     } else {
