# HG changeset patch
# Parent  8fc0f1c0828db454701fe7d4ad605ec9a7c7e215

diff --git a/devtools/client/locales/en-US/webconsole.properties b/devtools/client/locales/en-US/webconsole.properties
--- a/devtools/client/locales/en-US/webconsole.properties
+++ b/devtools/client/locales/en-US/webconsole.properties
@@ -320,8 +320,21 @@ webconsole.reverseSearch.noResult=No res
 # This string is displayed in the tooltip of the "previous result" button in the reverse search toolbar.
 # A keyboard shortcut will be shown inside the latter pair of brackets.
 webconsole.reverseSearch.result.previousButton.tooltip=Previous result (%S)
 
 # LOCALIZATION NOTE (webconsole.reverseSearch.result.nextButton.tooltip):
 # This string is displayed in the tooltip of the "next result" button in the reverse search toolbar.
 # A keyboard shortcut will be shown inside the latter pair of brackets.
 webconsole.reverseSearch.result.nextButton.tooltip=Next result (%S)
+
+# LOCALIZATION NOTE (webconsole.confirmDialog.getter.label)
+# Label used for the "invoke getter" confirm dialog that appears in the console when
+# a user tries to autocomplete a property with a getter.
+# Example: given the following object `x = {get y() {}}`, when the user types `x.y.`, it
+# would return "Invoke getter y to retrieve the property list?".
+# Parameters: %S is the name of the getter.
+webconsole.confirmDialog.getter.label=Invoke getter %S to retrieve the property list?
+
+# LOCALIZATION NOTE (webconsole.confirmDialog.getter.confirmButtonLabel)
+# Label used for the Confirm button in the "invoke getter" dialog that appears in the
+# console when a user tries to autocomplete a property with a getter.
+webconsole.confirmDialog.getter.confirmButtonLabel=Confirm
diff --git a/devtools/client/themes/tooltips.css b/devtools/client/themes/tooltips.css
--- a/devtools/client/themes/tooltips.css
+++ b/devtools/client/themes/tooltips.css
@@ -648,8 +648,58 @@
 .onboarding-close-button {
   align-self: flex-start;
 }
 
 .onboarding-close-button::before {
   background-image: url("chrome://devtools/skin/images/close.svg");
   margin: -6px 0 0 -6px;
 }
+
+/* Tooltip: Invoke getter confirmation Tooltip */
+
+.invoke-confirm {
+  font-family: var(--monospace-font-family);
+  color: var(--theme-popup-color);
+  border: 1px solid rgba(0,0,0, 0.1);
+  max-width: 400px;
+}
+
+.invoke-confirm .confirm-label {
+  margin: 0;
+  padding: 4px 8px;
+}
+
+.invoke-confirm .emphasized {
+  font-weight: bold;
+  overflow-wrap: break-word;
+}
+
+.invoke-confirm .confirm-button {
+  background-color: #5F9440;
+  color: white;
+  border: none;
+  padding: 8px;
+  display: block;
+  width: 100%;
+  text-align: left;
+  font-family: var(--monospace-font-family);
+}
+
+.invoke-confirm .learn-more {
+  text-align: end;
+  color: var(--object-color, #0074E8);
+  margin: 0;
+  padding: 4px 8px;
+}
+
+.invoke-confirm .learn-more:before {
+  content: "";
+  background-image: url(chrome://devtools/skin/images/help.svg);
+  background-size: contain;
+  display: inline-block;
+  min-width: 16px;
+  min-height: 16px;
+  margin-inline-end: 4px;
+  vertical-align: bottom;
+  fill: currentColor;
+  -moz-context-properties: fill;
+}
diff --git a/devtools/client/webconsole/actions/autocomplete.js b/devtools/client/webconsole/actions/autocomplete.js
--- a/devtools/client/webconsole/actions/autocomplete.js
+++ b/devtools/client/webconsole/actions/autocomplete.js
@@ -23,17 +23,17 @@ function autocompleteUpdate(force) {
       return dispatch(autocompleteClear());
     }
 
     const inputValue = services.getInputValue();
     const frameActorId = services.getFrameActor();
     const cursor = services.getInputCursor();
 
     const state = getState().autocomplete;
-    const { cache } = state;
+    const { cache, getterPath } = state;
     if (!force && (
       !inputValue ||
       /^[a-zA-Z0-9_$]/.test(inputValue.substring(cursor))
     )) {
       return dispatch(autocompleteClear());
     }
 
     const input = inputValue.substring(0, cursor);
@@ -43,20 +43,40 @@ function autocompleteUpdate(force) {
       input.startsWith(cache.input) &&
       /[a-zA-Z0-9]$/.test(input) &&
       frameActorId === cache.frameActorId;
 
     if (retrieveFromCache) {
       return dispatch(autoCompleteDataRetrieveFromCache(input));
     }
 
+    let authorizedEvaluations = (
+      Array.isArray(state.authorizedEvaluations) &&
+      state.authorizedEvaluations.length > 0
+    ) ? state.authorizedEvaluations : [];
+
+    if (Array.isArray(getterPath) && getterPath.length > 0) {
+    // We need to check for any previous authorizations. For example, here if getterPath
+    // is ["a", "b", "c", "d"], we want to see if there was any other path that was
+    // authorized in a previous request. For that, we only add the previous
+    // authorizations if the last auth is contained in getterPath. (for the example, we
+    // would keep if it is [["a", "b"]], not if [["b"]] nor [["f", "g"]])
+      const last = authorizedEvaluations[authorizedEvaluations.length - 1];
+      const concat = !last || last.every((x, index) => x === getterPath[index]);
+      if (concat) {
+        authorizedEvaluations.push(getterPath);
+      } else {
+        authorizedEvaluations = [getterPath];
+      }
+    }
     return dispatch(autocompleteDataFetch({
       input,
       frameActorId,
       client: services.getWebConsoleClient(),
+      authorizedEvaluations,
     }));
   };
 }
 
 /**
  * Called when the autocompletion data should be cleared.
  */
 function autocompleteClear() {
@@ -85,51 +105,65 @@ function generateRequestId() {
 
 /**
  * Action that fetch autocompletion data from the server.
  *
  * @param {Object} Object of the following shape:
  *        - {String} input: the expression that we want to complete.
  *        - {String} frameActorId: The id of the frame we want to autocomplete in.
  *        - {WebConsoleClient} client: The webconsole client.
+ *        - {Array} authorizedEvaluations: Array of the properties access which can be
+ *                  executed by the engine.
+ *                   Example: [["x", "myGetter"], ["x", "myGetter", "y", "glitter"]]
+ *                  to retrieve properties of `x.myGetter.` and `x.myGetter.y.glitter`.
  */
 function autocompleteDataFetch({
   input,
   frameActorId,
   client,
+  authorizedEvaluations,
 }) {
   return ({dispatch, services}) => {
     const selectedNodeActor = services.getSelectedNodeActor();
     const id = generateRequestId();
     dispatch({type: AUTOCOMPLETE_PENDING_REQUEST, id});
-    client.autocomplete(input, undefined, frameActorId, selectedNodeActor).then(res => {
-      dispatch(autocompleteDataReceive(id, input, frameActorId, res));
+    client.autocomplete(
+      input,
+      undefined,
+      frameActorId,
+      selectedNodeActor,
+      authorizedEvaluations
+    ).then(res => {
+      dispatch(
+        autocompleteDataReceive(id, input, frameActorId, res, authorizedEvaluations));
     }).catch(e => {
       console.error("failed autocomplete", e);
       dispatch(autocompleteClear());
     });
   };
 }
 
 /**
  * Called when we receive the autocompletion data from the server.
  *
  * @param {Integer} id: The autocompletion request id. This will be used in the reducer to
  *                      check that we update the state with the last request results.
  * @param {String} input: The expression that was evaluated to get the data.
  *        - {String} frameActorId: The id of the frame the evaluation was made in.
  * @param {Object} data: The actual data sent from the server.
  */
-function autocompleteDataReceive(id, input, frameActorId, data) {
+function autocompleteDataReceive(id, input, frameActorId, data, authorizedEvaluations) {
   return {
     type: AUTOCOMPLETE_DATA_RECEIVE,
     id,
     input,
     frameActorId,
     data,
+    authorizedEvaluations,
   };
 }
 
 module.exports = {
+  autocompleteClear,
   autocompleteUpdate,
   autocompleteDataFetch,
   autocompleteDataReceive,
 };
diff --git a/devtools/client/webconsole/components/App.js b/devtools/client/webconsole/components/App.js
--- a/devtools/client/webconsole/components/App.js
+++ b/devtools/client/webconsole/components/App.js
@@ -10,16 +10,17 @@ const dom = require("devtools/client/sha
 const { connect } = require("devtools/client/shared/redux/visibility-handler-connect");
 
 const actions = require("devtools/client/webconsole/actions/index");
 const ConsoleOutput = createFactory(require("devtools/client/webconsole/components/ConsoleOutput"));
 const FilterBar = createFactory(require("devtools/client/webconsole/components/FilterBar"));
 const SideBar = createFactory(require("devtools/client/webconsole/components/SideBar"));
 const ReverseSearchInput = createFactory(require("devtools/client/webconsole/components/ReverseSearchInput"));
 const JSTerm = createFactory(require("devtools/client/webconsole/components/JSTerm"));
+const ConfirmDialog = createFactory(require("devtools/client/webconsole/components/ConfirmDialog"));
 const NotificationBox = createFactory(require("devtools/client/shared/components/NotificationBox").NotificationBox);
 
 const l10n = require("devtools/client/webconsole/webconsole-l10n");
 const { Utils: WebConsoleUtils } = require("devtools/client/webconsole/utils");
 
 const SELF_XSS_OK = l10n.getStr("selfxss.okstring");
 const SELF_XSS_MSG = l10n.getFormatStr("selfxss.msg", [SELF_XSS_OK]);
 
@@ -249,16 +250,21 @@ class App extends Component {
             ? ReverseSearchInput({
               hud,
             })
             : null
         ),
         SideBar({
           serviceContainer,
         }),
+        ConfirmDialog({
+          hud,
+          serviceContainer,
+          codeMirrorEnabled: jstermCodeMirror,
+        }),
       )
     );
   }
 }
 
 const mapStateToProps = state => ({
   notifications: getAllNotifications(state),
   reverseSearchInputVisible: state.ui.reverseSearchInputVisible,
diff --git a/devtools/client/webconsole/components/ConfirmDialog.js b/devtools/client/webconsole/components/ConfirmDialog.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/components/ConfirmDialog.js
@@ -0,0 +1,115 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+loader.lazyRequireGetter(this, "PropTypes", "devtools/client/shared/vendor/react-prop-types");
+loader.lazyRequireGetter(this, "gDevTools", "devtools/client/framework/devtools", true);
+loader.lazyRequireGetter(this, "HTMLTooltip", "devtools/client/shared/widgets/tooltip/HTMLTooltip", true);
+loader.lazyRequireGetter(this, "createPortal", "devtools/client/shared/vendor/react-dom", true);
+
+// React & Redux
+const { Component } = require("devtools/client/shared/vendor/react");
+const dom = require("devtools/client/shared/vendor/react-dom-factories");
+const { connect } = require("devtools/client/shared/vendor/react-redux");
+
+const {getAutocompleteState} = require("devtools/client/webconsole/selectors/autocomplete");
+const autocompleteActions = require("devtools/client/webconsole/actions/autocomplete");
+const { l10n } = require("devtools/client/webconsole/utils/messages");
+
+class ConfirmDialog extends Component {
+  static get propTypes() {
+    return {
+      // Console object.
+      hud: PropTypes.object.isRequired,
+      // Update autocomplete popup state.
+      autocompleteUpdate: PropTypes.func.isRequired,
+      // Data to be displayed in the confirm dialog.
+      getterPath: PropTypes.array.isRequired,
+      serviceContainer: PropTypes.object.isRequired,
+    };
+  }
+
+  constructor(props) {
+    super(props);
+
+    const { hud } = props;
+    hud.confirmDialog = this;
+  }
+
+  componentDidMount() {
+    const doc = this.props.hud.document;
+    const toolbox = gDevTools.getToolbox(this.props.hud.owner.target);
+    const tooltipDoc = toolbox ? toolbox.doc : doc;
+    // The popup will be attached to the toolbox document or HUD document in the case
+    // such as the browser console which doesn't have a toolbox.
+    this.tooltip = new HTMLTooltip(tooltipDoc, {
+      className: "invoke-confirm",
+    });
+  }
+
+  componentDidUpdate() {
+    const {getterPath, serviceContainer} = this.props;
+    if (getterPath) {
+      this.tooltip.show(serviceContainer.getJsTermTooltipAnchor(), {y: 5});
+    } else {
+      this.tooltip.hide();
+    }
+  }
+
+  componentDidThrow(e) {
+    console.log("Error", e);
+    this.setState(state => ({...state, hasError: true}));
+  }
+
+  render() {
+    if (
+      (this.state && this.state.hasError) ||
+      (!this.props || !this.props.getterPath)
+    ) {
+      return null;
+    }
+
+    const {getterPath} = this.props;
+    const getterName = getterPath.join(".");
+
+    // We deliberately use getStr, and not getFormatStr, because we want getterName to
+    // be wrapped in its own span.
+    const description = l10n.getStr("webconsole.confirmDialog.getter.label");
+    const [descriptionPrefix, descriptionSuffix] = description.split("%S");
+
+    return createPortal([
+      dom.p({
+        className: "confirm-label",
+      },
+        dom.span({}, descriptionPrefix),
+        dom.span({className: "emphasized"}, getterName),
+        dom.span({}, descriptionSuffix)
+      ),
+      dom.button({
+        className: "confirm-button",
+        onClick: () => {
+          this.tooltip.hide();
+          this.props.autocompleteUpdate(true);
+        },
+      }, l10n.getStr("webconsole.confirmDialog.getter.confirmButtonLabel")),
+    ], this.tooltip.panel);
+  }
+}
+
+// Redux connect
+function mapStateToProps(state) {
+  const autocompleteData = getAutocompleteState(state);
+  return {
+    getterPath: autocompleteData.getterPath,
+  };
+}
+
+function mapDispatchToProps(dispatch) {
+  return {
+    autocompleteUpdate: force => dispatch(autocompleteActions.autocompleteUpdate(force)),
+  };
+}
+
+module.exports = connect(mapStateToProps, mapDispatchToProps)(ConfirmDialog);
diff --git a/devtools/client/webconsole/components/JSTerm.js b/devtools/client/webconsole/components/JSTerm.js
--- a/devtools/client/webconsole/components/JSTerm.js
+++ b/devtools/client/webconsole/components/JSTerm.js
@@ -76,16 +76,18 @@ class JSTerm extends Component {
       serviceContainer: PropTypes.object.isRequired,
       // Handler for clipboard 'paste' event (also used for 'drop' event, callback).
       onPaste: PropTypes.func,
       codeMirrorEnabled: PropTypes.bool,
       // Update position in the history after executing an expression (action).
       updateHistoryPosition: PropTypes.func.isRequired,
       // Update autocomplete popup state.
       autocompleteUpdate: PropTypes.func.isRequired,
+      // Clear autocomplete popup state.
+      autocompleteClear: PropTypes.func.isRequired,
       // Data to be displayed in the autocomplete popup.
       autocompleteData: PropTypes.object.isRequired,
     };
   }
 
   constructor(props) {
     super(props);
 
@@ -166,16 +168,25 @@ class JSTerm extends Component {
 
           if (!inputUpdated) {
             return "CodeMirror.Pass";
           }
           return null;
         };
 
         const onArrowLeft = () => {
+          const {autocompleteData} = this.props;
+          if (
+            this.autocompletePopup.isOpen ||
+            this.getAutoCompletionText() ||
+            (autocompleteData && autocompleteData.getterPath)
+          ) {
+            this.props.autocompleteClear();
+          }
+
           if (this.autocompletePopup.isOpen || this.getAutoCompletionText()) {
             this.clearCompletion();
           }
           return "CodeMirror.Pass";
         };
 
         this.editor = new Editor({
           autofocus: true,
@@ -184,34 +195,45 @@ class JSTerm extends Component {
           gutters: [],
           lineWrapping: true,
           mode: Editor.modes.js,
           styleActiveLine: false,
           tabIndex: "0",
           viewportMargin: Infinity,
           disableSearchAddon: true,
           extraKeys: {
+            // No need to handle shift + Enter as it's natively handled by CodeMirror.
             "Enter": () => {
-              // No need to handle shift + Enter as it's natively handled by CodeMirror.
+              const {autocompleteData} = this.props;
+              if (autocompleteData && autocompleteData.getterPath) {
+                this.props.autocompleteUpdate(true);
+                return null;
+              }
 
               const hasSuggestion = this.hasAutocompletionSuggestion();
               if (!hasSuggestion && !Debugger.isCompilableUnit(this.getInputValue())) {
-                // incomplete statement
+                // incomplete statement, let CodeMirror add a new line.
                 return "CodeMirror.Pass";
               }
 
               if (hasSuggestion) {
                 return this.acceptProposedCompletion();
               }
 
               this.execute();
               return null;
             },
 
             "Tab": () => {
+              const {autocompleteData} = this.props;
+              if (autocompleteData && autocompleteData.getterPath) {
+                this.props.autocompleteUpdate(true);
+                return false;
+              }
+
               if (this.hasEmptyInput()) {
                 this.editor.codeMirror.getInputField().blur();
                 return false;
               }
 
               const isSomethingSelected = this.editor.somethingSelected();
               const hasSuggestion = this.hasAutocompletionSuggestion();
 
@@ -364,20 +386,26 @@ class JSTerm extends Component {
         this.editor.on("changes", this._inputEventHandler);
         this.editor.on("beforeChange", this._onBeforeChange);
         this.editor.appendToLocalElement(this.node);
         const cm = this.editor.codeMirror;
         cm.on("paste", (_, event) => this.props.onPaste(event));
         cm.on("drop", (_, event) => this.props.onPaste(event));
 
         this.node.addEventListener("keydown", event => {
-          if (event.keyCode === KeyCodes.DOM_VK_ESCAPE && this.autocompletePopup.isOpen) {
-            this.clearCompletion();
-            event.preventDefault();
-            event.stopPropagation();
+          if (event.keyCode === KeyCodes.DOM_VK_ESCAPE) {
+            if (this.autocompletePopup.isOpen || (
+              this.props.autocompleteData &&
+              this.props.autocompleteData.getterPath
+            )) {
+              this.props.autocompleteClear();
+              // this.clearCompletion();
+              event.preventDefault();
+              event.stopPropagation();
+            }
           }
         });
       }
     } else if (this.inputNode) {
       this.inputNode.addEventListener("keypress", this._keyPress);
       this.inputNode.addEventListener("input", this._inputEventHandler);
       this.inputNode.addEventListener("keyup", this._inputEventHandler);
       this.focus();
@@ -841,41 +869,47 @@ class JSTerm extends Component {
 
       if (event.keyCode === KeyCodes.DOM_VK_LEFT &&
         (this.autocompletePopup.isOpen || this.getAutoCompletionText())
       ) {
         this.clearCompletion();
       }
 
       return;
-    } else if (event.keyCode == KeyCodes.DOM_VK_RETURN) {
-      if (!this.autocompletePopup.isOpen && (
-        event.shiftKey || !Debugger.isCompilableUnit(this.getInputValue())
-      )) {
-        // shift return or incomplete statement
-        return;
-      }
     }
 
     switch (event.keyCode) {
       case KeyCodes.DOM_VK_ESCAPE:
-        if (this.autocompletePopup.isOpen) {
-          this.clearCompletion();
+        if (this.autocompletePopup.isOpen || (
+          this.props.autocompleteData && this.props.autocompleteData.getterPath
+        )) {
+          this.props.autocompleteClear();
           event.preventDefault();
           event.stopPropagation();
         }
         break;
 
       case KeyCodes.DOM_VK_RETURN:
+        if (this.props.autocompleteData && this.props.autocompleteData.getterPath) {
+          this.props.autocompleteUpdate(true);
+          event.preventDefault();
+          return;
+        }
+
         if (this.hasAutocompletionSuggestion()) {
           this.acceptProposedCompletion();
-        } else {
+          event.preventDefault();
+          return;
+        }
+
+        if (!event.shiftKey && Debugger.isCompilableUnit(this.getInputValue())) {
           this.execute();
+          event.preventDefault();
         }
-        event.preventDefault();
+
         break;
 
       case KeyCodes.DOM_VK_UP:
         if (this.autocompletePopup.isOpen) {
           this.autocompletePopup.selectPreviousItem();
           event.preventDefault();
         } else if (this.canCaretGoPrevious()) {
           inputUpdated = this.historyPeruse(HISTORY_BACK);
@@ -943,32 +977,40 @@ class JSTerm extends Component {
           this.clearCompletion();
         } else if (inputValue.length <= 0) {
           this.hud.outputScroller.scrollTop = this.hud.outputScroller.scrollHeight;
           event.preventDefault();
         }
         break;
 
       case KeyCodes.DOM_VK_LEFT:
-        if (this.autocompletePopup.isOpen || this.getAutoCompletionText()) {
-          this.clearCompletion();
+        if (this.autocompletePopup.isOpen || this.getAutoCompletionText() || (
+          this.props.autocompleteData && this.props.autocompleteData.getterPath)
+        ) {
+          this.props.autocompleteClear();
         }
         break;
 
       case KeyCodes.DOM_VK_RIGHT:
         // We only want to complete on Right arrow if the completion text is
         // displayed.
         if (this.getAutoCompletionText()) {
           this.acceptProposedCompletion();
           event.preventDefault();
         }
         this.clearCompletion();
         break;
 
       case KeyCodes.DOM_VK_TAB:
+        if (this.props.autocompleteData && this.props.autocompleteData.getterPath) {
+          this.props.autocompleteUpdate(true);
+          event.preventDefault();
+          return;
+        }
+
         if (this.hasAutocompletionSuggestion()) {
           this.acceptProposedCompletion();
           event.preventDefault();
         } else if (!this.hasEmptyInput()) {
           if (!event.shiftKey) {
             this.insertStringAtCursor("\t");
           }
           event.preventDefault();
@@ -1099,17 +1141,23 @@ class JSTerm extends Component {
    *          matches: {Array} array of the properties matching the input,
    *          matchProp: {String} The string used to filter the properties,
    *          isElementAccess: {Boolean} True when the input is an element access,
    *                           i.e. `document["addEve`.
    *        }
    * @fires autocomplete-updated
    */
   updateAutocompletionPopup(data) {
-    const {matches, matchProp, isElementAccess} = data;
+    const { matches, matchProp, isElementAccess, isUnsafeGetter } = data;
+    if (isUnsafeGetter === true) {
+      this.autocompletePopup.hidePopup();
+      this.emit("autocomplete-updated");
+      return;
+    }
+
     if (!matches.length) {
       this.clearCompletion();
       this.emit("autocomplete-updated");
       return;
     }
 
     const inputUntilCursor = this.getInputValueBeforeCursor();
 
@@ -1158,34 +1206,29 @@ class JSTerm extends Component {
     if (items.length >= minimumAutoCompleteLength
       || (items.length === 1 && items[0].preLabel !== matchProp)
       || (
         items.length === 1
         && !this.canDisplayAutoCompletionText()
         && items[0].label !== matchProp
       )
     ) {
-      let popupAlignElement;
+      const popupAlignElement = this.props.serviceContainer.getJsTermTooltipAnchor();
       let xOffset;
       let yOffset;
 
       if (this.editor) {
-        popupAlignElement = this.node.querySelector(".CodeMirror-cursor");
         // We need to show the popup at the "." or "[".
         xOffset = -1 * matchProp.length * this._inputCharWidth;
         yOffset = 5;
       } else if (this.inputNode) {
         const offset = inputUntilCursor.length -
           (inputUntilCursor.lastIndexOf("\n") + 1) -
           matchProp.length;
         xOffset = (offset * this._inputCharWidth) + this._paddingInlineStart;
-        // We use completeNode as the popup anchor as its height never exceeds the
-        // content size, whereas it can be the case for inputNode (when there's no message
-        // in the output, it takes the whole height).
-        popupAlignElement = this.completeNode;
       }
 
       if (popupAlignElement) {
         popup.openPopup(popupAlignElement, xOffset, yOffset, 0, {
           preventSelectCallback: true,
         });
       }
     } else if (items.length < minimumAutoCompleteLength && popup.isOpen) {
@@ -1558,13 +1601,13 @@ function mapStateToProps(state) {
 
 function mapDispatchToProps(dispatch) {
   return {
     appendToHistory: (expr) => dispatch(historyActions.appendToHistory(expr)),
     clearHistory: () => dispatch(historyActions.clearHistory()),
     updateHistoryPosition: (direction, expression) =>
       dispatch(historyActions.updateHistoryPosition(direction, expression)),
     autocompleteUpdate: force => dispatch(autocompleteActions.autocompleteUpdate(force)),
-    autocompleteBailOut: () => dispatch(autocompleteActions.autocompleteBailOut()),
+    autocompleteClear: () => dispatch(autocompleteActions.autocompleteClear()),
   };
 }
 
 module.exports = connect(mapStateToProps, mapDispatchToProps)(JSTerm);
diff --git a/devtools/client/webconsole/components/moz.build b/devtools/client/webconsole/components/moz.build
--- a/devtools/client/webconsole/components/moz.build
+++ b/devtools/client/webconsole/components/moz.build
@@ -5,16 +5,17 @@
 
 DIRS += [
     'message-types'
 ]
 
 DevToolsModules(
     'App.js',
     'CollapseButton.js',
+    'ConfirmDialog.js',
     'ConsoleOutput.js',
     'ConsoleTable.js',
     'FilterBar.js',
     'FilterButton.js',
     'FilterCheckbox.js',
     'GripMessageBody.js',
     'JSTerm.js',
     'Message.js',
diff --git a/devtools/client/webconsole/reducers/autocomplete.js b/devtools/client/webconsole/reducers/autocomplete.js
--- a/devtools/client/webconsole/reducers/autocomplete.js
+++ b/devtools/client/webconsole/reducers/autocomplete.js
@@ -3,32 +3,38 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const {
   AUTOCOMPLETE_CLEAR,
   AUTOCOMPLETE_DATA_RECEIVE,
   AUTOCOMPLETE_PENDING_REQUEST,
   AUTOCOMPLETE_RETRIEVE_FROM_CACHE,
+  APPEND_TO_HISTORY,
+  UPDATE_HISTORY_POSITION,
+  REVERSE_SEARCH_INPUT_CHANGE,
+  REVERSE_SEARCH_BACK,
+  REVERSE_SEARCH_NEXT,
 } = require("devtools/client/webconsole/constants");
 
 function getDefaultState() {
   return Object.freeze({
     cache: null,
     matches: [],
     matchProp: null,
     isElementAccess: false,
     pendingRequestId: null,
+    isUnsafeGetter: false,
+    getterPath: null,
+    authorizedEvaluations: [],
   });
 }
 
 function autocomplete(state = getDefaultState(), action) {
   switch (action.type) {
-    case AUTOCOMPLETE_CLEAR:
-      return getDefaultState();
     case AUTOCOMPLETE_RETRIEVE_FROM_CACHE:
       return autoCompleteRetrieveFromCache(state, action);
     case AUTOCOMPLETE_PENDING_REQUEST:
       return {
         ...state,
         cache: null,
         pendingRequestId: action.id,
       };
@@ -36,26 +42,49 @@ function autocomplete(state = getDefault
       if (action.id !== state.pendingRequestId) {
         return state;
       }
 
       if (action.data.matches === null) {
         return getDefaultState();
       }
 
+      if (action.data.isUnsafeGetter) {
+        return {
+          ...getDefaultState(),
+          isUnsafeGetter: true,
+          getterPath: action.data.getterPath,
+          authorizedEvaluations: action.authorizedEvaluations,
+        };
+      }
+
       return {
         ...state,
+        authorizedEvaluations: action.authorizedEvaluations,
+        getterPath: null,
+        isUnsafeGetter: false,
+        pendingRequestId: null,
         cache: {
           input: action.input,
           frameActorId: action.frameActorId,
           ...action.data,
         },
-        pendingRequestId: null,
         ...action.data,
       };
+    // Reset the autocomplete data when:
+    // - clear is explicitely called
+    // - the user navigates the history
+    // - or an item was added to the history (i.e. something was evaluated).
+    case AUTOCOMPLETE_CLEAR:
+    case APPEND_TO_HISTORY:
+    case UPDATE_HISTORY_POSITION:
+    case REVERSE_SEARCH_INPUT_CHANGE:
+    case REVERSE_SEARCH_BACK:
+    case REVERSE_SEARCH_NEXT:
+      return getDefaultState();
   }
 
   return state;
 }
 
 /**
  * Retrieve from cache action reducer.
  *
@@ -94,15 +123,17 @@ function autoCompleteRetrieveFromCache(s
       return l.toLocaleLowerCase().startsWith(filterByLc);
     }
 
     return l.startsWith(filterBy);
   });
 
   return {
     ...state,
+    isUnsafeGetter: false,
+    getterPath: null,
     matches: newList,
     matchProp: filterBy,
     isElementAccess: cache.isElementAccess,
   };
 }
 
 exports.autocomplete = autocomplete;
diff --git a/devtools/client/webconsole/test/mochitest/browser.ini b/devtools/client/webconsole/test/mochitest/browser.ini
--- a/devtools/client/webconsole/test/mochitest/browser.ini
+++ b/devtools/client/webconsole/test/mochitest/browser.ini
@@ -190,16 +190,17 @@ skip-if = verify
 [browser_jsterm_autocomplete_arrow_keys.js]
 [browser_jsterm_autocomplete_await.js]
 [browser_jsterm_autocomplete_cached_results.js]
 [browser_jsterm_autocomplete_commands.js]
 [browser_jsterm_autocomplete_control_space.js]
 [browser_jsterm_autocomplete_crossdomain_iframe.js]
 [browser_jsterm_autocomplete_escape_key.js]
 [browser_jsterm_autocomplete_extraneous_closing_brackets.js]
+[browser_jsterm_autocomplete_getters.js]
 [browser_jsterm_autocomplete_helpers.js]
 [browser_jsterm_autocomplete_in_chrome_tab.js]
 [browser_jsterm_autocomplete_in_debugger_stackframe.js]
 [browser_jsterm_autocomplete_inside_text.js]
 [browser_jsterm_autocomplete_native_getters.js]
 [browser_jsterm_autocomplete_nav_and_tab_key.js]
 [browser_jsterm_autocomplete_paste_undo.js]
 [browser_jsterm_autocomplete_return_key_no_selection.js]
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters.js
@@ -0,0 +1,170 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that accessing properties with getters displays the confirm dialog to invoke them,
+// and then displays the autocomplete popup with the results.
+
+const TEST_URI = `data:text/html;charset=utf-8,
+<head>
+  <script>
+    /* Create a prototype-less object so popup does not contain native
+     * Object prototype properties.
+     */
+    window.foo = Object.create(null, Object.getOwnPropertyDescriptors({
+      get bar() {
+        return Object.create(null, Object.getOwnPropertyDescriptors({
+          get baz() {
+            return Object.create(null, Object.getOwnPropertyDescriptors({
+              hello: 1,
+              world: "",
+            }));
+          },
+          bloop: true,
+        }))
+      },
+      get rab() {
+        return "";
+      }
+    }));
+  </script>
+</head>
+<body>Autocomplete popup - invoke getter usage test</body>`;
+
+add_task(async function() {
+  // Run test with legacy JsTerm
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+  await performTests();
+  // And then run it with the CodeMirror-powered one.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
+  await performTests();
+});
+
+async function performTests() {
+  const hud = await openNewTabAndConsole(TEST_URI);
+  const { jsterm } = hud;
+  const { autocompletePopup } = jsterm;
+  const target = await TargetFactory.forTab(gBrowser.selectedTab);
+  const toolbox = gDevTools.getToolbox(target);
+
+  await setInputValueForAutocompletion(jsterm, "window.foo.bar.");
+  await waitFor(() => isConfirmTooltipOpened(toolbox));
+
+  ok(true, "The confirm dialog is displayed");
+
+  let tooltip = getConfirmTooltip(toolbox);
+  let labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.bar to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that hitting Enter does invoke the getter and return its properties");
+  let onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey("KEY_Enter");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after Enter");
+  is(getPopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.|");
+  is(isConfirmTooltipOpened(toolbox), false, "confirm tooltip is now closed");
+
+  let onPopUpClose = autocompletePopup.once("popup-closed");
+  EventUtils.synthesizeKey("KEY_Enter");
+  await onPopUpClose;
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.baz|");
+
+  info("Check that the invoke tooltip is displayed when performing an element access");
+  EventUtils.sendString("[");
+  await waitFor(() => isConfirmTooltipOpened(toolbox));
+
+  tooltip = getConfirmTooltip(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent,
+    "Invoke getter window.foo.bar.baz to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that hitting Tab does invoke the getter and return its properties");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey("KEY_Tab");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after Tab");
+  is(getPopupLabels(autocompletePopup).join("-"), `"hello"-"world"`,
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.baz[|");
+  is(isConfirmTooltipOpened(toolbox), false, "confirm tooltip is now closed");
+
+  onPopUpClose = autocompletePopup.once("popup-closed");
+  EventUtils.synthesizeKey("KEY_Tab");
+  await onPopUpClose;
+  checkJsTermValueAndCursor(jsterm, `window.foo.bar.baz["hello"]|`);
+
+  info("Check that autocompletion work on a getter result");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.sendString(".");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "got items of getter result");
+  ok(getPopupLabels(autocompletePopup).includes("toExponential"),
+    "popup has expected items");
+
+  await setInputValueForAutocompletion(jsterm, "window.foo.rab.");
+  await waitFor(() => isConfirmTooltipOpened(toolbox));
+  tooltip = getConfirmTooltip(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.rab to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that Escape closes the confirm tooltip");
+  let onConfirmTooltipClosed = waitFor(() => !isConfirmTooltipOpened(toolbox));
+  EventUtils.synthesizeKey("KEY_Escape");
+  await onConfirmTooltipClosed;
+
+  info("Check that Ctrl+space show the confirm tooltip again");
+  EventUtils.synthesizeKey(" ", {ctrlKey: true});
+  await waitFor(() => isConfirmTooltipOpened(toolbox));
+  tooltip = getConfirmTooltip(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.rab to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check clicking the confirm button invokes the getter and return its properties");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  tooltip.querySelector(".confirm-button").click();
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after clicking on the confirm button");
+  ok(getPopupLabels(autocompletePopup).includes("startsWith"),
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.rab.|");
+  is(isConfirmTooltipOpened(toolbox), false, "confirm tooltip is now closed");
+
+  info("Open the tooltip again");
+  await setInputValueForAutocompletion(jsterm, "window.foo.bar.");
+  await waitFor(() => isConfirmTooltipOpened(toolbox));
+  tooltip = getConfirmTooltip(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.bar to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that ArrowLeft closes the confirm tooltip");
+  onConfirmTooltipClosed = waitFor(() => !isConfirmTooltipOpened(toolbox));
+  EventUtils.synthesizeKey("KEY_ArrowLeft");
+  await onConfirmTooltipClosed;
+}
+
+function getPopupLabels(popup) {
+  return popup.getItems().map(item => item.label);
+}
+
+function getConfirmTooltip(toolbox) {
+  const {doc} = toolbox;
+  return doc.querySelector(".invoke-confirm");
+}
+
+function isConfirmTooltipOpened(toolbox) {
+  const tooltip = getConfirmTooltip(toolbox);
+  if (!tooltip) {
+    return false;
+  }
+
+  return tooltip.classList.contains("tooltip-visible");
+}
+
diff --git a/devtools/client/webconsole/webconsole-output-wrapper.js b/devtools/client/webconsole/webconsole-output-wrapper.js
--- a/devtools/client/webconsole/webconsole-output-wrapper.js
+++ b/devtools/client/webconsole/webconsole-output-wrapper.js
@@ -150,16 +150,23 @@ WebConsoleOutputWrapper.prototype = {
 
         getSelectedNodeActor: () => {
           const inspectorSelection = this.owner.getInspectorSelection();
           if (inspectorSelection && inspectorSelection.nodeFront) {
             return inspectorSelection.nodeFront.actorID;
           }
           return null;
         },
+
+        getJsTermTooltipAnchor: () => {
+          if (jstermCodeMirror) {
+            return hud.jsterm.node.querySelector(".CodeMirror-cursor");
+          }
+          return hud.jsterm.completeNode;
+        },
       };
 
       // Set `openContextMenu` this way so, `serviceContainer` variable
       // is available in the current scope and we can pass it into
       // `createContextMenu` method.
       serviceContainer.openContextMenu = (e, message) => {
         const { screenX, screenY, target } = e;
 
@@ -291,24 +298,26 @@ WebConsoleOutputWrapper.prototype = {
       store = configureStore(this.hud, {
         // We may not have access to the toolbox (e.g. in the browser console).
         sessionId: this.toolbox && this.toolbox.sessionId || -1,
         telemetry: this.telemetry,
         services: serviceContainer,
       });
 
       const {prefs} = store.getState();
+      const jstermCodeMirror = prefs.jstermCodeMirror
+        && !Services.appinfo.accessibilityEnabled;
+
       const app = App({
         attachRefToHud,
         serviceContainer,
         hud,
         onFirstMeaningfulPaint: resolve,
         closeSplitConsole: this.closeSplitConsole.bind(this),
-        jstermCodeMirror: prefs.jstermCodeMirror
-          && !Services.appinfo.accessibilityEnabled,
+        jstermCodeMirror,
         jstermReverseSearch: prefs.jstermReverseSearch,
       });
 
       // Render the root Application component.
       if (this.parentNode) {
         const provider = createElement(Provider, { store }, app);
         this.body = ReactDOM.render(provider, this.parentNode);
       } else {
