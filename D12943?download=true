diff --git a/devtools/client/locales/en-US/webconsole.properties b/devtools/client/locales/en-US/webconsole.properties
--- a/devtools/client/locales/en-US/webconsole.properties
+++ b/devtools/client/locales/en-US/webconsole.properties
@@ -325,3 +325,16 @@
 # This string is displayed in the tooltip of the "next result" button in the reverse search toolbar.
 # A keyboard shortcut will be shown inside the latter pair of brackets.
 webconsole.reverseSearch.result.nextButton.tooltip=Next result (%S)
+
+# LOCALIZATION NOTE (webconsole.confirmDialog.getter.label)
+# Label used for the "invoke getter" confirm dialog that appears in the console when
+# a user tries to autocomplete a property with a getter.
+# Example: given the following object `x = {get y() {}}`, when the user types `x.y.`, it
+# would return "Invoke getter y to retrieve the property list?".
+# Parameters: %S is the name of the getter.
+webconsole.confirmDialog.getter.label=Invoke getter %S to retrieve the property list?
+
+# LOCALIZATION NOTE (webconsole.confirmDialog.getter.confirmButtonLabel)
+# Label used for the Confirm button in the "invoke getter" dialog that appears in the
+# console when a user tries to autocomplete a property with a getter.
+webconsole.confirmDialog.getter.confirmButtonLabel=Confirm
diff --git a/devtools/client/themes/tooltips.css b/devtools/client/themes/tooltips.css
--- a/devtools/client/themes/tooltips.css
+++ b/devtools/client/themes/tooltips.css
@@ -655,3 +655,46 @@
   background-image: url("chrome://devtools/skin/images/close.svg");
   margin: -6px 0 0 -6px;
 }
+
+/* Tooltip: Invoke getter confirm Tooltip */
+
+.invoke-confirm {
+  font-family: var(--monospace-font-family);
+  color: var(--theme-popup-color);
+  border: 1px solid rgba(0,0,0, 0.1);
+  max-width: 400px;
+}
+
+.invoke-confirm .tooltip-panel {
+  display: flex;
+  flex-direction: column;
+}
+
+.invoke-confirm .confirm-label {
+  margin: 0;
+  padding: 8px;
+  flex-grow: 1;
+}
+
+.invoke-confirm .emphasized {
+  font-weight: bold;
+  overflow-wrap: break-word;
+}
+
+.invoke-confirm .confirm-button {
+  background-color: var(--theme-selection-background);
+  color: white;
+  border: none;
+  padding: 8px;
+  display: block;
+  width: 100%;
+  text-align: left;
+  font-family: var(--monospace-font-family);
+}
+
+/* The button already has a "selected" style, we can remove the focus rings. */
+.confirm-button:-moz-focusring,
+.confirm-button::-moz-focus-inner {
+  outline:none;
+  border:none;
+}
diff --git a/devtools/client/webconsole/actions/autocomplete.js b/devtools/client/webconsole/actions/autocomplete.js
--- a/devtools/client/webconsole/actions/autocomplete.js
+++ b/devtools/client/webconsole/actions/autocomplete.js
@@ -16,8 +16,10 @@
  *
  * @param {Boolean} force: True to force a call to the server (as opposed to retrieve
  *                         from the cache).
+ * @param {Array<String>} getterPath: Array representing the getter access (i.e.
+ *                                    `a.b.c.d.` is described as ['a', 'b', 'c', 'd'] ).
  */
-function autocompleteUpdate(force) {
+function autocompleteUpdate(force, getterPath) {
   return ({dispatch, getState, services}) => {
     if (services.inputHasSelection()) {
       return dispatch(autocompleteClear());
@@ -48,10 +50,31 @@
       return dispatch(autoCompleteDataRetrieveFromCache(input));
     }
 
+    let authorizedEvaluations = (
+      Array.isArray(state.authorizedEvaluations) &&
+      state.authorizedEvaluations.length > 0
+    ) ? state.authorizedEvaluations : [];
+
+    if (Array.isArray(getterPath) && getterPath.length > 0) {
+      // We need to check for any previous authorizations. For example, here if getterPath
+      // is ["a", "b", "c", "d"], we want to see if there was any other path that was
+      // authorized in a previous request. For that, we only add the previous
+      // authorizations if the last auth is contained in getterPath. (for the example, we
+      // would keep if it is [["a", "b"]], not if [["b"]] nor [["f", "g"]])
+      const last = authorizedEvaluations[authorizedEvaluations.length - 1];
+      const concat = !last || last.every((x, index) => x === getterPath[index]);
+      if (concat) {
+        authorizedEvaluations.push(getterPath);
+      } else {
+        authorizedEvaluations = [getterPath];
+      }
+    }
+
     return dispatch(autocompleteDataFetch({
       input,
       frameActorId,
       client: services.getWebConsoleClient(),
+      authorizedEvaluations,
     }));
   };
 }
@@ -90,18 +113,30 @@
  *        - {String} input: the expression that we want to complete.
  *        - {String} frameActorId: The id of the frame we want to autocomplete in.
  *        - {WebConsoleClient} client: The webconsole client.
+ *        - {Array} authorizedEvaluations: Array of the properties access which can be
+ *                  executed by the engine.
+ *                   Example: [["x", "myGetter"], ["x", "myGetter", "y", "glitter"]]
+ *                  to retrieve properties of `x.myGetter.` and `x.myGetter.y.glitter`.
  */
 function autocompleteDataFetch({
   input,
   frameActorId,
   client,
+  authorizedEvaluations,
 }) {
   return ({dispatch, services}) => {
     const selectedNodeActor = services.getSelectedNodeActor();
     const id = generateRequestId();
     dispatch({type: AUTOCOMPLETE_PENDING_REQUEST, id});
-    client.autocomplete(input, undefined, frameActorId, selectedNodeActor).then(res => {
-      dispatch(autocompleteDataReceive(id, input, frameActorId, res));
+    client.autocomplete(
+      input,
+      undefined,
+      frameActorId,
+      selectedNodeActor,
+      authorizedEvaluations
+    ).then(res => {
+      dispatch(
+        autocompleteDataReceive(id, input, frameActorId, res, authorizedEvaluations));
     }).catch(e => {
       console.error("failed autocomplete", e);
       dispatch(autocompleteClear());
@@ -118,17 +153,19 @@
  *        - {String} frameActorId: The id of the frame the evaluation was made in.
  * @param {Object} data: The actual data sent from the server.
  */
-function autocompleteDataReceive(id, input, frameActorId, data) {
+function autocompleteDataReceive(id, input, frameActorId, data, authorizedEvaluations) {
   return {
     type: AUTOCOMPLETE_DATA_RECEIVE,
     id,
     input,
     frameActorId,
     data,
+    authorizedEvaluations,
   };
 }
 
 module.exports = {
+  autocompleteClear,
   autocompleteUpdate,
   autocompleteDataFetch,
   autocompleteDataReceive,
diff --git a/devtools/client/webconsole/components/App.js b/devtools/client/webconsole/components/App.js
--- a/devtools/client/webconsole/components/App.js
+++ b/devtools/client/webconsole/components/App.js
@@ -15,6 +15,7 @@
 const SideBar = createFactory(require("devtools/client/webconsole/components/SideBar"));
 const ReverseSearchInput = createFactory(require("devtools/client/webconsole/components/ReverseSearchInput"));
 const JSTerm = createFactory(require("devtools/client/webconsole/components/JSTerm"));
+const ConfirmDialog = createFactory(require("devtools/client/webconsole/components/ConfirmDialog"));
 const NotificationBox = createFactory(require("devtools/client/shared/components/NotificationBox").NotificationBox);
 
 const l10n = require("devtools/client/webconsole/webconsole-l10n");
@@ -247,6 +248,11 @@
         SideBar({
           serviceContainer,
         }),
+        ConfirmDialog({
+          hud,
+          serviceContainer,
+          codeMirrorEnabled: jstermCodeMirror,
+        }),
       )
     );
   }
diff --git a/devtools/client/webconsole/components/ConfirmDialog.js b/devtools/client/webconsole/components/ConfirmDialog.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/components/ConfirmDialog.js
@@ -0,0 +1,150 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+loader.lazyRequireGetter(this, "PropTypes", "devtools/client/shared/vendor/react-prop-types");
+loader.lazyRequireGetter(this, "gDevTools", "devtools/client/framework/devtools", true);
+loader.lazyRequireGetter(this, "HTMLTooltip", "devtools/client/shared/widgets/tooltip/HTMLTooltip", true);
+loader.lazyRequireGetter(this, "createPortal", "devtools/client/shared/vendor/react-dom", true);
+
+// React & Redux
+const { Component } = require("devtools/client/shared/vendor/react");
+const dom = require("devtools/client/shared/vendor/react-dom-factories");
+const { connect } = require("devtools/client/shared/vendor/react-redux");
+
+const {getAutocompleteState} = require("devtools/client/webconsole/selectors/autocomplete");
+const autocompleteActions = require("devtools/client/webconsole/actions/autocomplete");
+const { l10n } = require("devtools/client/webconsole/utils/messages");
+
+class ConfirmDialog extends Component {
+  static get propTypes() {
+    return {
+      // Console object.
+      hud: PropTypes.object.isRequired,
+      // Update autocomplete popup state.
+      autocompleteUpdate: PropTypes.func.isRequired,
+      autocompleteClear: PropTypes.func.isRequired,
+      // Data to be displayed in the confirm dialog.
+      getterPath: PropTypes.array.isRequired,
+      serviceContainer: PropTypes.object.isRequired,
+    };
+  }
+
+  constructor(props) {
+    super(props);
+
+    const { hud } = props;
+    hud.confirmDialog = this;
+
+    this.cancel = this.cancel.bind(this);
+    this.confirm = this.confirm.bind(this);
+  }
+
+  componentDidMount() {
+    const doc = this.props.hud.document;
+    const toolbox = gDevTools.getToolbox(this.props.hud.owner.target);
+    const tooltipDoc = toolbox ? toolbox.doc : doc;
+    // The popup will be attached to the toolbox document or HUD document in the case
+    // such as the browser console which doesn't have a toolbox.
+    this.tooltip = new HTMLTooltip(tooltipDoc, {
+      className: "invoke-confirm",
+    });
+  }
+
+  componentDidUpdate() {
+    const {getterPath, serviceContainer} = this.props;
+
+    if (getterPath) {
+      this.tooltip.show(serviceContainer.getJsTermTooltipAnchor(), {y: 5});
+      this.tooltip.focus();
+    } else {
+      this.tooltip.hide();
+      this.props.hud.jsterm.focus();
+    }
+  }
+
+  componentDidThrow(e) {
+    console.error("Error in ConfirmDialog", e);
+    this.setState(state => ({...state, hasError: true}));
+  }
+
+  cancel() {
+    this.tooltip.hide();
+    this.props.autocompleteClear();
+  }
+
+  confirm() {
+    this.tooltip.hide();
+    this.props.autocompleteUpdate(this.props.getterPath);
+  }
+
+  render() {
+    if (
+      (this.state && this.state.hasError) ||
+      (!this.props || !this.props.getterPath)
+    ) {
+      return null;
+    }
+
+    const {getterPath} = this.props;
+    const getterName = getterPath.join(".");
+
+    // We deliberately use getStr, and not getFormatStr, because we want getterName to
+    // be wrapped in its own span.
+    const description = l10n.getStr("webconsole.confirmDialog.getter.label");
+    const [descriptionPrefix, descriptionSuffix] = description.split("%S");
+
+    return createPortal([
+      dom.p({
+        className: "confirm-label",
+      },
+        dom.span({}, descriptionPrefix),
+        dom.span({className: "emphasized"}, getterName),
+        dom.span({}, descriptionSuffix)
+      ),
+      dom.button({
+        className: "confirm-button",
+        onBlur: () => this.cancel(),
+        onKeyDown: event => {
+          const {key} = event;
+          if (["Escape", "ArrowLeft", "Backspace"].includes(key)) {
+            this.cancel();
+            event.stopPropagation();
+            return;
+          }
+
+          if (["Tab", "Enter", " "].includes(key)) {
+            this.confirm();
+            event.stopPropagation();
+          }
+        },
+        // We can't use onClick because it would respond to Enter and Space keypress.
+        // We don't want that because we have a Ctrl+Space shortcut to force an
+        // autocomplete update; if the ConfirmDialog need to be displayed, since
+        // we automatically focus the button, the keyup on space would fire the onClick
+        // handler.
+        onMouseDown: this.confirm,
+      }, l10n.getStr("webconsole.confirmDialog.getter.confirmButtonLabel")),
+    ], this.tooltip.panel);
+  }
+}
+
+// Redux connect
+function mapStateToProps(state) {
+  const autocompleteData = getAutocompleteState(state);
+  return {
+    getterPath: autocompleteData.getterPath,
+  };
+}
+
+function mapDispatchToProps(dispatch) {
+  return {
+    autocompleteUpdate: getterPath =>
+      dispatch(autocompleteActions.autocompleteUpdate(true, getterPath)),
+    autocompleteClear: () => dispatch(autocompleteActions.autocompleteClear()),
+  };
+}
+
+module.exports = connect(mapStateToProps, mapDispatchToProps)(ConfirmDialog);
diff --git a/devtools/client/webconsole/components/JSTerm.js b/devtools/client/webconsole/components/JSTerm.js
--- a/devtools/client/webconsole/components/JSTerm.js
+++ b/devtools/client/webconsole/components/JSTerm.js
@@ -1163,12 +1163,11 @@
         && items[0].label !== matchProp
       )
     ) {
-      let popupAlignElement;
+      const popupAlignElement = this.props.serviceContainer.getJsTermTooltipAnchor();
       let xOffset;
       let yOffset;
 
       if (this.editor) {
-        popupAlignElement = this.node.querySelector(".CodeMirror-cursor");
         // We need to show the popup at the "." or "[".
         xOffset = -1 * matchProp.length * this._inputCharWidth;
         yOffset = 5;
@@ -1177,10 +1176,6 @@
           (inputUntilCursor.lastIndexOf("\n") + 1) -
           matchProp.length;
         xOffset = (offset * this._inputCharWidth) + this._paddingInlineStart;
-        // We use completeNode as the popup anchor as its height never exceeds the
-        // content size, whereas it can be the case for inputNode (when there's no message
-        // in the output, it takes the whole height).
-        popupAlignElement = this.completeNode;
       }
 
       if (popupAlignElement) {
diff --git a/devtools/client/webconsole/components/moz.build b/devtools/client/webconsole/components/moz.build
--- a/devtools/client/webconsole/components/moz.build
+++ b/devtools/client/webconsole/components/moz.build
@@ -10,6 +10,7 @@
 DevToolsModules(
     'App.js',
     'CollapseButton.js',
+    'ConfirmDialog.js',
     'ConsoleOutput.js',
     'ConsoleTable.js',
     'FilterBar.js',
diff --git a/devtools/client/webconsole/reducers/autocomplete.js b/devtools/client/webconsole/reducers/autocomplete.js
--- a/devtools/client/webconsole/reducers/autocomplete.js
+++ b/devtools/client/webconsole/reducers/autocomplete.js
@@ -8,22 +8,30 @@
   AUTOCOMPLETE_DATA_RECEIVE,
   AUTOCOMPLETE_PENDING_REQUEST,
   AUTOCOMPLETE_RETRIEVE_FROM_CACHE,
+  APPEND_TO_HISTORY,
+  UPDATE_HISTORY_POSITION,
+  REVERSE_SEARCH_INPUT_CHANGE,
+  REVERSE_SEARCH_BACK,
+  REVERSE_SEARCH_NEXT,
   WILL_NAVIGATE,
 } = require("devtools/client/webconsole/constants");
 
-function getDefaultState() {
+function getDefaultState(overrides = {}) {
   return Object.freeze({
     cache: null,
     matches: [],
     matchProp: null,
     isElementAccess: false,
     pendingRequestId: null,
+    isUnsafeGetter: false,
+    getterPath: null,
+    authorizedEvaluations: [],
+    ...overrides,
   });
 }
 
 function autocomplete(state = getDefaultState(), action) {
   switch (action.type) {
-    case AUTOCOMPLETE_CLEAR:
     case WILL_NAVIGATE:
       return getDefaultState();
     case AUTOCOMPLETE_RETRIEVE_FROM_CACHE:
@@ -43,16 +51,42 @@
         return getDefaultState();
       }
 
+      if (action.data.isUnsafeGetter) {
+        return {
+          ...getDefaultState(),
+          isUnsafeGetter: true,
+          getterPath: action.data.getterPath,
+          authorizedEvaluations: action.authorizedEvaluations,
+        };
+      }
+
       return {
         ...state,
+        authorizedEvaluations: action.authorizedEvaluations,
+        getterPath: null,
+        isUnsafeGetter: false,
+        pendingRequestId: null,
         cache: {
           input: action.input,
           frameActorId: action.frameActorId,
           ...action.data,
         },
-        pendingRequestId: null,
         ...action.data,
       };
+    // Reset the autocomplete data when:
+    // - clear is explicitely called
+    // - the user navigates the history
+    // - or an item was added to the history (i.e. something was evaluated).
+    case AUTOCOMPLETE_CLEAR:
+      return getDefaultState({
+        authorizedEvaluations: state.authorizedEvaluations,
+      });
+    case APPEND_TO_HISTORY:
+    case UPDATE_HISTORY_POSITION:
+    case REVERSE_SEARCH_INPUT_CHANGE:
+    case REVERSE_SEARCH_BACK:
+    case REVERSE_SEARCH_NEXT:
+      return getDefaultState();
   }
 
   return state;
@@ -101,6 +135,8 @@
 
   return {
     ...state,
+    isUnsafeGetter: false,
+    getterPath: null,
     matches: newList,
     matchProp: filterBy,
     isElementAccess: cache.isElementAccess,
diff --git a/devtools/client/webconsole/test/mochitest/browser.ini b/devtools/client/webconsole/test/mochitest/browser.ini
--- a/devtools/client/webconsole/test/mochitest/browser.ini
+++ b/devtools/client/webconsole/test/mochitest/browser.ini
@@ -195,6 +195,9 @@
 [browser_jsterm_autocomplete_crossdomain_iframe.js]
 [browser_jsterm_autocomplete_escape_key.js]
 [browser_jsterm_autocomplete_extraneous_closing_brackets.js]
+[browser_jsterm_autocomplete_getters_cache.js]
+[browser_jsterm_autocomplete_getters_cancel.js]
+[browser_jsterm_autocomplete_getters_confirm.js]
 [browser_jsterm_autocomplete_helpers.js]
 [browser_jsterm_autocomplete_in_chrome_tab.js]
 [browser_jsterm_autocomplete_in_debugger_stackframe.js]
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_cache.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_cache.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_cache.js
@@ -0,0 +1,104 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the invoke getter authorizations are cleared when expected.
+
+const TEST_URI = `data:text/html;charset=utf-8,
+<head>
+  <script>
+    /* Create a prototype-less object so popup does not contain native
+     * Object prototype properties.
+     */
+    var obj = props => Object.create(null, Object.getOwnPropertyDescriptors(props));
+    window.foo = obj({
+      get bar() {
+        return obj({
+          get baz() {
+            return obj({
+              hello: 1,
+              world: "",
+            });
+          },
+          bloop: true,
+        })
+      }
+    });
+  </script>
+</head>
+<body>Autocomplete popup - invoke getter cache test</body>`;
+
+add_task(async function() {
+  // Run test with legacy JsTerm
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+  await performTests();
+  // And then run it with the CodeMirror-powered one.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
+  await performTests();
+});
+
+async function performTests() {
+  const hud = await openNewTabAndConsole(TEST_URI);
+  const { jsterm } = hud;
+  const { autocompletePopup } = jsterm;
+  const target = await TargetFactory.forTab(gBrowser.selectedTab);
+  const toolbox = gDevTools.getToolbox(target);
+
+  let tooltip = await setInputValueForGetterConfirmDialog(toolbox, jsterm, "foo.bar.");
+  let labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter foo.bar to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that hitting Enter does invoke the getter and return its properties");
+  let onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey("KEY_Enter");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after Enter");
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "foo.bar.|");
+  is(isConfirmDialogOpened(toolbox), false, "confirm tooltip is now closed");
+
+  info("Close autocomplete popup");
+  let onPopupClose = autocompletePopup.once("popup-closed");
+  EventUtils.synthesizeKey("KEY_Escape");
+  await onPopupClose;
+
+  info("Ctrl+Space again to ensure the autocomplete is shown, not the confirm dialog");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey(" ", {ctrlKey: true});
+  await onPopUpOpen;
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "foo.bar.|");
+  is(isConfirmDialogOpened(toolbox), false, "confirm tooltip is not open");
+
+  info("Type a space, then backspace and ensure the autocomplete popup is displayed");
+  let onAutocompleteUpdate = jsterm.once("autocomplete-updated");
+  EventUtils.synthesizeKey(" ");
+  await onAutocompleteUpdate;
+  is(autocompletePopup.isOpen, true, "Autocomplete popup is still opened");
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+
+  onAutocompleteUpdate = jsterm.once("autocomplete-updated");
+  EventUtils.synthesizeKey("KEY_Backspace");
+  await onAutocompleteUpdate;
+  is(autocompletePopup.isOpen, true, "Autocomplete popup is still opened");
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+
+  info("Reload the page to ensure asking for autocomplete again show the confirm dialog");
+  onPopupClose = autocompletePopup.once("popup-closed");
+  await refreshTab();
+  await onPopupClose;
+
+  EventUtils.synthesizeKey(" ", {ctrlKey: true});
+  await waitFor(() => isConfirmDialogOpened(toolbox));
+  ok(true, "Confirm Dialog is shown after tab navigation");
+  tooltip = getConfirmDialog(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter foo.bar to retrieve the property list?",
+    "Dialog has expected text content");
+}
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_cancel.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_cancel.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_cancel.js
@@ -0,0 +1,57 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the confirm dialog can be close with different actions.
+
+const TEST_URI = `data:text/html;charset=utf-8,
+<head>
+  <script>
+    window.foo = {
+      get rab() {
+        return "";
+      }
+    };
+  </script>
+</head>
+<body>Autocomplete popup - invoke getter - close dialog test</body>`;
+
+add_task(async function() {
+  // Run test with legacy JsTerm
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+  await performTests();
+  // And then run it with the CodeMirror-powered one.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
+  await performTests();
+});
+
+async function performTests() {
+  const hud = await openNewTabAndConsole(TEST_URI);
+  const { jsterm } = hud;
+  const target = await TargetFactory.forTab(gBrowser.selectedTab);
+  const toolbox = gDevTools.getToolbox(target);
+
+  let tooltip = await setInputValueForGetterConfirmDialog(toolbox, jsterm, "foo.rab.");
+  let labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter foo.rab to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that Escape closes the confirm tooltip");
+  let onConfirmTooltipClosed = waitFor(() => !isConfirmDialogOpened(toolbox));
+  EventUtils.synthesizeKey("KEY_Escape");
+  await onConfirmTooltipClosed;
+
+  info("Check that Ctrl+space show the confirm tooltip again");
+  EventUtils.synthesizeKey(" ", {ctrlKey: true});
+  await waitFor(() => isConfirmDialogOpened(toolbox));
+  tooltip = getConfirmDialog(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter foo.rab to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that ArrowLeft closes the confirm tooltip");
+  onConfirmTooltipClosed = waitFor(() => !isConfirmDialogOpened(toolbox));
+  EventUtils.synthesizeKey("KEY_ArrowLeft");
+  await onConfirmTooltipClosed;
+}
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_confirm.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_confirm.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_getters_confirm.js
@@ -0,0 +1,138 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that accessing properties with getters displays the confirm dialog to invoke them,
+// and then displays the autocomplete popup with the results.
+
+const TEST_URI = `data:text/html;charset=utf-8,
+<head>
+  <script>
+    /* Create a prototype-less object so popup does not contain native
+     * Object prototype properties.
+     */
+    var obj = props => Object.create(null, Object.getOwnPropertyDescriptors(props));
+    window.foo = obj({
+      get bar() {
+        return obj({
+          get baz() {
+            return obj({
+              hello: 1,
+              world: "",
+            });
+          },
+          bloop: true,
+        })
+      },
+      get rab() {
+        return "";
+      }
+    });
+  </script>
+</head>
+<body>Autocomplete popup - invoke getter usage test</body>`;
+
+add_task(async function() {
+  // Run test with legacy JsTerm
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+  await performTests();
+  // And then run it with the CodeMirror-powered one.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
+  await performTests();
+});
+
+async function performTests() {
+  const hud = await openNewTabAndConsole(TEST_URI);
+  const { jsterm } = hud;
+  const { autocompletePopup } = jsterm;
+  const target = await TargetFactory.forTab(gBrowser.selectedTab);
+  const toolbox = gDevTools.getToolbox(target);
+
+  let tooltip = await setInputValueForGetterConfirmDialog(toolbox, jsterm,
+    "window.foo.bar.");
+  let labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.bar to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that hitting Enter does invoke the getter and return its properties");
+  let onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey("KEY_Enter");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after Enter");
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.|");
+  is(isConfirmDialogOpened(toolbox), false, "confirm tooltip is now closed");
+
+  let onPopUpClose = autocompletePopup.once("popup-closed");
+  EventUtils.synthesizeKey("KEY_Enter");
+  await onPopUpClose;
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.baz|");
+
+  info("Check that the invoke tooltip is displayed when performing an element access");
+  EventUtils.sendString("[");
+  await waitFor(() => isConfirmDialogOpened(toolbox));
+
+  tooltip = getConfirmDialog(toolbox);
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent,
+    "Invoke getter window.foo.bar.baz to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that hitting Tab does invoke the getter and return its properties");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey("KEY_Tab");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after Tab");
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), `"hello"-"world"`,
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.baz[|");
+  is(isConfirmDialogOpened(toolbox), false, "confirm tooltip is now closed");
+
+  onPopUpClose = autocompletePopup.once("popup-closed");
+  EventUtils.synthesizeKey("KEY_Tab");
+  await onPopUpClose;
+  checkJsTermValueAndCursor(jsterm, `window.foo.bar.baz["hello"]|`);
+
+  info("Check that autocompletion work on a getter result");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.sendString(".");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "got items of getter result");
+  ok(getAutocompletePopupLabels(autocompletePopup).includes("toExponential"),
+    "popup has expected items");
+
+  tooltip = await setInputValueForGetterConfirmDialog(toolbox, jsterm, "window.foo.rab.");
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.rab to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check clicking the confirm button invokes the getter and return its properties");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeMouseAtCenter(tooltip.querySelector(".confirm-button"), {
+    type: "mousedown",
+  }, toolbox.win);
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after clicking on the confirm button");
+  ok(getAutocompletePopupLabels(autocompletePopup).includes("startsWith"),
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.rab.|");
+  is(isConfirmDialogOpened(toolbox), false, "confirm tooltip is now closed");
+
+  info("Open the tooltip again");
+  tooltip = await setInputValueForGetterConfirmDialog(toolbox, jsterm, "window.foo.bar.");
+  labelEl = tooltip.querySelector(".confirm-label");
+  is(labelEl.textContent, "Invoke getter window.foo.bar to retrieve the property list?",
+    "Dialog has expected text content");
+
+  info("Check that Space invokes the getter and return its properties");
+  onPopUpOpen = autocompletePopup.once("popup-opened");
+  EventUtils.synthesizeKey(" ");
+  await onPopUpOpen;
+  ok(autocompletePopup.isOpen, "popup is open after space");
+  is(getAutocompletePopupLabels(autocompletePopup).join("-"), "baz-bloop",
+    "popup has expected items");
+  checkJsTermValueAndCursor(jsterm, "window.foo.bar.|");
+  is(isConfirmDialogOpened(toolbox), false, "confirm tooltip is now closed");
+}
diff --git a/devtools/client/webconsole/test/mochitest/head.js b/devtools/client/webconsole/test/mochitest/head.js
--- a/devtools/client/webconsole/test/mochitest/head.js
+++ b/devtools/client/webconsole/test/mochitest/head.js
@@ -419,6 +419,22 @@
 }
 
 /**
+ * Set the value of the JsTerm and wait for the confirm dialog to be displayed.
+ *
+ * @param {Toolbox} toolbox
+ * @param {JsTerm} jsterm
+ * @param {String} value : The value to set the jsterm to.
+ *                  Default to value.length (caret set at the end).
+ * @returns {Promise<HTMLElement>} resolves with dialog element when it is opened.
+ */
+async function setInputValueForGetterConfirmDialog(toolbox, jsterm, value) {
+  await setInputValueForAutocompletion(jsterm, value);
+  await waitFor(() => isConfirmDialogOpened(toolbox));
+  ok(true, "The confirm dialog is displayed");
+  return getConfirmDialog(toolbox);
+}
+
+/**
  * Checks if the jsterm has the expected completion value.
  *
  * @param {JsTerm} jsterm
@@ -1075,3 +1091,39 @@
     return label.textContent === nodeLabel;
   });
 }
+
+/**
+ * Return an array of the label of the autocomplete popup items.
+ *
+ * @param {AutocompletPopup} popup
+ * @returns {Array<String>}
+ */
+function getAutocompletePopupLabels(popup) {
+  return popup.getItems().map(item => item.label);
+}
+
+/**
+ * Return the "Confirm Dialog" element.
+ *
+ * @param toolbox
+ * @returns {HTMLElement|null}
+ */
+function getConfirmDialog(toolbox) {
+  const {doc} = toolbox;
+  return doc.querySelector(".invoke-confirm");
+}
+
+/**
+ * Returns true if the Confirm Dialog is opened.
+ * @param toolbox
+ * @returns {Boolean}
+ */
+function isConfirmDialogOpened(toolbox) {
+  const tooltip = getConfirmDialog(toolbox);
+  if (!tooltip) {
+    return false;
+  }
+
+  return tooltip.classList.contains("tooltip-visible");
+}
+
diff --git a/devtools/client/webconsole/webconsole-output-wrapper.js b/devtools/client/webconsole/webconsole-output-wrapper.js
--- a/devtools/client/webconsole/webconsole-output-wrapper.js
+++ b/devtools/client/webconsole/webconsole-output-wrapper.js
@@ -156,6 +156,13 @@
           }
           return null;
         },
+
+        getJsTermTooltipAnchor: () => {
+          if (jstermCodeMirror) {
+            return hud.jsterm.node.querySelector(".CodeMirror-cursor");
+          }
+          return hud.jsterm.completeNode;
+        },
       };
 
       // Set `openContextMenu` this way so, `serviceContainer` variable
@@ -303,14 +310,16 @@
       });
 
       const {prefs} = store.getState();
+      const jstermCodeMirror = prefs.jstermCodeMirror
+        && !Services.appinfo.accessibilityEnabled;
+
       const app = App({
         attachRefToHud,
         serviceContainer,
         hud,
         onFirstMeaningfulPaint: resolve,
         closeSplitConsole: this.closeSplitConsole.bind(this),
-        jstermCodeMirror: prefs.jstermCodeMirror
-          && !Services.appinfo.accessibilityEnabled,
+        jstermCodeMirror,
       });
 
       // Render the root Application component.

