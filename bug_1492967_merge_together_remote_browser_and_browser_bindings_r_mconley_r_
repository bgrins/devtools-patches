# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1537504834 25200
#      Thu Sep 20 21:40:34 2018 -0700
# Node ID 8d800c16a3e6fc2253c6ab1c72c64bf9df56860d
# Parent  5347c7e4811a1a4d80bcee4119cead9192fdff69
Bug 1492967 - Merge together remote-browser and browser bindings;r=mconley,r=ochameau

Differential Revision: https://phabricator.services.mozilla.com/D6462

diff --git a/devtools/client/responsive.html/browser/tunnel.js b/devtools/client/responsive.html/browser/tunnel.js
--- a/devtools/client/responsive.html/browser/tunnel.js
+++ b/devtools/client/responsive.html/browser/tunnel.js
@@ -59,19 +59,19 @@ const PROPERTIES_FROM_BROWSER_WINDOW = [
 
 /**
  * This module takes an "outer" <xul:browser> from a browser tab as described by
  * Firefox's tabbrowser.xml and wires it up to an "inner" <iframe mozbrowser>
  * browser element containing arbitrary page content of interest.
  *
  * The inner <iframe mozbrowser> element is _just_ the page content.  It is not
  * enough to to replace <xul:browser> on its own.  <xul:browser> comes along
- * with lots of associated functionality via XBL bindings defined for such
- * elements in browser.xml and remote-browser.xml, and the Firefox UI depends on
- * these various things to make the UI function.
+ * with lots of associated functionality via XBL binding defined for such
+ * elements in browser.xml, and the Firefox UI depends on these various things
+ * to make the UI function.
  *
  * By mapping various methods, properties, and messages from the outer browser
  * to the inner browser, we can control the content inside the inner browser
  * using the standard Firefox UI elements for navigation, reloading, and more.
  *
  * The approaches used in this module were chosen to avoid needing changes to
  * the core browser for this specialized use case.  If we start to increase
  * usage of <iframe mozbrowser> in the core browser, we should avoid this module
@@ -98,19 +98,19 @@ function tunnelToInnerBrowser(outer, inn
         throw new Error("The outer browser must be non-remote.");
       }
       if (!inner.isRemoteBrowser) {
         throw new Error("The inner browser must be remote.");
       }
 
       // Various browser methods access the `frameLoader` property, including:
       //   * `saveBrowser` from contentAreaUtils.js
-      //   * `docShellIsActive` from remote-browser.xml
-      //   * `hasContentOpener` from remote-browser.xml
-      //   * `preserveLayers` from remote-browser.xml
+      //   * `docShellIsActive` from browser.xml
+      //   * `hasContentOpener` from browser.xml
+      //   * `preserveLayers` from browser.xml
       //   * `receiveMessage` from SessionStore.jsm
       // In general, these methods are interested in the `frameLoader` for the content,
       // so we redirect them to the inner browser's `frameLoader`.
       outer[FRAME_LOADER] = outer.frameLoader;
       Object.defineProperty(outer, "frameLoader", {
         get() {
           const stack = getStack();
           // One exception is `receiveMessage` from SessionStore.jsm.  SessionStore
@@ -153,51 +153,46 @@ function tunnelToInnerBrowser(outer, inn
       // which we can use to route messages of interest to the inner browser instead.
       // Note: The _actual_ messageManager accessible from
       // `browser.frameLoader.messageManager` is not overridable and is left unchanged.
       // Only the XBL getter `browser.messageManager` is overridden.  Browser UI code
       // always uses this getter instead of `browser.frameLoader.messageManager` directly,
       // so this has the effect of overriding the message manager for browser UI code.
       mmTunnel = new MessageManagerTunnel(outer, inner);
 
+      // Clear out any cached state that references the XBL binding's non-remote state,
+      // such as form fill controllers.  Otherwise they will remain in place and leak the
+      // outer docshell.
+      outer.destroy();
+
       // We are tunneling to an inner browser with a specific remoteness, so it is simpler
       // for the logic of the browser UI to assume this tab has taken on that remoteness,
       // even though it's not true.  Since the actions the browser UI performs are sent
       // down to the inner browser by this tunnel, the tab's remoteness effectively is the
       // remoteness of the inner browser.
-      // Setting this attribute changes the browser to the remote XBL binding via CSS.
-      // The XBL binding for remote browsers uses the message manager for many actions in
-      // the UI and that works well here, since it gives us one main thing we need to
+      // By setting this attribute and then forcibly reinitializing the binding state,
+      // we start using the remote browser message manager which is used for many actions
+      // in the UI. This works well here, since it gives us one main thing we need to
       // route to the inner browser (the messages), instead of having to tweak many
-      // different browser properties.  It is safe to alter a XBL binding dynamically.
+      // different browser properties.
       // The content within is not reloaded.
       outer.setAttribute("remote", "true");
       outer.setAttribute("remoteType", inner.remoteType);
-
-      // Clear out any cached state that references the current non-remote XBL binding,
-      // such as form fill controllers.  Otherwise they will remain in place and leak the
-      // outer docshell.
-      outer.destroy();
+      outer.construct();
 
-      // The constructor of the new XBL binding is run asynchronously and there is no
-      // event to signal its completion.  Spin an event loop to watch for properties that
-      // are set by the contructor.
-      Services.tm.spinEventLoopUntil(() => {
-        return outer._remoteWebNavigation;
-      });
       // Verify that we indeed have the correct binding.
       if (!outer.isRemoteBrowser) {
         throw new Error("Browser failed to switch to remote browser binding");
       }
 
       // Replace the `webNavigation` object with our own version which tries to use
       // mozbrowser APIs where possible.  This replaces the webNavigation object that the
-      // remote-browser.xml binding creates.  We do not care about it's original value
-      // because stop() will remove the remote-browser.xml binding and these will no
-      // longer be used.
+      // remote browser binding creates.  We do not care about it's original value
+      // because stop() will remove the browser binding and these will no longer bee
+      // used.
       const webNavigation = new BrowserElementWebNavigation(inner);
       webNavigation.copyStateFrom(inner._remoteWebNavigationImpl);
       outer._remoteWebNavigation = webNavigation;
       outer._remoteWebNavigationImpl = webNavigation;
 
       // Now that we've flipped to the remote browser XBL binding, add `progressListener`
       // onto the remote version of `webProgress`.  Normally tabbrowser.xml does this step
       // when it creates a new browser, etc.  Since we manually changed the XBL binding
@@ -274,22 +269,23 @@ function tunnelToInnerBrowser(outer, inn
       }
 
       // Remove the inner browser from the WeakMap from browser to tab.
       gBrowser._tabForBrowser.delete(inner);
 
       // Remove the progress listener we added manually.
       outer.webProgress.removeProgressListener(filteredProgressListener);
 
-      // Reset the XBL binding back to the default.
+      // Reset the XBL binding back to the original state.
       outer.destroy();
 
       // Reset @remote since this is now back to a regular, non-remote browser
       outer.setAttribute("remote", "false");
       outer.removeAttribute("remoteType");
+      outer.construct();
 
       // Delete browser window properties exposed on content's owner global
       for (const property of PROPERTIES_FROM_BROWSER_WINDOW) {
         delete inner.ownerGlobal[property];
       }
 
       // Remove mozbrowser event handlers
       inner.removeEventListener("mozbrowseropenwindow", this);
diff --git a/layout/tools/reftest/reftest.jsm b/layout/tools/reftest/reftest.jsm
--- a/layout/tools/reftest/reftest.jsm
+++ b/layout/tools/reftest/reftest.jsm
@@ -173,17 +173,16 @@ function OnRefTestLoad(win)
       g.containingWindow = win;
     }
 
     if (g.browserIsIframe) {
       g.browser = g.containingWindow.document.createElementNS(XHTML_NS, "iframe");
       g.browser.setAttribute("mozbrowser", "");
     } else {
       g.browser = g.containingWindow.document.createElementNS(XUL_NS, "xul:browser");
-      g.browser.setAttribute("class", "lightweight");
     }
     g.browser.setAttribute("id", "browser");
     g.browser.setAttribute("type", "content");
     g.browser.setAttribute("primary", "true");
     g.browser.setAttribute("remote", g.browserIsRemote ? "true" : "false");
     // Make sure the browser element is exactly 800x1000, no matter
     // what size our window is
     g.browser.setAttribute("style", "padding: 0px; margin: 0px; border:none; min-width: 800px; min-height: 1000px; max-width: 800px; max-height: 1000px");
diff --git a/testing/mochitest/tests/SimpleTest/test.css b/testing/mochitest/tests/SimpleTest/test.css
--- a/testing/mochitest/tests/SimpleTest/test.css
+++ b/testing/mochitest/tests/SimpleTest/test.css
@@ -32,12 +32,8 @@
 }
 
 .tests_report {
   border-width: 2px;
   border-style: solid;
   width: 20em;
   display: table;
 }
-
-browser[remote="true"] {
-  -moz-binding: url("chrome://global/content/bindings/remote-browser.xml#remote-browser");
-}
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -79,17 +79,16 @@ toolkit.jar:
    content/global/bindings/groupbox.xml        (widgets/groupbox.xml)
    content/global/bindings/menu.xml            (widgets/menu.xml)
    content/global/bindings/menulist.xml        (widgets/menulist.xml)
    content/global/bindings/notification.xml    (widgets/notification.xml)
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/progressmeter.xml   (widgets/progressmeter.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
-   content/global/bindings/remote-browser.xml  (widgets/remote-browser.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
 *  content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
    content/global/bindings/text.xml            (widgets/text.xml)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
diff --git a/toolkit/content/widgets/browser.xml b/toolkit/content/widgets/browser.xml
--- a/toolkit/content/widgets/browser.xml
+++ b/toolkit/content/widgets/browser.xml
@@ -149,27 +149,40 @@
         Used by session restore to ensure that currentURI is set so
         that switch-to-tab works before the tab is fully
         restored. This function also invokes onLocationChanged
         listeners in tabbrowser.xml.
       -->
       <method name="_setCurrentURI">
         <parameter name="aURI"/>
         <body><![CDATA[
-          this.docShell.setCurrentURI(aURI);
+          if (this.isRemoteBrowser) {
+            this._remoteWebProgressManager.setCurrentURI(aURI);
+          } else {
+            this.docShell.setCurrentURI(aURI);
+          }
         ]]></body>
       </method>
 
+      <field name="_documentURI">null</field>
       <property name="documentURI"
-                onget="return this.contentDocument.documentURIObject;"
+                onget="return this.isRemoteBrowser ? this._documentURI : this.contentDocument.documentURIObject;"
                 readonly="true"/>
 
+
+      <field name="_documentContentType">null</field>
       <property name="documentContentType"
-                onget="return this.contentDocument ? this.contentDocument.contentType : null;"
-                readonly="true"/>
+                readonly="true">
+        <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._documentContentType;
+          }
+          return this.contentDocument ? this.contentDocument.contentType : null;
+        ]]></getter>
+      </property>
 
       <!--
         Weak reference to an optional frame loader that can be used to influence
         process selection for this browser.
         See nsIBrowser.sameProcessAsFrameLoader.
       -->
       <field name="_sameProcessAsFrameLoader">null</field>
       <property name="sameProcessAsFrameLoader">
@@ -202,60 +215,114 @@
 
       <property name="dateTimePicker"
                 onget="return document.getElementById(this.getAttribute('datetimepicker'))"
                 readonly="true"/>
 
       <property name="docShellIsActive">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              return this.frameLoader.tabParent.docShellIsActive;
+            }
             return this.docShell && this.docShell.isActive;
           ]]>
         </getter>
         <setter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              this.frameLoader.tabParent.docShellIsActive = val;
+              return val;
+            }
             if (this.docShell)
               return this.docShell.isActive = val;
             return false;
           ]]>
         </setter>
       </property>
 
       <method name="preserveLayers">
         <parameter name="preserve"/>
-        <body>
-          // Only useful for remote browsers.
-        </body>
+        <body><![CDATA[
+          if (!this.isRemoteBrowser) {
+            return;
+          }
+          let {frameLoader} = this;
+          if (frameLoader.tabParent) {
+            frameLoader.tabParent.preserveLayers(preserve);
+          }
+        ]]></body>
       </method>
 
+
       <property name="renderLayers">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              let {frameLoader} = this;
+              if (frameLoader && frameLoader.tabParent) {
+                return frameLoader.tabParent.renderLayers;
+              }
+              return false;
+            }
             return this.docShellIsActive;
           ]]>
         </getter>
         <setter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              let {frameLoader} = this;
+              if (frameLoader && frameLoader.tabParent) {
+                return frameLoader.tabParent.renderLayers = val;
+              }
+              return false;
+            }
             return this.docShellIsActive = val;
           ]]>
         </setter>
       </property>
 
       <property name="hasLayers" readonly="true">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              let {frameLoader} = this;
+              if (frameLoader.tabParent) {
+                return frameLoader.tabParent.hasLayers;
+              }
+              return false;
+            }
+
             return this.docShellIsActive;
           ]]>
         </getter>
       </property>
 
+      <method name="forceRepaint">
+        <body>
+          <![CDATA[
+            if (!this.isRemoteBrowser) {
+              return;
+            }
+            let {frameLoader} = this;
+            if (frameLoader && frameLoader.tabParent) {
+              frameLoader.tabParent.forceRepaint();
+            }
+          ]]>
+        </body>
+      </method>
+
+      <field name="_imageDocument">null</field>
       <property name="imageDocument"
                 readonly="true">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              return this._imageDocument;
+            }
             var document = this.contentDocument;
             if (!document || !(document instanceof Ci.nsIImageDocument))
               return null;
 
             try {
                 return {width: document.imageRequest.image.width, height: document.imageRequest.image.height };
             } catch (e) {}
             return null;
@@ -321,19 +388,32 @@
               return this.ownerGlobal.gBrowser;
             }
             return null;
           ]]>
         </body>
       </method>
 
       <field name="_finder">null</field>
-
+      <field name="_remoteFinder">null</field>
       <property name="finder" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            if (!this._remoteFinder) {
+              // Don't attempt to create the remote finder if the
+              // messageManager has already gone away
+              if (!this.messageManager)
+                return null;
+
+              let jsm = "resource://gre/modules/FinderParent.jsm";
+              let { FinderParent } = ChromeUtils.import(jsm, {});
+              this._remoteFinder = new FinderParent(this);
+            }
+            return this._remoteFinder;
+          }
           if (!this._finder) {
             if (!this.docShell)
               return null;
 
             let Finder = ChromeUtils.import("resource://gre/modules/Finder.jsm", {}).Finder;
             this._finder = new Finder(this.docShell);
           }
           return this._finder;
@@ -357,120 +437,201 @@
             this._fastFind = Cc["@mozilla.org/typeaheadfind;1"]
                                .createInstance(Ci.nsITypeAheadFind);
             this._fastFind.init(this.docShell);
           }
           return this._fastFind;
         ]]></getter>
       </property>
 
+      <field name="_outerWindowID">null</field>
       <property name="outerWindowID" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._outerWindowID;
+          }
           return this.contentWindow.windowUtils.outerWindowID;
         ]]></getter>
       </property>
 
+      <field name="_innerWindowID">null</field>
       <property name="innerWindowID" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._innerWindowID;
+          }
           try {
             return this.contentWindow.windowUtils.currentInnerWindowID;
           } catch (e) {
             if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {
               throw e;
             }
             return null;
           }
         ]]></getter>
       </property>
 
       <field name="_lastSearchString">null</field>
 
+
+      <field name="_controller">null</field>
+
+      <field name="_selectParentHelper">null</field>
+
+      <field name="_remoteWebNavigation">null</field>
+      <!-- Note that this overrides webNavigation on XULFrameElement, and duplicates the return value for the non-remote case -->
+      <property name="webNavigation"
+                readonly="true"
+                onget="return this.isRemoteBrowser ? this._remoteWebNavigation : this.docShell.QueryInterface(Components.interfaces.nsIWebNavigation);"/>
+
+      <field name="_remoteWebProgress">null</field>
       <property name="webProgress"
                 readonly="true"
-                onget="return this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);"/>
+                onget="return this.isRemoteBrowser ? this._remoteWebProgress : this.docShell.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebProgress);"/>
 
+      <field name="_contentWindow">null</field>
       <property name="contentWindowAsCPOW"
                 readonly="true"
-                onget="return this.contentWindow;"/>
+                onget="return this.isRemoteBrowser ? this._contentWindow : this.contentWindow;"/>
 
       <property name="sessionHistory"
                 onget="return this.webNavigation.sessionHistory;"
                 readonly="true"/>
 
       <property name="markupDocumentViewer"
                 onget="return this.docShell.contentViewer;"
                 readonly="true"/>
 
+      <field name="_contentDocument">null</field>
       <property name="contentDocumentAsCPOW"
-                onget="return this.contentDocument;"
+                onget="return this.isRemoteBrowser ? this._contentDocument : this.contentDocument;"
+                readonly="true"/>
+
+      <field name="_contentTitle">""</field>
+      <property name="contentTitle"
+                onget="return this.isRemoteBrowser ? this._contentTitle : this.contentDocument.title;"
                 readonly="true"/>
 
-      <property name="contentTitle"
-                onget="return this.contentDocument.title;"
-                readonly="true"/>
-
+      <field name="_characterSet">""</field>
       <property name="characterSet"
-                onget="return this.docShell.charset;">
+                onget="return this.isRemoteBrowser ? this._characterSet : this.docShell.charset;">
         <setter><![CDATA[
-          this.docShell.charset = val;
-          this.docShell.gatherCharsetMenuTelemetry();
+          if (this.isRemoteBrowser) {
+            this.messageManager.sendAsyncMessage("UpdateCharacterSet", {value: val});
+            this._characterSet = val;
+          } else {
+            this.docShell.charset = val;
+            this.docShell.gatherCharsetMenuTelemetry();
+          }
         ]]></setter>
       </property>
 
+      <field name="_mayEnableCharacterEncodingMenu">null</field>
       <property name="mayEnableCharacterEncodingMenu"
-                onget="return this.docShell.mayEnableCharacterEncodingMenu;"
+                onget="return this.isRemoteBrowser ? this._mayEnableCharacterEncodingMenu : this.docShell.mayEnableCharacterEncodingMenu;"
                 readonly="true"/>
 
+      <field name="_contentPrincipal">null</field>
       <property name="contentPrincipal"
-                onget="return this.contentDocument.nodePrincipal;"
+                onget="return this.isRemoteBrowser ? this._contentPrincipal : this.contentDocument.nodePrincipal;"
                 readonly="true"/>
 
+      <field name="_contentRequestContextID">null</field>
       <property name="contentRequestContextID" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._contentRequestContextID;
+          }
           try {
             return this.contentDocument.documentLoadGroup
                        .requestContextID;
           } catch (e) {
             return null;
           }
         ]]></getter>
       </property>
 
       <property name="showWindowResizer"
                 onset="if (val) this.setAttribute('showresizer', 'true');
                        else this.removeAttribute('showresizer');
                        return val;"
                 onget="return this.getAttribute('showresizer') == 'true';"/>
 
+      <field name="_fullZoom">1</field>
       <property name="fullZoom">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._fullZoom;
+          }
           return this.markupDocumentViewer.fullZoom;
         ]]></getter>
         <setter><![CDATA[
-          this.markupDocumentViewer.fullZoom = val;
+          if (this.isRemoteBrowser) {
+            let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
+
+            if (changed) {
+              this._fullZoom = val;
+              try {
+                this.messageManager.sendAsyncMessage("FullZoom", {value: val});
+              } catch (ex) {}
+
+              let event = new Event("FullZoomChange", {bubbles: true});
+              this.dispatchEvent(event);
+            }
+          } else {
+            this.markupDocumentViewer.fullZoom = val;
+          }
         ]]></setter>
       </property>
 
+      <field name="_textZoom">1</field>
       <property name="textZoom">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._textZoom;
+          }
           return this.markupDocumentViewer.textZoom;
         ]]></getter>
         <setter><![CDATA[
-          this.markupDocumentViewer.textZoom = val;
+          if (this.isRemoteBrowser) {
+            let changed = val.toFixed(2) != this._textZoom.toFixed(2);
+
+            if (changed) {
+              this._textZoom = val;
+              try {
+                this.messageManager.sendAsyncMessage("TextZoom", {value: val});
+              } catch (ex) {}
+
+              let event = new Event("TextZoomChange", {bubbles: true});
+              this.dispatchEvent(event);
+            }
+          } else {
+            this.markupDocumentViewer.textZoom = val;
+          }
+
+        ]]></setter>
+        <setter><![CDATA[
         ]]></setter>
       </property>
 
+      <field name="_isSyntheticDocument">false</field>
       <property name="isSyntheticDocument">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._isSyntheticDocument;
+          }
           return this.contentDocument.mozSyntheticDocument;
         ]]></getter>
       </property>
 
       <property name="hasContentOpener">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this.frameLoader.tabParent.hasContentOpener;
+          }
           return !!this.contentWindow.opener;
         ]]></getter>
       </property>
 
       <field name="mPrefs" readonly="true">
         Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
       </field>
 
@@ -722,37 +883,53 @@
               return;
             }
             this.messageManager.sendAsyncMessage("Browser:UnselectedTabHover",
               { hovered });
           ]]>
         </body>
       </method>
 
-      <property name="securityUI">
+      <field name="_securityUI">null</field>
+      <property name="securityUI"
+                readonly="true">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              if (!this._securityUI) {
+                // Don't attempt to create the remote web progress if the
+                // messageManager has already gone away
+                if (!this.messageManager)
+                  return null;
+
+                let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
+                let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
+                this._securityUI = new RemoteSecurityUI();
+              }
+
+              // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
+              var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
+                          .createInstance(Ci.nsISupportsInterfacePointer);
+              ptr.data = this._securityUI;
+              return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
+            }
+
             if (!this.docShell.securityUI) {
               const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
               if (!this.hasAttribute("disablesecurity") &&
                   SECUREBROWSERUI_CONTRACTID in Cc) {
                 var securityUI = Cc[SECUREBROWSERUI_CONTRACTID]
                                    .createInstance(Ci.nsISecureBrowserUI);
                 securityUI.init(this.contentWindow);
               }
             }
 
             return this.docShell.securityUI;
           ]]>
         </getter>
-        <setter>
-          <![CDATA[
-            this.docShell.securityUI = val;
-          ]]>
-        </setter>
       </property>
 
       <field name="urlbarChangeTracker">
         ({
           _startedLoadSinceLastUserTyping: false,
 
           startedLoad() {
             this._startedLoadSinceLastUserTyping = true;
@@ -794,16 +971,72 @@
 
       <!-- This is managed by the tabbrowser -->
       <field name="lastURI">null</field>
 
       <field name="mDestroyed">false</field>
 
       <constructor>
         <![CDATA[
+        this.construct();
+        ]]>
+      </constructor>
+
+      <method name="construct">
+        <body><![CDATA[
+          if (this.isRemoteBrowser) {
+            /*
+            * Don't try to send messages from this function. The message manager for
+            * the <browser> element may not be initialized yet.
+            */
+
+            this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
+                                          .createInstance(Ci.nsIWebNavigation);
+            this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
+            this._remoteWebNavigationImpl.swapBrowser(this);
+
+            // Initialize contentPrincipal to the about:blank principal for this loadcontext
+            let {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
+            let aboutBlank = Services.io.newURI("about:blank");
+            let ssm = Services.scriptSecurityManager;
+            this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
+
+            this.messageManager.addMessageListener("Browser:Init", this);
+            this.messageManager.addMessageListener("DOMTitleChanged", this);
+            this.messageManager.addMessageListener("ImageDocumentLoaded", this);
+            this.messageManager.addMessageListener("FullZoomChange", this);
+            this.messageManager.addMessageListener("TextZoomChange", this);
+            this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
+
+            // browser-child messages, such as Content:LocationChange, are handled in
+            // RemoteWebProgress, ensure it is loaded and ready.
+            let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
+            let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
+            this._remoteWebProgressManager = new RemoteWebProgressManager(this);
+            this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
+
+            this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
+
+            if (this.hasAttribute("selectmenulist")) {
+              this.messageManager.addMessageListener("Forms:ShowDropDown", this);
+              this.messageManager.addMessageListener("Forms:HideDropDown", this);
+            }
+
+            if (!this.hasAttribute("disablehistory")) {
+              Services.obs.addObserver(this, "browser:purge-session-history", true);
+            }
+
+            let rc_js = "resource://gre/modules/RemoteController.js";
+            let scope = {};
+            Services.scriptloader.loadSubScript(rc_js, scope);
+            let RemoteController = scope.RemoteController;
+            this._controller = new RemoteController(this);
+            this.controllers.appendController(this._controller);
+          }
+
           try {
             // |webNavigation.sessionHistory| will have been set by the frame
             // loader when creating the docShell as long as this xul:browser
             // doesn't have the 'disablehistory' attribute set.
             if (this.docShell && this.webNavigation.sessionHistory) {
               var os = Cc["@mozilla.org/observer-service;1"]
                          .getService(Ci.nsIObserverService);
               os.addObserver(this, "browser:purge-session-history", true);
@@ -853,42 +1086,61 @@
             this.messageManager.addMessageListener("AudibleAutoplayMediaOccurred", this);
 
             if (this.hasAttribute("selectmenulist")) {
               this.messageManager.addMessageListener("Forms:ShowDropDown", this);
               this.messageManager.addMessageListener("Forms:HideDropDown", this);
             }
 
           }
-        ]]>
-      </constructor>
+        ]]></body>
+      </method>
 
       <destructor>
         <![CDATA[
           this.destroy();
         ]]>
       </destructor>
 
+
       <!-- This is necessary because the destructor doesn't always get called when
            we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
 
-           Note: this function is overriden in remote-browser.xml, so any clean-up that
-           also applies to browser.isRemoteBrowser = true must be duplicated there. -->
+           Note: This overrides the destroy() method from browser.xml. -->
       <method name="destroy">
-        <body>
-          <![CDATA[
+        <body><![CDATA[
           // Make sure that any open select is closed.
           if (this._selectParentHelper) {
             let menulist = document.getElementById(this.getAttribute("selectmenulist"));
             this._selectParentHelper.hide(menulist, this);
           }
           if (this.mDestroyed)
             return;
           this.mDestroyed = true;
 
+          if (this.isRemoteBrowser) {
+            try {
+              this.controllers.removeController(this._controller);
+            } catch (ex) {
+              // This can fail when this browser element is not attached to a
+              // BrowserDOMWindow.
+            }
+
+            if (!this.hasAttribute("disablehistory")) {
+              let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
+              try {
+                Services.obs.removeObserver(this, "browser:purge-session-history");
+              } catch (ex) {
+                // It's not clear why this sometimes throws an exception.
+              }
+            }
+
+            return;
+          }
+
           if (this.docShell && this.webNavigation.sessionHistory) {
             var os = Cc["@mozilla.org/observer-service;1"]
                        .getService(Ci.nsIObserverService);
             try {
               os.removeObserver(this, "browser:purge-session-history");
             } catch (ex) {
               // It's not clear why this sometimes throws an exception.
             }
@@ -902,20 +1154,20 @@
           if (!this.isRemoteBrowser) {
             this.removeEventListener("pagehide", this.onPageHide, true);
           }
 
           if (this._autoScrollNeedsCleanup) {
             // we polluted the global scope, so clean it up
             this._autoScrollPopup.remove();
           }
-          ]]>
-        </body>
+        ]]></body>
       </method>
 
+
       <!--
         We call this _receiveMessage (and alias receiveMessage to it) so that
         bindings that inherit from this one can delegate to it.
       -->
       <method name="_receiveMessage">
         <parameter name="aMessage"/>
         <body><![CDATA[
           let data = aMessage.data;
@@ -1006,20 +1258,102 @@
           }
           return undefined;
         ]]></body>
       </method>
 
       <method name="receiveMessage">
         <parameter name="aMessage"/>
         <body><![CDATA[
-          return this._receiveMessage(aMessage);
+          if (!this.isRemoteBrowser) {
+            return this._receiveMessage(aMessage);
+          }
+
+          let data = aMessage.data;
+          switch (aMessage.name) {
+            case "Browser:Init":
+              this._outerWindowID = data.outerWindowID;
+              break;
+            case "DOMTitleChanged":
+              this._contentTitle = data.title;
+              break;
+            case "ImageDocumentLoaded":
+              this._imageDocument = {
+                width: data.width,
+                height: data.height,
+              };
+              break;
+
+            case "Forms:ShowDropDown": {
+              if (!this._selectParentHelper) {
+                this._selectParentHelper =
+                  ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
+              }
+
+              let menulist = document.getElementById(this.getAttribute("selectmenulist"));
+              menulist.menupopup.style.direction = data.direction;
+
+              let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
+                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;
+              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
+                                                zoom, data.uaBackgroundColor, data.uaColor,
+                                                data.uaSelectBackgroundColor, data.uaSelectColor,
+                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
+              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
+              break;
+            }
+
+            case "FullZoomChange": {
+              this._fullZoom = data.value;
+              let event = document.createEvent("Events");
+              event.initEvent("FullZoomChange", true, false);
+              this.dispatchEvent(event);
+              break;
+            }
+
+            case "TextZoomChange": {
+              this._textZoom = data.value;
+              let event = document.createEvent("Events");
+              event.initEvent("TextZoomChange", true, false);
+              this.dispatchEvent(event);
+              break;
+            }
+
+            case "ZoomChangeUsingMouseWheel": {
+              let event = document.createEvent("Events");
+              event.initEvent("ZoomChangeUsingMouseWheel", true, false);
+              this.dispatchEvent(event);
+              break;
+            }
+
+            default:
+              return this._receiveMessage(aMessage);
+          }
+          return undefined;
+
         ]]></body>
       </method>
 
+      <method name="enableDisableCommandsRemoteOnly">
+        <parameter name="aAction"/>
+        <parameter name="aEnabledLength"/>
+        <parameter name="aEnabledCommands"/>
+        <parameter name="aDisabledLength"/>
+        <parameter name="aDisabledCommands"/>
+        <body>
+          <![CDATA[
+          if (this._controller) {
+            this._controller.enableDisableCommands(aAction,
+                                                   aEnabledLength, aEnabledCommands,
+                                                   aDisabledLength, aDisabledCommands);
+          }
+          ]]>
+        </body>
+      </method>
+
       <method name="observe">
         <parameter name="aSubject"/>
         <parameter name="aTopic"/>
         <parameter name="aState"/>
         <body>
           <![CDATA[
             if (aTopic == "browser:purge-session-history") {
               this.purgeSessionHistory();
@@ -1036,25 +1370,49 @@
             }
           ]]>
         </body>
       </method>
 
       <method name="purgeSessionHistory">
         <body>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              try {
+                this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+              } catch (ex) {
+                // This can throw if the browser has started to go away.
+                if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
+                  throw ex;
+                }
+              }
+              this._remoteWebNavigationImpl.canGoBack = false;
+              this._remoteWebNavigationImpl.canGoForward = false;
+              return;
+            }
             this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
           ]]>
         </body>
       </method>
 
       <method name="createAboutBlankContentViewer">
         <parameter name="aPrincipal"/>
         <body>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              // Ensure that the content process has the permissions which are
+              // needed to create a document with the given principal.
+              let permissionPrincipal =
+                BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
+              this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
+
+              // Create the about blank content viewer in the content process
+              this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
+              return;
+            }
             let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
             this.docShell.createAboutBlankContentViewer(principal);
           ]]>
         </body>
       </method>
 
       <field name="_AUTOSCROLL_SNAP">10</field>
       <field name="_scrolling">false</field>
@@ -1402,20 +1760,33 @@
           event = new CustomEvent("EndSwapDocShells", {"detail": aOtherBrowser});
           this.dispatchEvent(event);
           event = new CustomEvent("EndSwapDocShells", {"detail": this});
           aOtherBrowser.dispatchEvent(event);
         ]]>
         </body>
       </method>
 
+      <field name="_permitUnloadId">0</field>
       <method name="getInPermitUnload">
         <parameter name="aCallback"/>
         <body>
         <![CDATA[
+          if (this.isRemoteBrowser) {
+            let id = this._permitUnloadId++;
+            let mm = this.messageManager;
+            mm.sendAsyncMessage("InPermitUnload", {id});
+            mm.addMessageListener("InPermitUnload", function listener(msg) {
+              if (msg.data.id != id) {
+                return;
+              }
+              aCallback(msg.data.inPermitUnload);
+            });
+          }
+
           if (!this.docShell || !this.docShell.contentViewer) {
             aCallback(false);
             return;
           }
           aCallback(this.docShell.contentViewer.inPermitUnload);
         ]]>
         </body>
       </method>
@@ -1427,16 +1798,80 @@
       <property name="dontPromptAndUnload"
                 onget="return 2;"
                 readonly="true"/>
 
       <method name="permitUnload">
         <parameter name="aPermitUnloadFlags"/>
         <body>
         <![CDATA[
+          if (this.isRemoteBrowser) {
+            let {tabParent} = this.frameLoader;
+
+            if (!tabParent.hasBeforeUnload) {
+              return { permitUnload: true, timedOut: false };
+            }
+
+            const kTimeout = 1000;
+
+            let finished = false;
+            let responded = false;
+            let permitUnload;
+            let id = this._permitUnloadId++;
+            let mm = this.messageManager;
+            let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
+
+            let msgListener = msg => {
+              if (msg.data.id != id) {
+                return;
+              }
+              if (msg.data.kind == "start") {
+                responded = true;
+                return;
+              }
+              done(msg.data.permitUnload);
+            };
+
+            let observer = subject => {
+              if (subject == mm) {
+                done(true);
+              }
+            };
+
+            function done(result) {
+              finished = true;
+              permitUnload = result;
+              mm.removeMessageListener("PermitUnload", msgListener);
+              Services.obs.removeObserver(observer, "message-manager-close");
+            }
+
+            mm.sendAsyncMessage("PermitUnload", {id, aPermitUnloadFlags});
+            mm.addMessageListener("PermitUnload", msgListener);
+            Services.obs.addObserver(observer, "message-manager-close");
+
+            let timedOut = false;
+            function timeout() {
+              if (!responded) {
+                timedOut = true;
+              }
+
+              // Dispatch something to ensure that the main thread wakes up.
+              Services.tm.dispatchToMainThread(function() {});
+            }
+
+            let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+            timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
+
+            while (!finished && !timedOut) {
+              Services.tm.currentThread.processNextEvent(true);
+            }
+
+            return {permitUnload, timedOut};
+          }
+
           if (!this.docShell || !this.docShell.contentViewer) {
             return {permitUnload: true, timedOut: false};
           }
           return {permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),
                   timedOut: false};
         ]]>
         </body>
       </method>
@@ -1576,13 +2011,23 @@
         }
 
         if (links.length) {
           let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
           this.droppedLinkHandler(event, links, triggeringPrincipal);
         }
       ]]>
       </handler>
+      <handler event="dragstart">
+      <![CDATA[
+        // If we're a remote browser dealing with a dragstart, stop it
+        // from propagating up, since our content process should be dealing
+        // with the mouse movement.
+        if (this.isRemoteBrowser) {
+          event.stopPropagation();
+        }
+      ]]>
+      </handler>
     </handlers>
 
   </binding>
 
 </bindings>
diff --git a/toolkit/content/widgets/remote-browser.xml b/toolkit/content/widgets/remote-browser.xml
deleted file mode 100644
--- a/toolkit/content/widgets/remote-browser.xml
+++ /dev/null
@@ -1,600 +0,0 @@
-<?xml version="1.0"?>
-
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<bindings id="firefoxBrowserBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-
-  <binding id="remote-browser" extends="chrome://global/content/bindings/browser.xml#browser">
-
-    <implementation type="application/javascript">
-
-      <field name="_securityUI">null</field>
-
-      <property name="securityUI"
-                readonly="true">
-        <getter><![CDATA[
-          if (!this._securityUI) {
-            // Don't attempt to create the remote web progress if the
-            // messageManager has already gone away
-            if (!this.messageManager)
-              return null;
-
-            let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
-            let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
-            this._securityUI = new RemoteSecurityUI();
-          }
-
-          // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
-          var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
-                      .createInstance(Ci.nsISupportsInterfacePointer);
-          ptr.data = this._securityUI;
-          return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
-        ]]></getter>
-      </property>
-
-      <field name="_controller">null</field>
-
-      <field name="_selectParentHelper">null</field>
-
-      <field name="_remoteWebNavigation">null</field>
-
-      <property name="webNavigation"
-                onget="return this._remoteWebNavigation;"
-                readonly="true"/>
-
-      <field name="_remoteWebProgress">null</field>
-
-      <property name="webProgress"
-                onget="return this._remoteWebProgress;"
-                readonly="true"/>
-
-      <field name="_remoteFinder">null</field>
-
-      <property name="finder" readonly="true">
-        <getter><![CDATA[
-          if (!this._remoteFinder) {
-            // Don't attempt to create the remote finder if the
-            // messageManager has already gone away
-            if (!this.messageManager)
-              return null;
-
-            let jsm = "resource://gre/modules/FinderParent.jsm";
-            let { FinderParent } = ChromeUtils.import(jsm, {});
-            this._remoteFinder = new FinderParent(this);
-          }
-          return this._remoteFinder;
-        ]]></getter>
-      </property>
-
-      <field name="_documentURI">null</field>
-
-      <field name="_documentContentType">null</field>
-
-      <!--
-        Used by session restore to ensure that currentURI is set so
-        that switch-to-tab works before the tab is fully
-        restored. This function also invokes onLocationChanged
-        listeners in tabbrowser.xml.
-      -->
-      <method name="_setCurrentURI">
-        <parameter name="aURI"/>
-        <body><![CDATA[
-          this._remoteWebProgressManager.setCurrentURI(aURI);
-        ]]></body>
-      </method>
-
-      <property name="documentURI"
-                onget="return this._documentURI;"
-                readonly="true"/>
-
-      <property name="documentContentType"
-                onget="return this._documentContentType;"
-                readonly="true"/>
-
-      <field name="_contentTitle">""</field>
-
-      <property name="contentTitle"
-                onget="return this._contentTitle"
-                readonly="true"/>
-
-      <field name="_characterSet">""</field>
-
-      <property name="characterSet"
-                onget="return this._characterSet">
-        <setter><![CDATA[
-          this.messageManager.sendAsyncMessage("UpdateCharacterSet", {value: val});
-          this._characterSet = val;
-        ]]></setter>
-      </property>
-
-      <field name="_mayEnableCharacterEncodingMenu">null</field>
-
-      <property name="mayEnableCharacterEncodingMenu"
-                onget="return this._mayEnableCharacterEncodingMenu;"
-                readonly="true"/>
-
-      <field name="_contentWindow">null</field>
-
-      <property name="contentWindow"
-                onget="return null"
-                readonly="true"/>
-
-      <property name="contentWindowAsCPOW"
-                onget="return this._contentWindow"
-                readonly="true"/>
-
-      <property name="contentDocument"
-                onget="return null"
-                readonly="true"/>
-
-      <field name="_contentPrincipal">null</field>
-
-      <property name="contentPrincipal"
-                onget="return this._contentPrincipal"
-                readonly="true"/>
-
-      <field name="_contentRequestContextID">null</field>
-
-      <property name="contentRequestContextID"
-                onget="return this._contentRequestContextID"
-                readonly="true"/>
-
-      <field name="_contentDocument">null</field>
-
-      <property name="contentDocumentAsCPOW"
-                onget="return this._contentDocument"
-                readonly="true"/>
-
-      <field name="_imageDocument">null</field>
-
-      <property name="imageDocument"
-                onget="return this._imageDocument"
-                readonly="true"/>
-
-      <field name="_fullZoom">1</field>
-      <property name="fullZoom">
-        <getter><![CDATA[
-          return this._fullZoom;
-        ]]></getter>
-        <setter><![CDATA[
-          let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
-
-          if (changed) {
-            this._fullZoom = val;
-            try {
-              this.messageManager.sendAsyncMessage("FullZoom", {value: val});
-            } catch (ex) {}
-
-            let event = new Event("FullZoomChange", {bubbles: true});
-            this.dispatchEvent(event);
-          }
-        ]]></setter>
-      </property>
-
-      <field name="_textZoom">1</field>
-      <property name="textZoom">
-        <getter><![CDATA[
-          return this._textZoom;
-        ]]></getter>
-        <setter><![CDATA[
-          let changed = val.toFixed(2) != this._textZoom.toFixed(2);
-
-          if (changed) {
-            this._textZoom = val;
-            try {
-              this.messageManager.sendAsyncMessage("TextZoom", {value: val});
-            } catch (ex) {}
-
-            let event = new Event("TextZoomChange", {bubbles: true});
-            this.dispatchEvent(event);
-          }
-        ]]></setter>
-      </property>
-
-      <field name="_isSyntheticDocument">false</field>
-      <property name="isSyntheticDocument">
-        <getter><![CDATA[
-          return this._isSyntheticDocument;
-        ]]></getter>
-      </property>
-
-      <property name="hasContentOpener">
-        <getter><![CDATA[
-          return this.frameLoader.tabParent.hasContentOpener;
-        ]]></getter>
-      </property>
-
-      <field name="_outerWindowID">null</field>
-      <property name="outerWindowID"
-                onget="return this._outerWindowID"
-                readonly="true"/>
-
-      <field name="_innerWindowID">null</field>
-      <property name="innerWindowID">
-        <getter><![CDATA[
-          return this._innerWindowID;
-        ]]></getter>
-      </property>
-
-      <property name="docShellIsActive">
-        <getter>
-          <![CDATA[
-            return this.frameLoader.tabParent.docShellIsActive;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            this.frameLoader.tabParent.docShellIsActive = val;
-            return val;
-          ]]>
-        </setter>
-      </property>
-
-      <method name="preserveLayers">
-        <parameter name="preserve"/>
-        <body><![CDATA[
-          let {frameLoader} = this;
-          if (frameLoader.tabParent) {
-            frameLoader.tabParent.preserveLayers(preserve);
-          }
-        ]]></body>
-      </method>
-
-      <property name="renderLayers">
-        <getter>
-          <![CDATA[
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              return frameLoader.tabParent.renderLayers;
-            }
-            return false;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              return frameLoader.tabParent.renderLayers = val;
-            }
-            return false;
-          ]]>
-        </setter>
-      </property>
-
-      <method name="forceRepaint">
-        <body>
-          <![CDATA[
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              frameLoader.tabParent.forceRepaint();
-            }
-          ]]>
-        </body>
-      </method>
-
-      <property name="hasLayers" readonly="true">
-        <getter><![CDATA[
-          let {frameLoader} = this;
-          if (frameLoader.tabParent) {
-            return frameLoader.tabParent.hasLayers;
-          }
-          return false;
-        ]]></getter>
-      </property>
-
-      <field name="mDestroyed">false</field>
-
-      <field name="_permitUnloadId">0</field>
-
-      <method name="getInPermitUnload">
-        <parameter name="aCallback"/>
-        <body>
-        <![CDATA[
-          let id = this._permitUnloadId++;
-          let mm = this.messageManager;
-          mm.sendAsyncMessage("InPermitUnload", {id});
-          mm.addMessageListener("InPermitUnload", function listener(msg) {
-            if (msg.data.id != id) {
-              return;
-            }
-            aCallback(msg.data.inPermitUnload);
-          });
-        ]]>
-        </body>
-      </method>
-
-      <method name="permitUnload">
-        <parameter name="aPermitUnloadFlags"/>
-        <body>
-        <![CDATA[
-          let {tabParent} = this.frameLoader;
-
-          if (!tabParent.hasBeforeUnload) {
-            return { permitUnload: true, timedOut: false };
-          }
-
-          const kTimeout = 1000;
-
-          let finished = false;
-          let responded = false;
-          let permitUnload;
-          let id = this._permitUnloadId++;
-          let mm = this.messageManager;
-          let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-
-          let msgListener = msg => {
-            if (msg.data.id != id) {
-              return;
-            }
-            if (msg.data.kind == "start") {
-              responded = true;
-              return;
-            }
-            done(msg.data.permitUnload);
-          };
-
-          let observer = subject => {
-            if (subject == mm) {
-              done(true);
-            }
-          };
-
-          function done(result) {
-            finished = true;
-            permitUnload = result;
-            mm.removeMessageListener("PermitUnload", msgListener);
-            Services.obs.removeObserver(observer, "message-manager-close");
-          }
-
-          mm.sendAsyncMessage("PermitUnload", {id, aPermitUnloadFlags});
-          mm.addMessageListener("PermitUnload", msgListener);
-          Services.obs.addObserver(observer, "message-manager-close");
-
-          let timedOut = false;
-          function timeout() {
-            if (!responded) {
-              timedOut = true;
-            }
-
-            // Dispatch something to ensure that the main thread wakes up.
-            Services.tm.dispatchToMainThread(function() {});
-          }
-
-          let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-          timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
-
-          while (!finished && !timedOut) {
-            Services.tm.currentThread.processNextEvent(true);
-          }
-
-          return {permitUnload, timedOut};
-        ]]>
-        </body>
-      </method>
-
-      <constructor>
-        <![CDATA[
-          /*
-           * Don't try to send messages from this function. The message manager for
-           * the <browser> element may not be initialized yet.
-           */
-
-          this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
-                                        .createInstance(Ci.nsIWebNavigation);
-          this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
-          this._remoteWebNavigationImpl.swapBrowser(this);
-
-          // Initialize contentPrincipal to the about:blank principal for this loadcontext
-          let {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
-          let aboutBlank = Services.io.newURI("about:blank");
-          let ssm = Services.scriptSecurityManager;
-          this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
-
-          this.messageManager.addMessageListener("Browser:Init", this);
-          this.messageManager.addMessageListener("DOMTitleChanged", this);
-          this.messageManager.addMessageListener("ImageDocumentLoaded", this);
-          this.messageManager.addMessageListener("FullZoomChange", this);
-          this.messageManager.addMessageListener("TextZoomChange", this);
-          this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
-
-          // browser-child messages, such as Content:LocationChange, are handled in
-          // RemoteWebProgress, ensure it is loaded and ready.
-          let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
-          let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
-          this._remoteWebProgressManager = new RemoteWebProgressManager(this);
-          this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
-
-          this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
-
-          if (this.hasAttribute("selectmenulist")) {
-            this.messageManager.addMessageListener("Forms:ShowDropDown", this);
-            this.messageManager.addMessageListener("Forms:HideDropDown", this);
-          }
-
-          if (!this.hasAttribute("disablehistory")) {
-            Services.obs.addObserver(this, "browser:purge-session-history", true);
-          }
-
-          let rc_js = "resource://gre/modules/RemoteController.js";
-          let scope = {};
-          Services.scriptloader.loadSubScript(rc_js, scope);
-          let RemoteController = scope.RemoteController;
-          this._controller = new RemoteController(this);
-          this.controllers.appendController(this._controller);
-        ]]>
-      </constructor>
-
-      <destructor>
-        <![CDATA[
-          this.destroy();
-        ]]>
-      </destructor>
-
-      <!-- This is necessary because the destructor doesn't always get called when
-           we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
-
-           Note: This overrides the destroy() method from browser.xml. -->
-      <method name="destroy">
-        <body><![CDATA[
-          // Make sure that any open select is closed.
-          if (this._selectParentHelper) {
-            let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-            this._selectParentHelper.hide(menulist, this);
-          }
-
-          if (this.mDestroyed)
-            return;
-          this.mDestroyed = true;
-
-          try {
-            this.controllers.removeController(this._controller);
-          } catch (ex) {
-            // This can fail when this browser element is not attached to a
-            // BrowserDOMWindow.
-          }
-
-          if (!this.hasAttribute("disablehistory")) {
-            let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-            try {
-              Services.obs.removeObserver(this, "browser:purge-session-history");
-            } catch (ex) {
-              // It's not clear why this sometimes throws an exception.
-            }
-          }
-        ]]></body>
-      </method>
-
-      <method name="receiveMessage">
-        <parameter name="aMessage"/>
-        <body><![CDATA[
-          let data = aMessage.data;
-          switch (aMessage.name) {
-            case "Browser:Init":
-              this._outerWindowID = data.outerWindowID;
-              break;
-            case "DOMTitleChanged":
-              this._contentTitle = data.title;
-              break;
-            case "ImageDocumentLoaded":
-              this._imageDocument = {
-                width: data.width,
-                height: data.height,
-              };
-              break;
-
-            case "Forms:ShowDropDown": {
-              if (!this._selectParentHelper) {
-                this._selectParentHelper =
-                  ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
-              }
-
-              let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-              menulist.menupopup.style.direction = data.direction;
-
-              let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
-                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;
-              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
-                                                zoom, data.uaBackgroundColor, data.uaColor,
-                                                data.uaSelectBackgroundColor, data.uaSelectColor,
-                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
-              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
-              break;
-            }
-
-            case "FullZoomChange": {
-              this._fullZoom = data.value;
-              let event = document.createEvent("Events");
-              event.initEvent("FullZoomChange", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            case "TextZoomChange": {
-              this._textZoom = data.value;
-              let event = document.createEvent("Events");
-              event.initEvent("TextZoomChange", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            case "ZoomChangeUsingMouseWheel": {
-              let event = document.createEvent("Events");
-              event.initEvent("ZoomChangeUsingMouseWheel", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            default:
-              // Delegate to browser.xml.
-              return this._receiveMessage(aMessage);
-          }
-          return undefined;
-        ]]></body>
-      </method>
-
-      <method name="enableDisableCommandsRemoteOnly">
-        <parameter name="aAction"/>
-        <parameter name="aEnabledLength"/>
-        <parameter name="aEnabledCommands"/>
-        <parameter name="aDisabledLength"/>
-        <parameter name="aDisabledCommands"/>
-        <body>
-          if (this._controller) {
-            this._controller.enableDisableCommands(aAction,
-                                                   aEnabledLength, aEnabledCommands,
-                                                   aDisabledLength, aDisabledCommands);
-          }
-        </body>
-      </method>
-
-      <method name="purgeSessionHistory">
-        <body>
-          <![CDATA[
-            try {
-              this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
-            } catch (ex) {
-              // This can throw if the browser has started to go away.
-              if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
-                throw ex;
-              }
-            }
-            this._remoteWebNavigationImpl.canGoBack = false;
-            this._remoteWebNavigationImpl.canGoForward = false;
-          ]]>
-        </body>
-      </method>
-
-      <method name="createAboutBlankContentViewer">
-        <parameter name="aPrincipal"/>
-        <body>
-          <![CDATA[
-            // Ensure that the content process has the permissions which are
-            // needed to create a document with the given principal.
-            let permissionPrincipal =
-              BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
-            this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
-
-            // Create the about blank content viewer in the content process
-            this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
-          ]]>
-        </body>
-      </method>
-    </implementation>
-    <handlers>
-      <handler event="dragstart">
-      <![CDATA[
-        // If we're a remote browser dealing with a dragstart, stop it
-        // from propagating up, since our content process should be dealing
-        // with the mouse movement.
-        event.stopPropagation();
-      ]]>
-      </handler>
-    </handlers>
-
-  </binding>
-
-</bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -180,20 +180,16 @@ iframe {
     display: block;
   }
 }
 
 browser {
   -moz-binding: url("chrome://global/content/bindings/browser.xml#browser");
 }
 
-browser[remote=true]:not(.lightweight) {
-  -moz-binding: url("chrome://global/content/bindings/remote-browser.xml#remote-browser");
-}
-
 /********** notifications **********/
 
 notificationbox {
   -moz-binding: url("chrome://global/content/bindings/notification.xml#notificationbox");
   -moz-box-orient: vertical;
 }
 
 .notificationbox-stack {
diff --git a/toolkit/modules/RemoteController.js b/toolkit/modules/RemoteController.js
--- a/toolkit/modules/RemoteController.js
+++ b/toolkit/modules/RemoteController.js
@@ -62,17 +62,17 @@ RemoteController.prototype = {
   },
 
   getSupportedCommands(aCount, aCommands) {
     throw Cr.NS_ERROR_NOT_IMPLEMENTED;
   },
 
   onEvent() {},
 
-  // This is intended to be called from the remote-browser binding to update
+  // This is intended to be called from the browser binding to update
   // the enabled and disabled commands.
   enableDisableCommands(aAction,
                                   aEnabledLength, aEnabledCommands,
                                   aDisabledLength, aDisabledCommands) {
     // Clear the list first
     this._supportedCommands = { };
 
     for (let c = 0; c < aEnabledLength; c++) {
