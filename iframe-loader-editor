# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  554c1870ebdce41d0ed1a095b5bb81c0faeef34e
Bug 1128747 - Odd white space at the top of scss file

diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -29,16 +29,17 @@ const MAX_VERTICAL_OFFSET = 3;
 const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
 const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const events  = require("devtools/toolkit/event-emitter");
 const { PrefObserver } = require("devtools/styleeditor/utils");
 
 Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
 const L10N = Services.strings.createBundle(L10N_BUNDLE);
 
 // CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
 // JavaScript and CSS that is injected into an iframe in
 // order to initialize a CodeMirror instance.
 
 const CM_STYLES   = [
   "chrome://browser/skin/devtools/common.css",
@@ -234,30 +235,31 @@ Editor.prototype = {
    * an optional second parameter. This method actually creates and
    * loads CodeMirror and all its dependencies.
    *
    * This method is asynchronous and returns a promise.
    */
   appendTo: function (el, env) {
     let def = promise.defer();
     let cm  = editors.get(this);
-
+console.log("Incoming env?", env, el.ownerDocument);
     if (!env)
       env = el.ownerDocument.createElementNS(XUL_NS, "iframe");
 
     env.flex = 1;
 
     if (cm)
       throw new Error("You can append an editor only once.");
 
+console.trace();
     let onLoad = () => {
       // Once the iframe is loaded, we can inject CodeMirror
       // and its dependencies into its DOM.
-
-      env.removeEventListener("load", onLoad, true);
+console.log(env, env.contentWindow);
+      // env.removeEventListener("load", onLoad, true);
       let win = env.contentWindow.wrappedJSObject;
 
       if (!this.config.themeSwitching)
         win.document.documentElement.setAttribute("force-theme", "light");
 
       CM_SCRIPTS.forEach((url) =>
         Services.scriptloader.loadSubScript(url, win, "utf8"));
 
@@ -332,19 +334,38 @@ Editor.prototype = {
       this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
       this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
       this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
       this._prefObserver.on(ENABLE_CODE_FOLDING, this.reloadPreferences);
 
       this.reloadPreferences();
       def.resolve();
     };
+    env.setAttribute("src", CM_IFRAME);
+console.log("env", env, env.contentWindow);
 
-    env.addEventListener("load", onLoad, true);
-    env.setAttribute("src", CM_IFRAME);
+    // Depending on the host, iframe.contentWindow is not always
+    // defined at this moment. If it is not defined, we use an
+    // event listener on the iframe DOM node. If it's defined,
+    // we use the chromeEventHandler. We can't use a listener
+    // on the DOM node every time because this won't work
+    // if the (xul chrome) iframe is loaded in a content docshell.
+    if (env.contentWindow) {
+      let domHelper = new DOMHelpers(iframe.contentWindow);
+      domHelper.onceDOMReady(onLoad);
+    } else {
+      let callback = () => {
+        env.removeEventListener("DOMContentLoaded", callback);
+        onLoad();
+      }
+      env.addEventListener("DOMContentLoaded", callback);
+    }
+
+
+    // env.addEventListener("load", onLoad, true);
     el.appendChild(env);
 
     this.once("destroy", () => el.removeChild(env));
     return def.promise;
   },
 
   /**
    * Returns a boolean indicating whether the editor is ready to
diff --git a/browser/themes/shared/devedition.inc.css b/browser/themes/shared/devedition.inc.css
--- a/browser/themes/shared/devedition.inc.css
+++ b/browser/themes/shared/devedition.inc.css
@@ -278,17 +278,17 @@ searchbar:not([oneoffui]) .search-go-but
    causes an overflow and makes it disappear, which removes the overflow and
    causes it to reappear, etc, etc. */
 #tabbrowser-tabs[movingtab] > .tabbrowser-tab[beforeselected]:not([last-visible-tab])::after,
 .tabbrowser-tab:not([selected]):not([afterselected-visible]):not([afterhovered]):not([first-visible-tab]):not(:hover)::before,
 #tabbrowser-tabs:not([overflow]) > .tabbrowser-tab[last-visible-tab]:not([selected]):not([beforehovered]):not(:hover)::after {
   background: var(--tab-separator-color);
   width: 1px;
   -moz-margin-start: 0;
-  -moz-margin-end: -1px;
+  -moz-margin-end: 0;
 }
 
 .tabbrowser-arrowscrollbox > .scrollbutton-down,
 .tabbrowser-arrowscrollbox > .scrollbutton-up {
   background-color: var(--tab-background-color);
   border-color: transparent;
 }
 
