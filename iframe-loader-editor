# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  788a0bb0ce1611704a10e1360d08bd2a8011c36e
Bug 1128747 - Odd white space at the top of scss file

diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -29,16 +29,17 @@ const MAX_VERTICAL_OFFSET = 3;
 const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
 const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const events  = require("devtools/toolkit/event-emitter");
 const { PrefObserver } = require("devtools/styleeditor/utils");
 
 Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource:///modules/devtools/DOMHelpers.jsm");
 const L10N = Services.strings.createBundle(L10N_BUNDLE);
 
 // CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
 // JavaScript and CSS that is injected into an iframe in
 // order to initialize a CodeMirror instance.
 
 const CM_STYLES   = [
   "chrome://browser/skin/devtools/common.css",
@@ -234,30 +235,31 @@ Editor.prototype = {
    * an optional second parameter. This method actually creates and
    * loads CodeMirror and all its dependencies.
    *
    * This method is asynchronous and returns a promise.
    */
   appendTo: function (el, env) {
     let def = promise.defer();
     let cm  = editors.get(this);
-
     if (!env)
       env = el.ownerDocument.createElementNS(XUL_NS, "iframe");
 
     env.flex = 1;
-
     if (cm)
       throw new Error("You can append an editor only once.");
 
+console.log("Initial env", this, env.contentWindow, env.contentDocument);
+console.trace();
+
     let onLoad = () => {
       // Once the iframe is loaded, we can inject CodeMirror
       // and its dependencies into its DOM.
-
-      env.removeEventListener("load", onLoad, true);
+console.log("Loaded env", env.contentWindow, env.contentDocument);
+      // env.removeEventListener("load", onLoad, true);
       let win = env.contentWindow.wrappedJSObject;
 
       if (!this.config.themeSwitching)
         win.document.documentElement.setAttribute("force-theme", "light");
 
       CM_SCRIPTS.forEach((url) =>
         Services.scriptloader.loadSubScript(url, win, "utf8"));
 
@@ -332,20 +334,47 @@ Editor.prototype = {
       this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
       this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
       this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
       this._prefObserver.on(ENABLE_CODE_FOLDING, this.reloadPreferences);
 
       this.reloadPreferences();
       def.resolve();
     };
+    env.setAttribute("src", CM_IFRAME);
 
-    env.addEventListener("load", onLoad, true);
-    env.setAttribute("src", CM_IFRAME);
+    // Depending on the host, iframe.contentWindow is not always
+    // defined at this moment. If it is not defined, we use an
+    // event listener on the iframe DOM node. If it's defined,
+    // we use the chromeEventHandler. We can't use a listener
+    // on the DOM node every time because this won't work
+    // if the (xul chrome) iframe is loaded in a content docshell.
+    if (env.contentWindow) {
+      let domHelper = new DOMHelpers(iframe.contentWindow);
+      domHelper.onceDOMReady(onLoad);
+    } else {
+      let callback = () => {
+        env.removeEventListener("DOMContentLoaded", callback);
+        onLoad();
+      }
+      env.addEventListener("DOMContentLoaded", callback);
+    }
+
+
+
+    let hiddenDOMWindow = Cc["@mozilla.org/appshell/appShellService;1"]
+                     .getService(Ci.nsIAppShellService)
+                     .hiddenDOMWindow;
+    hiddenDOMWindow.setTimeout(() => {
+    console.log("About to aaappend child")
+    // env.addEventListener("load", onLoad, true);
     el.appendChild(env);
+console.dir(env);
+console.log(env.contentWindow);
+    }, 5000);
 
     this.once("destroy", () => el.removeChild(env));
     return def.promise;
   },
 
   /**
    * Returns a boolean indicating whether the editor is ready to
    * use.  Use appendTo(el).then(() => {}) for most cases
diff --git a/browser/devtools/styleeditor/StyleEditorUI.jsm b/browser/devtools/styleeditor/StyleEditorUI.jsm
--- a/browser/devtools/styleeditor/StyleEditorUI.jsm
+++ b/browser/devtools/styleeditor/StyleEditorUI.jsm
@@ -519,19 +519,19 @@ StyleEditorUI.prototype = {
           this._selectEditor(editor);
         }
         this.emit("editor-added", editor);
       }.bind(this),
 
       onShow: function(summary, details, data) {
         let editor = data.editor;
         this.selectedEditor = editor;
-
+console.log("FOO", data, editor, editor.sourceEditor);
         Task.spawn(function* () {
-          if (!editor.sourceEditor) {
+          if (!editor._sourceEditor) {
             // only initialize source editor when we switch to this view
             let inputElement = details.querySelector(".stylesheet-editor-input");
             yield editor.load(inputElement);
           }
 
           editor.onShow();
 
           this.emit("editor-selected", editor);
diff --git a/browser/devtools/styleeditor/StyleSheetEditor.jsm b/browser/devtools/styleeditor/StyleSheetEditor.jsm
--- a/browser/devtools/styleeditor/StyleSheetEditor.jsm
+++ b/browser/devtools/styleeditor/StyleSheetEditor.jsm
@@ -10,16 +10,17 @@ this.EXPORTED_SYMBOLS = ["StyleSheetEdit
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 const require = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools.require;
 const Editor  = require("devtools/sourceeditor/editor");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const {CssLogic} = require("devtools/styleinspector/css-logic");
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/FileUtils.jsm");
 Cu.import("resource://gre/modules/NetUtil.jsm");
 Cu.import("resource://gre/modules/osfile.jsm");
 Cu.import("resource://gre/modules/Task.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
 Cu.import("resource:///modules/devtools/StyleEditorUtil.jsm");
@@ -363,16 +364,17 @@ StyleSheetEditor.prototype = {
       mode: Editor.modes.css,
       readOnly: false,
       autoCloseBrackets: "{}()[]",
       extraKeys: this._getKeyBindings(),
       contextMenu: "sourceEditorContextMenu",
       autocomplete: Services.prefs.getBoolPref(AUTOCOMPLETION_PREF),
       autocompleteOpts: { walker: this.walker }
     };
+    console.log("Load has happened", this._state, this._state.text);
     let sourceEditor = this._sourceEditor = new Editor(config);
 
     sourceEditor.on("dirty-change", this._onPropertyChange);
 
     return sourceEditor.appendTo(inputElement).then(() => {
       sourceEditor.on("save", this.saveToFile);
 
       if (this.styleSheet.update) {
