# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b3ceae83e290925f754544cff4d30ef4de9ab399

diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -750,23 +750,39 @@ xmlns="http://www.w3.org/1999/xhtml"
                flex="1">
         <vbox flex="1" class="toolbar-items">
           <spacer flex="1000"/>
 
           <hbox id="TabsToolbar-customization-target" flex="1">
             <hbox class="titlebar-spacer" type="pre-tabs"
                   skipintoolbarset="true"/>
 
-            <tabs id="tabbrowser-tabs"
+            <hbox id="tabbrowser-tabs"
                   flex="1"
-                  setfocus="false"
                   tooltip="tabbrowser-tab-tooltip"
                   stopwatchid="FX_TAB_CLICK_MS">
-              <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
-            </tabs>
+              <hbox class="tab-drop-indicator-box">
+                <image class="tab-drop-indicator" collapsed="true"/>
+              </hbox>
+              <arrowscrollbox orient="horizontal" flex="1"
+                              style="min-width: 1px;"
+                              clicktoscroll="true"
+                              class="tabbrowser-arrowscrollbox">
+                <tabs flex="1"
+                      setfocus="false"
+                      id="tabbrowser-tabs-inner">
+                  <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
+                </tabs>
+                <toolbarbutton class="tabs-newtab-button toolbarbutton-1"
+                               command="cmd_newNavigatorTab"
+                               onclick="checkForMiddleClick(this, event);"
+                               tooltip="dynamic-shortcut-tooltip"/>
+                <spacer class="closing-tabs-spacer" style="width: 0;"/>
+              </arrowscrollbox>
+            </hbox>
 
             <toolbarbutton id="new-tab-button"
                            class="toolbarbutton-1 chromeclass-toolbar-additional"
                            label="&tabCmd.label;"
                            command="cmd_newNavigatorTab"
                            onclick="checkForMiddleClick(this, event);"
                            tooltip="dynamic-shortcut-tooltip"
                            ondrop="newTabButtonObserver.onDrop(event)"
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -200,17 +200,17 @@ window._gBrowser = {
 
   get tabContainer() {
     delete this.tabContainer;
     return this.tabContainer = document.getElementById("tabbrowser-tabs");
   },
 
   get tabs() {
     delete this.tabs;
-    return this.tabs = this.tabContainer.children;
+    return this.tabs = this.tabContainer.tabsInner.children;
   },
 
   get tabbox() {
     delete this.tabbox;
     return this.tabbox = document.getElementById("tabbrowser-tabbox");
   },
 
   get tabpanels() {
@@ -845,17 +845,17 @@ window._gBrowser = {
     return newTitle;
   },
 
   updateTitlebar() {
     document.title = this.getWindowTitleForBrowser(this.selectedBrowser);
   },
 
   updateCurrentBrowser(aForceUpdate) {
-    let newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);
+    let newBrowser = this.getBrowserAtIndex(this.tabContainer.tabsInner.selectedIndex);
     if (this.selectedBrowser == newBrowser && !aForceUpdate) {
       return;
     }
 
     let newTab = this.getTabForBrowser(newBrowser);
 
     if (!aForceUpdate) {
       TelemetryStopwatch.start("FX_TAB_SWITCH_UPDATE_MS");
@@ -1468,17 +1468,17 @@ window._gBrowser = {
 
     if (replace) {
       let browser;
       if (targetTab) {
         browser = this.getBrowserForTab(targetTab);
         targetTabIndex = targetTab._tPos;
       } else {
         browser = this.selectedBrowser;
-        targetTabIndex = this.tabContainer.selectedIndex;
+        targetTabIndex = this.tabContainer.tabsInner.selectedIndex;
       }
       let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
       if (allowThirdPartyFixup) {
         flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP |
           Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
       }
       if (!allowInheritPrincipal) {
         flags |= Ci.nsIWebNavigation.LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL;
@@ -2403,17 +2403,17 @@ window._gBrowser = {
         index = Math.min(index, this._numPinnedTabs);
       } else {
         index = Math.max(index, this._numPinnedTabs);
       }
 
       // use .item() instead of [] because dragging to the end of the strip goes out of
       // bounds: .item() returns null (so it acts like appendChild), but [] throws
       let tabAfter = this.tabs.item(index);
-      this.tabContainer.insertBefore(t, tabAfter);
+      this.tabContainer.tabsInner.insertBefore(t, tabAfter);
       if (tabAfter) {
         this._updateTabsAfterInsert();
       } else {
         t._tPos = index;
       }
 
       if (pinned) {
         this._updateTabBarForPinnedTabs();
@@ -3707,17 +3707,17 @@ window._gBrowser = {
 
     aIndex = aIndex < aTab._tPos ? aIndex : aIndex + 1;
 
     // invalidate cache
     this._visibleTabs = null;
 
     // use .item() instead of [] because dragging to the end of the strip goes out of
     // bounds: .item() returns null (so it acts like appendChild), but [] throws
-    this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));
+    this.tabContainer.tabsInner.insertBefore(aTab, this.tabs.item(aIndex));
     this._updateTabsAfterInsert();
 
     if (wasFocused)
       this.selectedTab.focus();
 
     this.tabContainer._handleTabSelect(true);
 
     if (aTab.pinned)
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -10,17 +10,17 @@
           xmlns:xbl="http://www.mozilla.org/xbl">
 
   <binding id="tabbrowser-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
     <implementation>
       <!-- Override scrollbox.xml method, since our scrollbox's children are
            inherited from the binding parent -->
       <method name="_getScrollableElements">
         <body><![CDATA[
-          return Array.filter(document.getBindingParent(this).children,
+          return Array.filter(document.getElementById("tabbrowser-tabs-inner").children,
                               this._canScrollToElement, this);
         ]]></body>
       </method>
       <method name="_canScrollToElement">
         <parameter name="tab"/>
         <body><![CDATA[
           return !tab._pinnedUnscrollable && !tab.hidden;
         ]]></body>
@@ -28,17 +28,17 @@
     </implementation>
 
     <handlers>
       <handler event="underflow" phase="capturing"><![CDATA[
         // Ignore underflow events:
         // - from nested scrollable elements
         // - for vertical orientation
         // - corresponding to an overflow event that we ignored
-        let tabs = document.getBindingParent(this);
+        let tabs = document.getElementById("tabbrowser-tabs-inner")
         if (event.originalTarget != this._scrollbox ||
             event.detail == 0 ||
             !tabs.hasAttribute("overflow")) {
           return;
         }
 
         tabs.removeAttribute("overflow");
 
@@ -56,54 +56,25 @@
         // Ignore overflow events:
         // - from nested scrollable elements
         // - for vertical orientation
         if (event.originalTarget != this._scrollbox ||
             event.detail == 0) {
           return;
         }
 
-        var tabs = document.getBindingParent(this);
+        var tabs = document.getElementById("tabbrowser-tabs-inner");
         tabs.setAttribute("overflow", "true");
         tabs._positionPinnedTabs();
         tabs._handleTabSelect(true);
       ]]></handler>
     </handlers>
   </binding>
 
-  <binding id="tabbrowser-tabs"
-           extends="chrome://global/content/bindings/tabbox.xml#tabs">
-    <content>
-      <xul:hbox class="tab-drop-indicator-box">
-        <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
-      </xul:hbox>
-      <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
-                          style="min-width: 1px;"
-                          clicktoscroll="true"
-                          class="tabbrowser-arrowscrollbox">
-<!--
- This is a hack to circumvent bug 472020, otherwise the tabs show up on the
- right of the newtab button.
--->
-        <children includes="tab"/>
-<!--
-  This is to ensure anything extensions put here will go before the newtab
-  button, necessary due to the previous hack.
--->
-        <children/>
-        <xul:toolbarbutton class="tabs-newtab-button toolbarbutton-1"
-                           anonid="tabs-newtab-button"
-                           command="cmd_newNavigatorTab"
-                           onclick="checkForMiddleClick(this, event);"
-                           tooltip="dynamic-shortcut-tooltip"/>
-        <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
-                    style="width: 0;"/>
-      </xul:arrowscrollbox>
-    </content>
-
+  <binding id="tabbrowser-tabs">
     <implementation implements="nsIObserver">
       <constructor>
         <![CDATA[
           this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
           this._hiddenSoundPlayingTabs = new Set();
 
           let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
               "emptyPrivateTabTitle" : "emptyTabTitle";
@@ -150,16 +121,20 @@
       <destructor>
         <![CDATA[
           Services.prefs.removeObserver("privacy.userContext", this);
 
           CustomizableUI.removeListener(this);
         ]]>
       </destructor>
 
+      <field name="tabsInner" readonly="true">
+        document.getElementById("tabbrowser-tabs-inner");
+      </field>
+
       <field name="tabbox" readonly="true">
         document.getElementById("tabbrowser-tabbox");
       </field>
 
       <field name="contextMenu" readonly="true">
         document.getElementById("tabContextMenu");
       </field>
 
@@ -266,30 +241,30 @@
           return document.documentElement.getAttribute("customizing") == "true";
         ]]></getter>
       </property>
 
       <method name="_getVisibleTabs">
         <body><![CDATA[
           // Cannot access gBrowser before it's initialized.
           if (!gBrowser) {
-            return [ this.firstElementChild ];
+            return [ this.tabsInner.firstElementChild ];
           }
 
           return gBrowser.visibleTabs;
         ]]></body>
       </method>
 
       <method name="_setPositionalAttributes">
         <body><![CDATA[
           let visibleTabs = this._getVisibleTabs();
           if (!visibleTabs.length) {
             return;
           }
-          let selectedTab = this.selectedItem;
+          let selectedTab = this.tabsInner.selectedItem;
           let selectedIndex = visibleTabs.indexOf(selectedTab);
           if (this._beforeSelectedTab) {
             this._beforeSelectedTab.removeAttribute("beforeselected-visible");
           }
 
           if (selectedTab.closing || selectedIndex <= 0) {
             this._beforeSelectedTab = null;
           } else {
@@ -395,17 +370,17 @@
             this.removeAttribute("hashiddentabs");
           }
         ]]></body>
       </method>
 
       <method name="_handleTabSelect">
         <parameter name="aInstant"/>
         <body><![CDATA[
-          let selectedTab = this.selectedItem;
+          let selectedTab = this.tabsInner.selectedItem;
           if (this.getAttribute("overflow") == "true")
             this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);
 
           selectedTab._notselectedsinceload = false;
         ]]></body>
       </method>
 
       <field name="_closingTabsSpacer">
@@ -544,35 +519,35 @@
 
             let layoutData = this._pinnedTabsLayoutCache;
             let uiDensity = document.documentElement.getAttribute("uidensity");
             if (!layoutData ||
                 layoutData.uiDensity != uiDensity) {
               let arrowScrollbox = this.arrowScrollbox;
               layoutData = this._pinnedTabsLayoutCache = {
                 uiDensity,
-                pinnedTabWidth: this.children[0].getBoundingClientRect().width,
+                pinnedTabWidth: this.tabsInner.children[0].getBoundingClientRect().width,
                 scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width,
               };
             }
 
             let width = 0;
             for (let i = numPinned - 1; i >= 0; i--) {
-              let tab = this.children[i];
+              let tab = this.tabsInner.children[i];
               width += layoutData.pinnedTabWidth;
               tab.style.setProperty("margin-inline-start",
                 -(width + layoutData.scrollButtonWidth) + "px", "important");
               tab._pinnedUnscrollable = true;
             }
             this.style.paddingInlineStart = width + "px";
           } else {
             this.removeAttribute("positionpinnedtabs");
 
             for (let i = 0; i < numPinned; i++) {
-              let tab = this.children[i];
+              let tab = this.tabsInner.children[i];
               tab.style.marginInlineStart = "";
               tab._pinnedUnscrollable = false;
             }
 
             this.style.paddingInlineStart = "";
           }
 
           if (this._lastNumPinned != numPinned) {
@@ -587,17 +562,17 @@
         <body><![CDATA[
           let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
           let movingTabs = draggedTab._dragData.movingTabs;
 
           if (this.getAttribute("movingtab") != "true") {
             this.setAttribute("movingtab", "true");
             gNavToolbox.setAttribute("movingtab", "true");
             if (!draggedTab.multiselected)
-              this.selectedItem = draggedTab;
+              this.tabsInner.selectedItem = draggedTab;
           }
 
           if (!("animLastScreenX" in draggedTab._dragData))
             draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;
 
           let screenX = event.screenX;
           if (screenX == draggedTab._dragData.animLastScreenX)
             return;
@@ -938,17 +913,17 @@
           // DOMRect left/right properties are immutable.
           tab = {left: tab.left, right: tab.right};
 
           // Is the new tab already completely visible?
           if (scrollRect.left <= tab.left && tab.right <= scrollRect.right)
             return;
 
           if (this.arrowScrollbox.smoothScroll) {
-            let selectedTab = this.selectedItem;
+            let selectedTab = this.tabsInner.selectedItem;
             let selected = !selectedTab.pinned &&
                            selectedTab.getBoundingClientRect();
 
             // Can we make both the new tab and the selected tab completely visible?
             if (!selected ||
                 Math.max(tab.right - selected.left, selected.right - tab.left) <=
                   scrollRect.width) {
               this.arrowScrollbox.ensureElementIsVisible(aTab);
@@ -983,17 +958,17 @@
           return tab;
         ]]></body>
       </method>
 
       <method name="_getDropIndex">
         <parameter name="event"/>
         <parameter name="isLink"/>
         <body><![CDATA[
-          var tabs = this.children;
+          var tabs = this.tabsInner.children;
           var tab = this._getDragTargetTab(event, isLink);
           if (window.getComputedStyle(this).direction == "ltr") {
             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
               if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
                 return i;
           } else {
             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
               if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
@@ -1600,17 +1575,17 @@
         this._finishAnimateTabMove();
 
         if (effects == "link") {
           let tab = this._getDragTargetTab(event, true);
           if (tab) {
             if (!this._dragTime)
               this._dragTime = Date.now();
             if (Date.now() >= this._dragTime + this._dragOverDelay)
-              this.selectedItem = tab;
+              this.tabsInner.selectedItem = tab;
             ind.collapsed = true;
             return;
           }
         }
 
         var rect = arrowScrollbox.getBoundingClientRect();
         var newMargin;
         if (pixelsToScroll) {
@@ -1621,24 +1596,24 @@
           let maxMargin = Math.min(minMargin + scrollRect.width,
                                    scrollRect.right);
           if (!ltr)
             [minMargin, maxMargin] = [this.clientWidth - maxMargin,
                                       this.clientWidth - minMargin];
           newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
         } else {
           let newIndex = this._getDropIndex(event, effects == "link");
-          if (newIndex == this.children.length) {
-            let tabRect = this.children[newIndex - 1].getBoundingClientRect();
+          if (newIndex == this.tabsInner.children.length) {
+            let tabRect = this.tabsInner.children[newIndex - 1].getBoundingClientRect();
             if (ltr)
               newMargin = tabRect.right - rect.left;
             else
               newMargin = rect.right - tabRect.left;
           } else {
-            let tabRect = this.children[newIndex].getBoundingClientRect();
+            let tabRect = this.tabsInner.children[newIndex].getBoundingClientRect();
             if (ltr)
               newMargin = tabRect.left - rect.left;
             else
               newMargin = rect.right - tabRect.right;
           }
         }
 
         ind.collapsed = false;
@@ -1673,17 +1648,17 @@
           let draggedTabCopy;
           for (let tab of movingTabs) {
             let newTab = gBrowser.duplicateTab(tab);
             gBrowser.moveTabTo(newTab, newIndex++);
             if (tab == draggedTab)
               draggedTabCopy = newTab;
           }
           if (draggedTab.parentNode != this || event.shiftKey) {
-            this.selectedItem = draggedTabCopy;
+            this.tabsInner.selectedItem = draggedTabCopy;
           }
         } else if (draggedTab && draggedTab.parentNode == this) {
           let oldTranslateX = Math.round(draggedTab._dragData.translateX);
           let tabWidth = Math.round(draggedTab._dragData.tabWidth);
           let translateOffset = oldTranslateX % tabWidth;
           let newTranslateX = oldTranslateX - translateOffset;
           if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {
             newTranslateX += tabWidth;
@@ -1754,17 +1729,17 @@
           if (!links || links.length === 0)
             return;
 
           let inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
           if (event.shiftKey)
             inBackground = !inBackground;
 
           let targetTab = this._getDragTargetTab(event, true);
-          let userContextId = this.selectedItem.getAttribute("usercontextid");
+          let userContextId = this.tabsInner.selectedItem.getAttribute("usercontextid");
           let replace = !!targetTab;
           let newIndex = this._getDropIndex(event, true);
           let urls = links.map(link => link.url);
 
           let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);
 
           (async () => {
             if (urls.length >= Services.prefs.getIntPref("browser.tabs.maxOpenBeforeWarn")) {
@@ -2120,18 +2095,18 @@
       -->
 
       <method name="_mouseenter">
         <body><![CDATA[
           if (this.hidden || this.closing) {
             return;
           }
 
-          let tabContainer = this.parentNode;
-          let visibleTabs = tabContainer._getVisibleTabs();
+          let tabContainer = gBrowser.tabContainer;
+          let visibleTabs = gBrowser.tabContainer._getVisibleTabs();
           let tabIndex = visibleTabs.indexOf(this);
 
           if (this.selected)
             tabContainer._handleTabSelect();
 
           if (tabIndex == 0) {
             tabContainer._beforeHoveredTab = null;
           } else {
@@ -2169,17 +2144,17 @@
             tabToWarm = gBrowser._findTabToBlurTo(this);
           }
           gBrowser.warmupTab(tabToWarm);
         ]]></body>
       </method>
 
       <method name="_mouseleave">
         <body><![CDATA[
-          let tabContainer = this.parentNode;
+          let tabContainer = gBrowser.tabContainer;
           if (tabContainer._beforeHoveredTab) {
             tabContainer._beforeHoveredTab.removeAttribute("beforehovered");
             tabContainer._beforeHoveredTab = null;
           }
           if (tabContainer._afterHoveredTab) {
             tabContainer._afterHoveredTab.removeAttribute("afterhovered");
             tabContainer._afterHoveredTab = null;
           }
@@ -2333,17 +2308,17 @@
       <handler event="dragstart"><![CDATA[
         if (this.mOverCloseButton) {
           event.stopPropagation();
         }
       ]]></handler>
 
       <handler event="mousedown" phase="capturing">
       <![CDATA[
-        let tabContainer = this.parentNode;
+        let tabContainer = gBrowser.tabContainer;
 
         if (tabContainer._closeTabByDblclick &&
             event.button == 0 &&
             event.detail == 1) {
           this._selectedOnFirstMouseDown = this.selected;
         }
 
         if (this.selected) {
@@ -2440,17 +2415,17 @@
       ]]></handler>
 
       <handler event="dblclick" button="0" phase="capturing"><![CDATA[
         // for the one-close-button case
         if (event.originalTarget.getAttribute("anonid") == "close-button") {
           event.stopPropagation();
         }
 
-        let tabContainer = this.parentNode;
+        let tabContainer = gBrowser.tabContainer;
         if (tabContainer._closeTabByDblclick &&
             this._selectedOnFirstMouseDown &&
             this.selected &&
             !this._overPlayingIcon) {
           gBrowser.removeTab(this, {
             animate: true,
             byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,
           });
diff --git a/browser/themes/osx/browser.css b/browser/themes/osx/browser.css
--- a/browser/themes/osx/browser.css
+++ b/browser/themes/osx/browser.css
@@ -640,17 +640,17 @@ html|input.urlbar-input {
   color: hsl(240, 9%, 98%);
   text-shadow: none;
 }
 
 .tabbrowser-tab[visuallyselected=true]:not(:-moz-lwtheme) {
   -moz-font-smoothing-background-color: var(--toolbar-bgcolor);
 }
 
-#tabbrowser-tabs {
+#tabbrowser-tabs-inner {
   -moz-box-align: stretch;
   padding-left: 0;
   padding-right: 0;
   margin-bottom: 0;
   position: static;
 }
 
 /**
