# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  48314f305f726c8e6253442167ca44f09a4c667d
Add an inline tooltip for color swatches

diff --git a/devtools/client/shared/widgets/Tooltip.js b/devtools/client/shared/widgets/Tooltip.js
--- a/devtools/client/shared/widgets/Tooltip.js
+++ b/devtools/client/shared/widgets/Tooltip.js
@@ -117,16 +117,184 @@ var PanelFactory = {
 
     panel.setAttribute("class", "devtools-tooltip theme-tooltip-panel");
     doc.querySelector("window").appendChild(panel);
 
     return panel;
   }
 };
 
+function InlineTooltip(doc, options) {
+  EventEmitter.decorate(this);
+
+  this.doc = doc;
+  this.panel = this.doc.createElement("box");
+  this.panel.style.display = "none";
+  this.options = new OptionsStore({
+    consumeOutsideClick: false,
+    closeOnKeys: [ESCAPE_KEYCODE],
+    noAutoFocus: true,
+    closeOnEvents: []
+  }, options);
+
+  // Listen to keypress events to close the tooltip if configured to do so
+  let win = this.doc.querySelector("window");
+  this._onKeyPress = event => {
+    if (!this.isShown) {
+      return;
+    }
+
+    this.emit("keypress", event.keyCode);
+    if (this.options.get("closeOnKeys").indexOf(event.keyCode) !== -1 &&
+        this.isShown()) {
+      event.stopPropagation();
+      this.hide();
+    }
+  };
+  win.addEventListener("keypress", this._onKeyPress, false);
+}
+
+InlineTooltip.prototype = {
+  /**
+   * Show the tooltip. It might be wise to append some content first if you
+   * don't want the tooltip to be empty. You may access the content of the
+   * tooltip by setting a XUL node to t.content.
+   * @param {node} anchor
+   *        Which node should the tooltip be shown on
+   * @param {string} position [optional]
+   *        Optional tooltip position. Defaults to before_start
+   *        https://developer.mozilla.org/en-US/docs/XUL/PopupGuide/Positioning
+   * @param {number} x, y [optional]
+   *        The left and top offset coordinates, in pixels.
+   */
+  show: function(anchor) {
+    this.panel.style.display = "block";
+    let propertyContainer = anchor.closest(".ruleview-propertycontainer");
+
+    // Insert the inline editor next to the property
+    if (!this.panel.parentNode) {
+      propertyContainer.parentNode.insertBefore(this.panel, propertyContainer.nextSibling);
+    }
+  },
+
+  /**
+   * Hide the tooltip
+   */
+  hide: function() {
+    this.panel.style.display = "none";
+  },
+
+  isShown: function() {
+    return this.panel.style.display !== "none";
+  },
+
+  empty: function() {
+    this.panel.innerHTML = "";
+  },
+
+  /**
+   * Set the content of this tooltip. Will first empty the tooltip and then
+   * append the new content element.
+   * Consider using one of the set<type>Content() functions instead.
+   * @param {node} content
+   *        A node that can be appended in the tooltip XUL element
+   */
+  set content(content) {
+    if (this.content == content) {
+      return;
+    }
+
+    this.empty();
+
+    if (content) {
+      this.panel.appendChild(content);
+    }
+  },
+
+  get content() {
+    return this.panel.firstChild;
+  },
+
+  /**
+   * Load a document into an iframe, and set the iframe
+   * to be the tooltip's content.
+   *
+   * Used by tooltips that want to load their interface
+   * into an iframe from a URL.
+   *
+   * @param {string} width
+   *        Width of the iframe.
+   * @param {string} height
+   *        Height of the iframe.
+   * @param {string} url
+   *        URL of the document to load into the iframe.
+   *
+   * @return {promise} A promise which is resolved with
+   * the iframe.
+   *
+   * This function creates an iframe, loads the specified document
+   * into it, sets the tooltip's content to the iframe, and returns
+   * a promise.
+   *
+   * When the document is loaded, the function gets the content window
+   * and resolves the promise with the content window.
+   */
+  setIFrameContent: function({width, height}, url) {
+    let def = promise.defer();
+
+    // Create an iframe
+    let iframe = this.doc.createElementNS(XHTML_NS, "iframe");
+    iframe.setAttribute("transparent", true);
+    iframe.setAttribute("width", width);
+    iframe.setAttribute("height", height);
+    iframe.setAttribute("flex", "1");
+    iframe.setAttribute("class", "devtools-tooltip-iframe");
+
+    // Wait for the load to initialize the widget
+    function onLoad() {
+      iframe.removeEventListener("load", onLoad, true);
+      def.resolve(iframe);
+    }
+    iframe.addEventListener("load", onLoad, true);
+
+    // load the document from url into the iframe
+    iframe.setAttribute("src", url);
+
+    // Put the iframe in the tooltip
+    this.content = iframe;
+
+    return def.promise;
+  },
+
+  /**
+   * Fill the tooltip with a new instance of the spectrum color picker widget
+   * initialized with the given color, and return a promise that resolves to
+   * the instance of spectrum
+   */
+  setColorPickerContent: function(color) {
+    let dimensions = {width: "100%", height: "216"};
+    let panel = this.panel;
+    return this.setIFrameContent(dimensions, SPECTRUM_FRAME).then(onLoaded);
+
+    function onLoaded(iframe) {
+      let win = iframe.contentWindow.wrappedJSObject;
+      let def = promise.defer();
+      let container = win.document.getElementById("spectrum");
+      let spectrum = new Spectrum(container, color);
+      spectrum.show();
+      def.resolve(spectrum);
+      return def.promise;
+    }
+  },
+
+  destroy: function() {
+    console.log("destroy");
+  },
+}
+
 /**
  * Tooltip class.
  *
  * Basic usage:
  *   let t = new Tooltip(xulDoc);
  *   t.content = someXulContent;
  *   t.show();
  *   t.hide();
@@ -944,26 +1112,34 @@ Tooltip.prototype = {
 };
 
 /**
  * Base class for all (color, gradient, ...)-swatch based value editors inside
  * tooltips
  *
  * @param {XULDocument} doc
  */
-function SwatchBasedEditorTooltip(doc) {
+function SwatchBasedEditorTooltip(doc, useInline) {
   // Creating a tooltip instance
   // This one will consume outside clicks as it makes more sense to let the user
   // close the tooltip by clicking out
   // It will also close on <escape> and <enter>
-  this.tooltip = new Tooltip(doc, {
-    consumeOutsideClick: true,
-    closeOnKeys: [ESCAPE_KEYCODE, RETURN_KEYCODE],
-    noAutoFocus: false
-  });
+  if (useInline) {
+    this.tooltip = new InlineTooltip(doc, {
+      consumeOutsideClick: true,
+      closeOnKeys: [ESCAPE_KEYCODE, RETURN_KEYCODE],
+      noAutoFocus: false
+    });
+  } else {
+    this.tooltip = new Tooltip(doc, {
+      consumeOutsideClick: true,
+      closeOnKeys: [ESCAPE_KEYCODE, RETURN_KEYCODE],
+      noAutoFocus: false
+    });
+  }
 
   // By default, swatch-based editor tooltips revert value change on <esc> and
   // commit value change on <enter>
   this._onTooltipKeypress = (event, code) => {
     if (code === ESCAPE_KEYCODE) {
       this.revert();
     } else if (code === RETURN_KEYCODE) {
       this.commit();
@@ -1120,17 +1296,17 @@ SwatchBasedEditorTooltip.prototype = {
  * along with output-parser's generated color swatches.
  * It extends the parent SwatchBasedEditorTooltip class.
  * It just wraps a standard Tooltip and sets its content with an instance of a
  * color picker.
  *
  * @param {XULDocument} doc
  */
 function SwatchColorPickerTooltip(doc) {
-  SwatchBasedEditorTooltip.call(this, doc);
+  SwatchBasedEditorTooltip.call(this, doc, true);
 
   // Creating a spectrum instance. this.spectrum will always be a promise that
   // resolves to the spectrum instance
   this.spectrum = this.tooltip.setColorPickerContent([0, 0, 0, 1]);
   this._onSpectrumColorChange = this._onSpectrumColorChange.bind(this);
   this._openEyeDropper = this._openEyeDropper.bind(this);
 }
 
@@ -1149,22 +1325,24 @@ SwatchColorPickerTooltip.prototype = Her
       this.currentSwatchColor = this.activeSwatch.nextSibling;
       this._originalColor = this.currentSwatchColor.textContent;
       let color = this.activeSwatch.style.backgroundColor;
       this.spectrum.then(spectrum => {
         spectrum.off("changed", this._onSpectrumColorChange);
         spectrum.rgb = this._colorToRgba(color);
         spectrum.on("changed", this._onSpectrumColorChange);
         spectrum.updateUI();
+
+
+        let tooltipDoc = this.tooltip.content.contentDocument;
+        let eyeButton = tooltipDoc.querySelector("#eyedropper-button");
+        eyeButton.addEventListener("click", this._openEyeDropper);
       });
     }
 
-    let tooltipDoc = this.tooltip.content.contentDocument;
-    let eyeButton = tooltipDoc.querySelector("#eyedropper-button");
-    eyeButton.addEventListener("click", this._openEyeDropper);
   },
 
   _onSpectrumColorChange: function(event, rgba, cssColor) {
     this._selectColor(cssColor);
   },
 
   _selectColor: function(color) {
     if (this.activeSwatch) {
diff --git a/devtools/client/shared/widgets/spectrum.css b/devtools/client/shared/widgets/spectrum.css
--- a/devtools/client/shared/widgets/spectrum.css
+++ b/devtools/client/shared/widgets/spectrum.css
@@ -43,18 +43,19 @@
 /* Elements */
 
 .spectrum-container {
   position: relative;
   display: none;
   top: 0;
   left: 0;
   border-radius: 0;
-  width: 200px;
+  width: 100%;
   padding: 5px;
+  box-sizing: border-box;
 }
 
 .spectrum-show {
   display: inline-block;
 }
 
 /* Keep aspect ratio:
 http://www.briangrinstead.com/blog/keep-aspect-ratio-with-html-and-css */
@@ -84,18 +85,17 @@ http://www.briangrinstead.com/blog/keep-
   position: absolute;
   top: 0;
   right: 0;
   bottom: 0;
   left: 83%;
 }
 
 .spectrum-fill {
-  /* Same as spectrum-color width */
-  margin-top: 85%;
+  margin-top: 200px;
 }
 
 .spectrum-sat, .spectrum-val {
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
