# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  ac9f1219d11bf1a56ec1ace8e3ba9ff113b5cacb
Bug 1492967 - Merge together remote-browser and browser bindings

diff --git a/toolkit/content/widgets/browser.xml b/toolkit/content/widgets/browser.xml
--- a/toolkit/content/widgets/browser.xml
+++ b/toolkit/content/widgets/browser.xml
@@ -202,60 +202,114 @@
 
       <property name="dateTimePicker"
                 onget="return document.getElementById(this.getAttribute('datetimepicker'))"
                 readonly="true"/>
 
       <property name="docShellIsActive">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              return this.frameLoader.tabParent.docShellIsActive;
+            }
             return this.docShell && this.docShell.isActive;
           ]]>
         </getter>
         <setter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              this.frameLoader.tabParent.docShellIsActive = val;
+              return val;
+            }
             if (this.docShell)
               return this.docShell.isActive = val;
             return false;
           ]]>
         </setter>
       </property>
 
       <method name="preserveLayers">
         <parameter name="preserve"/>
-        <body>
-          // Only useful for remote browsers.
-        </body>
+        <body><![CDATA[
+          if (!this.isRemoteBrowser) {
+            return;
+          }
+          let {frameLoader} = this;
+          if (frameLoader.tabParent) {
+            frameLoader.tabParent.preserveLayers(preserve);
+          }
+        ]]></body>
       </method>
 
+
       <property name="renderLayers">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              let {frameLoader} = this;
+              if (frameLoader && frameLoader.tabParent) {
+                return frameLoader.tabParent.renderLayers;
+              }
+              return false;
+            }
             return this.docShellIsActive;
           ]]>
         </getter>
         <setter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              let {frameLoader} = this;
+              if (frameLoader && frameLoader.tabParent) {
+                return frameLoader.tabParent.renderLayers = val;
+              }
+              return false;
+            }
             return this.docShellIsActive = val;
           ]]>
         </setter>
       </property>
 
       <property name="hasLayers" readonly="true">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              let {frameLoader} = this;
+              if (frameLoader.tabParent) {
+                return frameLoader.tabParent.hasLayers;
+              }
+              return false;
+            }
+
             return this.docShellIsActive;
           ]]>
         </getter>
       </property>
 
+      <method name="forceRepaint">
+        <body>
+          <![CDATA[
+            if (!this.isRemoteBrowser) {
+              return;
+            }
+            let {frameLoader} = this;
+            if (frameLoader && frameLoader.tabParent) {
+              frameLoader.tabParent.forceRepaint();
+            }
+          ]]>
+        </body>
+      </method>
+
+      <field name="_imageDocument">null</field>
       <property name="imageDocument"
                 readonly="true">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              return this._imageDocument
+            }
             var document = this.contentDocument;
             if (!document || !(document instanceof Ci.nsIImageDocument))
               return null;
 
             try {
                 return {width: document.imageRequest.image.width, height: document.imageRequest.image.height };
             } catch (e) {}
             return null;
@@ -357,24 +411,32 @@
             this._fastFind = Cc["@mozilla.org/typeaheadfind;1"]
                                .createInstance(Ci.nsITypeAheadFind);
             this._fastFind.init(this.docShell);
           }
           return this._fastFind;
         ]]></getter>
       </property>
 
+      <field name="_outerWindowID">null</field>
       <property name="outerWindowID" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._outerWindowID;
+          }
           return this.contentWindow.windowUtils.outerWindowID;
         ]]></getter>
       </property>
 
+      <field name="_innerWindowID">null</field>
       <property name="innerWindowID" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._innerWindowID;
+          }
           try {
             return this.contentWindow.windowUtils.currentInnerWindowID;
           } catch (e) {
             if (e.result != Cr.NS_ERROR_NOT_AVAILABLE) {
               throw e;
             }
             return null;
           }
@@ -394,18 +456,19 @@
       <property name="sessionHistory"
                 onget="return this.webNavigation.sessionHistory;"
                 readonly="true"/>
 
       <property name="markupDocumentViewer"
                 onget="return this.docShell.contentViewer;"
                 readonly="true"/>
 
+      <field name="_contentDocument">null</field>
       <property name="contentDocumentAsCPOW"
-                onget="return this.contentDocument;"
+                onget="return this.isRemoteBrowser ? this._contentDocument : this.contentDocument;"
                 readonly="true"/>
 
       <property name="contentTitle"
                 onget="return this.contentDocument.title;"
                 readonly="true"/>
 
       <property name="characterSet"
                 onget="return this.docShell.charset;">
@@ -418,59 +481,112 @@
       <property name="mayEnableCharacterEncodingMenu"
                 onget="return this.docShell.mayEnableCharacterEncodingMenu;"
                 readonly="true"/>
 
       <property name="contentPrincipal"
                 onget="return this.contentDocument.nodePrincipal;"
                 readonly="true"/>
 
+      <field name="_contentRequestContextID">null</field>
       <property name="contentRequestContextID" readonly="true">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._contentRequestContextID;
+          }
           try {
             return this.contentDocument.documentLoadGroup
                        .requestContextID;
           } catch (e) {
             return null;
           }
         ]]></getter>
       </property>
 
       <property name="showWindowResizer"
                 onset="if (val) this.setAttribute('showresizer', 'true');
                        else this.removeAttribute('showresizer');
                        return val;"
                 onget="return this.getAttribute('showresizer') == 'true';"/>
 
+      <field name="_fullZoom">1</field>
       <property name="fullZoom">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._fullZoom;
+          }
           return this.markupDocumentViewer.fullZoom;
         ]]></getter>
         <setter><![CDATA[
+          if (this.isRemoteBrowser) {
+            let changed = val.toFixed(2) != this._fullZoom.toFixed(2);
+
+            if (changed) {
+              this._fullZoom = val;
+              try {
+                this.messageManager.sendAsyncMessage("FullZoom", {value: val});
+              } catch (ex) {}
+
+              let event = new Event("FullZoomChange", {bubbles: true});
+              this.dispatchEvent(event);
+            }
+          } else {
+            this.markupDocumentViewer.fullZoom = val;
+          }
+        ]]></setter>
+        <setter><![CDATA[
           this.markupDocumentViewer.fullZoom = val;
         ]]></setter>
       </property>
 
+      <field name="_textZoom">1</field>
       <property name="textZoom">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._textZoom;
+          }
           return this.markupDocumentViewer.textZoom;
         ]]></getter>
         <setter><![CDATA[
-          this.markupDocumentViewer.textZoom = val;
+          if (this.isRemoteBrowser) {
+            let changed = val.toFixed(2) != this._textZoom.toFixed(2);
+
+            if (changed) {
+              this._textZoom = val;
+              try {
+                this.messageManager.sendAsyncMessage("TextZoom", {value: val});
+              } catch (ex) {}
+
+              let event = new Event("TextZoomChange", {bubbles: true});
+              this.dispatchEvent(event);
+            }
+          } else {
+            this.markupDocumentViewer.textZoom = val;
+          }
+
+        ]]></setter>
+        <setter><![CDATA[
         ]]></setter>
       </property>
 
+      <field name="_isSyntheticDocument">false</field>
       <property name="isSyntheticDocument">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this._isSyntheticDocument;
+          }
           return this.contentDocument.mozSyntheticDocument;
         ]]></getter>
       </property>
 
       <property name="hasContentOpener">
         <getter><![CDATA[
+          if (this.isRemoteBrowser) {
+            return this.frameLoader.tabParent.hasContentOpener;
+          }
           return !!this.contentWindow.opener;
         ]]></getter>
       </property>
 
       <field name="mPrefs" readonly="true">
         Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
       </field>
 
@@ -722,37 +838,53 @@
               return;
             }
             this.messageManager.sendAsyncMessage("Browser:UnselectedTabHover",
               { hovered });
           ]]>
         </body>
       </method>
 
-      <property name="securityUI">
+      <field name="_securityUI">null</field>
+      <property name="securityUI"
+                readonly="true">
         <getter>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              if (!this._securityUI) {
+                // Don't attempt to create the remote web progress if the
+                // messageManager has already gone away
+                if (!this.messageManager)
+                  return null;
+
+                let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
+                let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
+                this._securityUI = new RemoteSecurityUI();
+              }
+
+              // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
+              var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
+                          .createInstance(Ci.nsISupportsInterfacePointer);
+              ptr.data = this._securityUI;
+              return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
+            }
+
             if (!this.docShell.securityUI) {
               const SECUREBROWSERUI_CONTRACTID = "@mozilla.org/secure_browser_ui;1";
               if (!this.hasAttribute("disablesecurity") &&
                   SECUREBROWSERUI_CONTRACTID in Cc) {
                 var securityUI = Cc[SECUREBROWSERUI_CONTRACTID]
                                    .createInstance(Ci.nsISecureBrowserUI);
                 securityUI.init(this.contentWindow);
               }
             }
 
             return this.docShell.securityUI;
           ]]>
         </getter>
-        <setter>
-          <![CDATA[
-            this.docShell.securityUI = val;
-          ]]>
-        </setter>
       </property>
 
       <field name="urlbarChangeTracker">
         ({
           _startedLoadSinceLastUserTyping: false,
 
           startedLoad() {
             this._startedLoadSinceLastUserTyping = true;
@@ -794,16 +926,69 @@
 
       <!-- This is managed by the tabbrowser -->
       <field name="lastURI">null</field>
 
       <field name="mDestroyed">false</field>
 
       <constructor>
         <![CDATA[
+          if (this.isRemoteBrowser) {
+            /*
+            * Don't try to send messages from this function. The message manager for
+            * the <browser> element may not be initialized yet.
+            */
+
+            this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
+                                          .createInstance(Ci.nsIWebNavigation);
+            this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
+            this._remoteWebNavigationImpl.swapBrowser(this);
+
+            // Initialize contentPrincipal to the about:blank principal for this loadcontext
+            let {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
+            let aboutBlank = Services.io.newURI("about:blank");
+            let ssm = Services.scriptSecurityManager;
+            this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
+
+            this.messageManager.addMessageListener("Browser:Init", this);
+            this.messageManager.addMessageListener("DOMTitleChanged", this);
+            this.messageManager.addMessageListener("ImageDocumentLoaded", this);
+            this.messageManager.addMessageListener("FullZoomChange", this);
+            this.messageManager.addMessageListener("TextZoomChange", this);
+            this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
+
+            // browser-child messages, such as Content:LocationChange, are handled in
+            // RemoteWebProgress, ensure it is loaded and ready.
+            let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
+            let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
+            this._remoteWebProgressManager = new RemoteWebProgressManager(this);
+            this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
+
+            this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
+
+            if (this.hasAttribute("selectmenulist")) {
+              this.messageManager.addMessageListener("Forms:ShowDropDown", this);
+              this.messageManager.addMessageListener("Forms:HideDropDown", this);
+            }
+
+            if (!this.hasAttribute("disablehistory")) {
+              Services.obs.addObserver(this, "browser:purge-session-history", true);
+            }
+
+            let rc_js = "resource://gre/modules/RemoteController.js";
+            let scope = {};
+            Services.scriptloader.loadSubScript(rc_js, scope);
+            let RemoteController = scope.RemoteController;
+            this._controller = new RemoteController(this);
+            this.controllers.appendController(this._controller);
+            return;
+          }
+
+
+
           try {
             // |webNavigation.sessionHistory| will have been set by the frame
             // loader when creating the docShell as long as this xul:browser
             // doesn't have the 'disablehistory' attribute set.
             if (this.docShell && this.webNavigation.sessionHistory) {
               var os = Cc["@mozilla.org/observer-service;1"]
                          .getService(Ci.nsIObserverService);
               os.addObserver(this, "browser:purge-session-history", true);
@@ -862,33 +1047,52 @@
       </constructor>
 
       <destructor>
         <![CDATA[
           this.destroy();
         ]]>
       </destructor>
 
+
       <!-- This is necessary because the destructor doesn't always get called when
            we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
 
-           Note: this function is overriden in remote-browser.xml, so any clean-up that
-           also applies to browser.isRemoteBrowser = true must be duplicated there. -->
+           Note: This overrides the destroy() method from browser.xml. -->
       <method name="destroy">
-        <body>
-          <![CDATA[
+        <body><![CDATA[
           // Make sure that any open select is closed.
           if (this._selectParentHelper) {
             let menulist = document.getElementById(this.getAttribute("selectmenulist"));
             this._selectParentHelper.hide(menulist, this);
           }
           if (this.mDestroyed)
             return;
           this.mDestroyed = true;
 
+          if (this.isRemoteBrowser) {
+            try {
+              this.controllers.removeController(this._controller);
+            } catch (ex) {
+              // This can fail when this browser element is not attached to a
+              // BrowserDOMWindow.
+            }
+
+            if (!this.hasAttribute("disablehistory")) {
+              let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
+              try {
+                Services.obs.removeObserver(this, "browser:purge-session-history");
+              } catch (ex) {
+                // It's not clear why this sometimes throws an exception.
+              }
+            }
+
+            return;
+          }
+
           if (this.docShell && this.webNavigation.sessionHistory) {
             var os = Cc["@mozilla.org/observer-service;1"]
                        .getService(Ci.nsIObserverService);
             try {
               os.removeObserver(this, "browser:purge-session-history");
             } catch (ex) {
               // It's not clear why this sometimes throws an exception.
             }
@@ -902,20 +1106,20 @@
           if (!this.isRemoteBrowser) {
             this.removeEventListener("pagehide", this.onPageHide, true);
           }
 
           if (this._autoScrollNeedsCleanup) {
             // we polluted the global scope, so clean it up
             this._autoScrollPopup.remove();
           }
-          ]]>
-        </body>
+        ]]></body>
       </method>
 
+
       <!--
         We call this _receiveMessage (and alias receiveMessage to it) so that
         bindings that inherit from this one can delegate to it.
       -->
       <method name="_receiveMessage">
         <parameter name="aMessage"/>
         <body><![CDATA[
           let data = aMessage.data;
@@ -1006,20 +1210,102 @@
           }
           return undefined;
         ]]></body>
       </method>
 
       <method name="receiveMessage">
         <parameter name="aMessage"/>
         <body><![CDATA[
-          return this._receiveMessage(aMessage);
+          if (!this.isRemoteBrowser) {
+            return this._receiveMessage(aMessage);
+          }
+
+          let data = aMessage.data;
+          switch (aMessage.name) {
+            case "Browser:Init":
+              this._outerWindowID = data.outerWindowID;
+              break;
+            case "DOMTitleChanged":
+              this._contentTitle = data.title;
+              break;
+            case "ImageDocumentLoaded":
+              this._imageDocument = {
+                width: data.width,
+                height: data.height,
+              };
+              break;
+
+            case "Forms:ShowDropDown": {
+              if (!this._selectParentHelper) {
+                this._selectParentHelper =
+                  ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
+              }
+
+              let menulist = document.getElementById(this.getAttribute("selectmenulist"));
+              menulist.menupopup.style.direction = data.direction;
+
+              let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
+                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;
+              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
+                                                zoom, data.uaBackgroundColor, data.uaColor,
+                                                data.uaSelectBackgroundColor, data.uaSelectColor,
+                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
+              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
+              break;
+            }
+
+            case "FullZoomChange": {
+              this._fullZoom = data.value;
+              let event = document.createEvent("Events");
+              event.initEvent("FullZoomChange", true, false);
+              this.dispatchEvent(event);
+              break;
+            }
+
+            case "TextZoomChange": {
+              this._textZoom = data.value;
+              let event = document.createEvent("Events");
+              event.initEvent("TextZoomChange", true, false);
+              this.dispatchEvent(event);
+              break;
+            }
+
+            case "ZoomChangeUsingMouseWheel": {
+              let event = document.createEvent("Events");
+              event.initEvent("ZoomChangeUsingMouseWheel", true, false);
+              this.dispatchEvent(event);
+              break;
+            }
+
+            default:
+              return this._receiveMessage(aMessage);
+          }
+          return undefined;
+
         ]]></body>
       </method>
 
+      <method name="enableDisableCommandsRemoteOnly">
+        <parameter name="aAction"/>
+        <parameter name="aEnabledLength"/>
+        <parameter name="aEnabledCommands"/>
+        <parameter name="aDisabledLength"/>
+        <parameter name="aDisabledCommands"/>
+        <body>
+          <![CDATA[
+          if (this._controller) {
+            this._controller.enableDisableCommands(aAction,
+                                                   aEnabledLength, aEnabledCommands,
+                                                   aDisabledLength, aDisabledCommands);
+          }
+          ]]>
+        </body>
+      </method>
+
       <method name="observe">
         <parameter name="aSubject"/>
         <parameter name="aTopic"/>
         <parameter name="aState"/>
         <body>
           <![CDATA[
             if (aTopic == "browser:purge-session-history") {
               this.purgeSessionHistory();
@@ -1036,25 +1322,49 @@
             }
           ]]>
         </body>
       </method>
 
       <method name="purgeSessionHistory">
         <body>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              try {
+                this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
+              } catch (ex) {
+                // This can throw if the browser has started to go away.
+                if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
+                  throw ex;
+                }
+              }
+              this._remoteWebNavigationImpl.canGoBack = false;
+              this._remoteWebNavigationImpl.canGoForward = false;
+              return;
+            }
             this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
           ]]>
         </body>
       </method>
 
       <method name="createAboutBlankContentViewer">
         <parameter name="aPrincipal"/>
         <body>
           <![CDATA[
+            if (this.isRemoteBrowser) {
+              // Ensure that the content process has the permissions which are
+              // needed to create a document with the given principal.
+              let permissionPrincipal =
+                BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
+              this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
+
+              // Create the about blank content viewer in the content process
+              this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
+              return;
+            }
             let principal = BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
             this.docShell.createAboutBlankContentViewer(principal);
           ]]>
         </body>
       </method>
 
       <field name="_AUTOSCROLL_SNAP">10</field>
       <field name="_scrolling">false</field>
@@ -1402,20 +1712,33 @@
           event = new CustomEvent("EndSwapDocShells", {"detail": aOtherBrowser});
           this.dispatchEvent(event);
           event = new CustomEvent("EndSwapDocShells", {"detail": this});
           aOtherBrowser.dispatchEvent(event);
         ]]>
         </body>
       </method>
 
+      <field name="_permitUnloadId">0</field>
       <method name="getInPermitUnload">
         <parameter name="aCallback"/>
         <body>
         <![CDATA[
+          if (this.isRemoteBrowser) {
+            let id = this._permitUnloadId++;
+            let mm = this.messageManager;
+            mm.sendAsyncMessage("InPermitUnload", {id});
+            mm.addMessageListener("InPermitUnload", function listener(msg) {
+              if (msg.data.id != id) {
+                return;
+              }
+              aCallback(msg.data.inPermitUnload);
+            });
+          }
+
           if (!this.docShell || !this.docShell.contentViewer) {
             aCallback(false);
             return;
           }
           aCallback(this.docShell.contentViewer.inPermitUnload);
         ]]>
         </body>
       </method>
@@ -1427,16 +1750,80 @@
       <property name="dontPromptAndUnload"
                 onget="return 2;"
                 readonly="true"/>
 
       <method name="permitUnload">
         <parameter name="aPermitUnloadFlags"/>
         <body>
         <![CDATA[
+          if (this.isRemoteBrowser) {
+            let {tabParent} = this.frameLoader;
+
+            if (!tabParent.hasBeforeUnload) {
+              return { permitUnload: true, timedOut: false };
+            }
+
+            const kTimeout = 1000;
+
+            let finished = false;
+            let responded = false;
+            let permitUnload;
+            let id = this._permitUnloadId++;
+            let mm = this.messageManager;
+            let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
+
+            let msgListener = msg => {
+              if (msg.data.id != id) {
+                return;
+              }
+              if (msg.data.kind == "start") {
+                responded = true;
+                return;
+              }
+              done(msg.data.permitUnload);
+            };
+
+            let observer = subject => {
+              if (subject == mm) {
+                done(true);
+              }
+            };
+
+            function done(result) {
+              finished = true;
+              permitUnload = result;
+              mm.removeMessageListener("PermitUnload", msgListener);
+              Services.obs.removeObserver(observer, "message-manager-close");
+            }
+
+            mm.sendAsyncMessage("PermitUnload", {id, aPermitUnloadFlags});
+            mm.addMessageListener("PermitUnload", msgListener);
+            Services.obs.addObserver(observer, "message-manager-close");
+
+            let timedOut = false;
+            function timeout() {
+              if (!responded) {
+                timedOut = true;
+              }
+
+              // Dispatch something to ensure that the main thread wakes up.
+              Services.tm.dispatchToMainThread(function() {});
+            }
+
+            let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+            timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
+
+            while (!finished && !timedOut) {
+              Services.tm.currentThread.processNextEvent(true);
+            }
+
+            return {permitUnload, timedOut};
+          }
+
           if (!this.docShell || !this.docShell.contentViewer) {
             return {permitUnload: true, timedOut: false};
           }
           return {permitUnload: this.docShell.contentViewer.permitUnload(aPermitUnloadFlags),
                   timedOut: false};
         ]]>
         </body>
       </method>
@@ -1576,13 +1963,23 @@
         }
 
         if (links.length) {
           let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);
           this.droppedLinkHandler(event, links, triggeringPrincipal);
         }
       ]]>
       </handler>
+      <handler event="dragstart">
+      <![CDATA[
+        // If we're a remote browser dealing with a dragstart, stop it
+        // from propagating up, since our content process should be dealing
+        // with the mouse movement.
+        if (this.isRemoteBrowser) {
+          event.stopPropagation();
+        }
+      ]]>
+      </handler>
     </handlers>
 
   </binding>
 
 </bindings>
diff --git a/toolkit/content/widgets/remote-browser.xml b/toolkit/content/widgets/remote-browser.xml
--- a/toolkit/content/widgets/remote-browser.xml
+++ b/toolkit/content/widgets/remote-browser.xml
@@ -7,40 +7,16 @@
 <bindings id="firefoxBrowserBindings"
           xmlns="http://www.mozilla.org/xbl"
           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <binding id="remote-browser" extends="chrome://global/content/bindings/browser.xml#browser">
 
     <implementation type="application/javascript">
 
-      <field name="_securityUI">null</field>
-
-      <property name="securityUI"
-                readonly="true">
-        <getter><![CDATA[
-          if (!this._securityUI) {
-            // Don't attempt to create the remote web progress if the
-            // messageManager has already gone away
-            if (!this.messageManager)
-              return null;
-
-            let jsm = "resource://gre/modules/RemoteSecurityUI.jsm";
-            let RemoteSecurityUI = ChromeUtils.import(jsm, {}).RemoteSecurityUI;
-            this._securityUI = new RemoteSecurityUI();
-          }
-
-          // We want to double-wrap the JS implemented interface, so that QI and instanceof works.
-          var ptr = Cc["@mozilla.org/supports-interface-pointer;1"]
-                      .createInstance(Ci.nsISupportsInterfacePointer);
-          ptr.data = this._securityUI;
-          return ptr.data.QueryInterface(Ci.nsISecureBrowserUI);
-        ]]></getter>
-      </property>
-
       <field name="_controller">null</field>
 
       <field name="_selectParentHelper">null</field>
 
       <field name="_remoteWebNavigation">null</field>
 
       <property name="webNavigation"
                 onget="return this._remoteWebNavigation;"
@@ -190,411 +166,13 @@
             } catch (ex) {}
 
             let event = new Event("TextZoomChange", {bubbles: true});
             this.dispatchEvent(event);
           }
         ]]></setter>
       </property>
 
-      <field name="_isSyntheticDocument">false</field>
-      <property name="isSyntheticDocument">
-        <getter><![CDATA[
-          return this._isSyntheticDocument;
-        ]]></getter>
-      </property>
-
-      <property name="hasContentOpener">
-        <getter><![CDATA[
-          return this.frameLoader.tabParent.hasContentOpener;
-        ]]></getter>
-      </property>
-
-      <field name="_outerWindowID">null</field>
-      <property name="outerWindowID"
-                onget="return this._outerWindowID"
-                readonly="true"/>
-
-      <field name="_innerWindowID">null</field>
-      <property name="innerWindowID">
-        <getter><![CDATA[
-          return this._innerWindowID;
-        ]]></getter>
-      </property>
-
-      <property name="docShellIsActive">
-        <getter>
-          <![CDATA[
-            return this.frameLoader.tabParent.docShellIsActive;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            this.frameLoader.tabParent.docShellIsActive = val;
-            return val;
-          ]]>
-        </setter>
-      </property>
-
-      <method name="preserveLayers">
-        <parameter name="preserve"/>
-        <body><![CDATA[
-          let {frameLoader} = this;
-          if (frameLoader.tabParent) {
-            frameLoader.tabParent.preserveLayers(preserve);
-          }
-        ]]></body>
-      </method>
-
-      <property name="renderLayers">
-        <getter>
-          <![CDATA[
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              return frameLoader.tabParent.renderLayers;
-            }
-            return false;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              return frameLoader.tabParent.renderLayers = val;
-            }
-            return false;
-          ]]>
-        </setter>
-      </property>
-
-      <method name="forceRepaint">
-        <body>
-          <![CDATA[
-            let {frameLoader} = this;
-            if (frameLoader && frameLoader.tabParent) {
-              frameLoader.tabParent.forceRepaint();
-            }
-          ]]>
-        </body>
-      </method>
-
-      <property name="hasLayers" readonly="true">
-        <getter><![CDATA[
-          let {frameLoader} = this;
-          if (frameLoader.tabParent) {
-            return frameLoader.tabParent.hasLayers;
-          }
-          return false;
-        ]]></getter>
-      </property>
-
-      <field name="mDestroyed">false</field>
-
-      <field name="_permitUnloadId">0</field>
-
-      <method name="getInPermitUnload">
-        <parameter name="aCallback"/>
-        <body>
-        <![CDATA[
-          let id = this._permitUnloadId++;
-          let mm = this.messageManager;
-          mm.sendAsyncMessage("InPermitUnload", {id});
-          mm.addMessageListener("InPermitUnload", function listener(msg) {
-            if (msg.data.id != id) {
-              return;
-            }
-            aCallback(msg.data.inPermitUnload);
-          });
-        ]]>
-        </body>
-      </method>
-
-      <method name="permitUnload">
-        <parameter name="aPermitUnloadFlags"/>
-        <body>
-        <![CDATA[
-          let {tabParent} = this.frameLoader;
-
-          if (!tabParent.hasBeforeUnload) {
-            return { permitUnload: true, timedOut: false };
-          }
-
-          const kTimeout = 1000;
-
-          let finished = false;
-          let responded = false;
-          let permitUnload;
-          let id = this._permitUnloadId++;
-          let mm = this.messageManager;
-          let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-
-          let msgListener = msg => {
-            if (msg.data.id != id) {
-              return;
-            }
-            if (msg.data.kind == "start") {
-              responded = true;
-              return;
-            }
-            done(msg.data.permitUnload);
-          };
-
-          let observer = subject => {
-            if (subject == mm) {
-              done(true);
-            }
-          };
-
-          function done(result) {
-            finished = true;
-            permitUnload = result;
-            mm.removeMessageListener("PermitUnload", msgListener);
-            Services.obs.removeObserver(observer, "message-manager-close");
-          }
-
-          mm.sendAsyncMessage("PermitUnload", {id, aPermitUnloadFlags});
-          mm.addMessageListener("PermitUnload", msgListener);
-          Services.obs.addObserver(observer, "message-manager-close");
-
-          let timedOut = false;
-          function timeout() {
-            if (!responded) {
-              timedOut = true;
-            }
-
-            // Dispatch something to ensure that the main thread wakes up.
-            Services.tm.dispatchToMainThread(function() {});
-          }
-
-          let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-          timer.initWithCallback(timeout, kTimeout, timer.TYPE_ONE_SHOT);
-
-          while (!finished && !timedOut) {
-            Services.tm.currentThread.processNextEvent(true);
-          }
-
-          return {permitUnload, timedOut};
-        ]]>
-        </body>
-      </method>
-
-      <constructor>
-        <![CDATA[
-          /*
-           * Don't try to send messages from this function. The message manager for
-           * the <browser> element may not be initialized yet.
-           */
-
-          this._remoteWebNavigation = Cc["@mozilla.org/remote-web-navigation;1"]
-                                        .createInstance(Ci.nsIWebNavigation);
-          this._remoteWebNavigationImpl = this._remoteWebNavigation.wrappedJSObject;
-          this._remoteWebNavigationImpl.swapBrowser(this);
-
-          // Initialize contentPrincipal to the about:blank principal for this loadcontext
-          let {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm", {});
-          let aboutBlank = Services.io.newURI("about:blank");
-          let ssm = Services.scriptSecurityManager;
-          this._contentPrincipal = ssm.getLoadContextCodebasePrincipal(aboutBlank, this.loadContext);
-
-          this.messageManager.addMessageListener("Browser:Init", this);
-          this.messageManager.addMessageListener("DOMTitleChanged", this);
-          this.messageManager.addMessageListener("ImageDocumentLoaded", this);
-          this.messageManager.addMessageListener("FullZoomChange", this);
-          this.messageManager.addMessageListener("TextZoomChange", this);
-          this.messageManager.addMessageListener("ZoomChangeUsingMouseWheel", this);
-
-          // browser-child messages, such as Content:LocationChange, are handled in
-          // RemoteWebProgress, ensure it is loaded and ready.
-          let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
-          let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
-          this._remoteWebProgressManager = new RemoteWebProgressManager(this);
-          this._remoteWebProgress = this._remoteWebProgressManager.topLevelWebProgress;
-
-          this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
-
-          if (this.hasAttribute("selectmenulist")) {
-            this.messageManager.addMessageListener("Forms:ShowDropDown", this);
-            this.messageManager.addMessageListener("Forms:HideDropDown", this);
-          }
-
-          if (!this.hasAttribute("disablehistory")) {
-            Services.obs.addObserver(this, "browser:purge-session-history", true);
-          }
-
-          let rc_js = "resource://gre/modules/RemoteController.js";
-          let scope = {};
-          Services.scriptloader.loadSubScript(rc_js, scope);
-          let RemoteController = scope.RemoteController;
-          this._controller = new RemoteController(this);
-          this.controllers.appendController(this._controller);
-        ]]>
-      </constructor>
-
-      <destructor>
-        <![CDATA[
-          this.destroy();
-        ]]>
-      </destructor>
-
-      <!-- This is necessary because the destructor doesn't always get called when
-           we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
-
-           Note: This overrides the destroy() method from browser.xml. -->
-      <method name="destroy">
-        <body><![CDATA[
-          // Make sure that any open select is closed.
-          if (this._selectParentHelper) {
-            let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-            this._selectParentHelper.hide(menulist, this);
-          }
-
-          if (this.mDestroyed)
-            return;
-          this.mDestroyed = true;
-
-          try {
-            this.controllers.removeController(this._controller);
-          } catch (ex) {
-            // This can fail when this browser element is not attached to a
-            // BrowserDOMWindow.
-          }
-
-          if (!this.hasAttribute("disablehistory")) {
-            let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
-            try {
-              Services.obs.removeObserver(this, "browser:purge-session-history");
-            } catch (ex) {
-              // It's not clear why this sometimes throws an exception.
-            }
-          }
-        ]]></body>
-      </method>
-
-      <method name="receiveMessage">
-        <parameter name="aMessage"/>
-        <body><![CDATA[
-          let data = aMessage.data;
-          switch (aMessage.name) {
-            case "Browser:Init":
-              this._outerWindowID = data.outerWindowID;
-              break;
-            case "DOMTitleChanged":
-              this._contentTitle = data.title;
-              break;
-            case "ImageDocumentLoaded":
-              this._imageDocument = {
-                width: data.width,
-                height: data.height,
-              };
-              break;
-
-            case "Forms:ShowDropDown": {
-              if (!this._selectParentHelper) {
-                this._selectParentHelper =
-                  ChromeUtils.import("resource://gre/modules/SelectParentHelper.jsm", {}).SelectParentHelper;
-              }
-
-              let menulist = document.getElementById(this.getAttribute("selectmenulist"));
-              menulist.menupopup.style.direction = data.direction;
-
-              let zoom = Services.prefs.getBoolPref("browser.zoom.full") ||
-                         this.isSyntheticDocument ? this._fullZoom : this._textZoom;
-              this._selectParentHelper.populate(menulist, data.options, data.selectedIndex,
-                                                zoom, data.uaBackgroundColor, data.uaColor,
-                                                data.uaSelectBackgroundColor, data.uaSelectColor,
-                                                data.selectBackgroundColor, data.selectColor, data.selectTextShadow);
-              this._selectParentHelper.open(this, menulist, data.rect, data.isOpenedViaTouch);
-              break;
-            }
-
-            case "FullZoomChange": {
-              this._fullZoom = data.value;
-              let event = document.createEvent("Events");
-              event.initEvent("FullZoomChange", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            case "TextZoomChange": {
-              this._textZoom = data.value;
-              let event = document.createEvent("Events");
-              event.initEvent("TextZoomChange", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            case "ZoomChangeUsingMouseWheel": {
-              let event = document.createEvent("Events");
-              event.initEvent("ZoomChangeUsingMouseWheel", true, false);
-              this.dispatchEvent(event);
-              break;
-            }
-
-            default:
-              // Delegate to browser.xml.
-              return this._receiveMessage(aMessage);
-          }
-          return undefined;
-        ]]></body>
-      </method>
-
-      <method name="enableDisableCommandsRemoteOnly">
-        <parameter name="aAction"/>
-        <parameter name="aEnabledLength"/>
-        <parameter name="aEnabledCommands"/>
-        <parameter name="aDisabledLength"/>
-        <parameter name="aDisabledCommands"/>
-        <body>
-          if (this._controller) {
-            this._controller.enableDisableCommands(aAction,
-                                                   aEnabledLength, aEnabledCommands,
-                                                   aDisabledLength, aDisabledCommands);
-          }
-        </body>
-      </method>
-
-      <method name="purgeSessionHistory">
-        <body>
-          <![CDATA[
-            try {
-              this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
-            } catch (ex) {
-              // This can throw if the browser has started to go away.
-              if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
-                throw ex;
-              }
-            }
-            this._remoteWebNavigationImpl.canGoBack = false;
-            this._remoteWebNavigationImpl.canGoForward = false;
-          ]]>
-        </body>
-      </method>
-
-      <method name="createAboutBlankContentViewer">
-        <parameter name="aPrincipal"/>
-        <body>
-          <![CDATA[
-            // Ensure that the content process has the permissions which are
-            // needed to create a document with the given principal.
-            let permissionPrincipal =
-              BrowserUtils.principalWithMatchingOA(aPrincipal, this.contentPrincipal);
-            this.frameLoader.tabParent.transmitPermissionsForPrincipal(permissionPrincipal);
-
-            // Create the about blank content viewer in the content process
-            this.messageManager.sendAsyncMessage("Browser:CreateAboutBlank", aPrincipal);
-          ]]>
-        </body>
-      </method>
     </implementation>
-    <handlers>
-      <handler event="dragstart">
-      <![CDATA[
-        // If we're a remote browser dealing with a dragstart, stop it
-        // from propagating up, since our content process should be dealing
-        // with the mouse movement.
-        event.stopPropagation();
-      ]]>
-      </handler>
-    </handlers>
 
   </binding>
 
 </bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -180,19 +180,19 @@ iframe {
     display: block;
   }
 }
 
 browser {
   -moz-binding: url("chrome://global/content/bindings/browser.xml#browser");
 }
 
-browser[remote=true]:not(.lightweight) {
+/* browser[remote=true]:not(.lightweight) {
   -moz-binding: url("chrome://global/content/bindings/remote-browser.xml#remote-browser");
-}
+} */
 
 /********** notifications **********/
 
 notificationbox {
   -moz-binding: url("chrome://global/content/bindings/notification.xml#notificationbox");
   -moz-box-orient: vertical;
 }
 
