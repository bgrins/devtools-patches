# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  634e6ef56895ee6aa94f58cd702dd96dee9c88bf

diff --git a/browser/base/content/hiddenWindow.xul b/browser/base/content/hiddenWindow.xul
--- a/browser/base/content/hiddenWindow.xul
+++ b/browser/base/content/hiddenWindow.xul
@@ -4,18 +4,36 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifdef XP_MACOSX
 <?xul-overlay href="chrome://browser/content/macBrowserOverlay.xul"?>
 <?xml-stylesheet href="chrome://browser/skin/webRTC-indicator.css" type="text/css"?>
 
+#include browser-doctype.inc
+
 <window id="main-window"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
-<popupset></popupset>
+<popupset>
+    <menupopup id="contentAreaContextMenu" pagemenu="#page-menu-separator"
+               onpopupshowing="if (event.target != this)
+                                 return true;
+                               gContextMenu = new nsContextMenu(this, event.shiftKey);
+                               if (gContextMenu.shouldDisplay)
+                                 updateEditUIVisibility();
+                               return gContextMenu.shouldDisplay;"
+               onpopuphiding="if (event.target != this)
+                                return;
+                              gContextMenu.hiding();
+                              gContextMenu = null;
+                              updateEditUIVisibility();">
+#include browser-context.inc
+    </menupopup>
+</popupset>
+
 #include browserMountPoints.inc
 
 </window>
 
 #endif
diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -67,17 +67,17 @@ function openContextMenu(aMessage) {
                             };
 
   let popup = browser.ownerDocument.getElementById("contentAreaContextMenu");
   let context = gContextMenuContentData.context;
 
   // The event is a CPOW that can't be passed into the native openPopupAtScreen
   // function. Therefore we synthesize a new MouseEvent to propagate the
   // inputSource to the subsequently triggered popupshowing event.
-  var newEvent = document.createEvent("MouseEvent");
+  var newEvent = Services.appShell.hiddenDOMWindow.document.createEvent("MouseEvent");
   newEvent.initNSMouseEvent("contextmenu", true, true, null, 0, context.screenX, context.screenY,
                             0, 0, false, false, false, false, 0, null, 0, context.mozInputSource);
 
   popup.openPopupAtScreen(newEvent.screenX, newEvent.screenY, true, newEvent);
 }
 
 function nsContextMenu(aXulMenu, aIsShift) {
   this.shouldDisplay = true;
@@ -126,29 +126,29 @@ nsContextMenu.prototype = {
         linkUrl: this.linkURL,
         selectionText: this.isTextSelected ? this.selectionInfo.fullText : undefined,
         frameId: this.frameOuterWindowID,
       };
       subject.wrappedJSObject = subject;
       Services.obs.notifyObservers(subject, "on-build-contextmenu");
     }
 
-    this.isFrameImage = document.getElementById("isFrameImage");
+    this.isFrameImage = Services.appShell.hiddenDOMWindow.document.getElementById("isFrameImage");
     this.ellipsis = "\u2026";
     try {
       this.ellipsis = Services.prefs.getComplexValue("intl.ellipsis",
                                                      Ci.nsIPrefLocalizedString).data;
     } catch (e) { }
 
     // Reset after "on-build-contextmenu" notification in case selection was
     // changed during the notification.
     this.isContentSelected = !this.selectionInfo.docSelectionIsCollapsed;
     this.onPlainTextLink = false;
 
-    let bookmarkPage = document.getElementById("context-bookmarkpage");
+    let bookmarkPage = Services.appShell.hiddenDOMWindow.document.getElementById("context-bookmarkpage");
     if (bookmarkPage)
       BookmarkingUI.onCurrentPageContextPopupShowing();
 
     // Initialize (disable/remove) menu items.
     this.initItems();
 
     // Register this opening of the menu with telemetry:
     this._checkTelemetryForMenu(aXulMenu);
@@ -207,17 +207,17 @@ nsContextMenu.prototype = {
     this.onMozExtLink        = context.onMozExtLink;
     this.onNumeric           = context.onNumeric;
     this.onPassword          = context.onPassword;
     this.onSaveableLink      = context.onSaveableLink;
     this.onSpellcheckable    = context.onSpellcheckable;
     this.onTextInput         = context.onTextInput;
     this.onVideo             = context.onVideo;
 
-    this.target = this.isRemote ? context.target : document.popupNode;
+    this.target = this.isRemote ? context.target : Services.appShell.hiddenDOMWindow.document.popupNode;
     this.targetAsCPOW = context.targetAsCPOW;
 
     this.principal = context.principal;
     this.frameOuterWindowID = context.frameOuterWindowID;
 
     this.inSyntheticDoc = context.inSyntheticDoc;
 
     // Everything after this isn't sent directly from ContextMenu
@@ -248,34 +248,34 @@ nsContextMenu.prototype = {
     this.inTabBrowser      = this.browser.ownerGlobal.gBrowser ?
       !!this.browser.ownerGlobal.gBrowser.getTabForBrowser(this.browser) : false;
 
     if (context.shouldInitInlineSpellCheckerUINoChildren) {
       if (this.isRemote) {
         InlineSpellCheckerUI.initFromRemote(gContextMenuContentData.spellInfo);
       } else {
         InlineSpellCheckerUI.init(this.target.QueryInterface(Ci.nsIDOMNSEditableElement).editor);
-        InlineSpellCheckerUI.initFromEvent(document.popupRangeParent,
-                                           document.popupRangeOffset);
+        InlineSpellCheckerUI.initFromEvent(Services.appShell.hiddenDOMWindow.document.popupRangeParent,
+                                           Services.appShell.hiddenDOMWindow.document.popupRangeOffset);
       }
     }
 
     if (context.shouldInitInlineSpellCheckerUIWithChildren) {
       if (this.isRemote) {
         InlineSpellCheckerUI.initFromRemote(gContextMenuContentData.spellInfo);
       } else {
         var targetWin = this.ownerDoc.defaultView;
         var editingSession = targetWin.QueryInterface(Ci.nsIInterfaceRequestor)
                                       .getInterface(Ci.nsIWebNavigation)
                                       .QueryInterface(Ci.nsIInterfaceRequestor)
                                       .getInterface(Ci.nsIEditingSession);
 
         InlineSpellCheckerUI.init(editingSession.getEditorForWindow(targetWin));
-        InlineSpellCheckerUI.initFromEvent(document.popupRangeParent,
-                                           document.popupRangeOffset);
+        InlineSpellCheckerUI.initFromEvent(Services.appShell.hiddenDOMWindow.document.popupRangeParent,
+                                           Services.appShell.hiddenDOMWindow.document.popupRangeOffset);
       }
 
       let canSpell = InlineSpellCheckerUI.canSpellCheck && this.canSpellCheck;
       this.showItem("spell-check-enabled", canSpell);
       this.showItem("spell-separator", canSpell);
     }
   },  // setContext
 
@@ -338,17 +338,17 @@ nsContextMenu.prototype = {
 
       this.linkTextStr = this.selectionInfo.linkText;
       this.onPlainTextLink = true;
     }
 
     var inContainer = false;
     if (gContextMenuContentData.userContextId) {
       inContainer = true;
-      var item = document.getElementById("context-openlinkincontainertab");
+      var item = Services.appShell.hiddenDOMWindow.document.getElementById("context-openlinkincontainertab");
 
       item.setAttribute("data-usercontextid", gContextMenuContentData.userContextId);
 
       var label =
         ContextualIdentityService.getUserContextLabel(gContextMenuContentData.userContextId);
       item.setAttribute("label",
          gBrowserBundle.formatStringFromName("userContextOpenLink.label",
                                              [label], 1));
@@ -458,17 +458,17 @@ nsContextMenu.prototype = {
       if (shell)
         haveSetDesktopBackground = shell.canSetDesktopBackground;
     }
 
     this.showItem("context-setDesktopBackground",
                   haveSetDesktopBackground && this.onLoadedImage);
 
     if (haveSetDesktopBackground && this.onLoadedImage) {
-      document.getElementById("context-setDesktopBackground")
+      Services.appShell.hiddenDOMWindow.document.getElementById("context-setDesktopBackground")
               .disabled = gContextMenuContentData.disableSetDesktopBackground;
     }
 
     // Reload image depends on an image that's not fully loaded
     this.showItem("context-reloadimage", (this.onImage && !this.onCompletedImage));
 
     // View image depends on having an image that's not standalone
     // (or is in a frame), or a canvas.
@@ -482,29 +482,29 @@ nsContextMenu.prototype = {
     // View background image depends on whether there is one, but don't make
     // background images of a stand-alone media document available.
     this.showItem("context-viewbgimage", shouldShow &&
                                          !this.hasMultipleBGImages &&
                                          !this.inSyntheticDoc);
     this.showItem("context-sep-viewbgimage", shouldShow &&
                                              !this.hasMultipleBGImages &&
                                              !this.inSyntheticDoc);
-    document.getElementById("context-viewbgimage")
+    Services.appShell.hiddenDOMWindow.document.getElementById("context-viewbgimage")
             .disabled = !this.hasBGImage;
 
     this.showItem("context-viewimageinfo", this.onImage);
     // The image info popup is broken for WebExtension popups, since the browser
     // is destroyed when the popup is closed.
     this.setItemAttr("context-viewimageinfo", "disabled", this.webExtBrowserType === "popup");
     this.showItem("context-viewimagedesc", this.onImage && this.imageDescURL !== "");
   },
 
   initMiscItems: function CM_initMiscItems() {
     // Use "Bookmark This Link" if on a link.
-    let bookmarkPage = document.getElementById("context-bookmarkpage");
+    let bookmarkPage = Services.appShell.hiddenDOMWindow.document.getElementById("context-bookmarkpage");
     this.showItem(bookmarkPage,
                   !(this.isContentSelected || this.onTextInput || this.onLink ||
                     this.onImage || this.onVideo || this.onAudio ||
                     this.onCanvas || this.inWebExtBrowser));
     bookmarkPage.setAttribute("tooltiptext", bookmarkPage.getAttribute("buttontooltiptext"));
 
     this.showItem("context-bookmarklink", (this.onLink && !this.onMailtoLink &&
                                            !this.onMozExtLink) || this.onPlainTextLink);
@@ -551,40 +551,40 @@ nsContextMenu.prototype = {
     var canSpell = InlineSpellCheckerUI.canSpellCheck &&
                    !InlineSpellCheckerUI.initialSpellCheckPending &&
                    this.canSpellCheck;
     let showDictionaries = canSpell && InlineSpellCheckerUI.enabled;
     var onMisspelling = InlineSpellCheckerUI.overMisspelling;
     var showUndo = canSpell && InlineSpellCheckerUI.canUndo();
     this.showItem("spell-check-enabled", canSpell);
     this.showItem("spell-separator", canSpell);
-    document.getElementById("spell-check-enabled")
+    Services.appShell.hiddenDOMWindow.document.getElementById("spell-check-enabled")
             .setAttribute("checked", canSpell && InlineSpellCheckerUI.enabled);
 
     this.showItem("spell-add-to-dictionary", onMisspelling);
     this.showItem("spell-undo-add-to-dictionary", showUndo);
 
     // suggestion list
     this.showItem("spell-suggestions-separator", onMisspelling || showUndo);
     if (onMisspelling) {
       var suggestionsSeparator =
-        document.getElementById("spell-add-to-dictionary");
+        Services.appShell.hiddenDOMWindow.document.getElementById("spell-add-to-dictionary");
       var numsug =
         InlineSpellCheckerUI.addSuggestionsToMenu(suggestionsSeparator.parentNode,
                                                   suggestionsSeparator, 5);
       this.showItem("spell-no-suggestions", numsug == 0);
     } else {
       this.showItem("spell-no-suggestions", false);
     }
 
     // dictionary list
     this.showItem("spell-dictionaries", showDictionaries);
     if (canSpell) {
-      var dictMenu = document.getElementById("spell-dictionaries-menu");
-      var dictSep = document.getElementById("spell-language-separator");
+      var dictMenu = Services.appShell.hiddenDOMWindow.document.getElementById("spell-dictionaries-menu");
+      var dictSep = Services.appShell.hiddenDOMWindow.document.getElementById("spell-language-separator");
       let count = InlineSpellCheckerUI.addDictionaryListToMenu(dictMenu, dictSep);
       this.showItem(dictSep, count > 0);
       this.showItem("spell-add-dictionaries-main", false);
     } else if (this.onSpellcheckable) {
       // when there is no spellchecker but we might be able to spellcheck
       // add the add to dictionaries item. This will ensure that people
       // with no dictionaries will be able to download them
       this.showItem("spell-language-separator", showDictionaries);
@@ -710,17 +710,17 @@ nsContextMenu.prototype = {
                       loginFillInfo.passwordField.disabled ||
                       (!this.onPassword && loginFillInfo.usernameField.disabled);
 
     this.showItem("fill-login-separator", showFill);
     this.showItem("fill-login", showFill);
     this.setItemAttr("fill-login", "disabled", disableFill);
 
     // Set the correct label for the fill menu
-    let fillMenu = document.getElementById("fill-login");
+    let fillMenu = Services.appShell.hiddenDOMWindow.document.getElementById("fill-login");
     if (this.onPassword) {
       fillMenu.setAttribute("label", fillMenu.getAttribute("label-password"));
       fillMenu.setAttribute("accesskey", fillMenu.getAttribute("accesskey-password"));
     } else {
       fillMenu.setAttribute("label", fillMenu.getAttribute("label-login"));
       fillMenu.setAttribute("accesskey", fillMenu.getAttribute("accesskey-login"));
     }
 
@@ -730,18 +730,18 @@ nsContextMenu.prototype = {
     let documentURI = gContextMenuContentData.documentURIObject;
     let fragment = LoginManagerContextMenu.addLoginsToMenu(this.targetAsCPOW, this.browser, documentURI);
 
     this.showItem("fill-login-no-logins", !fragment);
 
     if (!fragment) {
       return;
     }
-    let popup = document.getElementById("fill-login-popup");
-    let insertBeforeElement = document.getElementById("fill-login-no-logins");
+    let popup = Services.appShell.hiddenDOMWindow.document.getElementById("fill-login-popup");
+    let insertBeforeElement = Services.appShell.hiddenDOMWindow.document.getElementById("fill-login-no-logins");
     popup.insertBefore(fragment, insertBeforeElement);
   },
 
   initSyncItems() {
     gSync.updateContentContextMenu(this);
   },
 
   openPasswordManager() {
@@ -984,24 +984,24 @@ nsContextMenu.prototype = {
     mm.sendAsyncMessage("ContextMenu:SaveVideoFrameAsImage", {}, {
       target: this.target,
     });
 
     let onMessage = (message) => {
       mm.removeMessageListener("ContextMenu:SaveVideoFrameAsImage:Result", onMessage);
       let dataURL = message.data.dataURL;
       saveImageURL(dataURL, name, "SaveImageTitle", true, false,
-                   document.documentURIObject, null, null, null,
+                   Services.appShell.hiddenDOMWindow.document.documentURIObject, null, null, null,
                    isPrivate);
     };
     mm.addMessageListener("ContextMenu:SaveVideoFrameAsImage:Result", onMessage);
   },
 
   leaveDOMFullScreen() {
-    document.exitFullscreen();
+    Services.appShell.hiddenDOMWindow.document.exitFullscreen();
   },
 
   // Change current window to the URL of the background image.
   viewBGImage(e) {
     urlSecurityCheck(this.bgImageURL,
                      this.browser.contentPrincipal,
                      Ci.nsIScriptSecurityManager.DISALLOW_SCRIPT);
     openUILink(this.bgImageURL, e, { disallowInheritPrincipal: true,
@@ -1018,17 +1018,17 @@ nsContextMenu.prototype = {
       mm.removeMessageListener("ContextMenu:SetAsDesktopBackground:Result",
                                onMessage);
 
       if (message.data.disable ||
           !Services.policies.isAllowed("setDesktopBackground")) {
         return;
       }
 
-      let image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
+      let image = Services.appShell.hiddenDOMWindow.document.createElementNS("http://www.w3.org/1999/xhtml", "img");
       image.src = message.data.dataUrl;
       let imageName = message.data.imageName;
 
       // Confirm since it's annoying if you hit this accidentally.
       const kDesktopBackgroundURL =
                     "chrome://browser/content/setDesktopBackground.xul";
 
       if (AppConstants.platform == "macosx") {
@@ -1303,51 +1303,51 @@ nsContextMenu.prototype = {
    * If the element is not found, then this function finishes silently.
    *
    * @param {Element|String} aItemOrId The item element or the name of the element
    *                                   to show.
    * @param {Boolean} aShow Set to true to show the item, false to hide it.
    */
   showItem(aItemOrId, aShow) {
     var item = aItemOrId.constructor == String ?
-      document.getElementById(aItemOrId) : aItemOrId;
+      Services.appShell.hiddenDOMWindow.document.getElementById(aItemOrId) : aItemOrId;
     if (item)
       item.hidden = !aShow;
   },
 
   // Set given attribute of specified context-menu item.  If the
   // value is null, then it removes the attribute (which works
   // nicely for the disabled attribute).
   setItemAttr(aID, aAttr, aVal ) {
-    var elem = document.getElementById(aID);
+    var elem = Services.appShell.hiddenDOMWindow.document.getElementById(aID);
     if (elem) {
       if (aVal == null) {
         // null indicates attr should be removed.
         elem.removeAttribute(aAttr);
       } else {
         // Set attr=val.
         elem.setAttribute(aAttr, aVal);
       }
     }
   },
 
   // Set context menu attribute according to like attribute of another node
   // (such as a broadcaster).
   setItemAttrFromNode(aItem_id, aAttr, aOther_id) {
-    var elem = document.getElementById(aOther_id);
+    var elem = Services.appShell.hiddenDOMWindow.document.getElementById(aOther_id);
     if (elem && elem.getAttribute(aAttr) == "true")
       this.setItemAttr(aItem_id, aAttr, "true");
     else
       this.setItemAttr(aItem_id, aAttr, null);
   },
 
   // Temporary workaround for DOM api not yet implemented by XUL nodes.
   cloneNode(aItem) {
     // Create another element like the one we're cloning.
-    var node = document.createElement(aItem.tagName);
+    var node = Services.appShell.hiddenDOMWindow.document.createElement(aItem.tagName);
 
     // Copy attributes from argument item to the new one.
     var attrs = aItem.attributes;
     for (var i = 0; i < attrs.length; i++) {
       var attr = attrs.item(i);
       node.setAttribute(attr.nodeName, attr.nodeValue);
     }
 
@@ -1369,17 +1369,17 @@ nsContextMenu.prototype = {
   linkText() {
     return this.linkTextStr;
   },
 
   // Determines whether or not the separator with the specified ID should be
   // shown or not by determining if there are any non-hidden items between it
   // and the previous separator.
   shouldShowSeparator(aSeparatorID) {
-    var separator = document.getElementById(aSeparatorID);
+    var separator = Services.appShell.hiddenDOMWindow.document.getElementById(aSeparatorID);
     if (separator) {
       var sibling = separator.previousSibling;
       while (sibling && sibling.localName != "menuseparator") {
         if (!sibling.hidden)
           return true;
         sibling = sibling.previousSibling;
       }
     }
@@ -1481,17 +1481,17 @@ nsContextMenu.prototype = {
   get imageURL() {
     if (this.onImage)
       return this.mediaURL;
     return "";
   },
 
   // Formats the 'Search <engine> for "<selection or link text>"' context menu.
   formatSearchContextItem() {
-    var menuItem = document.getElementById("context-searchselect");
+    var menuItem = Services.appShell.hiddenDOMWindow.document.getElementById("context-searchselect");
     let selectedText = this.isTextSelected ? this.textSelected : this.linkTextStr;
 
     // Store searchTerms in context menu item so we know what to search onclick
     menuItem.searchTerms = selectedText;
 
     // Copied to alert.js' prefillAlertInfo().
     // If the JS character after our truncation point is a trail surrogate,
     // include it in the truncated string to avoid splitting a surrogate pair.
