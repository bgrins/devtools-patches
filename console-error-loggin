# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e6094d9c1efdbed6c119b2e503a8532c36f23edb
Extra logging

diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -1531,26 +1531,26 @@ ThreadActor.prototype = {
       }
       this._hiddenBreakpoints.clear();
     }
 
     this._state = "paused";
 
     // Create the actor pool that will hold the pause actor and its
     // children.
-    dbg_assert(!this._pausePool, "No pause pool should exist yet");
+    // dbg_assert(!this._pausePool, "No pause pool should exist yet");
     this._pausePool = new ActorPool(this.conn);
     this.conn.addActorPool(this._pausePool);
 
     // Give children of the pause pool a quick link back to the
     // thread...
     this._pausePool.threadActor = this;
 
     // Create the pause actor itself...
-    dbg_assert(!this._pauseActor, "No pause actor should exist yet");
+    // dbg_assert(!this._pauseActor, "No pause actor should exist yet");
     this._pauseActor = new PauseActor(this._pausePool);
     this._pausePool.addActor(this._pauseActor);
 
     // Update the list of frames.
     let poppedFrames = this._updateFrames();
 
     // Send off the paused packet and spin an event loop.
     let packet = { from: this.actorID,
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -157,19 +157,19 @@ WebConsoleActor.prototype =
             this.parentActor instanceof DebuggerServer.ContentActor;
   },
 
   /**
    * The window we work with.
    * @type nsIDOMWindow
    */
   get window() {
-    if (this.parentActor.isRootActor) {
-      return this._getWindowForBrowserConsole();
-    }
+    // if (this.parentActor.isRootActor) {
+    //   return this._getWindowForBrowserConsole();
+    // }
     return this.parentActor.window;
   },
 
   /**
    * Get a window to use for the browser console.
    *
    * @private
    * @return nsIDOMWindow
@@ -240,22 +240,22 @@ WebConsoleActor.prototype =
 
   // The evalWindow is used at the scope for JS evaluation.
   _evalWindow: null,
   get evalWindow() {
     return this._evalWindow || this.window;
   },
 
   set evalWindow(aWindow) {
-    this._evalWindow = aWindow;
+    // this._evalWindow = aWindow;
 
-    if (!this._progressListenerActive) {
-      events.on(this.parentActor, "will-navigate", this._onWillNavigate);
-      this._progressListenerActive = true;
-    }
+    // if (!this._progressListenerActive) {
+    //   events.on(this.parentActor, "will-navigate", this._onWillNavigate);
+    //   this._progressListenerActive = true;
+    // }
   },
 
   /**
    * Flag used to track if we are listening for events from the progress
    * listener of the tab actor. We use the progress listener to clear
    * this.evalWindow on page navigation.
    *
    * @private
@@ -419,24 +419,24 @@ WebConsoleActor.prototype =
    *        If |true| the object global is determined and added as a debuggee,
    *        otherwise |this.window| is used when makeDebuggeeValue() is invoked.
    * @return object
    *         Debuggee value for |aValue|.
    */
   makeDebuggeeValue: function WCA_makeDebuggeeValue(aValue, aUseObjectGlobal)
   {
     let global = this.window;
-    if (aUseObjectGlobal && typeof aValue == "object") {
-      try {
-        global = Cu.getGlobalForObject(aValue);
-      }
-      catch (ex) {
-        // The above can throw an exception if aValue is not an actual object.
-      }
-    }
+    // if (aUseObjectGlobal && typeof aValue == "object") {
+    //   try {
+    //     global = Cu.getGlobalForObject(aValue);
+    //   }
+    //   catch (ex) {
+    //     // The above can throw an exception if aValue is not an actual object.
+    //   }
+    // }
     let dbgGlobal = this.dbg.makeGlobalObjectReference(global);
     return dbgGlobal.makeDebuggeeValue(aValue);
   },
 
   /**
    * Create a grip for the given object.
    *
    * @param object aObject
diff --git a/devtools/server/worker.js b/devtools/server/worker.js
--- a/devtools/server/worker.js
+++ b/devtools/server/worker.js
@@ -49,17 +49,30 @@ this.addEventListener("message",  functi
       rpcs: []
     };
 
     // Step 4: Create a thread actor for the connection to the parent.
     let pool = new ActorPool(connection);
     connection.addActorPool(pool);
 
     let sources = null;
+    //Object.keys(global).join(", ")
+    try {
+      dump("Going to do some global stuff " + Error().stack + "\n");
+      dump("names? " + Object.getOwnPropertyNames(this.global).join(", ") + "\n");
+      dump("string? " + JSON.stringify(this.global) + "\n");
+      let g = this.global;
+      for (let i in g) {
+    dump(" HI1 " + i + "\n");
 
+      }
+
+  } catch(e) { dump("e" + e + "\n"); }
+dump("Hi  " + Object.keys(this).join(", ") + "----" + Object.keys(this.worker).join(", ") + "\n");
+// dump("Hi  " + global + "\n");
     let parent = {
       makeDebugger: makeDebugger.bind(null, {
         findDebuggees: () => {
           return [this.global];
         },
 
         shouldAddNewGlobalAsDebuggee: () => {
           return true;
@@ -68,20 +81,20 @@ this.addEventListener("message",  functi
 
       get sources() {
         if (sources === null) {
           sources = new TabSources(threadActor);
         }
         return sources;
       },
 
-      window: this
+      window: this.global
     };
 
-    let threadActor = new ThreadActor(parent, this);
+    let threadActor = new ThreadActor(parent, this.global);
     pool.addActor(threadActor);
 
     let consoleActor = new WebConsoleActor(connection, parent);
     pool.addActor(consoleActor);
 
     // Step 5: Send a response packet to the parent to notify
     // it that a connection has been established.
     postMessage(JSON.stringify({
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -677,16 +677,17 @@ WorkerDebuggerGlobalScope::WrapGlobalObj
                                                 GetWorkerPrincipal(), true,
                                                 aReflector);
 }
 
 void
 WorkerDebuggerGlobalScope::GetGlobal(JSContext* aCx,
                                      JS::MutableHandle<JSObject*> aGlobal)
 {
+  printf("Fetching global\n");
   aGlobal.set(mWorkerPrivate->GetOrCreateGlobalScope(aCx)->GetWrapper());
 }
 
 class WorkerDebuggerSandboxPrivate : public nsIGlobalObject,
                                      public nsWrapperCache
 {
 public:
   explicit WorkerDebuggerSandboxPrivate(JSObject *global)
