diff --git a/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js b/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js
--- a/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js
+++ b/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js
@@ -38,8 +38,8 @@
   invokeInTab("strict", 2);
 
   await waitForPaused(dbg);
-  const msg = await evaluate(dbg, "var c = 3");
+  await evaluate(dbg, "var c = 3");
   const msg2 = await evaluate(dbg, "c");
 
-  is(msg2, "3");
+  is(msg2.trim(), "3");
 });
diff --git a/devtools/client/webconsole/components/Message.js b/devtools/client/webconsole/components/Message.js
--- a/devtools/client/webconsole/components/Message.js
+++ b/devtools/client/webconsole/components/Message.js
@@ -324,12 +324,11 @@
           repeat,
           " ", location
         ),
-        // Add a newline for formatting when copying to the clipboard.
-        "\n",
-        // If an attachment is displayed, the final newline is handled by the attachment.
         attachment,
         ...notesNodes
-      )
+      ),
+      // If an attachment is displayed, the final newline is handled by the attachment.
+      attachment ? null : dom.br(),
     );
   }
 }
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js
@@ -5,35 +5,40 @@
 
 "use strict";
 
-const {PrefObserver} = require("devtools/client/shared/prefs");
-
-// RegExp that validates copied text for log lines.
-const LOG_FORMAT_WITH_TIMESTAMP = /^[\d:.]+ .+ (\d+ )?.+:\d+$/;
-const LOG_FORMAT_WITHOUT_TIMESTAMP = /^.+ (\d+ )?.+:\d+$/;
-// RegExp that validates copied text for stacktrace lines.
-const TRACE_FORMAT = /^\t.+ .+:\d+$/;
-
-const PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
+const httpServer = createTestHTTPServer();
+httpServer.registerPathHandler(`/`, function(request, response) {
+  response.setStatusLine(request.httpVersion, 200, "OK");
+  response.write(`
+    <meta charset=utf8>
+    <h1>Test "copy message" context menu entry</h1>
+    <script type="text/javascript" src="test.js"></script>`);
+});
 
-const TEST_URI = `data:text/html;charset=utf-8,<script>
-  window.logStuff = function () {
-    console.log("simple " +  "text message");
-    function wrapper() {
-      console.log(new Error("error object"));
-      console.trace();
-    }
-    wrapper();
-  };
-</script>`;
+httpServer.registerPathHandler("/test.js", function(request, response) {
+  response.setHeader("Content-Type", "application/javascript");
+  response.write(`
+    window.logStuff = function() {
+      console.log("simple text message");
+      function wrapper() {
+        console.log(new Error("error object"));
+        console.trace();
+      }
+      wrapper();
+    };
+  `);
+});
+
+const TEST_URI = `http://localhost:${httpServer.identity.primaryPort}/`;
+
+ // RegExp that validates copied text for log lines.
+const LOG_FORMAT_WITH_TIMESTAMP = /^[\d:.]+ .+/;
+const PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
 
 // Test the Copy menu item of the webconsole copies the expected clipboard text for
 // different log messages.
 
 add_task(async function() {
-  const observer = new PrefObserver("");
-  let onPrefUpdated = observer.once(PREF_MESSAGE_TIMESTAMP, () => {});
-  Services.prefs.setBoolPref(PREF_MESSAGE_TIMESTAMP, true);
-  await onPrefUpdated;
+  await pushPref(PREF_MESSAGE_TIMESTAMP, true);
 
   const hud = await openNewTabAndConsole(TEST_URI);
   hud.ui.clearOutput();
@@ -43,97 +48,110 @@
     content.wrappedJSObject.logStuff();
   });
 
+  info("Test copy menu item with timestamp");
+  await testMessagesCopy(hud, true);
+
+  // Disable timestamp and wait until timestamp are not displayed anymore.
+  await pushPref(PREF_MESSAGE_TIMESTAMP, false);
+  await waitFor(() => hud.ui.outputNode.querySelector(".message .timestamp") === null);
+
+  info("Test copy menu item without timestamp");
+  await testMessagesCopy(hud, false);
+});
+
+async function testMessagesCopy(hud, timestamp) {
+  const newLineString = "\n";
+
   info("Test copy menu item for the simple log");
   let message = await waitFor(() => findMessage(hud, "simple text message"));
   let clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
 
   info("Check copied text for simple log message");
-  let lines = clipboardText.split("\n");
+  let lines = clipboardText.split(newLineString);
   is(lines.length, 2, "There are 2 lines in the copied text");
   is(lines[1], "", "The last line is an empty new line");
-  ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
-    "Log line has the right format:\n" + lines[0]);
+  is(lines[0],
+    `${timestamp ? getTimestampText(message) + " " : ""}simple text message test.js:3:7`,
+    "Line of simple log message has expected text");
+  if (timestamp) {
+    ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
+      "Log line has the right format:\n" + lines[0]);
+  }
 
-  info("Test copy menu item for the stack trace message");
+  info("Test copy menu item for the console.trace message");
   message = await waitFor(() => findMessage(hud, "console.trace"));
   // Wait for the stacktrace to be rendered.
   await waitFor(() => message.querySelector(".frames"));
   clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
 
-  info("Check copied text for stack trace message");
-  lines = clipboardText.split("\n");
+  info("Check copied text for the console.trace message");
+  lines = clipboardText.split(newLineString);
   is(lines.length, 4, "There are 4 lines in the copied text");
-  is(lines[3], "", "The last line is an empty new line");
-  ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
-    "Log line has the right format:\n" + lines[0]);
-  ok(TRACE_FORMAT.test(lines[1]), "Stacktrace line has the right format:\n" + lines[1]);
-  ok(TRACE_FORMAT.test(lines[2]), "Stacktrace line has the right format:\n" + lines[2]);
-
-  info("Test copy menu item without timestamp");
-
-  onPrefUpdated = observer.once(PREF_MESSAGE_TIMESTAMP, () => {});
-  Services.prefs.setBoolPref(PREF_MESSAGE_TIMESTAMP, false);
-  await onPrefUpdated;
-
-  info("Test copy menu item for the simple log");
-  message = await waitFor(() => findMessage(hud, "simple text message"));
-  clipboardText = await copyMessageContent(hud, message);
-  ok(true, "Clipboard text was found and saved");
-
-  info("Check copied text for simple log message");
-  lines = clipboardText.split("\n");
-  is(lines.length, 2, "There are 2 lines in the copied text");
-  is(lines[1], "", "The last line is an empty new line");
-  ok(LOG_FORMAT_WITHOUT_TIMESTAMP.test(lines[0]),
-    "Log line has the right format:\n" + lines[0]);
-
-  info("Test copy menu item for the stack trace message");
-  message = await waitFor(() => findMessage(hud, "console.trace"));
-  clipboardText = await copyMessageContent(hud, message);
-  ok(true, "Clipboard text was found and saved");
-
-  info("Check copied text for stack trace message");
-  lines = clipboardText.split("\n");
-  is(lines.length, 4, "There are 4 lines in the copied text");
-  is(lines[3], "", "The last line is an empty new line");
-  ok(LOG_FORMAT_WITHOUT_TIMESTAMP.test(lines[0]),
-    "Log line has the right format:\n" + lines[0]);
-  ok(TRACE_FORMAT.test(lines[1]), "Stacktrace line has the right format:\n" + lines[1]);
-  ok(TRACE_FORMAT.test(lines[2]), "Stacktrace line has the right format:\n" + lines[2]);
+  is(lines[lines.length - 1], "", "The last line is an empty new line");
+  is(lines[0],
+    `${timestamp ? getTimestampText(message) + " " : ""}console.trace() test.js:6:9`,
+    "Stacktrace first line has the expected text");
+  if (timestamp) {
+    ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
+      "Log line has the right format:\n" + lines[0]);
+  }
+  is(lines[1], `    wrapper ${TEST_URI}test.js:6`,
+    "Stacktrace first line has the expected text");
+  is(lines[2], `    logStuff ${TEST_URI}test.js:8`,
+    "Stacktrace second line has the expected text");
 
   info("Test copy menu item for the error message");
   message = await waitFor(() => findMessage(hud, "Error:"));
+  // Wait for the stacktrace to be rendered.
+  await waitFor(() => message.querySelector(".frames"));
   clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
-  lines = clipboardText.split("\n");
-  is(lines[0], `Error: "error object"`, "Error object first line has expected text");
-  ok(lines[1].startsWith(`\twrapper data:text/html`),
-    "Error stacktrace first line starts with expected value:\n" + lines[1]);
-  ok(lines[2].startsWith(`\tlogStuff data:text/html`),
-    "Error stacktrace second line starts with expected value:\n" + lines[2]);
+  lines = clipboardText.split(newLineString);
+  is(lines[0], `${timestamp ? getTimestampText(message) + " " : ""}Error: "error object"`,
+    "Error object first line has expected text");
+  if (timestamp) {
+    ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
+      "Log line has the right format:\n" + lines[0]);
+  }
+  is(lines[1], `    wrapper ${TEST_URI}test.js:5`,
+    "Error Stacktrace first line has the expected text");
+  is(lines[2], `    logStuff ${TEST_URI}test.js:8`,
+    "Error Stacktrace second line has the expected text");
+}
 
-  observer.destroy();
-  Services.prefs.clearUserPref(PREF_MESSAGE_TIMESTAMP);
-});
+function getTimestampText(messageEl) {
+  return getSelectionTextFromElement(messageEl.querySelector(".timestamp"));
+}
 
 /**
  * Simple helper method to open the context menu on a given message, and click on the copy
  * menu item.
  */
-async function copyMessageContent(hud, message) {
-  const menuPopup = await openContextMenu(hud, message);
+async function copyMessageContent(hud, messageEl) {
+  const menuPopup = await openContextMenu(hud, messageEl);
   const copyMenuItem = menuPopup.querySelector("#console-menu-copy");
   ok(copyMenuItem, "copy menu item is enabled");
 
-  let clipboardText;
-  await waitForClipboardPromise(
-    () => copyMenuItem.click(),
-    data => {
-      clipboardText = data;
-      return data === message.textContent;
-    }
-  );
-  return clipboardText;
+  return waitForClipboardPromise(() => copyMenuItem.click(), data => data);
 }
+
+/**
+ * Return the string representation, as if it was selected with the mouse and copied,
+ * using the Selection API.
+ *
+ * @param {HTMLElement} el
+ * @returns {String} the text representation of the element.
+ */
+function getSelectionTextFromElement(el) {
+  const doc = el.ownerDocument;
+  const win = doc.defaultView;
+  const range = doc.createRange();
+  range.selectNode(el);
+  const selection = win.getSelection();
+  selection.addRange(range);
+  const selectionText = selection.toString();
+  selection.removeRange(range);
+  return selectionText;
+}
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js
@@ -5,13 +5,36 @@
 
 "use strict";
 
-const TEST_URI =
-`data:text/html;charset=utf-8,` +
-`<script>window.logStuff = function () {console.log("hello");};</script>`;
-const TEST_DATA = {
-  msg: "simple text message",
-  msg2: "second message test",
-};
+const httpServer = createTestHTTPServer();
+httpServer.registerPathHandler(`/`, function(request, response) {
+  response.setStatusLine(request.httpVersion, 200, "OK");
+  response.write(`
+    <html>
+      <head>
+        <meta charset="utf-8">
+        <script type="text/javascript" src="test.js"></script>
+      </head>
+      <body>Test "Export All" context menu entry</body>
+    </html>`);
+});
+
+httpServer.registerPathHandler("/test.js", function(request, response) {
+  response.setHeader("Content-Type", "application/javascript");
+  response.write(`
+    window.logStuff = function() {
+      function wrapper() {
+        console.log("hello");
+        console.log("myObject:", {a: 1}, "myArray:", ["b", "c"]);
+        console.log(new Error("error object"));
+        console.trace("myConsoleTrace");
+        console.info("world", "!");
+      }
+      wrapper();
+    };
+  `);
+});
+
+const TEST_URI = `http://localhost:${httpServer.identity.primaryPort}/`;
 
 // Test the export visible messages to clipboard of the webconsole copies the expected
 // clipboard text for different log messages to find if everything is copied to clipboard.
@@ -21,31 +44,70 @@
   hud.ui.clearOutput();
 
   info("Call the log function defined in the test page");
-  await ContentTask.spawn(gBrowser.selectedBrowser, TEST_DATA, function(testData) {
-    content.wrappedJSObject.console.log(testData.msg);
-    content.wrappedJSObject.console.log(testData.msg2);
-    content.wrappedJSObject.console.log("object:", {a: 1},
-                                        "array:", ["b", "c"]);
+  await ContentTask.spawn(gBrowser.selectedBrowser, null, function() {
     content.wrappedJSObject.logStuff();
   });
 
   info("Test export to clipboard ");
-  await waitFor(() => findMessages(hud, "").length === 4);
-  const message = findMessage(hud, TEST_DATA.msg);
+  // Let's wait until we have all the logged messages.
+  await waitFor(() => findMessages(hud, "").length === 5);
+  // And also until the stacktraces are rendered (there should be 2)
+  await waitFor(() => hud.ui.outputNode.querySelectorAll(".frames").length === 2);
+
+  const message = findMessage(hud, "hello");
   const clipboardText = await exportAllToClipboard(hud, message);
   ok(true, "Clipboard text was found and saved");
 
-  const clipboardLines = clipboardText.split("\n");
+// Here we should have:
+//   -------------------------------------------------------------------
+//   hello test.js:4:9
+//   -------------------------------------------------------------------
+//   myObject:
+//   Object { a: 1 }
+//    myArray:
+//   Array [ "b", "c"]
+//   test.js:5:9
+//   -------------------------------------------------------------------
+//   Error: "error object":
+//       wrapper test.js:5
+//       logStuff test.js:9
+//   test.js:6:9
+//   -------------------------------------------------------------------
+//   console.trace() myConsoleTrace test.js:7:9
+//       wrapper test.js:7
+//       logStuff test.js:9
+//   -------------------------------------------------------------------
+//   world ! test.js:8:9
+//   -------------------------------------------------------------------
+
   info("Check if all messages where copied to clipboard");
-  is(clipboardLines[0].trim(), TEST_DATA.msg,
-    "found first text message in clipboard");
-  is(clipboardLines[1].trim(), TEST_DATA.msg2,
-    "found second text message in clipboard");
-  is(clipboardLines[2].trim(), 'object: Object { a: 1 } array: Array [ "b", "c" ]',
-    "found object and array in clipboard");
-  const CLEAN_URI = TEST_URI.replace("text/html;charset=utf-8,", "");
-  is(clipboardLines[3].trim(), `hello ${CLEAN_URI}:1:32`,
-    "found text from data uri");
+  const clipboardLines = clipboardText.split("\n");
+  is(clipboardLines.length, 15, "There's 15 lines of text");
+  is(clipboardLines[clipboardLines.length - 1], "", "Last line is empty");
+
+  info("Check simple text message");
+  is(clipboardLines[0], "hello test.js:4:9", "Simple log has expected text");
+
+  info("Check multiple logged items message");
+  is(clipboardLines[1], `myObject: `);
+  is(clipboardLines[2], `Object { a: 1 }`);
+  is(clipboardLines[3], ` myArray: `);
+  is(clipboardLines[4], `Array [ "b", "c" ]`);
+  is(clipboardLines[5], `test.js:5:9`);
+
+  info("Check logged error object");
+  is(clipboardLines[6], `Error: "error object"`);
+  is(clipboardLines[7], `    wrapper ${TEST_URI}test.js:6`);
+  is(clipboardLines[8], `    logStuff ${TEST_URI}test.js:10`);
+  is(clipboardLines[9], `test.js:6:9`);
+
+  info("Check console.trace message");
+  is(clipboardLines[10], `console.trace() myConsoleTrace test.js:7:9`);
+  is(clipboardLines[11], `    wrapper ${TEST_URI}test.js:7`);
+  is(clipboardLines[12], `    logStuff ${TEST_URI}test.js:10`);
+
+  info("Check console.info message");
+  is(clipboardLines[13], `world ! test.js:8:9`);
 });
 
 /**
diff --git a/devtools/client/webconsole/utils/clipboard.js b/devtools/client/webconsole/utils/clipboard.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/utils/clipboard.js
@@ -0,0 +1,49 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ *
+ * @param {HTMLElement} el: The element we want the text of.
+ * @returns {String|null} The text of the element, as provided by the Selection API (or
+ *                        el.textContent if we don't have a window reference), or null if
+ *                        el is falsy.
+ */
+function getElementText(el) {
+  if (!el) {
+    return null;
+  }
+  // If we can, we use the Selection API to match what the user would get if they
+  // manually select and copy the message.
+  const doc = el.ownerDocument;
+  const win = doc && doc.defaultView;
+
+  if (!win) {
+    return el.textContent;
+  }
+
+  // We store the current selected range and unselect everything.
+  const selection = win.getSelection();
+  const currentSelectedRange = !selection.isCollapsed && selection.getRangeAt(0);
+  selection.removeAllRanges();
+
+  // Then creates a range from `el`, and get the text content.
+  const range = doc.createRange();
+  range.selectNode(el);
+  selection.addRange(range);
+  const text = selection.toString();
+
+  // Finally we revert the selection to what it was.
+  selection.removeRange(range);
+  if (currentSelectedRange) {
+    selection.addRange(currentSelectedRange);
+  }
+
+  return text;
+}
+
+module.exports = {
+  getElementText,
+};
diff --git a/devtools/client/webconsole/utils/context-menu.js b/devtools/client/webconsole/utils/context-menu.js
--- a/devtools/client/webconsole/utils/context-menu.js
+++ b/devtools/client/webconsole/utils/context-menu.js
@@ -15,6 +15,7 @@
 const { l10n } = require("devtools/client/webconsole/utils/messages");
 
 loader.lazyRequireGetter(this, "openContentLink", "devtools/client/shared/link", true);
+loader.lazyRequireGetter(this, "getElementText", "devtools/client/webconsole/utils/clipboard", true);
 
 /**
  * Create a Menu instance for the webconsole.
@@ -177,7 +178,7 @@
     disabled: false,
     click: () => {
       const webconsoleOutput = parentNode.querySelector(".webconsole-output");
-      clipboardHelper.copyString(webconsoleOutput.textContent);
+      clipboardHelper.copyString(getElementText(webconsoleOutput));
     },
   }));
 
diff --git a/devtools/client/webconsole/utils/moz.build b/devtools/client/webconsole/utils/moz.build
--- a/devtools/client/webconsole/utils/moz.build
+++ b/devtools/client/webconsole/utils/moz.build
@@ -4,6 +4,7 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DevToolsModules(
+    'clipboard.js',
     'context-menu.js',
     'id-generator.js',
     'messages.js',
diff --git a/devtools/client/webconsole/webconsole-output-wrapper.js b/devtools/client/webconsole/webconsole-output-wrapper.js
--- a/devtools/client/webconsole/webconsole-output-wrapper.js
+++ b/devtools/client/webconsole/webconsole-output-wrapper.js
@@ -23,6 +23,7 @@
 const ObjectClient = require("devtools/shared/client/object-client");
 const LongStringClient = require("devtools/shared/client/long-string-client");
 loader.lazyRequireGetter(this, "Constants", "devtools/client/webconsole/constants");
+loader.lazyRequireGetter(this, "getElementText", "devtools/client/webconsole/utils/clipboard", true);
 
 let store = null;
 
@@ -172,7 +173,7 @@
         const { screenX, screenY, target } = e;
 
         const messageEl = target.closest(".message");
-        const clipboardText = messageEl ? messageEl.textContent : null;
+        const clipboardText = getElementText(messageEl);
 
         const messageVariable = target.closest(".objectBox");
         // Ensure that console.group and console.groupCollapsed commands are not captured

