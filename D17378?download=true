# HG changeset patch
# Parent  4cf11457c07d0a48dc6f53699e9845022e8eb49f

diff --git a/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js b/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js
--- a/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js
+++ b/devtools/client/debugger/new/test/mochitest/browser_dbg-console-map-bindings.js
@@ -33,13 +33,13 @@ add_task(async function() {
   const dbg = await initDebugger("doc-strict.html");
 
   await getSplitConsole(dbg);
   ok(dbg.toolbox.splitConsole, "Split console is shown.");
 
   invokeInTab("strict", 2);
 
   await waitForPaused(dbg);
-  const msg = await evaluate(dbg, "var c = 3");
+  await evaluate(dbg, "var c = 3");
   const msg2 = await evaluate(dbg, "c");
 
-  is(msg2, "3");
+  is(msg2.trim(), "3");
 });
diff --git a/devtools/client/webconsole/components/Message.js b/devtools/client/webconsole/components/Message.js
--- a/devtools/client/webconsole/components/Message.js
+++ b/devtools/client/webconsole/components/Message.js
@@ -319,19 +319,18 @@ class Message extends Component {
           dom.span({ className: "message-body devtools-monospace" },
             ...bodyElements,
             learnMore
           ),
           repeat ? " " : null,
           repeat,
           " ", location
         ),
-        // Add a newline for formatting when copying to the clipboard.
-        "\n",
-        // If an attachment is displayed, the final newline is handled by the attachment.
         attachment,
         ...notesNodes
-      )
+      ),
+      // If an attachment is displayed, the final newline is handled by the attachment.
+      attachment ? null : dom.br(),
     );
   }
 }
 
 module.exports = Message;
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_copy_entire_message.js
@@ -1,44 +1,50 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-const {PrefObserver} = require("devtools/client/shared/prefs");
+const httpServer = createTestHTTPServer();
+httpServer.registerPathHandler(`/`, function(request, response) {
+  response.setStatusLine(request.httpVersion, 200, "OK");
+  response.write(`
+    <h1>Test "copy message" context menu entry</h1>
+    <script type="text/javascript" src="test.js"></script>`);
+});
+
+httpServer.registerPathHandler("/test.js", function(request, response) {
+  response.setHeader("Content-Type", "application/javascript");
+  response.write(`
+    window.logStuff = function() {
+      console.log("simple text message");
+      function wrapper() {
+        console.log(new Error("error object"));
+        console.trace();
+      }
+      wrapper();
+    };
+  `);
+});
+
+const TEST_URI = `http://localhost:${httpServer.identity.primaryPort}/`;
 
 // RegExp that validates copied text for log lines.
 const LOG_FORMAT_WITH_TIMESTAMP = /^[\d:.]+ .+ (\d+ )?.+:\d+$/;
 const LOG_FORMAT_WITHOUT_TIMESTAMP = /^.+ (\d+ )?.+:\d+$/;
-// RegExp that validates copied text for stacktrace lines.
-const TRACE_FORMAT = /^\t.+ .+:\d+$/;
 
 const PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
 
-const TEST_URI = `data:text/html;charset=utf-8,<script>
-  window.logStuff = function () {
-    console.log("simple " +  "text message");
-    function wrapper() {
-      console.log(new Error("error object"));
-      console.trace();
-    }
-    wrapper();
-  };
-</script>`;
-
 // Test the Copy menu item of the webconsole copies the expected clipboard text for
 // different log messages.
 
 add_task(async function() {
-  const observer = new PrefObserver("");
-  let onPrefUpdated = observer.once(PREF_MESSAGE_TIMESTAMP, () => {});
-  Services.prefs.setBoolPref(PREF_MESSAGE_TIMESTAMP, true);
-  await onPrefUpdated;
+  await pushPref(PREF_MESSAGE_TIMESTAMP, true);
 
   const hud = await openNewTabAndConsole(TEST_URI);
   hud.ui.clearOutput();
 
   info("Call the log function defined in the test page");
   await ContentTask.spawn(gBrowser.selectedBrowser, null, () => {
     content.wrappedJSObject.logStuff();
   });
@@ -50,90 +56,110 @@ add_task(async function() {
 
   info("Check copied text for simple log message");
   let lines = clipboardText.split("\n");
   is(lines.length, 2, "There are 2 lines in the copied text");
   is(lines[1], "", "The last line is an empty new line");
   ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
     "Log line has the right format:\n" + lines[0]);
 
-  info("Test copy menu item for the stack trace message");
+  info("Test copy menu item for the console.trace message");
   message = await waitFor(() => findMessage(hud, "console.trace"));
   // Wait for the stacktrace to be rendered.
   await waitFor(() => message.querySelector(".frames"));
   clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
 
-  info("Check copied text for stack trace message");
+  info("Check copied text for the console.trace message");
   lines = clipboardText.split("\n");
   is(lines.length, 4, "There are 4 lines in the copied text");
-  is(lines[3], "", "The last line is an empty new line");
+  is(lines[lines.length - 1], "", "The last line is an empty new line");
   ok(LOG_FORMAT_WITH_TIMESTAMP.test(lines[0]),
     "Log line has the right format:\n" + lines[0]);
-  ok(TRACE_FORMAT.test(lines[1]), "Stacktrace line has the right format:\n" + lines[1]);
-  ok(TRACE_FORMAT.test(lines[2]), "Stacktrace line has the right format:\n" + lines[2]);
+  is(lines[1], `    wrapper ${TEST_URI}test.js:6`,
+    "Stacktrace first line has the expected text");
+  is(lines[2], `    logStuff ${TEST_URI}test.js:8`,
+    "Stacktrace first line has the expected text");
 
   info("Test copy menu item without timestamp");
 
-  onPrefUpdated = observer.once(PREF_MESSAGE_TIMESTAMP, () => {});
-  Services.prefs.setBoolPref(PREF_MESSAGE_TIMESTAMP, false);
-  await onPrefUpdated;
+  // Disable timestamp and wait until timestamp are not displayed anymore.
+  await pushPref(PREF_MESSAGE_TIMESTAMP, false);
+  await waitFor(() => hud.ui.outputNode.querySelector(".message .timestamp") === null);
 
   info("Test copy menu item for the simple log");
   message = await waitFor(() => findMessage(hud, "simple text message"));
   clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
 
   info("Check copied text for simple log message");
   lines = clipboardText.split("\n");
   is(lines.length, 2, "There are 2 lines in the copied text");
   is(lines[1], "", "The last line is an empty new line");
   ok(LOG_FORMAT_WITHOUT_TIMESTAMP.test(lines[0]),
     "Log line has the right format:\n" + lines[0]);
 
-  info("Test copy menu item for the stack trace message");
+  info("Test copy menu item for the console.trace message");
   message = await waitFor(() => findMessage(hud, "console.trace"));
   clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
 
-  info("Check copied text for stack trace message");
+  info("Check copied text for the console.trace message");
   lines = clipboardText.split("\n");
   is(lines.length, 4, "There are 4 lines in the copied text");
-  is(lines[3], "", "The last line is an empty new line");
+  is(lines[lines.length - 1], "", "The last line is an empty new line");
   ok(LOG_FORMAT_WITHOUT_TIMESTAMP.test(lines[0]),
     "Log line has the right format:\n" + lines[0]);
-  ok(TRACE_FORMAT.test(lines[1]), "Stacktrace line has the right format:\n" + lines[1]);
-  ok(TRACE_FORMAT.test(lines[2]), "Stacktrace line has the right format:\n" + lines[2]);
+  is(lines[1], `    wrapper ${TEST_URI}test.js:6`,
+    "Stacktrace first line has the expected text");
+  is(lines[2], `    logStuff ${TEST_URI}test.js:8`,
+    "Stacktrace first line has the expected text");
 
   info("Test copy menu item for the error message");
   message = await waitFor(() => findMessage(hud, "Error:"));
   clipboardText = await copyMessageContent(hud, message);
   ok(true, "Clipboard text was found and saved");
   lines = clipboardText.split("\n");
   is(lines[0], `Error: "error object"`, "Error object first line has expected text");
-  ok(lines[1].startsWith(`\twrapper data:text/html`),
-    "Error stacktrace first line starts with expected value:\n" + lines[1]);
-  ok(lines[2].startsWith(`\tlogStuff data:text/html`),
-    "Error stacktrace second line starts with expected value:\n" + lines[2]);
-
-  observer.destroy();
-  Services.prefs.clearUserPref(PREF_MESSAGE_TIMESTAMP);
+  is(lines[1], `    wrapper ${TEST_URI}test.js:5`,
+    "Error Stacktrace first line has the expected text");
+  is(lines[2], `    logStuff ${TEST_URI}test.js:8`,
+    "Error Stacktrace first line has the expected text");
 });
 
 /**
  * Simple helper method to open the context menu on a given message, and click on the copy
  * menu item.
  */
 async function copyMessageContent(hud, message) {
   const menuPopup = await openContextMenu(hud, message);
   const copyMenuItem = menuPopup.querySelector("#console-menu-copy");
   ok(copyMenuItem, "copy menu item is enabled");
 
   let clipboardText;
   await waitForClipboardPromise(
     () => copyMenuItem.click(),
     data => {
       clipboardText = data;
-      return data === message.textContent;
+      return data === getSelectionTextFromElement(message);
     }
   );
   return clipboardText;
 }
+
+/**
+ * Return the string representation, as if it was selected with the mouse and copied,
+ * using the Selection API.
+ *
+ * @param {HTMLElement} el
+ * @returns {String} the text representation of the element.
+ */
+function getSelectionTextFromElement(el) {
+  const doc = el.ownerDocument;
+  const win = doc.defaultView;
+  const range = doc.createRange();
+  range.selectNode(el);
+  const selection = win.getSelection();
+  selection.addRange(range);
+  const selectionText = selection.toString();
+  selection.removeRange(range);
+  return selectionText;
+}
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_context_menu_export_console_output_clipboard.js
@@ -1,56 +1,120 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-const TEST_URI =
-`data:text/html;charset=utf-8,` +
-`<script>window.logStuff = function () {console.log("hello");};</script>`;
-const TEST_DATA = {
-  msg: "simple text message",
-  msg2: "second message test",
-};
+const httpServer = createTestHTTPServer();
+httpServer.registerPathHandler(`/`, function(request, response) {
+  response.setStatusLine(request.httpVersion, 200, "OK");
+  response.write(`
+    <html>
+      <head>
+        <meta charset="utf-8">
+        <script type="text/javascript" src="test.js"></script>
+      </head>
+      <body>Test "Export All" context menu entry</body>
+    </html>`);
+});
+
+httpServer.registerPathHandler("/test.js", function(request, response) {
+  response.setHeader("Content-Type", "application/javascript");
+  response.write(`
+    window.logStuff = function() {
+      function wrapper() {
+        console.log("hello");
+        console.log("myObject:", {a: 1}, "myArray:", ["b", "c"]);
+        console.log(new Error("error object"));
+        console.trace("myConsoleTrace");
+        console.info("world", "!");
+      }
+      wrapper();
+    };
+  `);
+});
+
+const TEST_URI = `http://localhost:${httpServer.identity.primaryPort}/`;
 
 // Test the export visible messages to clipboard of the webconsole copies the expected
 // clipboard text for different log messages to find if everything is copied to clipboard.
 
 add_task(async function() {
   const hud = await openNewTabAndConsole(TEST_URI);
   hud.ui.clearOutput();
 
   info("Call the log function defined in the test page");
-  await ContentTask.spawn(gBrowser.selectedBrowser, TEST_DATA, function(testData) {
-    content.wrappedJSObject.console.log(testData.msg);
-    content.wrappedJSObject.console.log(testData.msg2);
-    content.wrappedJSObject.console.log("object:", {a: 1},
-                                        "array:", ["b", "c"]);
+  await ContentTask.spawn(gBrowser.selectedBrowser, null, function(testData) {
     content.wrappedJSObject.logStuff();
   });
 
   info("Test export to clipboard ");
-  await waitFor(() => findMessages(hud, "").length === 4);
-  const message = findMessage(hud, TEST_DATA.msg);
+  // Let's wait until we have all the logged messages.
+  await waitFor(() => findMessages(hud, "").length === 5);
+  // And also until the stacktraces are rendered (there should be 2)
+  await waitFor(() => hud.ui.outputNode.querySelectorAll(".frames").length === 2);
+
+  const message = findMessage(hud, "hello");
   const clipboardText = await exportAllToClipboard(hud, message);
   ok(true, "Clipboard text was found and saved");
 
-  const clipboardLines = clipboardText.split("\n");
+  await new Promise(r=>r);
+
+// Here we should have:
+//   -------------------------------------------------------------------
+//   hello test.js:4:9
+//   -------------------------------------------------------------------
+//   myObject:
+//   Object { a: 1 }
+//    myArray:
+//   Array [ "b", "c"]
+//   test.js:5:9
+//   -------------------------------------------------------------------
+//   Error: "error object":
+//       wrapper test.js:5
+//       logStuff test.js:9
+//   test.js:6:9
+//   -------------------------------------------------------------------
+//   console.trace() myConsoleTrace test.js:7:9
+//       wrapper test.js:7
+//       logStuff test.js:9
+//   -------------------------------------------------------------------
+//   world ! test.js:8:9
+//   -------------------------------------------------------------------
+
   info("Check if all messages where copied to clipboard");
-  is(clipboardLines[0].trim(), TEST_DATA.msg,
-    "found first text message in clipboard");
-  is(clipboardLines[1].trim(), TEST_DATA.msg2,
-    "found second text message in clipboard");
-  is(clipboardLines[2].trim(), 'object: Object { a: 1 } array: Array [ "b", "c" ]',
-    "found object and array in clipboard");
-  const CLEAN_URI = TEST_URI.replace("text/html;charset=utf-8,", "");
-  is(clipboardLines[3].trim(), `hello ${CLEAN_URI}:1:32`,
-    "found text from data uri");
+  const clipboardLines = clipboardText.split("\n");
+  is(clipboardLines.length, 15, "There's 15 lines of text");
+  is(clipboardLines[clipboardLines.length - 1], "", "Last line is empty");
+
+  info("Check simple text message");
+  is(clipboardLines[0], "hello test.js:4:9", "Simple log has expected text");
+
+  info("Check multiple logged items message");
+  is(clipboardLines[1], `myObject: `);
+  is(clipboardLines[2], `Object { a: 1 }`);
+  is(clipboardLines[3], ` myArray: `);
+  is(clipboardLines[4], `Array [ "b", "c" ]`);
+  is(clipboardLines[5], `test.js:5:9`);
+
+  info("Check logged error object");
+  is(clipboardLines[6], `Error: "error object"`);
+  is(clipboardLines[7], `    wrapper ${TEST_URI}test.js:6`);
+  is(clipboardLines[8], `    logStuff ${TEST_URI}test.js:10`);
+  is(clipboardLines[9], `test.js:6:9`);
+
+  info("Check console.trace message");
+  is(clipboardLines[10], `console.trace() myConsoleTrace test.js:7:9`);
+  is(clipboardLines[11], `    wrapper ${TEST_URI}test.js:7`);
+  is(clipboardLines[12], `    logStuff ${TEST_URI}test.js:10`);
+
+  info("Check console.info message");
+  is(clipboardLines[13], `world ! test.js:8:9`);
 });
 
 /**
  * Simple helper method to open the context menu on a given message, and click on the
  * export visible messages to clipboard.
  */
 async function exportAllToClipboard(hud, message) {
   const menuPopup = await openContextMenu(hud, message);
diff --git a/devtools/client/webconsole/utils/clipboard.js b/devtools/client/webconsole/utils/clipboard.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/utils/clipboard.js
@@ -0,0 +1,39 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ *
+ * @param {HTMLElement} el: The element we want the text of.
+ * @returns {String|null} The text of the element, as provided by the Selection API (or
+ *                        el.textContent if we don't have a window reference), or null if
+ *                        el is falsy.
+ */
+function getElementText(el) {
+  if (!el) {
+    return null;
+  }
+  // If we can, we use the Selection API to match what the user would get if they
+  // manually select and copy the message.
+  const doc = el.ownerDocument;
+  const win = doc && doc.defaultView;
+
+  if (!win) {
+    return el.textContent;
+  }
+
+  const range = doc.createRange();
+  range.selectNode(el);
+  const selection = win.getSelection();
+  selection.addRange(range);
+  const text = selection.toString();
+  selection.removeRange(range);
+
+  return text;
+}
+
+module.exports = {
+  getElementText,
+};
diff --git a/devtools/client/webconsole/utils/context-menu.js b/devtools/client/webconsole/utils/context-menu.js
--- a/devtools/client/webconsole/utils/context-menu.js
+++ b/devtools/client/webconsole/utils/context-menu.js
@@ -10,16 +10,17 @@ const Menu = require("devtools/client/fr
 const MenuItem = require("devtools/client/framework/menu-item");
 
 const { MESSAGE_SOURCE } = require("devtools/client/webconsole/constants");
 
 const clipboardHelper = require("devtools/shared/platform/clipboard");
 const { l10n } = require("devtools/client/webconsole/utils/messages");
 
 loader.lazyRequireGetter(this, "openContentLink", "devtools/client/shared/link", true);
+loader.lazyRequireGetter(this, "getElementText", "devtools/client/webconsole/utils/clipboard", true);
 
 /**
  * Create a Menu instance for the webconsole.
  *
  * @param {Object} hud
  *        The webConsoleFrame.
  * @param {Element} parentNode
  *        The container of the new console frontend output wrapper.
@@ -172,17 +173,17 @@ function createContextMenu(hud, parentNo
 
   // Export to clipboard
   menu.append(new MenuItem({
     id: "console-menu-export-clipboard",
     label: l10n.getStr("webconsole.menu.exportClipboard.label"),
     disabled: false,
     click: () => {
       const webconsoleOutput = parentNode.querySelector(".webconsole-output");
-      clipboardHelper.copyString(webconsoleOutput.textContent);
+      clipboardHelper.copyString(getElementText(webconsoleOutput));
     },
   }));
 
   // Open object in sidebar.
   if (openSidebar) {
     menu.append(new MenuItem({
       id: "console-menu-open-sidebar",
       label: l10n.getStr("webconsole.menu.openInSidebar.label"),
diff --git a/devtools/client/webconsole/utils/moz.build b/devtools/client/webconsole/utils/moz.build
--- a/devtools/client/webconsole/utils/moz.build
+++ b/devtools/client/webconsole/utils/moz.build
@@ -1,12 +1,13 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DevToolsModules(
+    'clipboard.js',
     'context-menu.js',
     'id-generator.js',
     'messages.js',
     'object-inspector.js',
     'prefs.js',
 )
diff --git a/devtools/client/webconsole/webconsole-output-wrapper.js b/devtools/client/webconsole/webconsole-output-wrapper.js
--- a/devtools/client/webconsole/webconsole-output-wrapper.js
+++ b/devtools/client/webconsole/webconsole-output-wrapper.js
@@ -18,16 +18,17 @@ const { isPacketPrivate } = require("dev
 const { getAllMessagesById, getMessage } = require("devtools/client/webconsole/selectors/messages");
 const Telemetry = require("devtools/client/shared/telemetry");
 
 const EventEmitter = require("devtools/shared/event-emitter");
 const App = createFactory(require("devtools/client/webconsole/components/App"));
 const ObjectClient = require("devtools/shared/client/object-client");
 const LongStringClient = require("devtools/shared/client/long-string-client");
 loader.lazyRequireGetter(this, "Constants", "devtools/client/webconsole/constants");
+loader.lazyRequireGetter(this, "getElementText", "devtools/client/webconsole/utils/clipboard", true);
 
 let store = null;
 
 function WebConsoleOutputWrapper(parentNode, hud, toolbox, owner, document) {
   EventEmitter.decorate(this);
 
   this.parentNode = parentNode;
   this.hud = hud;
@@ -167,17 +168,17 @@ WebConsoleOutputWrapper.prototype = {
 
       // Set `openContextMenu` this way so, `serviceContainer` variable
       // is available in the current scope and we can pass it into
       // `createContextMenu` method.
       serviceContainer.openContextMenu = (e, message) => {
         const { screenX, screenY, target } = e;
 
         const messageEl = target.closest(".message");
-        const clipboardText = messageEl ? messageEl.textContent : null;
+        const clipboardText = getElementText(messageEl);
 
         const messageVariable = target.closest(".objectBox");
         // Ensure that console.group and console.groupCollapsed commands are not captured
         const variableText = (messageVariable
           && !(messageEl.classList.contains("startGroup"))
           && !(messageEl.classList.contains("startGroupCollapsed")))
             ? messageVariable.textContent : null;
 
