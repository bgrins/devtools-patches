# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  895e1f5cc6170e8bf4497a533aaed00d37797aa0
https://bugzilla.mozilla.org/show_bug.cgi?id=1420229

diff --git a/testing/mochitest/browser-test.js b/testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js
+++ b/testing/mochitest/browser-test.js
@@ -57,17 +57,28 @@ var TabDestroyObserver = {
     }
 
     return new Promise((resolve) => {
       this.promiseResolver = resolve;
     });
   },
 };
 
-function testInit() {
+async function testInit() {
+
+  // var testSuite = Cc["@mozilla.org/process/environment;1"].
+  //                   getService(Ci.nsIEnvironment).
+  //                   get("TEST_SUITE");
+  // if (testSuite == "browser-chrome-instrumentation") {
+  //   await takeInstrumentation();
+  // }
+
+  await takeInstrumentation();
+
+
   gConfig = readConfig();
   if (gConfig.testRoot == "browser") {
     // Make sure to launch the test harness for the first opened window only
     var prefs = Services.prefs;
     if (prefs.prefHasUserValue("testing.browserTestHarness.running"))
       return;
 
     prefs.setBoolPref("testing.browserTestHarness.running", true);
@@ -113,26 +124,55 @@ function testInit() {
     globalMM.loadFrameScript("chrome://mochikit/content/shutdown-leaks-collector.js", true);
   } else {
     // In non-e10s, only run the ShutdownLeaksCollector in the parent process.
     Components.utils.import("chrome://mochikit/content/ShutdownLeaksCollector.jsm");
   }
 
   let gmm = Cc["@mozilla.org/globalmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
   gmm.loadFrameScript("chrome://mochikit/content/tests/SimpleTest/AsyncUtilsContent.js", true);
-
-  var testSuite = Cc["@mozilla.org/process/environment;1"].
-                    getService(Ci.nsIEnvironment).
-                    get("TEST_SUITE");
-  if (testSuite == "browser-chrome-instrumentation") {
-    takeInstrumentation();
-  }
 }
 
-function takeInstrumentation() {
+async function takeInstrumentation() {
+
+
+
+  dump("takeInstrumentation started 2 \n")
+
+  // Create a server, connect to it and fetch tab actors for the parent process;
+  // pass |callback| the debugger client and tab actor form with all actor IDs.
+  function get_chrome_actors(callback) {
+
+    const { require, loader } = Cu.import("resource://devtools/shared/Loader.jsm", {});
+    const { DebuggerServer } = require("devtools/server/main");
+    const { DebuggerClient } = require("devtools/shared/client/debugger-client");
+    const { InspectorFront } = require("devtools/shared/fronts/inspector");
+
+    DebuggerServer.init();
+    DebuggerServer.registerAllActors();
+    DebuggerServer.allowChromeProcess = true;
+
+    let client = new DebuggerClient(DebuggerServer.connectPipe());
+    client.connect()
+      .then(() => client.getProcess())
+      .then(response => {
+        let inspector = InspectorFront(client, response.form);
+        let showAllAnonymousContent = true;
+        let walker = inspector.getWalker({ showAllAnonymousContent }).then(() => {
+          callback(client, response.form, walker);
+        });
+      });
+  }
+
+  await new Promise(resolve => {
+    get_chrome_actors((client, form, walker) => {
+      dump("Got chrome actor for client! " + form + "\n");
+      resolve();
+    });
+  });
 
   let instrumentData = {
     elements: {}
   };
 
   function pad(str, length) {
     if (str.length >= length)
       return str;
@@ -205,16 +245,18 @@ function takeInstrumentation() {
 
   // Saves instrumantation data
   function saveData() {
     let path = Cc["@mozilla.org/process/environment;1"].
                getService(Ci.nsIEnvironment).
                get("MOZ_UPLOAD_DIR");
     let encoder = new TextEncoder();
 
+    // dump("BRIAN " + JSON.stringify(instrumentData, null, 2));
+
     let instrumentPath = OS.Path.join(path, "xulinstrument.txt");
     OS.File.writeAtomic(instrumentPath, encoder.encode(JSON.stringify(instrumentData, null, 2)));
 
     let summaryPath = OS.Path.join(path, "xulsummary.txt");
     OS.File.writeAtomic(summaryPath, encoder.encode(getSummaryText()));
   }
 
   // An iterator over an element and its ancestors
@@ -304,16 +346,127 @@ function takeInstrumentation() {
 
     let selector = elementSelector(element);
     element.__instrumentSeen = true;
 
     if (selector in instrumentData.elements) {
       return;
     }
 
+
+    // function getMatchedSelectors (node, property, options) {
+    //   this.cssLogic.sourceFilter = options.filter || SharedCssLogic.FILTER.UA;
+    //   this.cssLogic.highlight(node.rawNode);
+
+    //   let rules = new Set();
+    //   let sheets = new Set();
+
+    //   let matched = [];
+    //   let propInfo = this.cssLogic.getPropertyInfo(property);
+    //   for (let selectorInfo of propInfo.matchedSelectors) {
+    //     let cssRule = selectorInfo.selector.cssRule;
+    //     let domRule = cssRule.sourceElement || cssRule.domRule;
+
+    //     let rule = this._styleRef(domRule);
+    //     rules.add(rule);
+
+    //     matched.push({
+    //       rule: rule,
+    //       sourceText: this.getSelectorSource(selectorInfo, node.rawNode),
+    //       selector: selectorInfo.selector.text,
+    //       name: selectorInfo.property,
+    //       value: selectorInfo.value,
+    //       status: selectorInfo.status
+    //     });
+    //   }
+
+    //   this.expandSets(rules, sheets);
+
+    //   return {
+    //     matched: matched,
+    //     rules: [...rules],
+    //     sheets: [...sheets]
+    //   };
+    // }
+
+
+
+
+    const DOMUtils = Cc["@mozilla.org/inspector/dom-utils;1"]
+            .getService(Ci.inIDOMUtils);
+    function getSelectors(node) {
+      let rules = DOMUtils.getCSSStyleRules(node, null);
+      var selectors = [];
+      for (var i = 0; i < rules.Count(); i++) {
+        var rule = rules.GetElementAt(i).QueryInterface(Ci.nsIDOMCSSStyleRule);
+      dump("BRIAN " + rule.selectorText + " " + i + " " +  rules.Count()+ "\n");
+        selectors.push(rule.selectorText);
+
+        rule.selectors.forEach(function (selector, i) {
+          dump("HERE!!!!!!!! \n" + selector + "\n");
+        });
+        //   if (selector._matchId !== this._matchId &&
+        //      (selector.elementStyle ||
+        //       DOMUtils.selectorMatchesElement(rule,
+        //                                   selector.selectorIndex))) {
+        //     selector._matchId = this._matchId;
+        //     this._matchedSelectors.push([ selector, status ]);
+        //     if (callback) {
+        //       callback.call(scope, selector, status);
+        //     }
+        //   }
+        // }, this);
+
+
+      }
+      return selectors;
+    }
+
+    if (selector === "#main-window > #tab-view-deck > #browser-panel > #navigator-toolbox > #nav-bar > #nav-bar-customization-target > #bookmarks-menu-button > #BMB_bookmarksPopup > menuitem.menuitem-iconic.bookmark-item.menuitem-with-favicon.subviewbutton[label=\"Test1\"]") {
+      // let rules = getSelectors(element);
+
+      // dump(JSON.stringify(rules) + "\n");
+
+      // DOMUtils.getCSSStyleRules(node, null);
+      // getCSSStyleRules returns ordered from least-specific to
+      // most-specific.
+      // for (let i = domRules.Count() - 1; i >= 0; i--) {
+      //   let domRule = domRules.GetElementAt(i);
+      //   let lastDOMRule = domRules.getElementAt(i+1);
+
+      //   let selectors = CssLogic.getSelectors(this.domRule);
+      //   for (let i = 0, len = selectors.length; i < len; i++) {
+      //     this._selectors.push(new CssSelector(this, selectors[i], i));
+      //   }
+
+      //   if (lastDOMRule && DOMUtils)
+      // }
+
+      // let lastRule;
+      // for (let rule of rules) {
+      //   if (lastRule)
+      // }
+
+
+      // const {require} = Cu.import("resource://devtools/shared/Loader.jsm", {});
+      // const {CssLogic} = require("devtools/server/css-logic");
+      // let cssLogic = new CssLogic(DOMUtils.isInheritedProperty);
+      // cssLogic.highlight(element);
+      // cssLogic._findMatchedSelectors();
+
+      // for (let sel of cssLogic._matchedSelectors) {
+      //   dump("processMatchedSelectors callback: " + sel + " " + sel.specificity + " " + status + "\n");
+      // }
+
+      // ((sel, status) => {
+      // });
+//JSON.stringify(cssLogic._matchedRules[0][0], null, 2) 
+
+      // dump("BRIAN XXXX HERE!!!!! \n");
+    }
     instrumentData.elements[selector] = getElementInfo(element);
   }
 
   // Instruments every element in a window
   function scanWindow(win) {
     Array.from(windowElements(win)).forEach(instrumentElement);
   }
 
