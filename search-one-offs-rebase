# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5f2ea22b34dcbcd2d51b4988740afde0ec03833e

diff --git a/browser/components/search/content/search-one-offs.js b/browser/components/search/content/search-one-offs.js
--- a/browser/components/search/content/search-one-offs.js
+++ b/browser/components/search/content/search-one-offs.js
@@ -286,22 +286,34 @@ class MozSearchOneOffs extends MozXULEle
     Services.obs.addObserver(this, "browser-search-service", true);
 
     // Rebuild the buttons when the theme changes.  See bug 1357800 for
     // details.  Summary: On Linux, switching between themes can cause a row
     // of buttons to disappear.
     Services.obs.addObserver(this, "lightweight-theme-changed", true);
   }
 
+  /**
+   * Width in pixels of the one-off buttons.  49px is the min-width of
+   * each search engine button, adapt this const when changing the css.
+   * It's actually 48px + 1px of right border.
+   */
   get buttonWidth() {
     return 49;
   }
-
+  /**
+   * The popup that contains the one-offs.  This is required, so it should
+   * never be null or undefined, except possibly before the one-offs are
+   * used.
+   */
   set popup(val) {
-    let events = ["popupshowing", "popuphidden"];
+    let events = [
+      "popupshowing",
+      "popuphidden",
+    ];
     if (this._popup) {
       for (let event of events) {
         this._popup.removeEventListener(event, this);
       }
     }
     if (val) {
       for (let event of events) {
         val.addEventListener(event, this);
@@ -316,43 +328,55 @@ class MozSearchOneOffs extends MozXULEle
       this._rebuild();
     }
     return val;
   }
 
   get popup() {
     return this._popup;
   }
-
+  /**
+   * The textbox associated with the one-offs.  Set this to a textbox to
+   * automatically keep the related one-offs UI up to date.  Otherwise you
+   * can leave it null/undefined, and in that case you should update the
+   * query property manually.
+   */
   set textbox(val) {
     if (this._textbox) {
       this._textbox.removeEventListener("input", this);
     }
     if (val) {
       val.addEventListener("input", this);
     }
-    return (this._textbox = val);
+    return this._textbox = val;
   }
 
   get textbox() {
     return this._textbox;
   }
-
+  /**
+   * The query string currently shown in the one-offs.  If the textbox
+   * property is non-null, then this is automatically updated on
+   * input.
+   */
   set query(val) {
     this._query = val;
     if (this.popup && this.popup.popupOpen) {
       this._updateAfterQueryChanged();
     }
     return val;
   }
 
   get query() {
     return this._query;
   }
-
+  /**
+   * The selected one-off, a xul:button, including the add-engine button
+   * and the search-settings button.  Null if no one-off is selected.
+   */
   set selectedButton(val) {
     if (val && val.classList.contains("dummy")) {
       // Never select dummy buttons.
       val = null;
     }
     let previousButton = this._selectedButton;
     if (previousButton) {
       previousButton.removeAttribute("selected");
@@ -373,17 +397,20 @@ class MozSearchOneOffs extends MozXULEle
     });
     this.dispatchEvent(event);
     return val;
   }
 
   get selectedButton() {
     return this._selectedButton;
   }
-
+  /**
+   * The index of the selected one-off, including the add-engine button
+   * and the search-settings button.  -1 if no one-off is selected.
+   */
   set selectedButtonIndex(val) {
     let buttons = this.getSelectableButtons(true);
     this.selectedButton = buttons[val];
     return val;
   }
 
   get selectedButtonIndex() {
     let buttons = this.getSelectableButtons(true);
@@ -415,23 +442,28 @@ class MozSearchOneOffs extends MozXULEle
     if (!this.getAttribute("includecurrentengine"))
       currentEngineNameToIgnore = Services.search.currentEngine.name;
 
     let pref = Services.prefs.getStringPref("browser.search.hiddenOneOffs");
     let hiddenList = pref ? pref.split(",") : [];
 
     this._engines = Services.search.getVisibleEngines().filter(e => {
       let name = e.name;
-      return (!currentEngineNameToIgnore || name != currentEngineNameToIgnore) &&
+      return (!currentEngineNameToIgnore ||
+              name != currentEngineNameToIgnore) &&
              !hiddenList.includes(name);
     });
 
     return this._engines;
   }
 
+  /**
+   * This handles events outside the one-off buttons, like on the popup
+   * and textbox.
+   */
   handleEvent(event) {
     switch (event.type) {
       case "input":
         // Allow the consumer's input to override its value property with
         // a oneOffSearchQuery property.  That way if the value is not
         // actually what the user typed (e.g., it's autofilled, or it's a
         // mozaction URI), the consumer has some way of providing it.
         this.query = event.target.oneOffSearchQuery || event.target.value;
@@ -456,48 +488,51 @@ class MozSearchOneOffs extends MozXULEle
   showSettings() {
     openPreferences("paneSearch", { origin: "contentSearch" });
 
     // If the preference tab was already selected, the panel doesn't
     // close itself automatically.
     this.popup.hidePopup();
   }
 
+  /**
+   * Updates the parts of the UI that show the query string.
+   */
   _updateAfterQueryChanged() {
     let headerSearchText = this.querySelector(".searchbar-oneoffheader-searchtext");
     headerSearchText.setAttribute("value", this.query);
     let groupText;
     let isOneOffSelected =
       this.selectedButton &&
       this.selectedButton.classList.contains("searchbar-engine-one-off-item");
     // Typing de-selects the settings or opensearch buttons at the bottom
     // of the search panel, as typing shows the user intends to search.
     if (this.selectedButton && !isOneOffSelected) {
       this.selectedButton = null;
     }
     if (this.query) {
-      groupText =
-        headerSearchText.previousElementSibling.value +
-        '"' +
-        headerSearchText.value +
-        '"' +
-        headerSearchText.nextElementSibling.value;
+      groupText = headerSearchText.previousElementSibling.value +
+                  '"' + headerSearchText.value + '"' +
+                  headerSearchText.nextElementSibling.value;
       if (!isOneOffSelected) {
         this.header.selectedIndex = 1;
       }
     } else {
       let noSearchHeader = this.querySelector(".searchbar-oneoffheader-search");
       groupText = noSearchHeader.value;
       if (!isOneOffSelected) {
         this.header.selectedIndex = 0;
       }
     }
     this.buttons.setAttribute("aria-label", groupText);
   }
 
+  /**
+   * Builds all the UI.
+   */
   _rebuild() {
     // Update the 'Search for <keywords> with:" header.
     this._updateAfterQueryChanged();
 
     // Handle opensearch items. This needs to be done before building the
     // list of one off providers, as that code will return early if all the
     // alternative engines are hidden.
     // Skip this in compact mode, ie. for the urlbar.
@@ -527,19 +562,18 @@ class MozSearchOneOffs extends MozXULEle
     // Remove the trailing empty text node introduced by the binding's
     // content markup above.
     if (this.settingsButtonCompact.nextElementSibling) {
       this.settingsButtonCompact.nextElementSibling.remove();
     }
 
     let engines = this.engines;
     let oneOffCount = engines.length;
-    let collapsed =
-      !oneOffCount ||
-      (oneOffCount == 1 && engines[0].name == Services.search.currentEngine.name);
+    let collapsed = !oneOffCount ||
+                    (oneOffCount == 1 && engines[0].name == Services.search.currentEngine.name);
 
     // header is a xul:deck so collapsed doesn't work on it, see bug 589569.
     this.header.hidden = this.buttons.collapsed = collapsed;
 
     if (collapsed) {
       return;
     }
 
@@ -574,18 +608,17 @@ class MozSearchOneOffs extends MozXULEle
     let height = rowCount * 33; // 32px per row, 1px border.
     this.buttons.setAttribute("height", height + "px");
 
     // Ensure we can refer to the settings buttons by ID:
     let origin = this.telemetryOrigin;
     this.settingsButton.id = origin + "-anon-search-settings";
     this.settingsButtonCompact.id = origin + "-anon-search-settings-compact";
 
-    let dummyItems =
-      enginesPerRow - (oneOffCount % enginesPerRow || enginesPerRow);
+    let dummyItems = enginesPerRow - (oneOffCount % enginesPerRow || enginesPerRow);
     for (let i = 0; i < engines.length; ++i) {
       let engine = engines[i];
       let button = document.createXULElement("button");
       button.id = this._buttonIDForEngine(engine);
       let uri = "chrome://browser/skin/search-engine-placeholder.png";
       if (engine.iconURI) {
         uri = engine.iconURI.spec;
       }
@@ -608,20 +641,17 @@ class MozSearchOneOffs extends MozXULEle
       }
 
       this.buttons.insertBefore(button, this.settingsButtonCompact);
     }
 
     let hasDummyItems = !!dummyItems;
     while (dummyItems) {
       let button = document.createXULElement("button");
-      button.setAttribute(
-        "class",
-        "searchbar-engine-one-off-item dummy last-row"
-      );
+      button.setAttribute("class", "searchbar-engine-one-off-item dummy last-row");
       button.setAttribute("width", buttonWidth);
 
       if (!--dummyItems) {
         button.classList.add("last-of-row");
       }
 
       this.buttons.insertBefore(button, this.settingsButtonCompact);
     }
@@ -629,17 +659,17 @@ class MozSearchOneOffs extends MozXULEle
     if (this.compact) {
       this.settingsButtonCompact.setAttribute("width", buttonWidth);
       if (rowCount == 1 && hasDummyItems) {
         // When there's only one row, make the compact settings button
         // hug the right edge of the panel.  It may not due to the panel's
         // width not being an integral multiple of the button width.  (See
         // the "There will be an emtpy area" comment above.)  Increase the
         // width of the last dummy item by the remainder.
-        let remainder = panelWidth - enginesPerRow * buttonWidth;
+        let remainder = panelWidth - (enginesPerRow * buttonWidth);
         let width = remainder + buttonWidth;
         let lastDummyItem = this.settingsButtonCompact.previousElementSibling;
         lastDummyItem.setAttribute("width", width);
       }
     }
   }
 
   _rebuildAddEngineList() {
@@ -663,20 +693,18 @@ class MozSearchOneOffs extends MozXULEle
 
     if (tooManyEngines) {
       // Make the top-level menu button.
       let button = document.createXULElement("toolbarbutton");
       list.appendChild(button);
       button.classList.add("addengine-item", "badged-button");
       button.setAttribute("class", "addengine-menu-button");
       button.setAttribute("type", "menu");
-      button.setAttribute(
-        "label",
-        this.bundle.GetStringFromName("cmd_addFoundEngineMenu")
-      );
+      button.setAttribute("label",
+        this.bundle.GetStringFromName("cmd_addFoundEngineMenu"));
       button.setAttribute("crop", "end");
       button.setAttribute("pack", "start");
 
       // Set the menu button's image to the image of the first engine.  The
       // offered engines may have differing images, so there's no perfect
       // choice here.
       let engine = engines[0];
       if (engine.icon) {
@@ -711,23 +739,19 @@ class MozSearchOneOffs extends MozXULEle
     // handling for free inside menupopups.
     let eltType = tooManyEngines ? "menuitem" : "toolbarbutton";
     for (let engine of engines) {
       let button = document.createXULElement(eltType);
       button.classList.add("addengine-item");
       if (!tooManyEngines) {
         button.classList.add("badged-button");
       }
-      button.id =
-        this.telemetryOrigin +
-        "-add-engine-" +
+      button.id = this.telemetryOrigin + "-add-engine-" +
         this._fixUpEngineNameForID(engine.title);
-      let label = this.bundle.formatStringFromName(
-        "cmd_addFoundEngine", [engine.title], 1
-      );
+      let label = this.bundle.formatStringFromName("cmd_addFoundEngine", [engine.title], 1);
       button.setAttribute("label", label);
       button.setAttribute("crop", "end");
       button.setAttribute("tooltiptext", engine.title + "\n" + engine.uri);
       button.setAttribute("uri", engine.uri);
       button.setAttribute("title", engine.title);
       if (engine.icon) {
         button.setAttribute("image", engine.icon);
       }
@@ -747,16 +771,23 @@ class MozSearchOneOffs extends MozXULEle
   _fixUpEngineNameForID(name) {
     return name.replace(/ /g, "-");
   }
 
   _buttonForEngine(engine) {
     return document.getElementById(this._buttonIDForEngine(engine));
   }
 
+  /**
+   * Updates the popup and textbox for the currently selected or moused-over
+   * button.
+   *
+   * @param mousedOverButton
+   * The currently moused-over button, or null if there isn't one.
+   */
   _updateStateForButton(mousedOverButton) {
     let button = mousedOverButton;
 
     // Ignore dummy buttons.
     if (button && button.classList.contains("dummy")) {
       button = null;
     }
 
@@ -835,25 +866,47 @@ class MozSearchOneOffs extends MozXULEle
           inBackground: true,
         };
       }
     }
 
     this.popup.handleOneOffSearch(aEvent, aEngine, where, params);
   }
 
+  /**
+   * Increments or decrements the index of the currently selected one-off.
+   *
+   * @param aForward
+   * If true, the index is incremented, and if false, the index is
+   * decremented.
+   * @param aIncludeNonEngineButtons
+   * If true, non-dummy buttons that do not have engines are included.
+   * These buttons include the OpenSearch and settings buttons.  For
+   * example, if the currently selected button is an engine button,
+   * the next button is the settings button, and you pass true for
+   * aForward, then passing true for this value would cause the
+   * settings to be selected.  Passing false for this value would
+   * cause the selection to clear or wrap around, depending on what
+   * value you passed for the aWrapAround parameter.
+   * @param aWrapAround
+   * If true, the selection wraps around between the first and last
+   * buttons.
+   * @return True if the selection can continue to advance after this method
+   * returns and false if not.
+   */
   advanceSelection(aForward, aIncludeNonEngineButtons, aWrapAround) {
     let buttons = this.getSelectableButtons(aIncludeNonEngineButtons);
     let index;
     if (this.selectedButton) {
       let inc = aForward ? 1 : -1;
       let oldIndex = buttons.indexOf(this.selectedButton);
       index = (oldIndex + inc + buttons.length) % buttons.length;
       if (!aWrapAround &&
-          ((aForward && index <= oldIndex) || (!aForward && oldIndex <= index))) {
+          ((aForward && index <= oldIndex) ||
+           (!aForward && oldIndex <= index))) {
         // The index has wrapped around, but wrapping around isn't
         // allowed.
         index = -1;
       }
     } else {
       index = aForward ? 0 : buttons.length - 1;
     }
     this.selectedButton = index < 0 ? null : buttons[index];
@@ -886,35 +939,32 @@ class MozSearchOneOffs extends MozXULEle
    * restored to the value that the user typed.  Pass that value here.
    * However, if you pass true for allowEmptySelection, you don't need
    * to pass anything for this parameter.  (Pass undefined or null.)
    */
   handleKeyPress(event, numListItems, allowEmptySelection, textboxUserValue) {
     if (!this.popup) {
       return;
     }
-    let handled = this._handleKeyPress(
-      event,
-      numListItems,
+    let handled = this._handleKeyPress(event, numListItems,
       allowEmptySelection,
-      textboxUserValue
-    );
+      textboxUserValue);
     if (handled) {
       event.preventDefault();
       event.stopPropagation();
     }
   }
 
   _handleKeyPress(event, numListItems, allowEmptySelection, textboxUserValue) {
     if (this.compact && this.buttons.collapsed) {
       return false;
     }
     if (event.keyCode == KeyEvent.DOM_VK_RIGHT &&
-        this.selectedButton &&
-        this.selectedButton.classList.contains("addengine-menu-button")) {
+      this.selectedButton &&
+      this.selectedButton.classList.contains("addengine-menu-button")) {
       // If the add-engine overflow menu item is selected and the user
       // presses the right arrow key, open the submenu.  Unfortunately
       // handling the left arrow key -- to close the popup -- isn't
       // straightforward.  Once the popup is open, it consumes all key
       // events.  Setting ignorekeys=handled on it doesn't help, since the
       // popup handles all arrow keys.  Setting ignorekeys=true on it does
       // mean that the popup no longer consumes the left arrow key, but
       // then it no longer handles up/down keys to select items in the
@@ -1000,17 +1050,18 @@ class MozSearchOneOffs extends MozXULEle
         // the buttons.
         this.advanceSelection(true, false, false);
         return true;
       }
       if (numListItems == 0) {
         this.advanceSelection(true, true, false);
         return true;
       }
-      if (this.popup.selectedIndex >= 0 && this.popup.selectedIndex < numListItems - 1) {
+      if (this.popup.selectedIndex >= 0 &&
+          this.popup.selectedIndex < numListItems - 1) {
         // Moving down within the list.  The autocomplete controller
         // should handle this case.  A button may be selected, so null it.
         this.selectedButton = null;
         return false;
       }
       if (this.popup.selectedIndex == numListItems - 1) {
         // Moving down from the last item in the list to the buttons.
         this.selectedButtonIndex = 0;
@@ -1111,18 +1162,17 @@ class MozSearchOneOffs extends MozXULEle
     if (!source) {
       return false;
     }
 
     if (this.telemetryOrigin) {
       source += "-" + this.telemetryOrigin;
     }
 
-    let tabBackground =
-      aOpenUILinkWhere == "tab" &&
+    let tabBackground = aOpenUILinkWhere == "tab" &&
       aOpenUILinkParams &&
       aOpenUILinkParams.inBackground;
     let where = tabBackground ? "tab-background" : aOpenUILinkWhere;
     BrowserSearch.recordOneoffSearchInTelemetry(engine, source, type, where);
     return true;
   }
 
   _resetAddEngineMenuTimeout() {
@@ -1132,15 +1182,12 @@ class MozSearchOneOffs extends MozXULEle
     this._addEngineMenuTimeout = setTimeout(() => {
       delete this._addEngineMenuTimeout;
       let button = this.querySelector(".addengine-menu-button");
       button.open = this._addEngineMenuShouldBeOpen;
     }, this._addEngineMenuTimeoutMs);
   }
 }
 
-MozXULElement.implementCustomInterface(MozSearchOneOffs, [
-  Ci.nsIObserver,
-  Ci.nsIWeakReference,
-]);
+MozXULElement.implementCustomInterface(MozSearchOneOffs, [Ci.nsIObserver, Ci.nsIWeakReference]);
 customElements.define("search-one-offs", MozSearchOneOffs);
 
 }
