# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c5fbbf959e23a4f33d450cb6c64ef739e09fbe13
Bug 1460982 - WIP - convert <searchbar> to a Custom Element

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -42,20 +42,16 @@
   min-width: 300px;
 %endif
 }
 
 #main-window[customize-entered] {
   min-width: -moz-fit-content;
 }
 
-searchbar {
-  -moz-binding: url("chrome://browser/content/search/search.xml#searchbar");
-}
-
 .searchbar-textbox {
   -moz-binding: url("chrome://browser/content/search/search.xml#searchbar-textbox");
 }
 
 .search-one-offs {
   -moz-binding: url("chrome://browser/content/search/search.xml#search-one-offs");
 }
 
diff --git a/browser/base/content/global-scripts.inc b/browser/base/content/global-scripts.inc
--- a/browser/base/content/global-scripts.inc
+++ b/browser/base/content/global-scripts.inc
@@ -11,16 +11,17 @@
 #ifdef BROWSER_XHTML
 xmlns="http://www.w3.org/1999/xhtml"
 #endif
 >
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 for (let script of [
   "chrome://browser/content/browser.js",
+  "chrome://browser/content/search/searchbar.js",
 
   "chrome://browser/content/browser-captivePortal.js",
   "chrome://browser/content/browser-compacttheme.js",
   "chrome://browser/content/browser-contentblocking.js",
   "chrome://browser/content/browser-feeds.js",
   "chrome://browser/content/browser-media.js",
   "chrome://browser/content/browser-pageActions.js",
   "chrome://browser/content/browser-places.js",
diff --git a/browser/components/search/content/search.xml b/browser/components/search/content/search.xml
--- a/browser/components/search/content/search.xml
+++ b/browser/components/search/content/search.xml
@@ -490,17 +490,17 @@
 
     </handlers>
   </binding>
 
   <binding id="searchbar-textbox"
       extends="chrome://global/content/bindings/autocomplete.xml#autocomplete">
     <implementation>
       <constructor><![CDATA[
-        if (document.getBindingParent(this).parentNode.parentNode.localName ==
+        if (this.closest('searchbar').parentNode.parentNode.localName ==
             "toolbarpaletteitem")
           return;
 
         if (Services.prefs.getBoolPref("browser.urlbar.clickSelectsAll"))
           this.setAttribute("clickSelectsAll", true);
 
         var textBox = document.getAnonymousElementByAttribute(this,
                                               "anonid", "moz-input-box");
@@ -508,34 +508,34 @@
         // Force the Custom Element to upgrade until Bug 1470242 handles this:
         customElements.upgrade(textBox);
         var cxmenu = textBox.menupopup;
         cxmenu.addEventListener("popupshowing",
                                 () => { this.initContextMenu(cxmenu); },
                                 {capture: true, once: true});
 
         this.setAttribute("aria-owns", this.popup.id);
-        document.getBindingParent(this)._textboxInitialized = true;
+        this.closest('searchbar')._textboxInitialized = true;
       ]]></constructor>
 
       <destructor><![CDATA[
         // If the context menu has never been opened, there won't be anything
         // to remove here.
         // Also, XBL and the customize toolbar code sometimes interact poorly.
         try {
           this.controllers.removeController(this.searchbarController);
         } catch (ex) { }
       ]]></destructor>
 
       // Add items to context menu and attach controller to handle them the
       // first time the context menu is opened.
       <method name="initContextMenu">
         <parameter name="aMenu"/>
         <body><![CDATA[
-          let stringBundle = document.getBindingParent(this)._stringBundle;
+          let stringBundle = this.closest('searchbar')._stringBundle;
 
           let pasteAndSearch, suggestMenuItem;
           let element, label, akey;
 
           element = document.createXULElement("menuseparator");
           aMenu.appendChild(element);
 
           let insertLocation = aMenu.firstElementChild;
@@ -681,17 +681,17 @@
           }
         ]]></body>
       </method>
 
       <method name="openSearch">
         <body>
           <![CDATA[
             if (!this.popupOpen) {
-              document.getBindingParent(this).openSuggestionsPanel();
+              this.closest('searchbar').openSuggestionsPanel();
               return false;
             }
             return true;
           ]]>
         </body>
       </method>
 
       <method name="handleEnter">
@@ -724,17 +724,17 @@
               return;
             }
             engine = oneOff.engine;
           }
           if (this._selectionDetails) {
             BrowserSearch.searchBar.telemetrySearchDetails = this._selectionDetails;
             this._selectionDetails = null;
           }
-          document.getBindingParent(this).handleSearchCommand(aEvent, engine);
+          this.closest('searchbar').handleSearchCommand(aEvent, engine);
         ]]></body>
       </method>
 
       <property name="selectedButton">
         <getter><![CDATA[
           return this.popup.oneOffButtons.selectedButton;
         ]]></getter>
         <setter><![CDATA[
@@ -799,21 +799,21 @@
         this.popup.removeAttribute("showonlysettings");
       ]]></handler>
 
       <handler event="keypress" phase="capturing"
                action="return this.handleKeyboardNavigation(event);"/>
 
       <handler event="keypress" keycode="VK_UP" modifiers="accel"
                phase="capturing"
-               action="document.getBindingParent(this).selectEngine(event, false);"/>
+               action="this.closest('searchbar').selectEngine(event, false);"/>
 
       <handler event="keypress" keycode="VK_DOWN" modifiers="accel"
                phase="capturing"
-               action="document.getBindingParent(this).selectEngine(event, true);"/>
+               action="this.closest('searchbar').selectEngine(event, true);"/>
 
       <handler event="keypress" keycode="VK_DOWN" modifiers="alt"
                phase="capturing"
                action="return this.openSearch();"/>
 
       <handler event="keypress" keycode="VK_UP" modifiers="alt"
                phase="capturing"
                action="return this.openSearch();"/>
@@ -830,17 +830,17 @@
       <![CDATA[
         var dataTransfer = event.dataTransfer;
         var data = dataTransfer.getData("text/plain");
         if (!data)
           data = dataTransfer.getData("text/x-moz-text-internal");
         if (data) {
           event.preventDefault();
           this.value = data;
-          document.getBindingParent(this).openSuggestionsPanel();
+          this.closest('searchbar').openSuggestionsPanel();
         }
       ]]>
       </handler>
 
     </handlers>
   </binding>
 
   <binding id="browser-search-autocomplete-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup">
diff --git a/browser/components/search/content/searchbar.js b/browser/components/search/content/searchbar.js
new file mode 100644
--- /dev/null
+++ b/browser/components/search/content/searchbar.js
@@ -0,0 +1,418 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+class MozSearchbar extends MozXULElement {
+  connectedCallback() {
+
+    this.appendChild(MozXULElement.parseXULToFragment(`
+      <stringbundle src="chrome://browser/locale/search.properties" anonid="searchbar-stringbundle"></stringbundle>
+      <textbox class="searchbar-textbox" anonid="searchbar-textbox" type="autocomplete" inputtype="search" placeholder="&searchInput.placeholder;" flex="1" autocompletepopup="PopupSearchAutoComplete" autocompletesearch="search-autocomplete" autocompletesearchparam="searchbar-history" maxrows="10" completeselectedindex="true" minresultsforpopup="0" inherits="disabled,disableautocomplete,searchengine,src,newlines">
+        <box>
+          <hbox class="searchbar-search-button" anonid="searchbar-search-button" inherits="addengines" tooltiptext="&searchIcon.tooltip;">
+            <image class="searchbar-search-icon"></image>
+            <image class="searchbar-search-icon-overlay"></image>
+          </hbox>
+        </box>
+        <hbox class="search-go-container">
+          <image class="search-go-button urlbar-icon" hidden="true" anonid="search-go-button" onclick="handleSearchCommand(event);" tooltiptext="&contentSearchSubmit.tooltip;"></image>
+        </hbox>
+      </textbox>
+    `, ["chrome://browser/locale/browser.dtd"]));
+    this._ignoreFocus = false;
+
+    this._clickClosedPopup = false;
+
+    this._stringBundle = this.querySelector("[anonid=searchbar-stringbundle]");
+
+    this._textboxInitialized = false;
+
+    this._textbox = this.querySelector("[anonid=searchbar-textbox]");
+
+    this._engines = null;
+
+    this.FormHistory = (ChromeUtils.import("resource://gre/modules/FormHistory.jsm", {})).FormHistory;
+
+    if (this.parentNode.parentNode.localName == "toolbarpaletteitem")
+      return;
+
+    Services.obs.addObserver(this, "browser-search-engine-modified");
+    Services.obs.addObserver(this, "browser-search-service");
+
+    this._initialized = true;
+
+    (window.delayedStartupPromise || Promise.resolve()).then(() => {
+      window.requestIdleCallback(() => {
+        Services.search.init(aStatus => {
+          // Bail out if the binding's been destroyed
+          if (!this._initialized)
+            return;
+
+          if (Components.isSuccessCode(aStatus)) {
+            // Refresh the display (updating icon, etc)
+            this.updateDisplay();
+            BrowserSearch.updateOpenSearchBadge();
+          } else {
+            Cu.reportError("Cannot initialize search service, bailing out: " + aStatus);
+          }
+        });
+      });
+    });
+
+    // Wait until the popupshowing event to avoid forcing immediate
+    // attachment of the search-one-offs binding.
+    this.textbox.popup.addEventListener("popupshowing", () => {
+      let oneOffButtons = this.textbox.popup.oneOffButtons;
+      // Some accessibility tests create their own <searchbar> that doesn't
+      // use the popup binding below, so null-check oneOffButtons.
+      if (oneOffButtons) {
+        oneOffButtons.telemetryOrigin = "searchbar";
+        // Set .textbox first, since the popup setter will cause
+        // a _rebuild call that uses it.
+        oneOffButtons.textbox = this.textbox;
+        oneOffButtons.popup = this.textbox.popup;
+      }
+    }, { capture: true, once: true });
+
+    this._setupEventListeners();
+  }
+
+  get engines() {
+    if (!this._engines)
+      this._engines = Services.search.getVisibleEngines();
+    return this._engines;
+  }
+
+  set currentEngine(val) {
+    Services.search.currentEngine = val;
+    return val;
+  }
+
+  get currentEngine() {
+    var currentEngine = Services.search.currentEngine;
+    // Return a dummy engine if there is no currentEngine
+    return currentEngine || { name: "", uri: null };
+  }
+  /**
+   * textbox is used by sanitize.js to clear the undo history when
+   * clearing form information.
+   */
+  get textbox() {
+    return this._textbox;
+  }
+
+  set value(val) {
+    return this._textbox.value = val;
+  }
+
+  get value() {
+    return this._textbox.value;
+  }
+
+  destroy() {
+    if (this._initialized) {
+      this._initialized = false;
+
+      Services.obs.removeObserver(this, "browser-search-engine-modified");
+      Services.obs.removeObserver(this, "browser-search-service");
+    }
+
+    // Make sure to break the cycle from _textbox to us. Otherwise we leak
+    // the world. But make sure it's actually pointing to us.
+    // Also make sure the textbox has ever been constructed, otherwise the
+    // _textbox getter will cause the textbox constructor to run, add an
+    // observer, and leak the world too.
+    if (this._textboxInitialized && this._textbox.mController.input == this)
+      this._textbox.mController.input = null;
+  }
+
+  focus() {
+    this._textbox.focus();
+  }
+
+  select() {
+    this._textbox.select();
+  }
+
+  observe(aEngine, aTopic, aVerb) {
+    if (aTopic == "browser-search-engine-modified" ||
+      (aTopic == "browser-search-service" && aVerb == "init-complete")) {
+      // Make sure the engine list is refetched next time it's needed
+      this._engines = null;
+
+      // Update the popup header and update the display after any modification.
+      this._textbox.popup.updateHeader();
+      this.updateDisplay();
+    }
+  }
+
+  setIcon(element, uri) {
+    element.setAttribute("src", uri);
+  }
+
+  updateDisplay() {
+    var uri = this.currentEngine.iconURI;
+    this.setIcon(this, uri ? uri.spec : "");
+
+    var name = this.currentEngine.name;
+    var text = this._stringBundle.getFormattedString("searchtip", [name]);
+    this._textbox.label = text;
+    this._textbox.tooltipText = text;
+  }
+
+  updateGoButtonVisibility() {
+    this.querySelector("[anonid=search-go-button]")
+      .hidden = !this._textbox.value;
+  }
+
+  openSuggestionsPanel(aShowOnlySettingsIfEmpty) {
+    if (this._textbox.open)
+      return;
+
+    this._textbox.showHistoryPopup();
+
+    if (this._textbox.value) {
+      // showHistoryPopup does a startSearch("") call, ensure the
+      // controller handles the text from the input box instead:
+      this._textbox.mController.handleText();
+    } else if (aShowOnlySettingsIfEmpty) {
+      this.setAttribute("showonlysettings", "true");
+    }
+  }
+
+  selectEngine(aEvent, isNextEngine) {
+    // Find the new index
+    var newIndex = this.engines.indexOf(this.currentEngine);
+    newIndex += isNextEngine ? 1 : -1;
+
+    if (newIndex >= 0 && newIndex < this.engines.length) {
+      this.currentEngine = this.engines[newIndex];
+    }
+
+    aEvent.preventDefault();
+    aEvent.stopPropagation();
+
+    this.openSuggestionsPanel();
+  }
+
+  handleSearchCommand(aEvent, aEngine, aForceNewTab) {
+    var where = "current";
+    let params;
+
+    // Open ctrl/cmd clicks on one-off buttons in a new background tab.
+    if (aEvent && aEvent.originalTarget.getAttribute("anonid") == "search-go-button") {
+      if (aEvent.button == 2)
+        return;
+      where = whereToOpenLink(aEvent, false, true);
+    } else if (aForceNewTab) {
+      where = "tab";
+      if (Services.prefs.getBoolPref("browser.tabs.loadInBackground"))
+        where += "-background";
+    } else {
+      var newTabPref = Services.prefs.getBoolPref("browser.search.openintab");
+      if (((aEvent instanceof KeyboardEvent && aEvent.altKey) ^ newTabPref) &&
+        !isTabEmpty(gBrowser.selectedTab)) {
+        where = "tab";
+      }
+      if ((aEvent instanceof MouseEvent) &&
+        (aEvent.button == 1 || aEvent.getModifierState("Accel"))) {
+        where = "tab";
+        params = {
+          inBackground: true,
+        };
+      }
+    }
+
+    this.handleSearchCommandWhere(aEvent, aEngine, where, params);
+  }
+
+  handleSearchCommandWhere(aEvent, aEngine, aWhere, aParams) {
+    var textBox = this._textbox;
+    var textValue = textBox.value;
+
+    let selection = this.telemetrySearchDetails;
+    let oneOffRecorded = false;
+
+    BrowserUsageTelemetry.recordSearchbarSelectedResultMethod(
+      aEvent,
+      selection ? selection.index : -1
+    );
+
+    if (!selection || (selection.index == -1)) {
+      oneOffRecorded = this.textbox.popup.oneOffButtons
+        .maybeRecordTelemetry(aEvent, aWhere, aParams);
+      if (!oneOffRecorded) {
+        let source = "unknown";
+        let type = "unknown";
+        let target = aEvent.originalTarget;
+        if (aEvent instanceof KeyboardEvent) {
+          type = "key";
+        } else if (aEvent instanceof MouseEvent) {
+          type = "mouse";
+          if (target.classList.contains("search-panel-header") ||
+            target.parentNode.classList.contains("search-panel-header")) {
+            source = "header";
+          }
+        } else if (aEvent instanceof XULCommandEvent) {
+          if (target.getAttribute("anonid") == "paste-and-search") {
+            source = "paste";
+          }
+        }
+        if (!aEngine) {
+          aEngine = this.currentEngine;
+        }
+        BrowserSearch.recordOneoffSearchInTelemetry(aEngine, source, type,
+          aWhere);
+      }
+    }
+
+    // This is a one-off search only if oneOffRecorded is true.
+    this.doSearch(textValue, aWhere, aEngine, aParams, oneOffRecorded);
+
+    if (aWhere == "tab" && aParams && aParams.inBackground)
+      this.focus();
+  }
+
+  doSearch(aData, aWhere, aEngine, aParams, aOneOff) {
+    var textBox = this._textbox;
+
+    // Save the current value in the form history
+    if (aData && !PrivateBrowsingUtils.isWindowPrivate(window) && this.FormHistory.enabled) {
+      this.FormHistory.update({
+        op: "bump",
+        fieldname: textBox.getAttribute("autocompletesearchparam"),
+        value: aData
+      }, {
+        handleError(aError) {
+          Cu.reportError("Saving search to form history failed: " + aError.message);
+        }
+      });
+    }
+
+    let engine = aEngine || this.currentEngine;
+    var submission = engine.getSubmission(aData, null, "searchbar");
+    let telemetrySearchDetails = this.telemetrySearchDetails;
+    this.telemetrySearchDetails = null;
+    if (telemetrySearchDetails && telemetrySearchDetails.index == -1) {
+      telemetrySearchDetails = null;
+    }
+    // If we hit here, we come either from a one-off, a plain search or a suggestion.
+    const details = {
+      isOneOff: aOneOff,
+      isSuggestion: (!aOneOff && telemetrySearchDetails),
+      selection: telemetrySearchDetails,
+    };
+    BrowserSearch.recordSearchInTelemetry(engine, "searchbar", details);
+    // null parameter below specifies HTML response for search
+    let params = {
+      postData: submission.postData,
+    };
+    if (aParams) {
+      for (let key in aParams) {
+        params[key] = aParams[key];
+      }
+    }
+    openTrustedLinkIn(submission.uri.spec, aWhere, params);
+  }
+
+  disconnectedCallback() {
+    this.destroy();
+  }
+
+  _setupEventListeners() {
+    this.addEventListener("command", (event) => {
+      const target = event.originalTarget;
+      if (target.engine) {
+        this.currentEngine = target.engine;
+      } else if (target.classList.contains("addengine-item")) {
+        // Select the installed engine if the installation succeeds
+        var installCallback = {
+          onSuccess: engine => this.currentEngine = engine,
+        };
+        Services.search.addEngine(target.getAttribute("uri"), null,
+          target.getAttribute("src"), false,
+          installCallback);
+      } else
+        return;
+
+      this.focus();
+      this.select();
+    });
+
+    this.addEventListener("DOMMouseScroll", (event) => { this.selectEngine(event, (event.detail > 0)); }, true);
+
+    this.addEventListener("input", (event) => { this.updateGoButtonVisibility(); });
+
+    this.addEventListener("drop", (event) => { this.updateGoButtonVisibility(); });
+
+    this.addEventListener("blur", (event) => {
+      // If the input field is still focused then a different window has
+      // received focus, ignore the next focus event.
+      this._ignoreFocus = (document.activeElement == this._textbox.inputField);
+    });
+
+    this.addEventListener("focus", (event) => {
+      // Speculatively connect to the current engine's search URI (and
+      // suggest URI, if different) to reduce request latency
+      this.currentEngine.speculativeConnect({
+        window,
+        originAttributes: gBrowser.contentPrincipal
+          .originAttributes
+      });
+
+      if (this._ignoreFocus) {
+        // This window has been re-focused, don't show the suggestions
+        this._ignoreFocus = false;
+        return;
+      }
+
+      // Don't open the suggestions if there is no text in the textbox.
+      if (!this._textbox.value)
+        return;
+
+      // Don't open the suggestions if the mouse was used to focus the
+      // textbox, that will be taken care of in the click handler.
+      if (Services.focus.getLastFocusMethod(window) & Services.focus.FLAG_BYMOUSE)
+        return;
+
+      this.openSuggestionsPanel();
+    });
+
+    this.addEventListener("mousedown", (event) => {
+      if (event.originalTarget.getAttribute("anonid") == "searchbar-search-button") {
+        this._clickClosedPopup = this._textbox.popup._isHiding;
+      }
+    }, true);
+
+    this.addEventListener("mousedown", (event) => {
+      // Ignore clicks on the search go button.
+      if (event.originalTarget.getAttribute("anonid") == "search-go-button") {
+        return;
+      }
+
+      let isIconClick = event.originalTarget.getAttribute("anonid") == "searchbar-search-button";
+
+      // Ignore clicks on the icon if they were made to close the popup
+      if (isIconClick && this._clickClosedPopup) {
+        return;
+      }
+
+      // Open the suggestions whenever clicking on the search icon or if there
+      // is text in the textbox.
+      if (isIconClick || this._textbox.value) {
+        this.openSuggestionsPanel(true);
+      }
+    });
+
+  }
+}
+
+customElements.define("searchbar", MozSearchbar);
+
+}
diff --git a/browser/components/search/jar.mn b/browser/components/search/jar.mn
--- a/browser/components/search/jar.mn
+++ b/browser/components/search/jar.mn
@@ -1,12 +1,13 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 browser.jar:
+        content/browser/search/searchbar.js                         (content/searchbar.js)
         content/browser/search/search.xml                           (content/search.xml)
         content/browser/search/searchReset.xhtml                    (content/searchReset.xhtml)
         content/browser/search/searchReset.js                       (content/searchReset.js)
 
         searchplugins/                                              (searchplugins/**)
 
 % resource search-plugins %searchplugins/
