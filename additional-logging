# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5c640585064da050ab2573d67e677ce4be5555f9
Extra logging for breakpoint sliding issues

diff --git a/devtools/server/actors/script.js b/devtools/server/actors/script.js
--- a/devtools/server/actors/script.js
+++ b/devtools/server/actors/script.js
@@ -2733,17 +2733,18 @@ SourceActor.prototype = {
           // build a map from column numbers to a list of entry points for each
           // column, implemented as a sparse array. An entry point is a (script,
           // offsets) pair, and represents all offsets in that script that are
           // entry points for the corresponding column.
           let columnToEntryPointsMap = [];
 
           // Iterate over all scripts that correspond to this source actor and
           // line number.
-          let scripts = this.scripts.getScriptsBySourceActor(this, originalLine);
+          // XXX: Shouldn't this be getScriptsBySourceActorAndLineNumber?
+          let scripts = this.scripts.getScriptsBySourceActorAndLineNumber(this, originalLine);
           for (let script of scripts) {
             let columnToOffsetMap = script.getAllColumnOffsets()
                                           .filter(({ lineNumber }) => {
               return lineNumber === originalLine;
             })
 
             // Iterate over each column, and add their list of offsets to the
             // map from column numbers to entry points by forming a (script,
@@ -2789,69 +2790,49 @@ SourceActor.prototype = {
           // To perform breakpoint sliding for line breakpoints, we need to
           // build a map from line numbers to a list of entry points for each
           // line, implemented as a sparse array. An entry point is a (script,
           // offsets) pair, and represents all offsets in that script that are
           // entry points for the corresponding line.
           let lineToEntryPointsMap = [];
 
           // Iterate over all scripts that correspond to this source actor.
-          let scripts = this.scripts.getScriptsBySourceActor(this);
-          console.log(scripts.length);
+          // let scripts = this.scripts.getScriptsBySourceActor(this);
+          // console.log("Original line?", originalLine);
+          let scripts = this.scripts.getScriptsBySourceActorAndLine(this, originalLine);
+          // console.log("Number of scripts", scripts.length);
+          // console.time("Looping scripts");
           for (let script of scripts) {
             // Get all offsets for each line in the current script. This returns
             // a map from line numbers to a list of offsets for each line,
             // implemented as a sparse array.
             let lineToOffsetsMap = script.getAllOffsets();
-            console.log("Offsets for script ", lineToOffsetsMap.length);
+            // console.log("Number of offsets for script ", lineToOffsetsMap.length);
 
             // Iterate over each line, and add their list of offsets to the map
             // from line numbers to entry points by forming a (script, offsets)
             // pair, where script is the current script, and offsets is the list
             // of offsets for the current line.
-            // console.time("lineToOffsetsMap");
-            let numTrue = 0;
-            let numFalse = 0;
-
             let importantOffsets = lineToOffsetsMap[-1];
-            // console.log("Offsets map -1", lineToOffsetsMap[-1]);
+            let n = Date.now();
             for (let line of importantOffsets) {
-              // console.log("Has offset at line " + line);
               let offsets = lineToOffsetsMap[line];
               let entryPoints = lineToEntryPointsMap[line];
               if (!entryPoints) {
                 // We dont have a list of entry points for the current line
                 // number yet, so create it and add it to the map.
                 entryPoints = [];
                 lineToEntryPointsMap[line] = entryPoints;
               }
               entryPoints.push({ script, offsets });
             }
-
-            // for (let line = 0; line < lineToOffsetsMap.length; ++line) {
-            //   let offsets = lineToOffsetsMap[line];
-            //   if (offsets) {
-            //     numTrue++;
-            //     console.log("Has offset at line " + line);
-            //     let entryPoints = lineToEntryPointsMap[line];
-            //     if (!entryPoints) {
-            //       // We dont have a list of entry points for the current line
-            //       // number yet, so create it and add it to the map.
-            //       entryPoints = [];
-            //       lineToEntryPointsMap[line] = entryPoints;
-            //     }
-            //     entryPoints.push({ script, offsets });
-            //   } else {
-            //     numFalse++;
-            //   }
-            // }
-            // console.timeEnd("lineToOffsetsMap");
-            // console.log("lineToOffsetsMap.length", lineToOffsetsMap.length,
-            //   "true: " + numTrue, "false: " + numFalse);
+            // console.log("Number of important offsets", importantOffsets.length,
+            //             "and took ", ((new Date()) - n) + "ms");
           }
+          // console.timeEnd("Looping scripts");
 
           // Now that we have a map from line numbers to a list of entry points
           // for each line, we can use it to perform breakpoint sliding. Start
           // at the original line of the breakpoint actor, and keep incrementing
           // it by one, until either we find a line that has at least one entry
           // point, or we go past the last line in the map.
           //
           // Note that by computing the entire map up front, and implementing it
@@ -2861,16 +2842,17 @@ SourceActor.prototype = {
           while (actualLine < lineToEntryPointsMap.length) {
             let entryPoints = lineToEntryPointsMap[actualLine];
             if (entryPoints) {
               setBreakpointAtEntryPoints(actor, entryPoints);
               break;
             }
             ++actualLine;
           }
+
           if (actualLine >= lineToEntryPointsMap.length) {
             // We went past the last line in the map, so breakpoint sliding
             // failed. Keep the BreakpointActor in the BreakpointActorMap as a
             // pending breakpoint, so we can try again whenever a new script is
             // introduced.
             return originalLocation;
           }
 
