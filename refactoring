# HG changeset patch
# Parent 21c26cd710ad98d7ec5a790e190ae34564f82e86
# User Brian Grinstead <bgrinstead@mozilla.com>
refactoring for anon-content based on feedback

diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
--- a/browser/devtools/framework/selection.js
+++ b/browser/devtools/framework/selection.js
@@ -223,18 +223,17 @@ Selection.prototype = {
     if (node.isLocal_toBeDeprecated()) {
       rawNode = node.rawNode();
     }
     if (rawNode) {
       try {
         let doc = this.document;
         if (doc && doc.defaultView) {
           let docEl = doc.documentElement;
-          let bindingParent =
-            new LayoutHelpers(doc.defaultView).getRootBindingParent(rawNode);
+          let bindingParent = LayoutHelpers.getRootBindingParent(rawNode);
 
           if (docEl.contains(bindingParent)) {
             return true;
           }
         }
       } catch (e) {
         // "can't access dead object" error
       }
@@ -260,16 +259,20 @@ Selection.prototype = {
   isElementNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
   },
 
   isPseudoElementNode: function() {
     return this.isNode() && this.nodeFront.isPseudoElement;
   },
 
+  isAnonymousNode: function() {
+    return this.isNode() && this.nodeFront.isAnonymous;
+  },
+
   isAttributeNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
   },
 
   isTextNode: function() {
     return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
   },
 
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -401,16 +401,17 @@ InspectorPanel.prototype = {
     // client know.
     let selection = this.selection.nodeFront;
 
     // On any new selection made by the user, store the unique css selector
     // of the selected node so it can be restored after reload of the same page
     if (reason !== "navigateaway" &&
         this.selection.node &&
         this.selection.isElementNode()) {
+
       try { // Anonymous nodes do not have a selector in the document
         this.selectionCssSelector = CssLogic.findCssSelector(this.selection.node);
       } catch(e) { }
     }
 
     let selfUpdate = this.updating("inspector-panel");
     Services.tm.mainThread.dispatch(() => {
       try {
@@ -580,38 +581,39 @@ InspectorPanel.prototype = {
     return null;
   },
 
   /**
    * Disable the delete item if needed. Update the pseudo classes.
    */
   _setupNodeMenu: function InspectorPanel_setupNodeMenu() {
     let isSelectionElement = this.selection.isElementNode() &&
-                             !this.selection.isPseudoElementNode;
+                             !this.selection.isPseudoElementNode();
+    let isEditableElement = isSelectionElement &&
+                            !this.selection.isAnonymousNode();
 
     // Set the pseudo classes
     for (let name of ["hover", "active", "focus"]) {
       let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);
 
       if (isSelectionElement) {
         let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
         menu.setAttribute("checked", checked);
         menu.removeAttribute("disabled");
       } else {
         menu.setAttribute("disabled", "true");
       }
     }
 
     // Disable delete item if needed
     let deleteNode = this.panelDoc.getElementById("node-menu-delete");
-    if (this.selection.isRoot() || this.selection.isDocumentTypeNode() ||
-        this.selection.isPseudoElementNode()) {
+    if (isEditableElement) {
+      deleteNode.removeAttribute("disabled");
+    } else {
       deleteNode.setAttribute("disabled", "true");
-    } else {
-      deleteNode.removeAttribute("disabled");
     }
 
     // Disable / enable "Copy Unique Selector", "Copy inner HTML" &
     // "Copy outer HTML" as appropriate
     let unique = this.panelDoc.getElementById("node-menu-copyuniqueselector");
     let copyInnerHTML = this.panelDoc.getElementById("node-menu-copyinner");
     let copyOuterHTML = this.panelDoc.getElementById("node-menu-copyouter");
     if (isSelectionElement) {
@@ -622,38 +624,38 @@ InspectorPanel.prototype = {
       unique.setAttribute("disabled", "true");
       copyInnerHTML.setAttribute("disabled", "true");
       copyOuterHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "edit HTML" item if the selection is an element and the root
     // actor has the appropriate trait (isOuterHTMLEditable)
     let editHTML = this.panelDoc.getElementById("node-menu-edithtml");
-    if (this.isOuterHTMLEditable && isSelectionElement) {
+    if (isEditableElement && this.isOuterHTMLEditable) {
       editHTML.removeAttribute("disabled");
     } else {
       editHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "paste outer HTML" item if the selection is an element and
     // the root actor has the appropriate trait (isOuterHTMLEditable) and if
     // the clipbard content is appropriate.
     let pasteOuterHTML = this.panelDoc.getElementById("node-menu-pasteouterhtml");
-    if (this.isOuterHTMLEditable && isSelectionElement &&
+    if (isEditableElement && this.isOuterHTMLEditable &&
         this._getClipboardContentForOuterHTML()) {
       pasteOuterHTML.removeAttribute("disabled");
     } else {
       pasteOuterHTML.setAttribute("disabled", "true");
     }
 
     // Enable the "copy image data-uri" item if the selection is previewable
     // which essentially checks if it's an image or canvas tag
     let copyImageData = this.panelDoc.getElementById("node-menu-copyimagedatauri");
     let markupContainer = this.markup.getContainer(this.selection.nodeFront);
-    if (markupContainer && markupContainer.isPreviewable()) {
+    if (isSelectionElement && markupContainer && markupContainer.isPreviewable()) {
       copyImageData.removeAttribute("disabled");
     } else {
       copyImageData.setAttribute("disabled", "true");
     }
   },
 
   _resetNodeMenu: function InspectorPanel_resetNodeMenu() {
     // Remove any extra items
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -1273,16 +1273,18 @@ MarkupView.prototype = {
  *
  * @param MarkupView aMarkupView
  *        The markup view that owns this container.
  * @param NodeFront aNode
  *        The node to display.
  * @param Inspector aInspector
  *        The inspector tool container the markup-view
  */
+
+
 function MarkupContainer(aMarkupView, aNode, aInspector) {
   this.markup = aMarkupView;
   this.doc = this.markup.doc;
   this.undo = this.markup.undo;
   this.node = aNode;
   this._inspector = aInspector;
 
   if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1198,16 +1198,18 @@ CssRuleView.prototype = {
       label = "ruleView.contextmenu.showCSSSources";
     }
     this.menuitemSources.setAttribute("label",
                                       _strings.GetStringFromName(label));
 
     let accessKey = label + ".accessKey";
     this.menuitemSources.setAttribute("accesskey",
                                       _strings.GetStringFromName(accessKey));
+
+    this.menuitemAddRule.disabled = this.inspector.selection.isAnonymousNode();
   },
 
   /**
    * Get the type of a given node in the rule-view
    * @param {DOMNode} node The node which we want information about
    * @return {Object} The type information object contains the following props:
    * - type {String} One of the VIEW_NODE_XXX_TYPE const in
    *   style-inspector-overlays
@@ -1751,17 +1753,21 @@ function RuleEditor(aRuleView, aRule) {
   this._onSelectorDone = this._onSelectorDone.bind(this);
 
   this._create();
 }
 
 RuleEditor.prototype = {
   get isSelectorEditable() {
     let toolbox = this.ruleView.inspector.toolbox;
-    return toolbox.target.client.traits.selectorEditable;
+    let trait = toolbox.target.client.traits.selectorEditable;
+
+    // Do not allow editing anonymousselectors until we can
+    // detect mutations on  pseudo elements in Bug 1034110.
+    return trait && !this.rule.elementStyle.element.isAnonymous;
   },
 
   _create: function() {
     this.element = this.doc.createElementNS(HTML_NS, "div");
     this.element.className = "ruleview-rule theme-separator";
     this.element.setAttribute("uneditable", !this.isEditable);
     this.element._ruleEditor = this;
     if (this.rule.pseudoElement) {
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -126,27 +126,28 @@ function getNode(nodeOrSelector) {
   return typeof nodeOrSelector === "string" ?
     content.document.querySelector(nodeOrSelector) :
     nodeOrSelector;
 }
 
 /**
  * Set the inspector's current selection to a node or to the first match of the
  * given css selector
+ * @param {String|DOMNode|NodeFront} data The node to select.  If it is a string
+ * or DOMNode it will not be remote safe - using a NodeFront is safer.
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @param {String} reason Defaults to "test" which instructs the inspector not
  * to highlight the node upon selection
- * @param {String} reason Defaults to "test" which instructs the inspector not to highlight the node upon selection
  * @return a promise that resolves when the inspector is updated with the new
  * node
  */
-function selectNode(nodeOrSelector, inspector, reason="test") {
-  info("Selecting the node " + nodeOrSelector);
-  let node = getNode(nodeOrSelector);
+function selectNode(data, inspector, reason="test") {
+  info("Selecting the node " + data);
+  let node = getNode(data);
   let updated = inspector.once("inspector-updated");
   if (node._form) {
     inspector.selection.setNodeFront(node, reason);
   } else {
     inspector.selection.setNode(node, reason);
   }
   return updated;
 }
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -331,35 +331,16 @@ LayoutHelpers.prototype = {
     let docShell = win.QueryInterface(Ci.nsIInterfaceRequestor)
                    .getInterface(Ci.nsIWebNavigation)
                    .QueryInterface(Ci.nsIDocShell);
 
     return docShell === this._topDocShell;
   },
 
   /**
-   * Traverse getBindingParent until arriving upon the bound element
-   * responsible for the generation of the specified node.
-   *
-   * @param {DOMNode} node
-   * @return {DOMNode}
-   *         If node is not anonymous, this will return node. Otherwise,
-   *         it will return the bound element
-   *
-   */
-  getRootBindingParent: function(node) {
-    let parent;
-    let doc = node.ownerDocument;
-    while ((parent = doc.getBindingParent(node))) {
-      node = parent;
-    }
-    return node;
-  },
-
-  /**
    * Check a window is part of the top level window.
    *
    * @param {DOMWindow} win
    * @return {Boolean}
    */
   isIncludedInTopLevelWindow: function LH_isIncludedInTopLevelWindow(win) {
     if (this.isTopLevelWindow(win)) {
       return true;
@@ -510,8 +491,43 @@ LayoutHelpers.prototype = {
     return {
       p1: {x: xOffset, y: yOffset},
       p2: {x: xOffset + width, y: yOffset},
       p3: {x: xOffset + width, y: yOffset + height},
       p4: {x: xOffset, y: yOffset + height}
     };
   }
 };
+
+/**
+ * Traverse getBindingParent until arriving upon the bound element
+ * responsible for the generation of the specified node.
+ *
+ * @param {DOMNode} node
+ * @return {DOMNode}
+ *         If node is not anonymous, this will return node. Otherwise,
+ *         it will return the bound element
+ *
+ */
+LayoutHelpers.getRootBindingParent = function(node) {
+  let parent;
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return node;
+  }
+  while ((parent = doc.getBindingParent(node))) {
+    node = parent;
+  }
+  return node;
+};
+
+
+/**
+ * Determine whether a node is anonymous by determining if there
+ * is a bindingParent.
+ *
+ * @param {DOMNode} node
+ * @return {bool}
+ *
+ */
+LayoutHelpers.isAnonymous = function(node) {
+  return LayoutHelpers.getRootBindingParent(node) !== node;
+};
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -951,24 +951,30 @@ BoxModelHighlighter.prototype = Heritage
   _updateInfobar: function() {
     if (!this.currentNode) {
       return;
     }
 
     let node = this.currentNode;
     let info = this.nodeInfo;
 
+    // If this is a ::before or ::after, then reset node to the
+    // parent and append ::before/::after onto the pseudoClassesBox.
+    let pseudoElement = null;
+    if (node.tagName === "_moz_generated_content_before") {
+      pseudoElement = "::before";
+      node = LayoutHelpers.getRootBindingParent(node);
+    } else if (node.tagName === "_moz_generated_content_after") {
+      pseudoElement = "::after";
+      node = LayoutHelpers.getRootBindingParent(node);
+    }
+
     // Update the tag, id, classes, pseudo-classes and dimensions only if they
     // changed to avoid triggering paint events
     let tagName = node.tagName;
-    if (tagName === "_moz_generated_content_before") {
-      tagName = "::before";
-    } else if (tagName === "_moz_generated_content_after") {
-      tagName = "::after";
-    }
     if (info.tagNameLabel.textContent !== tagName) {
       info.tagNameLabel.textContent = tagName;
     }
 
     let id = node.id ? "#" + node.id : "";
     if (info.idLabel.textContent !== id) {
       info.idLabel.textContent = id;
     }
@@ -976,16 +982,21 @@ BoxModelHighlighter.prototype = Heritage
     let classList = (node.classList || []).length ? "." + [...node.classList].join(".") : "";
     if (info.classesBox.textContent !== classList) {
       info.classesBox.textContent = classList;
     }
 
     let pseudos = PSEUDO_CLASSES.filter(pseudo => {
       return DOMUtils.hasPseudoClassLock(node, pseudo);
     }, this).join("");
+
+    if (pseudoElement) {
+      pseudos += pseudoElement;
+    }
+
     if (info.pseudoClassesBox.textContent !== pseudos) {
       info.pseudoClassesBox.textContent = pseudos;
     }
 
     let rect = node.getBoundingClientRect();
     let dim = Math.ceil(rect.width) + " x " + Math.ceil(rect.height);
     if (info.dimensionBox.textContent !== dim) {
       info.dimensionBox.textContent = dim;
@@ -1314,17 +1325,17 @@ function isNodeValid(node) {
   // Is the document inaccessible?
   let doc = node.ownerDocument;
   if (!doc || !doc.defaultView) {
     return false;
   }
 
   // Is the node connected to the document? Using getBindingParent adds
   // support for anonymous elements generated by a node in the document.
-  let bindingParent = new LayoutHelpers(doc.defaultView).getRootBindingParent(node);
+  let bindingParent = LayoutHelpers.getRootBindingParent(node);
   if (!doc.documentElement.contains(bindingParent)) {
     return false;
   }
 
   return true;
 }
 
 XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -224,16 +224,17 @@ var NodeActor = exports.NodeActor = prot
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
       isBeforePseudoElement: this.rawNode.nodeName === "_moz_generated_content_before",
       isAfterPseudoElement: this.rawNode.nodeName === "_moz_generated_content_after",
+      isAnonymous: LayoutHelpers.isAnonymous(this.rawNode),
       pseudoClassLocks: this.writePseudoClassLocks(),
 
       isDisplayed: this.isDisplayed,
     };
 
     if (this.isDocumentElement()) {
       form.isDocumentElement = true;
     }
@@ -562,16 +563,17 @@ let NodeFront = protocol.FrontClass(Node
   },
 
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
 
   get isBeforePseudoElement() this._form.isBeforePseudoElement,
   get isAfterPseudoElement() this._form.isAfterPseudoElement,
   get isPseudoElement() this.isBeforePseudoElement || this.isAfterPseudoElement,
+  get isAnonymous() this._form.isAnonymous,
 
   get tagName() this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE ? this.nodeName : null,
   get shortValue() this._form.shortValue,
   get incompleteValue() !!this._form.incompleteValue,
 
   get isDocumentElement() !!this._form.isDocumentElement,
 
   // doctype properties
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -18,18 +18,21 @@ loader.lazyGetter(this, "CssLogic", () =
 loader.lazyGetter(this, "DOMUtils", () => Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils));
 
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
-const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":-moz-selection"];
+const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
+const PSEUDO_ELEMENTS_TO_READ = PSEUDO_ELEMENTS.filter(pseudo => {
+  return pseudo !== ":before" && pseudo !== ":after";
+});
 
 // Predeclare the domnode actor type for use in requests.
 types.addActorType("domnode");
 
 // Predeclare the domstylerule actor type
 types.addActorType("domstylerule");
 
 /**
@@ -297,17 +300,17 @@ var PageStyleActor = protocol.ActorClass
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSeletors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
   getApplied: method(function(node, options) {
     let entries = [];
-    this.addElementRules(node, undefined, options, entries);
+    entries = entries.concat(this._getAllElementRules(node, undefined, options));
     return this.getAppliedProps(node, entries, options);
   }, {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
@@ -323,90 +326,121 @@ var PageStyleActor = protocol.ActorClass
   /**
    * Helper function for getApplied, adds all the rules from a given
    * element. See getApplied for documentation on parameters.
    * @param NodeActor node
    * @param bool inherited
    * @param object options
    * @param Array rules (modifies this instead of returning)
    */
-  addElementRules: function(node, inherited, options, rules)
+  _getAllElementRules: function(node, inherited, options)
   {
-    let element = node.rawNode;
-    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
-    let form = node.form();
-    let isBeforeOrAfter = form.isBeforePseudoElement ||
-                          form.isAfterPseudoElement;
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(node.rawNode);
+    let rules = [];
 
-    // If it is before or after, then we don't want to get styles for
-    // this element.  Want to get it for the parent with the corresponding
-    // pseudo.  Then we want to lie to the view and tell it that it isn't a pseudo
-    // style so that it shows up normally.
-    if (isBeforeOrAfter) {
-      element = element.parentNode;
-      pseudoElements = [form.isBeforePseudoElement ? ":before" : ":after"];
+    if (!elementToRead || !elementToRead.style) {
+      return rules;
     }
 
-    if (!element || !element.style) {
-      return;
-    }
+    let elementStyle = this._styleRef(elementToRead);
+    let showElementStyles = !inherited && !pseudoToRead;
+    let showInheritedStyles = inherited && this._hasInheritedProps(elementToRead.style);
 
-    let elementStyle = this._styleRef(element);
-    let showInlineStyles = !inherited && !isBeforeOrAfter;
-    let showInheritedStyles = inherited && this._hasInheritedProps(element.style);
-
-    if (showInlineStyles || showInheritedStyles) {
+    // First any inline styles
+    if (showElementStyles) {
       rules.push({
         rule: elementStyle,
-        inherited: inherited,
       });
     }
 
-    for (let pseudo of pseudoElements) {
+    // Now any inherited styles
+    if (showInheritedStyles) {
+      rules.push({
+        rule: elementStyle,
+        inherited: inherited
+      });
+    }
 
-      // Get the styles that apply to the element.
-      let domRules = DOMUtils.getCSSStyleRules(element, pseudo);
-      if (!domRules) {
+    // Add normal rules.  Typically this is passing in the node passed into the
+    // function, unless if that node was ::before/::after.  In which case,
+    // it will pass in the parentNode along with "::before"/"::after".
+    this._getElementRules(elementToRead, pseudoToRead, inherited, options).forEach((rule) => {
+      // The only case when there would be a pseudo here is ::before/::after,
+      // and in this case we want to tell the view that it belongs to the
+      // element (which is a _moz_generated_content native anonymous element).
+      rule.pseudoElement = null;
+      rules.push(rule);
+    });
+
+    // Now any pseudos (except for ::before / ::after, which was handled as
+    // a 'normal rule' above.
+    if (showElementStyles) {
+      for (let pseudo of PSEUDO_ELEMENTS_TO_READ) {
+        this._getElementRules(elementToRead, pseudo, inherited, options).forEach((rule) => {
+          rules.push(rule);
+        });
+      }
+    }
+
+    return rules;
+  },
+
+  /**
+   * Helper function for _getAllElementRules, returns the rules from a given
+   * element. See getApplied for documentation on parameters.
+   * @param DOMNode elementToRead
+   * @param string pseudoToRead
+   * @param DOMNode inherited
+   * @param object options
+   *
+   * @returns Array rules
+   */
+  _getElementRules: function (elementToRead, pseudoToRead, inherited, options) {
+    let domRules = DOMUtils.getCSSStyleRules(elementToRead, pseudoToRead);
+    if (!domRules) {
+      return [];
+    }
+
+    let rules = [];
+
+    // getCSSStyleRules returns ordered from least-specific to
+    // most-specific.
+    for (let i = domRules.Count() - 1; i >= 0; i--) {
+      let domRule = domRules.GetElementAt(i);
+
+      let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
+
+      if (isSystem && options.filter != CssLogic.FILTER.UA) {
         continue;
       }
 
-      // getCSSStyleRules returns ordered from least-specific to
-      // most-specific.
-      for (let i = domRules.Count() - 1; i >= 0; i--) {
-        let domRule = domRules.GetElementAt(i);
-
-        let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
-
-        if (isSystem && options.filter != CssLogic.FILTER.UA) {
+      if (inherited) {
+        // Don't include inherited rules if none of its properties
+        // are inheritable.
+        let hasInherited = Array.prototype.some.call(domRule.style, prop => {
+          return DOMUtils.isInheritedProperty(prop);
+        });
+        if (!hasInherited) {
           continue;
         }
-
-        if (inherited) {
-          // Don't include inherited rules if none of its properties
-          // are inheritable.
-          let hasInherited = Array.prototype.some.call(domRule.style, prop => {
-            return DOMUtils.isInheritedProperty(prop);
-          });
-          if (!hasInherited) {
-            continue;
-          }
-        }
-
-        let ruleActor = this._styleRef(domRule);
-        rules.push({
-          rule: ruleActor,
-          inherited: inherited,
-          pseudoElement: isBeforeOrAfter ? null : pseudo,
-          isSystem: isSystem
-        });
       }
 
+      let ruleActor = this._styleRef(domRule);
+      rules.push({
+        rule: ruleActor,
+        inherited: inherited,
+        isSystem: isSystem,
+        pseudoElement: pseudoToRead
+      });
     }
+
+    return rules;
   },
 
+
   /**
    * Helper function for getApplied and addNewRule that fetches a set of
    * style properties that apply to the given node and associated rules
    * @param NodeActor node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
@@ -422,32 +456,36 @@ var PageStyleActor = protocol.ActorClass
    * @returns Object containing the list of rule entries, rule actors and
    *   stylesheet actors that applies to the given node and its associated
    *   rules.
    */
   getAppliedProps: function(node, entries, options) {
     if (options.inherited) {
       let parent = this.walker.parentNode(node);
       while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
-        this.addElementRules(parent, parent, options, entries);
+        entries = entries.concat(this._getAllElementRules(parent, parent, options));
         parent = this.walker.parentNode(parent);
       }
     }
 
     if (options.matchedSelectors) {
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
         }
 
         let domRule = entry.rule.rawRule;
         let selectors = CssLogic.getSelectors(domRule);
         let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;
+
+        // XXX: uncomment after bug 1037519 lands
+        // let {pseudoToRead,elementToRead} = CssLogic.getStyleableElementAndPseudo(element);
         entry.matchedSelectors = [];
         for (let i = 0; i < selectors.length; i++) {
+          // if (DOMUtils.selectorMatchesElement(elementToRead, domRule, i, pseudoToRead)) {
           if (DOMUtils.selectorMatchesElement(element, domRule, i)) {
             entry.matchedSelectors.push(selectors[i]);
           }
         }
       }
     }
 
     let rules = new Set;
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -174,44 +174,22 @@ CssLogic.prototype = {
     }
 
     this._matchedRules = null;
     this._matchedSelectors = null;
     let win = this.viewedDocument.defaultView;
 
     // Handle computed styles on pseudo by reading style rules
     // on the parent node with proper pseudo arg to getComputedStyle.
-    let {elementToRead, pseudoToRead} = this.getStyleAndPseudoElements(this.viewedElement);
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(this.viewedElement);
 
     this._computedStyle = win.getComputedStyle(elementToRead, pseudoToRead);
   },
 
   /**
-   * XXX
-   * @returns {Object}
-   *            - elementToRead
-   *            - pseudoToRead
-   */
-  getStyleAndPseudoElements: function(node) {
-    let elementToRead = node;
-    let pseudoToRead = null;
-    if (node.nodeName == "_moz_generated_content_before") {
-      elementToRead = node.parentNode;
-      pseudoToRead = ":before";
-    } else if (node.nodeName == "_moz_generated_content_after") {
-      elementToRead = node.parentNode;
-      pseudoToRead = ":after";
-    }
-    return {
-      elementToRead: elementToRead,
-      pseudoToRead: pseudoToRead
-    };
-  },
-
-  /**
    * Get the source filter.
    * @returns {string} The source filter being used.
    */
   get sourceFilter() {
     return this._sourceFilter;
   },
 
   /**
@@ -611,17 +589,17 @@ CssLogic.prototype = {
 
     do {
       let status = this.viewedElement === element ?
                    CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
 
       try {
         // Handle finding rules on pseudo by reading style rules
         // on the parent node with proper pseudo arg to getCSSStyleRules.
-        let {elementToRead, pseudoToRead} = this.getStyleAndPseudoElements(element);
+        let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(element);
         domRules = domUtils.getCSSStyleRules(elementToRead, pseudoToRead);
       } catch (ex) {
         Services.console.
           logStringMessage("CL__buildMatchedRules error: " + ex);
         continue;
       }
 
       // getCSSStyleRules can return null with a shadow DOM element.
@@ -753,16 +731,40 @@ CssLogic.getSelectors = function CssLogi
   let len = domUtils.getSelectorCount(aDOMRule);
   for (let i = 0; i < len; i++) {
     let text = domUtils.getSelectorText(aDOMRule, i);
     selectors.push(text);
   }
   return selectors;
 }
 
+
+
+/**
+ * XXX
+ * @returns {Object}
+ *            - elementToRead
+ *            - pseudoToRead
+ */
+CssLogic.getStyleableElementAndPseudo = function(node) {
+  let elementToRead = node;
+  let pseudoToRead = null;
+  if (node.nodeName == "_moz_generated_content_before") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":before";
+  } else if (node.nodeName == "_moz_generated_content_after") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":after";
+  }
+  return {
+    elementToRead: elementToRead,
+    pseudoToRead: pseudoToRead
+  };
+},
+
 /**
  * Memonized lookup of a l10n string from a string bundle.
  * @param {string} aName The key to lookup.
  * @returns A localized version of the given key.
  */
 CssLogic.l10n = function(aName) CssLogic._strings.GetStringFromName(aName);
 
 DevToolsUtils.defineLazyGetter(CssLogic, "_strings", function() Services.strings
