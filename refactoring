# HG changeset patch
# Parent 93142ba4638c70620596bf0b6185c372399718c9
# User Brian Grinstead <bgrinstead@mozilla.com>
refactoring for anon-content based on feedback

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -580,17 +580,17 @@ InspectorPanel.prototype = {
     return null;
   },
 
   /**
    * Disable the delete item if needed. Update the pseudo classes.
    */
   _setupNodeMenu: function InspectorPanel_setupNodeMenu() {
     let isSelectionElement = this.selection.isElementNode() &&
-                             !this.selection.isPseudoElementNode;
+                             !this.selection.isPseudoElementNode();
 
     // Set the pseudo classes
     for (let name of ["hover", "active", "focus"]) {
       let menu = this.panelDoc.getElementById("node-menu-pseudo-" + name);
 
       if (isSelectionElement) {
         let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
         menu.setAttribute("checked", checked);
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -1273,16 +1273,18 @@ MarkupView.prototype = {
  *
  * @param MarkupView aMarkupView
  *        The markup view that owns this container.
  * @param NodeFront aNode
  *        The node to display.
  * @param Inspector aInspector
  *        The inspector tool container the markup-view
  */
+
+
 function MarkupContainer(aMarkupView, aNode, aInspector) {
   this.markup = aMarkupView;
   this.doc = this.markup.doc;
   this.undo = this.markup.undo;
   this.node = aNode;
   this._inspector = aInspector;
 
   if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE) {
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1751,17 +1751,21 @@ function RuleEditor(aRuleView, aRule) {
   this._onSelectorDone = this._onSelectorDone.bind(this);
 
   this._create();
 }
 
 RuleEditor.prototype = {
   get isSelectorEditable() {
     let toolbox = this.ruleView.inspector.toolbox;
-    return toolbox.target.client.traits.selectorEditable;
+    let trait = toolbox.target.client.traits.selectorEditable;
+
+    // Do not allow editing pseudo element selectors until we can
+    // detect mutations on them in Bug 1034110.
+    return trait && !this.rule.elementStyle.element.isPseudoElement;
   },
 
   _create: function() {
     this.element = this.doc.createElementNS(HTML_NS, "div");
     this.element.className = "ruleview-rule theme-separator";
     this.element.setAttribute("uneditable", !this.isEditable);
     this.element._ruleEditor = this;
     if (this.rule.pseudoElement) {
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -126,27 +126,28 @@ function getNode(nodeOrSelector) {
   return typeof nodeOrSelector === "string" ?
     content.document.querySelector(nodeOrSelector) :
     nodeOrSelector;
 }
 
 /**
  * Set the inspector's current selection to a node or to the first match of the
  * given css selector
+ * @param {String|DOMNode|NodeFront} data The node to select.  If it is a string
+ * or DOMNode it will not be remote safe - using a NodeFront is safer.
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @param {String} reason Defaults to "test" which instructs the inspector not
  * to highlight the node upon selection
- * @param {String} reason Defaults to "test" which instructs the inspector not to highlight the node upon selection
  * @return a promise that resolves when the inspector is updated with the new
  * node
  */
-function selectNode(nodeOrSelector, inspector, reason="test") {
-  info("Selecting the node " + nodeOrSelector);
-  let node = getNode(nodeOrSelector);
+function selectNode(data, inspector, reason="test") {
+  info("Selecting the node " + data);
+  let node = getNode(data);
   let updated = inspector.once("inspector-updated");
   if (node._form) {
     inspector.selection.setNodeFront(node, reason);
   } else {
     inspector.selection.setNode(node, reason);
   }
   return updated;
 }
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -951,24 +951,30 @@ BoxModelHighlighter.prototype = Heritage
   _updateInfobar: function() {
     if (!this.currentNode) {
       return;
     }
 
     let node = this.currentNode;
     let info = this.nodeInfo;
 
+    // If this is a ::before or ::after, then reset node to the
+    // parent and append ::before/::after onto the pseudoClassesBox.
+    let pseudoElement = null;
+    if (node.tagName === "_moz_generated_content_before") {
+      pseudoElement = "::before";
+      node = this.layoutHelpers.getRootBindingParent(node);
+    } else if (node.tagName === "_moz_generated_content_after") {
+      pseudoElement = "::after";
+      node = this.layoutHelpers.getRootBindingParent(node);
+    }
+
     // Update the tag, id, classes, pseudo-classes and dimensions only if they
     // changed to avoid triggering paint events
     let tagName = node.tagName;
-    if (tagName === "_moz_generated_content_before") {
-      tagName = "::before";
-    } else if (tagName === "_moz_generated_content_after") {
-      tagName = "::after";
-    }
     if (info.tagNameLabel.textContent !== tagName) {
       info.tagNameLabel.textContent = tagName;
     }
 
     let id = node.id ? "#" + node.id : "";
     if (info.idLabel.textContent !== id) {
       info.idLabel.textContent = id;
     }
@@ -976,16 +982,21 @@ BoxModelHighlighter.prototype = Heritage
     let classList = (node.classList || []).length ? "." + [...node.classList].join(".") : "";
     if (info.classesBox.textContent !== classList) {
       info.classesBox.textContent = classList;
     }
 
     let pseudos = PSEUDO_CLASSES.filter(pseudo => {
       return DOMUtils.hasPseudoClassLock(node, pseudo);
     }, this).join("");
+
+    if (pseudoElement) {
+      pseudos += pseudoElement;
+    }
+
     if (info.pseudoClassesBox.textContent !== pseudos) {
       info.pseudoClassesBox.textContent = pseudos;
     }
 
     let rect = node.getBoundingClientRect();
     let dim = Math.ceil(rect.width) + " x " + Math.ceil(rect.height);
     if (info.dimensionBox.textContent !== dim) {
       info.dimensionBox.textContent = dim;
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -18,18 +18,21 @@ loader.lazyGetter(this, "CssLogic", () =
 loader.lazyGetter(this, "DOMUtils", () => Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils));
 
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
-const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":-moz-selection"];
+const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
 exports.PSEUDO_ELEMENTS = PSEUDO_ELEMENTS;
+const PSEUDO_ELEMENTS_TO_READ = PSEUDO_ELEMENTS.filter(pseudo => {
+  return pseudo !== ":before" && pseudo !== ":after";
+});
 
 // Predeclare the domnode actor type for use in requests.
 types.addActorType("domnode");
 
 // Predeclare the domstylerule actor type
 types.addActorType("domstylerule");
 
 /**
@@ -297,17 +300,17 @@ var PageStyleActor = protocol.ActorClass
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSeletors`: Include an array of specific selectors that
    *     caused this rule to match its node.
    */
   getApplied: method(function(node, options) {
     let entries = [];
-    this.addElementRules(node, undefined, options, entries);
+    entries = entries.concat(this._getAllElementRules(node, undefined, options));
     return this.getAppliedProps(node, entries, options);
   }, {
     request: {
       node: Arg(0, "domnode"),
       inherited: Option(1, "boolean"),
       matchedSelectors: Option(1, "boolean"),
       filter: Option(1, "string")
     },
@@ -323,90 +326,121 @@ var PageStyleActor = protocol.ActorClass
   /**
    * Helper function for getApplied, adds all the rules from a given
    * element. See getApplied for documentation on parameters.
    * @param NodeActor node
    * @param bool inherited
    * @param object options
    * @param Array rules (modifies this instead of returning)
    */
-  addElementRules: function(node, inherited, options, rules)
+  _getAllElementRules: function(node, inherited, options)
   {
-    let element = node.rawNode;
-    let pseudoElements = inherited ? [null] : [null, ...PSEUDO_ELEMENTS];
-    let form = node.form();
-    let isBeforeOrAfter = form.isBeforePseudoElement ||
-                          form.isAfterPseudoElement;
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(node.rawNode);
+    let rules = [];
 
-    // If it is before or after, then we don't want to get styles for
-    // this element.  Want to get it for the parent with the corresponding
-    // pseudo.  Then we want to lie to the view and tell it that it isn't a pseudo
-    // style so that it shows up normally.
-    if (isBeforeOrAfter) {
-      element = element.parentNode;
-      pseudoElements = [form.isBeforePseudoElement ? ":before" : ":after"];
+    if (!elementToRead || !elementToRead.style) {
+      return rules;
     }
 
-    if (!element || !element.style) {
-      return;
-    }
+    let elementStyle = this._styleRef(elementToRead);
+    let showElementStyles = !inherited && !pseudoToRead;
+    let showInheritedStyles = inherited && this._hasInheritedProps(elementToRead.style);
 
-    let elementStyle = this._styleRef(element);
-    let showInlineStyles = !inherited && !isBeforeOrAfter;
-    let showInheritedStyles = inherited && this._hasInheritedProps(element.style);
-
-    if (showInlineStyles || showInheritedStyles) {
+    // First any inline styles
+    if (showElementStyles) {
       rules.push({
         rule: elementStyle,
-        inherited: inherited,
       });
     }
 
-    for (let pseudo of pseudoElements) {
+    // Now any inherited styles
+    if (showInheritedStyles) {
+      rules.push({
+        rule: elementStyle,
+        inherited: inherited
+      });
+    }
 
-      // Get the styles that apply to the element.
-      let domRules = DOMUtils.getCSSStyleRules(element, pseudo);
-      if (!domRules) {
+    // Add normal rules.  Typically this is passing in the node passed into the
+    // function, unless if that node was ::before/::after.  In which case,
+    // it will pass in the parentNode along with "::before"/"::after".
+    this._getElementRules(elementToRead, pseudoToRead, inherited, options).forEach((rule) => {
+      // The only case when there would be a pseudo here is ::before/::after,
+      // and in this case we want to tell the view that it belongs to the
+      // element (which is a _moz_generated_content native anonymous element).
+      rule.pseudoElement = null;
+      rules.push(rule);
+    });
+
+    // Now any pseudos (except for ::before / ::after, which was handled as
+    // a 'normal rule' above.
+    if (showElementStyles) {
+      for (let pseudo of PSEUDO_ELEMENTS_TO_READ) {
+        this._getElementRules(elementToRead, pseudo, inherited, options).forEach((rule) => {
+          rules.push(rule);
+        });
+      }
+    }
+
+    return rules;
+  },
+
+  /**
+   * Helper function for _getAllElementRules, returns the rules from a given
+   * element. See getApplied for documentation on parameters.
+   * @param DOMNode elementToRead
+   * @param string pseudoToRead
+   * @param DOMNode inherited
+   * @param object options
+   *
+   * @returns Array rules
+   */
+  _getElementRules: function (elementToRead, pseudoToRead, inherited, options) {
+    let domRules = DOMUtils.getCSSStyleRules(elementToRead, pseudoToRead);
+    if (!domRules) {
+      return [];
+    }
+
+    let rules = [];
+
+    // getCSSStyleRules returns ordered from least-specific to
+    // most-specific.
+    for (let i = domRules.Count() - 1; i >= 0; i--) {
+      let domRule = domRules.GetElementAt(i);
+
+      let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
+
+      if (isSystem && options.filter != CssLogic.FILTER.UA) {
         continue;
       }
 
-      // getCSSStyleRules returns ordered from least-specific to
-      // most-specific.
-      for (let i = domRules.Count() - 1; i >= 0; i--) {
-        let domRule = domRules.GetElementAt(i);
-
-        let isSystem = !CssLogic.isContentStylesheet(domRule.parentStyleSheet);
-
-        if (isSystem && options.filter != CssLogic.FILTER.UA) {
+      if (inherited) {
+        // Don't include inherited rules if none of its properties
+        // are inheritable.
+        let hasInherited = Array.prototype.some.call(domRule.style, prop => {
+          return DOMUtils.isInheritedProperty(prop);
+        });
+        if (!hasInherited) {
           continue;
         }
-
-        if (inherited) {
-          // Don't include inherited rules if none of its properties
-          // are inheritable.
-          let hasInherited = Array.prototype.some.call(domRule.style, prop => {
-            return DOMUtils.isInheritedProperty(prop);
-          });
-          if (!hasInherited) {
-            continue;
-          }
-        }
-
-        let ruleActor = this._styleRef(domRule);
-        rules.push({
-          rule: ruleActor,
-          inherited: inherited,
-          pseudoElement: isBeforeOrAfter ? null : pseudo,
-          isSystem: isSystem
-        });
       }
 
+      let ruleActor = this._styleRef(domRule);
+      rules.push({
+        rule: ruleActor,
+        inherited: inherited,
+        isSystem: isSystem,
+        pseudoElement: pseudoToRead
+      });
     }
+
+    return rules;
   },
 
+
   /**
    * Helper function for getApplied and addNewRule that fetches a set of
    * style properties that apply to the given node and associated rules
    * @param NodeActor node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
@@ -422,30 +456,31 @@ var PageStyleActor = protocol.ActorClass
    * @returns Object containing the list of rule entries, rule actors and
    *   stylesheet actors that applies to the given node and its associated
    *   rules.
    */
   getAppliedProps: function(node, entries, options) {
     if (options.inherited) {
       let parent = this.walker.parentNode(node);
       while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
-        this.addElementRules(parent, parent, options, entries);
+        entries = entries.concat(this._getAllElementRules(parent, parent, options));
         parent = this.walker.parentNode(parent);
       }
     }
 
     if (options.matchedSelectors) {
       for (let entry of entries) {
         if (entry.rule.type === ELEMENT_STYLE) {
           continue;
         }
 
         let domRule = entry.rule.rawRule;
         let selectors = CssLogic.getSelectors(domRule);
         let element = entry.inherited ? entry.inherited.rawNode : node.rawNode;
+
         entry.matchedSelectors = [];
         for (let i = 0; i < selectors.length; i++) {
           if (DOMUtils.selectorMatchesElement(element, domRule, i)) {
             entry.matchedSelectors.push(selectors[i]);
           }
         }
       }
     }
diff --git a/toolkit/devtools/styleinspector/css-logic.js b/toolkit/devtools/styleinspector/css-logic.js
--- a/toolkit/devtools/styleinspector/css-logic.js
+++ b/toolkit/devtools/styleinspector/css-logic.js
@@ -174,44 +174,22 @@ CssLogic.prototype = {
     }
 
     this._matchedRules = null;
     this._matchedSelectors = null;
     let win = this.viewedDocument.defaultView;
 
     // Handle computed styles on pseudo by reading style rules
     // on the parent node with proper pseudo arg to getComputedStyle.
-    let {elementToRead, pseudoToRead} = this.getStyleAndPseudoElements(this.viewedElement);
+    let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(this.viewedElement);
 
     this._computedStyle = win.getComputedStyle(elementToRead, pseudoToRead);
   },
 
   /**
-   * XXX
-   * @returns {Object}
-   *            - elementToRead
-   *            - pseudoToRead
-   */
-  getStyleAndPseudoElements: function(node) {
-    let elementToRead = node;
-    let pseudoToRead = null;
-    if (node.nodeName == "_moz_generated_content_before") {
-      elementToRead = node.parentNode;
-      pseudoToRead = ":before";
-    } else if (node.nodeName == "_moz_generated_content_after") {
-      elementToRead = node.parentNode;
-      pseudoToRead = ":after";
-    }
-    return {
-      elementToRead: elementToRead,
-      pseudoToRead: pseudoToRead
-    };
-  },
-
-  /**
    * Get the source filter.
    * @returns {string} The source filter being used.
    */
   get sourceFilter() {
     return this._sourceFilter;
   },
 
   /**
@@ -611,17 +589,17 @@ CssLogic.prototype = {
 
     do {
       let status = this.viewedElement === element ?
                    CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
 
       try {
         // Handle finding rules on pseudo by reading style rules
         // on the parent node with proper pseudo arg to getCSSStyleRules.
-        let {elementToRead, pseudoToRead} = this.getStyleAndPseudoElements(element);
+        let {elementToRead, pseudoToRead} = CssLogic.getStyleableElementAndPseudo(element);
         domRules = domUtils.getCSSStyleRules(elementToRead, pseudoToRead);
       } catch (ex) {
         Services.console.
           logStringMessage("CL__buildMatchedRules error: " + ex);
         continue;
       }
 
       // getCSSStyleRules can return null with a shadow DOM element.
@@ -753,16 +731,40 @@ CssLogic.getSelectors = function CssLogi
   let len = domUtils.getSelectorCount(aDOMRule);
   for (let i = 0; i < len; i++) {
     let text = domUtils.getSelectorText(aDOMRule, i);
     selectors.push(text);
   }
   return selectors;
 }
 
+
+
+/**
+ * XXX
+ * @returns {Object}
+ *            - elementToRead
+ *            - pseudoToRead
+ */
+CssLogic.getStyleableElementAndPseudo = function(node) {
+  let elementToRead = node;
+  let pseudoToRead = null;
+  if (node.nodeName == "_moz_generated_content_before") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":before";
+  } else if (node.nodeName == "_moz_generated_content_after") {
+    elementToRead = node.parentNode;
+    pseudoToRead = ":after";
+  }
+  return {
+    elementToRead: elementToRead,
+    pseudoToRead: pseudoToRead
+  };
+},
+
 /**
  * Memonized lookup of a l10n string from a string bundle.
  * @param {string} aName The key to lookup.
  * @returns A localized version of the given key.
  */
 CssLogic.l10n = function(aName) CssLogic._strings.GetStringFromName(aName);
 
 DevToolsUtils.defineLazyGetter(CssLogic, "_strings", function() Services.strings
