# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  81d0ebe62a21093e03230e99b5e1d8b4b1d0e3a9

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -143,44 +143,42 @@ class MozTextLabel extends MozElementMix
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey(force) {
     // Skip doing any DOM manipulation whenever possible:
     let accessKey = this.accessKey;
     if (!gUnderlineAccesskey || this._lastFormattedAccessKey == accessKey || !this.textContent || this.isHiddenHighlightable) {
       return;
     }
-
+console.log("Formatting accesskey", this)
     // Special case for hidden labels, wait to render them until idle:
     if (!force && this.closest("groupbox[hidden]")) {
       idleLabelsToRender.add(this);
       idleRenderLabels();
       return;
     }
 
     this._lastFormattedAccessKey = accessKey;
 
 
     if (!this.accessKeyParens) {
       this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
       this.appendChild(this.accessKeyParens);
+    } else {
+      this.accessKeyParens.textContent = "";
     }
 
-    var afterLabel = this.accessKeyParens;
-    afterLabel.textContent = "";
-
-    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
-    if (oldAccessKey) { // Clear old accesskey
-      mergeElement(oldAccessKey);
+    if (this.accessKeySpan) {
+      mergeElement(this.accessKeySpan);
+      this.accessKeySpan = null;
     }
 
-    var oldHiddenSpan =
-      this.getElementsByAttribute("class", "hiddenColon").item(0);
-    if (oldHiddenSpan) {
-      mergeElement(oldHiddenSpan);
+    if (this.hiddenSpan) {
+      mergeElement(this.hiddenSpan);
+      this.hiddenSpan = null;
     }
 
     // If we used to have an accessKey but not anymore, we're done here
     if (!accessKey) {
       return;
     }
 
     var labelText = this.textContent;
@@ -191,56 +189,56 @@ class MozTextLabel extends MozElementMix
         accessKeyIndex =
           labelText.toUpperCase().indexOf(accessKey.toUpperCase());
       }
     } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
       accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
     }
 
     const HTML_NS = "http://www.w3.org/1999/xhtml";
-    var span = document.createElementNS(HTML_NS, "span");
-    span.className = "accesskey";
+    this.accessKeySpan = document.createElementNS(HTML_NS, "span");
+    this.accessKeySpan.className = "accesskey";
 
     // Note that if you change the following code, see the comment of
     // nsTextBoxFrame::UpdateAccessTitle.
 
     // If accesskey is not in string, append in parentheses
     if (accessKeyIndex < 0) {
       // If end is colon, we should insert before colon.
       // i.e., "label:" -> "label(X):"
       var colonHidden = false;
       if (/:$/.test(labelText)) {
         labelText = labelText.slice(0, -1);
-        var hiddenSpan = document.createElementNS(HTML_NS, "span");
-        hiddenSpan.className = "hiddenColon";
-        hiddenSpan.style.display = "none";
+        this.hiddenSpan = document.createElementNS(HTML_NS, "span");
+        this.hiddenSpan.className = "hiddenColon";
+        this.hiddenSpan.style.display = "none";
         // Hide the last colon by using span element.
         // I.e., label<span style="display:none;">:</span>
-        wrapChar(this, hiddenSpan, labelText.length);
+        wrapChar(this, this.hiddenSpan, labelText.length);
         colonHidden = true;
       }
       // If end is space(U+20),
       // we should not add space before parentheses.
       var endIsSpace = false;
       if (/ $/.test(labelText)) {
         endIsSpace = true;
       }
       if (gInsertSeparator && !endIsSpace)
-        afterLabel.textContent = " (";
+        this.accessKeyParens.textContent = " (";
       else
-        afterLabel.textContent = "(";
-      span.textContent = accessKey.toUpperCase();
-      afterLabel.appendChild(span);
+        this.accessKeyParens.textContent = "(";
+      this.accessKeySpan.textContent = accessKey.toUpperCase();
+      this.accessKeyParens.appendChild(this.accessKeySpan);
       if (!colonHidden)
-        afterLabel.appendChild(document.createTextNode(")"));
+        this.accessKeyParens.appendChild(document.createTextNode(")"));
       else
-        afterLabel.appendChild(document.createTextNode("):"));
+        this.accessKeyParens.appendChild(document.createTextNode("):"));
       return;
     }
-    wrapChar(this, span, accessKeyIndex);
+    wrapChar(this, this.accessKeySpan, accessKeyIndex);
   }
 
   open(aEvent) {
     if (!this.isTextLink) {
       return;
     }
 
     var href = this.href;
@@ -343,17 +341,17 @@ function wrapChar(parent, element, index
   element.appendChild(node);
 }
 
 let gInsertSeparator;
 let gUnderlineAccesskey;
 let gAlwaysAppendAccessKey = false;
 function setGlobalAccessKeyFormattingState() {
   if (gUnderlineAccesskey === undefined) {
-    gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+    gUnderlineAccesskey = true; // Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
   }
   if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
     return;
   }
   try {
     const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
     const prefNameInsertSeparator =
       "intl.menuitems.insertseparatorbeforeaccesskeys";
