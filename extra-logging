# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  3b0e85d537381b6013609ed42fb5bd286d757cb8
Extra logging for wa

diff --git a/devtools/client/webaudioeditor/test/browser_wa_destroy-node-01.js b/devtools/client/webaudioeditor/test/browser_wa_destroy-node-01.js
--- a/devtools/client/webaudioeditor/test/browser_wa_destroy-node-01.js
+++ b/devtools/client/webaudioeditor/test/browser_wa_destroy-node-01.js
@@ -4,16 +4,18 @@
 /**
  * Tests that the destruction node event is fired and that the nodes are no
  * longer stored internally in the tool, that the graph is updated properly, and
  * that selecting a soon-to-be dead node clears the inspector.
  *
  * All done in one test since this test takes a few seconds to clear GC.
  */
 
+SimpleTest.requestCompleteLog();
+
 add_task(function* () {
   // Use a longer timeout as garbage collection event
   // can be unpredictable.
   requestLongerTimeout(2);
 
   let { target, panel } = yield initWebAudioEditor(DESTROY_NODES_URL);
   let { panelWin } = panel;
   let { gFront, $, $$, gAudioNodes } = panelWin;
@@ -29,28 +31,37 @@ add_task(function* () {
   let [created] = yield Promise.all([
     getNSpread(gAudioNodes, "add", 13),
     waitForGraphRendered(panelWin, 13, 2)
   ]);
 
   // Flatten arrays of event arguments and take the first (AudioNodeModel)
   // and get its ID.
   let actorIDs = created.map(ev => ev[0].id);
-
+  console.log("XXXXXX actor ids: ", actorIDs);
+  console.time("clickGraphNode");
   // Click a soon-to-be dead buffer node
   yield clickGraphNode(panelWin, actorIDs[5]);
+  console.timeEnd("clickGraphNode");
 
+  console.time("forceCC");
+  // console.log("clicked");
+  // yield new Promise(r=>setTimeout(r, 2000));
   // Wait for a tick before gc to prevent this test from intermittent timeout
   // where the node never get collected.
-  yield DevToolsUtils.waitForTick();
+  // yield DevToolsUtils.waitForTick();
   forceCC();
+  console.timeEnd("forceCC");
 
+  console.time("destruction");
   // Wait for destruction and graph to re-render
   yield Promise.all([destroyed, waitForGraphRendered(panelWin, 3, 2)]);
+  console.timeEnd("destruction");
 
+  // yield new Promise(r=>r);
   // Test internal storage
   is(panelWin.gAudioNodes.length, 3, "All nodes should be GC'd except one gain, osc and dest node.");
 
   // Test graph rendering
   ok(findGraphNode(panelWin, actorIDs[0]), "dest should be in graph");
   ok(findGraphNode(panelWin, actorIDs[1]), "osc should be in graph");
   ok(findGraphNode(panelWin, actorIDs[2]), "gain should be in graph");
 
diff --git a/devtools/client/webaudioeditor/test/head.js b/devtools/client/webaudioeditor/test/head.js
--- a/devtools/client/webaudioeditor/test/head.js
+++ b/devtools/client/webaudioeditor/test/head.js
@@ -416,19 +416,22 @@ function countGraphObjects(win) {
     edges: win.document.querySelectorAll(".edgePaths > .edgePath").length
   };
 }
 
 /**
 * Forces cycle collection and GC, used in AudioNode destruction tests.
 */
 function forceCC() {
-  SpecialPowers.DOMWindowUtils.cycleCollect();
-  SpecialPowers.DOMWindowUtils.garbageCollect();
-  SpecialPowers.DOMWindowUtils.garbageCollect();
+  ContentTask.spawn(gBrowser.selectedBrowser, {}, function*() {
+    Cu.forceGC();
+    Cu.forceCC();
+    Cu.forceGC();
+    Cu.forceCC();
+  });
 }
 
 /**
  * Takes a `values` array of automation value entries,
  * looking for the value at `time` seconds, checking
  * to see if the value is close to `expected`.
  */
 function checkAutomationValue(values, time, expected) {
diff --git a/devtools/client/webaudioeditor/views/context.js b/devtools/client/webaudioeditor/views/context.js
--- a/devtools/client/webaudioeditor/views/context.js
+++ b/devtools/client/webaudioeditor/views/context.js
@@ -266,16 +266,18 @@ var ContextView = {
     this.draw();
   },
 
   /**
    * Called when `gAudioNodes` fires an event -- most events (listed
    * in GRAPH_REDRAW_EVENTS) qualify as a redraw event.
    */
   _onEvent: function (eventName, ...args) {
+    console.log("Webaudio got event", eventName, args);
+
     // If bypassing, just toggle the class on the SVG node
     // rather than rerendering everything
     if (eventName === "bypass") {
       this._bypassNode.apply(this, args);
     }
     if (~GRAPH_REDRAW_EVENTS.indexOf(eventName)) {
       this.draw();
     }
diff --git a/devtools/server/actors/webaudio.js b/devtools/server/actors/webaudio.js
--- a/devtools/server/actors/webaudio.js
+++ b/devtools/server/actors/webaudio.js
@@ -610,16 +610,17 @@ var WebAudioActor = exports.WebAudioActo
    * created), so make a new actor and store that.
    */
   _getActorByNativeID: function (nativeID) {
     // Ensure we have a Number, rather than a string
     // return via notification.
     nativeID = ~~nativeID;
 
     let actorID = this._nativeToActorID.get(nativeID);
+    console.log("Getting native actor", this._nativeToActorID, this._nativeToActorID.get(nativeID));
     let actor = actorID != null ? this.conn.getActor(actorID) : null;
     return actor;
   },
 
   /**
    * Called on first audio node creation, signifying audio context usage
    */
   _onStartContext: function () {
@@ -683,16 +684,18 @@ var WebAudioActor = exports.WebAudioActo
 
   /** Called when `webaudio-node-demise` is triggered,
    * and emits the associated actor to the front if found.
    */
   _onDestroyNode: function ({data}) {
     // Cast to integer.
     let nativeID = ~~data;
 
+    console.log("_onDestroyNode", data, this._getActorByNativeID(nativeID), this._getActorByNativeID);
+
     let actor = this._getActorByNativeID(nativeID);
 
     // If actorID exists, emit; in the case where we get demise
     // notifications for a document that no longer exists,
     // the mapping should not be found, so we do not emit an event.
     if (actor) {
       this._nativeToActorID.delete(nativeID);
       emit(this, "destroy-node", actor);
