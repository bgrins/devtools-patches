# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  19d8a9565a3efb43500ba0aabf3f0da21add09af
Extra logging for netmonitor test

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -3,16 +3,18 @@
 
 ///////////////////
 //
 // Whitelisting this test.
 // As part of bug 1077403, the leaking uncaught rejection should be fixed.
 //
 thisTestLeaksUncaughtRejectionsAndShouldBeFixed("TypeError: aValue.content is undefined");
 
+SimpleTest.requestCompleteLog();
+
 /**
  * Bug 863102 - Automatically scroll down upon new network requests.
  */
 add_task(function*() {
   requestLongerTimeout(2);
   let monitor, debuggee, requestsContainer, scrollTop;
 
   let [aTab, aDebuggee, aMonitor] = yield initNetMonitor(INFINITE_GET_URL);
@@ -24,63 +26,82 @@ add_task(function*() {
   ok(!!requestsContainer, "Container element exists as expected.");
 
   // (1) Check that the scroll position is maintained at the bottom
   // when the requests overflow the vertical size of the container.
   yield waitForRequestsToOverflowContainer(monitor, requestsContainer);
   yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
 
+  info("Brian waiting 0");
+
   // (2) Now set the scroll position somewhere in the middle and check
   // that additional requests do not change the scroll position.
   let children = requestsContainer.childNodes;
   let middleNode = children.item(children.length / 2);
   middleNode.scrollIntoView();
   ok(!scrolledToBottom(requestsContainer), "Not scrolled to bottom.");
+  info("Brian waiting 1");
   scrollTop = requestsContainer.scrollTop; // save for comparison later
-  yield waitForNetworkEvents(monitor, 8);
+  info("Brian waiting 2");
+  yield waitForNetworkEvents(monitor, 2);
+  info("Brian waiting 3");
   yield waitSomeTime();
+  info("Brian waiting 4");
   is(requestsContainer.scrollTop, scrollTop, "Did not scroll.");
+  info("Brian waiting 5");
 
   // (3) Now set the scroll position back at the bottom and check that
   // additional requests *do* cause the container to scroll down.
   requestsContainer.scrollTop = requestsContainer.scrollHeight;
+  yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Set scroll position to bottom.");
-  yield waitForNetworkEvents(monitor, 8);
+  info("Brian waiting 6");
+  yield waitForNetworkEvents(monitor, 2);
+  info("Brian waiting 7");
   yield waitForScroll(monitor);
+  info("Brian waiting 8");
   ok(scrolledToBottom(requestsContainer), "Still scrolled to bottom.");
+  info("Brian waiting 9");
 
   // (4) Now select an item in the list and check that additional requests
   // do not change the scroll position.
   monitor.panelWin.NetMonitorView.RequestsMenu.selectedIndex = 0;
-  yield waitForNetworkEvents(monitor, 8);
+  info("Brian waiting 10");
+  yield waitForNetworkEvents(monitor, 2);
+  info("Brian waiting 11");
   yield waitSomeTime();
+  info("Brian waiting 12");
   is(requestsContainer.scrollTop, 0, "Did not scroll.");
+  info("Brian waiting 13");
 
   // Done: clean up.
   yield teardown(monitor);
 
+  info("Brian waiting 14");
   finish();
 
   function waitForRequestsToOverflowContainer(aMonitor, aContainer) {
-    return waitForNetworkEvents(aMonitor, 8).then(() => {
+    return waitForNetworkEvents(aMonitor, 2).then(() => {
       if (aContainer.scrollHeight > aContainer.clientHeight) {
         return promise.resolve();
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
       }
     });
   }
 
   function scrolledToBottom(aElement) {
     return aElement.scrollTop + aElement.clientHeight >= aElement.scrollHeight;
   }
 
   function waitSomeTime() {
+    info ("waitSomeTime entered");
     let waitSomeTime = promise.defer();
     setTimeout(waitSomeTime.resolve, 50); // Wait to make sure no scrolls happen
     return waitSomeTime.promise;
   }
 
   function waitForScroll(aMonitor) {
+    info ("Waiting for scroll event");
     return aMonitor._view.RequestsMenu.widget.once("scroll-to-bottom");
   }
 });
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -2,16 +2,17 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
+const {console} = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
 const {DeferredTask} = Cu.import("resource://gre/modules/DeferredTask.jsm", {});
 
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
 const SCROLL_FREQUENCY = 16;
@@ -114,16 +115,17 @@ SideMenuWidget.prototype = {
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
       // 4. The list should already be scrolled at the bottom.
       this.isScrolledToBottom();
 
+    console.log("SHOULD MAINTAIN SCROLL AT BOTTOM", maintainScrollAtBottom);
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
     if (maintainScrollAtBottom) {
       this.scrollToBottom();
     }
 
@@ -139,16 +141,17 @@ SideMenuWidget.prototype = {
    */
   isScrolledToBottom: function() {
     if (this._list.lastElementChild) {
       let domUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
                                 .getInterface(Ci.nsIDOMWindowUtils);
       let childRect = domUtils.getBoundsWithoutFlushing(this._list.lastElementChild);
       let listRect = domUtils.getBoundsWithoutFlushing(this._list);
 
+      console.log("CHECKING IF SCROLLED TO BOTTOM", childRect.height, childRect.top,  listRect.bottom, (childRect.height + childRect.top) < listRect.bottom);
       // Cheap way to check if it's scrolled all the way to the bottom.
       return (childRect.height + childRect.top) < listRect.bottom;
     }
 
     return false;
   },
 
   /**
