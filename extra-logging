# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  27215c225f856c794654570065406220b0b9401f
Extra logging for netmonitor test

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -3,16 +3,18 @@
 
 ///////////////////
 //
 // Whitelisting this test.
 // As part of bug 1077403, the leaking uncaught rejection should be fixed.
 //
 thisTestLeaksUncaughtRejectionsAndShouldBeFixed("TypeError: aValue.content is undefined");
 
+SimpleTest.requestCompleteLog();
+
 /**
  * Bug 863102 - Automatically scroll down upon new network requests.
  */
 add_task(function*() {
   requestLongerTimeout(2);
   let monitor, debuggee, requestsContainer, scrollTop;
 
   let [aTab, aDebuggee, aMonitor] = yield initNetMonitor(INFINITE_GET_URL);
@@ -24,63 +26,82 @@ add_task(function*() {
   ok(!!requestsContainer, "Container element exists as expected.");
 
   // (1) Check that the scroll position is maintained at the bottom
   // when the requests overflow the vertical size of the container.
   yield waitForRequestsToOverflowContainer(monitor, requestsContainer);
   yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
 
+  info("Brian waiting 0");
+
   // (2) Now set the scroll position somewhere in the middle and check
   // that additional requests do not change the scroll position.
   let children = requestsContainer.childNodes;
   let middleNode = children.item(children.length / 2);
   middleNode.scrollIntoView();
   ok(!scrolledToBottom(requestsContainer), "Not scrolled to bottom.");
+  info("Brian waiting 1");
   scrollTop = requestsContainer.scrollTop; // save for comparison later
-  yield waitForNetworkEvents(monitor, 8);
+  info("Brian waiting 2");
+  yield waitForNetworkEvents(monitor, 2);
+  info("Brian waiting 3");
   yield waitSomeTime();
+  info("Brian waiting 4");
   is(requestsContainer.scrollTop, scrollTop, "Did not scroll.");
+  info("Brian waiting 5");
 
   // (3) Now set the scroll position back at the bottom and check that
   // additional requests *do* cause the container to scroll down.
   requestsContainer.scrollTop = requestsContainer.scrollHeight;
+  yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Set scroll position to bottom.");
-  yield waitForNetworkEvents(monitor, 8);
+  info("Brian waiting 6");
+  yield waitForNetworkEvents(monitor, 2);
+  info("Brian waiting 7");
   yield waitForScroll(monitor);
+  info("Brian waiting 8");
   ok(scrolledToBottom(requestsContainer), "Still scrolled to bottom.");
+  info("Brian waiting 9");
 
   // (4) Now select an item in the list and check that additional requests
   // do not change the scroll position.
   monitor.panelWin.NetMonitorView.RequestsMenu.selectedIndex = 0;
-  yield waitForNetworkEvents(monitor, 8);
+  info("Brian waiting 10");
+  yield waitForNetworkEvents(monitor, 2);
+  info("Brian waiting 11");
   yield waitSomeTime();
+  info("Brian waiting 12");
   is(requestsContainer.scrollTop, 0, "Did not scroll.");
+  info("Brian waiting 13");
 
   // Done: clean up.
   yield teardown(monitor);
 
+  info("Brian waiting 14");
   finish();
 
   function waitForRequestsToOverflowContainer(aMonitor, aContainer) {
-    return waitForNetworkEvents(aMonitor, 8).then(() => {
+    return waitForNetworkEvents(aMonitor, 2).then(() => {
       if (aContainer.scrollHeight > aContainer.clientHeight) {
         return promise.resolve();
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
       }
     });
   }
 
   function scrolledToBottom(aElement) {
     return aElement.scrollTop + aElement.clientHeight >= aElement.scrollHeight;
   }
 
   function waitSomeTime() {
+    info ("waitSomeTime entered");
     let waitSomeTime = promise.defer();
     setTimeout(waitSomeTime.resolve, 50); // Wait to make sure no scrolls happen
     return waitSomeTime.promise;
   }
 
   function waitForScroll(aMonitor) {
+    info ("Waiting for scroll event");
     return aMonitor._view.RequestsMenu.widget.once("scroll-to-bottom");
   }
 });
