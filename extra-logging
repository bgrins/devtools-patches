# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  9a303d947bd08a517e0d5935fd8057fa2817c43f
Bug 1477005

diff --git a/devtools/shared/security/socket.js b/devtools/shared/security/socket.js
--- a/devtools/shared/security/socket.js
+++ b/devtools/shared/security/socket.js
@@ -10,17 +10,16 @@ var { Ci, Cc, CC, Cr } = require("chrome
 
 // Ensure PSM is initialized to support TLS sockets
 Cc["@mozilla.org/psm;1"].getService(Ci.nsISupports);
 
 var Services = require("Services");
 var promise = require("promise");
 var defer = require("devtools/shared/defer");
 var DevToolsUtils = require("devtools/shared/DevToolsUtils");
-var { dumpn, dumpv } = DevToolsUtils;
 loader.lazyRequireGetter(this, "WebSocketServer",
   "devtools/server/socket/websocket-server");
 loader.lazyRequireGetter(this, "DebuggerTransport",
   "devtools/shared/transport/transport", true);
 loader.lazyRequireGetter(this, "WebSocketDebuggerTransport",
   "devtools/shared/transport/websocket-transport");
 loader.lazyRequireGetter(this, "DebuggerServer",
   "devtools/server/main", true);
@@ -70,31 +69,38 @@ var DebuggerSocket = {};
  *        Defaults to a PROMPT instance if not supplied.
  * @param cert object (optional)
  *        The server's cert details.  Used with OOB_CERT authentication.
  * @return promise
  *         Resolved to a DebuggerTransport instance.
  */
 DebuggerSocket.connect = async function(settings) {
   // Default to PROMPT |Authenticator| instance if not supplied
+  console.log("DebuggerSocket.connect 1");
   if (!settings.authenticator) {
     settings.authenticator = new (Authenticators.get().Client)();
+    console.log("DebuggerSocket.connect 2");
   }
   _validateSettings(settings);
+  console.log("DebuggerSocket.connect 3", settings);
   // eslint-disable-next-line no-shadow
   const { host, port, encryption, authenticator, cert } = settings;
+  console.log("DebuggerSocket.connect 4", host, port, encryption, authenticator, cert);
   const transport = await _getTransport(settings);
+  console.log("DebuggerSocket.connect 5", transport);
   await authenticator.authenticate({
     host,
     port,
     encryption,
     cert,
     transport
   });
+  console.log("DebuggerSocket.connect 6");
   transport.connectionSettings = settings;
+  console.log("DebuggerSocket.connect 7");
   return transport;
 };
 
 /**
  * Validate that the connection settings have been set to a supported configuration.
  */
 function _validateSettings(settings) {
   const { encryption, webSocket, authenticator } = settings;
@@ -124,47 +130,54 @@ function _validateSettings(settings) {
  *        The server's cert details.  Used with OOB_CERT authentication.
  * @return transport DebuggerTransport
  *         A possible DevTools transport (if connection succeeded and streams
  *         are actually alive and working)
  */
 var _getTransport = async function(settings) {
   const { host, port, encryption, webSocket } = settings;
 
+  console.log("_getTransport 1");
   if (webSocket) {
     // Establish a connection and wait until the WebSocket is ready to send and receive
+    console.log("_getTransport 2");
     const socket = await new Promise((resolve, reject) => {
       const s = new WebSocket(`ws://${host}:${port}`);
       s.onopen = () => resolve(s);
       s.onerror = err => reject(err);
     });
 
     return new WebSocketDebuggerTransport(socket);
   }
 
+  console.log("_getTransport 3");
   let attempt = await _attemptTransport(settings);
   if (attempt.transport) {
+    console.log("_getTransport 4");
     // Success
     return attempt.transport;
   }
 
+  console.log("_getTransport 5");
   // If the server cert failed validation, store a temporary override and make
   // a second attempt.
   if (encryption && attempt.certError) {
     _storeCertOverride(attempt.s, host, port);
   } else {
     throw new Error("Connection failed");
   }
 
+  console.log("_getTransport 6");
   attempt = await _attemptTransport(settings);
   if (attempt.transport) {
     // Success
     return attempt.transport;
   }
 
+  console.log("_getTransport 7");
   throw new Error("Connection failed even after cert override");
 };
 
 /**
  * Make a single attempt to connect and create a DevTools transport.  This could
  * fail if the remote host is unreachable, for example.  If there is security
  * error due to the use of self-signed certs, you should make another attempt
  * after storing a cert override.
@@ -203,17 +216,17 @@ var _attemptTransport = async function(s
     certError = results.certError;
   } catch (e) {
     // For other unexpected errors, like NS_ERROR_CONNECTION_REFUSED, we reach
     // this block.
     input.close();
     output.close();
     throw e;
   }
-  dumpv("Server cert accepted? " + !certError);
+  console.log("Server cert accepted? " + !certError);
 
   // The |Authenticator| examines the connection as well and may determine it
   // should be dropped.
   alive = alive && authenticator.validateConnection({
     host: settings.host,
     port: settings.port,
     encryption: settings.encryption,
     cert: settings.cert,
@@ -440,21 +453,21 @@ SocketListener.prototype = {
         const file = nsFile(self.portOrPath);
         if (file.exists()) {
           file.remove(false);
         }
         self._socket.initWithFilename(file, parseInt("666", 8), backlog);
       }
       await self._setAdditionalSocketOptions();
       self._socket.asyncListen(self);
-      dumpn("Socket listening on: " + (self.port || self.portOrPath));
+      console.log("Socket listening on: " + (self.port || self.portOrPath));
     })().then(() => {
       this._advertise();
     }).catch(e => {
-      dumpn("Could not start debugging listener on '" + this.portOrPath +
+      console.log("Could not start debugging listener on '" + this.portOrPath +
             "': " + e);
       this.close();
     });
   },
 
   _advertise: function() {
     if (!this.discoverable || !this.port) {
       return;
@@ -545,17 +558,17 @@ SocketListener.prototype = {
   // nsIServerSocketListener implementation
 
   onSocketAccepted:
   DevToolsUtils.makeInfallible(function(socket, socketTransport) {
     new ServerSocketConnection(this, socketTransport);
   }, "SocketListener.onSocketAccepted"),
 
   onStopListening: function(socket, status) {
-    dumpn("onStopListening, status: " + status);
+    console.log("onStopListening, status: " + status);
   }
 
 };
 
 // Client must complete TLS handshake within this window (ms)
 loader.lazyGetter(this, "HANDSHAKE_TIMEOUT", () => {
   return Services.prefs.getIntPref("devtools.remote.tls-handshake-timeout");
 });
@@ -622,23 +635,28 @@ ServerSocketConnection.prototype = {
   },
 
   /**
    * This is the main authentication workflow.  If any pieces reject a promise,
    * the connection is denied.  If the entire process resolves successfully,
    * the connection is finally handed off to the |DebuggerServer|.
    */
   _handle() {
-    dumpn("Debugging connection starting authentication on " + this.address);
+    console.log("Debugging connection starting authentication on " + this.address);
     const self = this;
     (async function() {
+      console.log("_handle 1");
       self._listenForTLSHandshake();
+      console.log("_handle 2");
       await self._createTransport();
+      console.log("_handle 3");
       await self._awaitTLSHandshake();
+      console.log("_handle 4");
       await self._authenticate();
+      console.log("_handle 5");
     })().then(() => this.allow()).catch(e => this.deny(e));
   },
 
   /**
    * We need to open the streams early on, as that is required in the case of
    * TLS sockets to keep the handshake moving.
    */
   async _createTransport() {
@@ -691,28 +709,28 @@ ServerSocketConnection.prototype = {
                                         HANDSHAKE_TIMEOUT);
   },
 
   _awaitTLSHandshake() {
     return this._handshakeDeferred.promise;
   },
 
   _onHandshakeTimeout() {
-    dumpv("Client failed to complete TLS handshake");
+    console.log("Client failed to complete TLS handshake");
     this._handshakeDeferred.reject(Cr.NS_ERROR_NET_TIMEOUT);
   },
 
   // nsITLSServerSecurityObserver implementation
   onHandshakeDone(socket, clientStatus) {
     clearTimeout(this._handshakeTimeout);
     this._setSecurityObserver(null);
-    dumpv("TLS version:    " + clientStatus.tlsVersionUsed.toString(16));
-    dumpv("TLS cipher:     " + clientStatus.cipherName);
-    dumpv("TLS key length: " + clientStatus.keyLength);
-    dumpv("TLS MAC length: " + clientStatus.macLength);
+    console.log("TLS version:    " + clientStatus.tlsVersionUsed.toString(16));
+    console.log("TLS cipher:     " + clientStatus.cipherName);
+    console.log("TLS key length: " + clientStatus.keyLength);
+    console.log("TLS MAC length: " + clientStatus.macLength);
     this._clientCert = clientStatus.peerCert;
     /*
      * TODO: These rules should be really be set on the TLS socket directly, but
      * this would need more platform work to expose it via XPCOM.
      *
      * Enforcing cipher suites here would be a bad idea, as we want TLS
      * cipher negotiation to work correctly.  The server already allows only
      * Gecko's normal set of cipher suites.
@@ -752,31 +770,31 @@ ServerSocketConnection.prototype = {
     }
     let errorName = result;
     for (const name in Cr) {
       if (Cr[name] === result) {
         errorName = name;
         break;
       }
     }
-    dumpn("Debugging connection denied on " + this.address +
+    console.log("Debugging connection denied on " + this.address +
           " (" + errorName + ")");
     if (this._transport) {
       this._transport.hooks = null;
       this._transport.close(result);
     }
     this._socketTransport.close(result);
     this.destroy();
   },
 
   allow() {
     if (this._destroyed) {
       return;
     }
-    dumpn("Debugging connection allowed on " + this.address);
+    console.log("Debugging connection allowed on " + this.address);
     DebuggerServer._onConnection(this._transport);
     this.destroy();
   },
 
   destroy() {
     this._destroyed = true;
     clearTimeout(this._handshakeTimeout);
     this._setSecurityObserver(null);
