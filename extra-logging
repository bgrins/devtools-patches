# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  05a916de84fb6de611b69633b318bd800961c68a
Extra logging for netmonitor test

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -16,45 +16,61 @@ add_task(function*() {
   ok(!!requestsContainer, "Container element exists as expected.");
 
   // (1) Check that the scroll position is maintained at the bottom
   // when the requests overflow the vertical size of the container.
   yield waitForRequestsToOverflowContainer(monitor, requestsContainer);
   yield waitForScroll(monitor);
   ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
 
+  info("Brian waiting 0");
+
   // (2) Now set the scroll position somewhere in the middle and check
   // that additional requests do not change the scroll position.
   let children = requestsContainer.childNodes;
   let middleNode = children.item(children.length / 2);
   middleNode.scrollIntoView();
   ok(!scrolledToBottom(requestsContainer), "Not scrolled to bottom.");
+  info("Brian waiting 1");
   scrollTop = requestsContainer.scrollTop; // save for comparison later
+  info("Brian waiting 2");
   yield waitForNetworkEvents(monitor, 1);
+  info("Brian waiting 3");
   yield waitSomeTime();
+  info("Brian waiting 4");
   is(requestsContainer.scrollTop, scrollTop, "Did not scroll.");
+  info("Brian waiting 5");
 
   // (3) Now set the scroll position back at the bottom and check that
   // additional requests *do* cause the container to scroll down.
   requestsContainer.scrollTop = requestsContainer.scrollHeight;
   ok(scrolledToBottom(requestsContainer), "Set scroll position to bottom.");
+  info("Brian waiting 6");
   yield waitForNetworkEvents(monitor, 1);
+  info("Brian waiting 7");
   yield waitForScroll(monitor);
+  info("Brian waiting 8");
   ok(scrolledToBottom(requestsContainer), "Still scrolled to bottom.");
+  info("Brian waiting 9");
 
   // (4) Now select an item in the list and check that additional requests
   // do not change the scroll position.
   monitor.panelWin.NetMonitorView.RequestsMenu.selectedIndex = 0;
+  info("Brian waiting 10");
   yield waitForNetworkEvents(monitor, 1);
+  info("Brian waiting 11");
   yield waitSomeTime();
+  info("Brian waiting 12");
   is(requestsContainer.scrollTop, 0, "Did not scroll.");
+  info("Brian waiting 13");
 
   // Done: clean up.
   yield teardown(monitor);
 
+  info("Brian waiting 14");
   finish();
 
   function waitForRequestsToOverflowContainer(aMonitor, aContainer) {
     return waitForNetworkEvents(aMonitor, 1).then(() => {
       if (aContainer.scrollHeight > aContainer.clientHeight) {
         return promise.resolve();
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
@@ -63,25 +79,28 @@ add_task(function*() {
   }
 
   function scrolledToBottom(aElement) {
     return aElement.scrollTop + aElement.clientHeight >= aElement.scrollHeight;
   }
 
   // Wait to make sure no scrolls happen
   function waitSomeTime() {
+    info ("waitSomeTime entered");
     let waitSomeTime = promise.defer();
     setTimeout(waitSomeTime.resolve, 50);
     return waitSomeTime.promise;
   }
 
   // The scroll event takes a short amount of time to fire after a request
   // is added.  This returns a promise that will resolve once it happens.
   function waitForScroll(aMonitor) {
+    info ("waitForScroll entered");
     let sideMenuList = aMonitor._view.RequestsMenu.widget._list;
     let scrolled = promise.defer();
     sideMenuList.addEventListener("scroll", function onscroll() {
       sideMenuList.removeEventListener("scroll", onscroll);
+      info ("waitForScroll resolved");
       scrolled.resolve();
     });
     return scrolled.promise;
   }
 });
