# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1572286363 25200
#      Mon Oct 28 11:12:43 2019 -0700
# Node ID 1cfd901472776badf5016a3ebb92900c6e326269
# Parent  0ec9e4f71228e0cdc4bcb325fe9095ede13df7d5
Bug 1592054 - Initialize tabbrowser-tab contents before appending it into the DOM

This prevents a brief flash of unstyled tab content that can be noticed especially
in debug builds.

What happens currently is that we first append child content into the tab
upon connection, then we do attribute inheritance which sets the relevant
styling properties.

With this change we first set up the child content and attributes _before_ appending
the tab into the DOM, so that it's ready to render after being appended.

Differential Revision: https://phabricator.services.mozilla.com/D50837

diff --git a/browser/base/content/tabbrowser-tab.js b/browser/base/content/tabbrowser-tab.js
--- a/browser/base/content/tabbrowser-tab.js
+++ b/browser/base/content/tabbrowser-tab.js
@@ -96,16 +96,20 @@
           </hbox>
         </stack>
       `);
       }
       return document.importNode(this.constructor._fragment, true);
     }
 
     connectedCallback() {
+      this.initialize();
+    }
+
+    initialize() {
       if (this._initialized) {
         return;
       }
 
       this.textContent = "";
       this.appendChild(this.fragment);
       this.initializeAttributeInheritance();
       this.setAttribute("context", "tabContextMenu");
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -2736,16 +2736,17 @@
           index = Math.min(index, this._numPinnedTabs);
         } else {
           index = Math.max(index, this._numPinnedTabs);
           index = Math.min(index, this.tabs.length);
         }
 
         let tabAfter = this.tabs[index] || null;
         this._invalidateCachedTabs();
+        t.initialize();
         this.tabContainer.insertBefore(t, tabAfter);
         if (tabAfter) {
           this._updateTabsAfterInsert();
         } else {
           t._tPos = index;
         }
 
         if (pinned) {
