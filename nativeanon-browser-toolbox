# HG changeset patch
# Parent 19867b642ec1a96d1d376e47d325bbe4865438b8
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1119276 - Show all native anon content in browser toolbox;r=pbrosset

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1369,16 +1369,18 @@ pref("devtools.inspector.activeSidebar",
 pref("devtools.inspector.markupPreview", false);
 pref("devtools.inspector.remote", false);
 // Expand pseudo-elements by default in the rule-view
 pref("devtools.inspector.show_pseudo_elements", true);
 // The default size for image preview tooltips in the rule-view/computed-view/markup-view
 pref("devtools.inspector.imagePreviewTooltipSize", 300);
 // Enable user agent style inspection in rule-view
 pref("devtools.inspector.showUserAgentStyles", false);
+// Show all native anonymous content (like controls in <video> tags)
+pref("devtools.inspector.showAllAnonymousContent", false);
 
 // DevTools default color unit
 pref("devtools.defaultColorUnit", "hex");
 
 // Enable the Responsive UI tool
 pref("devtools.responsiveUI.no-reload-notification", false);
 
 // Enable the Debugger
diff --git a/browser/devtools/framework/toolbox-process-window.js b/browser/devtools/framework/toolbox-process-window.js
--- a/browser/devtools/framework/toolbox-process-window.js
+++ b/browser/devtools/framework/toolbox-process-window.js
@@ -46,16 +46,17 @@ let connect = Task.async(function*() {
   });
 });
 
 // Certain options should be toggled since we can assume chrome debugging here
 function setPrefDefaults() {
   Services.prefs.setBoolPref("devtools.inspector.showUserAgentStyles", true);
   Services.prefs.setBoolPref("devtools.profiler.ui.show-platform-data", true);
   Services.prefs.setBoolPref("browser.devedition.theme.showCustomizeButton", false);
+  Services.prefs.setBoolPref("devtools.inspector.showAllAnonymousContent", true);
 }
 
 window.addEventListener("load", function() {
   let cmdClose = document.getElementById("toolbox-cmd-close");
   cmdClose.addEventListener("command", onCloseCommand);
   setPrefDefaults();
   connect().catch(Cu.reportError);
 });
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -1498,17 +1498,19 @@ Toolbox.prototype = {
   /**
    * Initialize the inspector/walker/selection/highlighter fronts.
    * Returns a promise that resolves when the fronts are initialized
    */
   initInspector: function() {
     if (!this._initInspector) {
       this._initInspector = Task.spawn(function*() {
         this._inspector = InspectorFront(this._target.client, this._target.form);
-        this._walker = yield this._inspector.getWalker();
+        this._walker = yield this._inspector.getWalker(
+          {showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent")}
+        );
         this._selection = new Selection(this._walker);
 
         if (this.highlighterUtils.isRemoteHighlightable()) {
           this.walker.on("highlighter-ready", this._highlighterReady);
           this.walker.on("highlighter-hide", this._highlighterHidden);
 
           let autohide = !gDevTools.testing;
           this._highlighter = yield this._inspector.getHighlighter(autohide);
diff --git a/browser/devtools/markupview/test/browser.ini b/browser/devtools/markupview/test/browser.ini
--- a/browser/devtools/markupview/test/browser.ini
+++ b/browser/devtools/markupview/test/browser.ini
@@ -29,16 +29,17 @@ support-files =
   lib_jquery_1.7_min.js
   lib_jquery_1.11.1_min.js
   lib_jquery_2.1.1_min.js
 
 [browser_markupview_anonymous_01.js]
 [browser_markupview_anonymous_02.js]
 skip-if = e10s # scratchpad.xul is not loading in e10s window
 [browser_markupview_anonymous_03.js]
+[browser_markupview_anonymous_04.js]
 [browser_markupview_copy_image_data.js]
 [browser_markupview_css_completion_style_attribute.js]
 [browser_markupview_events.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events-overflow.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
 [browser_markupview_events_jquery_1.0.js]
 skip-if = e10s # Bug 1040751 - CodeMirror editor.destroy() isn't e10s compatible
diff --git a/browser/devtools/markupview/test/browser_markupview_anonymous_01.js b/browser/devtools/markupview/test/browser_markupview_anonymous_01.js
--- a/browser/devtools/markupview/test/browser_markupview_anonymous_01.js
+++ b/browser/devtools/markupview/test/browser_markupview_anonymous_01.js
@@ -22,9 +22,23 @@ add_task(function*() {
 
   info ("Checking the normal child element");
   let span = children.nodes[1];
   yield isEditingMenuEnabled(span, inspector);
 
   info ("Checking the ::after pseudo element");
   let after = children.nodes[2];
   yield isEditingMenuDisabled(after, inspector);
+
+  let native = yield getNodeFront("#native", inspector);
+
+  // Markup looks like: <div><video controls /></div>
+  let nativeChildren = yield inspector.walker.children(native);
+  is (nativeChildren.nodes.length, 1, "Children returned from walker");
+
+  info ("Checking the video element");
+  let video = nativeChildren.nodes[0];
+  ok (!video.isAnonymous, "<video> is not anonymous");
+
+  let videoChildren = yield inspector.walker.children(video);
+  is (videoChildren.nodes.length, 0,
+    "No native children returned from walker for <video> by default");
 });
diff --git a/browser/devtools/markupview/test/browser_markupview_anonymous_04.js b/browser/devtools/markupview/test/browser_markupview_anonymous_04.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_anonymous_04.js
@@ -0,0 +1,36 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test native anonymous content in the markupview with devtools.inspector.showAllAnonymousContent
+// set to true
+const TEST_URL = TEST_URL_ROOT + "doc_markup_anonymous.html";
+
+add_task(function*() {
+  Services.prefs.setBoolPref("devtools.inspector.showAllAnonymousContent", true);
+
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  let native = yield getNodeFront("#native", inspector);
+
+  // Markup looks like: <div><video controls /></div>
+  let nativeChildren = yield inspector.walker.children(native);
+  is (nativeChildren.nodes.length, 1, "Children returned from walker");
+
+  info ("Checking the video element");
+  let video = nativeChildren.nodes[0];
+  ok (!video.isAnonymous, "<video> is not anonymous");
+
+  let videoChildren = yield inspector.walker.children(video);
+  is (videoChildren.nodes.length, 3, "<video> has native anonymous children");
+
+  for (let node of videoChildren.nodes) {
+    ok (node.isAnonymous, "Child is anonymous");
+    ok (!node._form.isXBLAnonymous, "Child is not XBL anonymous");
+    ok (!node._form.isShadowAnonymous, "Child is not shadow anonymous");
+    ok (node._form.isNativeAnonymous, "Child is native anonymous");
+    yield isEditingMenuDisabled(node, inspector);
+  }
+});
diff --git a/browser/devtools/markupview/test/doc_markup_anonymous.html b/browser/devtools/markupview/test/doc_markup_anonymous.html
--- a/browser/devtools/markupview/test/doc_markup_anonymous.html
+++ b/browser/devtools/markupview/test/doc_markup_anonymous.html
@@ -15,16 +15,18 @@
     }
   </style>
 </head>
 <body>
   <div id="pseudo"><span>middle</span></div>
 
   <div id="shadow">light dom</div>
 
+  <div id="native"><video controls></video></div>
+
   <script>
   var host = document.querySelector('#shadow');
   if (host.createShadowRoot) {
     var root = host.createShadowRoot();
     root.innerHTML = '<h3>Shadow DOM</h3><select multiple></select>';
   }
   </script>
 </body>
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -27,16 +27,17 @@ registerCleanupFunction(() => gDevTools.
 // Clear preferences that may be set during the course of tests.
 registerCleanupFunction(() => {
   Services.prefs.clearUserPref("devtools.inspector.htmlPanelOpen");
   Services.prefs.clearUserPref("devtools.inspector.sidebarOpen");
   Services.prefs.clearUserPref("devtools.inspector.activeSidebar");
   Services.prefs.clearUserPref("devtools.dump.emit");
   Services.prefs.clearUserPref("devtools.markup.pagesize");
   Services.prefs.clearUserPref("dom.webcomponents.enabled");
+  Services.prefs.clearUserPref("devtools.inspector.showAllAnonymousContent");
 });
 
 // Auto close the toolbox and close the test tabs when the test ends
 registerCleanupFunction(function*() {
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   yield gDevTools.closeToolbox(target);
 
   while (gBrowser.tabs.length > 1) {
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1141,16 +1141,17 @@ var WalkerActor = protocol.ActorClass({
   initialize: function(conn, tabActor, options) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
+    this.showAllAnonymousContent = options.showAllAnonymousContent;
 
     this.layoutHelpers = new LayoutHelpers(this.rootWin);
 
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
     this._orphaned = new Set();
 
@@ -1182,16 +1183,22 @@ var WalkerActor = protocol.ActorClass({
       root: this.rootNode.form()
     }
   },
 
   toString: function() {
     return "[WalkerActor " + this.actorID + "]";
   },
 
+  getDocumentWalker: function(node, whatToShow) {
+    // Allow native anon content (like <video> controls) if preffed on
+    let nodeFilter = this.showAllAnonymousContent ? allAnonymousContentTreeWalkerFilter : standardTreeWalkerFilter;
+    return new DocumentWalker(node, this.rootWin, whatToShow, nodeFilter);
+  },
+
   destroy: function() {
     this._destroyed = true;
 
     this.clearPseudoClassLocks();
     this._activePseudoClassLocks = null;
 
     this._hoveredNode = null;
     this.rootDoc = null;
@@ -1371,17 +1378,17 @@ var WalkerActor = protocol.ActorClass({
    * @param NodeActor node
    *    The node whose parents are requested.
    * @param object options
    *    Named options, including:
    *    `sameDocument`: If true, parents will be restricted to the same
    *      document as the node.
    */
   parents: method(function(node, options={}) {
-    let walker = DocumentWalker(node.rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(node.rawNode);
     let parents = [];
     let cur;
     while((cur = walker.parentNode())) {
       if (options.sameDocument && cur.ownerDocument != node.rawNode.ownerDocument) {
         break;
       }
       parents.push(this._ref(cur));
     }
@@ -1392,17 +1399,17 @@ var WalkerActor = protocol.ActorClass({
       sameDocument: Option(1)
     },
     response: {
       nodes: RetVal("array:domnode")
     },
   }),
 
   parentNode: function(node) {
-    let walker = DocumentWalker(node.rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(node.rawNode);
     let parent = walker.parentNode();
     if (parent) {
       return this._ref(parent);
     }
     return null;
   },
 
   /**
@@ -1453,17 +1460,17 @@ var WalkerActor = protocol.ActorClass({
       return;
     }
 
     if (node.retained) {
       // Forcing a retained node to go away.
       this._retainedOrphans.delete(node);
     }
 
-    let walker = DocumentWalker(node.rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(node.rawNode);
 
     let child = walker.firstChild();
     while (child) {
       let childActor = this._refMap.get(child);
       if (childActor) {
         this.releaseNode(childActor, options);
       }
       child = walker.nextSibling();
@@ -1480,17 +1487,17 @@ var WalkerActor = protocol.ActorClass({
   /**
    * Add any nodes between `node` and the walker's root node that have not
    * yet been seen by the client.
    */
   ensurePathToRoot: function(node, newParents=new Set()) {
     if (!node) {
       return newParents;
     }
-    let walker = DocumentWalker(node.rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(node.rawNode);
     let cur;
     while ((cur = walker.parentNode())) {
       let parent = this._refMap.get(cur);
       if (!parent) {
         // This parent didn't exist, so hasn't been seen by the client yet.
         newParents.add(this._ref(cur));
       } else {
         // This parent did exist, so the client knows about it.
@@ -1531,17 +1538,17 @@ var WalkerActor = protocol.ActorClass({
     let maxNodes = options.maxNodes || -1;
     if (maxNodes == -1) {
       maxNodes = Number.MAX_VALUE;
     }
 
     // We're going to create a few document walkers with the same filter,
     // make it easier.
     let getFilteredWalker = (node) => {
-      return new DocumentWalker(node, this.rootWin, options.whatToShow);
+      return this.getDocumentWalker(node, options.whatToShow);
     }
 
     // Need to know the first and last child.
     let rawNode = node.rawNode;
     let firstChild = getFilteredWalker(rawNode).firstChild();
     let lastChild = getFilteredWalker(rawNode).lastChild();
 
     if (!firstChild) {
@@ -1614,17 +1621,17 @@ var WalkerActor = protocol.ActorClass({
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    *
    * @returns an object with three items:
    *    hasFirst: true if the first child of the node is included in the list.
    *    hasLast: true if the last child of the node is included in the list.
    *    nodes: Child nodes returned by the request.
    */
   siblings: method(function(node, options={}) {
-    let parentNode = DocumentWalker(node.rawNode, this.rootWin).parentNode();
+    let parentNode = this.getDocumentWalker(node.rawNode, options.whatToShow).parentNode();
     if (!parentNode) {
       return {
         hasFirst: true,
         hasLast: true,
         nodes: [node]
       };
     }
 
@@ -1640,32 +1647,32 @@ var WalkerActor = protocol.ActorClass({
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   nextSibling: method(function(node, options={}) {
-    let walker = DocumentWalker(node.rawNode, this.rootWin, options.whatToShow || Ci.nsIDOMNodeFilter.SHOW_ALL);
+    let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.nextSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
   /**
    * Get the previous sibling of a given node.  Getting nodes one at a time
    * might be inefficient, be careful.
    *
    * @param object options
    *    Named options:
    *    `whatToShow`: A bitmask of node types that should be included.  See
    *       https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter.
    */
   previousSibling: method(function(node, options={}) {
-    let walker = DocumentWalker(node.rawNode, this.rootWin, options.whatToShow || Ci.nsIDOMNodeFilter.SHOW_ALL);
+    let walker = this.getDocumentWalker(node.rawNode, options.whatToShow);
     let sibling = walker.previousSibling();
     return sibling ? this._ref(sibling) : null;
   }, traversalMethod),
 
   /**
    * Helper function for the `children` method: Read forward in the sibling
    * list into an array with `count` items, including the current node.
    */
@@ -1912,17 +1919,17 @@ var WalkerActor = protocol.ActorClass({
    */
   addPseudoClassLock: method(function(node, pseudo, options={}) {
     this._addPseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
 
-    let walker = DocumentWalker(node.rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(node.rawNode);
     let cur;
     while ((cur = walker.parentNode())) {
       let curNode = this._ref(cur);
       this._addPseudoClassLock(curNode, pseudo);
     }
   }, {
     request: {
       node: Arg(0, "domnode"),
@@ -1993,17 +2000,17 @@ var WalkerActor = protocol.ActorClass({
    */
   removePseudoClassLock: method(function(node, pseudo, options={}) {
     this._removePseudoClassLock(node, pseudo);
 
     if (!options.parents) {
       return;
     }
 
-    let walker = DocumentWalker(node.rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(node.rawNode);
     let cur;
     while ((cur = walker.parentNode())) {
       let curNode = this._ref(cur);
       this._removePseudoClassLock(curNode, pseudo);
     }
   }, {
     request: {
       node: Arg(0, "domnode"),
@@ -2562,17 +2569,17 @@ var WalkerActor = protocol.ActorClass({
       this.rootNode = null;
     }
 
     this.queueMutation({
       type: "documentUnload",
       target: documentActor.actorID
     });
 
-    let walker = DocumentWalker(doc, this.rootWin);
+    let walker = this.getDocumentWalker(doc);
     let parentNode = walker.parentNode();
     if (parentNode) {
       // Send a childList mutation on the frame so that clients know
       // they should reread the children list.
       this.queueMutation({
         type: "childList",
         target: this._refMap.get(parentNode).actorID,
         added: [],
@@ -2587,17 +2594,17 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Check if a node is attached to the DOM tree of the current page.
    * @param {nsIDomNode} rawNode
    * @return {Boolean} false if the node is removed from the tree or within a
    * document fragment
    */
   _isInDOMTree: function(rawNode) {
-    let walker = DocumentWalker(rawNode, this.rootWin);
+    let walker = this.getDocumentWalker(rawNode);
     let current = walker.currentNode;
 
     // Reaching the top of tree
     while (walker.parentNode()) {
       current = walker.currentNode;
     }
 
     // The top of the tree is a fragment or is not rootDoc, hence rawNode isn't
@@ -3102,17 +3109,19 @@ var InspectorActor = exports.InspectorAc
     if (window.document.readyState === "loading") {
       window.addEventListener("DOMContentLoaded", domReady, true);
     } else {
       domReady();
     }
 
     return this._walkerPromise;
   }, {
-    request: {},
+    request: {
+      options: Arg(0, "nullable:json")
+    },
     response: {
       walker: RetVal("domwalker")
     }
   }),
 
   getPageStyle: method(function() {
     if (this._pageStylePromise) {
       return this._pageStylePromise;
@@ -3251,18 +3260,18 @@ var InspectorFront = exports.InspectorFr
     this.manage(this);
   },
 
   destroy: function() {
     delete this.walker;
     protocol.Front.prototype.destroy.call(this);
   },
 
-  getWalker: protocol.custom(function() {
-    return this._getWalker().then(walker => {
+  getWalker: protocol.custom(function(options = {}) {
+    return this._getWalker(options).then(walker => {
       this.walker = walker;
       return walker;
     });
   }, {
     impl: "_getWalker"
   }),
 
   getPageStyle: protocol.custom(function() {
@@ -3287,39 +3296,34 @@ exports._documentWalker = DocumentWalker
 function nodeDocument(node) {
   return node.ownerDocument || (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 /**
  * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
  * See inDeepTreeWalker for more information about the methods.
  *
- * @param {DOMNode} aNode
- * @param {Window} aRootWin
- * @param {Int} aShow See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
- * @param {Function} aFilter A custom filter function Taking in a DOMNode
- *        and returning an Int. See nodeFilter for an example.
+ * @param {DOMNode} node
+ * @param {Window} rootWin
+ * @param {Int} whatToShow See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
+ * @param {Function} filter A custom filter function Taking in a DOMNode
+ *        and returning an Int. See WalkerActor.nodeFilter for an example.
  */
-function DocumentWalker(aNode, aRootWin, aShow=Ci.nsIDOMNodeFilter.SHOW_ALL,
-                        aFilter=nodeFilter) {
-  if (!(this instanceof DocumentWalker)) {
-    return new DocumentWalker(aNode, aRootWin, aShow, aFilter);
-  }
-
-  if (!aRootWin.location) {
+function DocumentWalker(node, rootWin, whatToShow=Ci.nsIDOMNodeFilter.SHOW_ALL, filter=standardTreeWalkerFilter) {
+  if (!rootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
-  this.walker.init(aRootWin.document, aShow);
-  this.walker.currentNode = aNode;
-  this.filter = aFilter;
+  this.walker.init(rootWin.document, whatToShow);
+  this.walker.currentNode = node;
+  this.filter = filter;
 }
 
 DocumentWalker.prototype = {
   get node() this.walker.node,
   get whatToShow() this.walker.whatToShow,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
 
@@ -3371,19 +3375,21 @@ DocumentWalker.prototype = {
 };
 
 function isXULElement(el) {
   return el &&
          el.namespaceURI === XUL_NS;
 }
 
 /**
- * A tree walker filter for avoiding empty whitespace text nodes.
+ * This DeepTreeWalker filter skips whitespace text nodes and anonymous
+ * content with the exception of ::before and ::after and anonymous content
+ * in XUL document (needed to show all elements in the browser toolbox).
  */
-function nodeFilter(aNode) {
+function standardTreeWalkerFilter(aNode) {
   // Ignore empty whitespace text nodes.
   if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
       !/[^\s]/.exec(aNode.nodeValue)) {
     return Ci.nsIDOMNodeFilter.FILTER_SKIP;
   }
 
   // Ignore all native anonymous content (like internals for form
   // controls).  Except for:
@@ -3399,16 +3405,29 @@ function nodeFilter(aNode) {
       ) {
     return Ci.nsIDOMNodeFilter.FILTER_SKIP;
   }
 
   return Ci.nsIDOMNodeFilter.FILTER_ACCEPT;
 }
 
 /**
+ * This DeepTreeWalker filter is like standardTreeWalkerFilter except that
+ * it also includes all anonymous content (like internal form controls).
+ */
+function allAnonymousContentTreeWalkerFilter(aNode) {
+  // Ignore empty whitespace text nodes.
+  if (aNode.nodeType == Ci.nsIDOMNode.TEXT_NODE &&
+      !/[^\s]/.exec(aNode.nodeValue)) {
+    return Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  }
+  return Ci.nsIDOMNodeFilter.FILTER_ACCEPT
+}
+
+/**
  * Given an image DOMNode, return the image data-uri.
  * @param {DOMNode} node The image node
  * @param {Number} maxDim Optionally pass a maximum size you want the longest
  * side of the image to be resized to before getting the image data.
  * @return {Object} An object containing the data-uri and size-related information
  * {data: "...", size: {naturalWidth: 400, naturalHeight: 300, resized: true}}
  * @throws an error if the node isn't an image or if the image is missing
  */
diff --git a/toolkit/devtools/server/tests/mochitest/inspector-helpers.js b/toolkit/devtools/server/tests/mochitest/inspector-helpers.js
--- a/toolkit/devtools/server/tests/mochitest/inspector-helpers.js
+++ b/toolkit/devtools/server/tests/mochitest/inspector-helpers.js
@@ -99,17 +99,17 @@ function sortOwnershipChildren(children)
 
 function serverOwnershipSubtree(walker, node) {
   let actor = walker._refMap.get(node);
   if (!actor) {
     return undefined;
   }
 
   let children = [];
-  let docwalker = _documentWalker(node, window);
+  let docwalker = new _documentWalker(node, window);
   let child = docwalker.firstChild();
   while (child) {
     let item = serverOwnershipSubtree(walker, child);
     if (item) {
       children.push(item);
     }
     child = docwalker.nextSibling();
   }
diff --git a/toolkit/devtools/server/tests/mochitest/test_css-logic.html b/toolkit/devtools/server/tests/mochitest/test_css-logic.html
--- a/toolkit/devtools/server/tests/mochitest/test_css-logic.html
+++ b/toolkit/devtools/server/tests/mochitest/test_css-logic.html
@@ -98,41 +98,41 @@ addTest(function findCssSelector() {
 
 addTest(function getComputedStyle() {
   let node = document.querySelector("#computed-style");
   is (CssLogic.getComputedStyle(node).getPropertyValue("width"),
       "50px", "Computed style on a normal node works (width)");
   is (CssLogic.getComputedStyle(node).getPropertyValue("height"),
       "10px", "Computed style on a normal node works (height)");
 
-  let firstChild = _documentWalker(node, window).firstChild();
+  let firstChild = new _documentWalker(node, window).firstChild();
   is (CssLogic.getComputedStyle(firstChild).getPropertyValue("content"),
       "\"before\"", "Computed style on a ::before node works (content)");
-  let lastChild = _documentWalker(node, window).lastChild();
+  let lastChild = new _documentWalker(node, window).lastChild();
   is (CssLogic.getComputedStyle(lastChild).getPropertyValue("content"),
       "\"after\"", "Computed style on a ::after node works (content)");
 
   runNextTest();
 });
 
 addTest(function getBindingElementAndPseudo() {
   let node = document.querySelector("#computed-style");
   var {bindingElement, pseudo} = CssLogic.getBindingElementAndPseudo(node);
 
   is (bindingElement, node,
       "Binding element is the node itself for a normal node");
   ok (!pseudo, "Pseudo is null for a normal node");
 
-  let firstChild = _documentWalker(node, window).firstChild();
+  let firstChild = new _documentWalker(node, window).firstChild();
   var {bindingElement, pseudo} = CssLogic.getBindingElementAndPseudo(firstChild);
   is (bindingElement, node,
       "Binding element is the parent for a pseudo node");
   is (pseudo, ":before", "Pseudo is correct for a ::before node");
 
-  let lastChild = _documentWalker(node, window).lastChild();
+  let lastChild = new _documentWalker(node, window).lastChild();
   var {bindingElement, pseudo} = CssLogic.getBindingElementAndPseudo(lastChild);
   is (bindingElement, node,
       "Binding element is the parent for a pseudo node");
   is (pseudo, ":after", "Pseudo is correct for a ::after node");
 
   runNextTest();
 });
 
diff --git a/toolkit/devtools/server/tests/mochitest/test_inspector-insert.html b/toolkit/devtools/server/tests/mochitest/test_inspector-insert.html
--- a/toolkit/devtools/server/tests/mochitest/test_inspector-insert.html
+++ b/toolkit/devtools/server/tests/mochitest/test_inspector-insert.html
@@ -60,17 +60,17 @@ addTest(function testRearrange() {
     ok(!gInspectee.querySelector("#a").nextSibling, "a should now be at the end of the list.");
     return gWalker.children(longlist);
   }).then(response => {
     is(nodeA, response.nodes[response.nodes.length - 1], "a should now be the last returned child.");
     // Now move it to the middle of the list.
     nextNode = response.nodes[13];
     return gWalker.insertBefore(nodeA, longlist, nextNode);
   }).then(response => {
-    let sibling = inspector._documentWalker(gInspectee.querySelector("#a"), window).nextSibling();
+    let sibling = new inspector._documentWalker(gInspectee.querySelector("#a"), window).nextSibling();
     is(sibling, nextNode.rawNode(), "Node should match the expected next node.");
     return gWalker.children(longlist);
   }).then(response => {
     is(nodeA, response.nodes[13], "a should be where we expect it.");
     is(nextNode, response.nodes[14], "next node should be where we expect it.");
   }).then(runNextTest));
 });
 
