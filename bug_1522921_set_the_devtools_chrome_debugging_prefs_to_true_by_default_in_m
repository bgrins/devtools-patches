# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1548441554 28800
#      Fri Jan 25 10:39:14 2019 -0800
# Node ID cb8042f42f772d59db4849e867418097828e622f
# Parent  f039f8426b5f90e3811f0cd8d0c3ccfd3abdfb13
Bug 1522921 - Set the devtools chrome debugging prefs to true by default in mochitests and wpt

Differential Revision: https://phabricator.services.mozilla.com/D17671

diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_selfxss.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_selfxss.js
--- a/devtools/client/webconsole/test/mochitest/browser_jsterm_selfxss.js
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_selfxss.js
@@ -12,16 +12,17 @@ XPCOMUtils.defineLazyServiceGetter(
   "clipboardHelper",
   "@mozilla.org/widget/clipboardhelper;1",
   "nsIClipboardHelper"
 );
 const WebConsoleUtils = require("devtools/client/webconsole/utils").Utils;
 const stringToCopy = "EvilCommand";
 
 add_task(async function() {
+  await pushPref("devtools.chrome.enabled", false);
   // Run test with legacy JsTerm
   await pushPref("devtools.webconsole.jsterm.codeMirror", false);
   await performTest();
   // And then run it with the CodeMirror-powered one.
   await pushPref("devtools.webconsole.jsterm.codeMirror", true);
   await performTest();
 });
 
diff --git a/devtools/server/tests/browser/browser_storage_dynamic_windows.js b/devtools/server/tests/browser/browser_storage_dynamic_windows.js
--- a/devtools/server/tests/browser/browser_storage_dynamic_windows.js
+++ b/devtools/server/tests/browser/browser_storage_dynamic_windows.js
@@ -101,16 +101,24 @@ async function testStores(data, front) {
 
   await testAddIframe(front);
   await testRemoveIframe(front);
 }
 
 function testWindowsBeforeReload(data) {
   for (const storageType in beforeReload) {
     ok(data[storageType], `${storageType} storage actor is present`);
+
+    // If this test is run with chrome debugging enabled we get an extra
+    // key for "chrome". We don't want the test to fail in this case, so
+    // ignore it.
+    if (storageType == "indexedDB") {
+      delete data[storageType].hosts.chrome;
+    }
+
     is(Object.keys(data[storageType].hosts).length,
        Object.keys(beforeReload[storageType]).length,
         `Number of hosts for ${storageType} match`);
     for (const host in beforeReload[storageType]) {
       ok(data[storageType].hosts[host], `Host ${host} is present`);
     }
   }
 }
diff --git a/devtools/server/tests/browser/browser_storage_listings.js b/devtools/server/tests/browser/browser_storage_listings.js
--- a/devtools/server/tests/browser/browser_storage_listings.js
+++ b/devtools/server/tests/browser/browser_storage_listings.js
@@ -450,16 +450,21 @@ var testSessionStorageObjects = async fu
   matchItems(await sessionStorageActor.getStoreObjects(host));
   if (index == Object.keys(hosts).length - 1) {
     return;
   }
   await testSessionStorageObjects(++index, hosts, sessionStorageActor);
 };
 
 var testIndexedDB = async function(indexedDBActor) {
+  // If this test is run with chrome debugging enabled we get an extra
+  // key for "chrome". We don't want the test to fail in this case, so
+  // ignore it.
+  delete indexedDBActor.hosts.chrome;
+
   is(Object.keys(indexedDBActor.hosts).length, 3,
      "Correct number of host entries for indexed db");
 
   for (const host in indexedDBActor.hosts) {
     for (const item of indexedDBActor.hosts[host]) {
       const parsedItem = JSON.parse(item);
       let found = false;
       for (const toMatch of IDBValues.listStoresResponse[host]) {
diff --git a/testing/mochitest/mochitest_options.py b/testing/mochitest/mochitest_options.py
--- a/testing/mochitest/mochitest_options.py
+++ b/testing/mochitest/mochitest_options.py
@@ -700,23 +700,16 @@ class MochitestArguments(ArgumentContain
         elif build_obj:
             options.certPath = os.path.join(build_obj.topsrcdir, 'build', 'pgo', 'certs')
 
         if options.symbolsPath and len(urlparse(options.symbolsPath).scheme) < 2:
             options.symbolsPath = self.get_full_path(options.symbolsPath, parser.oldcwd)
         elif not options.symbolsPath and build_obj:
             options.symbolsPath = os.path.join(build_obj.distdir, 'crashreporter-symbols')
 
-        if options.jsdebugger:
-            options.extraPrefs += [
-                "devtools.debugger.remote-enabled=true",
-                "devtools.chrome.enabled=true",
-                "devtools.debugger.prompt-connection=false"
-            ]
-
         if options.debugOnFailure and not options.jsdebugger:
             parser.error(
                 "--debug-on-failure requires --jsdebugger.")
 
         if options.debuggerArgs and not options.debugger:
             parser.error(
                 "--debugger-args requires --debugger.")
 
diff --git a/testing/profiles/unittest-required/user.js b/testing/profiles/unittest-required/user.js
--- a/testing/profiles/unittest-required/user.js
+++ b/testing/profiles/unittest-required/user.js
@@ -80,19 +80,19 @@ user_pref("browser.warnOnQuit", false);
 // Enable webapps testing mode, which bypasses native installation.
 user_pref("browser.webapps.testing", true);
 user_pref("captivedetect.canonicalURL", "http://{server}/captive-detect/success.txt");
 // Point Firefox Health Report at a local server. We don't care if it actually
 // works. It just can't hit the default production endpoint.
 user_pref("datareporting.healthreport.documentServerURI", "http://{server}/healthreport/");
 user_pref("datareporting.healthreport.uploadEnabled", false);
 user_pref("devtools.browsertoolbox.panel", "jsdebugger");
-user_pref("devtools.chrome.enabled", false);
-user_pref("devtools.debugger.prompt-connection", true);
-user_pref("devtools.debugger.remote-enabled", false);
+user_pref("devtools.chrome.enabled", true);
+user_pref("devtools.debugger.prompt-connection", false);
+user_pref("devtools.debugger.remote-enabled", true);
 user_pref("devtools.debugger.remote-port", 6023);
 user_pref("devtools.testing", true);
 // Required to set values in wpt metadata files (bug 1485842)
 user_pref("dom.audioworklet.enabled", false);
 user_pref("dom.allow_scripts_to_close_windows", true);
 user_pref("dom.disable_open_during_load", false);
 user_pref("dom.ipc.reportProcessHangs", false); // process hang monitor
 // Don't forceably kill content processes after a timeout
