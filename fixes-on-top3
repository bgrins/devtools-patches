# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  d99e0d666738a6a46e7ccc21ccd805d4228baddb
Bug 1479125 - Fixes on top of the scripted change

diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -125,18 +125,18 @@ var gXPInstallObserver = {
 
     options.eventCallback = (aEvent) => {
       switch (aEvent) {
         case "removed":
           cancelInstallation();
           break;
         case "shown":
           let addonList = document.getElementById("addon-install-confirmation-content");
-          while (addonList.firstElementChild)
-            addonList.firstElementChild.remove();
+          while (addonList.firstChild)
+            addonList.firstChild.remove();
 
           for (let install of installInfo.installs) {
             let container = document.createXULElement("hbox");
 
             let name = document.createXULElement("label");
             name.setAttribute("value", install.addon.name);
             name.setAttribute("class", "addon-install-confirmation-name");
             container.appendChild(name);
@@ -496,18 +496,18 @@ var gExtensionsNotifications = {
   },
 
   updateAlerts() {
     let sideloaded = ExtensionsUI.sideloaded;
     let updates = ExtensionsUI.updates;
 
     let container = PanelUI.addonNotificationContainer;
 
-    while (container.firstElementChild) {
-      container.firstElementChild.remove();
+    while (container.firstChild) {
+      container.firstChild.remove();
     }
 
     let items = 0;
     for (let update of updates) {
       if (++items > 4) {
         break;
       }
       let text = gNavigatorBundle.getFormattedString("webextPerms.updateMenuItem", [update.addon.name]);
diff --git a/browser/base/content/browser-pageActions.js b/browser/base/content/browser-pageActions.js
--- a/browser/base/content/browser-pageActions.js
+++ b/browser/base/content/browser-pageActions.js
@@ -1132,18 +1132,18 @@ BrowserPageActions.addSearchEngine = {
     button.classList.add("badged-button");
     button.setAttribute("image", this.engines[0].icon);
     button.setAttribute("uri", this.engines[0].uri);
     button.setAttribute("crop", "center");
   },
 
   onSubviewShowing(panelViewNode) {
     let body = panelViewNode.querySelector(".panel-subview-body");
-    while (body.firstElementChild) {
-      body.firstElementChild.remove();
+    while (body.firstChild) {
+      body.firstChild.remove();
     }
     for (let engine of this.engines) {
       let button = document.createXULElement("toolbarbutton");
       button.classList.add("subviewbutton", "subviewbutton-iconic");
       button.setAttribute("label", engine.title);
       button.setAttribute("image", engine.icon);
       button.setAttribute("uri", engine.uri);
       button.addEventListener("command", event => {
@@ -1251,18 +1251,18 @@ BrowserPageActions.shareURL = {
     });
 
     let item = document.createElement("toolbarbutton");
     item.setAttribute("label", BrowserPageActions.panelNode.getAttribute("shareMore-label"));
     item.classList.add("subviewbutton", "subviewbutton-iconic", "share-more-button");
     item.addEventListener("command", onCommand);
     fragment.appendChild(item);
 
-    while (bodyNode.firstElementChild) {
-      bodyNode.firstElementChild.remove();
+    while (bodyNode.firstChild) {
+      bodyNode.firstChild.remove();
     }
     bodyNode.appendChild(fragment);
     this._cached = true;
   }
 };
 
 // Attach sharingService here so tests can override the implementation
 XPCOMUtils.defineLazyServiceGetter(BrowserPageActions.shareURL,
diff --git a/browser/base/content/urlbarBindings.xml b/browser/base/content/urlbarBindings.xml
--- a/browser/base/content/urlbarBindings.xml
+++ b/browser/base/content/urlbarBindings.xml
@@ -530,17 +530,17 @@ file, You can obtain one at http://mozil
             strikeOut.removeAllRanges();
             selection = controller.getSelection(controller.SELECTION_URLSECONDARY);
             selection.removeAllRanges();
             this.formatScheme(controller.SELECTION_URLSTRIKEOUT, true);
             this.formatScheme(controller.SELECTION_URLSECONDARY, true);
             this.inputField.style.setProperty("--urlbar-scheme-size", "0px");
           }
 
-          let textNode = this.editor.rootElement.firstElementChild;
+          let textNode = this.editor.rootElement.firstChild;
           let value = textNode.textContent;
           if (!value)
             return;
 
           if (this.focused)
             return;
 
           // Get the URL from the fixup service:
@@ -651,17 +651,17 @@ file, You can obtain one at http://mozil
       </method>
 
       <method name="formatScheme">
         <parameter name="selectionType"/>
         <parameter name="clear"/>
         <body><![CDATA[
           let editor = this.scheme.editor;
           let controller = editor.selectionController;
-          let textNode = editor.rootElement.firstElementChild;
+          let textNode = editor.rootElement.firstChild;
           let selection = controller.getSelection(selectionType);
           if (clear) {
             selection.removeAllRanges();
           } else {
             let r = document.createRange();
             r.setStart(textNode, 0);
             r.setEnd(textNode, textNode.textContent.length);
             selection.addRange(r);
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -3951,18 +3951,18 @@ var CustomizableUI = {
    * @param aSubview the subview to clear.
    */
   clearSubview(aSubview) {
     let parent = aSubview.parentNode;
     // We'll take the container out of the document before cleaning it out
     // to avoid reflowing each time we remove something.
     parent.removeChild(aSubview);
 
-    while (aSubview.firstElementChild) {
-      aSubview.firstElementChild.remove();
+    while (aSubview.firstChild) {
+      aSubview.firstChild.remove();
     }
 
     parent.appendChild(aSubview);
   },
 };
 Object.freeze(this.CustomizableUI);
 Object.freeze(this.CustomizableUI.windows);
 
diff --git a/browser/components/customizableui/CustomizeMode.jsm b/browser/components/customizableui/CustomizeMode.jsm
--- a/browser/components/customizableui/CustomizeMode.jsm
+++ b/browser/components/customizableui/CustomizeMode.jsm
@@ -2596,18 +2596,18 @@ CustomizeMode.prototype = {
 
     function uninit() {
       document.removeEventListener("keydown", onkeydown);
       document.removeEventListener("keyup", onkeyup);
       if (rAFHandle) {
         window.cancelAnimationFrame(rAFHandle);
       }
       let arena = elements.arena;
-      while (arena.firstElementChild) {
-        arena.firstElementChild.remove();
+      while (arena.firstChild) {
+        arena.firstChild.remove();
       }
       arena.removeAttribute("score");
       arena.removeAttribute("lives");
       arena.removeAttribute("kcode");
       arena.style.removeProperty("background-image");
       arena.style.removeProperty("background-position");
       arena.style.removeProperty("background-repeat");
       arena.style.removeProperty("background-size");
diff --git a/browser/components/customizableui/content/panelUI.js b/browser/components/customizableui/content/panelUI.js
--- a/browser/components/customizableui/content/panelUI.js
+++ b/browser/components/customizableui/content/panelUI.js
@@ -539,18 +539,18 @@ const PanelUI = {
     }
   },
 
   /**
    * Remove all the nodes from the 'Recent Highlights' section and hide it as well.
    */
   clearLibraryRecentHighlights() {
     let container = this.libraryRecentHighlights;
-    while (container.firstElementChild) {
-      container.firstElementChild.remove();
+    while (container.firstChild) {
+      container.firstChild.remove();
     }
     container.hidden = container.previousElementSibling.hidden =
       container.previousElementSibling.previousElementSibling.hidden = true;
   },
 
   /**
    * Event handler; invoked when an item of the Recent Highlights is clicked.
    *
@@ -621,18 +621,18 @@ const PanelUI = {
     buildHelpMenu();
 
     let helpMenu = document.getElementById("menu_HelpPopup");
     let items = this.getElementsByTagName("vbox")[0];
     let attrs = ["oncommand", "onclick", "label", "key", "disabled"];
     let NSXUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
     // Remove all buttons from the view
-    while (items.firstElementChild) {
-      items.firstElementChild.remove();
+    while (items.firstChild) {
+      items.firstChild.remove();
     }
 
     // Add the current set of menuitems of the Help menu to this view
     let menuItems = Array.prototype.slice.call(helpMenu.getElementsByTagName("menuitem"));
     let fragment = document.createDocumentFragment();
     for (let node of menuItems) {
       if (node.hidden)
         continue;
diff --git a/browser/components/extensions/test/browser/browser_ext_tabs_hide.js b/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
--- a/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
+++ b/browser/components/extensions/test/browser/browser_ext_tabs_hide.js
@@ -198,17 +198,17 @@ add_task(async function test_tabs_showhi
   // hidden.  The rest of the tabs should be hidden at this point.  Hidden
   // status was already validated inside the extension, this double checks
   // from chrome code.
   let otherwin;
   for (let win of BrowserWindowIterator()) {
     if (win != window) {
       otherwin = win;
     }
-    let tabs = Array.from(win.gBrowser.tabs.values());
+    let tabs = Array.from(win.gBrowser.tabs);
     ok(!tabs[0].hidden, "first tab not hidden");
     for (let i = 1; i < tabs.length; i++) {
       ok(tabs[i].hidden, "tab hidden value is correct");
       let id = SessionStore.getCustomTabValue(tabs[i], "hiddenBy");
       is(id, extension.id, "tab hiddenBy value is correct");
       await TabStateFlusher.flush(tabs[i].linkedBrowser);
     }
 
@@ -217,17 +217,17 @@ add_task(async function test_tabs_showhi
   }
 
   // Close the other window then restore it to test that the tabs are
   // restored with proper hidden state, and the correct extension id.
   await BrowserTestUtils.closeWindow(otherwin);
 
   otherwin = SessionStore.undoCloseWindow(0);
   await BrowserTestUtils.waitForEvent(otherwin, "load");
-  let tabs = Array.from(otherwin.gBrowser.tabs.values());
+  let tabs = Array.from(otherwin.gBrowser.tabs);
   ok(!tabs[0].hidden, "first tab not hidden");
   for (let i = 1; i < tabs.length; i++) {
     ok(tabs[i].hidden, "tab hidden value is correct");
     let id = SessionStore.getCustomTabValue(tabs[i], "hiddenBy");
     is(id, extension.id, "tab hiddenBy value is correct");
   }
 
   // Test closing the last visible tab, the next tab which is hidden should become
@@ -237,17 +237,17 @@ add_task(async function test_tabs_showhi
   ok(!otherwin.gBrowser.selectedTab.hidden, "tab was unhidden");
 
   // Showall will unhide any remaining hidden tabs.
   extension.sendMessage("showall");
   await extension.awaitMessage("shown");
 
   // Check from chrome code that all tabs are visible again.
   for (let win of BrowserWindowIterator()) {
-    let tabs = Array.from(win.gBrowser.tabs.values());
+    let tabs = Array.from(win.gBrowser.tabs);
     for (let i = 0; i < tabs.length; i++) {
       ok(!tabs[i].hidden, "tab hidden value is correct");
     }
   }
 
   // Close second window.
   await BrowserTestUtils.closeWindow(otherwin);
 
diff --git a/browser/components/places/content/browserPlacesViews.js b/browser/components/places/content/browserPlacesViews.js
--- a/browser/components/places/content/browserPlacesViews.js
+++ b/browser/components/places/content/browserPlacesViews.js
@@ -1038,17 +1038,17 @@ PlacesToolbar.prototype = {
   async _rebuild() {
     // Clear out references to existing nodes, since they will be removed
     // and re-added.
     if (this._overFolder.elt)
       this._clearOverFolder();
 
     this._openedMenuButton = null;
     while (this._rootElt.hasChildNodes()) {
-      this._rootElt.firstElementChild.remove();
+      this._rootElt.firstChild.remove();
     }
 
     let cc = this._resultNode.childCount;
     if (cc > 0) {
       // There could be a lot of nodes, but we only want to build the ones that
       // are more likely to be shown, not all of them.
       // We also don't want to wait for reflows at every node insertion, to
       // calculate a precise number of visible items, thus we guess a size from
@@ -2115,17 +2115,17 @@ PlacesPanelMenuView.prototype = {
 
   invalidateContainer: function PAMV_invalidateContainer(aPlacesNode) {
     let elt = this._getDOMNodeForPlacesNode(aPlacesNode);
     if (elt != this._rootElt)
       return;
 
     // Container is the toolbar itself.
     while (this._rootElt.hasChildNodes()) {
-      this._rootElt.firstElementChild.remove();
+      this._rootElt.firstChild.remove();
     }
 
     let fragment = document.createDocumentFragment();
     for (let i = 0; i < this._resultNode.childCount; ++i) {
       this._insertNewItem(this._resultNode.getChild(i), fragment);
     }
     this._rootElt.appendChild(fragment);
   }
diff --git a/browser/components/search/content/search.xml b/browser/components/search/content/search.xml
--- a/browser/components/search/content/search.xml
+++ b/browser/components/search/content/search.xml
@@ -1570,18 +1570,18 @@
       <!-- If a page offers more than this number of engines, the add-engines
            menu button is shown, instead of showing the engines directly in the
            popup. -->
       <field name="_addEngineMenuThreshold">5</field>
 
       <method name="_rebuildAddEngineList">
         <body><![CDATA[
         let list = this.addEngines;
-        while (list.firstElementChild) {
-          list.firstElementChild.remove();
+        while (list.firstChild) {
+          list.firstChild.remove();
         }
 
         // Add a button for each engine that the page in the selected browser
         // offers, except when there are too many offered engines.
         // The popup isn't designed to handle too many (by scrolling for
         // example), so a page could break the popup by offering too many.
         // Instead, add a single menu button with a submenu of all the engines.
 
diff --git a/browser/components/syncedtabs/TabListView.js b/browser/components/syncedtabs/TabListView.js
--- a/browser/components/syncedtabs/TabListView.js
+++ b/browser/components/syncedtabs/TabListView.js
@@ -172,18 +172,18 @@ TabListView.prototype = {
   },
 
   _createTab() {
     return this._doc.importNode(this._tabTemplate.content, true).firstElementChild;
   },
 
   _clearChilden(node) {
     let parent = node || this.container;
-    while (parent.firstElementChild) {
-      parent.firstElementChild.remove();
+    while (parent.firstChild) {
+      parent.firstChild.remove();
     }
   },
 
   // These listeners are attached only once, when we initialize the view
   _attachFixedListeners() {
     this.tabsFilter.addEventListener("input", this.onFilter.bind(this));
     this.tabsFilter.addEventListener("focus", this.onFilterFocus.bind(this));
     this.tabsFilter.addEventListener("blur", this.onFilterBlur.bind(this));
diff --git a/browser/components/uitour/UITour.jsm b/browser/components/uitour/UITour.jsm
--- a/browser/components/uitour/UITour.jsm
+++ b/browser/components/uitour/UITour.jsm
@@ -1132,18 +1132,18 @@ var UITour = {
         tooltip.hidePopup();
       }
 
       tooltipTitle.textContent = aTitle || "";
       tooltipDesc.textContent = aDescription || "";
       tooltipIcon.src = aIconURL || "";
       tooltipIcon.hidden = !aIconURL;
 
-      while (tooltipButtons.firstElementChild)
-        tooltipButtons.firstElementChild.remove();
+      while (tooltipButtons.firstChild)
+        tooltipButtons.firstChild.remove();
 
       for (let button of aButtons) {
         let isButton = button.style != "text";
         let el = document.createElement(isButton ? "button" : "label");
         el.setAttribute(isButton ? "label" : "value", button.label);
 
         if (isButton) {
           if (button.iconURL)
@@ -1230,18 +1230,18 @@ var UITour = {
   },
 
   _hideInfoElement(aWindow) {
     let document = aWindow.document;
     let tooltip = document.getElementById("UITourTooltip");
     this._removeAnnotationPanelMutationObserver(tooltip);
     tooltip.hidePopup();
     let tooltipButtons = document.getElementById("UITourTooltipButtons");
-    while (tooltipButtons.firstElementChild)
-      tooltipButtons.firstElementChild.remove();
+    while (tooltipButtons.firstChild)
+      tooltipButtons.firstChild.remove();
   },
 
   hideInfo(aWindow) {
     this._hideInfoElement(aWindow);
     this._setMenuStateForAnnotation(aWindow, false, "appMenu");
     this._setMenuStateForAnnotation(aWindow, false, "pageActionPanel");
   },
 
diff --git a/browser/modules/ExtensionsUI.jsm b/browser/modules/ExtensionsUI.jsm
--- a/browser/modules/ExtensionsUI.jsm
+++ b/browser/modules/ExtensionsUI.jsm
@@ -284,18 +284,18 @@ var ExtensionsUI = {
           textEl.textContent = strings.text;
           textEl.hidden = !strings.text;
 
           let listIntroEl = doc.getElementById("addon-webext-perm-intro");
           listIntroEl.textContent = strings.listIntro;
           listIntroEl.hidden = (strings.msgs.length == 0);
 
           let list = doc.getElementById("addon-webext-perm-list");
-          while (list.firstElementChild) {
-            list.firstElementChild.remove();
+          while (list.firstChild) {
+            list.firstChild.remove();
           }
 
           for (let msg of strings.msgs) {
             let item = doc.createElementNS(HTML_NS, "li");
             item.textContent = msg;
             list.appendChild(item);
           }
         } else if (topic == "swapping") {
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -1492,17 +1492,17 @@
         <parameter name="aNoEmphasis"/>
         <body>
           <![CDATA[
           // Get rid of all previous text
           if (!aDescriptionElement) {
             return;
           }
           while (aDescriptionElement.hasChildNodes())
-            aDescriptionElement.firstElementChild.remove();
+            aDescriptionElement.firstChild.remove();
 
           // If aNoEmphasis is specified, don't add any emphasis
           if (aNoEmphasis) {
             aDescriptionElement.appendChild(document.createTextNode(aText));
             return;
           }
 
           // Get the indices that separate match and non-match text
@@ -1547,17 +1547,17 @@
         </body>
       </method>
 
       <method name="_setUpTags">
         <parameter name="tags"/>
         <body>
           <![CDATA[
           while (this._tagsText.hasChildNodes()) {
-            this._tagsText.firstElementChild.remove();
+            this._tagsText.firstChild.remove();
           }
 
           let anyTagsMatch = false;
 
           // Include only tags that match the search string.
           for (let tag of tags) {
             // Check if the tag matches the search string.
             let search = this.getAttribute("text");
@@ -1689,17 +1689,17 @@
       -->
       <method name="_setUpEmphasisedSections">
         <parameter name="aDescriptionElement"/>
         <parameter name="aTextPairs"/>
         <body>
           <![CDATA[
           // Get rid of all previous text
           while (aDescriptionElement.hasChildNodes())
-            aDescriptionElement.firstElementChild.remove();
+            aDescriptionElement.firstChild.remove();
 
           for (let [text, emphasise] of aTextPairs) {
             if (emphasise) {
               let span = aDescriptionElement.appendChild(
                 document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
               span.textContent = text;
               switch (emphasise) {
                 case "match":
diff --git a/toolkit/content/widgets/richlistbox.xml b/toolkit/content/widgets/richlistbox.xml
--- a/toolkit/content/widgets/richlistbox.xml
+++ b/toolkit/content/widgets/richlistbox.xml
@@ -580,18 +580,18 @@
           ]]>
         </body>
       </method>
 
       <property name="children" readonly="true">
         <getter>
           <![CDATA[
             let iface = Ci.nsIDOMXULSelectControlItemElement;
-            let children = Array.from(this.children)
-                                .filter(node => node instanceof iface);
+            let children = Array.from(this.childNodes)
+                                .filter(node => node.nodeType == 1 && node instanceof iface);
             if (this.dir == "reverse" && this._mayReverse) {
               children.reverse();
             }
             return children;
           ]]>
         </getter>
       </property>
 
