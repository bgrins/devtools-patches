# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  cf9e7037ac4c13770b8d61329e3f9bc2b3b3a413

diff --git a/browser/base/content/browser-fullZoom.js b/browser/base/content/browser-fullZoom.js
--- a/browser/base/content/browser-fullZoom.js
+++ b/browser/base/content/browser-fullZoom.js
@@ -341,17 +341,17 @@ var FullZoom = {
     if (!this.siteSpecific || gInPrintPreviewMode) {
       this._executeSoon(aCallback);
       return;
     }
 
     // The browser is sometimes half-destroyed because this method is called
     // by content pref service callbacks, which themselves can be called at any
     // time, even after browsers are closed.
-    if (!aBrowser.parentNode || aBrowser.isSyntheticDocument) {
+    if (!aBrowser.mInitialized || aBrowser.isSyntheticDocument) {
       this._executeSoon(aCallback);
       return;
     }
 
     if (aValue !== undefined) {
       ZoomManager.setZoomForBrowser(aBrowser, this._ensureValid(aValue));
       this._ignorePendingZoomAccesses(aBrowser);
       this._executeSoon(aCallback);
@@ -429,17 +429,17 @@ var FullZoom = {
     return {
       token: map.get(browser),
       get isCurrent() {
         // At this point, the browser may have been destructed and unbound but
         // its outer ID not removed from the map because outer-window-destroyed
         // hasn't been received yet.  In that case, the browser is unusable, it
         // has no properties, so return false.  Check for this case by getting a
         // property, say, docShell.
-        return map.get(browser) === this.token && browser.parentNode;
+        return map.get(browser) === this.token && browser.mInitialized;
       },
     };
   },
 
   /**
    * Returns the browser that the supplied zoom event is associated with.
    * @param event  The ZoomChangeUsingMouseWheel event.
    * @return  The associated browser element, if one exists, otherwise null.
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -108,17 +108,17 @@ window._gBrowser = {
    * Binding from browser to tab
    */
   _tabForBrowser: new WeakMap(),
 
   _preloadedBrowser: null,
 
   /**
    * `_createLazyBrowser` will define properties on the unbound lazy browser
-   * which correspond to properties defined in XBL which will be bound to
+   * which correspond to properties defined in MozBrowser which will be bound to
    * the browser when it is inserted into the document.  If any of these
    * properties are accessed by consumers, `_insertBrowser` is called and
    * the browser is inserted to ensure that things don't break.  This list
    * provides the names of properties that may be called while the browser
    * is in its unbound (lazy) state.
    */
   _browserBindingProperties: [
     "canGoBack", "canGoForward", "goBack", "goForward", "permitUnload",
@@ -3088,24 +3088,24 @@ window._gBrowser = {
     this._tabFilters.delete(aTab);
     this._tabListeners.delete(aTab);
 
     var browser = this.getBrowserForTab(aTab);
 
     if (aTab.linkedPanel) {
       this._outerWindowIDBrowserMap.delete(browser.outerWindowID);
 
-      // Because of the way XBL works (fields just set JS
-      // properties on the element) and the code we have in place
+      // Because of the fact that we are setting JS properties on
+      // the browser elements, and we have code in place
       // to preserve the JS objects for any elements that have
       // JS properties set on them, the browser element won't be
       // destroyed until the document goes away.  So we force a
       // cleanup ourselves.
-      // This has to happen before we remove the child so that the
-      // XBL implementation of nsIObserver still works.
+      // This has to happen before we remove the child since functions
+      // like `getBrowserContainer` expect the browser to be parented.
       browser.destroy();
     }
 
     var wasPinned = aTab.pinned;
 
     // Remove the tab ...
     aTab.remove();
 
diff --git a/devtools/client/responsive.html/browser/swap.js b/devtools/client/responsive.html/browser/swap.js
--- a/devtools/client/responsive.html/browser/swap.js
+++ b/devtools/client/responsive.html/browser/swap.js
@@ -35,17 +35,17 @@ function debug(msg) {
 function swapToInnerBrowser({ tab, containerURL, getInnerBrowser }) {
   let browserWindow = tab.ownerGlobal;
   let gBrowser = browserWindow.gBrowser;
   let innerBrowser;
   let tunnel;
 
   // Dispatch a custom event each time the _viewport content_ is swapped from one browser
   // to another.  DevTools server code uses this to follow the content if there is an
-  // active DevTools connection.  While browser.xml does dispatch it's own SwapDocShells
+  // active DevTools connection.  While browser.js does dispatch it's own SwapDocShells
   // event, this one is easier for DevTools to follow because it's only emitted once per
   // transition, instead of twice like SwapDocShells.
   const dispatchDevToolsBrowserSwap = (from, to) => {
     const CustomEvent = browserWindow.CustomEvent;
     const event = new CustomEvent("DevTools:BrowserSwap", {
       detail: to,
       bubbles: true,
     });
@@ -416,17 +416,17 @@ function addXULBrowserDecorations(browse
         return browser._outerWindowID;
       },
       configurable: true,
       enumerable: true,
     });
   }
 
   // It's not necessary for these to actually do anything.  These properties are
-  // swapped between browsers in browser.xml's `swapDocShells`, and then their
+  // swapped between browsers in browser.js's `swapDocShells`, and then their
   // `swapBrowser` methods are called, so we define them here for that to work
   // without errors.  During the swap process above, these will move from the
   // the new inner browser to the original tab's browser (step 4) and then to
   // the temporary container tab's browser (step 7), which is then closed.
   if (browser._remoteWebNavigationImpl == undefined) {
     browser._remoteWebNavigationImpl = {
       swapBrowser() {},
     };
diff --git a/devtools/client/responsive.html/browser/tunnel.js b/devtools/client/responsive.html/browser/tunnel.js
--- a/devtools/client/responsive.html/browser/tunnel.js
+++ b/devtools/client/responsive.html/browser/tunnel.js
@@ -14,17 +14,17 @@ const FRAME_LOADER = Symbol("devtools/re
 // Export for use in tests.
 exports.OUTER_FRAME_LOADER_SYMBOL = FRAME_LOADER;
 
 function debug(msg) {
   // console.log(msg);
 }
 
 /**
- * Properties swapped between browsers by browser.xml's `swapDocShells`.
+ * Properties swapped between browsers by browser.js's `swapDocShells`.
  */
 const SWAPPED_BROWSER_STATE = [
   "_remoteFinder",
   "_securityUI",
   "_documentURI",
   "_documentContentType",
   "_contentTitle",
   "_characterSet",
@@ -59,18 +59,18 @@ const PROPERTIES_FROM_BROWSER_WINDOW = [
 
 /**
  * This module takes an "outer" <xul:browser> from a browser tab as described by
  * Firefox's tabbrowser.xml and wires it up to an "inner" <iframe mozbrowser>
  * browser element containing arbitrary page content of interest.
  *
  * The inner <iframe mozbrowser> element is _just_ the page content.  It is not
  * enough to to replace <xul:browser> on its own.  <xul:browser> comes along
- * with lots of associated functionality via XBL binding defined for such
- * elements in browser.xml, and the Firefox UI depends on these various things
+ * with lots of associated functionality via a Custom Element defined for such
+ * elements in browser.js, and the Firefox UI depends on these various things
  * to make the UI function.
  *
  * By mapping various methods, properties, and messages from the outer browser
  * to the inner browser, we can control the content inside the inner browser
  * using the standard Firefox UI elements for navigation, reloading, and more.
  *
  * The approaches used in this module were chosen to avoid needing changes to
  * the core browser for this specialized use case.  If we start to increase
@@ -98,19 +98,19 @@ function tunnelToInnerBrowser(outer, inn
         throw new Error("The outer browser must be non-remote.");
       }
       if (!inner.isRemoteBrowser) {
         throw new Error("The inner browser must be remote.");
       }
 
       // Various browser methods access the `frameLoader` property, including:
       //   * `saveBrowser` from contentAreaUtils.js
-      //   * `docShellIsActive` from browser.xml
-      //   * `hasContentOpener` from browser.xml
-      //   * `preserveLayers` from browser.xml
+      //   * `docShellIsActive` from browser.js
+      //   * `hasContentOpener` from browser.js
+      //   * `preserveLayers` from browser.js
       //   * `receiveMessage` from SessionStore.jsm
       // In general, these methods are interested in the `frameLoader` for the content,
       // so we redirect them to the inner browser's `frameLoader`.
       outer[FRAME_LOADER] = outer.frameLoader;
       Object.defineProperty(outer, "frameLoader", {
         get() {
           const stack = getStack();
           // One exception is `receiveMessage` from SessionStore.jsm.  SessionStore
@@ -148,22 +148,22 @@ function tunnelToInnerBrowser(outer, inn
       // copy the content's `permanentKey` up to the outer browser.
       debug("Copy inner permanentKey to outer browser");
       outer.permanentKey = inner.permanentKey;
 
       // Replace the outer browser's native messageManager with a message manager tunnel
       // which we can use to route messages of interest to the inner browser instead.
       // Note: The _actual_ messageManager accessible from
       // `browser.frameLoader.messageManager` is not overridable and is left unchanged.
-      // Only the XBL getter `browser.messageManager` is overridden.  Browser UI code
-      // always uses this getter instead of `browser.frameLoader.messageManager` directly,
+      // Only the Custom Element getter `browser.messageManager` is overridden. This
+      // getter is always used instead of `browser.frameLoader.messageManager` directly,
       // so this has the effect of overriding the message manager for browser UI code.
       mmTunnel = new MessageManagerTunnel(outer, inner);
 
-      // Clear out any cached state that references the XBL binding's non-remote state,
+      // Clear out any cached state that references the Custom Element's non-remote state,
       // such as form fill controllers.  Otherwise they will remain in place and leak the
       // outer docshell.
       outer.destroy();
 
       // We are tunneling to an inner browser with a specific remoteness, so it is simpler
       // for the logic of the browser UI to assume this tab has taken on that remoteness,
       // even though it's not true.  Since the actions the browser UI performs are sent
       // down to the inner browser by this tunnel, the tab's remoteness effectively is the
@@ -188,19 +188,19 @@ function tunnelToInnerBrowser(outer, inn
       // remote browser binding creates.  We do not care about it's original value
       // because stop() will remove the browser binding and these will no longer bee
       // used.
       const webNavigation = new BrowserElementWebNavigation(inner);
       webNavigation.copyStateFrom(inner._remoteWebNavigationImpl);
       outer._remoteWebNavigation = webNavigation;
       outer._remoteWebNavigationImpl = webNavigation;
 
-      // Now that we've flipped to the remote browser XBL binding, add `progressListener`
+      // Now that we've flipped to the remote browser mode, add `progressListener`
       // onto the remote version of `webProgress`.  Normally tabbrowser.xml does this step
-      // when it creates a new browser, etc.  Since we manually changed the XBL binding
+      // when it creates a new browser, etc.  Since we manually changed the mode
       // above, it caused a fresh webProgress object to be created which does not have any
       // listeners added.  So, we get the listener that gBrowser is using for the tab and
       // reattach it here.
       const tab = gBrowser.getTabForBrowser(outer);
       const filteredProgressListener = gBrowser._tabFilters.get(tab);
       outer.webProgress.addProgressListener(filteredProgressListener);
 
       // Add the inner browser to tabbrowser's WeakMap from browser to tab.  This assists
@@ -300,17 +300,17 @@ function tunnelToInnerBrowser(outer, inn
       }
 
       // Remove the inner browser from the WeakMap from browser to tab.
       gBrowser._tabForBrowser.delete(inner);
 
       // Remove the progress listener we added manually.
       outer.webProgress.removeProgressListener(filteredProgressListener);
 
-      // Reset the XBL binding back to the original state.
+      // Reset the Custom Element back to the original state.
       outer.destroy();
 
       // Reset @remote since this is now back to a regular, non-remote browser
       outer.setAttribute("remote", "false");
       outer.removeAttribute("remoteType");
       outer.construct();
 
       // Delete browser window properties exposed on content's owner global
@@ -383,17 +383,17 @@ MessageManagerTunnel.prototype = {
   OVERRIDDEN_METHODS: [
     "loadFrameScript",
     "addMessageListener",
     "removeMessageListener",
     "sendAsyncMessage",
   ],
 
   OUTER_TO_INNER_MESSAGES: [
-    // Messages sent from remote-browser.xml
+    // Messages sent from browser.js
     "Browser:PurgeSessionHistory",
     "InPermitUnload",
     "PermitUnload",
     // Messages sent from browser.js
     "Browser:Reload",
     "PageStyle:Disable",
     "PageStyle:Switch",
     // Messages sent from SelectParentHelper.jsm
@@ -417,17 +417,17 @@ MessageManagerTunnel.prototype = {
     "PageStyle:StyleSheets",
     // Messages sent to RemoteWebProgress.jsm
     "Content:LoadURIResult",
     "Content:LocationChange",
     "Content:ProgressChange",
     "Content:SecurityChange",
     "Content:StateChange",
     "Content:StatusChange",
-    // Messages sent to remote-browser.xml
+    // Messages sent to browser.js
     "DOMTitleChanged",
     "ImageDocumentLoaded",
     "Forms:ShowDropDown",
     "Forms:HideDropDown",
     "InPermitUnload",
     "PermitUnload",
     // Messages sent to tabbrowser.xml
     "contextmenu",
@@ -435,17 +435,17 @@ MessageManagerTunnel.prototype = {
     "Forms:UpdateDropDown",
     // Messages sent to SessionStore.jsm
     "SessionStore:update",
     // Messages sent to BrowserTestUtils.jsm
     "browser-test-utils:loadEvent",
   ],
 
   OUTER_TO_INNER_MESSAGE_PREFIXES: [
-    // Messages sent from browser.xml
+    // Messages sent from browser.js
     "Autoscroll:",
     // Messages sent from nsContextMenu.js
     "ContextMenu:",
     // Messages sent from DevTools
     "debug:",
     // Messages sent from findbar.xml
     "Findbar:",
     // Messages sent from RemoteFinder.jsm
@@ -458,17 +458,17 @@ MessageManagerTunnel.prototype = {
     "PageInfo:",
     // Messages sent from printUtils.js
     "Printing:",
     // Messages sent from viewSourceUtils.js
     "ViewSource:",
   ],
 
   INNER_TO_OUTER_MESSAGE_PREFIXES: [
-    // Messages sent to browser.xml
+    // Messages sent to browser.js
     "Autoscroll:",
     // Messages sent to nsContextMenu.js
     "ContextMenu:",
     // Messages sent to DevTools
     "debug:",
     // Messages sent to findbar.xml
     "Findbar:",
     // Messages sent to RemoteFinder.jsm
diff --git a/devtools/server/actors/network-monitor/network-observer.js b/devtools/server/actors/network-monitor/network-observer.js
--- a/devtools/server/actors/network-monitor/network-observer.js
+++ b/devtools/server/actors/network-monitor/network-observer.js
@@ -81,17 +81,17 @@ function matchRequest(channel, filters) 
     const topFrame = NetworkHelper.getTopFrameForRequest(channel);
     // topFrame is typically null for some chrome requests like favicons
     if (topFrame) {
       try {
         if (topFrame.outerWindowID == filters.outerWindowID) {
           return true;
         }
       } catch (e) {
-        // outerWindowID getter from browser.xml (non-remote <xul:browser>) may
+        // outerWindowID getter from browser.js (non-remote <xul:browser>) may
         // throw when closing a tab while resources are still loading.
       }
     }
   }
 
   return false;
 }
 exports.matchRequest = matchRequest;
diff --git a/dom/ipc/tests/process_error.xul b/dom/ipc/tests/process_error.xul
--- a/dom/ipc/tests/process_error.xul
+++ b/dom/ipc/tests/process_error.xul
@@ -26,12 +26,16 @@
       }
 
       Services.obs.removeObserver(crashObserver, 'ipc:content-shutdown');
       done();
     }
 
     Services.obs.addObserver(crashObserver, 'ipc:content-shutdown');
 
-    BrowserTestUtils.crashBrowser(document.getElementById('thebrowser'), true, false);
+    // Allow the browser to get connected before using the messageManager to cause
+    // a crash:
+    addEventListener("DOMContentLoaded", () => {
+      BrowserTestUtils.crashBrowser(document.getElementById('thebrowser'), true, false);
+    });
   ]]></script>
 
 </window>
diff --git a/gfx/layers/apz/src/AutoscrollAnimation.cpp b/gfx/layers/apz/src/AutoscrollAnimation.cpp
--- a/gfx/layers/apz/src/AutoscrollAnimation.cpp
+++ b/gfx/layers/apz/src/AutoscrollAnimation.cpp
@@ -71,17 +71,17 @@ bool AutoscrollAnimation::DoSample(Frame
   // An autoscroll animation never ends of its own accord.
   // It can be stopped in response to various input events, in which case
   // AsyncPanZoomController::StopAutoscroll() will stop it via
   // CancelAnimation().
   return true;
 }
 
 void AutoscrollAnimation::Cancel(CancelAnimationFlags aFlags) {
-  // The cancellation was initiated by browser.xml, so there's no need to
+  // The cancellation was initiated by browser.js, so there's no need to
   // notify it.
   if (aFlags & TriggeredExternally) {
     return;
   }
 
   if (RefPtr<GeckoContentController> controller =
           mApzc.GetGeckoContentController()) {
     controller->CancelAutoscroll(mApzc.GetGuid());
diff --git a/mobile/android/app/mobile.js b/mobile/android/app/mobile.js
--- a/mobile/android/app/mobile.js
+++ b/mobile/android/app/mobile.js
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #filter substitution
 
-// For browser.xml binding
+// For browser.js element
 //
 // cacheRatio* is a ratio that determines the amount of pixels to cache. The
 // ratio is multiplied by the viewport width or height to get the displayport's
 // width or height, respectively.
 //
 // (divide integer value by 1000 to get the ratio)
 //
 // For instance: cachePercentageWidth is 1500
diff --git a/mobile/android/chrome/content/browser.js b/mobile/android/chrome/content/browser.js
--- a/mobile/android/chrome/content/browser.js
+++ b/mobile/android/chrome/content/browser.js
@@ -5373,17 +5373,17 @@ var XPInstallObserver = {
   },
 
   hideRestartPrompt: function() {
     NativeWindow.doorhanger.hide("addon-app-restart", BrowserApp.selectedTab.id);
   }
 };
 
 /**
- * Handler for blocked popups, triggered by DOMUpdateBlockedPopups events in browser.xml
+ * Handler for blocked popups, triggered by DOMUpdateBlockedPopups events in browser.js
  */
 var PopupBlockerObserver = {
   onUpdateBlockedPopups: function onUpdateBlockedPopups(aEvent) {
     let browser = BrowserApp.selectedBrowser;
     if (aEvent.originalTarget != browser)
       return;
 
     if (!browser.blockedPopups)
diff --git a/toolkit/components/processsingleton/CustomElementsListener.jsm b/toolkit/components/processsingleton/CustomElementsListener.jsm
--- a/toolkit/components/processsingleton/CustomElementsListener.jsm
+++ b/toolkit/components/processsingleton/CustomElementsListener.jsm
@@ -8,15 +8,16 @@ ChromeUtils.import("resource://gre/modul
 // Set up Custom Elements for XUL and XHTML documents before anything else
 // happens. Anything loaded here should be considered part of core XUL functionality.
 // Any window-specific elements can be registered via <script> tags at the
 // top of individual documents.
 Services.obs.addObserver({
   observe(doc) {
     if (doc.nodePrincipal.isSystemPrincipal && (
       doc.contentType == "application/vnd.mozilla.xul+xml" ||
-      doc.contentType == "application/xhtml+xml"
+      doc.contentType == "application/xhtml+xml" ||
+      doc.contentType == "text/html"
     )) {
       Services.scriptloader.loadSubScript(
         "chrome://global/content/customElements.js", doc.ownerGlobal);
     }
   },
 }, "document-element-inserted");
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -285,16 +285,20 @@ MozElements.BaseControl = class BaseCont
 MozXULElement.implementCustomInterface(MozElements.BaseControl,
                                        [Ci.nsIDOMXULControlElement]);
 
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozElements = MozElements;
 
+customElements.setElementCreationCallback("browser", () => {
+  Services.scriptloader.loadSubScript("chrome://global/content/elements/browser-custom-element.js", window);
+});
+
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/radio.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -85,16 +85,17 @@ toolkit.jar:
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbar.xml         (widgets/toolbar.xml)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
    content/global/bindings/videocontrols.xml   (widgets/videocontrols.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
+   content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -167,20 +167,16 @@ iframe {
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   browser,
   editor,
   iframe {
     display: block;
   }
 }
 
-browser {
-  -moz-binding: url("chrome://global/content/bindings/browser.xml#browser");
-}
-
 /*********** popup notification ************/
 popupnotification {
   -moz-binding: url("chrome://global/content/bindings/notification.xml#popup-notification");
 }
 
 .popup-notification-menubutton:not([label]) {
   display: none;
 }
diff --git a/toolkit/modules/E10SUtils.jsm b/toolkit/modules/E10SUtils.jsm
--- a/toolkit/modules/E10SUtils.jsm
+++ b/toolkit/modules/E10SUtils.jsm
@@ -102,17 +102,17 @@ var E10SUtils = {
 
   getRemoteTypeForURI(aURL, aMultiProcess,
                       aPreferredRemoteType = DEFAULT_REMOTE_TYPE,
                       aCurrentUri) {
     if (!aMultiProcess) {
       return NOT_REMOTE;
     }
 
-    // loadURI in browser.xml treats null as about:blank
+    // loadURI in browser.js treats null as about:blank
     if (!aURL) {
       aURL = "about:blank";
     }
 
     let uri;
     try {
       uri = Services.uriFixup.createFixupURI(aURL, Ci.nsIURIFixup.FIXUP_FLAG_NONE);
     } catch (e) {
