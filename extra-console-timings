# HG changeset patch
# Parent d14f1a013830f51dc006bcba2f8719eb5983eb6d
# User Brian Grinstead <bgrinstead@mozilla.com>
extra console.times


diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -1179,42 +1179,48 @@ WebConsoleFrame.prototype = {
    *
    * @param object aMessage
    *        The message received from the server.
    * @return nsIDOMElement|null
    *         The message element to display in the Web Console output.
    */
   logConsoleAPIMessage: function WCF_logConsoleAPIMessage(aMessage)
   {
+    console.time("INNER1");
     let body = null;
     let clipboardText = null;
     let sourceURL = aMessage.filename;
     let sourceLine = aMessage.lineNumber;
     let level = aMessage.level;
     let args = aMessage.arguments;
     let objectActors = new Set();
     let node = null;
 
     // Gather the actor IDs.
     args.forEach((aValue) => {
       if (WebConsoleUtils.isActorGrip(aValue)) {
         objectActors.add(aValue.actor);
       }
     });
+    console.timeEnd("INNER1");
 
     switch (level) {
       case "log":
       case "info":
       case "warn":
       case "error":
       case "exception":
       case "assert":
       case "debug": {
+    console.time("INNER2.1");
         let msg = new Messages.ConsoleGeneric(aMessage);
+    console.timeEnd("INNER2.1");
+    console.time("INNER2.2");
         node = msg.init(this.output).render().element;
+    console.timeEnd("INNER2.2");
         break;
       }
       case "trace": {
         let msg = new Messages.ConsoleTrace(aMessage);
         node = msg.init(this.output).render().element;
         break;
       }
       case "dir": {
@@ -1296,34 +1302,38 @@ WebConsoleFrame.prototype = {
           this._releaseObject(actor);
         }
         objectActors.clear();
     }
 
     if (level == "groupEnd") {
       return null; // no need to continue
     }
+    console.time("INNER3");
 
     if (!node) {
       node = this.createMessageNode(CATEGORY_WEBDEV, LEVELS[level], body,
                                     sourceURL, sourceLine, clipboardText,
                                     level, aMessage.timeStamp);
       if (aMessage.private) {
         node.setAttribute("private", true);
       }
     }
 
+    console.timeEnd("INNER3");
+    console.time("INNER4");
     if (objectActors.size > 0) {
       node._objectActors = objectActors;
 
       if (!node._messageObject) {
         let repeatNode = node.getElementsByClassName("message-repeats")[0];
         repeatNode._uid += [...objectActors].join("-");
       }
     }
+    console.timeEnd("INNER4");
 
     return node;
   },
 
   /**
    * Handle ConsoleAPICall objects received from the server. This method outputs
    * the window.console API call.
    *
@@ -2088,35 +2098,36 @@ WebConsoleFrame.prototype = {
     }
     console.time("Flush message queue outer");
     let outputNode = this.outputNode;
     let lastVisibleNode = null;
     let scrollNode = outputNode.parentNode;
     let scrolledToBottom = Utils.isOutputScrolledToBottom(outputNode);
     let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
 
-    console.time("Output the current batch of messages.");
+    console.time("Output the current batch of messages ("+batch.length+").");
     // Output the current batch of messages.
     let newMessages = new Set();
     let updatedMessages = new Set();
-    for (let item of batch) {
+    for (let i = 0; i < batch.length; i++) {
+      let item = batch[i];
       let result = this._outputMessageFromQueue(hudIdSupportsString, item);
       if (result) {
         if (result.isRepeated) {
           updatedMessages.add(result.isRepeated);
         }
         else {
           newMessages.add(result.node);
         }
         if (result.visible && result.node == this.outputNode.lastChild) {
           lastVisibleNode = result.node;
         }
       }
     }
-    console.timeEnd("Output the current batch of messages.");
+    console.timeEnd("Output the current batch of messages ("+batch.length+").");
 
     let oldScrollHeight = 0;
 
     // Prune messages if needed. We do not do this for every flush call to
     // improve performance.
     let removedNodes = 0;
     console.time("Prune messages if needed");
     if (shouldPrune || !this._outputQueue.length) {
@@ -2202,51 +2213,62 @@ WebConsoleFrame.prototype = {
    *         - node: the DOM element of the message.
    *         - isRepeated: the DOM element of the original message, if this is
    *         a repeated message, otherwise null.
    *         - visible: boolean that tells if the message is visible.
    */
   _outputMessageFromQueue:
   function WCF__outputMessageFromQueue(aHudIdSupportsString, aItem)
   {
+    console.time("Adding single message");
     let [category, methodOrNode, args] = aItem;
-
+    console.time("Adding single message1.1" + typeof methodOrNode);
     let node = typeof methodOrNode == "function" ?
                methodOrNode.apply(this, args || []) :
                methodOrNode;
     if (!node) {
       return null;
     }
 
     let afterNode = node._outputAfterNode;
     if (afterNode) {
       delete node._outputAfterNode;
     }
 
+    console.timeEnd("Adding single message1.1" + typeof methodOrNode);
+    console.time("Adding single message1.2");
     let isFiltered = this.filterMessageNode(node);
 
     let isRepeated = this._filterRepeatedMessage(node);
 
     let visible = !isRepeated && !isFiltered;
+    console.timeEnd("Adding single message1.2");
     if (!isRepeated) {
+    console.time("Adding single message2");
       this.outputNode.insertBefore(node,
                                    afterNode ? afterNode.nextSibling : null);
       this._pruneCategoriesQueue[node.category] = true;
 
       let nodeID = node.getAttribute("id");
+    console.timeEnd("Adding single message2");
+    console.time("Adding single message3");
       Services.obs.notifyObservers(aHudIdSupportsString,
                                    "web-console-message-created", nodeID);
-
-    }
-
+    console.timeEnd("Adding single message3");
+
+    }
+
+    console.time("Adding single message4");
     if (node._onOutput) {
       node._onOutput();
       delete node._onOutput;
     }
-
+    console.timeEnd("Adding single message4");
+
+    console.timeEnd("Adding single message");
     return {
       visible: visible,
       node: node,
       isRepeated: isRepeated,
     };
   },
 
   /**
