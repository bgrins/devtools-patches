
# HG changeset patch
# User Andrew Swan <aswan@mozilla.com>
# Date 1560449313 25200
# Node ID 8707261552a9026ba21f0e5ecce562ddd19d0fe4
# Parent  c163881a80c9a032b40f7d965fad6a6850fcf8a4
cache tabs, remove delete use

diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -71,16 +71,20 @@ window._gBrowser = {
 
   ownerGlobal: window,
 
   ownerDocument: document,
 
   closingTabsEnum: { ALL: 0, OTHER: 1, TO_END: 2, MULTI_SELECTED: 3 },
 
   _visibleTabs: null,
+  _tabs: null,
+  _tabContainer: null,
+  _tabbox: null,
+  _tabpanels: null,
 
   _lastRelatedTabMap: new WeakMap(),
 
   mProgressListeners: [],
 
   mTabsProgressListeners: [],
 
   _tabListeners: new Map(),
@@ -195,64 +199,70 @@ window._gBrowser = {
 
   _switcher: null,
 
   _soundPlayingAttrRemovalTimer: 0,
 
   _hoverTabTimer: null,
 
   get tabContainer() {
-    delete this.tabContainer;
-    return this.tabContainer = document.getElementById("tabbrowser-tabs");
+    if (!this._tabContainer) {
+      this._tabContainer = document.getElementById("tabbrowser-tabs");
+    }
+    return this._tabContainer;
   },
 
   get tabs() {
-    return this.tabContainer.allTabs;
+    if (!this._tabs) {
+      this._tabs = this.tabContainer.allTabs;
+    }
+    return this._tabs;
   },
 
   get tabCount() {
     return this.tabContainer.tabCount;
   },
 
   get tabbox() {
-    delete this.tabbox;
-    return this.tabbox = document.getElementById("tabbrowser-tabbox");
+    if (!this._tabbox) {
+      this._tabbox = document.getElementById("tabbrowser-tabbox");
+    }
+    return this._tabbox;
   },
 
   get tabpanels() {
-    delete this.tabpanels;
-    return this.tabpanels = document.getElementById("tabbrowser-tabpanels");
-  },
-
-  get addEventListener() {
-    delete this.addEventListener;
-    return this.addEventListener = this.tabpanels.addEventListener.bind(this.tabpanels);
-  },
-
-  get removeEventListener() {
-    delete this.removeEventListener;
-    return this.removeEventListener = this.tabpanels.removeEventListener.bind(this.tabpanels);
-  },
-
-  get dispatchEvent() {
-    delete this.dispatchEvent;
-    return this.dispatchEvent = this.tabpanels.dispatchEvent.bind(this.tabpanels);
+    if (!this._tabpanels) {
+      this._tabpanels = document.getElementById("tabbrowser-tabpanels");
+    }
+    return this._tabpanels;
+  },
+
+  addEventListener(...args) {
+    return this.tabpanels.addEventListener(...args);
+  },
+
+  removeEventListener(...args) {
+    return this.tabpanels.removeEventListener(...args);
+  },
+
+  dispatchEvent(...args) {
+    return this.tabpanels.dispatchEvent(...args);
   },
 
   get visibleTabs() {
     if (!this._visibleTabs) {
       this._visibleTabs =
         Array.prototype.filter.call(this.tabs, tab => !tab.hidden && !tab.closing);
     }
     return this._visibleTabs;
   },
 
   get _numPinnedTabs() {
     for (var i = 0; i < this.tabCount; i++) {
-      if (!this.tabContainer.getItemAtIndex(i).pinned)
+      if (!this.tabs[i].pinned)
         break;
     }
     return i;
   },
 
   get popupAnchor() {
     if (this.selectedTab._popupAnchor) {
       return this.selectedTab._popupAnchor;
@@ -506,16 +516,23 @@ window._gBrowser = {
   set userTypedValue(val) {
     this.selectedBrowser.userTypedValue = val;
   },
 
   get userTypedValue() {
     return this.selectedBrowser.userTypedValue;
   },
 
+  _invalidateCachedTabs() {
+    // XXX make this more fine-grained?  sometimes we just need to invalidate
+    // _visibleTabs
+    this._tabs = null;
+    this._visibleTabs = null;
+  },
+
   _setFindbarData() {
     // Ensure we know what the find bar key is in the content process:
     let {sharedData} = Services.ppmm;
     if (!sharedData.has("Findbar:Shortcut")) {
       let keyEl = document.getElementById("key_find");
       let mods = keyEl.getAttribute("modifiers")
         .replace(/accel/i, AppConstants.platform == "macosx" ? "meta" : "control");
       sharedData.set("Findbar:Shortcut", {
@@ -2377,17 +2394,17 @@ window._gBrowser = {
       // Call _handleNewTab asynchronously as it needs to know if the
       // new tab is selected.
       setTimeout(function(tabContainer) {
         tabContainer._handleNewTab(t);
       }, 0, this.tabContainer);
     }
 
     // invalidate cache
-    this._visibleTabs = null;
+// XXX   this._invalidateCachedTabs();
 
     let usingPreloadedContent = false;
     let b;
 
     try {
       // If this new tab is owned by another, assert that relationship
       if (ownerTab) {
         t.owner = ownerTab;
@@ -2425,16 +2442,18 @@ window._gBrowser = {
       if (pinned) {
         index = Math.max(index, 0);
         index = Math.min(index, this._numPinnedTabs);
       } else {
         index = Math.max(index, this._numPinnedTabs);
         index = Math.min(index, this.tabCount);
       }
 
+      this._invalidateCachedTabs();
+
       let tabAfter = this.tabContainer.getItemAtIndex(index);
       this.tabContainer.insertBefore(t, tabAfter);
       if (tabAfter) {
         this._updateTabsAfterInsert();
       } else {
         t._tPos = index;
       }
 
@@ -2969,17 +2988,17 @@ window._gBrowser = {
     if (!adoptedByTab && aTab.hasAttribute("soundplaying")) {
       // Don't persist the muted state as this wasn't a user action.
       // This lets undo-close-tab return it to an unmuted state.
       aTab.linkedBrowser.mute(true);
     }
 
     aTab.closing = true;
     this._removingTabs.push(aTab);
-    this._visibleTabs = null; // invalidate cache
+    this._invalidateCachedTabs();
 
     // Invalidate hovered tab state tracking for this closing tab.
     if (this.tabContainer._hoveredTab == aTab)
       aTab._mouseleave();
 
     if (newTab)
       this.addTrustedTab(BROWSER_NEW_TAB_URL, {
         skipAnimation: true,
@@ -3095,16 +3114,17 @@ window._gBrowser = {
       // like `getBrowserContainer` expect the browser to be parented.
       browser.destroy();
     }
 
     var wasPinned = aTab.pinned;
 
     // Remove the tab ...
     aTab.remove();
+    this._invalidateCachedTabs();
 
     // Update hashiddentabs if this tab was hidden.
     if (aTab.hidden)
       this.tabContainer._updateHiddenTabsStatus();
 
     // ... and fix up the _tPos properties immediately.
     for (let i = aTab._tPos; i < this.tabCount; i++)
       this.tabContainer.getItemAtIndex(i)._tPos = i;
@@ -3549,17 +3569,17 @@ window._gBrowser = {
 
     this.tabContainer._updateHiddenTabsStatus();
     this.tabContainer._handleTabSelect(true);
   },
 
   showTab(aTab) {
     if (aTab.hidden) {
       aTab.removeAttribute("hidden");
-      this._visibleTabs = null; // invalidate cache
+      this._invalidateCachedTabs();
 
       this.tabContainer._updateCloseButtons();
       this.tabContainer._updateHiddenTabsStatus();
 
       this.tabContainer._setPositionalAttributes();
 
       let event = document.createEvent("Events");
       event.initEvent("TabShow", true, false);
@@ -3567,17 +3587,17 @@ window._gBrowser = {
       SessionStore.deleteCustomTabValue(aTab, "hiddenBy");
     }
   },
 
   hideTab(aTab, aSource) {
     if (!aTab.hidden && !aTab.pinned && !aTab.selected &&
         !aTab.closing && !aTab._sharingState) {
       aTab.setAttribute("hidden", "true");
-      this._visibleTabs = null; // invalidate cache
+      this._invalidateCachedTabs();
 
       this.tabContainer._updateCloseButtons();
       this.tabContainer._updateHiddenTabsStatus();
 
       this.tabContainer._setPositionalAttributes();
 
       // Splice this tab out of any lines of succession before any events are
       // dispatched.
@@ -3735,18 +3755,17 @@ window._gBrowser = {
     if (!aKeepRelatedTabs) {
       this._lastRelatedTabMap = new WeakMap();
     }
 
     let wasFocused = (document.activeElement == this.selectedTab);
 
     aIndex = aIndex < aTab._tPos ? aIndex : aIndex + 1;
 
-    // invalidate cache
-    this._visibleTabs = null;
+    this._invalidateCachedTabs();
 
     this.tabContainer.insertBefore(aTab, this.tabContainer.getItemAtIndex(aIndex));
     this._updateTabsAfterInsert();
 
     if (wasFocused)
       this.selectedTab.focus();
 
     this.tabContainer._handleTabSelect(true);
@@ -3899,17 +3918,17 @@ window._gBrowser = {
   /**
    * Adds two given tabs and all tabs between them into the (multi) selected tabs collection
    */
   addRangeToMultiSelectedTabs(aTab1, aTab2) {
     if (aTab1 == aTab2) {
       return;
     }
 
-    const tabs = this._visibleTabs;
+    const tabs = this.visibleTabs;
     const indexOfTab1 = tabs.indexOf(aTab1);
     const indexOfTab2 = tabs.indexOf(aTab2);
 
     const [lowerIndex, higherIndex] = indexOfTab1 < indexOfTab2 ?
       [indexOfTab1, indexOfTab2] : [indexOfTab2, indexOfTab1];
 
     for (let i = lowerIndex; i <= higherIndex; i++) {
       this.addToMultiSelectedTabs(tabs[i], true);

