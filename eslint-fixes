# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  68e42ab040871fd306a0c1c2c4e2b41d365d147d
Bug 1436076 - Part 1 - Fix eslint for hudservice.js;r=nchevobbe

MozReview-Commit-ID: EAarz11x4mW

diff --git a/.eslintignore b/.eslintignore
--- a/.eslintignore
+++ b/.eslintignore
@@ -140,17 +140,16 @@ devtools/client/storage/test/*.html
 !devtools/client/storage/test/storage-overflow.html
 !devtools/client/storage/test/storage-search.html
 !devtools/client/storage/test/storage-unsecured-iframe.html
 !devtools/client/storage/test/storage-unsecured-iframe-usercontextid.html
 devtools/client/webaudioeditor/**
 devtools/client/webconsole/net/**
 devtools/client/webconsole/new-console-output/test/mochitest/**
 devtools/client/webconsole/test/**
-devtools/client/webconsole/hudservice.js
 devtools/client/webconsole/webconsole-connection-proxy.js
 devtools/client/webconsole/webconsole.js
 devtools/client/webide/**
 !devtools/client/webide/components/webideCli.js
 devtools/server/tests/browser/storage-*.html
 !devtools/server/tests/browser/storage-unsecured-iframe.html
 devtools/server/tests/browser/stylesheets-nested-iframes.html
 devtools/server/tests/unit/xpcshell_debugging_script.js
diff --git a/devtools/client/webconsole/hudservice.js b/devtools/client/webconsole/hudservice.js
--- a/devtools/client/webconsole/hudservice.js
+++ b/devtools/client/webconsole/hudservice.js
@@ -17,27 +17,26 @@ loader.lazyRequireGetter(this, "Telemetr
 loader.lazyRequireGetter(this, "WebConsoleFrame", "devtools/client/webconsole/webconsole", true);
 loader.lazyRequireGetter(this, "NewWebConsoleFrame", "devtools/client/webconsole/new-webconsole", true);
 loader.lazyRequireGetter(this, "gDevTools", "devtools/client/framework/devtools", true);
 loader.lazyRequireGetter(this, "DebuggerServer", "devtools/server/main", true);
 loader.lazyRequireGetter(this, "DebuggerClient", "devtools/shared/client/debugger-client", true);
 loader.lazyRequireGetter(this, "showDoorhanger", "devtools/client/shared/doorhanger", true);
 loader.lazyRequireGetter(this, "viewSource", "devtools/client/shared/view-source");
 const l10n = require("devtools/client/webconsole/webconsole-l10n");
-const BROWSER_CONSOLE_WINDOW_FEATURES = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
+const BC_WINDOW_FEATURES = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
 
 // The preference prefix for all of the Browser Console filters.
-const BROWSER_CONSOLE_FILTER_PREFS_PREFIX = "devtools.browserconsole.filter.";
+const BC_FILTER_PREFS_PREFIX = "devtools.browserconsole.filter.";
 
 var gHudId = 0;
 
 // The HUD service
 
-function HUD_SERVICE()
-{
+function HUD_SERVICE() {
   this.consoles = new Map();
   this.lastFinishedRequest = { callback: null };
 }
 
 HUD_SERVICE.prototype =
 {
   _browserConsoleID: null,
   _browserConsoleDefer: null,
@@ -67,242 +66,225 @@ HUD_SERVICE.prototype =
    */
   lastFinishedRequest: null,
 
   /**
    * Get the current context, which is the main application window.
    *
    * @returns nsIDOMWindow
    */
-  currentContext: function HS_currentContext() {
+  currentContext() {
     return Services.wm.getMostRecentWindow(gDevTools.chromeWindowType);
   },
 
   /**
    * Open a Web Console for the given target.
    *
    * @see devtools/framework/target.js for details about targets.
    *
-   * @param object aTarget
+   * @param object target
    *        The target that the web console will connect to.
-   * @param nsIDOMWindow aIframeWindow
+   * @param nsIDOMWindow iframeWindow
    *        The window where the web console UI is already loaded.
-   * @param nsIDOMWindow aChromeWindow
+   * @param nsIDOMWindow chromeWindow
    *        The window of the web console owner.
    * @return object
    *         A promise object for the opening of the new WebConsole instance.
    */
-  openWebConsole:
-  function HS_openWebConsole(aTarget, aIframeWindow, aChromeWindow)
-  {
-    let hud = new WebConsole(aTarget, aIframeWindow, aChromeWindow);
+  openWebConsole(target, iframeWindow, chromeWindow) {
+    let hud = new WebConsole(target, iframeWindow, chromeWindow);
     this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
    * Open a Browser Console for the given target.
    *
    * @see devtools/framework/target.js for details about targets.
    *
-   * @param object aTarget
+   * @param object target
    *        The target that the browser console will connect to.
-   * @param nsIDOMWindow aIframeWindow
+   * @param nsIDOMWindow iframeWindow
    *        The window where the browser console UI is already loaded.
-   * @param nsIDOMWindow aChromeWindow
+   * @param nsIDOMWindow chromeWindow
    *        The window of the browser console owner.
    * @return object
    *         A promise object for the opening of the new BrowserConsole instance.
    */
-  openBrowserConsole:
-  function HS_openBrowserConsole(aTarget, aIframeWindow, aChromeWindow)
-  {
-    let hud = new BrowserConsole(aTarget, aIframeWindow, aChromeWindow);
+  openBrowserConsole(target, iframeWindow, chromeWindow) {
+    let hud = new BrowserConsole(target, iframeWindow, chromeWindow);
     this._browserConsoleID = hud.hudId;
     this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
    * Returns the Web Console object associated to a content window.
    *
-   * @param nsIDOMWindow aContentWindow
+   * @param nsIDOMWindow contentWindow
    * @returns object
    */
-  getHudByWindow: function HS_getHudByWindow(aContentWindow)
-  {
-    for (let [hudId, hud] of this.consoles) {
+  getHudByWindow(contentWindow) {
+    for (let [, hud] of this.consoles) {
       let target = hud.target;
-      if (target && target.tab && target.window === aContentWindow) {
+      if (target && target.tab && target.window === contentWindow) {
         return hud;
       }
     }
     return null;
   },
 
   /**
    * Returns the console instance for a given id.
    *
-   * @param string aId
+   * @param string id
    * @returns Object
    */
-  getHudReferenceById: function HS_getHudReferenceById(aId)
-  {
-    return this.consoles.get(aId);
+  getHudReferenceById(id) {
+    return this.consoles.get(id);
   },
 
   /**
    * Find if there is a Web Console open for the current tab and return the
    * instance.
    * @return object|null
    *         The WebConsole object or null if the active tab has no open Web
    *         Console.
    */
-  getOpenWebConsole: function HS_getOpenWebConsole()
-  {
+  getOpenWebConsole() {
     let tab = this.currentContext().gBrowser.selectedTab;
     if (!tab || !TargetFactory.isKnownTab(tab)) {
       return null;
     }
     let target = TargetFactory.forTab(tab);
     let toolbox = gDevTools.getToolbox(target);
     let panel = toolbox ? toolbox.getPanel("webconsole") : null;
     return panel ? panel.hud : null;
   },
 
   /**
    * Toggle the Browser Console.
    */
-  toggleBrowserConsole: function HS_toggleBrowserConsole()
-  {
+  toggleBrowserConsole() {
     if (this._browserConsoleID) {
       let hud = this.getHudReferenceById(this._browserConsoleID);
       return hud.destroy();
     }
 
     if (this._browserConsoleDefer) {
       return this._browserConsoleDefer.promise;
     }
 
     this._browserConsoleDefer = defer();
 
-    function connect()
-    {
-      let deferred = defer();
-
-      // Ensure that the root actor and the tab actors have been registered on the DebuggerServer,
-      // so that the Browser Console can retrieve the console actors.
+    function connect() {
+      // Ensure that the root actor and the tab actors have been registered on the
+      // DebuggerServer, so that the Browser Console can retrieve the console actors.
       // (See Bug 1416105 for rationale).
       DebuggerServer.init();
       DebuggerServer.registerActors({ root: true, tab: true });
 
       DebuggerServer.allowChromeProcess = true;
 
       let client = new DebuggerClient(DebuggerServer.connectPipe());
       return client.connect()
         .then(() => client.getProcess())
-        .then(aResponse => {
+        .then(response => {
           // Use a TabActor in order to ensure calling `attach` to the ChromeActor
-          return { form: aResponse.form, client, chrome: true, isTabActor: true };
+          return { form: response.form, client, chrome: true, isTabActor: true };
         });
     }
 
     let target;
-    function getTarget(aConnection)
-    {
-      return TargetFactory.forRemoteTab(aConnection);
+    function getTarget(connection) {
+      return TargetFactory.forRemoteTab(connection);
     }
-    function openWindow(aTarget)
-    {
-      target = aTarget;
+    function openWindow(t) {
+      target = t;
       return new Promise(resolve => {
         let browserConsoleURL = Tools.webConsole.browserConsoleURL;
         let win = Services.ww.openWindow(null, browserConsoleURL, "_blank",
-                                         BROWSER_CONSOLE_WINDOW_FEATURES, null);
+                                         BC_WINDOW_FEATURES, null);
         win.addEventListener("DOMContentLoaded", () => {
           win.document.title = l10n.getStr("browserConsole.title");
           if (browserConsoleURL === Tools.webConsole.oldWebConsoleURL) {
             resolve({iframeWindow: win, chromeWindow: win});
           } else {
-            win.document.querySelector("iframe").addEventListener("DOMContentLoaded", (e) => {
-              resolve({iframeWindow: e.target.defaultView, chromeWindow: win});
-            }, { once: true });
+            win.document.querySelector("iframe").addEventListener("DOMContentLoaded",
+              e => resolve({iframeWindow: e.target.defaultView, chromeWindow: win}),
+              { once: true }
+            );
           }
         }, {once: true});
       });
     }
     connect().then(getTarget).then(openWindow).then(({iframeWindow, chromeWindow}) => {
       return this.openBrowserConsole(target, iframeWindow, chromeWindow)
-        .then((aBrowserConsole) => {
-          this._browserConsoleDefer.resolve(aBrowserConsole);
+        .then(browserConsole => {
+          this._browserConsoleDefer.resolve(browserConsole);
           this._browserConsoleDefer = null;
         });
     }, console.error.bind(console));
 
     return this._browserConsoleDefer.promise;
   },
 
   /**
    * Opens or focuses the Browser Console.
    */
-  openBrowserConsoleOrFocus: function HS_openBrowserConsoleOrFocus()
-  {
+  openBrowserConsoleOrFocus() {
     let hud = this.getBrowserConsole();
     if (hud) {
       hud.iframeWindow.focus();
       return promise.resolve(hud);
     }
-    else {
-      return this.toggleBrowserConsole();
-    }
+
+    return this.toggleBrowserConsole();
   },
 
   /**
    * Get the Browser Console instance, if open.
    *
    * @return object|null
    *         A BrowserConsole instance or null if the Browser Console is not
    *         open.
    */
-  getBrowserConsole: function HS_getBrowserConsole()
-  {
+  getBrowserConsole() {
     return this.getHudReferenceById(this._browserConsoleID);
   },
 };
 
-
 /**
  * A WebConsole instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
  *
  * This object only wraps the iframe that holds the Web Console UI. This is
  * meant to be an integration point between the Firefox UI and the Web Console
  * UI and features.
  *
  * @constructor
- * @param object aTarget
+ * @param object target
  *        The target that the web console will connect to.
- * @param nsIDOMWindow aIframeWindow
+ * @param nsIDOMWindow iframeWindow
  *        The window where the web console UI is already loaded.
- * @param nsIDOMWindow aChromeWindow
+ * @param nsIDOMWindow chromeWindow
  *        The window of the web console owner.
  */
-function WebConsole(aTarget, aIframeWindow, aChromeWindow)
-{
-  this.iframeWindow = aIframeWindow;
-  this.chromeWindow = aChromeWindow;
+function WebConsole(target, iframeWindow, chromeWindow) {
+  this.iframeWindow = iframeWindow;
+  this.chromeWindow = chromeWindow;
   this.hudId = "hud_" + ++gHudId;
-  this.target = aTarget;
+  this.target = target;
   this.browserWindow = this.chromeWindow.top;
   let element = this.browserWindow.document.documentElement;
   if (element.getAttribute("windowtype") != gDevTools.chromeWindowType) {
     this.browserWindow = HUDService.currentContext();
   }
-  if (aIframeWindow.location.href === Tools.webConsole.newWebConsoleURL) {
+  if (iframeWindow.location.href === Tools.webConsole.newWebConsoleURL) {
     this.ui = new NewWebConsoleFrame(this);
   } else {
     this.ui = new WebConsoleFrame(this);
   }
 }
 WebConsole.prototype = {
   iframeWindow: null,
   chromeWindow: null,
@@ -315,221 +297,210 @@ WebConsole.prototype = {
 
   /**
    * Getter for a function to to listen for every request that completes. Used
    * by unit tests. The callback takes one argument: the HTTP activity object as
    * received from the remote Web Console.
    *
    * @type function
    */
-  get lastFinishedRequestCallback()
-  {
+  get lastFinishedRequestCallback() {
     return HUDService.lastFinishedRequest.callback;
   },
 
   /**
    * Getter for the window that can provide various utilities that the web
    * console makes use of, like opening links, managing popups, etc.  In
    * most cases, this will be |this.browserWindow|, but in some uses (such as
    * the Browser Toolbox), there is no browser window, so an alternative window
    * hosts the utilities there.
    * @type nsIDOMWindow
    */
-  get chromeUtilsWindow()
-  {
+  get chromeUtilsWindow() {
     if (this.browserWindow) {
       return this.browserWindow;
     }
     return this.chromeWindow.top;
   },
 
   /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
-  get mainPopupSet()
-  {
+  get mainPopupSet() {
     return this.chromeUtilsWindow.document.getElementById("mainPopupSet");
   },
 
   /**
    * Getter for the output element that holds messages we display.
    * @type nsIDOMElement
    */
-  get outputNode()
-  {
+  get outputNode() {
     return this.ui ? this.ui.outputNode : null;
   },
 
-  get gViewSourceUtils()
-  {
+  get gViewSourceUtils() {
     return this.chromeUtilsWindow.gViewSourceUtils;
   },
 
   /**
    * Initialize the Web Console instance.
    *
    * @return object
    *         A promise for the initialization.
    */
-  init: function WC_init()
-  {
+  init() {
     return this.ui.init().then(() => this);
   },
 
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
-  getPanelTitle: function WC_getPanelTitle()
-  {
+  getPanelTitle() {
     let url = this.ui ? this.ui.contentLocation : "";
     return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
   },
 
   /**
    * The JSTerm object that manages the console's input.
    * @see webconsole.js::JSTerm
    * @type object
    */
-  get jsterm()
-  {
+  get jsterm() {
     return this.ui ? this.ui.jsterm : null;
   },
 
   /**
    * The clear output button handler.
    * @private
    */
-  _onClearButton: function WC__onClearButton()
-  {
+  _onClearButton() {
     if (this.target.isLocalTab) {
       gDevToolsBrowser.getDeveloperToolbar(this.browserWindow)
         .resetErrorsCount(this.target.tab);
     }
   },
 
   /**
    * Alias for the WebConsoleFrame.setFilterState() method.
    * @see webconsole.js::WebConsoleFrame.setFilterState()
    */
-  setFilterState: function WC_setFilterState()
-  {
+  setFilterState() {
     this.ui && this.ui.setFilterState.apply(this.ui, arguments);
   },
 
   /**
    * Open a link in a new tab.
    *
-   * @param string aLink
+   * @param string link
    *        The URL you want to open in a new tab.
    */
-  openLink: function WC_openLink(aLink, e)
-  {
+  openLink(link, e) {
     let isOSX = Services.appinfo.OS == "Darwin";
-    if (e != null && (e.button === 1 || (e.button === 0 && (isOSX ? e.metaKey : e.ctrlKey)))) {
-      this.chromeUtilsWindow.openUILinkIn(aLink, "tabshifted");
+    if (e && (e.button === 1 || (e.button === 0 && (isOSX ? e.metaKey : e.ctrlKey)))) {
+      this.chromeUtilsWindow.openUILinkIn(link, "tabshifted");
     } else {
-      this.chromeUtilsWindow.openUILinkIn(aLink, "tab");
+      this.chromeUtilsWindow.openUILinkIn(link, "tab");
     }
   },
 
   /**
    * Open a link in Firefox's view source.
    *
-   * @param string aSourceURL
+   * @param string sourceURL
    *        The URL of the file.
-   * @param integer aSourceLine
+   * @param integer sourceLine
    *        The line number which should be highlighted.
    */
-  viewSource: function WC_viewSource(aSourceURL, aSourceLine) {
+  viewSource(sourceURL, sourceLine) {
     // Attempt to access view source via a browser first, which may display it in
     // a tab, if enabled.
     let browserWin = Services.wm.getMostRecentWindow(gDevTools.chromeWindowType);
     if (browserWin && browserWin.BrowserViewSourceOfDocument) {
       return browserWin.BrowserViewSourceOfDocument({
-        URL: aSourceURL,
-        lineNumber: aSourceLine
+        URL: sourceURL,
+        lineNumber: sourceLine
       });
     }
-    this.gViewSourceUtils.viewSource(aSourceURL, null, this.iframeWindow.document, aSourceLine || 0);
+    return this.gViewSourceUtils.viewSource(
+      sourceURL, null, this.iframeWindow.document, sourceLine || 0);
   },
 
   /**
    * Tries to open a Stylesheet file related to the web page for the web console
    * instance in the Style Editor. If the file is not found, it is opened in
    * source view instead.
    *
    * Manually handle the case where toolbox does not exist (Browser Console).
    *
-   * @param string aSourceURL
+   * @param string sourceURL
    *        The URL of the file.
-   * @param integer aSourceLine
+   * @param integer sourceLine
    *        The line number which you want to place the caret.
    */
-  viewSourceInStyleEditor: function WC_viewSourceInStyleEditor(aSourceURL, aSourceLine) {
+  viewSourceInStyleEditor(sourceURL, sourceLine) {
     let toolbox = gDevTools.getToolbox(this.target);
     if (!toolbox) {
-      this.viewSource(aSourceURL, aSourceLine);
+      this.viewSource(sourceURL, sourceLine);
       return;
     }
-    toolbox.viewSourceInStyleEditor(aSourceURL, aSourceLine);
+    toolbox.viewSourceInStyleEditor(sourceURL, sourceLine);
   },
 
   /**
    * Tries to open a JavaScript file related to the web page for the web console
    * instance in the Script Debugger. If the file is not found, it is opened in
    * source view instead.
    *
    * Manually handle the case where toolbox does not exist (Browser Console).
    *
-   * @param string aSourceURL
+   * @param string sourceURL
    *        The URL of the file.
-   * @param integer aSourceLine
+   * @param integer sourceLine
    *        The line number which you want to place the caret.
    */
-  viewSourceInDebugger: function WC_viewSourceInDebugger(aSourceURL, aSourceLine) {
+  viewSourceInDebugger(sourceURL, sourceLine) {
     let toolbox = gDevTools.getToolbox(this.target);
     if (!toolbox) {
-      this.viewSource(aSourceURL, aSourceLine);
+      this.viewSource(sourceURL, sourceLine);
       return;
     }
-    toolbox.viewSourceInDebugger(aSourceURL, aSourceLine).then(() => {
+    toolbox.viewSourceInDebugger(sourceURL, sourceLine).then(() => {
       this.ui.emit("source-in-debugger-opened");
     });
   },
 
   /**
    * Tries to open a JavaScript file related to the web page for the web console
    * instance in the corresponding Scratchpad.
    *
-   * @param string aSourceURL
+   * @param string sourceURL
    *        The URL of the file which corresponds to a Scratchpad id.
    */
-  viewSourceInScratchpad: function WC_viewSourceInScratchpad(aSourceURL, aSourceLine) {
-    viewSource.viewSourceInScratchpad(aSourceURL, aSourceLine);
+  viewSourceInScratchpad(sourceURL, sourceLine) {
+    viewSource.viewSourceInScratchpad(sourceURL, sourceLine);
   },
 
   /**
    * Retrieve information about the JavaScript debugger's stackframes list. This
    * is used to allow the Web Console to evaluate code in the selected
    * stackframe.
    *
    * @return object|null
    *         An object which holds:
    *         - frames: the active ThreadClient.cachedFrames array.
    *         - selected: depth/index of the selected stackframe in the debugger
    *         UI.
    *         If the debugger is not open or if it's not paused, then |null| is
    *         returned.
    */
-  getDebuggerFrames: function WC_getDebuggerFrames()
-  {
+  getDebuggerFrames() {
     let toolbox = gDevTools.getToolbox(this.target);
     if (!toolbox) {
       return null;
     }
     let panel = toolbox.getPanel("jsdebugger");
 
     if (!panel) {
       return null;
@@ -544,18 +515,17 @@ WebConsole.prototype = {
    * Console server for the $0 helper.
    *
    * @return object|null
    *         A Selection referring to the currently selected node in the
    *         Inspector.
    *         If the inspector was never opened, or no node was ever selected,
    *         then |null| is returned.
    */
-  getInspectorSelection: function WC_getInspectorSelection()
-  {
+  getInspectorSelection() {
     let toolbox = gDevTools.getToolbox(this.target);
     if (!toolbox) {
       return null;
     }
     let panel = toolbox.getPanel("inspector");
     if (!panel || !panel.selection) {
       return null;
     }
@@ -564,18 +534,17 @@ WebConsole.prototype = {
 
   /**
    * Destroy the object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    *
    * @return object
    *         A promise object that is resolved once the Web Console is closed.
    */
-  destroy: function WC_destroy()
-  {
+  destroy() {
     if (this._destroyer) {
       return this._destroyer.promise;
     }
 
     HUDService.consoles.delete(this.hudId);
 
     this._destroyer = defer();
 
@@ -587,31 +556,29 @@ WebConsole.prototype = {
         panel.hidePopup();
       }
     }
 
     let onDestroy = Task.async(function* () {
       if (!this._browserConsole) {
         try {
           yield this.target.activeTab.focus();
-        }
-        catch (ex) {
+        } catch (ex) {
           // Tab focus can fail if the tab or target is closed.
         }
       }
 
       let id = WebConsoleUtils.supportsString(this.hudId);
       Services.obs.notifyObservers(id, "web-console-destroyed");
       this._destroyer.resolve(null);
     }.bind(this));
 
     if (this.ui) {
       this.ui.destroy().then(onDestroy);
-    }
-    else {
+    } else {
       onDestroy();
     }
 
     return this._destroyer.promise;
   },
 };
 
 /**
@@ -619,52 +586,50 @@ WebConsole.prototype = {
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
  *
  * This object only wraps the iframe that holds the Browser Console UI. This is
  * meant to be an integration point between the Firefox UI and the Browser Console
  * UI and features.
  *
  * @constructor
- * @param object aTarget
+ * @param object target
  *        The target that the browser console will connect to.
- * @param nsIDOMWindow aIframeWindow
+ * @param nsIDOMWindow iframeWindow
  *        The window where the browser console UI is already loaded.
- * @param nsIDOMWindow aChromeWindow
+ * @param nsIDOMWindow chromeWindow
  *        The window of the browser console owner.
  */
-function BrowserConsole()
-{
+function BrowserConsole() {
   WebConsole.apply(this, arguments);
   this._telemetry = new Telemetry();
 }
 
 BrowserConsole.prototype = extend(WebConsole.prototype, {
   _browserConsole: true,
-  _bc_init: null,
-  _bc_destroyer: null,
+  _bcInit: null,
+  _bcDestroyer: null,
 
   $init: WebConsole.prototype.init,
 
   /**
    * Initialize the Browser Console instance.
    *
    * @return object
    *         A promise for the initialization.
    */
-  init: function BC_init()
-  {
-    if (this._bc_init) {
-      return this._bc_init;
+  init() {
+    if (this._bcInit) {
+      return this._bcInit;
     }
 
     // Only add the shutdown observer if we've opened a Browser Console window.
     ShutdownObserver.init();
 
-    this.ui._filterPrefsPrefix = BROWSER_CONSOLE_FILTER_PREFS_PREFIX;
+    this.ui._filterPrefsPrefix = BC_FILTER_PREFS_PREFIX;
 
     let window = this.iframeWindow;
 
     // Make sure that the closing of the Browser Console window destroys this
     // instance.
     let onClose = () => {
       window.removeEventListener("unload", onClose);
       window.removeEventListener("focus", onFocus);
@@ -675,47 +640,46 @@ BrowserConsole.prototype = extend(WebCon
     this._telemetry.toolOpened("browserconsole");
 
     // Create an onFocus handler just to display the dev edition promo.
     // This is to prevent race conditions in some environments.
     // Hook to display promotional Developer Edition doorhanger. Only displayed once.
     let onFocus = () => showDoorhanger({ window, type: "deveditionpromo" });
     window.addEventListener("focus", onFocus);
 
-    this._bc_init = this.$init();
-    return this._bc_init;
+    this._bcInit = this.$init();
+    return this._bcInit;
   },
 
   $destroy: WebConsole.prototype.destroy,
 
   /**
    * Destroy the object.
    *
    * @return object
    *         A promise object that is resolved once the Browser Console is closed.
    */
-  destroy: function BC_destroy()
-  {
-    if (this._bc_destroyer) {
-      return this._bc_destroyer.promise;
+  destroy() {
+    if (this._bcDestroyer) {
+      return this._bcDestroyer.promise;
     }
 
     this._telemetry.toolClosed("browserconsole");
 
-    this._bc_destroyer = defer();
+    this._bcDestroyer = defer();
 
     let chromeWindow = this.chromeWindow;
     this.$destroy().then(() =>
       this.target.client.close().then(() => {
         HUDService._browserConsoleID = null;
         chromeWindow.close();
-        this._bc_destroyer.resolve(null);
+        this._bcDestroyer.resolve(null);
       }));
 
-    return this._bc_destroyer.promise;
+    return this._bcDestroyer.promise;
   },
 });
 
 const HUDService = new HUD_SERVICE();
 exports.HUDService = HUDService;
 
 /**
  * The ShutdownObserver listens for app shutdown and saves the current state
