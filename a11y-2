# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f3da8ae9d1a3e74cd273746da51a035ddc572bee

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,23 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  width: 60%;
+  justify-self: end;
+}
+
+.browserStack > .a11ymode {
+  justify-self: start;
+  width: 40%;
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -2077,32 +2077,49 @@
       remoteType,
       replayExecution,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+      let a11ymodeBrowser = document.createXULElement("browser");
+      // This will let us go from tab to a11ymode browser:
+      b.a11ymodeBrowser = a11ymodeBrowser;
+      // This will let us go from a11ymode to tab:
+      a11ymodeBrowser.linkedBrowser = b;
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
       b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
         type: "content",
       };
       for (let attribute in defaultBrowserAttributes) {
         b.setAttribute(attribute, defaultBrowserAttributes[attribute]);
+
+        if (
+          attribute != "messagemanagergroup" &&
+          attribute != "message" &&
+          attribute != "type"
+        ) {
+          a11ymodeBrowser.setAttribute(
+            attribute,
+            defaultBrowserAttributes[attribute]
+          );
+        }
       }
 
       if (userContextId) {
         b.setAttribute("usercontextid", userContextId);
       }
 
       if (remoteType) {
         b.setAttribute("remoteType", remoteType);
@@ -2121,19 +2138,24 @@
         if (remoteType) {
           throw new Error("Cannot set opener window on a remote browser!");
         }
         b.presetOpenerWindow(openerWindow);
       }
 
       if (!isPreloadBrowser) {
         b.setAttribute("autocompletepopup", "PopupAutoComplete");
+        a11ymodeBrowser.setAttribute("autocompletepopup", "PopupAutoComplete");
       }
       if (this._autoScrollPopup) {
         b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
+        a11ymodeBrowser.setAttribute(
+          "autoscrollpopup",
+          this._autoScrollPopup.id
+        );
       }
 
       /*
        * This attribute is meant to describe if the browser is the
        * preloaded browser. There are 2 defined states: "preloaded" or
        * "consumed". The order of events goes as follows:
        *   1. The preloaded browser is created and the 'preloadedState'
        *      attribute for that browser is set to "preloaded".
@@ -2155,16 +2177,17 @@
           throw new Error("Cannot have nextRemoteTabId without a remoteType");
         }
         // Gecko is going to read this attribute and use it.
         b.setAttribute("nextRemoteTabId", nextRemoteTabId.toString());
       }
 
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
+        a11ymodeBrowser.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
 
       // This will be used by gecko to control the name of the opened
       // window.
       if (name) {
         // XXX: The `name` property is special in HTML and XUL. Should
         // we use a different attribute name for this?
         b.setAttribute("name", name);
@@ -2179,16 +2202,27 @@
       // flex=0 it can't. When the toolbox is on the bottom it's a sibling of
       // browserStack, and when it's on the side it's a sibling of
       // browserContainer.
       let stack = document.createXULElement("stack");
       stack.className = "browserStack";
       stack.appendChild(b);
       stack.setAttribute("flex", "10000");
 
+      a11ymodeBrowser.classList.add("a11ymode");
+      stack.appendChild(a11ymodeBrowser);
+
+      // try {
+      //   a11ymodeBrowser.loadURI("about:a11ymode", {
+      //     triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+      //   });
+      // } catch (ex) {
+      //   Cu.reportError(ex);
+      // }
+
       let browserContainer = document.createXULElement("vbox");
       browserContainer.className = "browserContainer";
       browserContainer.appendChild(notificationbox);
       browserContainer.appendChild(stack);
       browserContainer.setAttribute("flex", "10000");
 
       let browserSidebarContainer = document.createXULElement("hbox");
       browserSidebarContainer.className = "browserSidebarContainer";
@@ -3779,16 +3813,19 @@
       if (this._switcher) {
         this._switcher.onTabRemoved(aTab);
       }
 
       // This will unload the document. An unload handler could remove
       // dependant tabs, so it's important that the tabbrowser is now in
       // a consistent state (tab removed, tab positions updated, etc.).
       browser.remove();
+      if (browser.a11ymodeBrowser) {
+        browser.a11ymodeBrowser.remove();
+      }
 
       // Release the browser in case something is erroneously holding a
       // reference to the tab after its removal.
       this._tabForBrowser.delete(aTab.linkedBrowser);
       aTab.linkedBrowser = null;
 
       panel.remove();
 
@@ -5160,17 +5197,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
diff --git a/devtools/client/accessibility/accessibility-view.js b/devtools/client/accessibility/accessibility-view.js
--- a/devtools/client/accessibility/accessibility-view.js
+++ b/devtools/client/accessibility/accessibility-view.js
@@ -91,81 +91,102 @@ AccessibilityView.prototype = {
     fluentBundles,
     toolbox,
     getAccessibilityTreeRoot,
     startListeningForAccessibilityEvents,
     stopListeningForAccessibilityEvents,
     audit,
     simulate,
   }) {
-    // Make sure state is reset every time accessibility panel is initialized.
-    await this.store.dispatch(reset(front, supports));
-    const container = document.getElementById("content");
-    const mainFrame = MainFrame({
-      accessibility: front,
-      fluentBundles,
-      toolbox,
-      getAccessibilityTreeRoot,
-      startListeningForAccessibilityEvents,
-      stopListeningForAccessibilityEvents,
-      audit,
-      simulate,
-    });
-    // Render top level component
-    const provider = createElement(Provider, { store: this.store }, mainFrame);
-    this.mainFrame = ReactDOM.render(provider, container);
+    // console.log(getAccessibilityTreeRoot());
+    // startListeningForAccessibilityEvents({
+    //   reorder: function() {
+    //     // console.trace(arguments);
+    //   },
+    //   "name-change": function() {
+    //     // console.trace(arguments);
+    //   },
+    //   "text-change": function() {
+    //     // console.trace(arguments);
+    //   },
+    //   "document-ready": function() {
+    //     // console.trace(arguments);
+    //   },
+    // });
+
+    // const walkerFront = getAccessibilityTreeRoot();
+    // const children = await walkerFront.children();
+    // const rootAccessibleFront = children[0];
+    // console.trace("Initializing a11y view", walkerFront, rootAccessibleFront);
+
+    // // Make sure state is reset every time accessibility panel is initialized.
+    // await this.store.dispatch(reset(front, supports));
+
+    // const container = document.getElementById("content");
+    // const mainFrame = MainFrame({
+    //   accessibility: front,
+    //   fluentBundles,
+    //   toolbox,
+    //   getAccessibilityTreeRoot,
+    //   startListeningForAccessibilityEvents,
+    //   stopListeningForAccessibilityEvents,
+    //   audit,
+    //   simulate,
+    // });
+
+    // // Render top level component
+    // const provider = createElement(Provider, { store: this.store }, mainFrame);
+    // this.mainFrame = ReactDOM.render(provider, container);
   },
 
   destroy() {
-    const container = document.getElementById("content");
-    ReactDOM.unmountComponentAtNode(container);
+    document.body.innerHTML = "";
+    // const container = document.getElementById("content");
+    // ReactDOM.unmountComponentAtNode(container);
   },
 
   async selectAccessible(accessible) {
-    await this.store.dispatch(select(accessible));
-    window.emit(EVENTS.NEW_ACCESSIBLE_FRONT_INSPECTED);
+    // await this.store.dispatch(select(accessible));
+    // window.emit(EVENTS.NEW_ACCESSIBLE_FRONT_INSPECTED);
   },
 
   async highlightAccessible(accessible) {
-    await this.store.dispatch(highlight(accessible));
-    window.emit(EVENTS.NEW_ACCESSIBLE_FRONT_HIGHLIGHTED);
+    // await this.store.dispatch(highlight(accessible));
+    // window.emit(EVENTS.NEW_ACCESSIBLE_FRONT_HIGHLIGHTED);
   },
 
   async selectNodeAccessible(node) {
-    const accessibilityFront = await node.targetFront.getFront("accessibility");
-    const accessibleWalkerFront = await accessibilityFront.getWalker();
-    let accessible = await accessibleWalkerFront.getAccessibleFor(node);
-    if (accessible) {
-      await accessible.hydrate();
-    }
-
-    // If node does not have an accessible object, try to find node's child text node and
-    // try to retrieve an accessible object for that child instead. This is the best
-    // effort approach until there's accessibility API to retrieve accessible object at
-    // point.
-    if (!accessible || accessible.indexInParent < 0) {
-      const { nodes: children } = await node.walkerFront.children(node);
-      for (const child of children) {
-        if (child.nodeType === nodeConstants.TEXT_NODE) {
-          accessible = await accessibleWalkerFront.getAccessibleFor(child);
-          // indexInParent property is only available with additional request
-          // for data (hydration) about the accessible object.
-          if (accessible) {
-            await accessible.hydrate();
-          }
-
-          if (accessible.indexInParent >= 0) {
-            break;
-          }
-        }
-      }
-    }
-
-    await this.store.dispatch(select(accessible));
-    window.emit(EVENTS.NEW_ACCESSIBLE_FRONT_INSPECTED);
+    // const accessibilityFront = await node.targetFront.getFront("accessibility");
+    // const accessibleWalkerFront = await accessibilityFront.getWalker();
+    // let accessible = await accessibleWalkerFront.getAccessibleFor(node);
+    // if (accessible) {
+    //   await accessible.hydrate();
+    // }
+    // // If node does not have an accessible object, try to find node's child text node and
+    // // try to retrieve an accessible object for that child instead. This is the best
+    // // effort approach until there's accessibility API to retrieve accessible object at
+    // // point.
+    // if (!accessible || accessible.indexInParent < 0) {
+    //   const { nodes: children } = await node.walkerFront.children(node);
+    //   for (const child of children) {
+    //     if (child.nodeType === nodeConstants.TEXT_NODE) {
+    //       accessible = await accessibleWalkerFront.getAccessibleFor(child);
+    //       // indexInParent property is only available with additional request
+    //       // for data (hydration) about the accessible object.
+    //       if (accessible) {
+    //         await accessible.hydrate();
+    //       }
+    //       if (accessible.indexInParent >= 0) {
+    //         break;
+    //       }
+    //     }
+    //   }
+    // }
+    // await this.store.dispatch(select(accessible));
+    // window.emit(EVENTS.NEW_ACCESSIBLE_FRONT_INSPECTED);
   },
 
   /**
    * Process message from accessibility panel.
    *
    * @param {Object} event  message type and data.
    */
   onMessage(event) {
@@ -174,8 +195,9 @@ AccessibilityView.prototype = {
 
     if (typeof this[method] === "function") {
       this[method](...data.args);
     }
   },
 };
 
 window.view = new AccessibilityView(store);
+
diff --git a/devtools/client/accessibility/accessibility.css b/devtools/client/accessibility/accessibility.css
--- a/devtools/client/accessibility/accessibility.css
+++ b/devtools/client/accessibility/accessibility.css
@@ -57,16 +57,27 @@ body {
 }
 
 @keyframes flash-out {
   from {
     background: var(--theme-contrast-background);
   }
 }
 
+body {
+  display: flex;
+}
+aside {
+  flex: 0;
+}
+aside button {
+  display: block;
+}
+
+
 .accessible .tree .node .theme-twisty {
   width: var(--accessibility-horizontal-indent);
 }
 
 .accessible .tree .node .theme-twisty:not(.open):dir(rtl) {
   transform: rotate(-90deg);
 }
 
diff --git a/devtools/client/accessibility/index.html b/devtools/client/accessibility/index.html
--- a/devtools/client/accessibility/index.html
+++ b/devtools/client/accessibility/index.html
@@ -13,12 +13,18 @@
   <link href="resource://devtools/client/shared/components/splitter/SplitBox.css" rel="stylesheet" />
   <link href="resource://devtools/client/shared/components/Accordion.css" rel="stylesheet" />
   <link href="resource://devtools/client/shared/components/List.css" rel="stylesheet" />
   <link href="resource://devtools/client/shared/components/tree/TreeView.css" rel="stylesheet" />
 
   <script src="chrome://devtools/content/shared/theme-switching.js"></script>
 </head>
 <body class="theme-body devtools-monospace" role="application">
+  <aside>
+    <button>1</button>
+    <button>2</button>
+    <button>3</button>
+    <button>4</button>
+  </aside>
   <div id="content" role="presentation"></div>
   <script src="./main.js"></script>
 </body>
 </html>
diff --git a/devtools/client/accessibility/panel.js b/devtools/client/accessibility/panel.js
--- a/devtools/client/accessibility/panel.js
+++ b/devtools/client/accessibility/panel.js
@@ -1,15 +1,22 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Services = require("Services");
 const { L10nRegistry } = require("resource://gre/modules/L10nRegistry.jsm");
+const { Cc, Ci } = require("chrome");
+
+// This turns on accessibility automatically (see Services.appinfo.accessibilityEnabled)
+// See https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/accessibility-parent.js#135 for more lifecycle
+const accService = Cc["@mozilla.org/accessibilityService;1"].getService(
+  Ci.nsIAccessibilityService
+);
 
 const EventEmitter = require("devtools/shared/event-emitter");
 
 const Telemetry = require("devtools/client/shared/telemetry");
 
 const { Picker } = require("devtools/client/accessibility/picker");
 const {
   A11Y_SERVICE_DURATION,
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -820,16 +820,23 @@ Toolbox.prototype = {
       // The isTargetSupported check needs to happen after the target is
       // remoted, otherwise we could have done it in the toolbox constructor
       // (bug 1072764).
       const toolDef = gDevTools.getToolDefinition(this._defaultToolId);
       if (!toolDef || !toolDef.isTargetSupported(this.target)) {
         this._defaultToolId = "webconsole";
       }
 
+      const url = new URL(this.win.location);
+      const searchParams = new this.win.URLSearchParams(url.search);
+
+      if (searchParams.get("a11ymode")) {
+        this._defaultToolId = "accessibility";
+        this.doc.documentElement.classList.add("a11ymode");
+      }
       // Start rendering the toolbox toolbar before selecting the tool, as the tools
       // can take a few hundred milliseconds seconds to start up.
       //
       // Delay React rendering as Toolbox.open is synchronous.
       // Even if this involve promises, it is synchronous. Toolbox.open already loads
       // react modules and freeze the event loop for a significant time.
       // requestIdleCallback allows releasing it to allow user events to be processed.
       // Use 16ms maximum delay to allow one frame to be rendered at 60FPS
diff --git a/devtools/client/themes/toolbox.css b/devtools/client/themes/toolbox.css
--- a/devtools/client/themes/toolbox.css
+++ b/devtools/client/themes/toolbox.css
@@ -1,12 +1,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+.a11ymode .debug-target-info,
+.a11ymode .devtools-tabbar {
+  display: none;
+}
 /*
  *  Debug Target Info layout
  *  +------------+--------------+------------------------+
  *  | connection | runtime info | target info icon + text |
  *  +------------+--------------+------------------------+
  */
 .debug-target-info {
   display: flex;
diff --git a/devtools/server/actors/accessibility/accessible.js b/devtools/server/actors/accessibility/accessible.js
--- a/devtools/server/actors/accessibility/accessible.js
+++ b/devtools/server/actors/accessibility/accessible.js
@@ -76,43 +76,46 @@ const CSS_TEXT_SELECTOR = "#text";
 function getNodeDescription(node) {
   if (!node || Cu.isDeadWrapper(node)) {
     return { nodeType: undefined, nodeCssSelector: "" };
   }
 
   const { nodeType } = node;
   return {
     nodeType,
-    // If node is a text node, we find a unique CSS selector for its parent and add a
-    // CSS_TEXT_SELECTOR postfix to indicate that it's a text node.
-    nodeCssSelector:
-      nodeType === Node.TEXT_NODE
-        ? `${findCssSelector(node.parentNode)}${CSS_TEXT_SELECTOR}`
-        : findCssSelector(node),
+    nodeCssSelector: null,
+    // // If node is a text node, we find a unique CSS selector for its parent and add a
+    // // CSS_TEXT_SELECTOR postfix to indicate that it's a text node.
+    // nodeCssSelector:
+    //   nodeType === Node.TEXT_NODE
+    //     ? `${findCssSelector(node.parentNode)}${CSS_TEXT_SELECTOR}`
+    //     : findCssSelector(node),
   };
 }
 
 /**
  * Get a snapshot of the nsIAccessible object including its subtree. None of the subtree
  * queried here is cached via accessible walker's refMap.
  * @param  {nsIAccessible} acc
  *         Accessible object to take a snapshot of.
  * @param  {nsIAccessibilityService} a11yService
  *         Accessibility service instance in the current process, used to get localized
  *         string representation of various accessible properties.
  * @return {JSON}
  *         JSON snapshot of the accessibility tree with root at current accessible.
  */
-function getSnapshot(acc, a11yService) {
+function getSnapshot(acc, a11yService, recurse) {
   if (isDefunct(acc)) {
     return {
       states: [a11yService.getStringStates(0, STATE_DEFUNCT)],
     };
   }
 
+  let time;
+  time = Date.now();
   const actions = [];
   for (let i = 0; i < acc.actionCount; i++) {
     actions.push(acc.getActionDescription(i));
   }
 
   const attributes = {};
   if (acc.attributes) {
     for (const { key, value } of acc.attributes.enumerate()) {
@@ -122,35 +125,44 @@ function getSnapshot(acc, a11yService) {
 
   const state = {};
   const extState = {};
   acc.getState(state, extState);
   const states = [...a11yService.getStringStates(state.value, extState.value)];
 
   const children = [];
   for (let child = acc.firstChild; child; child = child.nextSibling) {
-    children.push(getSnapshot(child, a11yService));
+    children.push(getSnapshot(child, a11yService, true));
   }
 
   const { nodeType, nodeCssSelector } = getNodeDescription(acc.DOMNode);
-  return {
+
+
+  let ret = {
     name: acc.name,
     role: a11yService.getStringRole(acc.role),
     actions,
     value: acc.value,
     nodeCssSelector,
     nodeType,
     description: acc.description,
     keyboardShortcut: acc.accessKey || acc.keyboardShortcut,
     childCount: acc.childCount,
     indexInParent: acc.indexInParent,
     states,
     children,
     attributes,
   };
+
+  if (!recurse) {
+    console.log("took", Date.now() - time, JSON.stringify(ret).length);
+    time = Date.now();
+  }
+
+  return ret;
 }
 
 /**
  * The AccessibleActor provides information about a given accessible object: its
  * role, name, states, etc.
  */
 const AccessibleActor = ActorClassWithSpec(accessibleSpec, {
   initialize(walker, rawAccessible) {
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -1397,16 +1397,32 @@
       if (!this.isRemoteBrowser) {
         return this._receiveMessage(aMessage);
       }
 
       let data = aMessage.data;
       switch (aMessage.name) {
         case "Browser:Init":
           this._outerWindowID = data.outerWindowID;
+          // XXX: move this
+          if (this.a11ymodeBrowser) {
+            // setTimeout(() => {
+            // let tab = gBrowser._tabForBrowser.get(this);
+            // console.log(tab, tab.outerWindowID, this._outerWindowID);
+            this.a11ymodeBrowser.loadURI(
+              `about:devtools-toolbox?type=tab&id=${
+                this._outerWindowID
+              }&a11ymode=true`,
+              {
+                triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+              }
+            );
+            // }, 10000);
+          }
+
           break;
         case "DOMTitleChanged":
           this._contentTitle = data.title;
           break;
         default:
           return this._receiveMessage(aMessage);
       }
       return undefined;
