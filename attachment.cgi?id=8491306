# HG changeset patch
# Parent 0d1299b49f174eeba9ef2d81e725c69418edbb35
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 1020244 - Chrome-only window API to insert anonymous content in nsCanvasFrame; r=ehsan

diff --git a/content/base/public/nsIDocument.h b/content/base/public/nsIDocument.h
--- a/content/base/public/nsIDocument.h
+++ b/content/base/public/nsIDocument.h
@@ -709,16 +709,32 @@ public:
    * the channel has not been set.
    */
   nsresult GetSrcdocData(nsAString& aSrcdocData);
 
   bool DidDocumentOpen() {
     return mDidDocumentOpen;
   }
 
+  /**
+   * Set the frame custom content container
+   */
+  void SetFrameCustomContentContainer(Element* aFrameCustomContentContainer)
+  {
+    mFrameCustomContentContainer = aFrameCustomContentContainer;
+  }
+
+  /**
+   * Get the frame custom content container
+   */
+  Element* GetFrameCustomContentContainer() const
+  {
+    return mFrameCustomContentContainer;
+  }
+
 protected:
   virtual Element *GetRootElementInternal() const = 0;
 
 private:
   class SelectorCacheKey
   {
     public:
       explicit SelectorCacheKey(const nsAString& aString) : mKey(aString)
@@ -2722,16 +2738,20 @@ protected:
   nsCOMPtr<nsIVariant> mStateObjectCached;
 
   uint32_t mInSyncOperationCount;
 
   nsRefPtr<mozilla::dom::XPathEvaluator> mXPathEvaluator;
 
   uint32_t mBlockDOMContentLoaded;
   bool mDidFireDOMContentLoaded:1;
+
+  // Temporarily stores the nsCanvasFrame's custom content container so that it
+  // can be restored whenever the frame is reconstructed
+  Element* mFrameCustomContentContainer;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIDocument, NS_IDOCUMENT_IID)
 
 /**
  * mozAutoSubtreeModified batches DOM mutations so that a DOMSubtreeModified
  * event is dispatched, if necessary, when the outermost mozAutoSubtreeModified
  * object is deleted.
diff --git a/dom/base/AnonymousContent.cpp b/dom/base/AnonymousContent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/base/AnonymousContent.cpp
@@ -0,0 +1,146 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "AnonymousContent.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/dom/AnonymousContentBinding.h"
+#include "nsIDocument.h"
+#include "nsIDOMHTMLCollection.h"
+#include "nsStyledElement.h"
+#include "nsVoidArray.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(AnonymousContent, mContentNode, mOwner)
+
+NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(AnonymousContent, AddRef)
+NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(AnonymousContent, Release)
+
+AnonymousContent::AnonymousContent(Element* aContentNode) :
+  mContentNode(aContentNode)
+{
+  mOwner = mContentNode->OwnerDoc();
+  SetIsDOMBinding();
+}
+
+AnonymousContent::~AnonymousContent()
+{
+}
+
+nsCOMPtr<Element>
+AnonymousContent::GetContentNode()
+{
+  return mContentNode;
+}
+
+void
+AnonymousContent::SetTextContentForElement(const nsAString& aElementId,
+                                           const nsAString& aText,
+                                           ErrorResult& aRv)
+{
+  Element* element = GetElementById(aElementId);
+  if (!element) {
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+    return;
+  }
+
+  element->SetTextContent(aText, aRv);
+}
+
+void
+AnonymousContent::GetTextContentForElement(const nsAString& aElementId,
+                                           DOMString& aText,
+                                           ErrorResult& aRv)
+{
+  Element* element = GetElementById(aElementId);
+  if (!element) {
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+    return;
+  }
+
+  element->GetTextContent(aText, aRv);
+}
+
+void
+AnonymousContent::SetAttributeForElement(const nsAString& aElementId,
+                                         const nsAString& aName,
+                                         const nsAString& aValue,
+                                         ErrorResult& aRv)
+{
+  Element* element = GetElementById(aElementId);
+  if (!element) {
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+    return;
+  }
+
+  element->SetAttribute(aName, aValue, aRv);
+}
+
+void
+AnonymousContent::GetAttributeForElement(const nsAString& aElementId,
+                                         const nsAString& aName,
+                                         DOMString& aValue,
+                                         ErrorResult& aRv)
+{
+  Element* element = GetElementById(aElementId);
+  if (!element) {
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+    return;
+  }
+
+  element->GetAttribute(aName, aValue);
+}
+
+void
+AnonymousContent::RemoveAttributeForElement(const nsAString& aElementId,
+                                            const nsAString& aName,
+                                            ErrorResult& aRv)
+{
+  Element* element = GetElementById(aElementId);
+  if (!element) {
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+    return;
+  }
+
+  element->RemoveAttribute(aName, aRv);
+}
+
+nsICSSDeclaration*
+AnonymousContent::GetStyleForElement(const nsAString& aElementId,
+                                     ErrorResult& aRv)
+{
+  Element* element = GetElementById(aElementId);
+  if (!element) {
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+    return nullptr;
+  }
+
+  return static_cast<nsStyledElement*>(element)->Style();
+}
+
+Element*
+AnonymousContent::GetElementById(const nsAString& aElementId)
+{
+  for (nsIContent* kid = mContentNode->GetFirstChild(); kid; kid = kid->GetNextNode(mContentNode)) {
+    if (!kid->IsElement()) {
+      continue;
+    }
+    nsIAtom* id = kid->AsElement()->GetID();
+    if (id && id->Equals(aElementId)) {
+      return kid->AsElement();
+    }
+  }
+  return nullptr;
+}
+
+JSObject*
+AnonymousContent::WrapObject(JSContext* cx)
+{
+  return AnonymousContentBinding::Wrap(cx, this);
+}
+
+} // dom namespace
+} // mozilla namespace
diff --git a/dom/base/AnonymousContent.h b/dom/base/AnonymousContent.h
new file mode 100644
--- /dev/null
+++ b/dom/base/AnonymousContent.h
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 3; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_AnonymousContent_h__
+#define mozilla_dom_AnonymousContent_h__
+
+#include "nsICSSDeclaration.h"
+#include "nsIDocument.h"
+#include "nsWrapperCache.h"
+
+namespace mozilla {
+namespace dom {
+
+class Element;
+
+class AnonymousContent MOZ_FINAL : public nsWrapperCache
+{
+public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(AnonymousContent)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(AnonymousContent)
+
+  explicit AnonymousContent(Element* aContentNode);
+  nsCOMPtr<Element> GetContentNode();
+  nsIDocument* GetParentObject() const { return mOwner; }
+  virtual JSObject* WrapObject(JSContext* cx) MOZ_OVERRIDE;
+
+  // WebIDL methods
+  void SetTextContentForElement(const nsAString& aElementId,
+                                const nsAString& aText,
+                                ErrorResult& aRv);
+
+  void GetTextContentForElement(const nsAString& aElementId,
+                                DOMString& aText,
+                                ErrorResult& aRv);
+
+  void SetAttributeForElement(const nsAString& aElementId,
+                              const nsAString& aName,
+                              const nsAString& aValue,
+                              ErrorResult& aRv);
+
+  void GetAttributeForElement(const nsAString& aElementId,
+                              const nsAString& aName,
+                              DOMString& aValue,
+                              ErrorResult& aRv);
+
+  void RemoveAttributeForElement(const nsAString& aElementId,
+                                 const nsAString& aName,
+                                 ErrorResult& aRv);
+
+  nsICSSDeclaration* GetStyleForElement(const nsAString& aElementId,
+                                        ErrorResult& aRv);
+
+private:
+  ~AnonymousContent();
+  Element* GetElementById(const nsAString& aElementId);
+  nsCOMPtr<Element> mContentNode;
+  nsCOMPtr<nsIDocument> mOwner;
+};
+
+} // dom namespace
+} // mozilla namespace
+
+#endif // mozilla_dom_AnonymousContent_h__
diff --git a/dom/base/moz.build b/dom/base/moz.build
--- a/dom/base/moz.build
+++ b/dom/base/moz.build
@@ -42,16 +42,17 @@ EXPORTS += [
     'nsPIWindowRoot.h',
     'nsStructuredCloneContainer.h',
     'nsWindowMemoryReporter.h',
     'nsWrapperCache.h',
     'nsWrapperCacheInlines.h',
 ]
 
 EXPORTS.mozilla.dom += [
+    'AnonymousContent.h',
     'BarProps.h',
     'Console.h',
     'DOMCursor.h',
     'DOMError.h',
     'DOMException.h',
     'DOMRequest.h',
     'ImageEncoder.h',
     'MessageChannel.h',
@@ -67,16 +68,17 @@ EXPORTS.mozilla.dom += [
     'ScriptSettings.h',
     'StructuredCloneTags.h',
     'SubtleCrypto.h',
     'URL.h',
     'URLSearchParams.h',
 ]
 
 UNIFIED_SOURCES += [
+    'AnonymousContent.cpp',
     'BarProps.cpp',
     'CompositionStringSynthesizer.cpp',
     'Console.cpp',
     'Crypto.cpp',
     'DOMCursor.cpp',
     'DOMError.cpp',
     'DOMException.cpp',
     'DOMRequest.cpp',
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -202,16 +202,17 @@
 #include "mozilla/Telemetry.h"
 #include "nsLocation.h"
 #include "nsHTMLDocument.h"
 #include "nsWrapperCacheInlines.h"
 #include "mozilla/DOMEventTargetHelper.h"
 #include "prrng.h"
 #include "nsSandboxFlags.h"
 #include "TimeChangeObserver.h"
+#include "mozilla/dom/AnonymousContent.h"
 #include "mozilla/dom/AudioContext.h"
 #include "mozilla/dom/BrowserElementDictionariesBinding.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/HashChangeEvent.h"
 #include "mozilla/dom/MozSelfSupportBinding.h"
 #include "mozilla/dom/PopStateEvent.h"
 #include "mozilla/dom/PopupBlockedEvent.h"
@@ -10388,16 +10389,101 @@ nsGlobalWindow::GetComputedStyleHelper(E
   nsRefPtr<nsComputedDOMStyle> compStyle =
     NS_NewComputedDOMStyle(&aElt, aPseudoElt, presShell,
                            aDefaultStylesOnly ? nsComputedDOMStyle::eDefaultOnly :
                                                 nsComputedDOMStyle::eAll);
 
   return compStyle.forget();
 }
 
+already_AddRefed<AnonymousContent>
+nsGlobalWindow::InsertAnonymousContent(Element& aElement, ErrorResult& aRv)
+{
+  FORWARD_TO_OUTER_OR_THROW(InsertAnonymousContent, (aElement, aRv), aRv, nullptr);
+
+  if (!mDocShell) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  nsCOMPtr<nsIPresShell> presShell = mDocShell->GetPresShell();
+  nsCOMPtr<nsINode> node = do_QueryInterface(&aElement);
+  if (!presShell || !presShell->GetCanvasFrame() || !node) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  // Get the canvas frame custom content container element
+  nsCOMPtr<nsIContent> container = presShell->GetCanvasFrame()
+                                            ->GetCustomContentContainer();
+
+  // Clone the node to avoid returning a direct reference
+  nsCOMPtr<nsINode> clonedElement = node->CloneNode(true, aRv);
+  if (aRv.Failed()) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  // Insert the element into the container
+  nsresult rv;
+  rv = container->AppendChildTo(clonedElement->AsContent(), true);
+  if (NS_FAILED(rv)) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  nsRefPtr<AnonymousContent> anonymousContent =
+    new AnonymousContent(clonedElement->AsElement());
+  mAnonymousContents.AppendElement(anonymousContent);
+  
+  return anonymousContent.forget();
+}
+
+void
+nsGlobalWindow::RemoveAnonymousContent(AnonymousContent& aContent,
+                                       ErrorResult& aRv)
+{
+  FORWARD_TO_OUTER_OR_THROW(RemoveAnonymousContent, (aContent, aRv), aRv, );
+
+  if (!mDocShell) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return;
+  }
+
+  nsCOMPtr<nsIPresShell> presShell = mDocShell->GetPresShell();
+  if (!presShell) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return;
+  }
+
+  // Iterate over know customContents to get and remove the right one
+  for (int32_t i = mAnonymousContents.Length() - 1; i >= 0; --i) {
+    if (mAnonymousContents[i] == &aContent) {
+      // Get the node from the customContent
+      nsCOMPtr<Element> node = aContent.GetContentNode();
+
+      // Get the canvas frame custom content container element
+      nsCOMPtr<nsIContent> container = presShell->GetCanvasFrame()
+                                                ->GetCustomContentContainer();
+
+      // Remove the node from the container
+      container->RemoveChild(*node, aRv);
+      if (aRv.Failed()) {
+        aRv.Throw(NS_ERROR_UNEXPECTED);
+        return;
+      }
+
+      // Remove the entry in mAnonymousContents
+      mAnonymousContents.RemoveElementAt(i);
+
+      break;
+    }
+  }
+}
+
 DOMStorage*
 nsGlobalWindow::GetSessionStorage(ErrorResult& aError)
 {
   FORWARD_TO_INNER_OR_THROW(GetSessionStorage, (aError), aError, nullptr);
 
   nsIPrincipal *principal = GetPrincipal();
   nsIDocShell* docShell = GetDocShell();
 
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -105,16 +105,17 @@ class Function;
 class Gamepad;
 class MediaQueryList;
 class MozSelfSupport;
 class Navigator;
 class OwningExternalOrWindowProxy;
 class Selection;
 class SpeechSynthesis;
 class WakeLock;
+class AnonymousContent;
 namespace indexedDB {
 class IDBFactory;
 } // namespace indexedDB
 } // namespace dom
 } // namespace mozilla
 
 extern nsresult
 NS_CreateJSTimeoutHandler(nsGlobalWindow *aWindow,
@@ -834,16 +835,22 @@ public:
   nsIDOMOfflineResourceList* GetApplicationCache(mozilla::ErrorResult& aError);
 
   mozilla::dom::Console* GetConsole(mozilla::ErrorResult& aRv);
 
   void GetSidebar(mozilla::dom::OwningExternalOrWindowProxy& aResult,
                   mozilla::ErrorResult& aRv);
   already_AddRefed<mozilla::dom::External> GetExternal(mozilla::ErrorResult& aRv);
 
+  already_AddRefed<mozilla::dom::AnonymousContent>
+  InsertAnonymousContent(mozilla::dom::Element& aElement,
+                         mozilla::ErrorResult& aError);
+  void RemoveAnonymousContent(mozilla::dom::AnonymousContent& aContent,
+                              mozilla::ErrorResult& aError);
+
 protected:
   bool AlertOrConfirm(bool aAlert, const nsAString& aMessage,
                       mozilla::ErrorResult& aError);
 
 public:
   void Alert(mozilla::ErrorResult& aError);
   void Alert(const nsAString& aMessage, mozilla::ErrorResult& aError);
   bool Confirm(const nsAString& aMessage, mozilla::ErrorResult& aError);
@@ -1178,16 +1185,18 @@ private:
                                     bool aDoJSFixups,
                                     bool aNavigate,
                                     nsIArray *argv,
                                     nsISupports *aExtraArgument,
                                     nsIPrincipal *aCalleePrincipal,
                                     JSContext *aJSCallerContext,
                                     nsIDOMWindow **aReturn);
 
+  nsTArray<nsRefPtr<mozilla::dom::AnonymousContent>> mAnonymousContents;
+
 public:
   // Timeout Functions
   // Language agnostic timeout function (all args passed).
   // |interval| is in milliseconds.
   nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
                                 int32_t interval,
                                 bool aIsInterval, int32_t *aReturn);
   int32_t SetTimeoutOrInterval(mozilla::dom::Function& aFunction,
diff --git a/dom/base/test/chrome.ini b/dom/base/test/chrome.ini
--- a/dom/base/test/chrome.ini
+++ b/dom/base/test/chrome.ini
@@ -1,13 +1,14 @@
 [DEFAULT]
 support-files =
   file_url.jsm
   file_empty.html
 
+[test_anonymousContent_xul_window.xul]
 [test_bug715041.xul]
 [test_bug715041_removal.xul]
 [test_domrequesthelper.xul]
 [test_url.xul]
 [test_console.xul]
 [test_messageChannel.xul]
 [test_navigator_resolve_identity_xrays.xul]
 [test_sendQueryContentAndSelectionSetEvent.html]
diff --git a/dom/base/test/mochitest.ini b/dom/base/test/mochitest.ini
--- a/dom/base/test/mochitest.ini
+++ b/dom/base/test/mochitest.ini
@@ -7,16 +7,19 @@ support-files =
   iframe_messageChannel_cloning.html
   iframe_messageChannel_chrome.html
   iframe_messageChannel_pingpong.html
   iframe_messageChannel_post.html
   file_empty.html
   iframe_postMessage_solidus.html
   file_setname.html
 
+[test_anonymousContent_api.html]
+[test_anonymousContent_append_after_reflow.html]
+[test_anonymousContent_manipulate_content.html]
 [test_appname_override.html]
 [test_audioWindowUtils.html]
 [test_audioNotification.html]
 skip-if = buildapp == 'mulet'
 [test_bug793311.html]
 [test_bug913761.html]
 [test_bug976673.html]
 [test_bug978522.html]
diff --git a/dom/base/test/test_anonymousContent_api.html b/dom/base/test/test_anonymousContent_api.html
new file mode 100644
--- /dev/null
+++ b/dom/base/test/test_anonymousContent_api.html
@@ -0,0 +1,55 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1020244
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 1020244 - Test the chrome-only AnonymousContent API</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1020244">Mozilla Bug 1020244</a>
+  <script type="application/javascript;version=1.8">
+
+  // Testing the presence of the chrome-only API
+  ok(!window.insertAnonymousContent,
+    "Content window shouldn't have access to insertAnonymousContent");
+  ok(!window.removeAnonymousContent,
+    "Content window shouldn't have access to removeAnonymousContent");
+
+  let chromeWindow = SpecialPowers.wrap(window);
+  ok(chromeWindow.insertAnonymousContent,
+    "Chrome window should have access to insertAnonymousContent");
+  ok(chromeWindow.removeAnonymousContent,
+    "Chrome window should have access to removeAnonymousContent");
+
+  // Testing invalid inputs
+  let invalidNodes = [null, undefined, false, 1, "string"];
+  for (let node of invalidNodes) {
+    let didThrow = false;
+    try {
+      chromeWindow.insertAnonymousContent(node);
+    } catch (e) {
+      didThrow = true;
+    }
+    ok(didThrow, "Passing an invalid node to insertAnonymousContent should throw");
+  }
+
+  // Testing the API of the returned object
+  let div = document.createElement("div");
+  div.textContent = "this is a test element";
+  let anonymousContent = chromeWindow.insertAnonymousContent(div);
+  ok(anonymousContent, "AnonymousContent object returned");
+
+  let members = ["getTextContentForElement", "setTextContentForElement",
+                 "getAttributeForElement", "setAttributeForElement",
+                 "removeAttributeForElement", "getStyleForElement"];
+  for (let member of members) {
+    ok(member in anonymousContent, "AnonymousContent object defines " + member);
+  }
+  chromeWindow.removeAnonymousContent(anonymousContent);
+  </script>
+</body>
+</html>
diff --git a/dom/base/test/test_anonymousContent_append_after_reflow.html b/dom/base/test/test_anonymousContent_append_after_reflow.html
new file mode 100644
--- /dev/null
+++ b/dom/base/test/test_anonymousContent_append_after_reflow.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1020244
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 1020244 - Make sure anonymous content still works after a reflow (after the canvasframe has been reconstructed)</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1020244">Mozilla Bug 1020244</a>
+<div>
+  <div id="test-element">text content</div>
+</div>
+  <script type="application/javascript;version=1.8">
+
+  // Insert content
+  let chromeWindow = SpecialPowers.wrap(window);
+  let testElement = document.querySelector("div");
+  let anonymousContent = chromeWindow.insertAnonymousContent(testElement);
+
+  // Modify the style
+  let style = anonymousContent.getStyleForElement("test-element");
+  style.backgroundColor = "red";
+
+  // Force a sync reflow on the document to force a reconstruction of the
+  // canvasFrame
+  document.documentElement.style.display = "none";
+  let forceFlush = document.documentElement.offsetHeight;
+  document.documentElement.style.display = "block";
+
+  // Check if the style can still be retrieved and is correct
+  let style = anonymousContent.getStyleForElement("test-element");
+  is(style.backgroundColor, "red",
+    "The anonymous content still exists after reflow");
+
+  chromeWindow.removeAnonymousContent(anonymousContent);
+  </script>
+</body>
+</html>
diff --git a/dom/base/test/test_anonymousContent_manipulate_content.html b/dom/base/test/test_anonymousContent_manipulate_content.html
new file mode 100644
--- /dev/null
+++ b/dom/base/test/test_anonymousContent_manipulate_content.html
@@ -0,0 +1,58 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1020244
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 1020244 - Manipulate content created with the AnonymousContent API</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1020244">Mozilla Bug 1020244</a>
+<div>
+  <div id="test-element" class="test-class">text content</div>
+</div>
+  <script type="application/javascript;version=1.8">
+
+  // Insert content
+  let chromeWindow = SpecialPowers.wrap(window);
+  let testElement = document.querySelector("div");
+  let anonymousContent = chromeWindow.insertAnonymousContent(testElement);
+
+  // Test getting/setting text content
+  is(anonymousContent.getTextContentForElement("test-element"),
+    "text content", "Textcontent for the test element is correct");
+
+  anonymousContent.setTextContentForElement("test-element",
+    "updated text content");
+  is(anonymousContent.getTextContentForElement("test-element"),
+    "updated text content",
+    "Textcontent for the test element is correct after update");
+
+  // Test getting/setting/removing attributes
+  is(anonymousContent.getAttributeForElement("test-element", "class"),
+    "test-class", "Class attribute for the test element is correct");
+
+  anonymousContent.setAttributeForElement("test-element", "class",
+    "updated-test-class");
+  is(anonymousContent.getAttributeForElement("test-element", "class"),
+    "updated-test-class",
+    "Class attribute for the test element is correct after update");
+
+  anonymousContent.removeAttributeForElement("test-element", "class");
+  is(anonymousContent.getAttributeForElement("test-element", "class"), null,
+    "Class attribute for the test element was removed");
+
+  // Test getting an element's style
+  let style = anonymousContent.getStyleForElement("test-element");
+  style.backgroundColor = "red";
+  let style2 = anonymousContent.getStyleForElement("test-element");
+  is(style2.backgroundColor, "red",
+    "The background was correctly set for the test element");
+
+  chromeWindow.removeAnonymousContent(anonymousContent);
+  </script>
+</body>
+</html>
diff --git a/dom/base/test/test_anonymousContent_xul_window.xul b/dom/base/test/test_anonymousContent_xul_window.xul
new file mode 100644
--- /dev/null
+++ b/dom/base/test/test_anonymousContent_xul_window.xul
@@ -0,0 +1,31 @@
+<?xml version="1.0"?>
+<?xml-stylesheet type="text/css" href="chrome://global/skin"?>
+<?xml-stylesheet type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css"?>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1020244
+Check that XUL windows aren't supported, that the API throws, but doesn't crash.
+-->
+<window title="Anonymous content in a XUL window"
+xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>
+
+  <!-- test results are displayed in the html:body -->
+  <body xmlns="http://www.w3.org/1999/xhtml"></body>
+  <box>This is a test box</box>
+
+  <script type="application/javascript;version=1.8">
+    // Insert content
+    let chromeWindow = SpecialPowers.wrap(window);
+    let testElement = document.querySelector("box");
+
+    let didThrow = false;
+    try {
+      chromeWindow.insertAnonymousContent(testElement);
+    } catch (e) {
+      didThrow = true;
+    }
+
+    ok(didThrow,
+      "Inserting anonymous content in a XUL window did throw an exception")
+  </script>
+</window>
diff --git a/dom/webidl/AnonymousContent.webidl b/dom/webidl/AnonymousContent.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/AnonymousContent.webidl
@@ -0,0 +1,62 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * This file declares the AnonymousContent interface which is used to
+ * manipulate content that has been inserted into the window's canvasFrame
+ * anonymous container.
+ * See Window.insertAnonymousContent.
+ *
+ * This API never returns a reference to the actual inserted DOM node on
+ * purpose. This is to make sure the content cannot be randomly changed and the
+ * DOM cannot be traversed from the node, so that Gecko can remain in control of
+ * the inserted content.
+ */
+
+[ChromeOnly]
+interface AnonymousContent {
+  /**
+   * Get the text content of an element inside this custom anonymous content.
+   */
+  [Throws]
+  DOMString getTextContentForElement(DOMString elementId);
+
+  /**
+   * Set the text content of an element inside this custom anonymous content.
+   */
+  [Throws]
+  void setTextContentForElement(DOMString elementId, DOMString text);
+
+  /**
+   * Get the value of an attribute of an element inside this custom anonymous
+   * content.
+   */
+  [Throws]
+  DOMString? getAttributeForElement(DOMString elementId,
+                                    DOMString attributeName);
+
+  /**
+   * Set the value of an attribute of an element inside this custom anonymous
+   * content.
+   */
+  [Throws]
+  void setAttributeForElement(DOMString elementId,
+                              DOMString attributeName,
+                              DOMString value);
+
+  /**
+   * Remove an attribute from an element inside this custom anonymous content.
+   */
+  [Throws]
+  void removeAttributeForElement(DOMString elementId,
+                                 DOMString attributeName);
+
+  /**
+   * Get the style for an element inside this custom anonymous content.
+   */
+  [Throws]
+  CSSStyleDeclaration getStyleForElement(DOMString elementId);
+};
diff --git a/dom/webidl/Window.webidl b/dom/webidl/Window.webidl
--- a/dom/webidl/Window.webidl
+++ b/dom/webidl/Window.webidl
@@ -390,16 +390,39 @@ partial interface Window {
 #ifdef HAVE_SIDEBAR
 // Mozilla extension
 partial interface Window {
   [Replaceable, Throws]
   readonly attribute (External or WindowProxy) sidebar;
 };
 #endif
 
+/**
+ * Chrome window anonymous content management.
+ * This is a Chrome only API that allows inserting absolutely positioned
+ * anonymous content on top of the current page displayed in the window.
+ * The supplied content is cloned and inserted into the window's CanvasFrame.
+ */
+partial interface Window {
+  /**
+   * Clones the provided element and inserts it into the window's CanvasFrame.
+   * Returns an AnonymousContent instance that can be used to manipulate the
+   * inserted element.
+   */
+  [ChromeOnly, Throws]
+  AnonymousContent insertAnonymousContent(Element aElement);
+
+  /**
+   * Removes the element inserted into the window's CanvasFrame given an
+   * AnonymousContent instance.
+   */
+  [ChromeOnly, Throws]
+  void removeAnonymousContent(AnonymousContent aContent);
+};
+
 [Func="IsChromeOrXBL"]
 interface ChromeWindow {
   [Func="nsGlobalWindow::IsChromeWindow"]
   const unsigned short STATE_MAXIMIZED = 1;
   [Func="nsGlobalWindow::IsChromeWindow"]
   const unsigned short STATE_MINIMIZED = 2;
   [Func="nsGlobalWindow::IsChromeWindow"]
   const unsigned short STATE_NORMAL = 3;
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -22,16 +22,17 @@ WEBIDL_FILES = [
     'AlarmsManager.webidl',
     'AnalyserNode.webidl',
     'Animatable.webidl',
     'Animation.webidl',
     'AnimationEffect.webidl',
     'AnimationEvent.webidl',
     'AnimationPlayer.webidl',
     'AnimationTimeline.webidl',
+    'AnonymousContent.webidl',
     'AppInfo.webidl',
     'AppNotificationServiceOptions.webidl',
     'Apps.webidl',
     'APZTestData.webidl',
     'ArchiveReader.webidl',
     'ArchiveRequest.webidl',
     'Attr.webidl',
     'AudioBuffer.webidl',
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -105,16 +105,48 @@ nsCanvasFrame::CreateAnonymousContent(ns
     mSelectionCaretsEndElement->SetAttribute(NS_LITERAL_STRING("_moz_anonclass"),
                                              NS_LITERAL_STRING("mozTouchCaret"), er);
     rv = mSelectionCaretsEndElement->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
                                              NS_LITERAL_STRING("moz-selectioncaret-right hidden"),
                                              true);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+  // Either create the custom content container or restore it from the owner
+  // document if available
+  dom::Element* customContentContainer = doc->GetFrameCustomContentContainer();
+  if (customContentContainer) {
+    aElements.AppendElement(customContentContainer);
+  } else {
+    nsRefPtr<dom::NodeInfo> nodeInfo;
+    nodeInfo = doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::div, nullptr,
+                                                   kNameSpaceID_XHTML,
+                                                   nsIDOMNode::ELEMENT_NODE);
+    NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
+
+    rv = NS_NewHTMLElement(&customContentContainer,
+                           nodeInfo.forget(),
+                           mozilla::dom::NOT_FROM_PARSER);
+    NS_ENSURE_SUCCESS(rv, rv);
+    aElements.AppendElement(customContentContainer);
+
+    // Add a _moz_anonclass attribute as highlighter selector.
+    customContentContainer->SetAttribute(NS_LITERAL_STRING("_moz_anonclass"),
+                                         NS_LITERAL_STRING("mozCustomContentContainer"),
+                                         er);
+    NS_ENSURE_SUCCESS(er.ErrorCode(), er.ErrorCode());
+
+    rv = customContentContainer->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
+                                         NS_LITERAL_STRING("moz-custom-content-container"),
+                                         true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    doc->SetFrameCustomContentContainer(customContentContainer);
+  }
+
   return NS_OK;
 }
 
 void
 nsCanvasFrame::AppendAnonymousContentTo(nsTArray<nsIContent*>& aElements, uint32_t aFilter)
 {
   if (mTouchCaretElement) {
     aElements.AppendElement(mTouchCaretElement);
@@ -122,33 +154,55 @@ nsCanvasFrame::AppendAnonymousContentTo(
 
   if (mSelectionCaretsStartElement) {
     aElements.AppendElement(mSelectionCaretsStartElement);
   }
 
   if (mSelectionCaretsEndElement) {
     aElements.AppendElement(mSelectionCaretsEndElement);
   }
+
+  nsCOMPtr<nsIDocument> doc = mContent->OwnerDoc();
+  dom::Element* customContentContainer = doc->GetFrameCustomContentContainer();
+  if (customContentContainer) {
+    aElements.AppendElement(customContentContainer);
+  }
 }
 
 void
 nsCanvasFrame::DestroyFrom(nsIFrame* aDestructRoot)
 {
   nsIScrollableFrame* sf =
     PresContext()->GetPresShell()->GetRootScrollFrameAsScrollable();
   if (sf) {
     sf->RemoveScrollPositionListener(this);
   }
 
   nsContentUtils::DestroyAnonymousContent(&mTouchCaretElement);
   nsContentUtils::DestroyAnonymousContent(&mSelectionCaretsStartElement);
   nsContentUtils::DestroyAnonymousContent(&mSelectionCaretsEndElement);
+
+  // Custom anonymous contents have the same lifetime as the owner document, so
+  // whenever the canvas frame is destroyed, they are unbound like the touch
+  // caret but remain stored at the document level and restored again if/when
+  // the frame gets created.
+  nsCOMPtr<nsIDocument> doc = mContent->OwnerDoc();
+  nsCOMPtr<dom::Element> customContentContainer = do_QueryInterface(doc->GetFrameCustomContentContainer());
+  nsContentUtils::DestroyAnonymousContent(&customContentContainer);
+
   nsContainerFrame::DestroyFrom(aDestructRoot);
 }
 
+dom::Element*
+nsCanvasFrame::GetCustomContentContainer() const
+{
+  nsCOMPtr<nsIDocument> doc = mContent->OwnerDoc();
+  return doc->GetFrameCustomContentContainer();
+}
+
 void
 nsCanvasFrame::ScrollPositionWillChange(nscoord aX, nscoord aY)
 {
   if (mDoPaintFocus) {
     mDoPaintFocus = false;
     PresContext()->FrameManager()->GetRootFrame()->InvalidateFrameSubtree();
   }
 }
diff --git a/layout/generic/nsCanvasFrame.h b/layout/generic/nsCanvasFrame.h
--- a/layout/generic/nsCanvasFrame.h
+++ b/layout/generic/nsCanvasFrame.h
@@ -82,16 +82,18 @@ public:
     return mSelectionCaretsStartElement;
   }
 
   mozilla::dom::Element* GetSelectionCaretsEndElement() const
   {
     return mSelectionCaretsEndElement;
   }
 
+  mozilla::dom::Element* GetCustomContentContainer() const;
+
   /** SetHasFocus tells the CanvasFrame to draw with focus ring
    *  @param aHasFocus true to show focus ring, false to hide it
    */
   NS_IMETHOD SetHasFocus(bool aHasFocus);
 
   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists) MOZ_OVERRIDE;
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -380,8 +380,22 @@ div[\_moz_anonclass="mozTouchCaret"].moz
 div[\_moz_anonclass="mozTouchCaret"].moz-touchcaret.hidden,
 div[\_moz_anonclass="mozTouchCaret"].moz-selectioncaret-left.hidden,
 div[\_moz_anonclass="mozTouchCaret"].moz-selectioncaret-right.hidden {
   width: 0px;
   height: 0px;
   margin: 0px;
   visibility: hidden;
 }
+
+/* Custom content container in the CanvasFrame, absolutely positioned on top of
+   everything else, not reacting to pointer events */
+div[\_moz_anonclass="mozCustomContentContainer"].moz-custom-content-container {
+  pointer-events: none;
+
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+
+  z-index: 2147483648;
+}
