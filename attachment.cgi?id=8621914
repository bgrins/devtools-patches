# HG changeset patch
# User Gabriel Luong <gabriel.luong@gmail.com>
# Parent  0a6778a3d65ab8a3aa364fcfe1e02906f0edb2f9

diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -3792,16 +3792,17 @@
  * @param {Function} filter A custom filter function Taking in a DOMNode
  *        and returning an Int. See WalkerActor.nodeFilter for an example.
  */
 function DocumentWalker(node, rootWin, whatToShow=Ci.nsIDOMNodeFilter.SHOW_ALL, filter=standardTreeWalkerFilter) {
   if (!rootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
+  this.rootWin = rootWin;
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
   this.walker.init(rootWin.document, whatToShow);
   this.filter = filter;
 
   // Make sure that the walker knows about the initial node (which could
@@ -3824,24 +3825,38 @@
   get currentNode() {
     return this.walker.currentNode;
   },
   set currentNode(aVal) {
     this.walker.currentNode = aVal;
   },
 
   parentNode: function() {
+    let node = this.walker.currentNode;
+
+    // ShadowHost is the parent of every ShadowRoot
+    if (node.host &&
+        node instanceof node.ownerDocument.defaultView.ShadowRoot) {
+      this.walker.currentNode = node.host;
+      return node.host;
+    }
+
     return this.walker.parentNode();
   },
 
   firstChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
 
+    if (node.shadowRoot) {
+      this.walker.currentNode = node.shadowRoot;
+      return node.shadowRoot;
+    }
+
     let firstChild = this.walker.firstChild();
     while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       firstChild = this.walker.nextSibling();
     }
 
     return firstChild;
   },
 
@@ -3850,33 +3865,77 @@
     if (!node)
       return null;
 
     let lastChild = this.walker.lastChild();
     while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       lastChild = this.walker.previousSibling();
     }
 
-    return lastChild;
+    if (lastChild) {
+      return lastChild;
+    }
+
+    let root = node.shadowRoot || null;
+    while (root) {
+      root = root.olderShadowRoot;
+      this.walker.currentNode = root;
+    }
+
+    return root;
   },
 
   previousSibling: function() {
-    let node = this.walker.previousSibling();
-    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
-      node = this.walker.previousSibling();
+    let node = this.walker.currentNode;
+
+    if (node.host && node instanceof node.ownerDocument.defaultView.ShadowRoot) {
+      let host = node.host;
+      let root = host.shadowRoot;
+      if (root == node) {
+        return null;
+      }
+
+      while (root && root.olderShadowRoot != node) {
+        root = root.olderShadowRoot;
+        this.walker.currentNode = root;
+      }
+
+      return root;
     }
-    return node;
+
+    let previousSibling = this.walker.previousSibling();
+    while (previousSibling && this.filter(previousSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      previousSibling = this.walker.previousSibling();
+    }
+    return previousSibling;
   },
 
   nextSibling: function() {
-    let node = this.walker.nextSibling();
-    while (node && this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
-      node = this.walker.nextSibling();
+    let node = this.walker.currentNode;
+
+    if (node instanceof node.ownerDocument.defaultView.ShadowRoot &&
+        node.olderShadowRoot) {
+      this.walker.currentNode = node.olderShadowRoot;
+      return node.olderShadowRoot;
+    } else if (node instanceof node.ownerDocument.defaultView.ShadowRoot) {
+      this.walker.currentNode = node.host;
+
+      let firstChild = this.walker.firstChild();
+      while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        firstChild = this.walker.nextSibling();
+      }
+
+      return firstChild;
     }
-    return node;
+
+    let nextSibling = this.walker.nextSibling();
+    while (nextSibling && this.filter(nextSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      nextSibling = this.walker.nextSibling();
+    }
+    return nextSibling;
   }
 };
 
 function isXULElement(el) {
   return el &&
          el.namespaceURI === XUL_NS;
 }
 
