# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  6a63c84bc1dbd6042411d8c4e71d5053b3b93bfb
Bug 835896 - Highlight the matched parts of search results;r=pbrosset

diff --git a/devtools/client/markupview/markup-view.js b/devtools/client/markupview/markup-view.js
--- a/devtools/client/markupview/markup-view.js
+++ b/devtools/client/markupview/markup-view.js
@@ -109,16 +109,24 @@ function MarkupView(aInspector, aFrame, 
   this._onNewSelection();
 
   this._boundKeyDown = this._onKeyDown.bind(this);
   this._frame.contentWindow.addEventListener("keydown", this._boundKeyDown, false);
 
   this._boundFocus = this._onFocus.bind(this);
   this._frame.addEventListener("focus", this._boundFocus, false);
 
+  // Listen to inspector search to highlight results
+  this._unhighlightSearchResult = this._unhighlightSearchResult.bind(this);
+  this._highlightSearchResult = this._highlightSearchResult.bind(this);
+  let search = this._inspector.search;
+  search.on("search-cleared", this._unhighlightSearchResult);
+  search.on("search-no-result", this._unhighlightSearchResult);
+  search.on("search-result", this._highlightSearchResult);
+
   this._makeTooltipPersistent = this._makeTooltipPersistent.bind(this);
 
   this._initPreview();
   this._initTooltips();
   this._initHighlighter();
 
   EventEmitter.decorate(this);
 }
@@ -330,16 +338,33 @@ MarkupView.prototype = {
     this._clearBriefBoxModelTimer();
     this._showBoxModel(nodeFront);
 
     this._briefBoxModelTimer = setTimeout(() => {
       this._hideBoxModel();
     }, NEW_SELECTION_HIGHLIGHTER_TIMER);
   },
 
+  _highlightSearchResult: function(event, {node, type, matched, query}) {
+    this._unhighlightSearchResult();
+
+    // Search results are selected in the view, so wait for updates
+    this._waitForChildren().then(() => {
+      let editor = this.getContainer(node).editor;
+
+      if (editor.highlightPart) {
+        editor.highlightPart(type, matched, query);
+      }
+    });
+  },
+
+  _unhighlightSearchResult: function() {
+    this.doc.defaultView.getSelection().removeAllRanges();
+  },
+
   template: function(aName, aDest, aOptions={stack: "markup-view.xhtml"}) {
     let node = this.doc.getElementById("template-" + aName).cloneNode(true);
     node.removeAttribute("id");
     template(node, aDest, aOptions);
     return node;
   },
 
   /**
@@ -1427,16 +1452,21 @@ MarkupView.prototype = {
     this._boundKeyDown = null;
 
     this._inspector.selection.off("new-node-front", this._boundOnNewSelection);
     this._boundOnNewSelection = null;
 
     this.walker.off("mutations", this._boundMutationObserver);
     this._boundMutationObserver = null;
 
+    let search = this._inspector.search;
+    search.off("search-cleared", this._unhighlightSearchResult);
+    search.off("search-no-result", this._unhighlightSearchResult);
+    search.off("search-result", this._highlightSearchResult);
+
     this.walker.off("display-change", this._boundOnDisplayChange);
     this._boundOnDisplayChange = null;
 
     this._elt.removeEventListener("mousemove", this._onMouseMove, false);
     this._elt.removeEventListener("mouseleave", this._onMouseLeave, false);
     this._elt = null;
 
     for (let [key, container] of this._containers) {
@@ -1986,16 +2016,47 @@ MarkupContainer.prototype = {
   _onToggle: function(event) {
     this.markup.navigate(this);
     if (this.hasChildren) {
       this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
     }
     event.stopPropagation();
   },
 
+  highlightPart: function(type, value, part) {
+    if (type === "selector") {
+      // No need to highlight anything if the type is selector
+      return;
+    }
+    // FIXME: if the node isn't imported yet, we have a race condition and t
+    // range isn't visible
+    let range = this.markup.doc.createRange();
+    // Get the node that contains the part
+    let node;
+    switch (type) {
+      case "attributeValue":
+        node = this.getAttributeElementByValue(value);
+        break;
+      case "attributeName":
+        node = this.getAttributeElement(value)
+          .parentNode.querySelector(".attr-name");
+        break;
+      case "tag":
+        node = this.tag;
+        break;
+    }
+    // Get the textnode to set the range in
+    node = node.firstChild;
+    let start = node.textContent.toLowerCase().indexOf(part.toLowerCase());
+    let end = start + part.length;
+    range.setStart(node, start);
+    range.setEnd(node, end);
+    this.markup.doc.defaultView.getSelection().addRange(range);
+  },
+
   /**
    * Get rid of event listeners and references, when the container is no longer
    * needed
    */
   destroy: function() {
     // Remove event listeners
     this.elt.removeEventListener("mousedown", this._onMouseDown, false);
     this.elt.removeEventListener("dblclick", this._onToggle, false);
@@ -2246,21 +2307,23 @@ GenericEditor.prototype = {
  * Creates a simple text editor node, used for TEXT and COMMENT
  * nodes.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param DOMNode aNode The node being edited.
  * @param string aTemplate The template id to use to build the editor.
  */
 function TextEditor(aContainer, aNode, aTemplate) {
+  this.doc = aContainer.doc;
   this.container = aContainer;
   this.markup = this.container.markup;
   this.node = aNode;
   this.template = this.markup.template.bind(aTemplate);
   this._selected = false;
+  this.updating = promise.resolve();
 
   this.markup.template(aTemplate, this);
 
   editableField({
     element: this.value,
     stopOnReturn: true,
     trigger: "dblclick",
     multiline: true,
@@ -2304,28 +2367,51 @@ TextEditor.prototype = {
     if (!this.selected || !this.node.incompleteValue) {
       let text = this.node.shortValue;
       if (this.node.incompleteValue) {
         text += ELLIPSIS;
       }
       this.value.textContent = text;
     } else {
       let longstr = null;
-      this.node.getNodeValue().then(ret => {
+      this.updating = this.node.getNodeValue().then(ret => {
         longstr = ret;
         return longstr.string();
       }).then(str => {
         longstr.release().then(null, console.error);
         if (this.selected) {
           this.value.textContent = str;
         }
       }).then(null, console.error);
     }
   },
 
+  highlightPart: function(type, value, part) {
+    // Make sure the highlight is done after update to avoid race conditions
+    this.updating.then(() => {
+      let range = this.markup.doc.createRange();
+      let textNode = this.value.firstChild;
+
+      let start = textNode.textContent.toLowerCase().indexOf(part.toLowerCase());
+      let end = start + part.length;
+
+      range.setStart(textNode, start);
+      range.setEnd(textNode, end);
+
+      this.markup.doc.defaultView.getSelection().addRange(range);
+
+      // XXX: Some weird try to change the color of the selection.
+      // this.markup.doc.designMode = "on";
+      // this.markup.doc.execCommand("BackColor", false, "yellow");
+      // this.markup.doc.execCommand("HiliteColor", false, "yellow");
+      // this.markup.doc.designMode = "off";
+
+    });
+  },
+
   destroy: function() {}
 };
 
 /**
  * Creates an editor for an Element node.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param Element aNode The node being edited.
@@ -2476,16 +2562,30 @@ ElementEditor.prototype = {
   removeAttribute: function(attrName) {
     let attr = this.attrElements.get(attrName);
     if (attr) {
       this.attrElements.delete(attrName);
       attr.remove();
     }
   },
 
+  /**
+   * Get the element used for one of the attributes of this element given its
+   * value
+   * @param string attrValue The value of the attribute to get the element for
+   * @return DOMElement
+   */
+  getAttributeElementByValue: function(attrValue) {
+    for (let attr of this.attrList.querySelectorAll(".attr-value")) {
+      if (attr.textContent === attrValue) {
+        return attr;
+      }
+    }
+  },
+
   _createAttribute: function(aAttr, aBefore = null) {
     // Create the template editor, which will save some variables here.
     let data = {
       attrName: aAttr.name,
     };
     this.template("attribute", data);
     let {attr, inner, name, val} = data;
 
