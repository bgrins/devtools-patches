# HG changeset patch
# Parent 744536761df2064cd568a76e06c87c2e75267bc2
# User Michael Ratcliffe <mratcliffe@mozilla.com>
# Date 1391619626 0

Bug 663778 - Base devtools box model highlighter on getBoxQuads() polyfill r=pbrossett

diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -81,25 +81,20 @@ LayoutHelpers.prototype = {
         width: quads.bounds.width * scale,
         x: quads.bounds.x * scale + xOffset,
         y: quads.bounds.y * scale + yOffset
       }
     };
   },
 
   calculateScale: function(node) {
-    // TODO: Fix zoom once getBoxQuads() zoom is fixed
-    return 1;
-
     let win = node.ownerDocument.defaultView;
     let winUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)
                       .getInterface(Ci.nsIDOMWindowUtils);
-    let isRetina = win.devicePixelRatio === 2;
-
-    return isRetina ? win.devicePixelRatio : winUtils.fullZoom;
+    return winUtils.fullZoom;
   },
 
   /**
    * Get the bounds for a box model region.
    *
    * @param {DOMNode} node
    *        The node for which we are to get the box model region quads
    * @param  {String} region
@@ -437,9 +432,147 @@ LayoutHelpers.prototype = {
       xOffset += frameRect.left + offsetLeft;
       yOffset += frameRect.top + offsetTop;
 
       frameWin = this.getParentWindow(frameWin);
     }
 
     return [xOffset * scale, yOffset * scale];
   },
+
+
+
+  /********************************************************************
+   * GetBoxQuads POLYFILL START
+   ********************************************************************/
+  _getBoxQuadsFromRect: function(rect, node) {
+    let scale = this.calculateScale(node);
+
+    let out = {
+      p1: {
+        x: rect.left * scale,
+        y: rect.top * scale
+      },
+      p2: {
+        x: (rect.left + rect.width) * scale,
+        y: rect.top * scale
+      },
+      p3: {
+        x: (rect.left + rect.width) * scale,
+        y: (rect.top + rect.height) * scale
+      },
+      p4: {
+        x: rect.left * scale,
+        y: (rect.top + rect.height) * scale
+      }
+    };
+
+    out.bounds = {
+      bottom: out.p4.y,
+      height: out.p4.y - out.p1.y,
+      left: out.p1.x,
+      right: out.p2.x,
+      top: out.p1.y,
+      width: out.p2.x - out.p1.x,
+      x: out.p1.x,
+      y: out.p1.y
+    };
+
+    return [out];
+  },
+
+  _parseNb: function(distance) {
+    let nb = parseFloat(distance, 10);
+    return isNaN(nb) ? 0 : nb;
+  },
+
+  getBoxQuads: function(node, region) {
+    // Get the border-box rect
+    // Note that this is relative to the node's viewport, so before we can use
+    // it, will need to go back up the frames like getRect
+    let borderRect = node.getBoundingClientRect();
+
+    // If the boxType is border, no need to go any further, we're done
+    if (region === "border") {
+      return this._getBoxQuadsFromRect(borderRect, node);
+    }
+
+    // Else, need to get margin/padding/border distances
+    let style = node.ownerDocument.defaultView.getComputedStyle(node);
+    let camel = s => s.substring(0, 1).toUpperCase() + s.substring(1);
+    let distances = {border:{}, padding:{}, margin: {}};
+
+    for (let side of ["top", "right", "bottom", "left"]) {
+      distances.border[side] = this._parseNb(style["border" + camel(side) + "Width"]);
+      distances.padding[side] = this._parseNb(style["padding" + camel(side)]);
+      distances.margin[side] = this._parseNb(style["margin" + camel(side)]);
+    }
+
+    // From the border-box rect, calculate the content-box, padding-box and
+    // margin-box rects
+    function offsetRect(rect, offsetType, dir=1) {
+      return {
+        top: rect.top + (dir * distances[offsetType].top),
+        left: rect.left + (dir * distances[offsetType].left),
+        width: rect.width - (dir * (distances[offsetType].left + distances[offsetType].right)),
+        height: rect.height - (dir * (distances[offsetType].top + distances[offsetType].bottom))
+      };
+    }
+
+    if (region === "margin") {
+      return this._getBoxQuadsFromRect(offsetRect(borderRect, "margin", -1), node);
+    } else if (region === "padding") {
+      return this._getBoxQuadsFromRect(offsetRect(borderRect, "border"), node);
+    } else if (region === "content") {
+      let paddingRect = offsetRect(borderRect, "border");
+      return this._getBoxQuadsFromRect(offsetRect(paddingRect, "padding"), node);
+    }
+  },
+
+  getAdjustedQuadsPolyfill: function(node, region) {
+    let [quads] = this.getBoxQuads(node, region);
+    let frameWin = node.ownerDocument.defaultView;
+    let scale = this.calculateScale(node);
+
+    while (true) {
+      let frameElement = this.getFrameElement(frameWin);
+      if (this.isTopLevelWindow(frameWin) || !frameElement) {
+        break;
+      }
+
+      // We are in an iframe.
+      // We take into account the parent iframe position and its
+      // offset (borders and padding).
+      let frameRect = frameElement.getBoundingClientRect();
+      let [offsetTop, offsetLeft] =
+        this.getIframeContentOffset(frameElement);
+
+      for (let point in quads) {
+        quads[point].x += (frameRect.left + offsetLeft) * scale;
+        quads[point].y += (frameRect.top + offsetTop) * scale;
+      }
+
+      frameWin = this.getParentWindow(frameWin);
+    }
+    return quads;
+   },
+
+   getBoundsPolyfill: function(node, region) {
+    let quads = this.getAdjustedQuadsPolyfill(node, region);
+
+    if (!quads) {
+      return;
+    }
+
+    let bounds = quads.bounds;
+
+    return {
+      top: Math.max(0, Math.ceil(bounds.top)),
+      left: Math.max(0, Math.floor(bounds.left)),
+      width: Math.ceil(bounds.width),
+      height: Math.ceil(bounds.height)
+    };
+  },
+
+  /********************************************************************
+   * GetBoxQuads POLYFILL END
+   ********************************************************************/
 };
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -553,25 +553,27 @@ BoxModelHighlighter.prototype = {
    */
   _highlightBoxModel: function(options) {
     let isShown = false;
 
     options.region = options.region || "content";
 
     // We do not cache the rectangle because comparing all 16 points
     // unnecessarily complicates things.
-    let rect = this.layoutHelpers.getBounds(this.currentNode, "border");
+    // TODO: Remove this polyfill
+    let rect = this.layoutHelpers.getBoundsPolyfill(this.currentNode, "border");
     if (!rect) {
       return;
     }
 
     if (rect.left >= 0 && rect.top >= 0 && rect.width > 0 && rect.height > 0) {
       for (let boxType in this._boxModelNodes) {
+        // TODO: Remove this polyfill
         let {p1, p2, p3, p4} =
-          this.layoutHelpers.getAdjustedQuads(this.currentNode, boxType);
+          this.layoutHelpers.getAdjustedQuadsPolyfill(this.currentNode, boxType);
 
         let boxNode = this._boxModelNodes[boxType];
         boxNode.setAttribute("points",
                              p1.x + "," + p1.y + " " +
                              p2.x + "," + p2.y + " " +
                              p3.x + "," + p3.y + " " +
                              p4.x + "," + p4.y);
 
@@ -685,17 +687,17 @@ BoxModelHighlighter.prototype = {
   },
 
   /**
    * Move the Infobar to the right place in the highlighter.
    */
   _moveInfobar: function() {
     const offset = 5;
 
-    let rect = this.layoutHelpers.getBounds(this.currentNode, "margin");
+    let rect = this.layoutHelpers.getBoundsPolyfill(this.currentNode, "margin");
     if (!rect) {
       return;
     }
 
     if (rect) {
       let winHeight = this.win.innerHeight * this.zoom;
       let winWidth = this.win.innerWidth * this.zoom;
 
