# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b423610b2e44ba5b63458608d4f78c979d970e77
Bug 1213932 - Restrict ServiceWorker logging to windows that match navigator.serviceWorker.controller.scriptURL;r=past

diff --git a/devtools/client/shared/frame-script-utils.js b/devtools/client/shared/frame-script-utils.js
--- a/devtools/client/shared/frame-script-utils.js
+++ b/devtools/client/shared/frame-script-utils.js
@@ -28,16 +28,36 @@ addMessageListener("devtools:test:reload
   content.location.reload(data.forceget);
 });
 
 addMessageListener("devtools:test:console", function ({ data }) {
   let method = data.shift();
   content.console[method].apply(content.console, data);
 });
 
+// A helper frame-script for service worker tests.
+addMessageListener("devtools:sw-test:register", function(msg) {
+  content.navigator.serviceWorker.register("serviceworker.js")
+    .then(swr => {
+      sendAsyncMessage("devtools:sw-test:register", {success: true});
+    }, error => {
+      sendAsyncMessage("devtools:sw-test:register", {success: false});
+    });
+});
+
+addMessageListener("devtools:sw-test:unregister", function(msg) {
+  content.navigator.serviceWorker.getRegistration().then(swr => {
+    swr.unregister().then(result => {
+      sendAsyncMessage("devtools:sw-test:unregister",
+                       {success: result ? true : false});
+    });
+  });
+});
+
+
 /**
  * Performs a single XMLHttpRequest and returns a promise that resolves once
  * the request has loaded.
  *
  * @param Object data
  *        { method: the request method (default: "GET"),
  *          url: the url to request (default: content.location.href),
  *          body: the request body to send (default: ""),
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -1529,18 +1529,17 @@ WebConsoleActor.prototype =
    * @return object
    *         The object that can be sent to the remote client.
    */
   prepareConsoleMessageForRemote:
   function WCA_prepareConsoleMessageForRemote(aMessage, aUseObjectGlobal = true)
   {
     let result = WebConsoleUtils.cloneObject(aMessage);
 
-    result.workerType = CONSOLE_WORKER_IDS.indexOf(result.innerID) == -1
-                          ? 'none' : result.innerID;
+    result.workerType = WebConsoleUtils.getWorkerType(result) || "none";
 
     delete result.wrappedJSObject;
     delete result.ID;
     delete result.innerID;
     delete result.consoleID;
 
     result.arguments = Array.map(aMessage.arguments || [], (aObj) => {
       let dbgObj = this.makeDebuggeeValue(aObj, aUseObjectGlobal);
diff --git a/devtools/shared/webconsole/test/chrome.ini b/devtools/shared/webconsole/test/chrome.ini
--- a/devtools/shared/webconsole/test/chrome.ini
+++ b/devtools/shared/webconsole/test/chrome.ini
@@ -1,15 +1,16 @@
 [DEFAULT]
 tags = devtools
 skip-if = buildapp == 'b2g'
 support-files =
   common.js
   data.json
   data.json^headers^
+  helper_serviceworker.js
   network_requests_iframe.html
   sandboxed_iframe.html
   console-test-worker.js
 
 [test_basics.html]
 [test_bug819670_getter_throws.html]
 [test_cached_messages.html]
 [test_commands_other.html]
diff --git a/devtools/shared/webconsole/test/helper_serviceworker.js b/devtools/shared/webconsole/test/helper_serviceworker.js
new file mode 100644
--- /dev/null
+++ b/devtools/shared/webconsole/test/helper_serviceworker.js
@@ -0,0 +1,1 @@
+console.log("Hello from serviceworker");
diff --git a/devtools/shared/webconsole/test/test_consoleapi_innerID.html b/devtools/shared/webconsole/test/test_consoleapi_innerID.html
--- a/devtools/shared/webconsole/test/test_consoleapi_innerID.html
+++ b/devtools/shared/webconsole/test/test_consoleapi_innerID.html
@@ -5,40 +5,54 @@
   <title>Test for the innerID property of the Console API</title>
   <script type="text/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
   <script type="text/javascript;version=1.8" src="common.js"></script>
   <!-- Any copyright is dedicated to the Public Domain.
      - http://creativecommons.org/publicdomain/zero/1.0/ -->
 </head>
 <body>
 <p>Test for the Console API</p>
+<iframe id="content-iframe" src="https://example.com/chrome/devtools/shared/webconsole/test/sandboxed_iframe.html"></iframe>
 
 <script class="testbody" type="text/javascript;version=1.8">
 SimpleTest.waitForExplicitFinish();
 
 let expectedConsoleCalls = [];
 
-function doConsoleCalls(aState)
-{
-  let { ConsoleAPI } = Cu.import("resource://gre/modules/Console.jsm", {});
-  let console = new ConsoleAPI({
-    innerID: window.QueryInterface(Ci.nsIInterfaceRequestor)
-                   .getInterface(Ci.nsIDOMWindowUtils)
-                   .currentInnerWindowID
-  });
+
+let doConsoleCalls = Task.async(function*(aState) {
+  function evaluateJS(input) {
+    return new Promise((resolve) => gState.client.evaluateJS(input, resolve));
+  }
+
+  // let { ConsoleAPI } = Cu.import("resource://gre/modules/Console.jsm", {});
+  // let console = new ConsoleAPI({
+  //   innerID: window.QueryInterface(Ci.nsIInterfaceRequestor)
+  //                  .getInterface(Ci.nsIDOMWindowUtils)
+  //                  .currentInnerWindowID
+  // });
 
   let longString = (new Array(DebuggerServer.LONG_STRING_LENGTH + 2)).join("a");
+  let str = `
+    function doConsoleCalls() {
+      let longString = (new Array(${DebuggerServer.LONG_STRING_LENGTH + 2})).join("a");
+      console.log("foobarBaz-log", undefined);
+      console.info("foobarBaz-info", null);
+      console.warn("foobarBaz-warn", top.document.documentElement);
+      console.debug(null);
+      console.trace();
+      console.dir(top.document, top.location);
+      console.log("foo", longString);
+    }
+    doConsoleCalls();
+  `;
 
-  console.log("foobarBaz-log", undefined);
-  console.info("foobarBaz-info", null);
-  console.warn("foobarBaz-warn", top.document.documentElement);
-  console.debug(null);
-  console.trace();
-  console.dir(top.document, top.location);
-  console.log("foo", longString);
+  yield new Promise((resolve) => {
+    aState.client.evaluateJS(str, resolve)
+  });
 
   expectedConsoleCalls = [
     {
       level: "log",
       filename: /test_consoleapi/,
       functionName: "doConsoleCalls",
       timeStamp: /^\d+$/,
       arguments: ["foobarBaz-log", { type: "undefined" }],
@@ -109,31 +123,41 @@ function doConsoleCalls(aState)
           type: "longString",
           initial: longString.substring(0,
             DebuggerServer.LONG_STRING_INITIAL_LENGTH),
           length: longString.length,
           actor: /[a-z]/,
         },
       ],
     },
+    {
+      level: "log",
+      filename: /helper_serviceworker/,
+    }
   ];
-}
+});
 
-function startTest()
+let startTest = Task.async(function*()
 {
   removeEventListener("load", startTest);
 
+  yield new Promise(resolve => {
+    SpecialPowers.pushPrefEnv({"set": [
+      ["devtools.webconsole.filter.serviceworkers", true]
+    ]}, resolve);
+  });
+
   attachConsoleToTab(["ConsoleAPI"], onAttach);
-}
+});
 
 function onAttach(aState, aResponse)
 {
   onConsoleAPICall = onConsoleAPICall.bind(null, aState);
   aState.dbgClient.addListener("consoleAPICall", onConsoleAPICall);
-  doConsoleCalls(aState.actor);
+  doConsoleCalls(aState);
 }
 
 let consoleCalls = [];
 
 function onConsoleAPICall(aState, aType, aPacket)
 {
   info("received message level: " + aPacket.message.level);
   is(aPacket.from, aState.actor, "console API call actor");
@@ -149,16 +173,34 @@ function onConsoleAPICall(aState, aType,
     info("checking received console call #" + aIndex);
     checkConsoleAPICall(consoleCalls[aIndex], expectedConsoleCalls[aIndex]);
   });
 
 
   consoleCalls = [];
 
   closeDebugger(aState, function() {
-    SimpleTest.finish();
+    swClosed.then(() => {
+      SimpleTest.finish();
+    });
   });
 }
 
+let swClosed = new Promise(resolve => {
+  document.getElementById("content-iframe").addEventListener("load", (e) => {
+    let win = e.target.contentWindow;
+    dump(win.location.toString());
+    win.navigator.serviceWorker.register("https://example.com/chrome/devtools/shared/webconsole/test/helper_serviceworker.js").then(swr => {
+      dump("BRIAN1\n");
+
+      swr.unregister().then(function(boolean) {
+        dump("BRIAN1.1\n");
+        resolve();
+      });
+    }, error => {
+      dump("BRIAN2" + error + "\n");
+    });
+  });
+});
 addEventListener("load", startTest);
 </script>
 </body>
 </html>
diff --git a/devtools/shared/webconsole/utils.js b/devtools/shared/webconsole/utils.js
--- a/devtools/shared/webconsole/utils.js
+++ b/devtools/shared/webconsole/utils.js
@@ -47,16 +47,34 @@ var WebConsoleUtils = {
   {
     let str = Cc["@mozilla.org/supports-string;1"].
               createInstance(Ci.nsISupportsString);
     str.data = aString;
     return str;
   },
 
   /**
+   * Given a message, return one of CONSOLE_WORKER_IDS if it is matching
+   * one of those.  You should use this instead of just checking
+   * CONSOLE_WORKER_IDS.indexOf(msg.innerID) because ServiceWorker messages
+   * include extra information in the innerID to include the scope.
+   *
+   * @return bool
+   */
+  getWorkerType: function(message) {
+    let id = "" + (message ? message.innerID : "");
+    for (let w of CONSOLE_WORKER_IDS) {
+      if (id.startsWith(w)) {
+        return w;
+      }
+    }
+    return null;
+  },
+
+  /**
    * Clone an object.
    *
    * @param object aObject
    *        The object you want cloned.
    * @param boolean aRecursive
    *        Tells if you want to dig deeper into the object, to clone
    *        recursively.
    * @param function [aFilter]
@@ -111,16 +129,39 @@ var WebConsoleUtils = {
     let style = win.getComputedStyle(aFrom);
     aTo.style.fontFamily = style.getPropertyCSSValue("font-family").cssText;
     aTo.style.fontSize = style.getPropertyCSSValue("font-size").cssText;
     aTo.style.fontWeight = style.getPropertyCSSValue("font-weight").cssText;
     aTo.style.fontStyle = style.getPropertyCSSValue("font-style").cssText;
   },
 
   /**
+   * Recursively gather a list of window locations given
+   * a top level window.
+   *
+   * @param nsIDOMWindow aWindow
+   * @return Array
+   *         list of window locations as strings
+   */
+  getLocationsForFrames: function(aWindow)
+  {
+    let location = aWindow.location.toString();
+    let locations = [location];
+
+    if (aWindow.frames) {
+      for (let i = 0; i < aWindow.frames.length; i++) {
+        let frame = aWindow.frames[i];
+        locations = locations.concat(this.getLocationsForFrames(frame));
+      }
+    }
+
+    return locations;
+  },
+
+  /**
    * Gets the ID of the inner window of this DOM window.
    *
    * @param nsIDOMWindow aWindow
    * @return integer
    *         Inner ID for the given aWindow.
    */
   getInnerWindowId: function WCU_getInnerWindowId(aWindow)
   {
@@ -930,31 +971,69 @@ ConsoleAPIListener.prototype =
     if (!this.owner) {
       return;
     }
 
     // Here, wrappedJSObject is not a security wrapper but a property defined
     // by the XPCOM component which allows us to unwrap the XPCOM interface and
     // access the underlying JSObject.
     let apiMessage = aMessage.wrappedJSObject;
-    if (this.window && CONSOLE_WORKER_IDS.indexOf(apiMessage.innerID) == -1) {
-      let msgWindow = Services.wm.getCurrentInnerWindowWithId(apiMessage.innerID);
-      if (!msgWindow || !isWindowIncluded(this.window, msgWindow)) {
-        // Not the same window!
-        return;
-      }
-    }
-    if (this.consoleID && apiMessage.consoleID != this.consoleID) {
+
+    if (!this.isMessageRelevant(apiMessage)) {
       return;
     }
 
     this.owner.onConsoleAPICall(apiMessage);
   },
 
   /**
+   * Given a message, return false if it's a ServiceWorker message
+   * but it's not applicable to this window.
+   *
+   * @param message
+   *        The message from the Storage Service
+   * @return bool
+   *         Do we care about this message?
+   */
+  isMessageRelevant: function(message) {
+    let workerType = WebConsoleUtils.getWorkerType(message);
+
+    if (this.window) {
+      // console.log("Received message", workerType, message.innerID);
+    }
+    if (this.window && workerType === "ServiceWorker") {
+      // For messages from Service Workers, message.ID is the
+      // script URL for the worker and innerID includes the scope,
+      // which can be used to determine whether it's controlling
+      // a window.
+      let scope = message.innerID.split("ServiceWorker:")[1];
+      let locations = WebConsoleUtils.getLocationsForFrames(this.window);
+
+      // console.log("Checking locations", locations, scope);
+      if (!locations.some(loc => loc.startsWith(scope))) {
+        return false;
+      }
+    }
+
+    if (this.window && !workerType) {
+      let msgWindow = Services.wm.getCurrentInnerWindowWithId(message.innerID);
+      if (!msgWindow || !isWindowIncluded(this.window, msgWindow)) {
+        // Not the same window!
+        return false;
+      }
+    }
+
+    if (this.consoleID && message.consoleID !== this.consoleID) {
+      return false;
+    }
+
+    return true;
+  },
+
+  /**
    * Get the cached messages for the current inner window and its (i)frames.
    *
    * @param boolean [aIncludePrivate=false]
    *        Tells if you want to also retrieve messages coming from private
    *        windows. Defaults to false.
    * @return array
    *         The array of cached messages.
    */
@@ -974,19 +1053,19 @@ ConsoleAPIListener.prototype =
         messages = messages.concat(ConsoleAPIStorage.getEvents(id));
       });
     }
 
     CONSOLE_WORKER_IDS.forEach((id) => {
       messages = messages.concat(ConsoleAPIStorage.getEvents(id));
     });
 
-    if (this.consoleID) {
-      messages = messages.filter((m) => m.consoleID == this.consoleID);
-    }
+    messages = messages.filter(msg => {
+      return this.isMessageRelevant(msg);
+    });
 
     if (aIncludePrivate) {
       return messages;
     }
 
     return messages.filter((m) => !m.private);
   },
 
diff --git a/dom/base/Console.cpp b/dom/base/Console.cpp
--- a/dom/base/Console.cpp
+++ b/dom/base/Console.cpp
@@ -497,17 +497,18 @@ private:
       if (mCallData->mTopStackFrame) {
         frame = *mCallData->mTopStackFrame;
       }
 
       nsString id;
       if (mWorkerPrivate->IsSharedWorker()) {
         id = NS_LITERAL_STRING("SharedWorker");
       } else if (mWorkerPrivate->IsServiceWorker()) {
-        id = NS_LITERAL_STRING("ServiceWorker");
+        id = NS_LITERAL_STRING("ServiceWorker:");
+        AppendASCIItoUTF16(mWorkerPrivate->WorkerName(), id);
       } else {
         id = NS_LITERAL_STRING("Worker");
       }
 
       mCallData->SetIDs(frame.mFilename, id);
     }
 
     // Now we could have the correct window (if we are not window-less).
