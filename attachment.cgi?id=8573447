# HG changeset patch
# User Tom Tromey <tromey@mozilla.com>

Bug 984880 - rebase patch, import new css parser, and simplify a bit

diff --git a/browser/devtools/framework/toolbox-options.xul b/browser/devtools/framework/toolbox-options.xul
index 87949ba..601a7de 100644
--- a/browser/devtools/framework/toolbox-options.xul
+++ b/browser/devtools/framework/toolbox-options.xul
@@ -53,16 +53,17 @@
           <description>
             <label control="defaultColorUnitMenuList"
                    accesskey="&options.defaultColorUnit.accesskey;"
             >&options.defaultColorUnit.label;</label>
             <hbox>
               <menulist id="defaultColorUnitMenuList"
                         data-pref="devtools.defaultColorUnit">
                 <menupopup>
+                  <menuitem label="&options.defaultColorUnit.authored;" value="authored"/>
                   <menuitem label="&options.defaultColorUnit.hex;" value="hex"/>
                   <menuitem label="&options.defaultColorUnit.hsl;" value="hsl"/>
                   <menuitem label="&options.defaultColorUnit.rgb;" value="rgb"/>
                   <menuitem label="&options.defaultColorUnit.name;" value="name"/>
                 </menupopup>
               </menulist>
             </hbox>
           </description>
diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
index 0548e5e..3ff5cec 100644
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -13,17 +13,17 @@ const Cc = Components.classes;
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/Task.jsm");
 Cu.import("resource://gre/modules/devtools/Loader.jsm");
 Cu.import("resource://gre/modules/devtools/Console.jsm");
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const {InplaceEditor, editableItem} = devtools.require("devtools/shared/inplace-editor");
-const {parseDeclarations} = devtools.require("devtools/styleinspector/css-parsing-utils");
+const {parseDeclarations} = devtools.require("devtools/css-parsing-utils");
 const {ReflowFront} = devtools.require("devtools/server/actors/layout");
 
 const SHARED_L10N = new ViewHelpers.L10N("chrome://browser/locale/devtools/shared.properties");
 const NUMERIC = /^-?[\d\.]+$/;
 const LONG_TEXT_ROTATE_LIMIT = 3;
 
 /**
  * An instance of EditingSession tracks changes that have been made during the
diff --git a/browser/devtools/sourceeditor/css-autocompleter.js b/browser/devtools/sourceeditor/css-autocompleter.js
index e5f9f8c..59876b0 100644
--- a/browser/devtools/sourceeditor/css-autocompleter.js
+++ b/browser/devtools/sourceeditor/css-autocompleter.js
@@ -1,14 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { Cc, Ci, Cu } = require('chrome');
-const cssTokenizer  = require("devtools/sourceeditor/css-tokenizer");
+const cssTokenizer  = require("devtools/css-tokenizer");
 const promise = Cu.import("resource://gre/modules/Promise.jsm");
 
 /**
  * Here is what this file (+ ./css-tokenizer.js) do.
  *
  * The main objective here is to provide as much suggestions to the user editing
  * a stylesheet in Style Editor. The possible things that can be suggested are:
  *  - CSS property names
diff --git a/browser/devtools/sourceeditor/css-tokenizer.js b/browser/devtools/sourceeditor/css-tokenizer.js
deleted file mode 100644
index f7d596a..0000000
--- a/browser/devtools/sourceeditor/css-tokenizer.js
+++ /dev/null
@@ -1,717 +0,0 @@
-/**
- * This file is taken from the below mentioned url and is under CC0 license.
- * https://github.com/tabatkins/css-parser/blob/master/tokenizer.js
- * Please retain this comment while updating this file from upstream.
- */
-
-(function (root, factory) {
-    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
-    // Rhino, and plain browser loading.
-    if (typeof define === 'function' && define.amd) {
-        define(['exports'], factory);
-    } else if (typeof exports !== 'undefined') {
-        factory(exports);
-    } else {
-        factory(root);
-    }
-}(this, function (exports) {
-
-var between = function (num, first, last) { return num >= first && num <= last; }
-function digit(code) { return between(code, 0x30,0x39); }
-function hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }
-function uppercaseletter(code) { return between(code, 0x41,0x5a); }
-function lowercaseletter(code) { return between(code, 0x61,0x7a); }
-function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
-function nonascii(code) { return code >= 0xa0; }
-function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
-function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
-function nonprintable(code) { return between(code, 0,8) || between(code, 0xe,0x1f) || between(code, 0x7f,0x9f); }
-function newline(code) { return code == 0xa || code == 0xc; }
-function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
-function badescape(code) { return newline(code) || isNaN(code); }
-
-// Note: I'm not yet acting smart enough to actually handle astral characters.
-var maximumallowedcodepoint = 0x10ffff;
-
-function tokenize(str, options) {
-  if(options == undefined) options = {transformFunctionWhitespace:false, scientificNotation:false};
-  var i = -1;
-  var tokens = [];
-  var state = "data";
-  var code;
-  var currtoken;
-
-  // Line number information.
-  var line = 0;
-  var column = 0;
-  // The only use of lastLineLength is in reconsume().
-  var lastLineLength = 0;
-  var incrLineno = function() {
-    line += 1;
-    lastLineLength = column;
-    column = 0;
-  };
-  var locStart = {line:line, column:column};
-
-  var next = function(num) { if(num === undefined) num = 1; return str.charCodeAt(i+num); };
-  var consume = function(num) {
-    if(num === undefined)
-      num = 1;
-    i += num;
-    code = str.charCodeAt(i);
-    if (newline(code)) incrLineno();
-    else column += num;
-    //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
-    return true;
-  };
-  var reconsume = function() {
-    i -= 1;
-    if (newline(code)) {
-      line -= 1;
-      column = lastLineLength;
-    } else {
-      column -= 1;
-    }
-    locStart.line = line;
-    locStart.column = column;
-    return true;
-  };
-  var eof = function() { return i >= str.length; };
-  var donothing = function() {};
-  var emit = function(token) {
-    if(token) {
-      token.finish();
-    } else {
-      token = currtoken.finish();
-    }
-    if (options.loc === true) {
-      token.loc = {};
-      token.loc.start = {line:locStart.line, column:locStart.column};
-      locStart = {line: line, column: column};
-      token.loc.end = locStart;
-    }
-    tokens.push(token);
-    //console.log('Emitting ' + token);
-    currtoken = undefined;
-    return true;
-  };
-  var create = function(token) { currtoken = token; return true; };
-  var parseerror = function() { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + " in state " + state + ".");return true; };
-  var switchto = function(newstate) {
-    state = newstate;
-    //console.log('Switching to ' + state);
-    return true;
-  };
-  var consumeEscape = function() {
-    // Assume the the current character is the \
-    consume();
-    if(hexdigit(code)) {
-      // Consume 1-6 hex digits
-      var digits = [];
-      for(var total = 0; total < 6; total++) {
-        if(hexdigit(code)) {
-          digits.push(code);
-          consume();
-        } else { break; }
-      }
-      var value = parseInt(digits.map(String.fromCharCode).join(''), 16);
-      if( value > maximumallowedcodepoint ) value = 0xfffd;
-      // If the current char is whitespace, cool, we'll just eat it.
-      // Otherwise, put it back.
-      if(!whitespace(code)) reconsume();
-      return value;
-    } else {
-      return code;
-    }
-  };
-
-  for(;;) {
-    if(i > str.length*2) return "I'm infinite-looping!";
-    consume();
-    switch(state) {
-    case "data":
-      if(whitespace(code)) {
-        emit(new WhitespaceToken);
-        while(whitespace(next())) consume();
-      }
-      else if(code == 0x22) switchto("double-quote-string");
-      else if(code == 0x23) switchto("hash");
-      else if(code == 0x27) switchto("single-quote-string");
-      else if(code == 0x28) emit(new OpenParenToken);
-      else if(code == 0x29) emit(new CloseParenToken);
-      else if(code == 0x2b) {
-        if(digit(next()) || (next() == 0x2e && digit(next(2)))) switchto("number") && reconsume();
-        else emit(new DelimToken(code));
-      }
-      else if(code == 0x2d) {
-        if(next(1) == 0x2d && next(2) == 0x3e) consume(2) && emit(new CDCToken);
-        else if(digit(next()) || (next(1) == 0x2e && digit(next(2)))) switchto("number") && reconsume();
-        else if(namestartchar(next())) switchto("identifier") && reconsume();
-        else emit(new DelimToken(code));
-      }
-      else if(code == 0x2e) {
-        if(digit(next())) switchto("number") && reconsume();
-        else emit(new DelimToken(code));
-      }
-      else if(code == 0x2f) {
-        if(next() == 0x2a) switchto("comment");
-        else emit(new DelimToken(code));
-      }
-      else if(code == 0x3a) emit(new ColonToken);
-      else if(code == 0x3b) emit(new SemicolonToken);
-      else if(code == 0x3c) {
-        if(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) consume(3) && emit(new CDOToken);
-        else emit(new DelimToken(code));
-      }
-      else if(code == 0x40) switchto("at-keyword");
-      else if(code == 0x5b) emit(new OpenSquareToken);
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit(new DelimToken(code));
-        else switchto("identifier") && reconsume();
-      }
-      else if(code == 0x5d) emit(new CloseSquareToken);
-      else if(code == 0x7b) emit(new OpenCurlyToken);
-      else if(code == 0x7d) emit(new CloseCurlyToken);
-      else if(digit(code)) switchto("number") && reconsume();
-      else if(code == 0x55 || code == 0x75) {
-        if(next(1) == 0x2b && hexdigit(next(2))) consume() && switchto("unicode-range");
-        else if((next(1) == 0x52 || next(1) == 0x72) && (next(2) == 0x4c || next(2) == 0x6c) && (next(3) == 0x28)) consume(3) && switchto("url");
-        else switchto("identifier") && reconsume();
-      }
-      else if(namestartchar(code)) switchto("identifier") && reconsume();
-      else if(eof()) { emit(new EOFToken); return tokens; }
-      else emit(new DelimToken(code));
-      break;
-
-    case "double-quote-string":
-      if(currtoken == undefined) create(new StringToken);
-
-      if(code == 0x22) emit() && switchto("data");
-      else if(eof()) parseerror() && emit() && switchto("data");
-      else if(newline(code)) parseerror() && emit(new BadStringToken) && switchto("data") && reconsume();
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit(new BadStringToken) && switchto("data");
-        else if(newline(next())) consume();
-        else currtoken.append(consumeEscape());
-      }
-      else currtoken.append(code);
-      break;
-
-    case "single-quote-string":
-      if(currtoken == undefined) create(new StringToken);
-
-      if(code == 0x27) emit() && switchto("data");
-      else if(eof()) parseerror() && emit() && switchto("data");
-      else if(newline(code)) parseerror() && emit(new BadStringToken) && switchto("data") && reconsume();
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit(new BadStringToken) && switchto("data");
-        else if(newline(next())) consume();
-        else currtoken.append(consumeEscape());
-      }
-      else currtoken.append(code);
-      break;
-
-    case "hash":
-      if(namechar(code)) create(new HashToken(code)) && switchto("hash-rest");
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit(new DelimToken(0x23)) && switchto("data") && reconsume();
-        else create(new HashToken(consumeEscape())) && switchto('hash-rest');
-      }
-      else emit(new DelimToken(0x23)) && switchto('data') && reconsume();
-      break;
-
-    case "hash-rest":
-      if(namechar(code)) currtoken.append(code);
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit(new DelimToken(0x23)) && switchto("data") && reconsume();
-        else currtoken.append(consumeEscape());
-      }
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "comment":
-      if(code == 0x2a) {
-        if(next() == 0x2f) consume() && switchto('data');
-        else donothing();
-      }
-      else if(eof()) parseerror() && switchto('data') && reconsume();
-      else donothing();
-      break;
-
-    case "at-keyword":
-      if(code == 0x2d) {
-        if(namestartchar(next())) consume() && create(new AtKeywordToken([0x40,code])) && switchto('at-keyword-rest');
-        else emit(new DelimToken(0x40)) && switchto('data') && reconsume();
-      }
-      else if(namestartchar(code)) create(new AtKeywordToken(code)) && switchto('at-keyword-rest');
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit(new DelimToken(0x23)) && switchto("data") && reconsume();
-        else create(new AtKeywordToken(consumeEscape())) && switchto('at-keyword-rest');
-      }
-      else emit(new DelimToken(0x40)) && switchto('data') && reconsume();
-      break;
-
-    case "at-keyword-rest":
-      if(namechar(code)) currtoken.append(code);
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit() && switchto("data") && reconsume();
-        else currtoken.append(consumeEscape());
-      }
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "identifier":
-      if(code == 0x2d) {
-        if(namestartchar(next())) create(new IdentifierToken(code)) && switchto('identifier-rest');
-        else switchto('data') && reconsume();
-      }
-      else if(namestartchar(code)) create(new IdentifierToken(code)) && switchto('identifier-rest');
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && switchto("data") && reconsume();
-        else create(new IdentifierToken(consumeEscape())) && switchto('identifier-rest');
-      }
-      else switchto('data') && reconsume();
-      break;
-
-    case "identifier-rest":
-      if(namechar(code)) currtoken.append(code);
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit() && switchto("data") && reconsume();
-        else currtoken.append(consumeEscape());
-      }
-      else if(code == 0x28) emit(new FunctionToken(currtoken)) && switchto('data');
-      else if(whitespace(code) && options.transformFunctionWhitespace) switchto('transform-function-whitespace');
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "transform-function-whitespace":
-      if(whitespace(code)) donothing();
-      else if(code == 0x28) emit(new FunctionToken(currtoken)) && switchto('data');
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "number":
-      create(new NumberToken());
-
-      if(code == 0x2d) {
-        if(digit(next())) consume() && currtoken.append([0x2d,code]) && switchto('number-rest');
-        else if(next(1) == 0x2e && digit(next(2))) consume(2) && currtoken.append([0x2d,0x2e,code]) && switchto('number-fraction');
-        else switchto('data') && reconsume();
-      }
-      else if(code == 0x2b) {
-        if(digit(next())) consume() && currtoken.append([0x2b,code]) && switchto('number-rest');
-        else if(next(1) == 0x2e && digit(next(2))) consume(2) && currtoken.append([0x2b,0x2e,code]) && switchto('number-fraction');
-        else switchto('data') && reconsume();
-      }
-      else if(digit(code)) currtoken.append(code) && switchto('number-rest');
-      else if(code == 0x2e) {
-        if(digit(next())) consume() && currtoken.append([0x2e,code]) && switchto('number-fraction');
-        else switchto('data') && reconsume();
-      }
-      else switchto('data') && reconsume();
-      break;
-
-    case "number-rest":
-      if(digit(code)) currtoken.append(code);
-      else if(code == 0x2e) {
-        if(digit(next())) consume() && currtoken.append([0x2e,code]) && switchto('number-fraction');
-        else emit() && switchto('data') && reconsume();
-      }
-      else if(code == 0x25) emit(new PercentageToken(currtoken)) && switchto('data') && reconsume();
-      else if(code == 0x45 || code == 0x65) {
-        if(!options.scientificNotation) create(new DimensionToken(currtoken,code)) && switchto('dimension');
-        else if(digit(next())) consume() && currtoken.append([0x25,code]) && switchto('sci-notation');
-        else if((next(1) == 0x2b || next(1) == 0x2d) && digit(next(2))) currtoken.append([0x25,next(1),next(2)]) && consume(2) && switchto('sci-notation');
-        else create(new DimensionToken(currtoken,code)) && switchto('dimension');
-      }
-      else if(code == 0x2d) {
-        if(namestartchar(next())) consume() && create(new DimensionToken(currtoken,[0x2d,code])) && switchto('dimension');
-        else if(next(1) == 0x5c && badescape(next(2))) parseerror() && emit() && switchto('data') && reconsume();
-        else if(next(1) == 0x5c) consume() && create(new DimensionToken(currtoken, [0x2d,consumeEscape()])) && switchto('dimension');
-        else emit() && switchto('data') && reconsume();
-      }
-      else if(namestartchar(code)) create(new DimensionToken(currtoken, code)) && switchto('dimension');
-      else if(code == 0x5c) {
-        if(badescape(next)) emit() && switchto('data') && reconsume();
-        else create(new DimensionToken(currtoken,consumeEscape)) && switchto('dimension');
-      }
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "number-fraction":
-      currtoken.type = "number";
-
-      if(digit(code)) currtoken.append(code);
-      else if(code == 0x2e) emit() && switchto('data') && reconsume();
-      else if(code == 0x25) emit(new PercentageToken(currtoken)) && switchto('data') && reconsume();
-      else if(code == 0x45 || code == 0x65) {
-        if(!options.scientificNotation) create(new DimensionToken(currtoken,code)) && switchto('dimension');
-        else if(digit(next())) consume() && currtoken.append([0x25,code]) && switchto('sci-notation');
-        else if((next(1) == 0x2b || next(1) == 0x2d) && digit(next(2))) currtoken.append([0x25,next(1),next(2)]) && consume(2) && switchto('sci-notation');
-        else create(new DimensionToken(currtoken,code)) && switchto('dimension');
-      }
-      else if(code == 0x2d) {
-        if(namestartchar(next())) consume() && create(new DimensionToken(currtoken,[0x2d,code])) && switchto('dimension');
-        else if(next(1) == 0x5c && badescape(next(2))) parseerror() && emit() && switchto('data') && reconsume();
-        else if(next(1) == 0x5c) consume() && create(new DimensionToken(currtoken, [0x2d,consumeEscape()])) && switchto('dimension');
-        else emit() && switchto('data') && reconsume();
-      }
-      else if(namestartchar(code)) create(new DimensionToken(currtoken, code)) && switchto('dimension');
-      else if(code == 0x5c) {
-        if(badescape(next)) emit() && switchto('data') && reconsume();
-        else create(new DimensionToken(currtoken,consumeEscape)) && switchto('dimension');
-      }
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "dimension":
-      if(namechar(code)) currtoken.append(code);
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && emit() && switchto('data') && reconsume();
-        else currtoken.append(consumeEscape());
-      }
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "sci-notation":
-      if(digit(code)) currtoken.append(code);
-      else emit() && switchto('data') && reconsume();
-      break;
-
-    case "url":
-      if(code == 0x22) switchto('url-double-quote');
-      else if(code == 0x27) switchto('url-single-quote');
-      else if(code == 0x29) emit(new URLToken) && switchto('data');
-      else if(whitespace(code)) donothing();
-      else switchto('url-unquoted') && reconsume();
-      break;
-
-    case "url-double-quote":
-      if(currtoken == undefined) create(new URLToken);
-
-      if(code == 0x22) switchto('url-end');
-      else if(newline(code)) parseerror() && switchto('bad-url');
-      else if(code == 0x5c) {
-        if(newline(next())) consume();
-        else if(badescape(next())) parseerror() && emit(new BadURLToken) && switchto('data') && reconsume();
-        else currtoken.append(consumeEscape());
-      }
-      else currtoken.append(code);
-      break;
-
-    case "url-single-quote":
-      if(currtoken == undefined) create(new URLToken);
-
-      if(code == 0x27) switchto('url-end');
-      else if(newline(code)) parseerror() && switchto('bad-url');
-      else if(code == 0x5c) {
-        if(newline(next())) consume();
-        else if(badescape(next())) parseerror() && emit(new BadURLToken) && switchto('data') && reconsume();
-        else currtoken.append(consumeEscape());
-      }
-      else currtoken.append(code);
-      break;
-
-    case "url-end":
-      if(whitespace(code)) donothing();
-      else if(code == 0x29) emit() && switchto('data');
-      else parseerror() && switchto('bad-url') && reconsume();
-      break;
-
-    case "url-unquoted":
-      if(currtoken == undefined) create(new URLToken);
-
-      if(whitespace(code)) switchto('url-end');
-      else if(code == 0x29) emit() && switchto('data');
-      else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) parseerror() && switchto('bad-url');
-      else if(code == 0x5c) {
-        if(badescape(next())) parseerror() && switchto('bad-url');
-        else currtoken.append(consumeEscape());
-      }
-      else currtoken.append(code);
-      break;
-
-    case "bad-url":
-      if(code == 0x29) emit(new BadURLToken) && switchto('data');
-      else if(code == 0x5c) {
-        if(badescape(next())) donothing();
-        else consumeEscape()
-      }
-      else donothing();
-      break;
-
-    case "unicode-range":
-      // We already know that the current code is a hexdigit.
-
-      var start = [code], end = [code];
-
-      for(var total = 1; total < 6; total++) {
-        if(hexdigit(next())) {
-          consume();
-          start.push(code);
-          end.push(code);
-        }
-        else break;
-      }
-
-      if(next() == 0x3f) {
-        for(;total < 6; total++) {
-          if(next() == 0x3f) {
-            consume();
-            start.push("0".charCodeAt(0));
-            end.push("f".charCodeAt(0));
-          }
-          else break;
-        }
-        emit(new UnicodeRangeToken(start,end)) && switchto('data');
-      }
-      else if(next(1) == 0x2d && hexdigit(next(2))) {
-        consume();
-        consume();
-        end = [code];
-        for(var total = 1; total < 6; total++) {
-          if(hexdigit(next())) {
-            consume();
-            end.push(code);
-          }
-          else break;
-        }
-        emit(new UnicodeRangeToken(start,end)) && switchto('data');
-      }
-      else emit(new UnicodeRangeToken(start)) && switchto('data');
-      break;
-
-    default:
-      console.log("Unknown state '" + state + "'");
-    }
-  }
-}
-
-function stringFromCodeArray(arr) {
-  return String.fromCharCode.apply(null,arr.filter(function(e){return e;}));
-}
-
-function CSSParserToken(options) { return this; }
-CSSParserToken.prototype.finish = function() { return this; }
-CSSParserToken.prototype.toString = function() { return this.tokenType; }
-CSSParserToken.prototype.toJSON = function() { return this.toString(); }
-
-function BadStringToken() { return this; }
-BadStringToken.prototype = new CSSParserToken;
-BadStringToken.prototype.tokenType = "BADSTRING";
-
-function BadURLToken() { return this; }
-BadURLToken.prototype = new CSSParserToken;
-BadURLToken.prototype.tokenType = "BADURL";
-
-function WhitespaceToken() { return this; }
-WhitespaceToken.prototype = new CSSParserToken;
-WhitespaceToken.prototype.tokenType = "WHITESPACE";
-WhitespaceToken.prototype.toString = function() { return "WS"; }
-
-function CDOToken() { return this; }
-CDOToken.prototype = new CSSParserToken;
-CDOToken.prototype.tokenType = "CDO";
-
-function CDCToken() { return this; }
-CDCToken.prototype = new CSSParserToken;
-CDCToken.prototype.tokenType = "CDC";
-
-function ColonToken() { return this; }
-ColonToken.prototype = new CSSParserToken;
-ColonToken.prototype.tokenType = ":";
-
-function SemicolonToken() { return this; }
-SemicolonToken.prototype = new CSSParserToken;
-SemicolonToken.prototype.tokenType = ";";
-
-function OpenCurlyToken() { return this; }
-OpenCurlyToken.prototype = new CSSParserToken;
-OpenCurlyToken.prototype.tokenType = "{";
-
-function CloseCurlyToken() { return this; }
-CloseCurlyToken.prototype = new CSSParserToken;
-CloseCurlyToken.prototype.tokenType = "}";
-
-function OpenSquareToken() { return this; }
-OpenSquareToken.prototype = new CSSParserToken;
-OpenSquareToken.prototype.tokenType = "[";
-
-function CloseSquareToken() { return this; }
-CloseSquareToken.prototype = new CSSParserToken;
-CloseSquareToken.prototype.tokenType = "]";
-
-function OpenParenToken() { return this; }
-OpenParenToken.prototype = new CSSParserToken;
-OpenParenToken.prototype.tokenType = "(";
-
-function CloseParenToken() { return this; }
-CloseParenToken.prototype = new CSSParserToken;
-CloseParenToken.prototype.tokenType = ")";
-
-function EOFToken() { return this; }
-EOFToken.prototype = new CSSParserToken;
-EOFToken.prototype.tokenType = "EOF";
-
-function DelimToken(code) {
-  this.value = String.fromCharCode(code);
-  return this;
-}
-DelimToken.prototype = new CSSParserToken;
-DelimToken.prototype.tokenType = "DELIM";
-DelimToken.prototype.toString = function() { return "DELIM("+this.value+")"; }
-
-function StringValuedToken() { return this; }
-StringValuedToken.prototype = new CSSParserToken;
-StringValuedToken.prototype.append = function(val) {
-  if(val instanceof Array) {
-    for(var i = 0; i < val.length; i++) {
-      this.value.push(val[i]);
-    }
-  } else {
-    this.value.push(val);
-  }
-  return true;
-}
-StringValuedToken.prototype.finish = function() {
-  this.value = stringFromCodeArray(this.value);
-  return this;
-}
-
-function IdentifierToken(val) {
-  this.value = [];
-  this.append(val);
-}
-IdentifierToken.prototype = new StringValuedToken;
-IdentifierToken.prototype.tokenType = "IDENT";
-IdentifierToken.prototype.toString = function() { return "IDENT("+this.value+")"; }
-
-function FunctionToken(val) {
-  // These are always constructed by passing an IdentifierToken
-  this.value = val.finish().value;
-}
-FunctionToken.prototype = new CSSParserToken;
-FunctionToken.prototype.tokenType = "FUNCTION";
-FunctionToken.prototype.toString = function() { return "FUNCTION("+this.value+")"; }
-
-function AtKeywordToken(val) {
-  this.value = [];
-  this.append(val);
-}
-AtKeywordToken.prototype = new StringValuedToken;
-AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
-AtKeywordToken.prototype.toString = function() { return "AT("+this.value+")"; }
-
-function HashToken(val) {
-  this.value = [];
-  this.append(val);
-}
-HashToken.prototype = new StringValuedToken;
-HashToken.prototype.tokenType = "HASH";
-HashToken.prototype.toString = function() { return "HASH("+this.value+")"; }
-
-function StringToken(val) {
-  this.value = [];
-  this.append(val);
-}
-StringToken.prototype = new StringValuedToken;
-StringToken.prototype.tokenType = "STRING";
-StringToken.prototype.toString = function() { return "\""+this.value+"\""; }
-
-function URLToken(val) {
-  this.value = [];
-  this.append(val);
-}
-URLToken.prototype = new StringValuedToken;
-URLToken.prototype.tokenType = "URL";
-URLToken.prototype.toString = function() { return "URL("+this.value+")"; }
-
-function NumberToken(val) {
-  this.value = [];
-  this.append(val);
-  this.type = "integer";
-}
-NumberToken.prototype = new StringValuedToken;
-NumberToken.prototype.tokenType = "NUMBER";
-NumberToken.prototype.toString = function() {
-  if(this.type == "integer")
-    return "INT("+this.value+")";
-  return "NUMBER("+this.value+")";
-}
-NumberToken.prototype.finish = function() {
-  this.repr = stringFromCodeArray(this.value);
-  this.value = this.repr * 1;
-  if(Math.abs(this.value) % 1 != 0) this.type = "number";
-  return this;
-}
-
-function PercentageToken(val) {
-  // These are always created by passing a NumberToken as val
-  val.finish();
-  this.value = val.value;
-  this.repr = val.repr;
-}
-PercentageToken.prototype = new CSSParserToken;
-PercentageToken.prototype.tokenType = "PERCENTAGE";
-PercentageToken.prototype.toString = function() { return "PERCENTAGE("+this.value+")"; }
-
-function DimensionToken(val,unit) {
-  // These are always created by passing a NumberToken as the val
-  val.finish();
-  this.num = val.value;
-  this.unit = [];
-  this.repr = val.repr;
-  this.append(unit);
-}
-DimensionToken.prototype = new CSSParserToken;
-DimensionToken.prototype.tokenType = "DIMENSION";
-DimensionToken.prototype.toString = function() { return "DIM("+this.num+","+this.unit+")"; }
-DimensionToken.prototype.append = function(val) {
-  if(val instanceof Array) {
-    for(var i = 0; i < val.length; i++) {
-      this.unit.push(val[i]);
-    }
-  } else {
-    this.unit.push(val);
-  }
-  return true;
-}
-DimensionToken.prototype.finish = function() {
-  this.unit = stringFromCodeArray(this.unit);
-  this.repr += this.unit;
-  return this;
-}
-
-function UnicodeRangeToken(start,end) {
-  // start and end are array of char codes, completely finished
-  start = parseInt(stringFromCodeArray(start),16);
-  if(end === undefined) end = start + 1;
-  else end = parseInt(stringFromCodeArray(end),16);
-
-  if(start > maximumallowedcodepoint) end = start;
-  if(end < start) end = start;
-  if(end > maximumallowedcodepoint) end = maximumallowedcodepoint;
-
-  this.start = start;
-  this.end = end;
-  return this;
-}
-UnicodeRangeToken.prototype = new CSSParserToken;
-UnicodeRangeToken.prototype.tokenType = "UNICODE-RANGE";
-UnicodeRangeToken.prototype.toString = function() {
-  if(this.start+1 == this.end)
-    return "UNICODE-RANGE("+this.start.toString(16).toUpperCase()+")";
-  if(this.start < this.end)
-    return "UNICODE-RANGE("+this.start.toString(16).toUpperCase()+"-"+this.end.toString(16).toUpperCase()+")";
-  return "UNICODE-RANGE()";
-}
-UnicodeRangeToken.prototype.contains = function(code) {
-  return code >= this.start && code < this.end;
-}
-
-
-// Exportation.
-// TODO: also export the various tokens objects?
-module.exports = tokenize;
-
-}));
diff --git a/browser/devtools/sourceeditor/moz.build b/browser/devtools/sourceeditor/moz.build
index 67a53b40..07cf55b 100644
--- a/browser/devtools/sourceeditor/moz.build
+++ b/browser/devtools/sourceeditor/moz.build
@@ -2,14 +2,13 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXTRA_JS_MODULES.devtools.sourceeditor += [
     'autocomplete.js',
     'css-autocompleter.js',
-    'css-tokenizer.js',
     'debugger.js',
     'editor.js'
 ]
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
diff --git a/browser/devtools/styleinspector/css-parsing-utils.js b/browser/devtools/styleinspector/css-parsing-utils.js
deleted file mode 100644
index a1e670c..0000000
--- a/browser/devtools/styleinspector/css-parsing-utils.js
+++ /dev/null
@@ -1,154 +0,0 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const cssTokenizer  = require("devtools/sourceeditor/css-tokenizer");
-
-/**
- * Returns the string enclosed in quotes
- */
-function quoteString(string) {
-  let hasDoubleQuotes = string.contains('"');
-  let hasSingleQuotes = string.contains("'");
-
-  if (hasDoubleQuotes && !hasSingleQuotes) {
-    // In this case, no escaping required, just enclose in single-quotes
-    return "'" + string + "'";
-  }
-
-  // In all other cases, enclose in double-quotes, and escape any double-quote
-  // that may be in the string
-  return '"' + string.replace(/"/g, '\"') + '"';
-}
-
-/**
- * Returns an array of CSS declarations given an string.
- * For example, parseDeclarations("width: 1px; height: 1px") would return
- * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
- *
- * The input string is assumed to only contain declarations so { and } characters
- * will be treated as part of either the property or value, depending where it's
- * found.
- *
- * @param {string} inputString
- *        An input string of CSS
- * @return {Array} an array of objects with the following signature:
- *         [{"name": string, "value": string, "priority": string}, ...]
- */
-function parseDeclarations(inputString) {
-  let tokens = cssTokenizer(inputString);
-
-  let declarations = [{name: "", value: "", priority: ""}];
-
-  let current = "", hasBang = false, lastProp;
-  for (let token of tokens) {
-    lastProp = declarations[declarations.length - 1];
-
-    if (token.tokenType === ":") {
-      if (!lastProp.name) {
-        // Set the current declaration name if there's no name yet
-        lastProp.name = current.trim();
-        current = "";
-        hasBang = false;
-      } else {
-        // Otherwise, just append ':' to the current value (declaration value
-        // with colons)
-        current += ":";
-      }
-    } else if (token.tokenType === ";") {
-      lastProp.value = current.trim();
-      current = "";
-      hasBang = false;
-      declarations.push({name: "", value: "", priority: ""});
-    } else {
-      switch(token.tokenType) {
-        case "IDENT":
-          if (token.value === "important" && hasBang) {
-            lastProp.priority = "important";
-            hasBang = false;
-          } else {
-            if (hasBang) {
-              current += "!";
-            }
-            current += token.value;
-          }
-          break;
-        case "WHITESPACE":
-          current += " ";
-          break;
-        case "DIMENSION":
-          current += token.repr;
-          break;
-        case "HASH":
-          current += "#" + token.value;
-          break;
-        case "URL":
-          current += "url(" + quoteString(token.value) + ")";
-          break;
-        case "FUNCTION":
-          current += token.value + "(";
-          break;
-        case "(":
-        case ")":
-          current += token.tokenType;
-          break;
-        case "EOF":
-          break;
-        case "DELIM":
-          if (token.value === "!") {
-            hasBang = true;
-          } else {
-            current += token.value;
-          }
-          break;
-        case "STRING":
-          current += quoteString(token.value);
-          break;
-        case "{":
-        case "}":
-          current += token.tokenType;
-          break;
-        default:
-          current += token.value;
-          break;
-      }
-    }
-  }
-
-  // Handle whatever trailing properties or values might still be there
-  if (current) {
-    if (!lastProp.name) {
-      // Trailing property found, e.g. p1:v1;p2:v2;p3
-      lastProp.name = current.trim();
-    } else {
-      // Trailing value found, i.e. value without an ending ;
-      lastProp.value += current.trim();
-    }
-  }
-
-  // Remove declarations that have neither a name nor a value
-  declarations = declarations.filter(prop => prop.name || prop.value);
-
-  return declarations;
-};
-exports.parseDeclarations = parseDeclarations;
-
-/**
- * Expects a single CSS value to be passed as the input and parses the value
- * and priority.
- *
- * @param {string} value The value from the text editor.
- * @return {object} an object with 'value' and 'priority' properties.
- */
-function parseSingleValue(value) {
-  let declaration = parseDeclarations("a: " + value + ";")[0];
-  return {
-    value: declaration ? declaration.value : "",
-    priority: declaration ? declaration.priority : ""
-  };
-};
-exports.parseSingleValue = parseSingleValue;
diff --git a/browser/devtools/styleinspector/moz.build b/browser/devtools/styleinspector/moz.build
index bf8611e..ae5fd5b 100644
--- a/browser/devtools/styleinspector/moz.build
+++ b/browser/devtools/styleinspector/moz.build
@@ -1,16 +1,14 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
-XPCSHELL_TESTS_MANIFESTS += ['test/unit/xpcshell.ini']
 
 EXTRA_JS_MODULES.devtools.styleinspector += [
     'computed-view.js',
-    'css-parsing-utils.js',
     'rule-view.js',
     'style-inspector-overlays.js',
     'style-inspector.js',
 ]
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
index 87e7475..ca94965 100644
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -9,17 +9,17 @@
 const {Cc, Ci, Cu} = require("chrome");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const {CssLogic} = require("devtools/styleinspector/css-logic");
 const {InplaceEditor, editableField, editableItem} = require("devtools/shared/inplace-editor");
 const {ELEMENT_STYLE, PSEUDO_ELEMENTS} = require("devtools/server/actors/styles");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {OutputParser} = require("devtools/output-parser");
 const {PrefObserver, PREF_ORIG_SOURCES} = require("devtools/styleeditor/utils");
-const {parseSingleValue, parseDeclarations} = require("devtools/styleinspector/css-parsing-utils");
+const {parseSingleValue, parseDeclarations} = require("devtools/css-parsing-utils");
 const overlays = require("devtools/styleinspector/style-inspector-overlays");
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const PREF_UA_STYLES = "devtools.inspector.showUserAgentStyles";
@@ -226,71 +226,66 @@ ElementStyle.prototype = {
         this._sortRulesForPseudoElement();
 
         // We're done with the previous list of rules.
         delete this._refreshRules;
 
         return null;
       });
     }).then(null, promiseWarn);
+
     this.populated = populated;
     return this.populated;
   },
 
   /**
    * Put pseudo elements in front of others.
    */
    _sortRulesForPseudoElement: function() {
       this.rules = this.rules.sort((a, b) => {
         return (a.pseudoElement || "z") > (b.pseudoElement || "z");
       });
    },
 
   /**
-   * Add a rule if it's one we care about.  Filters out duplicates and
-   * inherited styles with no inherited properties.
-   *
-   * @param {object} aOptions
-   *        Options for creating the Rule, see the Rule constructor.
-   *
-   * @return {bool} true if we added the rule.
+   * Add a rule if it's one we care about. Filters out duplicates and inherited
+   * styles with no inherited properties.
+   * @param {object} options Options for creating the Rule, see the Rule constructor.
    */
-  _maybeAddRule: function(aOptions) {
-    // If we've already included this domRule (for example, when a
-    // common selector is inherited), ignore it.
-    if (aOptions.rule &&
-        this.rules.some(function(rule) rule.domRule === aOptions.rule)) {
+  _maybeAddRule: function(options) {
+    // If we've already included this domRule (for example, when a common selector
+    // is inherited), ignore it
+    if (options.rule && this.rules.some(rule => rule.domRule === options.rule)) {
       return false;
     }
 
-    if (aOptions.system) {
+    if (options.system) {
       return false;
     }
 
     let rule = null;
 
-    // If we're refreshing and the rule previously existed, reuse the
-    // Rule object.
+    // If we're refreshing and the rule previously existed, reuse the Rule object
     if (this._refreshRules) {
       for (let r of this._refreshRules) {
-        if (r.matches(aOptions)) {
+        if (r.matches(options)) {
           rule = r;
-          rule.refresh(aOptions);
+          rule.refresh(options);
           break;
         }
       }
     }
 
     // If this is a new rule, create its Rule object.
     if (!rule) {
-      rule = new Rule(this, aOptions);
+      rule = new Rule(this, options);
     }
 
     // Ignore inherited rules with no properties.
-    if (aOptions.inherited && rule.textProps.length == 0) {
+    if (options.inherited && rule.textProps.length == 0) {
       return false;
     }
 
     this.rules.push(rule);
     return true;
   },
 
   /**
@@ -344,16 +339,28 @@ ElementStyle.prototype = {
     //   If the new property is a lower or equal priority, mark it as
     //   overridden.
     //
     // _overriddenDirty will be set on each prop, indicating whether its
     // dirty status changed during this pass.
     let taken = {};
     for (let computedProp of computedProps) {
       let earlier = taken[computedProp.name];
+
+      // XXX: prevent the -webkit-gradient from being selected after unchecking
+      // linear-gradient in this case:
+      //  -moz-linear-gradient: ...;
+      //  -webkit-linear-gradient: ...;
+      //  linear-gradient: ...;
+      // First of all, the isValid check should probably move to the prop instead of the textProp.editor
+      let isValidXXX = !computedProp.textProp.editor || computedProp.textProp.editor.isValid();
+      if (!isValidXXX) {
+        computedProp.overridden = true;
+        continue;
+      }
       let overridden;
       if (earlier &&
           computedProp.priority === "important" &&
           earlier.priority !== "important") {
         // New property is higher priority.  Mark the earlier property
         // overridden (which will reverse its dirty state).
         earlier._overriddenDirty = !earlier._overriddenDirty;
         earlier.overridden = true;
@@ -412,19 +419,19 @@ ElementStyle.prototype = {
 
 /**
  * A single style rule or declaration.
  *
  * @param {ElementStyle} aElementStyle
  *        The ElementStyle to which this rule belongs.
  * @param {object} aOptions
  *        The information used to construct this rule.  Properties include:
- *          rule: A StyleRuleActor
- *          inherited: An element this rule was inherited from.  If omitted,
- *            the rule applies directly to the current element.
+ *        - rule: A StyleRuleActor
+ *        - inherited: An element this rule was inherited from.  If omitted, the
+ *          rule applies directly to the current element.
  *          isSystem: Is this a user agent style?
  * @constructor
  */
 function Rule(aElementStyle, aOptions) {
   this.elementStyle = aElementStyle;
   this.domRule = aOptions.rule || null;
   this.style = aOptions.rule;
   this.matchedSelectors = aOptions.matchedSelectors || [];
@@ -751,16 +758,17 @@ Rule.prototype = {
   /**
    * Get the list of TextProperties from the style.  Needs
    * to parse the style's cssText.
    */
   _getTextProperties: function() {
     let textProps = [];
     let store = this.elementStyle.store;
     let props = parseDeclarations(this.style.cssText);
+
     for (let prop of props) {
       let name = prop.name;
       if (this.inherited && !domUtils.isInheritedProperty(name)) {
         continue;
       }
       let value = store.userProperties.getProperty(this.style, name, prop.value);
       let textProp = new TextProperty(this, name, value, prop.priority);
       textProps.push(textProp);
@@ -896,18 +904,17 @@ Rule.prototype = {
         match.prop = prop;
       } else if (rank) {
         // A previous match outranks us, disable ourself.
         prop.enabled = false;
         prop.updateEditor();
       }
     }
 
-    // If we found a match, update its value with the new text property
-    // value.
+    // If we found a match, update its value with the new text property value.
     if (match.prop) {
       match.prop.set(aNewProp);
       return true;
     }
 
     return false;
   },
 
@@ -2335,17 +2342,17 @@ TextPropertyEditor.prototype = {
     // the user.
     let outputParser = this.ruleEditor.ruleView._outputParser;
     let frag = outputParser.parseCssProperty(this.prop.name, this.prop.value);
     let parsedValue = frag.textContent;
 
     // Save the initial value as the last committed value,
     // for restoring after pressing escape.
     this.committed = { name: this.prop.name,
-                       value: parsedValue,
+                       value: this.prop.value, // FIXME
                        priority: this.prop.priority };
 
     appendText(propertyContainer, ";");
 
     this.warning = createChild(this.element, "div", {
       class: "ruleview-warning",
       hidden: "",
       title: CssLogic.l10n("rule.warning.title"),
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js b/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
index 0eaebcb..e376512 100644
--- a/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_media-queries.js
@@ -20,12 +20,11 @@ add_task(function*() {
   let _strings = Services.strings
     .createBundle("chrome://global/locale/devtools/styleinspector.properties");
 
   let inline = _strings.GetStringFromName("rule.sourceInline");
 
   is(elementStyle.rules.length, 3, "Should have 3 rules.");
   is(elementStyle.rules[0].title, inline, "check rule 0 title");
   is(elementStyle.rules[1].title, inline +
-    ":15 @media screen and (min-width: 1px)", "check rule 1 title");
-  is(elementStyle.rules[2].title, inline + ":8", "check rule 2 title");
+    ":9 @media screen and (min-width: 1px)", "check rule 1 title");
+  is(elementStyle.rules[2].title, inline + ":2", "check rule 2 title");
 });
-
diff --git a/browser/devtools/styleinspector/test/unit/test_parseSingleValue.js b/browser/devtools/styleinspector/test/unit/test_parseSingleValue.js
index ff39878..e69de29 100644
--- a/browser/devtools/styleinspector/test/unit/test_parseSingleValue.js
+++ b/browser/devtools/styleinspector/test/unit/test_parseSingleValue.js
@@ -1,76 +0,0 @@
-/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-const Cu = Components.utils;
-Cu.import("resource://gre/modules/devtools/Loader.jsm");
-const {parseSingleValue} = devtools.require("devtools/styleinspector/css-parsing-utils");
-
-const TEST_DATA = [
-  {input: null, throws: true},
-  {input: undefined, throws: true},
-  {input: "", expected: {value: "", priority: ""}},
-  {input: "  \t \t \n\n  ", expected: {value: "", priority: ""}},
-  {input: "blue", expected: {value: "blue", priority: ""}},
-  {input: "blue !important", expected: {value: "blue", priority: "important"}},
-  {input: "blue!important", expected: {value: "blue", priority: "important"}},
-  {input: "blue ! important", expected: {value: "blue", priority: "important"}},
-  {input: "blue !  important", expected: {value: "blue", priority: "important"}},
-  {input: "blue !", expected: {value: "blue", priority: ""}},
-  {input: "blue !mportant", expected: {value: "blue !mportant", priority: ""}},
-  {input: "  blue   !important ", expected: {value: "blue", priority: "important"}},
-  {
-    input: "url(\"http://url.com/whyWouldYouDoThat!important.png\") !important",
-    expected: {
-      value: "url(\"http://url.com/whyWouldYouDoThat!important.png\")",
-      priority: "important"
-    }
-  },
-  {
-    input: "url(\"http://url.com/whyWouldYouDoThat!important.png\")",
-    expected: {
-      value: "url(\"http://url.com/whyWouldYouDoThat!important.png\")",
-      priority: ""
-    }
-  },
-  {
-    input: "\"content!important\" !important",
-    expected: {
-      value: "\"content!important\"",
-      priority: "important"
-    }
-  },
-  {
-    input: "\"content!important\"",
-    expected: {
-      value: "\"content!important\"",
-      priority: ""
-    }
-  }
-];
-
-function run_test() {
-  for (let test of TEST_DATA) {
-    do_print("Test input value " + test.input);
-    try {
-      let output = parseSingleValue(test.input);
-      assertOutput(output, test.expected);
-    } catch (e) {
-      do_print("parseSingleValue threw an exception with the given input value");
-      if (test.throws) {
-        do_print("Exception expected");
-        do_check_true(true);
-      } else {
-        do_print("Exception unexpected\n" + e);
-        do_check_true(false);
-      }
-    }
-  }
-}
-
-function assertOutput(actual, expected) {
-  do_print("Check that the output has the expected value and priority");
-  do_check_eq(expected.value, actual.value);
-  do_check_eq(expected.priority, actual.priority);
-}
diff --git a/browser/devtools/styleinspector/test/unit/xpcshell.ini b/browser/devtools/styleinspector/test/unit/xpcshell.ini
deleted file mode 100644
index 90b0c5d..0000000
--- a/browser/devtools/styleinspector/test/unit/xpcshell.ini
+++ /dev/null
@@ -1,8 +0,0 @@
-[DEFAULT]
-head =
-tail =
-firefox-appdir = browser
-skip-if = toolkit == 'android' || toolkit == 'gonk'
-
-[test_parseDeclarations.js]
-[test_parseSingleValue.js]
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
index 79bf11a..6b23638 100644
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
@@ -42,16 +42,20 @@
   -  This label is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.label "Default color unit">
 
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.accesskey): This is the access
   -  key for a dropdown list that controls the default color unit used in the
   -  inspector. This is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.accesskey "U">
 
+<!-- LOCALIZATION NOTE (options.defaultColorUnit.authored): This is used in the
+  -  'Default color unit' dropdown list and is visible in the options panel. -->
+<!ENTITY options.defaultColorUnit.authored "As Authored">
+
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.hex): This is used in the
   -  'Default color unit' dropdown list and is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.hex "Hex">
 
 <!-- LOCALIZATION NOTE (options.defaultColorUnit.hsl): This is used in the
   -  'Default color unit' dropdown list and is visible in the options panel. -->
 <!ENTITY options.defaultColorUnit.hsl "HSL(A)">
 
diff --git a/toolkit/devtools/Loader.jsm b/toolkit/devtools/Loader.jsm
index 4c9e0cb..ed06db6 100644
--- a/toolkit/devtools/Loader.jsm
+++ b/toolkit/devtools/Loader.jsm
@@ -82,16 +82,18 @@ BuiltinProvider.prototype = {
         "devtools": "resource:///modules/devtools",
         "devtools/toolkit": "resource://gre/modules/devtools",
         "devtools/server": "resource://gre/modules/devtools/server",
         "devtools/toolkit/webconsole": "resource://gre/modules/devtools/toolkit/webconsole",
         "devtools/app-actor-front": "resource://gre/modules/devtools/app-actor-front.js",
         "devtools/styleinspector/css-logic": "resource://gre/modules/devtools/styleinspector/css-logic",
         "devtools/css-color": "resource://gre/modules/devtools/css-color",
         "devtools/output-parser": "resource://gre/modules/devtools/output-parser",
+        "devtools/css-parsing-utils": "resource://gre/modules/devtools/css-parsing-utils",
+        "devtools/css-tokenizer": "resource://gre/modules/devtools/css-tokenizer",
         "devtools/touch-events": "resource://gre/modules/devtools/touch-events",
         "devtools/client": "resource://gre/modules/devtools/client",
         "devtools/pretty-fast": "resource://gre/modules/devtools/pretty-fast.js",
         "devtools/jsbeautify": "resource://gre/modules/devtools/jsbeautify/beautify.js",
         "devtools/async-utils": "resource://gre/modules/devtools/async-utils",
         "devtools/content-observer": "resource://gre/modules/devtools/content-observer",
         "gcli": "resource://gre/modules/devtools/gcli",
         "projecteditor": "resource:///modules/devtools/projecteditor",
@@ -138,16 +140,18 @@ SrcdirProvider.prototype = {
     let devtoolsURI = this.fileURI(devtoolsDir);
     let toolkitURI = this.fileURI(toolkitDir);
     let serverURI = this.fileURI(OS.Path.join(toolkitDir, "server"));
     let webconsoleURI = this.fileURI(OS.Path.join(toolkitDir, "webconsole"));
     let appActorURI = this.fileURI(OS.Path.join(toolkitDir, "apps", "app-actor-front.js"));
     let cssLogicURI = this.fileURI(OS.Path.join(toolkitDir, "styleinspector", "css-logic"));
     let cssColorURI = this.fileURI(OS.Path.join(toolkitDir, "css-color"));
     let outputParserURI = this.fileURI(OS.Path.join(toolkitDir, "output-parser"));
+    let cssParsingUtilsURI = this.fileURI(OS.Path.join(toolkitDir, "css-parsing-utils"));
+    let cssTokenizerURI = this.fileURI(OS.Path.join(toolkitDir, "css-tokenizer"));
     let touchEventsURI = this.fileURI(OS.Path.join(toolkitDir, "touch-events"));
     let clientURI = this.fileURI(OS.Path.join(toolkitDir, "client"));
     let prettyFastURI = this.fileURI(OS.Path.join(toolkitDir), "pretty-fast.js");
     let jsBeautifyURI = this.fileURI(OS.Path.join(toolkitDir, "jsbeautify", "beautify.js"));
     let asyncUtilsURI = this.fileURI(OS.Path.join(toolkitDir), "async-utils.js");
     let contentObserverURI = this.fileURI(OS.Path.join(toolkitDir), "content-observer.js");
     let gcliURI = this.fileURI(OS.Path.join(toolkitDir, "gcli", "source", "lib", "gcli"));
     let projecteditorURI = this.fileURI(OS.Path.join(devtoolsDir, "projecteditor"));
@@ -164,16 +168,18 @@ SrcdirProvider.prototype = {
         "devtools": devtoolsURI,
         "devtools/toolkit": toolkitURI,
         "devtools/server": serverURI,
         "devtools/toolkit/webconsole": webconsoleURI,
         "devtools/app-actor-front": appActorURI,
         "devtools/styleinspector/css-logic": cssLogicURI,
         "devtools/css-color": cssColorURI,
         "devtools/output-parser": outputParserURI,
+        "devtools/css-parsing-utils": cssParsingUtilsURI,
+        "devtools/css-tokenizer": cssTokenizerURI,
         "devtools/touch-events": touchEventsURI,
         "devtools/client": clientURI,
         "devtools/pretty-fast": prettyFastURI,
         "devtools/jsbeautify": jsBeautifyURI,
         "devtools/async-utils": asyncUtilsURI,
         "devtools/content-observer": contentObserverURI,
         "gcli": gcliURI,
         "projecteditor": projecteditorURI,
diff --git a/toolkit/devtools/css-color.js b/toolkit/devtools/css-color.js
index 4cfabd6..62c4725 100644
--- a/toolkit/devtools/css-color.js
+++ b/toolkit/devtools/css-color.js
@@ -91,16 +91,17 @@ CssColor.COLORUNIT = {
   "hex": "hex",
   "name": "name",
   "rgb": "rgb",
   "hsl": "hsl"
 };
 
 CssColor.prototype = {
   authored: null,
+  original: null,
 
   get hasAlpha() {
     if (!this.valid) {
       return false;
     }
     return this._getRGBATuple().a !== 1;
   },
 
@@ -116,17 +117,17 @@ CssColor.prototype = {
       let tuple = this._getRGBATuple();
       return !(tuple.r || tuple.g || tuple.b || tuple.a);
     } catch(e) {
       return false;
     }
   },
 
   get specialValue() {
-    return SPECIALVALUES.has(this.authored) ? this.authored : null;
+    return SPECIALVALUES.has(this.original) ? this.original : null;
   },
 
   get name() {
     let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
     if (invalidOrSpecialValue !== false) {
       return invalidOrSpecialValue;
     }
 
@@ -177,63 +178,63 @@ CssColor.prototype = {
   get rgb() {
     let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
     if (invalidOrSpecialValue !== false) {
       return invalidOrSpecialValue;
     }
     if (!this.hasAlpha) {
       if (this.authored.startsWith("rgb(")) {
         // The color is valid and begins with rgb(. Return the authored value.
-        return this.authored;
+        return this.original;
       }
       let tuple = this._getRGBATuple();
       return "rgb(" + tuple.r + ", " + tuple.g + ", " + tuple.b + ")";
     }
     return this.rgba;
   },
 
   get rgba() {
     let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
     if (invalidOrSpecialValue !== false) {
       return invalidOrSpecialValue;
     }
     if (this.authored.startsWith("rgba(")) {
       // The color is valid and begins with rgba(. Return the authored value.
-        return this.authored;
+        return this.original;
     }
     let components = this._getRGBATuple();
     return "rgba(" + components.r + ", " +
                      components.g + ", " +
                      components.b + ", " +
                      components.a + ")";
   },
 
   get hsl() {
     let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
     if (invalidOrSpecialValue !== false) {
       return invalidOrSpecialValue;
     }
     if (this.authored.startsWith("hsl(")) {
       // The color is valid and begins with hsl(. Return the authored value.
-      return this.authored;
+      return this.original;
     }
     if (this.hasAlpha) {
       return this.hsla;
     }
     return this._hslNoAlpha();
   },
 
   get hsla() {
     let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
     if (invalidOrSpecialValue !== false) {
       return invalidOrSpecialValue;
     }
     if (this.authored.startsWith("hsla(")) {
       // The color is valid and begins with hsla(. Return the authored value.
-      return this.authored;
+      return this.original;
     }
     if (this.hasAlpha) {
       let a = this._getRGBATuple().a;
       return this._hslNoAlpha().replace("hsl", "hsla").replace(")", ", " + a + ")");
     }
     return this._hslNoAlpha().replace("hsl", "hsla").replace(")", ", 1)");
   },
 
@@ -261,30 +262,31 @@ CssColor.prototype = {
   /**
    * Change color
    *
    * @param  {String} color
    *         Any valid color string
    */
   newColor: function(color) {
     this.authored = color.toLowerCase();
+    this.original = color;
     return this;
   },
 
   /**
    * Return a string representing a color of type defined in COLOR_UNIT_PREF.
    */
   toString: function() {
     let color;
     let defaultUnit = Services.prefs.getCharPref(COLOR_UNIT_PREF);
     let unit = CssColor.COLORUNIT[defaultUnit];
 
     switch(unit) {
       case CssColor.COLORUNIT.authored:
-        color = this.authored;
+        color = this.original;
         break;
       case CssColor.COLORUNIT.hex:
         color = this.hex;
         break;
       case CssColor.COLORUNIT.hsl:
         color = this.hsl;
         break;
       case CssColor.COLORUNIT.name:
diff --git a/toolkit/devtools/css-parsing-utils.js b/toolkit/devtools/css-parsing-utils.js
new file mode 100644
index 0000000..d18c364
--- /dev/null
+++ b/toolkit/devtools/css-parsing-utils.js
@@ -0,0 +1,194 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ * This module contains various devtools css parsing helper functions.
+ * Import it like so:
+ *
+ * const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+ * const {parseDeclarations, parseSingleValue} = devtools.require("devtools/css-parsing-utils");
+ */
+
+const cssTokenizer = require("devtools/css-tokenizer");
+
+/**
+ * Returns an array of CSS declarations given an string.
+ * For example, parseDeclarations("width: 1px; height: 1px") would return
+ * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
+ *
+ * The input string is assumed to only contain declarations so { and } characters
+ * will be treated as part of either the property or value, depending where it's
+ * found.
+ *
+ * @param {string} inputString
+ *        An input string of CSS
+ * @return {Array} an array of objects with the following signature:
+ *         [{"name": string, "value": string, "priority": string}, ...]
+ */
+function parseDeclarations(inputString) {
+  let tokens = cssTokenizer(inputString);
+
+  let declarations = [{name: "", value: "", priority: ""}];
+
+  let current = "", hasBang = false, lastProp;
+  for (let token of tokens) {
+    lastProp = declarations[declarations.length - 1];
+
+    if (token.tokenType === ":") {
+      if (!lastProp.name) {
+        // Set the current declaration name if there's no name yet
+        lastProp.name = current.trim();
+        current = "";
+        hasBang = false;
+      } else {
+        // Otherwise, just append ':' to the current value (declaration value
+        // with colons)
+        current += ":";
+      }
+    } else if (token.tokenType === ";") {
+      lastProp.value = current.trim();
+      current = "";
+      hasBang = false;
+      declarations.push({name: "", value: "", priority: ""});
+    } else if (token.tokenType === "IDENT") {
+      if (token.value === "important" && hasBang) {
+        lastProp.priority = "important";
+        hasBang = false;
+      } else {
+        if (hasBang) {
+          current += "!";
+        }
+        current += token.value;
+      }
+    } else if (token.tokenType === "DELIM") {
+      if (token.value === "!") {
+        hasBang = true;
+      } else {
+        current += token.toSource();
+      }
+    } else if (token.tokenType !== "EOF") {
+      current += token.toSource();
+    }
+  }
+
+  // Handle whatever trailing properties or values might still be there
+  if (current) {
+    if (!lastProp.name) {
+      // Trailing property found, e.g. p1:v1;p2:v2;p3
+      lastProp.name = current.trim();
+    } else {
+      // Trailing value found, i.e. value without an ending ;
+      lastProp.value += current.trim();
+    }
+  }
+
+  // Remove declarations that have neither a name nor a value
+  declarations = declarations.filter(prop => prop.name || prop.value);
+
+  return declarations;
+};
+exports.parseDeclarations = parseDeclarations;
+
+/**
+ * Expects a single CSS value to be passed as the input and parses the value
+ * and priority.
+ *
+ * @param {string} value The value from the text editor.
+ * @return {object} an object with 'value' and 'priority' properties.
+ */
+function parseSingleValue(value) {
+  let declaration = parseDeclarations("a: " + value + ";")[0];
+  return {
+    value: declaration ? declaration.value : "",
+    priority: declaration ? declaration.priority : ""
+  };
+};
+exports.parseSingleValue = parseSingleValue;
+
+/**
+ * Get the text content of a rule given some CSS text, a line and a column
+ * Consider the following example:
+ * body {
+ *  color: red;
+ * }
+ * p {
+ *  line-height: 2em;
+ *  color: blue;
+ * }
+ * Calling the function with the whole text above and line=3 and column=0 would
+ * return "line-height: 2em; color: blue;"
+ * @param {String} text
+ * @param {Number} line (1-indexed)
+ * @param {Number} column (1-indexed)
+ * @return {String} The text content of the rule
+ */
+function getRuleText(text, line, column) {
+  if (typeof line === "undefined" || typeof column === "undefined") {
+    throw "Location information is missing";
+  }
+  let {start, end} = getRuleRange(text, line, column);
+  return text.substring(start, end);
+}
+exports.getRuleText = getRuleText;
+
+/**
+ * Given some css text and the line/column pair that corresponds to the position
+ * of a rule, return the {start, end} index range for the rule's text
+ * @param {String} text
+ * @param {Number} line (1-indexed)
+ * @param {Number} column (1-indexed)
+ * @return {Object} A {start, end} position object
+ */
+function getRuleRange(text, line, column) {
+  let start = locationToPosition(text, line, column);
+  start = text.indexOf("{", start) + 1;
+  let end = getRuleEndPosition(text, start);
+  return {start: start, end: end};
+}
+
+/**
+ * Get the position that corresponds to a line/column pair in a string
+ * @param {String} text
+ * @param {Number} line (1-indexed)
+ * @param {Number} column (1-indexed)
+ * @return {Number} the index in text that corresponds to line and column
+ */
+function locationToPosition(text, line, column) {
+  let lines = text.split("\n");
+  let linesAfter = lines.splice(line - 1);
+  let textBefore = lines.join("\n");
+  if (lines.length) {
+    textBefore += "\n";
+  }
+
+  return textBefore.length + column;
+}
+
+/**
+ * Given some css text and a start position, return the position where the current
+ * rule closes
+ * @param {String} text
+ * @param {Number} startPosition
+ * @param {Number} The position where the rule closes
+ */
+function getRuleEndPosition(text, startPosition) {
+  text = text.substring(startPosition);
+  let tokens = cssTokenizer(text, {loc: true});
+  let endLoc;
+
+  for (let token of tokens) {
+    if (token.tokenType === "}" || token.tokenType === "EOF") {
+      endLoc = token.loc.start;
+      break;
+    }
+  }
+
+  // cssTokenizer returns 0-indexed location information
+  let endPosition = locationToPosition(text, endLoc.line + 1, endLoc.column + 1);
+  return startPosition + endPosition - 1;
+}
diff --git a/toolkit/devtools/css-tokenizer.js b/toolkit/devtools/css-tokenizer.js
new file mode 100644
index 0000000..f2222ab
--- /dev/null
+++ b/toolkit/devtools/css-tokenizer.js
@@ -0,0 +1,1323 @@
+"use strict";
+
+(function (root, factory) {
+    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
+    // Rhino, and plain browser loading.
+    if (typeof define === 'function' && define.amd) {
+        define(['exports'], factory);
+    } else if (typeof exports !== 'undefined') {
+        factory(exports);
+    } else {
+        factory(root);
+    }
+}(this, function (exports) {
+
+function between(num, first, last) { return num >= first && num <= last; }
+function digit(code) { return between(code, 0x30,0x39); }
+function hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }
+function uppercaseletter(code) { return between(code, 0x41,0x5a); }
+function lowercaseletter(code) { return between(code, 0x61,0x7a); }
+function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
+function nonascii(code) { return code >= 0x80; }
+function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
+function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
+function nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }
+function newline(code) { return code == 0xa; }
+function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
+function astral(code) { return code > 0xffff; }
+
+var maximumallowedcodepoint = 0x10ffff;
+
+var InvalidCharacterError = function(message) {
+	this.message = message;
+};
+InvalidCharacterError.prototype = new Error;
+InvalidCharacterError.prototype.name = 'InvalidCharacterError';
+
+function preprocess(str) {
+	// Turn a string into an array of code points,
+	// following the preprocessing cleanup rules.
+	var codepoints = [];
+	for(var i = 0; i < str.length; i++) {
+		var code = str.charCodeAt(i);
+		if(code == 0xd && str.charCodeAt(i+1) == 0xa) {
+			code = 0xa; i++;
+		}
+		if(code == 0xd || code == 0xc) code = 0xa;
+		if(code === 0x0) code = 0xfffd;
+		if(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {
+			// Decode a surrogate pair into an astral codepoint.
+			var lead = code - 0xd800;
+			var trail = str.charCodeAt(i+1) - 0xdc00;
+			code = Math.pow(2, 20) + lead * Math.pow(2, 10) + trail;
+			i++;
+		}
+		codepoints.push(code);
+	}
+	return codepoints;
+}
+
+function stringFromCode(code) {
+	if(code <= 0xffff) return String.fromCharCode(code);
+	// Otherwise, encode astral char as surrogate pair.
+	code -= Math.pow(2, 20);
+	var lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;
+	var trail = code % Math.pow(2, 10) + 0xdc00;
+	return String.fromCharCode(lead) + String.fromCharCode(trail);
+}
+
+function tokenize(str, options) {
+	if (options === undefined) {
+		options = {loc: false};
+	}
+	str = preprocess(str);
+	var i = -1;
+	var tokens = [];
+	var code;
+
+	// Line number information.
+	var line = 0;
+	var column = 0;
+	// The only use of lastLineLength is in reconsume().
+	var lastLineLength = 0;
+	var incrLineno = function() {
+		line += 1;
+		lastLineLength = column;
+		column = 0;
+	};
+	var locStart = {line:line, column:column};
+
+	var codepoint = function(i) {
+		if(i >= str.length) {
+			return -1;
+		}
+		return str[i];
+	};
+	var next = function(num) {
+		if(num === undefined)
+			num = 1;
+		if(num > 3)
+			throw "Spec Error: no more than three codepoints of lookahead.";
+		return codepoint(i+num);
+	};
+	var consume = function(num) {
+		if(num === undefined)
+			num = 1;
+		while(num-- > 0) {
+			++i;
+			code = codepoint(i);
+			if(newline(code)) incrLineno();
+			else if (astral(code)) column += 2;
+			else column += num;
+		}
+		//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
+		return true;
+	};
+	var reconsume = function() {
+		i -= 1;
+		if (newline(code)) {
+			line -= 1;
+			column = lastLineLength;
+		} else if(astral(code)) {
+			column -= 2;
+		} else {
+			column -= 1;
+		}
+		return true;
+	};
+	var eof = function(codepoint) {
+		if(codepoint === undefined) codepoint = code;
+		return codepoint == -1;
+	};
+	var donothing = function() {};
+	var parseerror = function() { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");return true; };
+
+	var consumeAToken = function() {
+		consumeComments();
+		consume();
+		locStart.line = line;
+		locStart.column = column;
+		if(whitespace(code)) {
+			while(whitespace(next())) consume();
+			return new WhitespaceToken;
+		}
+		else if(code == 0x22) return consumeAStringToken();
+		else if(code == 0x23) {
+			if(namechar(next()) || areAValidEscape(next(1), next(2))) {
+				var token = new HashToken();
+				if(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = "id";
+				token.value = consumeAName();
+				return token;
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x24) {
+			if(next() == 0x3d) {
+				consume();
+				return new SuffixMatchToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x27) return consumeAStringToken();
+		else if(code == 0x28) return new OpenParenToken();
+		else if(code == 0x29) return new CloseParenToken();
+		else if(code == 0x2a) {
+			if(next() == 0x3d) {
+				consume();
+				return new SubstringMatchToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x2b) {
+			if(startsWithANumber()) {
+				reconsume();
+				return consumeANumericToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x2c) return new CommaToken();
+		else if(code == 0x2d) {
+			if(startsWithANumber()) {
+				reconsume();
+				return consumeANumericToken();
+			} else if(next(1) == 0x2d && next(2) == 0x3e) {
+				consume(2);
+				return new CDCToken();
+			} else if(startsWithAnIdentifier()) {
+				reconsume();
+				return consumeAnIdentlikeToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x2e) {
+			if(startsWithANumber()) {
+				reconsume();
+				return consumeANumericToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x3a) return new ColonToken;
+		else if(code == 0x3b) return new SemicolonToken;
+		else if(code == 0x3c) {
+			if(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
+				consume(3);
+				return new CDOToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x40) {
+			if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
+				return new AtKeywordToken(consumeAName());
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x5b) return new OpenSquareToken();
+		else if(code == 0x5c) {
+			if(startsWithAValidEscape()) {
+				reconsume();
+				return consumeAnIdentlikeToken();
+			} else {
+				parseerror();
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x5d) return new CloseSquareToken();
+		else if(code == 0x5e) {
+			if(next() == 0x3d) {
+				consume();
+				return new PrefixMatchToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x7b) return new OpenCurlyToken();
+		else if(code == 0x7c) {
+			if(next() == 0x3d) {
+				consume();
+				return new DashMatchToken();
+			} else if(next() == 0x7c) {
+				consume();
+				return new ColumnToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(code == 0x7d) return new CloseCurlyToken();
+		else if(code == 0x7e) {
+			if(next() == 0x3d) {
+				consume();
+				return new IncludeMatchToken();
+			} else {
+				return new DelimToken(code);
+			}
+		}
+		else if(digit(code)) {
+			reconsume();
+			return consumeANumericToken();
+		}
+		else if(namestartchar(code)) {
+			reconsume();
+			return consumeAnIdentlikeToken();
+		}
+		else if(eof()) return new EOFToken();
+		else return new DelimToken(code);
+	};
+
+	var consumeComments = function() {
+		while(next(1) == 0x2f && next(2) == 0x2a) {
+			consume(2);
+			while(true) {
+				consume();
+				if(code == 0x2a && next() == 0x2f) {
+					consume();
+					break;
+				} else if(eof()) {
+					parseerror();
+					return;
+				}
+			}
+		}
+	};
+
+	var consumeANumericToken = function() {
+		var num = consumeANumber();
+		if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
+			var token = new DimensionToken();
+			token.value = num.value;
+			token.repr = num.repr;
+			token.type = num.type;
+			token.unit = consumeAName();
+			return token;
+		} else if(next() == 0x25) {
+			consume();
+			var token = new PercentageToken();
+			token.value = num.value;
+			token.repr = num.repr;
+			return token;
+		} else {
+			var token = new NumberToken();
+			token.value = num.value;
+			token.repr = num.repr;
+			token.type = num.type;
+			return token;
+		}
+	};
+
+	var consumeAnIdentlikeToken = function() {
+		var str = consumeAName();
+		if(str.toLowerCase() == "url" && next() == 0x28) {
+			consume();
+			while(whitespace(next(1)) && whitespace(next(2))) consume();
+			if(next() == 0x22 || next() == 0x27) {
+				return new FunctionToken(str);
+			} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
+				return new FunctionToken(str);
+			} else {
+				return consumeAURLToken();
+			}
+		} else if(next() == 0x28) {
+			consume();
+			return new FunctionToken(str);
+		} else {
+			return new IdentToken(str);
+		}
+	};
+
+	var consumeAStringToken = function(endingCodePoint) {
+		if(endingCodePoint === undefined) endingCodePoint = code;
+		var string = "";
+		while(consume()) {
+			if(code == endingCodePoint || eof()) {
+				return new StringToken(string);
+			} else if(newline(code)) {
+				parseerror();
+				reconsume();
+				return new BadStringToken();
+			} else if(code == 0x5c) {
+				if(eof(next())) {
+					donothing();
+				} else if(newline(next())) {
+					consume();
+				} else {
+					string += stringFromCode(consumeEscape());
+				}
+			} else {
+				string += stringFromCode(code);
+			}
+		}
+	};
+
+	var consumeAURLToken = function() {
+		var token = new URLToken("");
+		while(whitespace(next())) consume();
+		if(eof(next())) return token;
+		while(consume()) {
+			if(code == 0x29 || eof()) {
+				return token;
+			} else if(whitespace(code)) {
+				while(whitespace(next())) consume();
+				if(next() == 0x29 || eof(next())) {
+					consume();
+					return token;
+				} else {
+					consumeTheRemnantsOfABadURL();
+					return new BadURLToken();
+				}
+			} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
+				parseerror();
+				consumeTheRemnantsOfABadURL();
+				return new BadURLToken();
+			} else if(code == 0x5c) {
+				if(startsWithAValidEscape()) {
+					token.value += stringFromCode(consumeEscape());
+				} else {
+					parseerror();
+					consumeTheRemnantsOfABadURL();
+					return new BadURLToken();
+				}
+			} else {
+				token.value += stringFromCode(code);
+			}
+		}
+	};
+
+	var consumeEscape = function() {
+		// Assume the the current character is the \
+		// and the next code point is not a newline.
+		consume();
+		if(hexdigit(code)) {
+			// Consume 1-6 hex digits
+			var digits = [code];
+			for(var total = 0; total < 5; total++) {
+				if(hexdigit(next())) {
+					consume();
+					digits.push(code);
+				} else {
+					break;
+				}
+			}
+			if(whitespace(next())) consume();
+			var value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);
+			if( value > maximumallowedcodepoint ) value = 0xfffd;
+			return value;
+		} else if(eof()) {
+			return 0xfffd;
+		} else {
+			return code;
+		}
+	};
+
+	var areAValidEscape = function(c1, c2) {
+		if(c1 != 0x5c) return false;
+		if(newline(c2)) return false;
+		return true;
+	};
+	var startsWithAValidEscape = function() {
+		return areAValidEscape(code, next());
+	};
+
+	var wouldStartAnIdentifier = function(c1, c2, c3) {
+		if(c1 == 0x2d) {
+			return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
+		} else if(namestartchar(c1)) {
+			return true;
+		} else if(c1 == 0x5c) {
+			return areAValidEscape(c1, c2);
+		} else {
+			return false;
+		}
+	};
+	var startsWithAnIdentifier = function() {
+		return wouldStartAnIdentifier(code, next(1), next(2));
+	};
+
+	var wouldStartANumber = function(c1, c2, c3) {
+		if(c1 == 0x2b || c1 == 0x2d) {
+			if(digit(c2)) return true;
+			if(c2 == 0x2e && digit(c3)) return true;
+			return false;
+		} else if(c1 == 0x2e) {
+			if(digit(c2)) return true;
+			return false;
+		} else if(digit(c1)) {
+			return true;
+		} else {
+			return false;
+		}
+	};
+	var startsWithANumber = function() {
+		return wouldStartANumber(code, next(1), next(2));
+	};
+
+	var consumeAName = function() {
+		var result = "";
+		while(consume()) {
+			if(namechar(code)) {
+				result += stringFromCode(code);
+			} else if(startsWithAValidEscape()) {
+				result += stringFromCode(consumeEscape());
+			} else {
+				reconsume();
+				return result;
+			}
+		}
+	};
+
+	var consumeANumber = function() {
+		var repr = [];
+		var type = "integer";
+		if(next() == 0x2b || next() == 0x2d) {
+			consume();
+			repr += stringFromCode(code);
+		}
+		while(digit(next())) {
+			consume();
+			repr += stringFromCode(code);
+		}
+		if(next(1) == 0x2e && digit(next(2))) {
+			consume();
+			repr += stringFromCode(code);
+			consume();
+			repr += stringFromCode(code);
+			type = "number";
+			while(digit(next())) {
+				consume();
+				repr += stringFromCode(code);
+			}
+		}
+		var c1 = next(1), c2 = next(2), c3 = next(3);
+		if((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
+			consume();
+			repr += stringFromCode(code);
+			consume();
+			repr += stringFromCode(code);
+			type = "number";
+			while(digit(next())) {
+				consume();
+				repr += stringFromCode(code);
+			}
+		} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
+			consume();
+			repr += stringFromCode(code);
+			consume();
+			repr += stringFromCode(code);
+			consume();
+			repr += stringFromCode(code);
+			type = "number";
+			while(digit(next())) {
+				consume();
+				repr += stringFromCode(code);
+			}
+		}
+		var value = convertAStringToANumber(repr);
+		return {type:type, value:value, repr:repr};
+	};
+
+	var convertAStringToANumber = function(string) {
+		// CSS's number rules are identical to JS, afaik.
+		return +string;
+	};
+
+	var consumeTheRemnantsOfABadURL = function() {
+		while(consume()) {
+			if(code == 0x2d || eof()) {
+				return;
+			} else if(startsWithAValidEscape()) {
+				consumeEscape();
+				donothing();
+			} else {
+				donothing();
+			}
+		}
+	};
+
+
+
+	var iterationCount = 0;
+	while(!eof(next())) {
+		var token = consumeAToken();
+		if (options.loc) {
+			token.loc = {};
+			token.loc.start = {line:locStart.line, column:locStart.column};
+			token.loc.end = {line:line, column:column};
+		}
+		tokens.push(token);
+		iterationCount++;
+		if(iterationCount > str.length*2) return "I'm infinite-looping!";
+	}
+	return tokens;
+}
+
+function CSSParserToken() { throw "Abstract Base Class"; }
+CSSParserToken.prototype.toJSON = function() {
+	return {token: this.tokenType};
+};
+CSSParserToken.prototype.toString = function() { return this.tokenType; };
+CSSParserToken.prototype.toSource = function() { return ''+this; };
+
+function BadStringToken() { return this; }
+BadStringToken.prototype = Object.create(CSSParserToken.prototype);
+BadStringToken.prototype.tokenType = "BADSTRING";
+
+function BadURLToken() { return this; }
+BadURLToken.prototype = Object.create(CSSParserToken.prototype);
+BadURLToken.prototype.tokenType = "BADURL";
+
+function WhitespaceToken() { return this; }
+WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
+WhitespaceToken.prototype.tokenType = "WHITESPACE";
+WhitespaceToken.prototype.toString = function() { return "WS"; };
+WhitespaceToken.prototype.toSource = function() { return " "; };
+
+function CDOToken() { return this; }
+CDOToken.prototype = Object.create(CSSParserToken.prototype);
+CDOToken.prototype.tokenType = "CDO";
+CDOToken.prototype.toSource = function() { return "<!--"; };
+
+function CDCToken() { return this; }
+CDCToken.prototype = Object.create(CSSParserToken.prototype);
+CDCToken.prototype.tokenType = "CDC";
+CDCToken.prototype.toSource = function() { return "-->"; };
+
+function ColonToken() { return this; }
+ColonToken.prototype = Object.create(CSSParserToken.prototype);
+ColonToken.prototype.tokenType = ":";
+
+function SemicolonToken() { return this; }
+SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
+SemicolonToken.prototype.tokenType = ";";
+
+function CommaToken() { return this; }
+CommaToken.prototype = Object.create(CSSParserToken.prototype);
+CommaToken.prototype.tokenType = ",";
+
+function GroupingToken() { throw "Abstract Base Class"; }
+GroupingToken.prototype = Object.create(CSSParserToken.prototype);
+
+function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
+OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
+OpenCurlyToken.prototype.tokenType = "{";
+
+function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
+CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
+CloseCurlyToken.prototype.tokenType = "}";
+
+function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
+OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
+OpenSquareToken.prototype.tokenType = "[";
+
+function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
+CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
+CloseSquareToken.prototype.tokenType = "]";
+
+function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
+OpenParenToken.prototype = Object.create(GroupingToken.prototype);
+OpenParenToken.prototype.tokenType = "(";
+
+function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
+CloseParenToken.prototype = Object.create(GroupingToken.prototype);
+CloseParenToken.prototype.tokenType = ")";
+
+function IncludeMatchToken() { return this; }
+IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
+IncludeMatchToken.prototype.tokenType = "~=";
+
+function DashMatchToken() { return this; }
+DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
+DashMatchToken.prototype.tokenType = "|=";
+
+function PrefixMatchToken() { return this; }
+PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
+PrefixMatchToken.prototype.tokenType = "^=";
+
+function SuffixMatchToken() { return this; }
+SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
+SuffixMatchToken.prototype.tokenType = "$=";
+
+function SubstringMatchToken() { return this; }
+SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
+SubstringMatchToken.prototype.tokenType = "*=";
+
+function ColumnToken() { return this; }
+ColumnToken.prototype = Object.create(CSSParserToken.prototype);
+ColumnToken.prototype.tokenType = "||";
+
+function EOFToken() { return this; }
+EOFToken.prototype = Object.create(CSSParserToken.prototype);
+EOFToken.prototype.tokenType = "EOF";
+EOFToken.prototype.toSource = function() { return ""; };
+
+function DelimToken(code) {
+	this.value = stringFromCode(code);
+	return this;
+}
+DelimToken.prototype = Object.create(CSSParserToken.prototype);
+DelimToken.prototype.tokenType = "DELIM";
+DelimToken.prototype.toString = function() { return "DELIM("+this.value+")"; };
+DelimToken.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.value = this.value;
+	return json;
+};
+DelimToken.prototype.toSource = function() {
+	if(this.value == "\\")
+		return "\\\n";
+	else
+		return this.value;
+};
+
+function StringValuedToken() { throw "Abstract Base Class"; }
+StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
+StringValuedToken.prototype.ASCIIMatch = function(str) {
+	return this.value.toLowerCase() == str.toLowerCase();
+};
+StringValuedToken.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.value = this.value;
+	return json;
+};
+
+function IdentToken(val) {
+	this.value = val;
+}
+IdentToken.prototype = Object.create(StringValuedToken.prototype);
+IdentToken.prototype.tokenType = "IDENT";
+IdentToken.prototype.toString = function() { return "IDENT("+this.value+")"; };
+IdentToken.prototype.toSource = function() {
+	return escapeIdent(this.value);
+};
+
+function FunctionToken(val) {
+	this.value = val;
+	this.mirror = ")";
+}
+FunctionToken.prototype = Object.create(StringValuedToken.prototype);
+FunctionToken.prototype.tokenType = "FUNCTION";
+FunctionToken.prototype.toString = function() { return "FUNCTION("+this.value+")"; };
+FunctionToken.prototype.toSource = function() {
+	return escapeIdent(this.value) + "(";
+};
+
+function AtKeywordToken(val) {
+	this.value = val;
+}
+AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
+AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
+AtKeywordToken.prototype.toString = function() { return "AT("+this.value+")"; };
+AtKeywordToken.prototype.toSource = function() {
+	return "@" + escapeIdent(this.value);
+};
+
+function HashToken(val) {
+	this.value = val;
+	this.type = "unrestricted";
+}
+HashToken.prototype = Object.create(StringValuedToken.prototype);
+HashToken.prototype.tokenType = "HASH";
+HashToken.prototype.toString = function() { return "HASH("+this.value+")"; };
+HashToken.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.value = this.value;
+	json.type = this.type;
+	return json;
+};
+HashToken.prototype.toSource = function() {
+	if(this.type == "id") {
+		return "#" + escapeIdent(this.value);
+	} else {
+		return "#" + escapeHash(this.value);
+	}
+};
+
+function StringToken(val) {
+	this.value = val;
+}
+StringToken.prototype = Object.create(StringValuedToken.prototype);
+StringToken.prototype.tokenType = "STRING";
+StringToken.prototype.toString = function() {
+	return '"' + escapeString(this.value) + '"';
+};
+
+function URLToken(val) {
+	this.value = val;
+}
+URLToken.prototype = Object.create(StringValuedToken.prototype);
+URLToken.prototype.tokenType = "URL";
+URLToken.prototype.toString = function() { return "URL("+this.value+")"; };
+URLToken.prototype.toSource = function() {
+	return 'url("' + escapeString(this.value) + '")';
+};
+
+function NumberToken() {
+	this.value = null;
+	this.type = "integer";
+	this.repr = "";
+}
+NumberToken.prototype = Object.create(CSSParserToken.prototype);
+NumberToken.prototype.tokenType = "NUMBER";
+NumberToken.prototype.toString = function() {
+	if(this.type == "integer")
+		return "INT("+this.value+")";
+	return "NUMBER("+this.value+")";
+};
+NumberToken.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.value = this.value;
+	json.type = this.type;
+	json.repr = this.repr;
+	return json;
+};
+NumberToken.prototype.toSource = function() { return this.repr; };
+
+function PercentageToken() {
+	this.value = null;
+	this.repr = "";
+}
+PercentageToken.prototype = Object.create(CSSParserToken.prototype);
+PercentageToken.prototype.tokenType = "PERCENTAGE";
+PercentageToken.prototype.toString = function() { return "PERCENTAGE("+this.value+")"; };
+PercentageToken.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.value = this.value;
+	json.repr = this.repr;
+	return json;
+};
+PercentageToken.prototype.toSource = function() { return this.repr + "%"; };
+
+function DimensionToken() {
+	this.value = null;
+	this.type = "integer";
+	this.repr = "";
+	this.unit = "";
+}
+DimensionToken.prototype = Object.create(CSSParserToken.prototype);
+DimensionToken.prototype.tokenType = "DIMENSION";
+DimensionToken.prototype.toString = function() { return "DIM("+this.value+","+this.unit+")"; };
+DimensionToken.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.value = this.value;
+	json.type = this.type;
+	json.repr = this.repr;
+	json.unit = this.unit;
+	return json;
+};
+DimensionToken.prototype.toSource = function() {
+	var source = this.repr;
+	var unit = escapeIdent(this.unit);
+	if(unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
+		// Unit is ambiguous with scinot
+		// Remove the leading "e", replace with escape.
+		unit = "\\65 " + unit.slice(1, unit.length);
+	}
+	return source+unit;
+};
+
+function escapeIdent(string) {
+	string = ''+string;
+	var result = '';
+	var firstcode = string.charCodeAt(0);
+	for(var i = 0; i < string.length; i++) {
+		var code = string.charCodeAt(i);
+		if(code === 0x0) {
+			throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
+		}
+
+		if(
+			between(code, 0x1, 0x1f) || code == 0x7f ||
+			(i === 0 && between(code, 0x30, 0x39)) ||
+			(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)
+		) {
+			result += '\\' + code.toString(16) + ' ';
+		} else if(
+			code >= 0x80 ||
+			code == 0x2d ||
+			code == 0x5f ||
+			between(code, 0x30, 0x39) ||
+			between(code, 0x41, 0x5a) ||
+			between(code, 0x61, 0x7a)
+		) {
+			result += string[i];
+		} else {
+			result += '\\' + string[i];
+		}
+	}
+	return result;
+}
+
+function escapeHash(string) {
+	// Escapes the contents of "unrestricted"-type hash tokens.
+	// Won't preserve the ID-ness of "id"-type hash tokens;
+	// use escapeIdent() for that.
+	string = ''+string;
+	var result = '';
+	for(var i = 0; i < string.length; i++) {
+		var code = string.charCodeAt(i);
+		if(code === 0x0) {
+			throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
+		}
+
+		if(
+			code >= 0x80 ||
+			code == 0x2d ||
+			code == 0x5f ||
+			between(code, 0x30, 0x39) ||
+			between(code, 0x41, 0x5a) ||
+			between(code, 0x61, 0x7a)
+		) {
+			result += string[i];
+		} else {
+			result += '\\' + code.toString(16) + ' ';
+		}
+	}
+	return result;
+}
+
+function escapeString(string) {
+	string = ''+string;
+	var result = '';
+	for(var i = 0; i < string.length; i++) {
+		var code = string.charCodeAt(i);
+
+		if(code === 0x0) {
+			throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
+		}
+
+		if(between(code, 0x1, 0x1f) || code == 0x7f) {
+			result += '\\' + code.toString(16) + ' ';
+		} else if(code == 0x22 || code == 0x5c) {
+			result += '\\' + string[i];
+		} else {
+			result += string[i];
+		}
+	}
+	return result;
+}
+
+// Exportation.
+exports.tokenize = tokenize;
+exports.IdentToken = IdentToken;
+exports.FunctionToken = FunctionToken;
+exports.AtKeywordToken = AtKeywordToken;
+exports.HashToken = HashToken;
+exports.StringToken = StringToken;
+exports.BadStringToken = BadStringToken;
+exports.URLToken = URLToken;
+exports.BadURLToken = BadURLToken;
+exports.DelimToken = DelimToken;
+exports.NumberToken = NumberToken;
+exports.PercentageToken = PercentageToken;
+exports.DimensionToken = DimensionToken;
+exports.IncludeMatchToken = IncludeMatchToken;
+exports.DashMatchToken = DashMatchToken;
+exports.PrefixMatchToken = PrefixMatchToken;
+exports.SuffixMatchToken = SuffixMatchToken;
+exports.SubstringMatchToken = SubstringMatchToken;
+exports.ColumnToken = ColumnToken;
+exports.WhitespaceToken = WhitespaceToken;
+exports.CDOToken = CDOToken;
+exports.CDCToken = CDCToken;
+exports.ColonToken = ColonToken;
+exports.SemicolonToken = SemicolonToken;
+exports.CommaToken = CommaToken;
+exports.OpenParenToken = OpenParenToken;
+exports.CloseParenToken = CloseParenToken;
+exports.OpenSquareToken = OpenSquareToken;
+exports.CloseSquareToken = CloseSquareToken;
+exports.OpenCurlyToken = OpenCurlyToken;
+exports.CloseCurlyToken = CloseCurlyToken;
+exports.EOFToken = EOFToken;
+exports.CSSParserToken = CSSParserToken;
+exports.GroupingToken = GroupingToken;
+
+function TokenStream(tokens) {
+	// Assume that tokens is an array.
+	this.tokens = tokens;
+	this.i = -1;
+}
+TokenStream.prototype.tokenAt = function(i) {
+	if(i < this.tokens.length)
+		return this.tokens[i];
+	return new EOFToken();
+};
+TokenStream.prototype.consume = function(num) {
+	if(num === undefined) num = 1;
+	this.i += num;
+	this.token = this.tokenAt(this.i);
+	//console.log(this.i, this.token);
+	return true;
+};
+TokenStream.prototype.next = function() {
+	return this.tokenAt(this.i+1);
+};
+TokenStream.prototype.reconsume = function() {
+	this.i--;
+};
+
+function parseerror(s, msg) {
+	console.log("Parse error at token " + s.i + ": " + s.token + ".\n" + msg);
+	return true;
+}
+function donothing(){ return true; }
+
+function consumeAListOfRules(s, topLevel) {
+	var rules = [];
+	var rule;
+	while(s.consume()) {
+		if(s.token instanceof WhitespaceToken) {
+			continue;
+		} else if(s.token instanceof EOFToken) {
+			return rules;
+		} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {
+			if(topLevel == "top-level") continue;
+			s.reconsume();
+			if(rule = consumeAQualifiedRule(s)) rules.push(rule);
+		} else if(s.token instanceof AtKeywordToken) {
+			s.reconsume();
+			if(rule = consumeAnAtRule(s)) rules.push(rule);
+		} else {
+			s.reconsume();
+			if(rule = consumeAQualifiedRule(s)) rules.push(rule);
+		}
+	}
+}
+
+function consumeAnAtRule(s) {
+	s.consume();
+	var rule = new AtRule(s.token.value);
+	while(s.consume()) {
+		if(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {
+			return rule;
+		} else if(s.token instanceof OpenCurlyToken) {
+			rule.value = consumeASimpleBlock(s);
+			return rule;
+		} else if(s.token instanceof SimpleBlock && s.token.name == "{") {
+			rule.value = s.token;
+			return rule;
+		} else {
+			s.reconsume();
+			rule.prelude.push(consumeAComponentValue(s));
+		}
+	}
+}
+
+function consumeAQualifiedRule(s) {
+	var rule = new QualifiedRule();
+	while(s.consume()) {
+		if(s.token instanceof EOFToken) {
+			parseerror(s, "Hit EOF when trying to parse the prelude of a qualified rule.");
+			return;
+		} else if(s.token instanceof OpenCurlyToken) {
+			rule.value = consumeASimpleBlock(s);
+			return rule;
+		} else if(s.token instanceof SimpleBlock && s.token.name == "{") {
+			rule.value = s.token;
+			return rule;
+		} else {
+			s.reconsume();
+			rule.prelude.push(consumeAComponentValue(s));
+		}
+	}
+}
+
+function consumeAListOfDeclarations(s) {
+	var decls = [];
+	while(s.consume()) {
+		if(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {
+			donothing();
+		} else if(s.token instanceof EOFToken) {
+			return decls;
+		} else if(s.token instanceof AtKeywordToken) {
+			s.reconsume();
+			decls.push(consumeAnAtRule(s));
+		} else if(s.token instanceof IdentToken) {
+			var temp = [s.token];
+			while(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))
+				temp.push(consumeAComponentValue(s));
+			var decl;
+			if(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);
+		} else {
+			parseerror(s);
+			s.reconsume();
+			while(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))
+				consumeAComponentValue(s);
+		}
+	}
+}
+
+function consumeADeclaration(s) {
+	// Assumes that the next input token will be an ident token.
+	s.consume();
+	var decl = new Declaration(s.token.value);
+	while(s.next() instanceof WhitespaceToken) s.consume();
+	if(!(s.next() instanceof ColonToken)) {
+		parseerror(s);
+		return;
+	} else {
+		s.consume();
+	}
+	while(!(s.next() instanceof EOFToken)) {
+		decl.value.push(consumeAComponentValue(s));
+	}
+	var foundImportant = false;
+	for(var i = decl.value.length - 1; i >= 0; i--) {
+		if(decl.value[i] instanceof WhitespaceToken) {
+			continue;
+		} else if(decl.value[i] instanceof IdentToken && decl.value[i].ASCIIMatch("important")) {
+			foundImportant = true;
+		} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == "!") {
+			decl.value.splice(i, decl.value.length);
+			decl.important = true;
+			break;
+		} else {
+			break;
+		}
+	}
+	return decl;
+}
+
+function consumeAComponentValue(s) {
+	s.consume();
+	if(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)
+		return consumeASimpleBlock(s);
+	if(s.token instanceof FunctionToken)
+		return consumeAFunction(s);
+	return s.token;
+}
+
+function consumeASimpleBlock(s) {
+	var mirror = s.token.mirror;
+	var block = new SimpleBlock(s.token.value);
+	while(s.consume()) {
+		if(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))
+			return block;
+		else {
+			s.reconsume();
+			block.value.push(consumeAComponentValue(s));
+		}
+	}
+}
+
+function consumeAFunction(s) {
+	var func = new Func(s.token.value);
+	while(s.consume()) {
+		if(s.token instanceof EOFToken || s.token instanceof CloseParenToken)
+			return func;
+		else {
+			s.reconsume();
+			func.value.push(consumeAComponentValue(s));
+		}
+	}
+}
+
+function normalizeInput(input) {
+	if(typeof input == "string")
+		return new TokenStream(tokenize(input));
+	if(input instanceof TokenStream)
+		return input;
+	if(input.length !== undefined)
+		return new TokenStream(input);
+	else throw SyntaxError(input);
+}
+
+function parseAStylesheet(s) {
+	s = normalizeInput(s);
+	var sheet = new Stylesheet();
+	sheet.value = consumeAListOfRules(s, "top-level");
+	return sheet;
+}
+
+function parseAListOfRules(s) {
+	s = normalizeInput(s);
+	return consumeAListOfRules(s);
+}
+
+function parseARule(s) {
+	s = normalizeInput(s);
+	while(s.next() instanceof WhitespaceToken) s.consume();
+	if(s.next() instanceof EOFToken) throw SyntaxError();
+	var rule;
+	if(s.next() instanceof AtKeywordToken) {
+		rule = consumeAnAtRule(s);
+	} else {
+		rule = consumeAQualifiedRule(s);
+		if(!rule) throw SyntaxError();
+	}
+	while(s.next() instanceof WhitespaceToken) s.consume();
+	if(s.next() instanceof EOFToken)
+		return rule;
+	throw SyntaxError();
+}
+
+function parseADeclaration(s) {
+	s = normalizeInput(s);
+	while(s.next() instanceof WhitespaceToken) s.consume();
+	if(!(s.next() instanceof IdentToken)) throw SyntaxError();
+	var decl = consumeADeclaration(s);
+	if(decl)
+		return decl;
+	else
+		throw SyntaxError();
+}
+
+function parseAListOfDeclarations(s) {
+	s = normalizeInput(s);
+	return consumeAListOfDeclarations(s);
+}
+
+function parseAComponentValue(s) {
+	s = normalizeInput(s);
+	while(s.next() instanceof WhitespaceToken) s.consume();
+	if(s.next() instanceof EOFToken) throw SyntaxError();
+	var val = consumeAComponentValue(s);
+	if(!val) throw SyntaxError();
+	while(s.next() instanceof WhitespaceToken) s.consume();
+	if(s.next() instanceof EOFToken)
+		return val;
+	throw SyntaxError();
+}
+
+function parseAListOfComponentValues(s) {
+	s = normalizeInput(s);
+	var vals = [];
+	while(true) {
+		var val = consumeAComponentValue(s);
+		if(val instanceof EOFToken)
+			return vals;
+		else
+			vals.push(val);
+	}
+}
+
+function parseACommaSeparatedListOfComponentValues(s) {
+	s = normalizeInput(s);
+	var listOfCVLs = [];
+	while(true) {
+		var vals = [];
+		while(true) {
+			var val = consumeAComponentValue(s);
+			if(val instanceof EOFToken) {
+				listOfCVLs.push(vals);
+				return listOfCVLs;
+			} else if(val instanceof CommaToken) {
+				listOfCVLs.push(vals);
+				break;
+			} else {
+				vals.push(val);
+			}
+		}
+	}
+}
+
+
+function CSSParserRule() { throw "Abstract Base Class"; }
+CSSParserRule.prototype.toString = function(indent) {
+	return JSON.stringify(this,null,indent);
+};
+CSSParserRule.prototype.toJSON = function() {
+	return {type:this.type, value:this.value};
+};
+
+function Stylesheet() {
+	this.value = [];
+	return this;
+}
+Stylesheet.prototype = Object.create(CSSParserRule.prototype);
+Stylesheet.prototype.type = "STYLESHEET";
+
+function AtRule(name) {
+	this.name = name;
+	this.prelude = [];
+	this.value = null;
+	return this;
+}
+AtRule.prototype = Object.create(CSSParserRule.prototype);
+AtRule.prototype.type = "AT-RULE";
+AtRule.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.name = this.name;
+	json.prelude = this.prelude;
+	return json;
+};
+
+function QualifiedRule() {
+	this.prelude = [];
+	this.value = [];
+	return this;
+}
+QualifiedRule.prototype = Object.create(CSSParserRule.prototype);
+QualifiedRule.prototype.type = "QUALIFIED-RULE";
+QualifiedRule.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.prelude = this.prelude;
+	return json;
+};
+
+function Declaration(name) {
+	this.name = name;
+	this.value = [];
+	this.important = false;
+	return this;
+}
+Declaration.prototype = Object.create(CSSParserRule.prototype);
+Declaration.prototype.type = "DECLARATION";
+Declaration.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.name = this.name;
+	json.important = this.important;
+	return json;
+};
+
+function SimpleBlock(type) {
+	this.name = type;
+	this.value = [];
+	return this;
+}
+SimpleBlock.prototype = Object.create(CSSParserRule.prototype);
+SimpleBlock.prototype.type = "BLOCK";
+SimpleBlock.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.name = this.name;
+	return json;
+};
+
+function Func(name) {
+	this.name = name;
+	this.value = [];
+	return this;
+}
+Func.prototype = Object.create(CSSParserRule.prototype);
+Func.prototype.type = "FUNCTION";
+Func.prototype.toJSON = function() {
+	var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
+	json.name = this.name;
+	return json;
+};
+
+// Exportation.
+exports.CSSParserRule = CSSParserRule;
+exports.Stylesheet = Stylesheet;
+exports.AtRule = AtRule;
+exports.QualifiedRule = QualifiedRule;
+exports.Declaration = Declaration;
+exports.SimpleBlock = SimpleBlock;
+exports.Func = Func;
+exports.parseAStylesheet = parseAStylesheet;
+exports.parseAListOfRules = parseAListOfRules;
+exports.parseARule = parseARule;
+exports.parseADeclaration = parseADeclaration;
+exports.parseAListOfDeclarations = parseAListOfDeclarations;
+exports.parseAComponentValue = parseAComponentValue;
+exports.parseAListOfComponentValues = parseAListOfComponentValues;
+exports.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;
+
+  module.exports = tokenize;
+
+}));
diff --git a/toolkit/devtools/moz.build b/toolkit/devtools/moz.build
index bed237a..70dda99 100644
--- a/toolkit/devtools/moz.build
+++ b/toolkit/devtools/moz.build
@@ -25,16 +25,18 @@ DIRS += [
 
 MOCHITEST_CHROME_MANIFESTS += ['tests/mochitest/chrome.ini']
 XPCSHELL_TESTS_MANIFESTS += ['tests/unit/xpcshell.ini']
 
 EXTRA_JS_MODULES.devtools += [
     'async-utils.js',
     'content-observer.js',
     'css-color.js',
+    'css-parsing-utils.js',
+    'css-tokenizer.js',
     'deprecated-sync-thenables.js',
     'DevToolsUtils.js',
     'event-emitter.js',
     'event-parsers.js',
     'output-parser.js',
     'path.js',
     'touch-events.js',
     'worker-loader.js',
diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
index 2094d1c..3e67d83 100644
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -8,23 +8,25 @@ const {Cc, Ci, Cu} = require("chrome");
 const Services = require("Services");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method, RetVal, types} = protocol;
 const events = require("sdk/event/core");
 const object = require("sdk/util/object");
 const {Class} = require("sdk/core/heritage");
 const {LongStringActor} = require("devtools/server/actors/string");
+const {getRuleText} = require("devtools/css-parsing-utils");
 
 
 // This will add the "stylesheet" actor type for protocol.js to recognize
 require("devtools/server/actors/stylesheets");
 
 loader.lazyGetter(this, "CssLogic", () => require("devtools/styleinspector/css-logic").CssLogic);
 loader.lazyGetter(this, "DOMUtils", () => Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils));
+loader.lazyImporter(this, "Task", "resource://gre/modules/Task.jsm");
 
 // The PageStyle actor flattens the DOM CSS objects a little bit, merging
 // Rules and their Styles into one actor.  For elements (which have a style
 // but no associated rule) we fake a rule with the following style id.
 const ELEMENT_STYLE = 100;
 exports.ELEMENT_STYLE = ELEMENT_STYLE;
 
 const PSEUDO_ELEMENTS = [":first-line", ":first-letter", ":before", ":after", ":-moz-selection"];
@@ -471,17 +473,17 @@ var PageStyleActor = protocol.ActorClass({
       }
       result += ".style"
     }
     return result;
   },
 
   /**
    * Get the set of styles that apply to a given node.
-   * @param NodeActor node
+   * @param {NodeActor} node
    * @param object options
    *   `filter`: A string filter that affects the "matched" handling.
    *     'user': Include properties from user style sheets.
    *     'ua': Include properties from user and user-agent sheets.
    *     Default value is 'ua'
    *   `inherited`: Include styles inherited from parent nodes.
    *   `matchedSeletors`: Include an array of specific selectors that
    *     caused this rule to match its node.
@@ -640,17 +642,17 @@ var PageStyleActor = protocol.ActorClass({
    *   List of appliedstyle objects that lists the rules that apply to the
    *   node. If adding a new rule to the stylesheet, only the new rule entry
    *   is provided and only the style properties that apply to the new
    *   rule is fetched.
    * @returns Object containing the list of rule entries, rule actors and
    *   stylesheet actors that applies to the given node and its associated
    *   rules.
    */
-  getAppliedProps: function(node, entries, options) {
+  getAppliedProps: Task.async(function*(node, entries, options) {
     if (options.inherited) {
       let parent = this.walker.parentNode(node);
       while (parent && parent.rawNode.nodeType != Ci.nsIDOMNode.DOCUMENT_NODE) {
         entries = entries.concat(this._getAllElementRules(parent, parent, options));
         parent = this.walker.parentNode(parent);
       }
     }
 
@@ -696,22 +698,26 @@ var PageStyleActor = protocol.ActorClass({
       }
     }
 
     let rules = new Set;
     let sheets = new Set;
     entries.forEach(entry => rules.add(entry.rule));
     this.expandSets(rules, sheets);
 
+    for (let rule of rules) {
+      yield rule.getAuthoredCssText();
+    }
+
     return {
       entries: entries,
       rules: [...rules],
       sheets: [...sheets]
     }
-  },
+  }),
 
   /**
    * Expand Sets of rules and sheets to include all parent rules and sheets.
    */
   expandSets: function(ruleSet, sheetSet) {
     // Sets include new items in their iteration
     for (let rule of ruleSet) {
       if (rule.rawRule.parentRule) {
@@ -935,22 +941,29 @@ var StyleRuleActor = protocol.ActorClass({
   initialize: function(pageStyle, item) {
     protocol.Actor.prototype.initialize.call(this, null);
     this.pageStyle = pageStyle;
     this.rawStyle = item.style;
 
     if (item instanceof (Ci.nsIDOMCSSRule)) {
       this.type = item.type;
       this.rawRule = item;
-      if ((this.rawRule instanceof Ci.nsIDOMCSSStyleRule ||
-           this.rawRule instanceof Ci.nsIDOMMozCSSKeyframeRule) &&
-           this.rawRule.parentStyleSheet) {
-        this.line = DOMUtils.getRuleLine(this.rawRule);
-        this.column = DOMUtils.getRuleColumn(this.rawRule);
-      }
+// XXX: make sure _getRuleLocation handles keyframes and other rules
+// <<<<<<<
+//       if ((this.rawRule instanceof Ci.nsIDOMCSSStyleRule ||
+//            this.rawRule instanceof Ci.nsIDOMMozCSSKeyframeRule) &&
+//            this.rawRule.parentStyleSheet) {
+//         this.line = DOMUtils.getRuleLine(this.rawRule);
+// |||||||
+//       if (this.rawRule instanceof Ci.nsIDOMCSSStyleRule && this.rawRule.parentStyleSheet) {
+//         this.line = DOMUtils.getRuleLine(this.rawRule);
+// =======
+//       this._getRuleLocation();
+// >>>>>>>
+      this._getRuleLocation();
     } else {
       // Fake a rule
       this.type = ELEMENT_STYLE;
       this.rawNode = item;
       this.rawRule = {
         style: item.style,
         toString: function() "[element rule " + this.style + "]"
       }
@@ -995,16 +1008,19 @@ var StyleRuleActor = protocol.ActorClass({
     if (this.rawRule.parentStyleSheet) {
       form.parentStyleSheet = this.pageStyle._sheetRef(this.rawRule.parentStyleSheet).actorID;
     }
 
     switch (this.type) {
       case Ci.nsIDOMCSSRule.STYLE_RULE:
         form.selectors = CssLogic.getSelectors(this.rawRule);
         form.cssText = this.rawStyle.cssText || "";
+        if (this.authoredText) {
+          form.cssText = this.authoredText;
+        }
         break;
       case ELEMENT_STYLE:
         // Elements don't have a parent stylesheet, and therefore
         // don't have an associated URI.  Provide a URI for
         // those.
         form.href = this.rawNode.ownerDocument.location.href;
         form.cssText = this.rawStyle.cssText || "";
         break;
@@ -1029,17 +1045,75 @@ var StyleRuleActor = protocol.ActorClass({
         form.keyText = this.rawRule.keyText || "";
         break;
     }
 
     return form;
   },
 
   /**
-   * Modify a rule's properties.  Passed an array of modifications:
+   * If the rule is really a rule and is within a stylesheet, then retrieve its
+   * line/column location information and store it on the object.
+   * Note that for inline <style> sheets, the line returned by DOMUtils is the
+   * one relative to the container HTML document, so for now, we calculate the
+   * offset manually to get the line number relative to the <style> tag
+   */
+  _getRuleLocation: function() {
+    if (!(this.rawRule instanceof Ci.nsIDOMCSSStyleRule) ||
+        !this.rawRule.parentStyleSheet) {
+      return;
+    }
+
+    this.line = DOMUtils.getRuleLine(this.rawRule);
+    this.column = DOMUtils.getRuleColumn(this.rawRule);
+
+    let sheet = this.rawRule.parentStyleSheet;
+    if (sheet.ownerNode && sheet.ownerNode.localName === "style") {
+       // Inline sheet, line info is going to be wrong.
+       // Get the location of the first { to know the line nb of the first rule,
+       // relative to this sheet, to get the offset
+       let text = sheet.ownerNode.textContent;
+       // Hacky for now, because this will fail if { appears in a comment before
+       // but better than nothing, and faster than parsing the whole text
+       let start = text.substring(0, text.indexOf("{"));
+       let relativeStartLine = start.split("\n").length;
+       let absoluteStartLine = DOMUtils.getRuleLine(sheet.cssRules[0]);
+       let offset = absoluteStartLine - relativeStartLine;
+       this.line -= offset;
+    }
+  },
+
+  /**
+   * While the actor form contains a cssText property that corresponds to the
+   * applied css declarations, this method returns the authored css declarations
+   * instead.
+   */
+  getAuthoredCssText: method(Task.async(function*() {
+    if (this.type !== Ci.nsIDOMCSSRule.STYLE_RULE || !this.rawRule.parentStyleSheet) {
+      return "";
+    }
+
+    if (this.authoredText) {
+      return this.authoredText;
+    }
+
+    let parentStyleSheet = this.pageStyle._sheetRef(this.rawRule.parentStyleSheet);
+    let {str: cssText} = yield parentStyleSheet.getText();
+    cssText = getRuleText(cssText, this.line, this.column);
+
+    // Cache the result on the rule actor to avoid parsing again next time
+    return this.authoredText = cssText.replace(/\n/g, "").trim();
+  }), {
+    response: {
+      text: RetVal("string")
+    }
+  }),
+
+  /**
+   * Modify a rule's properties. Passed an array of modifications:
    * {
    *   type: "set",
    *   name: <string>,
    *   value: <string>,
    *   priority: <optional string>
    * }
    *  or
    * {
diff --git a/toolkit/devtools/tests/unit/test_getRuleText.js b/toolkit/devtools/tests/unit/test_getRuleText.js
new file mode 100644
index 0000000..41fc67b
--- /dev/null
+++ b/toolkit/devtools/tests/unit/test_getRuleText.js
@@ -0,0 +1,127 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+const {getRuleText} = devtools.require("devtools/css-parsing-utils");
+
+const TEST_DATA = [
+  {
+    desc: "Empty input",
+    input: "",
+    line: 1,
+    column: 1,
+    expected: ""
+  },
+  {
+    desc: "Simplest test case",
+    input: "#id{color:red;background:yellow;}",
+    line: 1,
+    column: 1,
+    expected: "color:red;background:yellow;"
+  },
+  {
+    desc: "Multiple rules test case",
+    input: "#id{color:red;background:yellow;}.class-one .class-two { position:absolute; line-height: 45px}",
+    line: 1,
+    column: 34,
+    expected: " position:absolute; line-height: 45px"
+  },
+  {
+    desc: "Unclosed rule",
+    input: "#id{color:red;background:yellow;",
+    line: 1,
+    column: 1,
+    expected: "color:red;background:yellow;"
+  },
+  {
+    desc: "Null input",
+    input: null,
+    line: 1,
+    column: 1,
+    throws: true
+  },
+  {
+    desc: "Missing loc",
+    input: "#id{color:red;background:yellow;}",
+    throws: true
+  },
+  {
+    desc: "Multi-lines CSS",
+    input: [
+      "/* this is a multi line css */",
+      "body {",
+      "  color: green;",
+      "  background-repeat: no-repeat",
+      "}",
+      " /*something else here",
+      "* {",
+      "  color: purple;",
+      "}"
+    ].join("\n"),
+    line: 7,
+    column: 1,
+    expected: "\n  color: purple;\n"
+  },
+  {
+    desc: "Multi-lines CSS and multi-line rule",
+    input: [
+      "/* ",
+       "* some comments",
+       "*/",
+      "",
+      "body {",
+      "    margin: 0;",
+      "    padding: 15px 15px 2px 15px;",
+      "    color: red;",
+      "}",
+      "",
+      "#header .btn, #header .txt {",
+      "    font-size: 100%;",
+      "}",
+      "",
+      "#header #information {",
+      "    color: #dddddd;",
+      "    font-size: small;",
+      "}",
+    ].join("\n"),
+    line: 5,
+    column: 1,
+    expected: "\n    margin: 0;\n    padding: 15px 15px 2px 15px;\n    color: red;\n"
+  },
+  {
+    desc: "Content string containing a } character",
+    input: "   #id{border:1px solid red;content: '}';color:red;}",
+    line: 1,
+    column: 4,
+    expected: "border:1px solid red;content: '}';color:red;"
+  },
+];
+
+function run_test() {
+  for (let test of TEST_DATA) {
+    do_print("Starting test: " + test.desc);
+    do_print("Input string " + test.input);
+    let output;
+    try {
+      output = getRuleText(test.input, test.line, test.column);
+      if (test.throws) {
+        do_print("Test should have thrown");
+        do_check_true(false);
+      }
+    } catch (e) {
+      do_print("getRuleText threw an exception with the given input string");
+      if (test.throws) {
+        do_print("Exception expected");
+        do_check_true(true);
+      } else {
+        do_print("Exception unexpected\n" + e);
+        do_check_true(false);
+      }
+    }
+    if (output) {
+      do_check_eq(output, test.expected);
+    }
+  }
+}
diff --git a/browser/devtools/styleinspector/test/unit/test_parseDeclarations.js b/toolkit/devtools/tests/unit/test_parseDeclarations.js
similarity index 100%
rename from browser/devtools/styleinspector/test/unit/test_parseDeclarations.js
rename to toolkit/devtools/tests/unit/test_parseDeclarations.js
diff --git a/toolkit/devtools/tests/unit/test_parseSingleValue.js b/toolkit/devtools/tests/unit/test_parseSingleValue.js
new file mode 100644
index 0000000..ae22904
--- /dev/null
+++ b/toolkit/devtools/tests/unit/test_parseSingleValue.js
@@ -0,0 +1,75 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+const {parseSingleValue} = devtools.require("devtools/css-parsing-utils");
+
+const TEST_DATA = [
+  {input: null, throws: true},
+  {input: undefined, throws: true},
+  {input: "", expected: {value: "", priority: ""}},
+  {input: "  \t \t \n\n  ", expected: {value: "", priority: ""}},
+  {input: "blue", expected: {value: "blue", priority: ""}},
+  {input: "blue !important", expected: {value: "blue", priority: "important"}},
+  {input: "blue!important", expected: {value: "blue", priority: "important"}},
+  {input: "blue ! important", expected: {value: "blue", priority: "important"}},
+  {input: "blue !  important", expected: {value: "blue", priority: "important"}},
+  {input: "blue !", expected: {value: "blue", priority: ""}},
+  {input: "blue !mportant", expected: {value: "blue !mportant", priority: ""}},
+  {input: "  blue   !important ", expected: {value: "blue", priority: "important"}},
+  {
+    input: "url(\"http://url.com/whyWouldYouDoThat!important.png\") !important",
+    expected: {
+      value: "url(\"http://url.com/whyWouldYouDoThat!important.png\")",
+      priority: "important"
+    }
+  },
+  {
+    input: "url(\"http://url.com/whyWouldYouDoThat!important.png\")",
+    expected: {
+      value: "url(\"http://url.com/whyWouldYouDoThat!important.png\")",
+      priority: ""
+    }
+  },
+  {
+    input: "\"content!important\" !important",
+    expected: {
+      value: "\"content!important\"",
+      priority: "important"
+    }
+  },
+  {
+    input: "\"content!important\"",
+    expected: {
+      value: "\"content!important\"",
+      priority: ""
+    }
+  }
+];
+
+function run_test() {
+  for (let test of TEST_DATA) {
+    do_print("Test input value " + test.input);
+    try {
+      let output = parseSingleValue(test.input);
+      assertOutput(output, test.expected);
+    } catch (e) {
+      do_print("parseSingleValue threw an exception with the given input value");
+      if (test.throws) {
+        do_print("Exception expected");
+        do_check_true(true);
+      } else {
+        do_print("Exception unexpected\n" + e);
+        do_check_true(false);
+      }
+    }
+  }
+}
+
+function assertOutput(actual, expected) {
+  do_print("Check that the output has the expected value and priority");
+  do_check_eq(expected.value, actual.value);
+  do_check_eq(expected.priority, actual.priority);
+}
diff --git a/toolkit/devtools/tests/unit/xpcshell.ini b/toolkit/devtools/tests/unit/xpcshell.ini
index 2f35e19..a571c80 100644
--- a/toolkit/devtools/tests/unit/xpcshell.ini
+++ b/toolkit/devtools/tests/unit/xpcshell.ini
@@ -1,15 +1,18 @@
 [DEFAULT]
 head = head_devtools.js
 tail =
 skip-if = toolkit == 'android' || toolkit == 'gonk'
 support-files =
   exposeLoader.js
 
+[test_getRuleText.js]
 [test_independent_loaders.js]
 [test_invisible_loader.js]
+[test_parseDeclarations.js]
+[test_parseSingleValue.js]
 [test_safeErrorString.js]
 [test_defineLazyPrototypeGetter.js]
 [test_async-utils.js]
 [test_consoleID.js]
 [test_require_lazy.js]
 [test_require.js]
