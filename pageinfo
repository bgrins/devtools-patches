# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5415da14ec9a2f4749e8f405d6111a6f40e8138f

diff --git a/accessible/xpcom/xpcAccessible.cpp b/accessible/xpcom/xpcAccessible.cpp
--- a/accessible/xpcom/xpcAccessible.cpp
+++ b/accessible/xpcom/xpcAccessible.cpp
@@ -92,16 +92,28 @@ xpcAccessible::GetLastChild(nsIAccessibl
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   NS_IF_ADDREF(*aLastChild = ToXPC(IntlGeneric().LastChild()));
   return NS_OK;
 }
 
 NS_IMETHODIMP
+xpcAccessible::GetUniqueID(uint64_t* aUniqueID) {
+  NS_ENSURE_ARG_POINTER(aUniqueID);
+
+  if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
+
+  void* uniqueID = static_cast<void*>(this);
+  *aUniqueID = reinterpret_cast<uint64_t>(uniqueID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 xpcAccessible::GetChildCount(int32_t* aChildCount) {
   NS_ENSURE_ARG_POINTER(aChildCount);
 
   if (IntlGeneric().IsNull()) return NS_ERROR_FAILURE;
 
   *aChildCount = IntlGeneric().ChildCount();
   return NS_OK;
 }
diff --git a/accessible/xpcom/xpcAccessible.h b/accessible/xpcom/xpcAccessible.h
--- a/accessible/xpcom/xpcAccessible.h
+++ b/accessible/xpcom/xpcAccessible.h
@@ -25,16 +25,17 @@ class xpcAccessible : public nsIAccessib
  public:
   // nsIAccessible
   NS_IMETHOD GetParent(nsIAccessible** aParent) final;
   NS_IMETHOD GetNextSibling(nsIAccessible** aNextSibling) final;
   NS_IMETHOD GetPreviousSibling(nsIAccessible** aPreviousSibling) final;
   NS_IMETHOD GetFirstChild(nsIAccessible** aFirstChild) final;
   NS_IMETHOD GetLastChild(nsIAccessible** aLastChild) final;
   NS_IMETHOD GetChildCount(int32_t* aChildCount) final;
+  NS_IMETHOD GetUniqueID(uint64_t* aUniqueID) final;
   NS_IMETHOD GetChildAt(int32_t aChildIndex, nsIAccessible** aChild) final;
   NS_IMETHOD GetChildren(nsIArray** aChildren) final;
   NS_IMETHOD GetIndexInParent(int32_t* aIndexInParent) final;
 
   NS_IMETHOD GetUniqueID(int64_t* aUniqueID) final;
   NS_IMETHOD GetDOMNode(nsINode** aDOMNode) final;
   NS_IMETHOD GetId(nsAString& aID) final;
   NS_IMETHOD GetDocument(nsIAccessibleDocument** aDocument) final;
diff --git a/browser/actors/BrowserTabParent.jsm b/browser/actors/BrowserTabParent.jsm
--- a/browser/actors/BrowserTabParent.jsm
+++ b/browser/actors/BrowserTabParent.jsm
@@ -11,16 +11,20 @@ class BrowserTabParent extends JSWindowA
     if (!browser) {
       return; // Can happen sometimes if browser is being destroyed
     }
 
     if (browser.outerBrowser) {
       browser = browser.outerBrowser; // handle RDM mode
     }
 
+    if (browser.hostBrowser) {
+      return;
+    }
+
     let gBrowser = browser.ownerGlobal.gBrowser;
 
     if (!gBrowser) {
       // Note: gBrowser might be null because this message might be received
       // from the extension process. There's still an embedderElement involved,
       // but it's the one coming from dummy.xul.
       // This should probably be fixed by adding support to specifying "group: 'browsers"
       // in the registerWindowActor options/. See bug 1557118.
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -59,16 +59,96 @@ body {
 :root[customizing] {
   min-width: -moz-fit-content;
 }
 
 /* Prevent shrinking the page content to 0 height and width */
 .browserStack > browser {
   min-height: 25px;
   min-width: 25px;
+  /* margin-inline-start: 32px;
+  width: calc(100% - 32px); */
+}
+.browserStack:not([secondarybrowser]) > .secondarybrowser {
+  display: none;
+}
+/* 
+.browserStack > .secondarybrowser-controls {
+  justify-self: start;
+  width: 32px;
+  background: rgba(255, 255, 255, .8);
+}
+
+.browserStack > .secondarybrowser-controls > toolbarbutton {
+  width: 32px;
+  height: 32px;
+}
+.browserStack > .secondarybrowser-controls > toolbarbutton:hover,
+.browserStack > .secondarybrowser-controls > toolbarbutton[active] {
+  background-color: hsla(240,5%,5%,.1);
+} */
+
+  /* icons grabbed from https://www.iconfinder.com/iconsets/material-core */
+.secondarybrowser-on {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-split {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxNnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAxNiIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01MDYuMDAwMDAwLCAtMTMwLjAwMDAwMCkiPjxnIGlkPSJkcmF3ZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwNi4wMDAwMDAsIDEzMC4wMDAwMDApIj48cGF0aCBkPSJNMTgsMCBMMiwwIEMwLjgsMCAwLDAuOCAwLDIgTDAsMTQgQzAsMTUuMiAwLjgsMTYgMiwxNiBMMTgsMTYgQzE5LDE2IDIwLDE1LjIgMjAsMTQgTDIwLDIgQzIwLDAuOCAxOSwwIDE4LDAgTDE4LDAgWiBNMTgsMTQgTDEyLDE0IEwxMiwyIEwxOCwyIEwxOCwxNCBMMTgsMTQgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-off {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMCAyMCIgd2lkdGg9IjIwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTYuMDAwMDAwLCAtMjk2LjAwMDAwMCkiPjxnIGlkPSJsYW5ndWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk2LjAwMDAwMCwgMjk2LjAwMDAwMCkiPjxwYXRoIGQ9Ik0xMCwwIEM0LjUsMCAwLDQuNSAwLDEwIEMwLDE1LjUgNC41LDIwIDEwLDIwIEMxNS41LDIwIDIwLDE1LjUgMjAsMTAgQzIwLDQuNSAxNS41LDAgMTAsMCBMMTAsMCBaIE0xNi45LDYgTDE0LDYgQzEzLjcsNC43IDEzLjIsMy42IDEyLjYsMi40IEMxNC40LDMuMSAxNiw0LjMgMTYuOSw2IEwxNi45LDYgWiBNMTAsMiBDMTAuOCwzLjIgMTEuNSw0LjUgMTEuOSw2IEw4LjEsNiBDOC41LDQuNiA5LjIsMy4yIDEwLDIgTDEwLDIgWiBNMi4zLDEyIEMyLjEsMTEuNCAyLDEwLjcgMiwxMCBDMiw5LjMgMi4xLDguNiAyLjMsOCBMNS43LDggQzUuNiw4LjcgNS42LDkuMyA1LjYsMTAgQzUuNiwxMC43IDUuNywxMS4zIDUuNywxMiBMMi4zLDEyIEwyLjMsMTIgWiBNMy4xLDE0IEw2LDE0IEM2LjMsMTUuMyA2LjgsMTYuNCA3LjQsMTcuNiBDNS42LDE2LjkgNCwxNS43IDMuMSwxNCBMMy4xLDE0IFogTTYsNiBMMy4xLDYgQzQuMSw0LjMgNS42LDMuMSA3LjQsMi40IEM2LjgsMy42IDYuMyw0LjcgNiw2IEw2LDYgWiBNMTAsMTggQzkuMiwxNi44IDguNSwxNS41IDguMSwxNCBMMTEuOSwxNCBDMTEuNSwxNS40IDEwLjgsMTYuOCAxMCwxOCBMMTAsMTggWiBNMTIuMywxMiBMNy43LDEyIEM3LjYsMTEuMyA3LjUsMTAuNyA3LjUsMTAgQzcuNSw5LjMgNy42LDguNyA3LjcsOCBMMTIuNCw4IEMxMi41LDguNyAxMi42LDkuMyAxMi42LDEwIEMxMi42LDEwLjcgMTIuNCwxMS4zIDEyLjMsMTIgTDEyLjMsMTIgWiBNMTIuNiwxNy42IEMxMy4yLDE2LjUgMTMuNywxNS4zIDE0LDE0IEwxNi45LDE0IEMxNiwxNS43IDE0LjQsMTYuOSAxMi42LDE3LjYgTDEyLjYsMTcuNiBaIE0xNC40LDEyIEMxNC41LDExLjMgMTQuNSwxMC43IDE0LjUsMTAgQzE0LjUsOS4zIDE0LjQsOC43IDE0LjQsOCBMMTcuOCw4IEMxOCw4LjYgMTguMSw5LjMgMTguMSwxMCBDMTguMSwxMC43IDE4LDExLjQgMTcuOCwxMiBMMTQuNCwxMiBMMTQuNCwxMiBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+.secondarybrowser-media {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxOHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxOCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzEuMDAwMDAwLCAtMTcxLjAwMDAwMCkiPjxnIGlkPSJkcml2ZS1pbWFnZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTcxLjAwMDAwMCkiPjxwYXRoIGQ9Ik0xOCwxNiBMMTgsMiBDMTgsMC45IDE3LjEsMCAxNiwwIEwyLDAgQzAuOSwwIDAsMC45IDAsMiBMMCwxNiBDMCwxNy4xIDAuOSwxOCAyLDE4IEwxNiwxOCBDMTcuMSwxOCAxOCwxNy4xIDE4LDE2IEwxOCwxNiBaIE01LjUsMTAuNSBMOCwxMy41IEwxMS41LDkgTDE2LDE1IEwyLDE1IEw1LjUsMTAuNSBMNS41LDEwLjUgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-outline {
+  background: no-repeat center center url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAxMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00MjMuMDAwMDAwLCAtMzAxLjAwMDAwMCkiPjxnIGlkPSJsaXN0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjMuMDAwMDAwLCAzMDEuMDAwMDAwKSI+PHBhdGggZD0iTTAsNiBMMiw2IEwyLDQgTDAsNCBMMCw2IEwwLDYgWiBNMCwxMCBMMiwxMCBMMiw4IEwwLDggTDAsMTAgTDAsMTAgWiBNMCwyIEwyLDIgTDIsMCBMMCwwIEwwLDIgTDAsMiBaIE00LDYgTDE4LDYgTDE4LDQgTDQsNCBMNCw2IEw0LDYgWiBNNCwxMCBMMTgsMTAgTDE4LDggTDQsOCBMNCwxMCBMNCwxMCBaIE00LDAgTDQsMiBMMTgsMiBMMTgsMCBMNCwwIEw0LDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+);
+}
+.secondarybrowser-reader {
+  background: no-repeat center center url(chrome://browser/skin/readerMode.svg);
+}
+
+/*
+.browserStack > .secondarybrowser {
+  z-index: 2;
+  justify-self: center;
+  align-self: start;
+  width: 0;
+  position: relative;
+  top: -1px;
+}
+.browserStack[secondarybrowser="overlay"]::after {
+  content: "";
+  position: absolute;
+  left: 0;
+  right: 0;
+  top: 0;
+  bottom: 0;
+  background: rgba(0, 0, 0, .5);
+  z-index: 1;
+}
+.browserStack[secondarybrowser] > .secondarybrowser {
+  width: 95%;
+  height: 95%;
+  border: solid var(--tabs-navbar-shadow-size) rgba(0,0,0,.3);
+  border-top: none;
+}
+.browserStack[secondarybrowser="minimized"] > .secondarybrowser {
+  height: 34px;
+}
+*/
+
+.browserStack[secondarybrowser] > browser {
+  width: 50%;
+  height: 100%;
+}
+.browserStack[secondarybrowser] > .secondarybrowser {
+  width: 50%;
+  justify-self: end;
+  /* border-right: solid 2px rgba(0,0,0,.05); */
 }
 
 body {
   display: -moz-box;
   -moz-box-orient: vertical;
   -moz-box-flex: 1;
 }
 
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -3290,39 +3290,40 @@ function BrowserPageInfo(
       "https://bugzilla.mozilla.org/show_bug.cgi?id=1238180"
     );
     documentURL = documentURL.location;
   }
 
   let args = { initialTab, imageElement, browsingContext, browser };
 
   documentURL = documentURL || window.gBrowser.selectedBrowser.currentURI.spec;
-
-  // Check for windows matching the url
-  for (let currentWindow of Services.wm.getEnumerator("Browser:page-info")) {
-    if (currentWindow.closed) {
-      continue;
-    }
-    if (
-      currentWindow.document.documentElement.getAttribute("relatedUrl") ==
-      documentURL
-    ) {
-      currentWindow.focus();
-      currentWindow.resetPageInfo(args);
-      return currentWindow;
-    }
-  }
-
-  // We didn't find a matching window, so open a new one.
-  return openDialog(
-    "chrome://browser/content/pageinfo/pageInfo.xhtml",
-    "",
-    "chrome,toolbar,dialog=no,resizable",
-    args
-  );
+  console.log(args);
+  gBrowser.toggleSecondaryBrowser(gBrowser.selectedBrowser);
+  // // Check for windows matching the url
+  // for (let currentWindow of Services.wm.getEnumerator("Browser:page-info")) {
+  //   if (currentWindow.closed) {
+  //     continue;
+  //   }
+  //   if (
+  //     currentWindow.document.documentElement.getAttribute("relatedUrl") ==
+  //     documentURL
+  //   ) {
+  //     currentWindow.focus();
+  //     currentWindow.resetPageInfo(args);
+  //     return currentWindow;
+  //   }
+  // }
+
+  // // We didn't find a matching window, so open a new one.
+  // return openDialog(
+  //   "chrome://browser/content/pageinfo/pageInfo.xhtml",
+  //   "",
+  //   "chrome,toolbar,dialog=no,resizable",
+  //   args
+  // );
 }
 
 function UpdateUrlbarSearchSplitterState() {
   var splitter = document.getElementById("urlbar-search-splitter");
   var urlbar = document.getElementById("urlbar-container");
   var searchbar = document.getElementById("search-container");
 
   if (document.documentElement.getAttribute("customizing") == "true") {
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -603,16 +603,19 @@
     /**
      * Create a findbar instance.
      * @param aTab the tab to create the find bar for.
      * @return the created findbar, or null if the window or tab is closed/closing.
      */
     async _createFindBar(aTab) {
       let findBar = document.createXULElement("findbar");
       let browser = this.getBrowserForTab(aTab);
+      if (browser.secondaryBrowser) {
+        browser = browser.secondaryBrowser;
+      }
 
       // The findbar should be inserted after the browserStack and, if present for
       // this tab, after the StatusPanel as well.
       let insertAfterElement = browser.parentNode;
       if (insertAfterElement.nextElementSibling == StatusPanel.panel) {
         insertAfterElement = StatusPanel.panel;
       }
       insertAfterElement.insertAdjacentElement("afterend", findBar);
@@ -1845,16 +1848,17 @@
       let oldUserTypedValue = aBrowser.userTypedValue;
       let hadStartedLoad = aBrowser.didStartLoadSinceLastUserTyping();
       let parent = aBrowser.parentNode;
 
       // Change the "remote" attribute.
 
       // Make sure the browser is destroyed so it unregisters from observer notifications
       aBrowser.destroy();
+
       // Only remove the node if we're not rebuilding the frameloader via nsFrameLoaderOwner.
       let rebuildFrameLoaders =
         E10SUtils.rebuildFrameloadersOnRemotenessChange ||
         window.docShell.nsILoadContext.useRemoteSubframes;
       if (!rebuildFrameLoaders) {
         aBrowser.remove();
       }
 
@@ -2024,31 +2028,75 @@
       // correct type.
       if (oldRemoteType != aOptions.remoteType || aOptions.newFrameloader) {
         return this.updateBrowserRemoteness(aBrowser, aOptions);
       }
 
       return false;
     },
 
+    minMaxSecondaryBrowser(browser) {
+      this.openSecondaryBrowser(browser);
+      let stack = browser.parentNode;
+      if (stack.getAttribute("secondarybrowser") == "overlay") {
+        stack.setAttribute("secondarybrowser", "minimized");
+      } else {
+        stack.setAttribute("secondarybrowser", "overlay");
+      }
+    },
+
+    closeSecondaryBrowser(browser) {
+      let stack = browser.parentNode;
+      stack.removeAttribute("secondarybrowser");
+      if (browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.destroySecondaryBrowser();
+      }
+      for (let active of stack.querySelectorAll(
+        ".secondarybrowser-controls toolbarbutton[active]"
+      )) {
+        active.removeAttribute("active");
+      }
+    },
+
+    openSecondaryBrowser(browser) {
+      let stack = browser.parentNode;
+      if (!browser.secondaryBrowser) {
+        gBrowser.closeFindbarForTab(gBrowser.getTabForBrowser(browser));
+        browser.before(browser.createSecondaryBrowser());
+      }
+      if (!stack.hasAttribute("secondarybrowser")) {
+        stack.setAttribute("secondarybrowser", "overlay");
+      }
+    },
+
+    toggleSecondaryBrowser(browser) {
+      if (browser.secondaryBrowser) {
+        this.closeSecondaryBrowser(browser);
+      } else {
+        this.openSecondaryBrowser(browser);
+      }
+    },
+
     createBrowser({
       isPreloadBrowser,
       name,
       openWindowInfo,
       remoteType,
       sameProcessAsFrameLoader,
       uriIsAboutBlank,
       userContextId,
       skipLoad,
     } = {}) {
       let b = document.createXULElement("browser");
+
       // Use the JSM global to create the permanentKey, so that if the
       // permanentKey is held by something after this window closes, it
       // doesn't keep the window alive.
-      b.permanentKey = new (Cu.getGlobalForObject(Services).Object)();
+      b.permanentKey = new (Cu.getGlobalForObject(Services)).Object();
 
       const defaultBrowserAttributes = {
         contextmenu: "contentAreaContextMenu",
         datetimepicker: "DateTimePickerPanel",
         message: "true",
         messagemanagergroup: "browsers",
         selectmenulist: "ContentSelectDropdown",
         tooltip: "aHTMLTooltip",
@@ -2087,17 +2135,16 @@
        *      browsers will attempt to switch to a new content process,
        *      therefore the 'preloadedState' attribute is removed from
        *      that browser altogether
        * See more details on Bug 1420285.
        */
       if (isPreloadBrowser) {
         b.setAttribute("preloadedState", "preloaded");
       }
-
       if (sameProcessAsFrameLoader) {
         b.sameProcessAsFrameLoader = sameProcessAsFrameLoader;
       }
 
       // Propagate information about the opening content window to the browser.
       if (openWindowInfo) {
         b.openWindowInfo = openWindowInfo;
       }
@@ -2385,16 +2432,25 @@
         !browser.permitUnload(permitUnloadFlags).permitUnload
       ) {
         return false;
       }
 
       return true;
     },
 
+    closeFindbarForTab(aTab) {
+      // Reset the findbar and remove it if it is attached to the tab.
+      if (aTab._findBar) {
+        aTab._findBar.close(true);
+        aTab._findBar.remove();
+        delete aTab._findBar;
+      }
+    },
+
     discardBrowser(aTab, aForceDiscard) {
       "use strict";
       let browser = aTab.linkedBrowser;
 
       if (!this._mayDiscardBrowser(aTab, aForceDiscard)) {
         return false;
       }
 
@@ -2422,22 +2478,17 @@
       let listener = this._tabListeners.get(aTab);
       browser.webProgress.removeProgressListener(filter);
       filter.removeProgressListener(listener);
       listener.destroy();
 
       this._tabListeners.delete(aTab);
       this._tabFilters.delete(aTab);
 
-      // Reset the findbar and remove it if it is attached to the tab.
-      if (aTab._findBar) {
-        aTab._findBar.close(true);
-        aTab._findBar.remove();
-        delete aTab._findBar;
-      }
+      this.closeFindbarForTab();
 
       // Remove potentially stale attributes.
       let attributesToRemove = [
         "activemedia-blocked",
         "busy",
         "pendingicon",
         "progress",
         "soundplaying",
@@ -4146,16 +4197,26 @@
 
     announceWindowCreated(browser, userContextId) {
       let tab = this.getTabForBrowser(browser);
       if (tab && userContextId) {
         ContextualIdentityService.telemetry(userContextId);
         tab.setUserContextId(userContextId);
       }
 
+      // Automatically create the secondaryBrowser:
+      // XXX: this should only happen if the tab previously had it or if
+      // there's some global state
+      if (tab) {
+        // if (!browser.secondaryBrowser) {
+        //   // XXX: Make a module to control the sidebar here instead of random clicking
+        //   browser.parentNode.querySelector(".secondarybrowser-split").click();
+        // }
+      }
+
       // We don't want to update the container icon and identifier if
       // this is not the selected browser.
       if (browser == gBrowser.selectedBrowser) {
         updateUserContextUIIndicator();
       }
     },
 
     reloadMultiSelectedTabs() {
@@ -5131,17 +5192,16 @@
           openContextMenu(aMessage);
           break;
         }
         case "Browser:Init": {
           let tab = this.getTabForBrowser(browser);
           if (!tab) {
             return undefined;
           }
-
           this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
           browser.sendMessageToActor(
             "Browser:AppTab",
             { isAppTab: tab.pinned },
             "BrowserTab"
           );
           break;
         }
@@ -5452,16 +5512,21 @@
 
       let onTabCrashed = event => {
         if (!event.isTrusted || !event.isTopFrame) {
           return;
         }
 
         let browser = event.originalTarget;
 
+        if (browser.hostBrowser) {
+          console.error("secondarybrowser crashed");
+          return;
+        }
+
         // Preloaded browsers do not actually have any tabs. If one crashes,
         // it should be released and removed.
         if (browser === this.preloadedBrowser) {
           NewTabPagePreloading.removePreloadedBrowser(window);
           return;
         }
 
         let isRestartRequiredCrash =
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -117,16 +117,34 @@ let JSWINDOWACTORS = {
       events: {
         DOMWindowCreated: { capture: true },
       },
     },
 
     matches: ["about:newinstall"],
   },
 
+  SecondaryBrowser: {
+    parent: {
+      moduleURI: "resource:///actors/secondarybrowserParent.jsm",
+    },
+    child: {
+      moduleURI: "resource:///actors/SecondaryBrowserChild.jsm",
+      events: {
+        SecondaryBrowserContentLoaded: { wantUntrusted: true },
+        SecondaryBrowserContentEvent: { wantUntrusted: true },
+        SecondaryBrowserClose: { wantUntrusted: true },
+        SecondaryBrowserMinMax: { wantUntrusted: true },
+        DOMContentLoaded: {},
+        pageshow: {},
+        unload: {},
+      },
+    },
+  },
+
   AboutNewTab: {
     child: {
       moduleURI: "resource:///actors/AboutNewTabChild.jsm",
       events: {
         DOMContentLoaded: {},
       },
     },
     // The wildcard on about:newtab is for the ?endpoint query parameter
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -25,16 +25,17 @@ with Files("safebrowsing/**"):
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
 
 
 DIRS += [
     'about',
     'aboutconfig',
     'aboutlogins',
+    'secondarybrowser',
     'attribution',
     'contextualidentity',
     'customizableui',
     'dirprovider',
     'doh',
     'downloads',
     'enterprisepolicies',
     'extensions',
diff --git a/browser/components/secondarybrowser/SecondaryBrowserChild.jsm b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserChild.jsm
@@ -0,0 +1,577 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+
+const EXPORTED_SYMBOLS = ["SecondaryBrowserChild"];
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  FileUtils: "resource://gre/modules/FileUtils.jsm",
+  NetUtil: "resource://gre/modules/NetUtil.jsm",
+  Services: "resource://gre/modules/Services.jsm",
+});
+XPCOMUtils.defineLazyGlobalGetters(this, ["InspectorUtils"]);
+
+const hostToSecondaryBrowserMap = new WeakMap();
+const secondaryToHostBrowserMap = new WeakMap();
+
+XPCOMUtils.defineLazyServiceGetter(
+  this,
+  "ImgTools",
+  "@mozilla.org/image/tools;1",
+  Ci.imgITools
+);
+
+// See also https://searchfox.org/mozilla-central/source/browser/base/content/nsContextMenu.js#1637-1652
+// and https://searchfox.org/mozilla-central/source/browser/actors/ContextMenuChild.jsm#593-601 for how
+// normal save image works
+// Along with https://searchfox.org/mozilla-central/source/browser/components/ssb/SiteSpecificBrowserService.jsm#162
+
+function saveIcon(container, width, height, target) {
+  return new Promise((resolve, reject) => {
+    let output = FileUtils.openFileOutputStream(target);
+    let stream = ImgTools.encodeScaledImage(
+      container,
+      "image/vnd.microsoft.icon",
+      width,
+      height,
+      ""
+    );
+    NetUtil.asyncCopy(stream, output, status => {
+      if (Components.isSuccessCode(status)) {
+        resolve();
+      } else {
+        reject(Components.Exception("Failed to save icon.", status));
+      }
+    });
+  });
+}
+
+function sendToContent(browsingContext, messageType, detail = {}) {
+  let win = browsingContext.window;
+  let message = Object.assign({ messageType }, { value: detail });
+  let event = new win.CustomEvent("SecondaryBrowserChromeToContent", {
+    detail: Cu.cloneInto(message, win),
+  });
+  win.dispatchEvent(event);
+}
+
+// See stuff like https://searchfox.org/mozilla-central/source/devtools/server/actors/accessibility/walker.js#499
+
+// Basic idea here is to use this actor to receive the accessibility tree and
+// subsequent events from a 'host' browser, and then to send them along to an
+// 'secondarybrowser' browser (which are running in the same content process)
+// Maybe this should be two different actors?
+class SecondaryBrowserChild extends JSWindowActorChild {
+  willDestroy(e) {
+    // Overlay is destroyed. Kill observing:
+    if (secondaryToHostBrowserMap.has(this.browsingContext)) {
+      secondaryToHostBrowserMap.delete(this.browsingContext);
+    }
+  }
+  actorCreated(e) {
+    // I think it's better to wait for SecondaryBrowserContentLoaded to
+    // signal the connection so there's no races.. but maybe this
+    // would come in handy somehow?
+  }
+
+  receiveMessage(message) {
+    // console.log(
+    //   "SecondaryBrowserChild::receiveMessage",
+    //   message.name,
+    //   Services.appinfo.processID,
+    //   this.browsingContext.window.location.toString()
+    // );
+    switch (message.name) {
+      case "SecondaryBrowser:UpdateBrowsingContext": {
+        const { browsingContext, initialView } = message.data;
+        hostToSecondaryBrowserMap.set(this.browsingContext, browsingContext);
+        secondaryToHostBrowserMap.set(browsingContext, this.browsingContext);
+        this.sendImages();
+        this.cloneAndWalk();
+
+        break;
+      }
+    }
+  }
+
+  cloneAndWalk() {
+    let browsingContext = hostToSecondaryBrowserMap.get(this.browsingContext);
+    if (!browsingContext) {
+      return;
+    }
+    let getBoundsWithoutFlushing = element =>
+      element.ownerGlobal.windowUtils.getBoundsWithoutFlushing(element);
+    let px = number => number.toFixed(2) + "px";
+    function getSize(node) {
+      let bounds = getBoundsWithoutFlushing(currentNode);
+      return {
+        height: px(bounds.height),
+        width: px(bounds.width),
+        top: px(bounds.top),
+        left: px(bounds.left),
+      };
+    }
+
+    let nodeFilterConstants = {
+      FILTER_ACCEPT: 1,
+      FILTER_REJECT: 2,
+      FILTER_SKIP: 3,
+
+      SHOW_ALL: 0xffffffff,
+      SHOW_ELEMENT: 0x00000001,
+      SHOW_ATTRIBUTE: 0x00000002,
+      SHOW_TEXT: 0x00000004,
+      SHOW_CDATA_SECTION: 0x00000008,
+      SHOW_ENTITY_REFERENCE: 0x00000010,
+      SHOW_ENTITY: 0x00000020,
+      SHOW_PROCESSING_INSTRUCTION: 0x00000040,
+      SHOW_COMMENT: 0x00000080,
+      SHOW_DOCUMENT: 0x00000100,
+      SHOW_DOCUMENT_TYPE: 0x00000200,
+      SHOW_DOCUMENT_FRAGMENT: 0x00000400,
+      SHOW_NOTATION: 0x00000800,
+    };
+
+    let win = this.browsingContext.window;
+    let doc = win.document;
+
+    function standardTreeWalkerFilter(node) {
+      // Ignore empty whitespace text nodes that do not impact the layout.
+      // if (isWhitespaceTextNode(node)) {
+      //   return nodeHasSize(node)
+      //     ? nodeFilterConstants.FILTER_ACCEPT
+      //     : nodeFilterConstants.FILTER_SKIP;
+      // }
+
+      if (node.isNativeAnonymous) {
+        return nodeFilterConstants.FILTER_SKIP;
+      }
+
+      return nodeFilterConstants.FILTER_ACCEPT;
+    }
+    function hasVisitedState(node) {
+      if (!node) {
+        return false;
+      }
+
+      const NS_EVENT_STATE_VISITED = 1 << 24;
+
+      return (
+        !!(InspectorUtils.getContentState(node) & NS_EVENT_STATE_VISITED) ||
+        InspectorUtils.hasPseudoClassLock(node, ":visited")
+      );
+    }
+    const WHITELISTED_ATTRS = new Set([
+      "accept",
+      "accesskey",
+      "align",
+      "allow",
+      "alt",
+      "async",
+      "autocapitalize",
+      "autocomplete",
+      "autofocus",
+      "autoplay",
+      "background",
+      "Note",
+      "bgcolor",
+      "border",
+      "buffered",
+      "capture",
+      "charset",
+      "checked",
+      "cite",
+      "class",
+      "code",
+      "codebase",
+      "color",
+      "cols",
+      "colspan",
+      "content",
+      "contenteditable",
+      "contextmenu",
+      "controls",
+      "coords",
+      "crossorigin",
+      "csp",
+      "data",
+      "data",
+      "datetime",
+      "decoding",
+      "default",
+      "defer",
+      "dir",
+      "dirname",
+      "disabled",
+      "download",
+      "draggable",
+      "dropzone",
+      "enctype",
+      "enterkeyhint",
+      "for",
+      "form",
+      "formaction",
+      "formenctype",
+      "formmethod",
+      "formnovalidate",
+      "formtarget",
+      "headers",
+      "height",
+      "hidden",
+      "high",
+      "href",
+      "hreflang",
+      "http",
+      "icon",
+      "id",
+      "importance",
+      "integrity",
+      "intrinsicsize",
+      "inputmode",
+      "ismap",
+      "itemprop",
+      "keytype",
+      "kind",
+      "label",
+      "lang",
+      "language",
+      "loading",
+      "list",
+      "loop",
+      "low",
+      "manifest",
+      "max",
+      "maxlength",
+      "minlength",
+      "media",
+      "method",
+      "min",
+      "multiple",
+      "muted",
+      "name",
+      "novalidate",
+      "open",
+      "optimum",
+      "pattern",
+      "ping",
+      "placeholder",
+      "poster",
+      "preload",
+      "radiogroup",
+      "readonly",
+      "referrerpolicy",
+      "rel",
+      "required",
+      "reversed",
+      "rows",
+      "rowspan",
+      "sandbox",
+      "scope",
+      "scoped",
+      "selected",
+      "shape",
+      "size",
+      "sizes",
+      "slot",
+      "span",
+      "spellcheck",
+      /*"src",
+      "srcdoc",
+      "srclang",
+      "srcset",*/
+      "start",
+      "step",
+      // "style",
+      "summary",
+      "tabindex",
+      "target",
+      "title",
+      "translate",
+      "type",
+      "usemap",
+      "value",
+      "width",
+      "wrap",
+    ]);
+    function whitelistedAttrs(node) {
+      let returnedAttrs = {};
+      for (let attr of node.attributes) {
+        if (WHITELISTED_ATTRS.has(attr.name)) {
+          returnedAttrs[attr.name] = attr.value;
+        }
+      }
+      return returnedAttrs;
+    }
+    function isAuthorStylesheet(sheet) {
+      return sheet.parsingMode === "author";
+    }
+    function getStyles(node) {
+      // We could also just read all computed styles if we wanted
+      const domRules = InspectorUtils.getCSSStyleRules(
+        node,
+        null,
+        hasVisitedState(node)
+      );
+
+      const rules = [];
+
+      // getCSSStyleRules returns ordered from least-specific to
+      // most-specific.
+      // for (let i = domRules.length - 1; i >= 0; i--) {
+      for (let i = 0; i < domRules.length; i++) {
+        const domRule = domRules[i];
+
+        const isSystem = !isAuthorStylesheet(domRule.parentStyleSheet);
+        if (isSystem) {
+          continue;
+        }
+        rules.push(domRule.style.cssText);
+      }
+
+      return rules.join("");
+    }
+
+    let walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(
+      Ci.inIDeepTreeWalker
+    );
+    walker.showAnonymousContent = true;
+    walker.showSubDocuments = true;
+    walker.showDocumentsAsNodes = true;
+    walker.init(
+      doc.documentElement,
+      nodeFilterConstants.SHOW_TEXT | nodeFilterConstants.SHOW_ELEMENT
+    );
+
+    let domToSerialized = new Map();
+    let currentNode = walker.currentNode;
+    let clonedTree = {
+      children: [],
+      tag: currentNode.tagName.toLowerCase(),
+      size: getSize(currentNode),
+      attributes: {
+        style: getStyles(currentNode),
+      },
+    };
+
+    domToSerialized.set(currentNode, clonedTree);
+    while ((currentNode = walker.nextNode())) {
+      // XXX Handle ::after. How should this get translated to markup? I guess
+      // this would need a new style attribute w unique id per node?
+      if (currentNode.isNativeAnonymous) {
+        continue;
+      }
+      if (!domToSerialized.has(currentNode.parentNode)) {
+        continue;
+      }
+
+      if (
+        currentNode.tagName == "SCRIPT" ||
+        currentNode.tagName == "LINK" ||
+        currentNode.tagName == "STYLE"
+      ) {
+        // Put a placeholder to avoid messing up UA styles like
+        // `body > h1:-moz-first-node` with markup like `<body><style><h1>`
+        domToSerialized.get(currentNode.parentNode).children.push({
+          children: [],
+          tag: "div",
+          attributes: {},
+        });
+        continue;
+      }
+      if (currentNode.tagName == "HEAD") {
+        // XXX: Should any of this come across?
+        continue;
+      }
+
+      let parentTree = domToSerialized.get(currentNode.parentNode);
+      if (currentNode.nodeType == 3) {
+        parentTree.children.push(currentNode.data);
+      } else {
+        if (!currentNode.tagName) {
+          // XXX: why?
+          continue;
+        }
+        let thisTree = {
+          children: [],
+          tag: currentNode.tagName.toLowerCase(),
+          size: getSize(currentNode),
+          attributes: Object.assign({}, whitelistedAttrs(currentNode), {
+            style: getStyles(currentNode),
+          }),
+        };
+        domToSerialized.get(currentNode.parentNode).children.push(thisTree);
+        domToSerialized.set(currentNode, thisTree);
+      }
+    }
+
+    // XXX: I have a gist or push somewhere that extracted out the dt code to get applied
+    // styles.
+    // See https://searchfox.org/mozilla-central/source/dom/chrome-webidl/InspectorUtils.webidl#17
+    // InspectorUtils.getUsedFontFaces(searchRange, MAX_TEXT_RANGES);
+    console.log(clonedTree);
+    sendToContent(browsingContext, "DOMTree", clonedTree);
+  }
+
+  handleEvent(event) {
+    // console.log(
+    //   "SecondaryBrowserChild::handleEvent",
+    //   event,
+    //   Services.appinfo.processID,
+    //   this.browsingContext.window.location.toString()
+    // );
+
+    switch (event.type) {
+      case "pageshow": {
+        this.sendImages();
+        this.cloneAndWalk();
+        break;
+      }
+      case "DOMContentLoaded": {
+        this.sendImages();
+        this.cloneAndWalk();
+        break;
+      }
+      case "unload": {
+        this.sendImages();
+        this.cloneAndWalk();
+        break;
+      }
+      case "SecondaryBrowserContentLoaded": {
+        this.sendAsyncMessage("SecondaryBrowser:WindowCreated");
+        break;
+      }
+      case "SecondaryBrowserSaveMedia": {
+        // XXX: Forward this to parent and call internalSave (including
+        // zipping if multiple)
+        break;
+      }
+      case "SecondaryBrowserClose": {
+        this.sendAsyncMessage("SecondaryBrowser:Close");
+        break;
+      }
+      case "SecondaryBrowserMinMax": {
+        this.sendAsyncMessage("SecondaryBrowser:MinMax");
+        break;
+      }
+      case "SecondaryBrowserContentEvent": {
+        let browsingContext = secondaryToHostBrowserMap.get(
+          this.browsingContext
+        );
+
+        console.log(browsingContext, event.detail.producerId);
+        let matchedImage = [
+          ...browsingContext.window.windowUtils.getTrackedImages(),
+        ].filter(img => {
+          return img.producerId == event.detail.producerId;
+        });
+
+        if (!matchedImage.length) {
+          console.log("Recieved event for missing image");
+        } else {
+          // XXX: this doesnt do anything for background images
+          let el = matchedImage[0].notificationObserver;
+          console.log(el);
+          el.scrollIntoView();
+        }
+
+        this.sendAsyncMessage("SecondaryBrowser:MinMax");
+        break;
+      }
+      case "SecondaryBrowserContentView": {
+        if (event.detail.split) {
+          this.sendAsyncMessage("SecondaryBrowser:Split");
+        } else {
+          this.sendAsyncMessage("SecondaryBrowser:Unsplit");
+        }
+        break;
+      }
+    }
+  }
+
+  sendImages() {
+    // XXX: Set up notification on ImageTracker::Add to update as new
+    // ones are added.
+
+    let win = this.browsingContext.window;
+    let doc = win.document;
+    let browsingContext = hostToSecondaryBrowserMap.get(this.browsingContext);
+    if (!browsingContext) {
+      return;
+    }
+    // console.log(doc.URI, win.windowUtils.getTrackedImages().map(i=>i.notificationObserver));
+    console.log(doc.documentURI, win.windowUtils.getTrackedImages());
+    let uniqueSpecs = new Set();
+    sendToContent(
+      browsingContext,
+      "TrackedImages",
+      [...win.windowUtils.getTrackedImages()]
+        .filter(img => {
+          // Why is resource://gre-resources/arrow.gif included?
+          return img.URI.scheme != "resource" && img.URI.scheme != "chrome";
+        })
+        .filter(img => {
+          let has = uniqueSpecs.has(img.finalURI.spec);
+          uniqueSpecs.add(img.finalURI.spec);
+          return !has;
+        })
+        .map(img => {
+          // var img = window.windowUtils.getTrackedImages()[0];
+          var imageCache = Cc["@mozilla.org/image/tools;1"]
+            .getService(Ci.imgITools)
+            .getImgCacheForDocument(doc);
+          // The image cache's notion of where this image is located is
+          // the currentURI of the image loading content.
+          var props = imageCache.findEntryProperties(img.finalURI, doc);
+
+          var contentType;
+          var contentDisposition;
+          var width;
+          var height;
+
+          try {
+            width = img.image.width;
+          } catch (e) {}
+          try {
+            height = img.image.height;
+          } catch (e) {}
+
+          try {
+            contentType = props.get("type", Ci.nsISupportsCString).data;
+          } catch (e) {}
+
+          try {
+            contentDisposition = props.get(
+              "content-disposition",
+              Ci.nsISupportsCString
+            ).data;
+          } catch (e) {}
+          // console.log(contentType, contentDisposition);
+
+          return {
+            finalURI: img.finalURI.spec,
+            contentType,
+            contentDisposition,
+            width,
+            height,
+            producerId: img.producerId,
+          };
+        })
+    );
+
+    // We can either sendToContent or directly change the DOM:
+    console.log(
+      "SecondaryBrowserContentLoaded, PID:",
+      Services.appinfo.processID
+    );
+    let secondaryDoc = browsingContext.window.document;
+    // doc = hostToSecondaryBrowserMap.get(this.browsingContext);
+    let title = secondaryDoc.querySelector("#title");
+    title.textContent = `Page Info: ${this.browsingContext.window.document.title}`;
+  }
+}
diff --git a/browser/components/secondarybrowser/SecondaryBrowserParent.jsm b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/SecondaryBrowserParent.jsm
@@ -0,0 +1,65 @@
+/* vim: set ts=2 sw=2 sts=2 et tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+var EXPORTED_SYMBOLS = ["SecondaryBrowserParent"];
+
+class SecondaryBrowserParent extends JSWindowActorParent {
+  receiveMessage(message) {
+    // console.log("SecondaryBrowserParent::receiveMessage", message);
+    let browser = this.manager.browsingContext.embedderElement;
+    if (!browser) {
+      return; // Can happen sometimes if browser is being destroyed
+    }
+    if (!browser.hostBrowser) {
+      // This shouldn't really happen - the message is coming from a secondary browser
+      // which by definition should have a host.
+      return;
+    }
+
+    switch (message.name) {
+      // XXX: This could be used if we have an 'overlay' view
+      case "SecondaryBrowser:Close": {
+        let gBrowser = browser.hostBrowser.getTabBrowser();
+        gBrowser.closeSecondaryBrowser(browser.hostBrowser);
+        break;
+      }
+      case "SecondaryBrowser:MinMax": {
+        let gBrowser = browser.hostBrowser.getTabBrowser();
+        gBrowser.minMaxSecondaryBrowser(browser.hostBrowser);
+        break;
+      }
+      case "SecondaryBrowser:Split": {
+        browser.hostBrowser.parentNode.setAttribute(
+          "secondarybrowser",
+          "split"
+        );
+        break;
+      }
+      case "SecondaryBrowser:Unsplit": {
+        browser.hostBrowser.parentNode.setAttribute("secondarybrowser", "on");
+        break;
+      }
+
+      case "SecondaryBrowser:WindowCreated": {
+        let initialView;
+        // XXX: We need a cleaner way to signal initial state (or just build a prototype
+        // that only deals with outline)
+        initialView = "outline";
+        if (browser.parentNode.getAttribute("secondarybrowser") == "overlay") {
+          initialView = "outline";
+        }
+
+        browser.hostBrowser.browsingContext.currentWindowGlobal
+          .getActor("SecondaryBrowser")
+          .sendAsyncMessage("SecondaryBrowser:UpdateBrowsingContext", {
+            browsingContext: browser.browsingContext,
+            initialView,
+          });
+        break;
+      }
+    }
+  }
+}
diff --git a/browser/components/secondarybrowser/content/jar.mn b/browser/components/secondarybrowser/content/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/jar.mn
@@ -0,0 +1,8 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+    content/browser/secondarybrowser/secondaryui.html
+    content/browser/secondarybrowser/secondaryui.js
+    content/browser/secondarybrowser/secondaryui.css
diff --git a/browser/components/secondarybrowser/content/secondaryui.css b/browser/components/secondarybrowser/content/secondaryui.css
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.css
@@ -0,0 +1,181 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+ * {
+  box-sizing: border-box;
+ }
+
+ html, body {
+   margin: 0;
+   padding: 0;
+ }
+
+ #content {
+  display: flex;
+  flex-direction: column;
+  height: 100vh;
+  /* Offset the overlap into chrome */
+  padding-top: 2px;
+  padding: 1px;
+}
+
+ #controls {
+  position: absolute;
+  right: 4px;
+  top: 1px;
+ }
+
+ #close,
+ #minmax {
+  min-height: 30px;
+  margin: 0;
+  min-width: 20px;
+ }
+ #details-deck {
+  flex: 1;
+  overflow: scroll;
+ }
+ .tab-group {
+   margin-inline: 0;
+   margin-top: 0;
+   border-top: none;
+ }
+
+ /* XXX: don't show smaller images at the moment. Would prefer to have some filtering controls */
+ #icon-image-grid {
+  display: none;
+ }
+
+ /* XXX: Hide control bar for the DOM tree thing */
+ #controls, .tab-group {
+  display: none;
+}
+
+/*
+:root {
+  counter-reset: image-grid;
+}
+
+.image-grid {
+  display: grid;
+  grid-gap: 10px;
+  grid-template-columns: repeat(auto-fill, minmax(200px,1fr));
+  grid-auto-rows: 0;
+}
+
+.image-grid-item {
+  border-radius: 5px;
+}
+
+.image-grid-item {
+   background-color: #eee;
+   border-radius: 5px;
+   overflow: hidden;
+}
+
+.image-grid-item,
+.image-grid-item img {
+   position: relative;
+}
+
+.image-grid-item:after {
+  font-weight: bold;
+  background-color: rgba(0, 0, 0, .5);
+  content: counter(image-grid);
+  counter-increment: image-grid;
+  position: absolute;
+  top: 0;
+  left: 0; 
+  height: 100%;
+  width: 100%;
+  color: white;
+  display: flex;
+  justify-content: center; 
+  align-items: center;
+  transition: all .1s ease-in;
+}
+
+.image-grid-item:hover:after {
+  font-size: 30px;
+  background-color: rgba(0, 0, 0, .75);
+}
+*/
+
+#outline-output {
+  width: 100%;
+  height: calc(100vh - 32px); /* With toolbar */
+  height: 100vh;
+  border: none;
+  padding: 0;
+  margin: 0;
+}
+/* with flexbox */
+.image-grid {
+  display: flex;
+}
+.image-grid-item {
+  /* max-width: 25vw; */
+  max-width: 25vw;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  position: relative;
+}
+img {
+  max-width: 100%;
+}
+
+.image-grid-item::after {
+  position: absolute;
+  display: none;
+  content: '';
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  background: rgba(255, 255, 255, 0);
+  transition: background 0.2s ease;
+  pointer-events: none;
+}
+.image-grid-item:hover::after {
+  display: block;
+  background: rgba(255, 255, 255, .3);
+}
+
+.image-grid-controls {
+  display: none;
+  position: absolute;
+  right: 5px;
+  top: 5px;
+}
+.image-grid-item:hover .image-grid-controls {
+  display: block;
+}
+.image-grid-controls button {
+  min-width: 32px;
+}
+
+
+.image-grid-col {
+  flex: 1;
+  /* max-width: 25vw; */
+  margin: 2px;
+}
+
+/* 2 columns by default, hide columns 2 & 3 */
+.image-grid-col--2, .image-grid-col--3 { display: none }
+
+/* 3 columns at medium size */
+@media ( min-width: 768px ) {
+  .image-grid-col--2 { display: block; } /* show column 2 */
+}
+
+/* 4 columns at large size */
+@media ( min-width: 1080px ) {
+  .image-grid-col--3 { display: block; } /* show column 3 */
+}
+
+
+
+
diff --git a/browser/components/secondarybrowser/content/secondaryui.html b/browser/components/secondarybrowser/content/secondaryui.html
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.html
@@ -0,0 +1,66 @@
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE html>
+<html>
+<head>
+  <!-- <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'" /> -->
+  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
+  <meta name="viewport" content="width=device-width; user-scalable=0" />
+  <link rel="stylesheet" href="chrome://global/skin/in-content/common.css">
+  <link rel="stylesheet" href="chrome://mozapps/content/extensions/aboutaddons.css">
+  <link rel="stylesheet" href="chrome://browser/content/secondarybrowser/secondaryui.css">
+  <title>Page Info</title>
+</head>
+<body>
+  <div id="content">
+    <div id="controls">
+      <button id="minmax" aria-label="minimize / maximize">-</button>
+      <button id="close" aria-label="close">X</button>
+    </div>
+    <button-group class="tab-group">
+      <button is="named-deck-button" deck="details-deck" name="info" class="tab-button">Info</button>
+      <button is="named-deck-button" deck="details-deck" name="protections" class="tab-button">Protections</button>
+      <button is="named-deck-button" deck="details-deck" name="images" class="tab-button">Images</button>
+      <button is="named-deck-button" deck="details-deck" name="videos" class="tab-button">Videos</button>
+      <button is="named-deck-button" deck="details-deck" name="outline" class="tab-button">Outline</button>
+      <!-- <button is="named-deck-button" deck="details-deck" name="dev" class="tab-button">Firefox Developer</button> -->
+    </button-group>
+    <named-deck id="details-deck" selected-view="outline">
+      <section name="info">
+        <h2>Page Information</h2>
+        <div id="title"></div>
+      </section>
+      <section name="protections">
+        <h2>Protections</h2>
+        <p>Report here instead of in the panel</p>
+      </section>
+      <section name="images">
+        <div class="controls">
+          <button>Save All as Zip</button>
+        </div>
+        <div id="full-image-grid" class="image-grid"></div>
+        <div id="icon-image-grid" class="image-grid"></div>
+      </section>
+      <section name="videos">
+        <h2>Videos</h2>
+        <p>Caption search</p>
+      </section>
+      <section name="outline">
+        <iframe id="outline-output">
+
+        </iframe>
+      </section>
+      <!-- <section name="dev">
+        <h2>Firefox Developer</h2>
+        <p>Pid:</p>
+        <button>Reload tab</button>
+        <button>Crash tab</button>
+      </section> -->
+    </named-deck>
+  </div>
+  <script src="chrome://mozapps/content/extensions/named-deck.js"></script>
+  <script src="chrome://browser/content/secondarybrowser/secondaryui.js"></script>
+</body>
+</html>
diff --git a/browser/components/secondarybrowser/content/secondaryui.js b/browser/components/secondarybrowser/content/secondaryui.js
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/content/secondaryui.js
@@ -0,0 +1,501 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/*!
+ * Colcade v0.2.0
+ * Lightweight masonry layout
+ * by David DeSandro
+ * MIT license
+ */
+
+/*jshint browser: true, undef: true, unused: true */
+
+(function(window, factory) {
+  // universal module definition
+  /*jshint strict: false */
+  /*global define: false, module: false */
+  if (typeof define == "function" && define.amd) {
+    // AMD
+    define(factory);
+  } else if (typeof module == "object" && module.exports) {
+    // CommonJS
+    module.exports = factory();
+  } else {
+    // browser global
+    window.Colcade = factory();
+  }
+})(window, function factory() {
+  // -------------------------- Colcade -------------------------- //
+
+  function Colcade(element, options) {
+    element = getQueryElement(element);
+
+    // do not initialize twice on same element
+    if (element && element.colcadeGUID) {
+      var instance = instances[element.colcadeGUID];
+      instance.option(options);
+      return instance;
+    }
+
+    this.element = element;
+    // options
+    this.options = {};
+    this.option(options);
+    // kick things off
+    this.create();
+  }
+
+  var proto = Colcade.prototype;
+
+  proto.option = function(options) {
+    this.options = extend(this.options, options);
+  };
+
+  // globally unique identifiers
+  var GUID = 0;
+  // internal store of all Colcade intances
+  var instances = {};
+
+  proto.create = function() {
+    this.errorCheck();
+    // add guid for Colcade.data
+    var guid = (this.guid = ++GUID);
+    this.element.colcadeGUID = guid;
+    instances[guid] = this; // associate via id
+    // update initial properties & layout
+    this.reload();
+    // events
+    this._windowResizeHandler = this.onWindowResize.bind(this);
+    this._loadHandler = this.onLoad.bind(this);
+    window.addEventListener("resize", this._windowResizeHandler);
+    this.element.addEventListener("load", this._loadHandler, true);
+  };
+
+  proto.errorCheck = function() {
+    var errors = [];
+    if (!this.element) {
+      errors.push("Bad element: " + this.element);
+    }
+    if (!this.options.columns) {
+      errors.push("columns option required: " + this.options.columns);
+    }
+    if (!this.options.items) {
+      errors.push("items option required: " + this.options.items);
+    }
+
+    if (errors.length) {
+      throw new Error("[Colcade error] " + errors.join(". "));
+    }
+  };
+
+  // update properties and do layout
+  proto.reload = function() {
+    this.updateColumns();
+    this.updateItems();
+    this.layout();
+  };
+
+  proto.updateColumns = function() {
+    this.columns = querySelect(this.options.columns, this.element);
+  };
+
+  proto.updateItems = function() {
+    this.items = querySelect(this.options.items, this.element);
+  };
+
+  proto.getActiveColumns = function() {
+    return this.columns.filter(function(column) {
+      var style = getComputedStyle(column);
+      return style.display != "none";
+    });
+  };
+
+  // ----- layout ----- //
+
+  // public, updates activeColumns
+  proto.layout = function() {
+    this.activeColumns = this.getActiveColumns();
+    this._layout();
+  };
+
+  // private, does not update activeColumns
+  proto._layout = function() {
+    // reset column heights
+    this.columnHeights = this.activeColumns.map(function() {
+      return 0;
+    });
+    // layout all items
+    this.layoutItems(this.items);
+  };
+
+  proto.layoutItems = function(items) {
+    items.forEach(this.layoutItem, this);
+  };
+
+  proto.layoutItem = function(item) {
+    // layout item by appending to column
+    var minHeight = Math.min.apply(Math, this.columnHeights);
+    var index = this.columnHeights.indexOf(minHeight);
+    this.activeColumns[index].appendChild(item);
+    // at least 1px, if item hasn't loaded
+    // Not exactly accurate, but it's cool
+    this.columnHeights[index] += item.offsetHeight || 1;
+  };
+
+  // ----- adding items ----- //
+
+  proto.append = function(elems) {
+    var items = this.getQueryItems(elems);
+    // add items to collection
+    this.items = this.items.concat(items);
+    // lay them out
+    this.layoutItems(items);
+  };
+
+  proto.prepend = function(elems) {
+    var items = this.getQueryItems(elems);
+    // add items to collection
+    this.items = items.concat(this.items);
+    // lay out everything
+    this._layout();
+  };
+
+  proto.getQueryItems = function(elems) {
+    elems = makeArray(elems);
+    var fragment = document.createDocumentFragment();
+    elems.forEach(function(elem) {
+      fragment.appendChild(elem);
+    });
+    return querySelect(this.options.items, fragment);
+  };
+
+  // ----- measure column height ----- //
+
+  proto.measureColumnHeight = function(elem) {
+    var boundingRect = this.element.getBoundingClientRect();
+    this.activeColumns.forEach(function(column, i) {
+      // if elem, measure only that column
+      // if no elem, measure all columns
+      if (!elem || column.contains(elem)) {
+        var lastChildRect = column.lastElementChild.getBoundingClientRect();
+        // not an exact calculation as it includes top border, and excludes item bottom margin
+        this.columnHeights[i] = lastChildRect.bottom - boundingRect.top;
+      }
+    }, this);
+  };
+
+  // ----- events ----- //
+
+  proto.onWindowResize = function() {
+    clearTimeout(this.resizeTimeout);
+    this.resizeTimeout = setTimeout(
+      function() {
+        this.onDebouncedResize();
+      }.bind(this),
+      100
+    );
+  };
+
+  proto.onDebouncedResize = function() {
+    var activeColumns = this.getActiveColumns();
+    // check if columns changed
+    var isSameLength = activeColumns.length == this.activeColumns.length;
+    var isSameColumns = true;
+    this.activeColumns.forEach(function(column, i) {
+      isSameColumns = isSameColumns && column == activeColumns[i];
+    });
+    if (isSameLength && isSameColumns) {
+      return;
+    }
+    // activeColumns changed
+    this.activeColumns = activeColumns;
+    this._layout();
+  };
+
+  proto.onLoad = function(event) {
+    this.measureColumnHeight(event.target);
+  };
+
+  // ----- destroy ----- //
+
+  proto.destroy = function() {
+    // move items back to container
+    this.items.forEach(function(item) {
+      this.element.appendChild(item);
+    }, this);
+    // remove events
+    window.removeEventListener("resize", this._windowResizeHandler);
+    this.element.removeEventListener("load", this._loadHandler, true);
+    // remove data
+    delete this.element.colcadeGUID;
+    delete instances[this.guid];
+  };
+
+  // -------------------------- HTML init -------------------------- //
+
+  docReady(function() {
+    var dataElems = querySelect("[data-colcade]");
+    dataElems.forEach(htmlInit);
+  });
+
+  function htmlInit(elem) {
+    // convert attribute "foo: bar, qux: baz" into object
+    var attr = elem.getAttribute("data-colcade");
+    var attrParts = attr.split(",");
+    var options = {};
+    attrParts.forEach(function(part) {
+      var pair = part.split(":");
+      var key = pair[0].trim();
+      var value = pair[1].trim();
+      options[key] = value;
+    });
+
+    new Colcade(elem, options);
+  }
+
+  Colcade.data = function(elem) {
+    elem = getQueryElement(elem);
+    var id = elem && elem.colcadeGUID;
+    return id && instances[id];
+  };
+
+  // -------------------------- jQuery -------------------------- //
+
+  Colcade.makeJQueryPlugin = function($) {
+    $ = $ || window.jQuery;
+    if (!$) {
+      return;
+    }
+
+    $.fn.colcade = function(arg0 /*, arg1 */) {
+      // method call $().colcade( 'method', { options } )
+      if (typeof arg0 == "string") {
+        // shift arguments by 1
+        var args = Array.prototype.slice.call(arguments, 1);
+        return methodCall(this, arg0, args);
+      }
+      // just $().colcade({ options })
+      plainCall(this, arg0);
+      return this;
+    };
+
+    function methodCall($elems, methodName, args) {
+      var returnValue;
+      $elems.each(function(i, elem) {
+        // get instance
+        var colcade = $.data(elem, "colcade");
+        if (!colcade) {
+          return;
+        }
+        // apply method, get return value
+        var value = colcade[methodName].apply(colcade, args);
+        // set return value if value is returned, use only first value
+        returnValue = returnValue === undefined ? value : returnValue;
+      });
+      return returnValue !== undefined ? returnValue : $elems;
+    }
+
+    function plainCall($elems, options) {
+      $elems.each(function(i, elem) {
+        var colcade = $.data(elem, "colcade");
+        if (colcade) {
+          // set options & init
+          colcade.option(options);
+          colcade.layout();
+        } else {
+          // initialize new instance
+          colcade = new Colcade(elem, options);
+          $.data(elem, "colcade", colcade);
+        }
+      });
+    }
+  };
+
+  // try making plugin
+  Colcade.makeJQueryPlugin();
+
+  // -------------------------- utils -------------------------- //
+
+  function extend(a, b) {
+    for (var prop in b) {
+      a[prop] = b[prop];
+    }
+    return a;
+  }
+
+  // turn element or nodeList into an array
+  function makeArray(obj) {
+    var ary = [];
+    if (Array.isArray(obj)) {
+      // use object if already an array
+      ary = obj;
+    } else if (obj && typeof obj.length == "number") {
+      // convert nodeList to array
+      for (var i = 0; i < obj.length; i++) {
+        ary.push(obj[i]);
+      }
+    } else {
+      // array of single index
+      ary.push(obj);
+    }
+    return ary;
+  }
+
+  // get array of elements
+  function querySelect(selector, elem) {
+    elem = elem || document;
+    var elems = elem.querySelectorAll(selector);
+    return makeArray(elems);
+  }
+
+  function getQueryElement(elem) {
+    if (typeof elem == "string") {
+      elem = document.querySelector(elem);
+    }
+    return elem;
+  }
+
+  function docReady(onReady) {
+    if (document.readyState == "complete") {
+      onReady();
+      return;
+    }
+    document.addEventListener("DOMContentLoaded", onReady);
+  }
+
+  // -------------------------- end -------------------------- //
+
+  return Colcade;
+});
+
+function dispatchToChildActor(name, detail) {
+  let evt = { bubbles: true };
+  if (detail) {
+    evt.detail = detail;
+  }
+  document.dispatchEvent(new CustomEvent(name, evt));
+}
+window.addEventListener("DOMContentLoaded", function() {
+  dispatchToChildActor("SecondaryBrowserContentLoaded");
+});
+
+document.querySelector("#close").addEventListener("click", () => {
+  dispatchToChildActor("SecondaryBrowserClose");
+});
+document.querySelector("#minmax").addEventListener("click", () => {
+  dispatchToChildActor("SecondaryBrowserMinMax");
+});
+
+function buildImages(images) {
+  let fullGrid = document.querySelector("#full-image-grid");
+  let iconGrid = document.querySelector("#icon-image-grid");
+  fullGrid.innerHTML = iconGrid.innerHTML = `
+  <div class="image-grid-col image-grid-col--1"></div>
+  <div class="image-grid-col image-grid-col--2"></div>
+  <div class="image-grid-col image-grid-col--3"></div>
+  <div class="image-grid-col image-grid-col--4"></div>`;
+
+  for (let image of images) {
+    let item = document.createElement("div");
+    item.classList.add("image-grid-item");
+    let overlay = document.createElement("div");
+    overlay.classList.add("image-grid-controls");
+    let downloadButton = document.createElement("button");
+    downloadButton.textContent = "↓";
+    overlay.append(downloadButton);
+    item.append(overlay);
+    let img = document.createElement("img");
+    // XXX: We may be able to directly render an imgIRequest without needing to re-fetch
+    img.src = image.finalURI;
+    img.dataset.producerId = image.producerId;
+    img.onclick = function(e) {
+      dispatchToChildActor("SecondaryBrowserContentEvent", {
+        producerId: e.target.dataset.producerId,
+      });
+    };
+    // if (image.width && image.height) {
+    // item.style.width = `${image.width}px`;
+    // item.style.height = `${image.height}px`;
+    // img.width = image.width;
+    // img.height = image.height;
+    // }
+    item.append(img);
+    if (
+      image.width &&
+      image.height &&
+      (image.width <= 48 || image.height <= 48)
+    ) {
+      iconGrid.append(item);
+    } else {
+      fullGrid.append(item);
+    }
+  }
+
+  let fullGridColcade = new Colcade(fullGrid, {
+    columns: ".image-grid-col",
+    items: ".image-grid-item",
+  });
+
+  let iconGridColcade = new Colcade(iconGrid, {
+    columns: ".image-grid-col",
+    items: ".image-grid-item",
+  });
+}
+window.addEventListener("SecondaryBrowserChromeToContent", event => {
+  console.log("SecondaryBrowserChromeToContent", event.detail);
+  switch (event.detail.messageType) {
+    case "TrackedImages": {
+      buildImages(event.detail.value);
+
+      break;
+    }
+    case "DOMTree": {
+      let frameDoc = document.querySelector("#outline-output").contentDocument;
+
+      function createElement(node) {
+        if (typeof node === "string") {
+          return frameDoc.createTextNode(node);
+        }
+        const $el = frameDoc.createElement(node.tag);
+        for (let attr in node.attributes) {
+          $el.setAttribute(attr, node.attributes[attr]);
+        }
+
+        // if (node.size) {
+        //   $el.style.width = node.size.width;
+        //   $el.style.height = node.size.height;
+        //   $el.style.left = node.size.left;
+        //   $el.style.right = node.size.right;
+        // }
+
+        node.children.map(createElement).forEach($el.appendChild.bind($el));
+        return $el;
+      }
+      let docElemTree = event.detail.value;
+      let bodyTree = event.detail.value.children.filter(n => n.tag == "body")[0];
+      let newBody = createElement(bodyTree);
+      // Don't replace docElement, just set attrs
+      for (let attr in docElemTree.attributes) {
+        frameDoc.documentElement.setAttribute(
+          attr,
+          docElemTree.attributes[attr]
+        );
+        frameDoc.documentElement.style.width = docElemTree.size.width;
+        frameDoc.documentElement.style.height = docElemTree.size.height;
+      }
+      frameDoc.body.parentNode.replaceChild(newBody, frameDoc.body);
+
+      // frameDoc.body.append(createElement({type: "div"}));
+      // frameDoc.body.append(`${event.detail.value.children.length} children`);
+
+      // document.querySelector("#outline-output").textContent = JSON.stringify(
+      //   event.detail.value
+      // );
+
+      break;
+    }
+  }
+});
diff --git a/browser/components/secondarybrowser/moz.build b/browser/components/secondarybrowser/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/components/secondarybrowser/moz.build
@@ -0,0 +1,15 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ['content/jar.mn']
+
+#EXTRA_JS_MODULES += [
+#]
+
+FINAL_TARGET_FILES.actors += [
+    'SecondaryBrowserChild.jsm',
+    'SecondaryBrowserParent.jsm',
+]
diff --git a/browser/themes/shared/urlbar-searchbar.inc.css b/browser/themes/shared/urlbar-searchbar.inc.css
--- a/browser/themes/shared/urlbar-searchbar.inc.css
+++ b/browser/themes/shared/urlbar-searchbar.inc.css
@@ -693,16 +693,23 @@
   mask-image: linear-gradient(to right, transparent, black 3ch);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input {
   mask-position-x: calc(var(--cfr-label-width) * -1);
 }
 #urlbar[cfr-recommendation-state="expanded"] #urlbar-input:-moz-locale-dir(rtl) {
   mask-position-x: calc(var(--cfr-label-width));
 }
+#secondary-browser-button {
+  list-style-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMHB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxOCAyMCIgd2lkdGg9IjE4cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZXNjLz48ZGVmcy8+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSI+PGcgZmlsbD0iIzAwMDAwMCIgaWQ9IkNvcmUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjAwMDAwMCwgLTIuMDAwMDAwKSI+PGcgaWQ9ImFjY2Vzc2liaWxpdHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAyLjAwMDAwMCkiPjxwYXRoIGQ9Ik05LDAgQzEwLjEsMCAxMSwwLjkgMTEsMiBDMTEsMy4xIDEwLjEsNCA5LDQgQzcuOSw0IDcsMy4xIDcsMiBDNywwLjkgNy45LDAgOSwwIEw5LDAgWiBNMTgsNyBMMTIsNyBMMTIsMjAgTDEwLDIwIEwxMCwxNCBMOCwxNCBMOCwyMCBMNiwyMCBMNiw3IEwwLDcgTDAsNSBMMTgsNSBMMTgsNyBMMTgsNyBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=);
+}
+#secondary-browser-button[readeractive] {
+  background: var(--toolbarbutton-icon-fill-attention);
+  background: rgb(159, 200, 213);
+}
 
 /* Reader mode icon */
 
 #reader-mode-button {
   list-style-image: url(chrome://browser/skin/readerMode.svg);
 }
 
 #reader-mode-button[readeractive] {
diff --git a/dom/base/ImageTracker.cpp b/dom/base/ImageTracker.cpp
--- a/dom/base/ImageTracker.cpp
+++ b/dom/base/ImageTracker.cpp
@@ -136,16 +136,23 @@ void ImageTracker::SetAnimatingState(boo
 }
 
 void ImageTracker::RequestDiscardAll() {
   for (auto iter = mImages.Iter(); !iter.Done(); iter.Next()) {
     iter.Key()->RequestDiscard();
   }
 }
 
+void ImageTracker::GetTrackedImages(nsTArray<RefPtr<imgIRequest> >& images) {
+  for (auto iter = mImages.Iter(); !iter.Done(); iter.Next()) {
+    imgIRequest* req = iter.Key();
+    images.AppendElement(req);
+  }
+}
+
 void ImageTracker::MediaFeatureValuesChangedAllDocuments(
     const MediaFeatureChange& aChange) {
   // Inform every content image used in the document that media feature values
   // have changed.  If the same image is used in multiple places, then we can
   // end up informing them multiple times.  Theme changes are rare though and we
   // don't bother trying to ensure we only do this once per image.
   //
   // Pull the images out into an array and iterate over them, in case the
diff --git a/dom/base/ImageTracker.h b/dom/base/ImageTracker.h
--- a/dom/base/ImageTracker.h
+++ b/dom/base/ImageTracker.h
@@ -53,16 +53,18 @@ class ImageTracker {
   // Makes the images on this document capable of having their animation
   // active or suspended. An Image will animate as long as at least one of its
   // owning Documents needs it to animate; otherwise it can suspend.
   void SetAnimatingState(bool aAnimating);
 
   void RequestDiscardAll();
   void MediaFeatureValuesChangedAllDocuments(const MediaFeatureChange&);
 
+  void GetTrackedImages(nsTArray<RefPtr<imgIRequest> >& images);
+
  private:
   ~ImageTracker();
 
   nsDataHashtable<nsPtrHashKey<imgIRequest>, uint32_t> mImages;
   bool mLocking;
   bool mAnimating;
 };
 
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -33,16 +33,18 @@
 #include "ClientLayerManager.h"
 #include "nsQueryObject.h"
 #include "CubebDeviceEnumerator.h"
 
 #include "nsIScrollableFrame.h"
 
 #include "nsContentUtils.h"
 
+#include "imgIRequest.h"
+
 #include "nsIFrame.h"
 #include "nsIWidget.h"
 #include "nsCharsetSource.h"
 #include "nsJSEnvironment.h"
 #include "nsJSUtils.h"
 
 #include "mozilla/ChaosMode.h"
 #include "mozilla/CheckedInt.h"
@@ -70,16 +72,17 @@
 
 #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK)
 #  include <gdk/gdk.h>
 #  include <gdk/gdkx.h>
 #endif
 
 #include "Layers.h"
 
+#include "mozilla/dom/ImageTracker.h"
 #include "mozilla/dom/AudioDeviceInfo.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/BrowserChild.h"
 #include "mozilla/dom/IDBFactoryBinding.h"
 #include "mozilla/dom/IDBMutableFileBinding.h"
 #include "mozilla/dom/IDBMutableFile.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
@@ -401,16 +404,26 @@ nsDOMWindowUtils::GetViewportInfo(uint32
   CSSIntSize size = gfx::RoundedToInt(info.GetSize());
   *aWidth = size.width;
   *aHeight = size.height;
   *aAutoSize = info.IsAutoSizeEnabled();
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsDOMWindowUtils::GetTrackedImages(nsTArray<RefPtr<imgIRequest> >& images) {
+  nsCOMPtr<Document> doc = GetDocument();
+  if (doc) {
+    doc->ImageTracker()->GetTrackedImages(images);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsDOMWindowUtils::GetViewportFitInfo(nsAString& aViewportFit) {
   Document* doc = GetDocument();
   NS_ENSURE_STATE(doc);
 
   ViewportMetaData metaData = doc->GetViewportMetaData();
   if (metaData.mViewportFit.EqualsLiteral("contain")) {
     aViewportFit.AssignLiteral("contain");
   } else if (metaData.mViewportFit.EqualsLiteral("cover")) {
@@ -2262,16 +2275,17 @@ nsDOMWindowUtils::StartFrameTimeRecordin
       Preferences::GetUint("toolkit.framesRecording.bufferSize", uint32_t(0));
   bufferSize = std::min(bufferSize, kRecordingMaxSize);
   bufferSize = std::max(bufferSize, kRecordingMinSize);
   *startIndex = mgr->StartFrameTimeRecording(bufferSize);
 
   return NS_OK;
 }
 
+
 NS_IMETHODIMP
 nsDOMWindowUtils::StopFrameTimeRecording(uint32_t startIndex,
                                          nsTArray<float>& frameIntervals) {
   nsCOMPtr<nsIWidget> widget = GetWidget();
   if (!widget) return NS_ERROR_FAILURE;
 
   LayerManager* mgr = widget->GetLayerManager();
   if (!mgr) return NS_ERROR_FAILURE;
diff --git a/dom/interfaces/base/nsIDOMWindowUtils.idl b/dom/interfaces/base/nsIDOMWindowUtils.idl
--- a/dom/interfaces/base/nsIDOMWindowUtils.idl
+++ b/dom/interfaces/base/nsIDOMWindowUtils.idl
@@ -37,16 +37,17 @@ interface nsIQueryContentEventResult;
 interface nsIDOMWindow;
 interface nsIFile;
 interface nsIURI;
 interface nsIRunnable;
 interface nsITranslationNodeList;
 interface nsIJSRAIIHelper;
 interface nsIContentPermissionRequest;
 interface nsIObserver;
+interface imgIRequest;
 
 webidl Animation;
 webidl DOMRect;
 webidl Element;
 webidl EventTarget;
 webidl Event;
 webidl Node;
 webidl NodeList;
@@ -116,16 +117,18 @@ interface nsIDOMWindowUtils : nsISupport
                        out uint32_t aWidth, out uint32_t aHeight,
                        out boolean aAutoSize);
   /*
    * Information retrieved from the viewport-fit value of <meta name="viewport">
    * element.
    */
   AString getViewportFitInfo();
 
+  Array<imgIRequest> getTrackedImages();
+
   /**
    * Information about the window size in device pixels.
    */
   void getContentViewerSize(out uint32_t aDisplayWidth, out uint32_t aDisplayHeight);
 
   /**
    * For any scrollable element, this allows you to override the
    * visible region and draw more than what is visible, which is
diff --git a/dom/media/webvtt/WebVTTParserWrapper.jsm b/dom/media/webvtt/WebVTTParserWrapper.jsm
--- a/dom/media/webvtt/WebVTTParserWrapper.jsm
+++ b/dom/media/webvtt/WebVTTParserWrapper.jsm
@@ -1,24 +1,30 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const { WebVTT } = ChromeUtils.import("resource://gre/modules/vtt.jsm");
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 function WebVTTParserWrapper() {
   // Nothing
 }
 
 WebVTTParserWrapper.prototype = {
   loadParser(window) {
+    // console.log(window.location.toString(), Services.appinfo.processID);
     this.parser = new WebVTT.Parser(window, new TextDecoder("utf8"));
+    // this.parser.onflush = () => {
+    //   console.trace("Flush", window.location.toString(), this.parser.buffer);
+    // };
   },
 
   parse(data) {
+    console.trace("Parse", data);
     // We can safely translate the string data to a Uint8Array as we are
     // guaranteed character codes only from \u0000 => \u00ff
     var buffer = new Uint8Array(data.length);
     for (var i = 0; i < data.length; i++) {
       buffer[i] = data.charCodeAt(i);
     }
 
     this.parser.parse(buffer);
diff --git a/toolkit/actors/SelectParent.jsm b/toolkit/actors/SelectParent.jsm
--- a/toolkit/actors/SelectParent.jsm
+++ b/toolkit/actors/SelectParent.jsm
@@ -555,23 +555,26 @@ var SelectParentHelper = {
         }
       }
     }
 
     if (parentElement && ariaOwns) {
       parentElement.setAttribute("aria-owns", ariaOwns);
     }
 
+    // XXX: Pass in whether we are opening for a secondary browser. In the meantime
+    // we'll just enable search everywhere.add-a-comment
     // Check if search pref is enabled, if this is the first time iterating through
     // the dropdown, and if the list is long enough for a search element to be added.
-    if (
-      Services.prefs.getBoolPref("dom.forms.selectSearch") &&
-      addSearch &&
-      element.childElementCount > SEARCH_MINIMUM_ELEMENTS
-    ) {
+    if (true) {
+      // if (
+      //   Services.prefs.getBoolPref("dom.forms.selectSearch") &&
+      //   addSearch &&
+      //   element.childElementCount > SEARCH_MINIMUM_ELEMENTS
+      // ) {
       // Add a search text field as the first element of the dropdown
       let searchbox = element.ownerDocument.createXULElement("search-textbox");
       searchbox.className = "contentSelectDropdown-searchbox";
       searchbox.addEventListener("input", this.onSearchInput);
       searchbox.addEventListener("focus", this.onSearchFocus.bind(this));
       searchbox.addEventListener("blur", this.onSearchBlur);
       searchbox.addEventListener("command", this.onSearchInput);
 
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -455,18 +455,78 @@
         if (this.isRemoteBrowser) {
           this._documentContentType = aContentType;
         } else {
           this.contentDocument.documentContentType = aContentType;
         }
       }
     }
 
+    createSecondaryBrowser() {
+      if (!this.secondaryBrowser) {
+        this.secondaryBrowser = document.createXULElement("browser");
+        this.secondaryBrowser.classList.add("secondarybrowser");
+        this.secondaryBrowser.setAttribute("disablehistory", "true");
+        this.secondaryBrowser.setAttribute("nodefaultsrc", "true");
+        this.secondaryBrowser.setAttribute(
+          "remoteType",
+          this.getAttribute("remoteType")
+        );
+        this.secondaryBrowser.setAttribute(
+          "remote",
+          this.getAttribute("remote")
+        );
+        this.secondaryBrowser.setAttribute("type", "content");
+        this.secondaryBrowser.setAttribute(
+          "contextmenu",
+          this.getAttribute("contextmenu")
+        );
+        this.secondaryBrowser.setAttribute(
+          "datetimepicker",
+          this.getAttribute("datetimepicker")
+        );
+        this.secondaryBrowser.setAttribute(
+          "selectmenulist",
+          this.getAttribute("selectmenulist")
+        );
+        this.secondaryBrowser.setAttribute(
+          "tooltip",
+          this.getAttribute("tooltip")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autocompletepopup",
+          this.getAttribute("autocompletepopup")
+        );
+        this.secondaryBrowser.setAttribute(
+          "autoscrollpopup",
+          this.getAttribute("autoscrollpopup")
+        );
+        this.secondaryBrowser.setAttribute("message", "true");
+        this.secondaryBrowser.setAttribute(
+          "messagemanagergroup",
+          "secondarybrowsers"
+        );
+
+        this.secondaryBrowser.sameProcessAsFrameLoader = this.frameLoader;
+        this.secondaryBrowser.hostBrowser = this;
+        this.secondaryBrowser.src = "chrome://browser/content/secondarybrowser/secondaryui.html";
+        // XXX if we load "about:secondarybrowser" we get
+        // Security Error: Content at about:secondarybrowser may not load or link to chrome://mozapps/content/extensions/aboutaddons.css.
+
+      }
+      return this.secondaryBrowser;
+    }
+
     set sameProcessAsFrameLoader(val) {
       this._sameProcessAsFrameLoader = Cu.getWeakReference(val);
+      if (this.secondaryBrowser) {
+        this.secondaryBrowser.sameProcessAsFrameLoader = Cu.getWeakReference(
+          val
+        );
+      }
     }
 
     get sameProcessAsFrameLoader() {
       return (
         this._sameProcessAsFrameLoader && this._sameProcessAsFrameLoader.get()
       );
     }
 
@@ -1291,25 +1351,41 @@
         // our RemoteWebProgress or its associated manager, but we'll need to
         // add the progress listeners to the new non-remote WebProgress.
         this._remoteWebProgressManager = null;
         this._remoteWebProgress = null;
         this.restoreProgressListeners();
 
         this.addEventListener("pagehide", this.onPageHide, true);
       }
+
+      if (this.hadsecondaryBrowser) {
+        this.hadsecondaryBrowser = false;
+        this.before(this.createSecondaryBrowser());
+      }
     }
 
+    destroySecondaryBrowser() {
+      if (this.secondaryBrowser) {
+        this.hadsecondaryBrowser = true;
+        this.secondaryBrowser.remove();
+        this.secondaryBrowser = null;
+      }
+    }
     /**
      * This is necessary because the destructor doesn't always get called when
      * we are removed from a tabbrowser. This will be explicitly called by tabbrowser.
      */
     destroy() {
       elementsToDestroyOnUnload.delete(this);
 
+      // Just remove the secondarybrowser browser entirely and let it get recreated
+      // when we are re-added (i.e. with a remoteness change)
+      this.destroySecondaryBrowser();
+
       // Make sure that any open select is closed.
       if (this.hasAttribute("selectmenulist")) {
         let menulist = document.getElementById(
           this.getAttribute("selectmenulist")
         );
         if (menulist && menulist.open) {
           let resourcePath = "resource://gre/actors/SelectParent.jsm";
           let { SelectParentHelper } = ChromeUtils.import(resourcePath);
@@ -1990,17 +2066,23 @@
 
       function sendToChildren(browsingContext, childScope) {
         let windowGlobal = browsingContext.currentWindowGlobal;
         // If 'roots' is set, only send if windowGlobal.isProcessRoot is true.
         if (
           windowGlobal &&
           (childScope != "roots" || windowGlobal.isProcessRoot)
         ) {
-          windowGlobal.getActor(actorName).sendAsyncMessage(messageName, args);
+          try {
+            windowGlobal
+              .getActor(actorName)
+              .sendAsyncMessage(messageName, args);
+          } catch (e) {
+            console.log(actorName, messageName, e);
+          }
         }
 
         // Iterate as long as scope in assigned. Note that we use the original
         // passed in scope, not childScope here.
         if (scope) {
           for (let context of browsingContext.children) {
             sendToChildren(context, scope);
           }
diff --git a/toolkit/modules/ActorManagerParent.jsm b/toolkit/modules/ActorManagerParent.jsm
--- a/toolkit/modules/ActorManagerParent.jsm
+++ b/toolkit/modules/ActorManagerParent.jsm
@@ -186,17 +186,17 @@ let JSWINDOWACTORS = {
     child: {
       moduleURI: "resource://gre/actors/FindBarChild.jsm",
       events: {
         keypress: { mozSystemGroup: true },
       },
     },
 
     allFrames: true,
-    messageManagerGroups: ["browsers", "test"],
+    messageManagerGroups: ["browsers", "test", "secondarybrowsers"],
   },
 
   // This is the actor that responds to requests from the find toolbar and
   // searches for matches and highlights them.
   Finder: {
     child: {
       moduleURI: "resource://gre/actors/FinderChild.jsm",
     },
