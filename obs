# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  89034ef614c4d449b44a6880b1dc3aea3d8a1d9e

diff --git a/toolkit/content/widgets/browser.js b/toolkit/content/widgets/browser.js
--- a/toolkit/content/widgets/browser.js
+++ b/toolkit/content/widgets/browser.js
@@ -5,16 +5,38 @@
 "use strict";
 
 {
 
 class MozBrowser extends XULFrameElement {
 
   constructor() {
     super();
+
+    var t = this;
+    this.observer = {
+      observe(aSubject, aTopic, aState) {
+        console.log("observe", aSubject);
+        if (aTopic == "browser:purge-session-history") {
+          t.purgeSessionHistory();
+        } else if (aTopic == "apz:cancel-autoscroll") {
+          if (aState == t._autoScrollScrollId) {
+            // Set this._autoScrollScrollId to null, so in stopScroll() we
+            // don't call stopApzAutoscroll() (since it's APZ that
+            // initiated the stopping).
+            t._autoScrollScrollId = null;
+            t._autoScrollPresShellId = null;
+            t._autoScrollPopup.hidePopup();
+          }
+        }
+      },
+      QueryInterface: ChromeUtils.generateQI([Ci.nsIObserver,
+        Ci.nsISupportsWeakReference]),
+    };
+
     // Remote browsers override webNavigation. Store the normal XULFrameElement
     // webNavigation so it can be returned for non-remote browsers.
     this._webNavigation = this.__lookupGetter__("webNavigation");
     Object.defineProperty(this, 'webNavigation', {
       get() {
         if (this.isRemoteBrowser) {
           return this._remoteWebNavigation;
         }
@@ -196,17 +218,17 @@ class MozBrowser extends XULFrameElement
     this.messageManager.loadFrameScript("chrome://global/content/browser-child.js", true);
 
     if (this.hasAttribute("selectmenulist")) {
       this.messageManager.addMessageListener("Forms:ShowDropDown", this);
       this.messageManager.addMessageListener("Forms:HideDropDown", this);
     }
 
     if (!this.hasAttribute("disablehistory")) {
-      Services.obs.addObserver(this, "browser:purge-session-history", true);
+      Services.obs.addObserver(this.observer, "browser:purge-session-history", true);
     }
 
     let rc_js = "resource://gre/modules/RemoteController.js";
     let scope = {};
     Services.scriptloader.loadSubScript(rc_js, scope);
     let RemoteController = scope.RemoteController;
     this._controller = new RemoteController(this);
     this.controllers.appendController(this._controller);
@@ -217,17 +239,17 @@ class MozBrowser extends XULFrameElement
   setupNonRemoteBrowser() {
     try {
       // |webNavigation.sessionHistory| will have been set by the frame
       // loader when creating the docShell as long as this xul:browser
       // doesn't have the 'disablehistory' attribute set.
       if (this.docShell && this.webNavigation.sessionHistory) {
         var os = Cc["@mozilla.org/observer-service;1"]
           .getService(Ci.nsIObserverService);
-        os.addObserver(this, "browser:purge-session-history", true);
+        os.addObserver(this.observer, "browser:purge-session-history", true);
 
         // enable global history if we weren't told otherwise
         if (!this.hasAttribute("disableglobalhistory") && !this.isRemoteBrowser) {
           try {
             this.docShell.useGlobalHistory = true;
           } catch (ex) {
             // This can occur if the Places database is locked
             Cu.reportError("Error enabling browser global history: " + ex);
@@ -988,29 +1010,29 @@ class MozBrowser extends XULFrameElement
       } catch (ex) {
         // This can fail when this browser element is not attached to a
         // BrowserDOMWindow.
       }
 
       if (!this.hasAttribute("disablehistory")) {
         let Services = ChromeUtils.import("resource://gre/modules/Services.jsm", {}).Services;
         try {
-          Services.obs.removeObserver(this, "browser:purge-session-history");
+          Services.obs.removeObserver(this.observer, "browser:purge-session-history");
         } catch (ex) {
           // It's not clear why this sometimes throws an exception.
         }
       }
       return;
     }
 
     if (this.docShell && this.webNavigation.sessionHistory) {
       var os = Cc["@mozilla.org/observer-service;1"]
         .getService(Ci.nsIObserverService);
       try {
-        os.removeObserver(this, "browser:purge-session-history");
+        os.removeObserver(this.observer, "browser:purge-session-history");
       } catch (ex) {
         // It's not clear why this sometimes throws an exception.
       }
     }
 
     this._fastFind = null;
     this._webBrowserFind = null;
 
@@ -1057,17 +1079,17 @@ class MozBrowser extends XULFrameElement
             this.mPrefs.getBoolPref("apz.autoscroll.enabled", false)) {
             let { tabParent } = this.frameLoader;
             if (tabParent) {
               // If APZ is handling the autoscroll, it may decide to cancel
               // it of its own accord, so register an observer to allow it
               // to notify us of that.
               var os = Cc["@mozilla.org/observer-service;1"]
                 .getService(Ci.nsIObserverService);
-              os.addObserver(this, "apz:cancel-autoscroll", true);
+              os.addObserver(this.observer, "apz:cancel-autoscroll", true);
 
               usingApz = tabParent.startApzAutoscroll(
                 data.screenX, data.screenY,
                 data.scrollId, data.presShellId);
             }
             // Save the IDs for later
             this._autoScrollScrollId = data.scrollId;
             this._autoScrollPresShellId = data.presShellId;
@@ -1215,32 +1237,16 @@ class MozBrowser extends XULFrameElement
       }
 
       if (!handledByRemote) {
         return this._receiveMessage(aMessage);
       }
     }
   }
 
-  observe(aSubject, aTopic, aState) {
-    if (aTopic == "browser:purge-session-history") {
-      this.purgeSessionHistory();
-    } else if (aTopic == "apz:cancel-autoscroll") {
-      if (aState == this._autoScrollScrollId) {
-        // Set this._autoScrollScrollId to null, so in stopScroll() we
-        // don't call stopApzAutoscroll() (since it's APZ that
-        // initiated the stopping).
-        this._autoScrollScrollId = null;
-        this._autoScrollPresShellId = null;
-
-        this._autoScrollPopup.hidePopup();
-      }
-    }
-  }
-
   purgeSessionHistory() {
     if (this.isRemoteBrowser) {
       try {
         this.messageManager.sendAsyncMessage("Browser:PurgeSessionHistory");
       } catch (ex) {
         // This can throw if the browser has started to go away.
         if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {
           throw ex;
@@ -1280,17 +1286,17 @@ class MozBrowser extends XULFrameElement
       window.removeEventListener("keydown", this, true);
       window.removeEventListener("keypress", this, true);
       window.removeEventListener("keyup", this, true);
       this.messageManager.sendAsyncMessage("Autoscroll:Stop");
 
       var os = Cc["@mozilla.org/observer-service;1"]
         .getService(Ci.nsIObserverService);
       try {
-        os.removeObserver(this, "apz:cancel-autoscroll");
+        os.removeObserver(this.observer, "apz:cancel-autoscroll");
       } catch (ex) {
         // It's not clear why this sometimes throws an exception
       }
 
       if (this.isRemoteBrowser && this._autoScrollScrollId != null) {
         let { tabParent } = this.frameLoader;
         if (tabParent) {
           tabParent.stopApzAutoscroll(this._autoScrollScrollId,
