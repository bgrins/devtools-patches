# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a3e675a3b10a0ea289c301bedc31866f3daf7875
Bug 1386410

diff --git a/devtools/client/framework/target.js b/devtools/client/framework/target.js
--- a/devtools/client/framework/target.js
+++ b/devtools/client/framework/target.js
@@ -637,50 +637,56 @@ TabTarget.prototype = {
 
   /**
    * Target is not alive anymore.
    */
   destroy: function () {
     // If several things call destroy then we give them all the same
     // destruction promise so we're sure to destroy only once
     if (this._destroyer) {
+      console.log("Target: Returning existing destroy");
       return this._destroyer.promise;
     }
 
     this._destroyer = defer();
 
     // Before taking any action, notify listeners that destruction is imminent.
     this.emit("close");
 
+      console.log("Target: before teardown");
     if (this._tab) {
       this._teardownListeners();
     }
 
+      console.log("Target: after teardown");
     let cleanupAndResolve = () => {
+      console.log("Target: cleanupAndResolve");
       this._cleanup();
       this._destroyer.resolve(null);
     };
     // If this target was not remoted, the promise will be resolved before the
     // function returns.
     if (this._tab && !this._client) {
       cleanupAndResolve();
     } else if (this._client) {
       // If, on the other hand, this target was remoted, the promise will be
       // resolved after the remote connection is closed.
       this._teardownRemoteListeners();
 
       if (this.isLocalTab) {
+      console.log("Target: Closing local tab");
         // We started with a local tab and created the client ourselves, so we
         // should close it.
         this._client.close().then(cleanupAndResolve);
       } else if (this.activeTab) {
         // The client was handed to us, so we are not responsible for closing
         // it. We just need to detach from the tab, if already attached.
         // |detach| may fail if the connection is already dead, so proceed with
         // cleanup directly after this.
+      console.log("Target: Closing activeTab");
         this.activeTab.detach();
         cleanupAndResolve();
       } else {
         cleanupAndResolve();
       }
     }
 
     return this._destroyer.promise;
diff --git a/devtools/client/framework/test/browser_toolbox_custom_host.js b/devtools/client/framework/test/browser_toolbox_custom_host.js
--- a/devtools/client/framework/test/browser_toolbox_custom_host.js
+++ b/devtools/client/framework/test/browser_toolbox_custom_host.js
@@ -1,15 +1,21 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URL = "data:text/html,test custom host";
 
+// Use the new webconsole since the old one is triggering a  isn't working on new one (Bug 1304794)
+// Services.prefs.setBoolPref("devtools.webconsole.new-frontend-enabled", false);
+// registerCleanupFunction(function* () {
+//   Services.prefs.clearUserPref("devtools.webconsole.new-frontend-enabled");
+// });
+
 function test() {
   let {Toolbox} = require("devtools/client/framework/toolbox");
 
   let toolbox, iframe, target;
 
   window.addEventListener("message", onMessage);
 
   iframe = document.createElement("iframe");
@@ -25,33 +31,35 @@ function test() {
 
   function onMessage(event) {
     if (typeof(event.data) !== "string") {
       return;
     }
     info("onMessage: " + event.data);
     let json = JSON.parse(event.data);
     if (json.name == "toolbox-close") {
-      ok("Got the `toolbox-close` message");
+      ok(true, "Got the `toolbox-close` message");
       window.removeEventListener("message", onMessage);
       cleanup();
     }
   }
 
   function testCustomHost(t) {
     toolbox = t;
     is(toolbox.win.top, window, "Toolbox is included in browser.xul");
     is(toolbox.doc, iframe.contentDocument, "Toolbox is in the custom iframe");
     executeSoon(() => gBrowser.removeCurrentTab());
   }
 
   function cleanup() {
     iframe.remove();
 
+    info("IFRAME GONE");
     // Even if we received "toolbox-close", the toolbox may still be destroying
     // toolbox.destroy() returns a singleton promise that ensures
     // everything is cleaned up before proceeding.
     toolbox.destroy().then(() => {
+    info("TOOLBOX GONE");
       toolbox = iframe = target = null;
       finish();
     });
   }
 }
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -2342,69 +2342,81 @@ Toolbox.prototype = {
   },
 
   /**
    * Remove all UI elements, detach from target and clear up
    */
   destroy: function () {
     // If several things call destroy then we give them all the same
     // destruction promise so we're sure to destroy only once
+      console.log("Destroying 0");
     if (this._destroyer) {
+      console.log("Destroying 1");
       return this._destroyer;
     }
     let deferred = defer();
     this._destroyer = deferred.promise;
 
+      console.log("Destroying 1.0");
     this.emit("destroy");
 
+      console.log("Destroying 1.1");
     this._target.off("inspect-object", this._onInspectObject);
     this._target.off("navigate", this._refreshHostTitle);
     this._target.off("frame-update", this._updateFrames);
+      console.log("Destroying 1.2");
     this.off("select", this._refreshHostTitle);
     this.off("host-changed", this._refreshHostTitle);
     this.off("ready", this._showDevEditionPromo);
+      console.log("Destroying 1.3");
 
     gDevTools.off("tool-registered", this._toolRegistered);
     gDevTools.off("tool-unregistered", this._toolUnregistered);
+      console.log("Destroying 1.4");
 
     Services.prefs.removeObserver("devtools.cache.disabled", this._applyCacheSettings);
     Services.prefs.removeObserver("devtools.serviceWorkers.testing.enabled",
                                   this._applyServiceWorkersTestingSettings);
+      console.log("Destroying 1.5");
 
     this._lastFocusedElement = null;
 
+      console.log("Destroying 2");
     if (this._sourceMapURLService) {
       this._sourceMapURLService.destroy();
       this._sourceMapURLService = null;
     }
 
     if (this._sourceMapService) {
+      console.log("Destroying 2.0");
       this._sourceMapService.stopSourceMapWorker();
       this._sourceMapService = null;
     }
 
     if (this.webconsolePanel) {
       this._saveSplitConsoleHeight();
       this.webconsolePanel.removeEventListener("resize",
         this._saveSplitConsoleHeight);
       this.webconsolePanel = null;
+      console.log("Destroying 2.1");
     }
     if (this.textBoxContextMenuPopup) {
       this.textBoxContextMenuPopup.removeEventListener("popupshowing",
         this._updateTextBoxMenuItems, true);
       this.textBoxContextMenuPopup = null;
     }
     if (this._componentMount) {
       this._componentMount.removeEventListener("keypress", this._onToolbarArrowKeypress);
       this.ReactDOM.unmountComponentAtNode(this._componentMount);
       this._componentMount = null;
     }
 
     let outstanding = [];
     for (let [id, panel] of this._toolPanels) {
+      console.log("WAITING FOR", id, panel);
       try {
         gDevTools.emit(id + "-destroy", this, panel);
         this.emit(id + "-destroy", panel);
 
         outstanding.push(panel.destroy());
       } catch (e) {
         // We don't want to stop here if any panel fail to close.
         console.error("Panel " + id + ":", e);
@@ -2451,16 +2463,17 @@ Toolbox.prototype = {
     this._telemetry.destroy();
 
     // Finish all outstanding tasks (which means finish destroying panels and
     // then destroying the host, successfully or not) before destroying the
     // target.
     deferred.resolve(settleAll(outstanding)
         .catch(console.error)
         .then(() => {
+          console.log("OUTSTANDING DONE");
           this._removeHostListeners();
 
           // `location` may already be 'invalid' if the toolbox document is
           // already in process of destruction. Otherwise if it is still
           // around, ensure releasing toolbox document and triggering cleanup
           // thanks to unload event. We do that precisely here, before
           // nullifying the target as various cleanup code depends on the
           // target attribute to be still
@@ -2477,26 +2490,28 @@ Toolbox.prototype = {
           // require to complete.
           if (!this._target) {
             return null;
           }
           let target = this._target;
           this._target = null;
           this.highlighterUtils.release();
           target.off("close", this.destroy);
+          console.log("TARGET DESTROY");
           return target.destroy();
         }, console.error).then(() => {
           this.emit("destroyed");
 
           // Free _host after the call to destroyed in order to let a chance
           // to destroyed listeners to still query toolbox attributes
           this._host = null;
           this._win = null;
           this._toolPanels.clear();
 
+          console.log("ABOUT TO GC");
           // Force GC to prevent long GC pauses when running tests and to free up
           // memory in general when the toolbox is closed.
           if (flags.testing) {
             win.QueryInterface(Ci.nsIInterfaceRequestor)
               .getInterface(Ci.nsIDOMWindowUtils)
               .garbageCollect();
           }
         }).catch(console.error));
diff --git a/devtools/client/preferences/devtools.js b/devtools/client/preferences/devtools.js
--- a/devtools/client/preferences/devtools.js
+++ b/devtools/client/preferences/devtools.js
@@ -309,17 +309,17 @@ pref("devtools.webconsole.persistlog", f
 pref("devtools.webconsole.timestampMessages", false);
 
 // Web Console automatic multiline mode: |true| if you want incomplete statements
 // to automatically trigger multiline editing (equivalent to shift + enter).
 pref("devtools.webconsole.autoMultiline", true);
 
 // Enable the new webconsole frontend
 #if defined(NIGHTLY_BUILD) || defined(MOZ_DEV_EDITION)
-pref("devtools.webconsole.new-frontend-enabled", true);
+pref("devtools.webconsole.new-frontend-enabled", false);
 #else
 pref("devtools.webconsole.new-frontend-enabled", false);
 #endif
 
 // Enable client-side mapping service for source maps
 pref("devtools.source-map.client-service.enabled", true);
 
 // The number of lines that are displayed in the web console.
diff --git a/devtools/client/webconsole/panel.js b/devtools/client/webconsole/panel.js
--- a/devtools/client/webconsole/panel.js
+++ b/devtools/client/webconsole/panel.js
@@ -55,34 +55,42 @@ WebConsolePanel.prototype = {
       iframe.addEventListener("load", function () {
         deferredIframe.resolve(null);
       }, {capture: true, once: true});
     }
 
     // Local debugging needs to make the target remote.
     let promiseTarget;
     if (!this.target.isRemote) {
+      console.log("Target isn't remote");
       promiseTarget = this.target.makeRemote();
     } else {
+      console.log("Target is remote");
       promiseTarget = promise.resolve(this.target);
     }
 
     // 1. Wait for the iframe to load.
     // 2. Wait for the remote target.
     // 3. Open the Web Console.
     return deferredIframe.promise
       .then(() => promiseTarget)
       .then((target) => {
         this._frameWindow._remoteTarget = target;
 
         let webConsoleUIWindow = iframe.contentWindow.wrappedJSObject;
         let chromeWindow = iframe.ownerDocument.defaultView;
         return HUDService.openWebConsole(this.target, webConsoleUIWindow,
                                          chromeWindow);
       })
+      // .then(() => {
+      //   return new Promise(resolve => {
+
+      //     setTimeout(resolve, 5000);
+      //   })
+      // })
       .then((webConsole) => {
         this.hud = webConsole;
         this._isReady = true;
         this.emit("ready");
         return this;
       }, (reason) => {
         let msg = "WebConsolePanel open failed. " +
                   reason.error + ": " + reason.message;
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -2706,16 +2706,17 @@ WebConsoleFrame.prototype = {
    *         destroyed.
    */
   destroy: function () {
     if (this._destroyer) {
       return this._destroyer.promise;
     }
 
     this._destroyer = promise.defer();
+    console.log("WEBCONSOLE DESTROYER");
 
     let toolbox = gDevTools.getToolbox(this.owner.target);
     if (toolbox) {
       toolbox.off("webconsole-selected", this._onPanelSelected);
     }
 
     this._prefObserver.off(PREF_MESSAGE_TIMESTAMP, this._onToolboxPrefChanged);
     this._prefObserver.destroy();
@@ -2754,20 +2755,22 @@ WebConsoleFrame.prototype = {
     if (this._contextMenuHandler) {
       this._contextMenuHandler.destroy();
       this._contextMenuHandler = null;
     }
 
     this._commandController = null;
 
     let onDestroy = () => {
+    console.log("WEBCONSOLE onDestroy");
       this._destroyer.resolve(null);
     };
 
     if (this.proxy) {
+    console.log("PROXY onDestroy");
       this.proxy.disconnect().then(onDestroy);
       this.proxy = null;
     } else {
       onDestroy();
     }
 
     return this._destroyer.promise;
   },
diff --git a/devtools/shared/client/main.js b/devtools/shared/client/main.js
--- a/devtools/shared/client/main.js
+++ b/devtools/shared/client/main.js
@@ -354,62 +354,72 @@ DebuggerClient.prototype = {
    * @param onClosed function
    *        If specified, will be called when the debugging connection
    *        has been closed. This parameter is deprecated - please use
    *        the returned Promise.
    * @return Promise
    *         Resolves after the underlying transport is closed.
    */
   close: function (onClosed) {
-    let deferred = promise.defer();
+
+    console.trace();
+    if (this._closeDeferred) {
+      console.log("this._closeDeferred already exists", this._closed);
+      return this._closeDeferred.promise;
+    }
+
+    this._closeDeferred = promise.defer();
+    console.log("Client close 0");
     if (onClosed) {
-      deferred.promise.then(onClosed);
+      this._closeDeferred.promise.then(onClosed);
     }
 
     // Disable detach event notifications, because event handlers will be in a
     // cleared scope by the time they run.
     this._eventsEnabled = false;
 
     let cleanup = () => {
       this._transport.close();
       this._transport = null;
     };
+    console.log("Client close 1: ", this._closed);
 
     // If the connection is already closed,
     // there is no need to detach client
     // as we won't be able to send any message.
     if (this._closed) {
       cleanup();
-      deferred.resolve();
-      return deferred.promise;
+      this._closeDeferred.resolve();
+      return this._closeDeferred.promise;
     }
 
-    this.addOneTimeListener("closed", deferred.resolve);
+    this.addOneTimeListener("closed", this._closeDeferred.resolve);
 
     // Call each client's `detach` method by calling
     // lastly registered ones first to give a chance
     // to detach child clients first.
     let clients = [...this._clients.values()];
     this._clients.clear();
     const detachClients = () => {
       let client = clients.pop();
+    console.log("DETACHING CLIENT: ", client, clients.length);
       if (!client) {
         // All clients detached.
         cleanup();
         return;
       }
       if (client.detach) {
         client.detach(detachClients);
         return;
       }
       detachClients();
     };
     detachClients();
 
-    return deferred.promise;
+    return this._closeDeferred.promise;
   },
 
   /*
    * This function exists only to preserve DebuggerClient's interface;
    * new code should say 'client.mainRoot.listTabs()'.
    */
   listTabs: function (onResponse) {
     return this.mainRoot.listTabs(onResponse);
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -653,16 +653,17 @@ WebConsoleClient.prototype = {
    *        Function to invoke when the server response is received.
    */
   detach: function (onResponse) {
     this._client.removeListener("evaluationResult", this.onEvaluationResult);
     this._client.removeListener("networkEvent", this.onNetworkEvent);
     this._client.removeListener("networkEventUpdate",
                                 this.onNetworkEventUpdate);
     this._client.removeListener("inspectObject", this.onInspectObject);
+    console.log("DETACH CALLED", onResponse);
     this.stopListeners(null, onResponse);
     this._longStrings = null;
     this._client = null;
     this.pendingEvaluationResults.clear();
     this.pendingEvaluationResults = null;
     this.clearNetworkRequests();
     this._networkRequests = null;
   },
