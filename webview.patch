# HG changeset patch
# Parent  58bb9946f9ec43c3ffa7931a69b333a67ee6e904

diff --git a/b2g/chrome/content/system-app/js/web-view.js b/b2g/chrome/content/system-app/js/web-view.js
new file mode 100644
--- /dev/null
+++ b/b2g/chrome/content/system-app/js/web-view.js
@@ -0,0 +1,533 @@
+/* eslint-disable quotes */
+"use strict";
+
+// A <web-view> custom element, wrapping a <xul:browser>
+
+(function() {
+  const { Services } = ChromeUtils.import(
+    "resource://gre/modules/Services.jsm"
+  );
+
+  // Use a prefix to help with backward compatibility and ease UI porting.
+  const EVENT_PREFIX = "mozbrowser";
+
+  // The progress listener attached to the webview, managing some events.
+  function ProgressListener(webview) {
+    this.webview = webview;
+  }
+
+  ProgressListener.prototype = {
+    log(msg) {
+      console.log(`<web-view-listener> ${msg}`);
+    },
+
+    error(msg) {
+      console.error(`<web-view-listener> ${msg}`);
+    },
+
+    dispatchEvent(name, detail) {
+      this.log(`dispatching ${EVENT_PREFIX}${name}`);
+      let event = new CustomEvent(`${EVENT_PREFIX}${name}`, {
+        bubbles: true,
+        detail,
+      });
+      this.webview.dispatchEvent(event);
+    },
+
+    QueryInterface: ChromeUtils.generateQI([
+      Ci.nsIWebProgressListener,
+      Ci.nsISupportsWeakReference,
+    ]),
+    seenLoadStart: false,
+    seenLoadEnd: false,
+    backgroundcolor: "transparent",
+
+    set_background_color(color) {
+      this.backgroundcolor = color;
+    },
+
+    onLocationChange(webProgress, request, location, flags) {
+      this.log(`onLocationChange ${location.spec}`);
+
+      // Ignore locationchange events which occur before the first loadstart.
+      // These are usually about:blank loads we don't care about.
+      if (!this.seenLoadStart) {
+        this.log(`loadstart not seen yet, not dispatching locationchange`);
+        return;
+      }
+
+      // Remove password from uri.
+      location = Services.uriFixup.createExposableURI(location);
+
+      this.dispatchEvent(`locationchange`, {
+        url: location.spec,
+        canGoBack: this.webview.canGoBack,
+        canGoForward: this.webview.canGoForward,
+      });
+    },
+
+    // eslint-disable-next-line complexity
+    onStateChange(webProgress, request, stateFlags, status) {
+      const CERTIFICATE_ERROR_PAGE_PREF =
+        "security.alternate_certificate_error_page";
+      // this.log(`onStateChange ${stateFlags}`);
+
+      if (stateFlags & Ci.nsIWebProgressListener.STATE_START) {
+        !this.seenLoadStart && this.dispatchEvent("loadstart");
+        this.seenLoadStart = true;
+      }
+
+      if (stateFlags & Ci.nsIWebProgressListener.STATE_STOP) {
+        if (this.seenLoadStart && !this.seenLoadEnd) {
+          this.dispatchEvent("loadend", {
+            backgroundColor: this.backgroundcolor,
+          });
+          this.seenLoadEnd = true;
+        }
+
+        switch (status) {
+          case Cr.NS_OK:
+          case Cr.NS_BINDING_ABORTED:
+          // Ignoring NS_BINDING_ABORTED, which is set when loading page is
+          // stopped.
+          case Cr.NS_ERROR_PARSED_DATA_CACHED:
+            return;
+
+          // TODO See nsDocShell::DisplayLoadError to see what extra
+          // information we should be annotating this first block of errors
+          // with. Bug 1107091.
+          case Cr.NS_ERROR_UNKNOWN_PROTOCOL:
+            this.dispatchEvent("error", { type: "unknownProtocolFound" });
+            return;
+          case Cr.NS_ERROR_FILE_NOT_FOUND:
+            this.dispatchEvent("error", { type: "fileNotFound" });
+            return;
+          case Cr.NS_ERROR_UNKNOWN_HOST:
+            this.dispatchEvent("error", { type: "dnsNotFound" });
+            return;
+          case Cr.NS_ERROR_CONNECTION_REFUSED:
+            this.dispatchEvent("error", { type: "connectionFailure" });
+            return;
+          case Cr.NS_ERROR_NET_INTERRUPT:
+            this.dispatchEvent("error", { type: "netInterrupt" });
+            return;
+          case Cr.NS_ERROR_NET_TIMEOUT:
+            this.dispatchEvent("error", { type: "netTimeout" });
+            return;
+          case Cr.NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION:
+            this.dispatchEvent("error", { type: "cspBlocked" });
+            return;
+          case Cr.NS_ERROR_PHISHING_URI:
+            this.dispatchEvent("error", { type: "deceptiveBlocked" });
+            return;
+          case Cr.NS_ERROR_MALWARE_URI:
+            this.dispatchEvent("error", { type: "malwareBlocked" });
+            return;
+          case Cr.NS_ERROR_HARMFUL_URI:
+            this.dispatchEvent("error", { type: "harmfulBlocked" });
+            return;
+          case Cr.NS_ERROR_UNWANTED_URI:
+            this.dispatchEvent("error", { type: "unwantedBlocked" });
+            return;
+          case Cr.NS_ERROR_FORBIDDEN_URI:
+            this.dispatchEvent("error", { type: "forbiddenBlocked" });
+            return;
+          case Cr.NS_ERROR_OFFLINE:
+            this.dispatchEvent("error", { type: "offline" });
+            return;
+          case Cr.NS_ERROR_MALFORMED_URI:
+            this.dispatchEvent("error", { type: "malformedURI" });
+            return;
+          case Cr.NS_ERROR_REDIRECT_LOOP:
+            this.dispatchEvent("error", { type: "redirectLoop" });
+            return;
+          case Cr.NS_ERROR_UNKNOWN_SOCKET_TYPE:
+            this.dispatchEvent("error", { type: "unknownSocketType" });
+            return;
+          case Cr.NS_ERROR_NET_RESET:
+            this.dispatchEvent("error", { type: "netReset" });
+            return;
+          case Cr.NS_ERROR_DOCUMENT_NOT_CACHED:
+            this.dispatchEvent("error", { type: "notCached" });
+            return;
+          case Cr.NS_ERROR_DOCUMENT_IS_PRINTMODE:
+            this.dispatchEvent("error", { type: "isprinting" });
+            return;
+          case Cr.NS_ERROR_PORT_ACCESS_NOT_ALLOWED:
+            this.dispatchEvent("error", { type: "deniedPortAccess" });
+            return;
+          case Cr.NS_ERROR_UNKNOWN_PROXY_HOST:
+            this.dispatchEvent("error", { type: "proxyResolveFailure" });
+            return;
+          case Cr.NS_ERROR_PROXY_CONNECTION_REFUSED:
+            this.dispatchEvent("error", { type: "proxyConnectFailure" });
+            return;
+          case Cr.NS_ERROR_INVALID_CONTENT_ENCODING:
+            this.dispatchEvent("error", { type: "contentEncodingFailure" });
+            return;
+          case Cr.NS_ERROR_REMOTE_XUL:
+            this.dispatchEvent("error", { type: "remoteXUL" });
+            return;
+          case Cr.NS_ERROR_UNSAFE_CONTENT_TYPE:
+            this.dispatchEvent("error", { type: "unsafeContentType" });
+            return;
+          case Cr.NS_ERROR_CORRUPTED_CONTENT:
+            this.dispatchEvent("error", { type: "corruptedContentErrorv2" });
+            return;
+          case Cr.NS_ERROR_BLOCKED_BY_POLICY:
+            this.dispatchEvent("error", { type: "blockedByPolicy" });
+            return;
+
+          default:
+            // getErrorClass() will throw if the error code passed in is not a NSS
+            // error code.
+            try {
+              let nssErrorsService = Cc[
+                "@mozilla.org/nss_errors_service;1"
+              ].getService(Ci.nsINSSErrorsService);
+              if (
+                nssErrorsService.getErrorClass(status) ==
+                Ci.nsINSSErrorsService.ERROR_CLASS_BAD_CERT
+              ) {
+                // XXX Is there a point firing the event if the error page is not
+                // certerror? If yes, maybe we should add a property to the
+                // event to to indicate whether there is a custom page. That would
+                // let the embedder have more control over the desired behavior.
+                let errorPage = Services.prefs.getCharPref(
+                  CERTIFICATE_ERROR_PAGE_PREF,
+                  ""
+                );
+
+                if (errorPage == "certerror") {
+                  this.dispatchEvent("error", { type: "certerror" });
+                  return;
+                }
+              }
+            } catch (e) {}
+
+            this.dispatchEvent("error", { type: "other" });
+        }
+      }
+    },
+
+    onSecurityChange(webProgress, request, state) {
+      var securityStateDesc;
+      if (state & Ci.nsIWebProgressListener.STATE_IS_SECURE) {
+        securityStateDesc = "secure";
+      } else if (state & Ci.nsIWebProgressListener.STATE_IS_BROKEN) {
+        securityStateDesc = "broken";
+      } else if (state & Ci.nsIWebProgressListener.STATE_IS_INSECURE) {
+        securityStateDesc = "insecure";
+      } else {
+        this.error(`Unexpected securitychange state: ${state}`);
+        securityStateDesc = "???";
+      }
+
+      var mixedStateDesc;
+      if (
+        state & Ci.nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT
+      ) {
+        mixedStateDesc = "blocked_mixed_active_content";
+      } else if (
+        state & Ci.nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT
+      ) {
+        // Note that STATE_LOADED_MIXED_ACTIVE_CONTENT implies STATE_IS_BROKEN
+        mixedStateDesc = "loaded_mixed_active_content";
+      }
+
+      var isEV = !!(
+        state & Ci.nsIWebProgressListener.STATE_IDENTITY_EV_TOPLEVEL
+      );
+      var isMixedContent = !!(
+        state &
+        (Ci.nsIWebProgressListener.STATE_BLOCKED_MIXED_ACTIVE_CONTENT |
+          Ci.nsIWebProgressListener.STATE_LOADED_MIXED_ACTIVE_CONTENT)
+      );
+
+      this.dispatchEvent("securitychange", {
+        state: securityStateDesc,
+        mixedState: mixedStateDesc,
+        extendedValidation: isEV,
+        mixedContent: isMixedContent,
+      });
+    },
+  };
+
+  const kRelayedEvents = [
+    "backgroundcolor",
+    "close",
+    "contextmenu",
+    "documentfirstpaint",
+    "iconchange",
+    "manifestchange",
+    "metachange",
+    "opensearch",
+    "resize",
+    "scroll",
+  ];
+
+  class WebView extends HTMLElement {
+    constructor() {
+      super();
+      this.log("constructor");
+
+      this.browser = null;
+      this.attrs = [];
+
+      // Mark some functions used by the UI as unimplemented for now.
+      ["addNextPaintListener", "removeNextPaintListener"].forEach(name => {
+        this[name] = () => {
+          this.log(`Unimplemented: ${name}`);
+        };
+      });
+    }
+
+    log(msg) {
+      console.log(`<web-view> ${msg}`);
+    }
+
+    error(msg) {
+      console.error(`<web-view> ${msg}`);
+    }
+
+    static get observedAttributes() {
+      return ["src", "remote", "ignoreuserfocus", "transparent"];
+    }
+
+    attributeChangedCallback(name, old_value, new_value) {
+      if (old_value === new_value) {
+        return;
+      }
+
+      this.log(`attribute ${name} changed from ${old_value} to ${new_value}`);
+      // If we have not created the browser yet, buffer the attribute modification.
+      if (!this.browser) {
+        this.attrs.push({ name, old_value, new_value });
+      } else {
+        this.update_attr(name, old_value, new_value);
+      }
+    }
+
+    update_attr(name, old_value, new_value) {
+      if (!this.browser) {
+        this.error(`update_attr(${name}) called with no browser available.`);
+        return;
+      }
+
+      if (new_value) {
+        this.browser.setAttribute(name, new_value);
+      } else {
+        this.browser.removeAttribute(name);
+      }
+    }
+
+    connectedCallback() {
+      this.log(`connectedCallback`);
+      if (!this.browser) {
+        this.log(`creating xul:browser`);
+        // Creates a xul:browser with default attributes.
+        this.browser = document.createXULElement("browser");
+        this.browser.setAttribute("src", "about:blank");
+        this.browser.setAttribute("type", "content");
+        this.browser.setAttribute(
+          "style",
+          "border: none; width: 100%; height: 100%"
+        );
+
+        let src = null;
+
+        // Apply buffered attribute changes.
+        this.attrs.forEach(attr => {
+          if (attr.name == "src") {
+            src = attr.new_value;
+            return;
+          }
+          this.update_attr(attr.name, attr.old_value, attr.new_value);
+        });
+        this.attrs = [];
+
+        // Hack around failing to add the progress listener before construct() runs.
+        this.browser.delayConnectedCallback = () => {
+          return false;
+        };
+
+        this.appendChild(this.browser);
+        this.progressListener = new ProgressListener(this);
+        this.browser.addProgressListener(this.progressListener);
+
+        if (this.browser.isRemoteBrowser) {
+          this.browser.messageManager.addMessageListener(
+            "DOMTitleChanged",
+            this
+          );
+        } else {
+          this.browser.addEventListener("DOMTitleChanged", this);
+        }
+
+        kRelayedEvents.forEach(name => {
+          this.browser.addEventListener(name, this);
+        });
+
+        // Set the src to load once we have setup all listeners to not miss progress events
+        // like loadstart.
+        src && this.browser.setAttribute("src", src);
+      }
+    }
+
+    disconnectedCallback() {
+      if (this.browser.isRemoteBrowser) {
+        this.browser.messageManager &&
+          this.browser.messageManager.removeMessageListener(
+            "DOMTitleChanged",
+            this
+          );
+      } else {
+        this.browser.removeEventListener("DOMTitleChanged", this);
+      }
+
+      kRelayedEvents.forEach(name => {
+        this.browser.removeEventListener(name, this);
+      });
+
+      this.browser.removeProgressListener(this.progressListener);
+      this.progressListener = null;
+    }
+
+    dispatchCustomEvent(name, detail) {
+      this.log(`dispatching ${EVENT_PREFIX}${name}`);
+      let event = new CustomEvent(`${EVENT_PREFIX}${name}`, {
+        bubbles: true,
+        detail,
+      });
+      this.dispatchEvent(event);
+    }
+
+    handleEvent(event) {
+      switch (event.type) {
+        case "DOMTitleChanged":
+          this.dispatchCustomEvent("titlechange", {
+            title: this.browser.contentTitle,
+          });
+          break;
+        case "documentfirstpaint":
+        case "close":
+          this.dispatchCustomEvent(event.type);
+          break;
+
+        case "contextmenu":
+        case "iconchange":
+        case "manifestchange":
+        case "metachange":
+        case "opensearch":
+        case "resize":
+        case "scroll":
+          this.dispatchCustomEvent(event.type, event.detail);
+          break;
+        case "backgroundcolor":
+          this.progressListener.set_background_color(
+            event.detail.backgroundcolor
+          );
+          break;
+        default:
+          this.error(`Unexpected event ${event.type}`);
+      }
+    }
+
+    receiveMessage(message) {
+      switch (message.name) {
+        case "DOMTitleChanged":
+          this.dispatchCustomEvent("titlechange", {
+            title: message.data.title,
+          });
+          break;
+        default:
+          this.error(
+            `Unexpected message ${message.name} ${JSON.stringify(message.data)}`
+          );
+      }
+    }
+
+    get frame() {
+      return this.browser;
+    }
+
+    set src(url) {
+      this.log(`set src to ${url}`);
+      // If we are not yet connected to the DOM, add that action to the list
+      // of attribute changes.
+      if (!this.browser) {
+        this.attrs.push({ name: "src", new_value: url });
+      } else {
+        this.browser.setAttribute("src", url);
+      }
+    }
+
+    get src() {
+      return this.browser ? this.browser.getAttribute("src") : null;
+    }
+
+    get canGoBack() {
+      return !!this.browser && this.browser.canGoBack;
+    }
+
+    goBack() {
+      !!this.browser && this.browser.goBack();
+    }
+
+    get canGoForward() {
+      return !!this.browser && this.browser.canGoForward;
+    }
+
+    goForward() {
+      !!this.browser && this.browser.goForward();
+    }
+
+    focus() {
+      this.log(`focus() browser available: ${!!this.browser}`);
+      !!this.browser && this.browser.focus();
+    }
+
+    blur() {
+      this.log(`blur() browser available: ${!!this.browser}`);
+      !!this.browser && this.browser.blur();
+    }
+
+    get active() {
+      return !!this.browser && this.browser.docShellIsActive;
+    }
+
+    set active(val) {
+      if (this.browser) {
+        let current = this.browser.docShellIsActive;
+        this.browser.docShellIsActive = val;
+        if (current !== val) {
+          this.dispatchCustomEvent("visibilitychange", { visible: val });
+        }
+      }
+    }
+
+    get visible() {
+      return this.active;
+    }
+
+    set visible(val) {
+      this.active = val;
+    }
+
+    // Returns a promise that will resolve with the screenshot as a Blob.
+    getScreenshot(max_width, max_height, mime_type) {
+      this.log(`getScreenshot ${max_width}x${max_height}, ${mime_type}`);
+      if (!this.browser) {
+        return Promise.reject();
+      }
+      return this.browser.webViewGetScreenshot(
+        max_width,
+        max_height,
+        mime_type
+      );
+    }
+  }
+
+  console.log(`Setting up <web-view> custom element`);
+  window.customElements.define("web-view", WebView);
+})();
diff --git a/toolkit/content/browser-child.js b/toolkit/content/browser-child.js
--- a/toolkit/content/browser-child.js
+++ b/toolkit/content/browser-child.js
@@ -5,16 +5,22 @@
 /* eslint-env mozilla/frame-script */
 
 ChromeUtils.defineModuleGetter(
   this,
   "BrowserUtils",
   "resource://gre/modules/BrowserUtils.jsm"
 );
 
+ChromeUtils.defineModuleGetter(
+  this,
+  "WebViewChild",
+  "resource://gre/modules/WebViewChild.jsm"
+);
+
 try {
   docShell
     .QueryInterface(Ci.nsIInterfaceRequestor)
     .getInterface(Ci.nsIBrowserChild)
     .beginSendingWebProgressEventsToParent();
 } catch (e) {
   // In responsive design mode, we do not have a BrowserChild for the in-parent
   // document.
@@ -70,13 +76,16 @@ addMessageListener("BrowserElement:Creat
   );
   storagePrincipal = BrowserUtils.principalWithMatchingOA(
     storagePrincipal,
     content.document.effectiveStoragePrincipal
   );
   docShell.createAboutBlankContentViewer(principal, storagePrincipal);
 });
 
+// Initialize the <web-view> specific support.
+WebViewChild.init(this);
+
 // We may not get any responses to Browser:Init if the browser element
 // is torn down too quickly.
 var outerWindowID = docShell.outerWindowID;
 var browsingContextId = docShell.browsingContext.id;
 sendAsyncMessage("Browser:Init", { outerWindowID, browsingContextId });
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -1275,16 +1275,34 @@
         // CSP for about:blank is null; if we ever change _contentPrincipal above,
         // we should re-evaluate the CSP here.
         this._csp = null;
 
         this.messageManager.addMessageListener("Browser:Init", this);
         this.messageManager.addMessageListener("DOMTitleChanged", this);
         this.messageManager.addMessageListener("ImageDocumentLoaded", this);
 
+        // Start WebView additions.
+        [
+          "backgroundcolor",
+          "close",
+          "documentfirstpaint",
+          "iconchange",
+          "manifestchange",
+          "metachange",
+          "opensearch",
+          "resize",
+          "scroll",
+          "contextmenu",
+        ].forEach(item => {
+          this.messageManager.addMessageListener(`WebView::${item}`, this);
+        });
+        this.screenshot_id = 0;
+        // End WebView additions.
+
         let jsm = "resource://gre/modules/RemoteWebProgress.jsm";
         let { RemoteWebProgressManager } = ChromeUtils.import(jsm, {});
 
         let oldManager = this._remoteWebProgressManager;
         this._remoteWebProgressManager = new RemoteWebProgressManager(this);
         if (oldManager) {
           // We're transitioning from one remote type to another. This means that
           // the RemoteWebProgress listener is listening to the old message manager,
@@ -1512,22 +1530,151 @@
           this._contentTitle = data.title;
           break;
         case "ImageDocumentLoaded":
           this._imageDocument = {
             width: data.width,
             height: data.height,
           };
           break;
+        case "WebView::backgroundcolor":
+          this.webViewDispatchEventFromData("backgroundcolor", data, [
+            "backgroundcolor",
+          ]);
+          break;
+        case "WebView::close":
+          this.dispatchEvent(new CustomEvent("close"));
+          break;
+        case "WebView::contextmenu":
+          return this.webViewfireCtxMenuEvent(data);
+        case "WebView::documentfirstpaint":
+          this.dispatchEvent(new CustomEvent("documentfirstpaint"));
+          break;
+        case "WebView::iconchange":
+          this.webViewDispatchEventFromData("iconchange", data, [
+            "href",
+            "sizes",
+            "rel",
+          ]);
+          break;
+        case "WebView::manifestchange":
+          this.webViewDispatchEventFromData("manifestchange", data, ["href"]);
+          break;
+        case "WebView::metachange":
+          this.webViewDispatchEventFromData("metachange", data, [
+            "name",
+            "content",
+            "type",
+            "lang",
+          ]);
+          break;
+        case "WebView::opensearch":
+          this.webViewDispatchEventFromData("opensearch", data, [
+            "title",
+            "href",
+          ]);
+          break;
+        case "WebView::resize":
+          this.webViewDispatchEventFromData("resize", data, [
+            "width",
+            "height",
+          ]);
+          break;
+        case "WebView::scroll":
+          this.webViewDispatchEventFromData("scroll", data, ["top", "left"]);
+          break;
         default:
           return this._receiveMessage(aMessage);
       }
       return undefined;
     }
 
+    // Returns a promise resolving with the screenshot as a Blob.
+    // We don't use drawSnapshot because we can't get the content
+    // size from it.
+    webViewGetScreenshot(max_width, max_height, mime_type) {
+      let id = `WebView::ReturnScreenShot::${this.screenshot_id}`;
+      this.screenshot_id += 1;
+
+      return new Promise((resolve, reject) => {
+        let mm = this.messageManager;
+        mm.addMessageListener(id, function got_screenshot(message) {
+          mm.removeMessageListener(id, got_screenshot);
+          let data = message.data;
+          if (data.success) {
+            resolve(data.result);
+          } else {
+            reject();
+          }
+        });
+
+        mm.sendAsyncMessage("WebView::GetScreenshot", {
+          max_width,
+          max_height,
+          mime_type,
+          id,
+        });
+      });
+    }
+
+    webViewDispatchEventFromData(name, data, props) {
+      let detail = {};
+      props.forEach(prop => {
+        if (data[prop] !== undefined) {
+          detail[prop] = data[prop];
+        }
+      });
+      this.dispatchEvent(new CustomEvent(name, { detail }));
+    }
+
+    webViewfireCtxMenuEvent(data) {
+      console.log(`webViewfireCtxMenuEvent ${JSON.stringify(data)}`);
+      let event = this.webViewcreateEvent(
+        "contextmenu",
+        data,
+        /* cancellable */ true
+      );
+
+      if (data.contextmenu) {
+        var self = this;
+        Cu.exportFunction(
+          function(id) {
+            self.messageManager.sendAsyncMessage("WebView::fire-ctx-callback", {
+              menuitem: id,
+            });
+          },
+          event.detail,
+          { defineAs: "contextMenuItemSelected" }
+        );
+      }
+
+      // The embedder may have default actions on context menu events, so
+      // we fire a context menu event even if the child didn't define a
+      // custom context menu
+      return !this.dispatchEvent(event);
+    }
+
+    webViewcreateEvent(evtName, detail, cancelable) {
+      // This will have to change if we ever want to send a CustomEvent with null
+      // detail.  For now, it's OK.
+      if (detail !== undefined && detail !== null) {
+        detail = Cu.cloneInto(detail, window);
+        return new window.CustomEvent(evtName, {
+          bubbles: true,
+          cancelable,
+          detail,
+        });
+      }
+
+      return new window.Event(evtName, {
+        bubbles: true,
+        cancelable,
+      });
+    }
+
     enableDisableCommandsRemoteOnly(
       aAction,
       aEnabledCommands,
       aDisabledCommands
     ) {
       if (this._controller) {
         this._controller.enableDisableCommands(
           aAction,
diff --git a/toolkit/modules/WebViewChild.jsm b/toolkit/modules/WebViewChild.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/modules/WebViewChild.jsm
@@ -0,0 +1,705 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+var EXPORTED_SYMBOLS = ["WebViewChild"];
+
+const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+const kLongestReturnedString = 128;
+
+var WebViewChild = {
+  // Prints arguments separated by a space and appends a new line.
+  log(...args) {
+    dump("WebViewChild: ");
+    for (let a of args) {
+      dump(a + " ");
+    }
+    dump("\n");
+  },
+
+  init(global) {
+    this.global = global;
+
+    // A cache of the menuitem dom objects keyed by the id we generate
+    // and pass to the embedder
+    this._ctxHandlers = {};
+    // Counter of contextmenu events fired
+    this._ctxCounter = 0;
+
+    let els = Services.els;
+
+    // We are using the system group for those events so if something in the
+    // content called .stopPropagation() this will still be called.
+    els.addSystemEventListener(
+      global,
+      "DOMWindowClose",
+      this.windowCloseHandler.bind(this),
+      /* useCapture = */ false
+    );
+    els.addSystemEventListener(
+      global,
+      "DOMWindowCreated",
+      this.windowCreatedHandler.bind(this),
+      /* useCapture = */ true
+    );
+    els.addSystemEventListener(
+      global,
+      "DOMWindowResize",
+      this.windowResizeHandler.bind(this),
+      /* useCapture = */ false
+    );
+    els.addSystemEventListener(
+      global,
+      "contextmenu",
+      this.contextmenuHandler.bind(this),
+      /* useCapture = */ false
+    );
+    els.addSystemEventListener(
+      global,
+      "scroll",
+      this.scrollEventHandler.bind(this),
+      /* useCapture = */ false
+    );
+
+    global.addMessageListener(
+      "WebView::fire-ctx-callback",
+      this.recvFireCtxCallback.bind(this)
+    );
+
+    let metachange_handler = this.metaChangeHandler.bind(this);
+    global.addEventListener(
+      "DOMMetaAdded",
+      metachange_handler,
+      /* useCapture = */ true,
+      /* wantsUntrusted = */ false
+    );
+
+    global.addEventListener(
+      "DOMMetaChanged",
+      metachange_handler,
+      /* useCapture = */ true,
+      /* wantsUntrusted = */ false
+    );
+
+    global.addEventListener(
+      "DOMMetaRemoved",
+      metachange_handler,
+      /* useCapture = */ true,
+      /* wantsUntrusted = */ false
+    );
+
+    global.addEventListener(
+      "DOMLinkAdded",
+      this.linkAddedHandler.bind(this),
+      /* useCapture = */ true,
+      /* wantsUntrusted = */ false
+    );
+
+    // Remote the value of the background color since the parent can't get
+    // it directly in its progress listener.
+    // This will be dispatched before the parent's loadend so we can use
+    // this value in the loadend event handler of the <web-view> element.
+    let seenLoadStart = false;
+    let seenLoadEnd = false;
+    let progress_listener = {
+      QueryInterface: ChromeUtils.generateQI([
+        Ci.nsIWebProgressListener,
+        Ci.nsISupportsWeakReference,
+      ]),
+
+      onStateChange(webProgress, request, stateFlags, status) {
+        if (stateFlags & Ci.nsIWebProgressListener.STATE_START) {
+          seenLoadStart = true;
+        }
+
+        if (stateFlags & Ci.nsIWebProgressListener.STATE_STOP) {
+          let backgroundcolor = "transparent";
+          try {
+            backgroundcolor = global.content
+              .getComputedStyle(global.content.document.body)
+              .getPropertyValue("background-color");
+          } catch (e) {}
+          if (seenLoadStart && !seenLoadEnd) {
+            global.sendAsyncMessage("WebView::backgroundcolor", {
+              backgroundcolor,
+            });
+            seenLoadEnd = true;
+          }
+        }
+      },
+    };
+
+    global.docShell
+      .QueryInterface(Ci.nsIWebProgress)
+      .addProgressListener(
+        progress_listener,
+        Ci.nsIWebProgress.NOTIFY_STATE_WINDOW
+      );
+
+    // Installs a message listener for screenshot requests.
+    global.addMessageListener(
+      "WebView::GetScreenshot",
+      this.getScreenshot.bind(this)
+    );
+  },
+
+  getScreenshot(message) {
+    let data = message.data;
+    this.log(`Taking screenshot for ${JSON.stringify(data)}`);
+
+    let takeScreenshotClosure = () => {
+      this.takeScreenshot(
+        data.max_width,
+        data.max_height,
+        data.mime_type,
+        data.id
+      );
+    };
+
+    let max_delay_ms = Services.prefs.getIntPref(
+      "dom.webview.maxScreenshotDelayMS",
+      /* default */ 2000
+    );
+
+    // Try to wait for the event loop to go idle before we take the screenshot,
+    // but once we've waited maxDelayMS milliseconds, go ahead and take it
+    // anyway.
+    Cc["@mozilla.org/message-loop;1"]
+      .getService(Ci.nsIMessageLoop)
+      .postIdleTask(takeScreenshotClosure, max_delay_ms);
+  },
+
+  // Actually take a screenshot and foward the result up to our parent, given
+  // the desired maxWidth and maxHeight (in CSS pixels), and given the
+  // message manager id associated with the request from the parent.
+  takeScreenshot(max_width, max_height, mime_type, id) {
+    // You can think of the screenshotting algorithm as carrying out the
+    // following steps:
+    //
+    // - Calculate maxWidth, maxHeight, and viewport's width and height in the
+    //   dimension of device pixels by multiply the numbers with
+    //   window.device_pixel_ratio.
+    //
+    // - Let scale_width be the factor by which we'd need to downscale the
+    //   viewport pixel width so it would fit within max_pixel_width.
+    //   (If the viewport's pixel width is less than max_pixel_width, let
+    //   scale_width be 1.) Compute scale_height the same way.
+    //
+    // - Scale the viewport by max(scale_width, scale_height).  Now either the
+    //   viewport's width is no larger than maxWidth, the viewport's height is
+    //   no larger than maxHeight, or both.
+    //
+    // - Crop the viewport so its width is no larger than maxWidth and its
+    //   height is no larger than maxHeight.
+    //
+    // - Set mozOpaque to true and background color to solid white
+    //   if we are taking a JPEG screenshot, keep transparent if otherwise.
+    //
+    // - Return a screenshot of the page's viewport scaled and cropped per
+    //   above.
+    let content = this.global.content;
+    if (!content) {
+      this.global.sendAsyncMessage(id, {
+        success: false,
+      });
+      return;
+    }
+
+    let device_pixel_ratio = content.devicePixelRatio;
+
+    let max_pixel_width = Math.round(max_width * device_pixel_ratio);
+    let max_pixel_height = Math.round(max_height * device_pixel_ratio);
+
+    let content_pixel_width = content.innerWidth * device_pixel_ratio;
+    let content_pixel_height = content.innerHeight * device_pixel_ratio;
+
+    let scale_width = Math.min(1, max_pixel_width / content_pixel_width);
+    let scale_height = Math.min(1, max_pixel_height / content_pixel_height);
+
+    let scale = Math.max(scale_width, scale_height);
+
+    let canvas_width = Math.min(
+      max_pixel_width,
+      Math.round(content_pixel_width * scale)
+    );
+    let canvas_height = Math.min(
+      max_pixel_height,
+      Math.round(content_pixel_height * scale)
+    );
+
+    var canvas = content.document.createElementNS(
+      "http://www.w3.org/1999/xhtml",
+      "canvas"
+    );
+
+    let transparent = mime_type !== "image/jpeg";
+    if (!transparent) {
+      canvas.mozOpaque = true;
+    }
+    canvas.width = canvas_width;
+    canvas.height = canvas_height;
+
+    let ctx = canvas.getContext("2d", { willReadFrequently: true });
+    ctx.scale(scale * device_pixel_ratio, scale * device_pixel_ratio);
+
+    let flags =
+      ctx.DRAWWINDOW_DRAW_VIEW |
+      ctx.DRAWWINDOW_USE_WIDGET_LAYERS |
+      ctx.DRAWWINDOW_DO_NOT_FLUSH |
+      ctx.DRAWWINDOW_ASYNC_DECODE_IMAGES;
+    ctx.drawWindow(
+      content,
+      0,
+      0,
+      content.innerWidth,
+      content.innerHeight,
+      transparent ? "rgba(255,255,255,0)" : "rgb(255,255,255)",
+      flags
+    );
+
+    // Take a JPEG screenshot by default instead of PNG with alpha channel.
+    // This requires us to unpremultiply the alpha channel, which
+    // is expensive on ARM processors because they lack a hardware integer
+    // division instruction.
+    canvas.toBlob(blob => {
+      this.global.sendAsyncMessage(id, {
+        success: true,
+        result: blob,
+      });
+    }, mime_type);
+  },
+
+  // Processes the "rel" field in <link> tags and forward to specific handlers.
+  linkAddedHandler(event) {
+    let win = event.target.ownerGlobal;
+    if (win != this.global.content) {
+      return;
+    }
+
+    let iconchange_handler = this.iconChangedHandler.bind(this);
+    let handlers = {
+      icon: iconchange_handler,
+      "apple-touch-icon": iconchange_handler,
+      "apple-touch-icon-precomposed": iconchange_handler,
+      search: this.openSearchHandler.bind(this),
+      manifest: this.manifestChangedHandler.bind(this),
+    };
+
+    this.log(`Got linkAdded: (${event.target.href}) ${event.target.rel}`);
+    event.target.rel.split(" ").forEach(function(x) {
+      let token = x.toLowerCase();
+      if (handlers[token]) {
+        handlers[token](event);
+      }
+    }, this);
+  },
+
+  iconChangedHandler(event) {
+    let target = event.target;
+    this.log(`Got iconchanged: (${target.href})`);
+    let icon = { href: target.href };
+    this.maybeCopyAttribute(target, icon, "sizes");
+    this.maybeCopyAttribute(target, icon, "rel");
+    this.global.sendAsyncMessage("WebView::iconchange", icon);
+  },
+
+  openSearchHandler(event) {
+    let target = event.target;
+    this.log(`Got opensearch: (${target.href})`);
+
+    if (target.type !== "application/opensearchdescription+xml") {
+      return;
+    }
+
+    this.global.sendAsyncMessage("WebView::opensearch", {
+      title: target.title,
+      href: target.href,
+    });
+  },
+
+  manifestChangedHandler(event) {
+    let target = event.target;
+    this.log(`Got manifestchanged: (${target.href})`);
+    let manifest = { href: target.href };
+    this.global.sendAsyncMessage("WebView::manifestchange", manifest);
+  },
+
+  metaChangeHandler(event) {
+    let win = event.target.ownerGlobal;
+    if (win != this.global.content) {
+      return;
+    }
+
+    let name = event.target.name;
+    let property = event.target.getAttributeNS(null, "property");
+
+    if (!name && !property) {
+      return;
+    }
+
+    this.log(`Got metaChanged: (${name || property}) ${event.target.content}`);
+
+    let generic_handler = this.genericMetaHandler.bind(this);
+
+    let handlers = {
+      viewmode: generic_handler,
+      "theme-color": generic_handler,
+      "theme-group": generic_handler,
+      "application-name": this.applicationNameChangedHandler.bind(this),
+    };
+    let handler = handlers[name];
+
+    if ((property || name).match(/^og:/)) {
+      name = property || name;
+      handler = generic_handler;
+    }
+
+    if (handler) {
+      handler(name, event.type, event.target);
+    }
+  },
+
+  genericMetaHandler(name, eventType, target) {
+    let meta = {
+      name,
+      content: target.content,
+      type: eventType.replace("DOMMeta", "").toLowerCase(),
+    };
+    this.global.sendAsyncMessage("WebView::metachange", meta);
+  },
+
+  applicationNameChangedHandler(name, eventType, target) {
+    if (eventType !== "DOMMetaAdded") {
+      // Bug 1037448 - Decide what to do when <meta name="application-name">
+      // changes
+      return;
+    }
+
+    let meta = { name, content: target.content };
+
+    let lang;
+    let elm;
+
+    for (
+      elm = target;
+      !lang && elm && elm.nodeType == target.ELEMENT_NODE;
+      elm = elm.parentNode
+    ) {
+      if (elm.hasAttribute("lang")) {
+        lang = elm.getAttribute("lang");
+        continue;
+      }
+
+      if (elm.hasAttributeNS("http://www.w3.org/XML/1998/namespace", "lang")) {
+        lang = elm.getAttributeNS(
+          "http://www.w3.org/XML/1998/namespace",
+          "lang"
+        );
+        continue;
+      }
+    }
+
+    // No lang has been detected.
+    if (!lang && elm.nodeType == target.DOCUMENT_NODE) {
+      lang = elm.contentLanguage;
+    }
+
+    if (lang) {
+      meta.lang = lang;
+    }
+
+    this.global.sendAsyncMessage("WebView::metachange", meta);
+  },
+
+  addMozAfterPaintHandler(callback) {
+    let self = this;
+    function onMozAfterPaint() {
+      let uri = self.global.docShell.QueryInterface(Ci.nsIWebNavigation)
+        .currentURI;
+      if (uri.spec != "about:blank") {
+        self.log(`Got afterpaint event: ${uri.spec}`);
+        self.global.removeEventListener(
+          "MozAfterPaint",
+          onMozAfterPaint,
+          /* useCapture = */ true
+        );
+        callback();
+      }
+    }
+    this.global.addEventListener(
+      "MozAfterPaint",
+      onMozAfterPaint,
+      /* useCapture = */ true
+    );
+    return onMozAfterPaint;
+  },
+
+  windowCreatedHandler(event) {
+    let targetDocShell = event.target.defaultView.docShell;
+    if (targetDocShell != this.global.docShell) {
+      return;
+    }
+
+    let uri = this.global.docShell.QueryInterface(Ci.nsIWebNavigation)
+      .currentURI;
+    this.log("Window created: " + uri.spec);
+    if (uri.spec != "about:blank") {
+      this.addMozAfterPaintHandler(() => {
+        this.global.sendAsyncMessage("WebView::documentfirstpaint");
+      });
+    }
+  },
+
+  windowCloseHandler(event) {
+    let win = event.target;
+    if (win != this.global.content || event.defaultPrevented) {
+      return;
+    }
+
+    this.log("Closing window " + win);
+    this.global.sendAsyncMessage("WebView::close");
+
+    // Inform the window implementation that we handled this close ourselves.
+    event.preventDefault();
+  },
+
+  windowResizeHandler(event) {
+    let win = event.target;
+    if (win != this.global.content || event.defaultPrevented) {
+      return;
+    }
+
+    this.log("resizing window " + win);
+    this.global.sendAsyncMessage("WebView::resize", {
+      width: event.detail.width,
+      height: event.detail.height,
+    });
+
+    // Inform the window implementation that we handled this resize ourselves.
+    event.preventDefault();
+  },
+
+  contextmenuHandler(event) {
+    this.log(event.type);
+    if (event.defaultPrevented) {
+      return;
+    }
+
+    this._ctxCounter++;
+    this._ctxHandlers = {};
+
+    let elem = event.target;
+    let menuData = { systemTargets: [], contextmenu: null };
+    let ctxMenuId = null;
+    let clipboardPlainTextOnly = Services.prefs.getBoolPref(
+      "clipboard.plainTextOnly"
+    );
+    var copyableElements = {
+      image: false,
+      link: false,
+      hasElements: () => {
+        return this.image || this.link;
+      },
+    };
+
+    // Set the event target as the copy image command needs it to
+    // determine what was context-clicked on.
+    this.global.docShell.contentViewer
+      .QueryInterface(Ci.nsIContentViewerEdit)
+      .setCommandNode(elem);
+
+    while (elem && elem.parentNode) {
+      let ctxData = this.getSystemCtxMenuData(elem);
+      if (ctxData) {
+        menuData.systemTargets.push({
+          nodeName: elem.nodeName,
+          data: ctxData,
+        });
+      }
+
+      if (
+        !ctxMenuId &&
+        "hasAttribute" in elem &&
+        elem.hasAttribute("contextmenu")
+      ) {
+        ctxMenuId = elem.getAttribute("contextmenu");
+      }
+
+      // Enable copy image/link option
+      if (elem.nodeName == "IMG") {
+        copyableElements.image = !clipboardPlainTextOnly;
+      } else if (elem.nodeName == "A") {
+        copyableElements.link = true;
+      }
+
+      elem = elem.parentNode;
+    }
+
+    if (ctxMenuId || copyableElements.hasElements()) {
+      var menu = null;
+      if (ctxMenuId) {
+        menu = event.target.ownerDocument.getElementById(ctxMenuId);
+      }
+      menuData.contextmenu = this.buildMenuObj(menu, "", copyableElements);
+    }
+
+    // Pass along the position where the context menu should be located
+    menuData.clientX = event.clientX;
+    menuData.clientY = event.clientY;
+    menuData.screenX = event.screenX;
+    menuData.screenY = event.screenY;
+
+    // The value returned by the contextmenu sync call is true if the embedder
+    // called preventDefault() on its contextmenu event.
+    //
+    // We call preventDefault() on our contextmenu event if the embedder called
+    // preventDefault() on /its/ contextmenu event.  This way, if the embedder
+    // ignored the contextmenu event, TabChild will fire a click.
+    if (this.global.sendSyncMessage("WebView::contextmenu", menuData)[0]) {
+      event.preventDefault();
+    } else {
+      this._ctxHandlers = {};
+    }
+  },
+
+  maybeCopyAttribute(src, target, attribute) {
+    if (src.getAttribute(attribute)) {
+      target[attribute] = src.getAttribute(attribute);
+    }
+  },
+
+  buildMenuObj(menu, idPrefix, copyableElements) {
+    let menuObj = { type: "menu", customized: false, items: [] };
+    // Customized context menu
+    if (menu) {
+      this.maybeCopyAttribute(menu, menuObj, "label");
+
+      for (let i = 0, child; (child = menu.children[i++]); ) {
+        if (child.nodeName === "MENU") {
+          menuObj.items.push(
+            this.buildMenuObj(child, idPrefix + i + "_", false)
+          );
+        } else if (child.nodeName === "MENUITEM") {
+          let id = this._ctxCounter + "_" + idPrefix + i;
+          let menuitem = { id, type: "menuitem" };
+          this.maybeCopyAttribute(child, menuitem, "label");
+          this.maybeCopyAttribute(child, menuitem, "icon");
+          this._ctxHandlers[id] = child;
+          menuObj.items.push(menuitem);
+        }
+      }
+
+      if (menuObj.items.length) {
+        menuObj.customized = true;
+      }
+    }
+    // Note: Display "Copy Link" first in order to make sure "Copy Image" is
+    //       put together with other image options if elem is an image link.
+    // "Copy Link" menu item
+    if (copyableElements.link) {
+      menuObj.items.push({ id: "copy-link" });
+    }
+    // "Copy Image" menu item
+    if (copyableElements.image) {
+      menuObj.items.push({ id: "copy-image" });
+    }
+
+    return menuObj;
+  },
+
+  getSystemCtxMenuData(elem) {
+    let documentURI = this.global.docShell.QueryInterface(Ci.nsIWebNavigation)
+      .currentURI.spec;
+    let content = this.global.content;
+    if (
+      (elem instanceof content.HTMLAnchorElement && elem.href) ||
+      (elem instanceof content.HTMLAreaElement && elem.href)
+    ) {
+      return {
+        uri: elem.href,
+        documentURI,
+        text: elem.textContent.substring(0, kLongestReturnedString),
+      };
+    }
+    if (elem instanceof Ci.nsIImageLoadingContent && elem.currentURI) {
+      return { uri: elem.currentURI.spec, documentURI };
+    }
+    if (elem instanceof content.HTMLImageElement) {
+      return { uri: elem.src, documentURI };
+    }
+    if (elem instanceof content.HTMLMediaElement) {
+      let hasVideo = !(
+        elem.readyState >= elem.HAVE_METADATA &&
+        (elem.videoWidth == 0 || elem.videoHeight == 0)
+      );
+      return {
+        uri: elem.currentSrc || elem.src,
+        hasVideo,
+        documentURI,
+      };
+    }
+    if (elem instanceof content.HTMLInputElement && elem.hasAttribute("name")) {
+      // For input elements, we look for a parent <form> and if there is
+      // one we return the form's method and action uri.
+      let parent = elem.parentNode;
+      while (parent) {
+        if (
+          parent instanceof content.HTMLFormElement &&
+          parent.hasAttribute("action")
+        ) {
+          let actionHref = this.global.docShell
+            .QueryInterface(Ci.nsIWebNavigation)
+            .currentURI.resolve(parent.getAttribute("action"));
+          let method = parent.hasAttribute("method")
+            ? parent.getAttribute("method").toLowerCase()
+            : "get";
+          return {
+            documentURI,
+            action: actionHref,
+            method,
+            name: elem.getAttribute("name"),
+          };
+        }
+        parent = parent.parentNode;
+      }
+    }
+    return false;
+  },
+
+  recvFireCtxCallback(data) {
+    this.log(`Received fireCtxCallback message: (${data.json.menuitem})`);
+
+    let doCommandIfEnabled = command => {
+      if (this.global.docShell.isCommandEnabled(command)) {
+        this.global.docShell.doCommand(command);
+      }
+    };
+
+    if (data.json.menuitem == "copy-image") {
+      doCommandIfEnabled("cmd_copyImage");
+    } else if (data.json.menuitem == "copy-link") {
+      doCommandIfEnabled("cmd_copyLink");
+    } else if (data.json.menuitem in this._ctxHandlers) {
+      this._ctxHandlers[data.json.menuitem].click();
+      this._ctxHandlers = {};
+    } else {
+      // We silently ignore if the embedder uses an incorrect id in the callback
+      this.log("Ignored invalid contextmenu invocation");
+    }
+  },
+
+  scrollEventHandler(event) {
+    let win = event.target;
+    if (win != this.global.content || event.defaultPrevented) {
+      return;
+    }
+
+    this.log("scroll event " + win);
+    this.global.sendAsyncMessage("WebView::scroll", {
+      top: win.scrollY,
+      left: win.scrollX,
+    });
+  },
+};
