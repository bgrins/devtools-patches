# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  175e8e5c6d8eade64bd63ca106f1d88b1f337265
Bug 1139644 - Make markupview use sdk timers instead of individual timers for each window;r=pbrosset

diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -22,16 +22,17 @@ const DRAG_DROP_MAX_AUTOSCROLL_SPEED = 1
 const {UndoStack} = require("devtools/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/markupview/html-editor");
 const promise = require("resource://gre/modules/Promise.jsm").Promise;
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const Heritage = require("sdk/core/heritage");
+const {setTimeout, clearTimeout, setInterval, clearInterval} = require("sdk/timers");
 const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis", Ci.nsIPrefLocalizedString).data;
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
@@ -169,42 +170,42 @@ MarkupView.prototype = {
   _onMouseMove: function(event) {
     if (this.isDragging) {
       event.preventDefault();
       this._dragStartEl = event.target;
 
       let docEl = this.doc.documentElement;
 
       if (this._scrollInterval) {
-        this.win.clearInterval(this._scrollInterval);
+        clearInterval(this._scrollInterval);
       }
 
       // Auto-scroll when the mouse approaches top/bottom edge
       let distanceFromBottom = docEl.clientHeight - event.pageY + this.win.scrollY,
           distanceFromTop = event.pageY - this.win.scrollY;
 
       if (distanceFromBottom <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
         // Map our distance from 0-50 to 5-15 range so the speed is kept
         // in a range not too fast, not too slow
         let speed = map(distanceFromBottom, 0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE,
                         DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);
         // Here, we use minus because the value of speed - 15 is always negative
         // and it makes the speed relative to the distance between mouse and edge
         // the closer to the edge, the faster
-        this._scrollInterval = this.win.setInterval(() => {
+        this._scrollInterval = setInterval(() => {
           docEl.scrollTop -= speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
         }, 0);
       }
 
       if (distanceFromTop <= DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE) {
         // refer to bottom edge's comments for more info
         let speed = map(distanceFromTop, 0, DRAG_DROP_AUTOSCROLL_EDGE_DISTANCE,
                         DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);
 
-        this._scrollInterval = this.win.setInterval(() => {
+        this._scrollInterval = setInterval(() => {
           docEl.scrollTop += speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED;
         }, 0);
       }
 
       return;
     };
 
     let target = event.target;
@@ -251,17 +252,17 @@ MarkupView.prototype = {
   _onMouseUp: function() {
     if (this._lastDropTarget) {
       this.indicateDropTarget(null);
     }
     if (this._lastDragTarget) {
       this.indicateDragTarget(null);
     }
     if (this._scrollInterval) {
-      this.win.clearInterval(this._scrollInterval);
+      clearInterval(this._scrollInterval);
     }
   },
 
   _hoveredNode: null,
 
   /**
    * Show a NodeFront's container as being hovered
    * @param {NodeFront} nodeFront The node to show as hovered
@@ -276,17 +277,17 @@ MarkupView.prototype = {
     }
 
     this.getContainer(nodeFront).hovered = true;
     this._hoveredNode = nodeFront;
   },
 
   _onMouseLeave: function() {
     if (this._scrollInterval) {
-      this.win.clearInterval(this._scrollInterval);
+      clearInterval(this._scrollInterval);
     }
     if (this.isDragging) return;
 
     this._hideBoxModel(true);
     if (this._hoveredNode) {
       this.getContainer(this._hoveredNode).hovered = false;
     }
     this._hoveredNode = null;
@@ -315,23 +316,23 @@ MarkupView.prototype = {
     return this._inspector.toolbox.highlighterUtils.unhighlight(forceHide);
   },
 
   _briefBoxModelTimer: null,
   _brieflyShowBoxModel: function(nodeFront) {
     let win = this._frame.contentWindow;
 
     if (this._briefBoxModelTimer) {
-      win.clearTimeout(this._briefBoxModelTimer);
+      clearTimeout(this._briefBoxModelTimer);
       this._briefBoxModelTimer = null;
     }
 
     this._showBoxModel(nodeFront);
 
-    this._briefBoxModelTimer = this._frame.contentWindow.setTimeout(() => {
+    this._briefBoxModelTimer = setTimeout(() => {
       this._hideBoxModel();
     }, NEW_SELECTION_HIGHLIGHTER_TIMER);
   },
 
   template: function(aName, aDest, aOptions={stack: "markup-view.xhtml"}) {
     let node = this.doc.getElementById("template-" + aName).cloneNode(true);
     node.removeAttribute("id");
     template(node, aDest, aOptions);
@@ -1514,19 +1515,19 @@ MarkupView.prototype = {
    * Hide the preview while resizing, to avoid slowness.
    */
   _resizePreview: function() {
     if (!this._previewEnabled) {
       return;
     }
     let win = this._frame.contentWindow;
     this._previewBar.classList.add("hide");
-    win.clearTimeout(this._resizePreviewTimeout);
-
-    win.setTimeout(() => {
+    clearTimeout(this._resizePreviewTimeout);
+
+    setTimeout(() => {
       this._updatePreview();
       this._previewBar.classList.remove("hide");
     }, 1000);
   },
 
   /**
    * Takes an element as it's only argument and marks the element
    * as the drop target
@@ -1813,17 +1814,17 @@ MarkupContainer.prototype = {
     // target is the MarkupContainer itself.
     this._isMouseDown = true;
     this.hovered = false;
     this.markup.navigate(this);
     event.stopPropagation();
 
     // Start dragging the container after a delay.
     this.markup._dragStartEl = target;
-    this.win.setTimeout(() => {
+    setTimeout(() => {
       // Make sure the mouse is still down and on target.
       if (!this._isMouseDown || this.markup._dragStartEl !== target ||
           this.node.isPseudoElement || this.node.isAnonymous ||
           !this.win.getSelection().isCollapsed) {
         return;
       }
       this.isDragging = true;
 
@@ -1880,20 +1881,20 @@ MarkupContainer.prototype = {
    * Temporarily flash the container to attract attention.
    * Used for markup mutations.
    */
   flashMutation: function() {
     if (!this.selected) {
       let contentWin = this.win;
       this.flashed = true;
       if (this._flashMutationTimer) {
-        contentWin.clearTimeout(this._flashMutationTimer);
+        clearTimeout(this._flashMutationTimer);
         this._flashMutationTimer = null;
       }
-      this._flashMutationTimer = contentWin.setTimeout(() => {
+      this._flashMutationTimer = setTimeout(() => {
         this.flashed = false;
       }, this.markup.CONTAINER_FLASHING_DURATION);
     }
   },
 
   set flashed(aValue) {
     if (aValue) {
       // Make sure the animation class is not here
diff --git a/browser/devtools/markupview/test/browser_markupview_mutation_02.js b/browser/devtools/markupview/test/browser_markupview_mutation_02.js
--- a/browser/devtools/markupview/test/browser_markupview_mutation_02.js
+++ b/browser/devtools/markupview/test/browser_markupview_mutation_02.js
@@ -90,11 +90,11 @@ add_task(function*() {
 function* assertNodeFlashing(nodeFront, inspector) {
   let container = getContainerForNodeFront(nodeFront, inspector);
   ok(container, "Markup container for node found");
   ok(container.tagState.classList.contains("theme-bg-contrast"),
     "Markup container for node is flashing");
 
   // Clear the mutation flashing timeout now that we checked the node was flashing
   let markup = inspector.markup;
-  markup._frame.contentWindow.clearTimeout(container._flashMutationTimer);
+  clearTimeout(container._flashMutationTimer);
   container._flashMutationTimer = null;
 }
diff --git a/browser/devtools/markupview/test/head.js b/browser/devtools/markupview/test/head.js
--- a/browser/devtools/markupview/test/head.js
+++ b/browser/devtools/markupview/test/head.js
@@ -4,16 +4,17 @@
 
 const Cu = Components.utils;
 let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 let TargetFactory = devtools.TargetFactory;
 let {console} = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 let promise = devtools.require("resource://gre/modules/Promise.jsm").Promise;
 let {getInplaceEditorForSpan: inplaceEditor} = devtools.require("devtools/shared/inplace-editor");
 let clipboard = devtools.require("sdk/clipboard");
+let {setTimeout, clearTimeout} = devtools.require("sdk/timers");
 
 // All test are asynchronous
 waitForExplicitFinish();
 
 // If a test times out we want to see the complete log and not just the last few
 // lines.
 SimpleTest.requestCompleteLog();
 
