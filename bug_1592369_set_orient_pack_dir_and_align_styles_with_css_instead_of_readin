# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1572386311 25200
#      Tue Oct 29 14:58:31 2019 -0700
# Node ID f03bab6c9e27436e273b17553315926c21825929
# Parent  94c1f20bb838c7200c7e35094cb749bd5a35bc74
Bug 1592369 - Set [orient], [pack], [dir], and [align] styles with CSS instead of reading the XUL layout attributes

Differential Revision: https://phabricator.services.mozilla.com/D51013

diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -226,54 +226,20 @@ void nsBoxFrame::CacheAttributes() {
   GetInitialAutoStretch(autostretch);
   if (autostretch)
     AddStateBits(NS_STATE_AUTO_STRETCH);
   else
     RemoveStateBits(NS_STATE_AUTO_STRETCH);
 }
 
 bool nsBoxFrame::GetInitialHAlignment(nsBoxFrame::Halignment& aHalign) {
-  if (!GetContent() || !GetContent()->IsElement()) return false;
-
-  Element* element = GetContent()->AsElement();
-  // XXXdwh Everything inside this if statement is deprecated code.
-  static Element::AttrValuesArray alignStrings[] = {nsGkAtoms::left,
-                                                    nsGkAtoms::right, nullptr};
-  static const Halignment alignValues[] = {hAlign_Left, hAlign_Right};
-  int32_t index = element->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::align,
-                                           alignStrings, eCaseMatters);
-  if (index >= 0) {
-    aHalign = alignValues[index];
-    return true;
-  }
+  if (!GetContent()) return false;
 
-  // Now that the deprecated stuff is out of the way, we move on to check the
-  // appropriate attribute.  For horizontal boxes, we are checking the PACK
-  // attribute.  For vertical boxes we are checking the ALIGN attribute.
-  nsAtom* attrName = IsXULHorizontal() ? nsGkAtoms::pack : nsGkAtoms::align;
-  static Element::AttrValuesArray strings[] = {
-      nsGkAtoms::_empty, nsGkAtoms::start, nsGkAtoms::center, nsGkAtoms::end,
-      nullptr};
-  static const Halignment values[] = {hAlign_Left /*not used*/, hAlign_Left,
-                                      hAlign_Center, hAlign_Right};
-  index = element->FindAttrValueIn(kNameSpaceID_None, attrName, strings,
-                                   eCaseMatters);
-
-  if (index == Element::ATTR_VALUE_NO_MATCH) {
-    // The attr was present but had a nonsensical value. Revert to the default.
-    return false;
-  }
-  if (index > 0) {
-    aHalign = values[index];
-    return true;
-  }
-
-  // Now that we've checked for the attribute it's time to check CSS.  For
-  // horizontal boxes we're checking PACK.  For vertical boxes we are checking
-  // ALIGN.
+  // For horizontal boxes we're checking PACK.  For vertical boxes we are
+  // checking ALIGN.
   const nsStyleXUL* boxInfo = StyleXUL();
   if (IsXULHorizontal()) {
     switch (boxInfo->mBoxPack) {
       case StyleBoxPack::Start:
         aHalign = nsBoxFrame::hAlign_Left;
         return true;
       case StyleBoxPack::Center:
         aHalign = nsBoxFrame::hAlign_Center;
@@ -299,56 +265,19 @@ bool nsBoxFrame::GetInitialHAlignment(ns
         return false;
     }
   }
 
   return false;
 }
 
 bool nsBoxFrame::GetInitialVAlignment(nsBoxFrame::Valignment& aValign) {
-  if (!GetContent() || !GetContent()->IsElement()) return false;
-
-  Element* element = GetContent()->AsElement();
-
-  static Element::AttrValuesArray valignStrings[] = {
-      nsGkAtoms::top, nsGkAtoms::baseline, nsGkAtoms::middle, nsGkAtoms::bottom,
-      nullptr};
-  static const Valignment valignValues[] = {vAlign_Top, vAlign_BaseLine,
-                                            vAlign_Middle, vAlign_Bottom};
-  int32_t index = element->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::valign,
-                                           valignStrings, eCaseMatters);
-  if (index >= 0) {
-    aValign = valignValues[index];
-    return true;
-  }
-
-  // Now that the deprecated stuff is out of the way, we move on to check the
-  // appropriate attribute.  For horizontal boxes, we are checking the ALIGN
-  // attribute.  For vertical boxes we are checking the PACK attribute.
-  nsAtom* attrName = IsXULHorizontal() ? nsGkAtoms::align : nsGkAtoms::pack;
-  static Element::AttrValuesArray strings[] = {
-      nsGkAtoms::_empty,   nsGkAtoms::start, nsGkAtoms::center,
-      nsGkAtoms::baseline, nsGkAtoms::end,   nullptr};
-  static const Valignment values[] = {vAlign_Top /*not used*/, vAlign_Top,
-                                      vAlign_Middle, vAlign_BaseLine,
-                                      vAlign_Bottom};
-  index = element->FindAttrValueIn(kNameSpaceID_None, attrName, strings,
-                                   eCaseMatters);
-  if (index == Element::ATTR_VALUE_NO_MATCH) {
-    // The attr was present but had a nonsensical value. Revert to the default.
-    return false;
-  }
-  if (index > 0) {
-    aValign = values[index];
-    return true;
-  }
-
-  // Now that we've checked for the attribute it's time to check CSS.  For
-  // horizontal boxes we're checking ALIGN.  For vertical boxes we are checking
-  // PACK.
+  if (!GetContent()) return false;
+  // For horizontal boxes we're checking ALIGN.  For vertical boxes we are
+  // checking PACK.
   const nsStyleXUL* boxInfo = StyleXUL();
   if (IsXULHorizontal()) {
     switch (boxInfo->mBoxAlign) {
       case StyleBoxAlign::Start:
         aValign = nsBoxFrame::vAlign_Top;
         return true;
       case StyleBoxAlign::Center:
         aValign = nsBoxFrame::vAlign_Middle;
@@ -380,35 +309,22 @@ bool nsBoxFrame::GetInitialVAlignment(ns
 
   return false;
 }
 
 void nsBoxFrame::GetInitialOrientation(bool& aIsHorizontal) {
   // see if we are a vertical or horizontal box.
   if (!GetContent()) return;
 
-  // Check the style system first.
   const nsStyleXUL* boxInfo = StyleXUL();
   if (boxInfo->mBoxOrient == StyleBoxOrient::Horizontal) {
     aIsHorizontal = true;
   } else {
     aIsHorizontal = false;
   }
-
-  // Now see if we have an attribute.  The attribute overrides
-  // the style system value.
-  if (!GetContent()->IsElement()) return;
-
-  static Element::AttrValuesArray strings[] = {nsGkAtoms::vertical,
-                                               nsGkAtoms::horizontal, nullptr};
-  int32_t index = GetContent()->AsElement()->FindAttrValueIn(
-      kNameSpaceID_None, nsGkAtoms::orient, strings, eCaseMatters);
-  if (index >= 0) {
-    aIsHorizontal = index == 1;
-  }
 }
 
 void nsBoxFrame::GetInitialDirection(bool& aIsNormal) {
   if (!GetContent()) return;
 
   if (IsXULHorizontal()) {
     // For horizontal boxes only, we initialize our value based off the CSS
     // 'direction' property. This means that BiDI users will end up with
@@ -418,38 +334,16 @@ void nsBoxFrame::GetInitialDirection(boo
   } else
     aIsNormal = true;  // Assume a normal direction in the vertical case.
 
   // Now check the style system to see if we should invert aIsNormal.
   const nsStyleXUL* boxInfo = StyleXUL();
   if (boxInfo->mBoxDirection == StyleBoxDirection::Reverse) {
     aIsNormal = !aIsNormal;  // Invert our direction.
   }
-
-  if (!GetContent()->IsElement()) {
-    return;
-  }
-
-  Element* element = GetContent()->AsElement();
-
-  // Now see if we have an attribute.  The attribute overrides
-  // the style system value.
-  if (IsXULHorizontal()) {
-    static Element::AttrValuesArray strings[] = {
-        nsGkAtoms::reverse, nsGkAtoms::ltr, nsGkAtoms::rtl, nullptr};
-    int32_t index = element->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
-                                             strings, eCaseMatters);
-    if (index >= 0) {
-      bool values[] = {!aIsNormal, true, false};
-      aIsNormal = values[index];
-    }
-  } else if (element->AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,
-                                  nsGkAtoms::reverse, eCaseMatters)) {
-    aIsNormal = !aIsNormal;
-  }
 }
 
 /* Returns true if it was set.
  */
 bool nsBoxFrame::GetInitialEqualSize(bool& aEqualSize) {
   // see if we are a vertical or horizontal box.
   if (!GetContent() || !GetContent()->IsElement()) return false;
 
@@ -463,28 +357,16 @@ bool nsBoxFrame::GetInitialEqualSize(boo
   return false;
 }
 
 /* Returns true if it was set.
  */
 bool nsBoxFrame::GetInitialAutoStretch(bool& aStretch) {
   if (!GetContent()) return false;
 
-  // Check the align attribute.
-  if (GetContent()->IsElement()) {
-    static Element::AttrValuesArray strings[] = {nsGkAtoms::_empty,
-                                                 nsGkAtoms::stretch, nullptr};
-    int32_t index = GetContent()->AsElement()->FindAttrValueIn(
-        kNameSpaceID_None, nsGkAtoms::align, strings, eCaseMatters);
-    if (index != Element::ATTR_MISSING && index != 0) {
-      aStretch = index == 1;
-      return true;
-    }
-  }
-
   // Check the CSS box-align property.
   const nsStyleXUL* boxInfo = StyleXUL();
   aStretch = (boxInfo->mBoxAlign == StyleBoxAlign::Stretch);
 
   return true;
 }
 
 void nsBoxFrame::DidReflow(nsPresContext* aPresContext,
diff --git a/layout/xul/nsScrollbarFrame.cpp b/layout/xul/nsScrollbarFrame.cpp
--- a/layout/xul/nsScrollbarFrame.cpp
+++ b/layout/xul/nsScrollbarFrame.cpp
@@ -376,20 +376,16 @@ nsresult nsScrollbarFrame::CreateAnonymo
 
     aElements.AppendElement(ContentInfo(mSlider, key));
 
     NS_TrustedNewXULElement(
         getter_AddRefs(mThumb),
         nodeInfoManager->GetNodeInfo(nsGkAtoms::thumb, nullptr,
                                      kNameSpaceID_XUL, nsINode::ELEMENT_NODE));
     mThumb->SetAttr(kNameSpaceID_None, nsGkAtoms::orient, orient, false);
-    mThumb->SetAttr(kNameSpaceID_None, nsGkAtoms::align,
-                    NS_LITERAL_STRING("center"), false);
-    mThumb->SetAttr(kNameSpaceID_None, nsGkAtoms::pack,
-                    NS_LITERAL_STRING("center"), false);
     mSlider->AppendChildTo(mThumb, false);
   }
 
   {
     AnonymousContentKey key;
     mUpBottomButton =
         MakeScrollbarButton(sbbNodeInfo, vertical, /* aBottom */ true,
                             /* aDown */ false, key);
diff --git a/toolkit/content/minimal-xul.css b/toolkit/content/minimal-xul.css
--- a/toolkit/content/minimal-xul.css
+++ b/toolkit/content/minimal-xul.css
@@ -33,17 +33,16 @@
 }
 
 /* hide the content, but don't destroy the frames */
 [collapsed="true"] {
   visibility: collapse;
 }
 
 /* Rules required for style caching of anonymous content scrollbar parts */
-
 scrollcorner, resizer, scrollbar, scrollbarbutton, slider {
   /* All scrollbar parts must not inherit any properties from the scrollable
    * element (except for visibility and pointer-events), for the anonymous
    * content style caching system to work.
    */
   all: initial;
   visibility: inherit;
   pointer-events: inherit;
@@ -80,20 +79,29 @@ scrollcorner, resizer, scrollbar, scroll
    * cannot match :root, so no need to duplicate them.
    */
   -moz-user-focus: ignore;
   -moz-user-select: none;
   display: -moz-box;
   box-sizing: border-box;
 }
 
+scrollbar[orient="vertical"],
+slider[orient="vertical"],
+thumb[orient="vertical"] {
+  -moz-box-orient: vertical;
+}
+
 thumb {
   /* Prevent -moz-user-modify declaration from designmode.css having an
    * effect. */
   -moz-user-modify: initial;
+
+  -moz-box-align: center;
+  -moz-box-pack: center;
 }
 
 /* There are other rules that set direction and cursor on scrollbar,
  * expecting them to inherit into its children.  Explicitly inherit those,
  * overriding the 'all: initial; direction: ltr;' declarations above.
  */
 scrollbarbutton, slider, thumb {
   direction: inherit;
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -569,38 +569,36 @@ tabmodalprompt {
 
 .menulist-highlightable-label:not([highlightable="true"]),
 .menulist-label[highlightable="true"],
 .menu-iconic-highlightable-text:not([highlightable="true"]),
 .menu-iconic-text[highlightable="true"] {
   display: none;
 }
 
-@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
-  /* Support common XUL attributes in the emulated flex mode so we can
-     test the browser in this configuration without mass-changing existing
-     markup and CSS. */
-  [orient="vertical"] { -moz-box-orient: vertical; }
-  [orient="horizontal"] { -moz-box-orient: horizontal; }
+[orient="vertical"] { -moz-box-orient: vertical !important; }
+[orient="horizontal"] { -moz-box-orient: horizontal !important; }
 
-  [dir="reverse"] { -moz-box-direction: reverse; }
+[dir="reverse"] { -moz-box-direction: reverse !important; }
 
-  [align="start"] { -moz-box-align: start; }
-  [align="center"] { -moz-box-align: center; }
-  [align="end"] { -moz-box-align: end; }
-  [align="baseline"] { -moz-box-align: baseline; }
-  [align="stretch"] { -moz-box-align: stretch; }
+[align="start"] { -moz-box-align: start !important; }
+[align="center"] { -moz-box-align: center !important; }
+[align="end"] { -moz-box-align: end !important; }
+[align="baseline"] { -moz-box-align: baseline !important; }
+[align="stretch"] { -moz-box-align: stretch !important; }
 
-  [pack="start"] { -moz-box-pack: start; }
-  [pack="center"] { -moz-box-pack: center; }
-  [pack="end"] { -moz-box-pack: end; }
+[pack="start"] { -moz-box-pack: start !important; }
+[pack="center"] { -moz-box-pack: center !important; }
+[pack="end"] { -moz-box-pack: end !important; }
 
+@supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   /* This isn't a real solution for [flex] and [ordinal], but it covers enough
-     cases to render the browser chrome. If we get attr() in Bug 435426 this could
-     work for all cases. */
+     cases to render the browser chrome for us to test emulated flex mode without
+     mass-changing existing markup and CSS.
+     If we get attr() in Bug 435426 this could  work for all cases. */
   [flex="1"] { -moz-box-flex: 1; }
   [flex="2"] { -moz-box-flex: 2; }
   [flex="3"] { -moz-box-flex: 3; }
   [flex="4"] { -moz-box-flex: 4; }
   [flex="5"] { -moz-box-flex: 5; }
   [flex="6"] { -moz-box-flex: 6; }
   [flex="7"] { -moz-box-flex: 7; }
   [flex="8"] { -moz-box-flex: 8; }
