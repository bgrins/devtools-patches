# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  f5b4481c9fd50becb35cef02b599198b766fb1bb
Bug 1053898

diff --git a/devtools/client/inspector/markup/views/element-editor.js b/devtools/client/inspector/markup/views/element-editor.js
--- a/devtools/client/inspector/markup/views/element-editor.js
+++ b/devtools/client/inspector/markup/views/element-editor.js
@@ -102,16 +102,17 @@ function ElementEditor(container, node) 
       });
     },
     cssProperties: this._cssProperties
   });
 
   let displayName = this.node.displayName;
   this.tag.textContent = displayName;
   this.closeTag.textContent = displayName;
+  console.log("Setting displayname on this.closeTag", displayName);
 
   let isVoidElement = HTML_VOID_ELEMENTS.includes(displayName);
   if (node.isInHTMLDocument && isVoidElement) {
     this.elt.classList.add("void-element");
   }
 
   this.update();
   this.initialized = true;
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -248,17 +248,17 @@ var NodeActor = exports.NodeActor = prot
   // Returns the JSON representation of this object over the wire.
   form: function (detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
     let inlineTextChild = this.walker.inlineTextChild(this);
-
+    console.log("Returning form for ", this.rawNode, getNodeDisplayName(this.rawNode));
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
       nodeValue: this.rawNode.nodeValue,
@@ -1400,17 +1400,17 @@ var WalkerActor = protocol.ActorClassWit
       // in case this one is incompatible with the walker's filter function.
       return this.getDocumentWalker(documentWalkerNode, whatToShow, SKIP_TO_SIBLING);
     };
 
     // Need to know the first and last child.
     let rawNode = node.rawNode;
     let firstChild = getFilteredWalker(rawNode).firstChild();
     let lastChild = getFilteredWalker(rawNode).lastChild();
-
+    console.log(rawNode, firstChild, lastChild);
     if (!firstChild) {
       // No children, we're done.
       return { hasFirst: true, hasLast: true, nodes: [] };
     }
 
     let start;
     if (options.center) {
       start = options.center.rawNode;
@@ -3064,96 +3064,149 @@ function isNodeDead(node) {
 function DocumentWalker(node, rootWin,
     whatToShow = nodeFilterConstants.SHOW_ALL,
     filter = standardTreeWalkerFilter,
     skipTo = SKIP_TO_PARENT) {
   if (Cu.isDeadWrapper(rootWin) || !rootWin.location) {
     throw new Error("Got an invalid root window in DocumentWalker");
   }
 
+  this.filter = filter;
+  let startingNode = this.getStartingNode(node, skipTo);
+
+  // XXX: If this is a node with a shadow root, then we want to represent
+  // the shadow root as the first child and then traverse the light DOM somehow.
+  // It's not clear if the deepTreeWalker can be used for this.
+
+  console.log("Creating a walker!", startingNode, startingNode.host, startingNode.shadowRoot);
+
   this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"]
     .createInstance(Ci.inIDeepTreeWalker);
   this.walker.showAnonymousContent = true;
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
   this.walker.init(rootWin.document, whatToShow);
-  this.filter = filter;
 
   // Make sure that the walker knows about the initial node (which could
   // be skipped due to a filter).
-  this.walker.currentNode = this.getStartingNode(node, skipTo);
+  this.walker.currentNode = startingNode;
 }
 
 DocumentWalker.prototype = {
   get whatToShow() {
     return this.walker.whatToShow;
   },
   get currentNode() {
     return this.walker.currentNode;
   },
   set currentNode(val) {
     this.walker.currentNode = val;
   },
 
   parentNode: function () {
-    return this.walker.parentNode();
+    let node = this.walker.currentNode;
+    // ShadowHost is the parent of every ShadowRoot
+    if (node.host &&
+        node instanceof node.ownerDocument.defaultView.ShadowRoot) {
+      this.walker.currentNode = node.host;
+      return node.host;
+    }
+    let par =  this.walker.parentNode();
+    console.log("Getting parent node", node, node.parentNode, par)
+    return par;
   },
 
   nextNode: function () {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
 
+    if (node.shadowRoot) {
+      console.log("Has shadow root.. looking for nexNODE: ", node.children.length);
+      this.currentNode = node.shadowRoot;
+      return node.shadowRoot;
+    }
+
     let nextNode = this.walker.nextNode();
     while (nextNode && this.isSkippedNode(nextNode)) {
       nextNode = this.walker.nextNode();
     }
 
     return nextNode;
   },
 
   firstChild: function () {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
+    console.log("First child", node, node.shadowRoot);
+    if (node.shadowRoot) {
+      console.log("Has shadow root.. looking for children: ", node.children.length);
+      this.currentNode = node.shadowRoot;
+      return node.shadowRoot;
+    }
 
     let firstChild = this.walker.firstChild();
     while (firstChild && this.isSkippedNode(firstChild)) {
       firstChild = this.walker.nextSibling();
     }
 
     return firstChild;
   },
 
   lastChild: function () {
     let node = this.walker.currentNode;
     if (!node) {
       return null;
     }
 
+    if (node.shadowRoot) {
+      this.currentNode = node.shadowRoot;
+      return node.shadowRoot;
+    }
+
     let lastChild = this.walker.lastChild();
     while (lastChild && this.isSkippedNode(lastChild)) {
       lastChild = this.walker.previousSibling();
     }
 
+    // if (!lastChild && node.shadowRoot) {
+    //   console.log("No last child for", node, node.shadowRoot);
+    //   // this.walker.currentNode = node.shadowRoot;
+    //   // return node.shadowRoot;
+    // }
+
     return lastChild;
   },
 
   previousSibling: function () {
     let node = this.walker.previousSibling();
+    if (node && node.host) {
+      return null;
+    }
     while (node && this.isSkippedNode(node)) {
+      // ShadowHost is the parent of every ShadowRoot
+      // if (node.host &&
+      //     node instanceof node.ownerDocument.defaultView.ShadowRoot) {
+      //   this.walker.currentNode = node.host;
+      //   return node.host;
+      // }
       node = this.walker.previousSibling();
     }
+
     return node;
   },
 
   nextSibling: function () {
     let node = this.walker.nextSibling();
+    if (node && node.host) {
+      return null;
+    }
     while (node && this.isSkippedNode(node)) {
       node = this.walker.nextSibling();
     }
     return node;
   },
 
   getStartingNode: function (node, skipTo) {
     // Keep a reference on the starting node in case we can't find a node compatible with
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -1402,17 +1402,17 @@ pref("privacy.trackingprotection.lower_n
 pref("privacy.trackingprotection.lower_network_priority", false);
 #endif
 
 pref("dom.event.contextmenu.enabled",       true);
 pref("dom.event.clipboardevents.enabled",   true);
 pref("dom.event.highrestimestamp.enabled",  true);
 pref("dom.event.coalesce_mouse_move",       true);
 
-pref("dom.webcomponents.enabled",           false);
+pref("dom.webcomponents.enabled",           true);
 #ifdef NIGHTLY_BUILD
 pref("dom.webcomponents.customelements.enabled", true);
 #else
 pref("dom.webcomponents.customelements.enabled", false);
 #endif
 
 pref("javascript.enabled",                  true);
 pref("javascript.options.strict",           false);
