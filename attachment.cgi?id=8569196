# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  dad115d9ea81b6ed9f2233551f02449ce39babed
Bug 1123851 - 4 - Add event-handling support for canvasframe native anonymous content

diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -409,20 +409,13 @@ div:-moz-native-anonymous.moz-selectionc
 div:-moz-native-anonymous.moz-selectioncaret-right.hidden > div {
   width: 0px;
   height: 0px;
   margin: 0px;
   visibility: hidden;
 }
 
 /* Custom content container in the CanvasFrame, fixed positioned on top of
-   everything else, not reacting to pointer events. */
+   everything else. */
 div:-moz-native-anonymous.moz-custom-content-container {
-  pointer-events: none;
-
   position: fixed;
-  top: 0;
-  left: 0;
-  width: 100%;
-  height: 100%;
-
   z-index: 2147483648;
 }
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -595,22 +595,23 @@ LayoutHelpers.isShadowAnonymous = functi
   return parent.shadowRoot && parent.shadowRoot.contains(node);
 };
 
 /**
  * Get the current zoom factor applied to the container window of a given node.
  * Container windows are used as a weakmap key to store the corresponding
  * nsIDOMWindowUtils instance to avoid querying it every time.
  *
- * @param {DOMNode} The node for which the zoom factor should be calculated
+ * @param {DOMNode|DOMWindow} The node for which the zoom factor should be
+ * calculated, or its owner window.
  * @return {Number}
  */
 let windowUtils = new WeakMap;
-LayoutHelpers.getCurrentZoom = function(node, map = z=>z) {
-  let win = node.ownerDocument.defaultView;
+LayoutHelpers.getCurrentZoom = function(node) {
+  let win = node.self === node ? node : node.ownerDocument.defaultView;
   let utils = windowUtils.get(win);
   if (utils) {
     return utils.fullZoom;
   }
 
   utils = win.QueryInterface(Ci.nsIInterfaceRequestor)
              .getInterface(Ci.nsIDOMWindowUtils);
   windowUtils.set(win, utils);
diff --git a/toolkit/devtools/gcli/commands/highlight.js b/toolkit/devtools/gcli/commands/highlight.js
--- a/toolkit/devtools/gcli/commands/highlight.js
+++ b/toolkit/devtools/gcli/commands/highlight.js
@@ -32,19 +32,21 @@ function destroyHighlighters() {
   }
   exports.highlighters.length = 0;
 }
 
 /**
  * Get an object that looks like a TabActor for instantiating highlighters
  */
 function getTabActorContext(env) {
+  let browser = env.chromeWindow.gBrowser.getBrowserForDocument(env.document);
   return {
-    browser: env.chromeWindow.gBrowser.getBrowserForDocument(env.document),
-    window: env.window
+    browser: browser,
+    window: env.window,
+    chromeEventHandler: browser.docShell.chromeEventHandler
   };
 }
 
 exports.items = [
   {
     name: "highlight",
     description: gcli.lookup("highlightDesc"),
     manual: gcli.lookup("highlightManual"),
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -9,20 +9,23 @@
   This stylesheet is loaded as a ua stylesheet via the addon sdk, so having this
   pseudo-class is important.
   Having bug 1086532 fixed would make it possible to load this stylesheet in a
   <style scoped> node instead, directly in the native anonymous container
   element.
 */
 
 :-moz-native-anonymous .highlighter-container {
+  position: absolute;
+  /* The container for all highlighters doesn't react to pointer-events by
+     default. This is because most highlighters cover the whole viewport and
+     don't need to be accessed.
+     If you are adding a new highlighter that needs interactivity, you need to
+     define 'pointer-events:auto;' on it. */
   pointer-events: none;
-  position: absolute;
-  width: 100%;
-  height: 100%;
 }
 
 :-moz-native-anonymous .highlighter-container [hidden] {
   display: none;
 }
 
 /* Box model highlighter */
 
@@ -176,16 +179,22 @@
 :-moz-native-anonymous .highlighted-rect {
   position: absolute;
   background: #80d4ff;
   opacity: 0.8;
 }
 
 /* Element geometry highlighter */
 
+:-moz-native-anonymous .geometry-editor-root {
+  /* The geometry editor can be interacted with, so it needs to react to
+     pointer events */
+  pointer-events: auto;
+}
+
 :-moz-native-anonymous .geometry-editor-offset-parent {
   stroke: #08c;
   shape-rendering: crispEdges;
   stroke-dasharray: 5 3;
   fill: transparent;
 }
 
 :-moz-native-anonymous .geometry-editor-current-node {
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -120,16 +120,17 @@ let HighlighterActor = exports.Highlight
     this._inspector = inspector;
     this._walker = this._inspector.walker;
     this._tabActor = this._inspector.tabActor;
 
     this._highlighterReady = this._highlighterReady.bind(this);
     this._highlighterHidden = this._highlighterHidden.bind(this);
     this._onNavigate = this._onNavigate.bind(this);
 
+    this._layoutHelpers = new LayoutHelpers(this._tabActor.window);
     this._createHighlighter();
 
     // Listen to navigation events to switch from the BoxModelHighlighter to the
     // SimpleOutlineHighlighter, and back, if the top level window changes.
     events.on(this._tabActor, "navigate", this._onNavigate);
   },
 
   get conn() this._inspector && this._inspector.conn,
@@ -174,16 +175,17 @@ let HighlighterActor = exports.Highlight
     protocol.Actor.prototype.destroy.call(this);
 
     this._destroyHighlighter();
     events.off(this._tabActor, "navigate", this._onNavigate);
     this._autohide = null;
     this._inspector = null;
     this._walker = null;
     this._tabActor = null;
+    this._layoutHelpers = null;
   },
 
   /**
    * Display the box model highlighting on a given NodeActor.
    * There is only one instance of the box model highlighter, so calling this
    * method several times won't display several highlighters, it will just move
    * the highlighter instance to these nodes.
    *
@@ -264,22 +266,23 @@ let HighlighterActor = exports.Highlight
 
     this._tabActor.window.focus();
     this._startPickerListeners();
 
     return null;
   }),
 
   _findAndAttachElement: function(event) {
-    let doc = event.target.ownerDocument;
-
     let x = event.clientX;
     let y = event.clientY;
 
-    let node = doc.elementFromPoint(x, y);
+    // Search for the node using elementFromPoint starting from the root window
+    // and going into nested iframes if needed.
+    let node = this._layoutHelpers.getElementFromPoint(
+      this._tabActor.window.document, x, y);
     return this._walker.attachElement(node);
   },
 
   _startPickerListeners: function() {
     let target = getPageListenerTarget(this._tabActor);
     target.addEventListener("mousemove", this._onHovered, true);
     target.addEventListener("click", this._onPick, true);
     target.addEventListener("mousedown", this._preventContentEvent, true);
@@ -439,30 +442,36 @@ function CanvasFrameAnonymousContentHelp
   this.anonymousContentDocument = this.tabActor.window.document;
   // XXX the next line is a wallpaper for bug 1123362.
   this.anonymousContentGlobal = Cu.getGlobalForObject(this.anonymousContentDocument);
 
   this._insert();
 
   this._onNavigate = this._onNavigate.bind(this);
   events.on(this.tabActor, "navigate", this._onNavigate);
+
+  this.listeners = new Map();
 }
 
+exports.CanvasFrameAnonymousContentHelper = CanvasFrameAnonymousContentHelper;
+
 CanvasFrameAnonymousContentHelper.prototype = {
   destroy: function() {
     // If the current window isn't the one the content was inserted into, this
     // will fail, but that's fine.
     try {
       let doc = this.anonymousContentDocument;
       doc.removeAnonymousContent(this._content);
     } catch (e) {console.error(e)}
     events.off(this.tabActor, "navigate", this._onNavigate);
     this.tabActor = this.nodeBuilder = this._content = null;
     this.anonymousContentDocument = null;
     this.anonymousContentGlobal = null;
+
+    this._removeAllListeners();
   },
 
   _insert: function() {
     // Re-insert the content node after page navigation only if the new page
     // isn't XUL.
     if (isXUL(this.tabActor)) {
       return;
     }
@@ -489,17 +498,19 @@ CanvasFrameAnonymousContentHelper.protot
     installHelperSheet(this.tabActor.window,
       "@import url('" + HIGHLIGHTER_STYLESHEET_URI + "');");
     let node = this.nodeBuilder();
     this._content = doc.insertAnonymousContent(node);
   },
 
   _onNavigate: function({isTopLevel}) {
     if (isTopLevel) {
+      this._removeAllListeners();
       this._insert();
+      this.anonymousContentDocument = this.tabActor.window.document;
     }
   },
 
   getTextContentForElement: function(id) {
     if (!this.content) {
       return null;
     }
     return this.content.getTextContentForElement(id);
@@ -525,24 +536,122 @@ CanvasFrameAnonymousContentHelper.protot
   },
 
   removeAttributeForElement: function(id, name) {
     if (this.content) {
       this.content.removeAttributeForElement(id, name);
     }
   },
 
+  /**
+   * Add an event listener to one of the elements inserted in the canvasFrame
+   * native anonymous container.
+   * Like other methods in this helper, this requires the ID of the element to
+   * be passed in.
+   *
+   * Note that if the content page navigates, the event listeners won't be
+   * added again.
+   *
+   * A single event listener is added per event types only, at the browser level
+   * and if the event originalTarget is found to have the provided ID, the
+   * callback is executed.
+   *
+   * IMPORTANT: the chrome-only canvasFrame insertion API takes great care of
+   * not leaking references to inserted elements to chrome JS code. That's
+   * because otherwise, chrome JS code could freely modify native anon elements
+   * inside the canvasFrame and probably change things that are assumed not to
+   * change by the C++ code managing this frame.
+   * See https://wiki.mozilla.org/DevTools/Highlighter#The_AnonymousContent_API
+   * Unfortunately, the inserted nodes are still available via
+   * event.originalTarget, and that's what the event handler here uses to check
+   * that the event actually occured on the right element, but that also means
+   * consumers of this code would be able to access the inserted elements.
+   * Therefore, the originalTarget property will be nullified before the event
+   * is passed to your handler.
+   *
+   * @param {String} id
+   * @param {String} type
+   * @param {Function} handler
+   */
+  addEventListenerForElement: function(id, type, handler) {
+    // If noone is listening for this type of event yet, add one listener.
+    if (!this.listeners.has(type)) {
+      let target = getPageListenerTarget(this.tabActor);
+      target.addEventListener(type, this, true);
+      // Each type entry in the map is a map of ids:handlers.
+      this.listeners.set(type, new Map);
+    }
+
+    let listeners = this.listeners.get(type);
+    listeners.set(id, handler);
+  },
+
+  /**
+   * Remove an event listener from one of the elements inserted in the
+   * canvasFrame native anonymous container.
+   * @param {String} id
+   * @param {String} type
+   * @param {Function} handler
+   */
+  removeEventListenerForElement: function(id, type, handler) {
+    let listeners = this.listeners.get(type);
+    if (!listeners) {
+      return;
+    }
+    listeners.delete(id);
+
+    // If noone is listening for event type anymore, remove the listener.
+    if (!this.listeners.has(type)) {
+      let target = getPageListenerTarget(this.tabActor);
+      target.removeEventListener(type, this, true);
+    }
+  },
+
+  handleEvent: function(event) {
+    let listeners = this.listeners.get(event.type);
+    if (!listeners) {
+      return;
+    }
+
+    let targetID = event.originalTarget.id;
+
+    // Hiding the originalTarget property to avoid exposing references to
+    // native anonymous elements. See addEventListenerForElement's comment.
+    event = Object.defineProperty(event, "originalTarget", {
+      get: () => null,
+      configurable: false
+    });
+
+    for (let [id, handler] of listeners) {
+      if (targetID === id) {
+        handler(event, id);
+      }
+    }
+  },
+
+  _removeAllListeners: function() {
+    if (this.tabActor) {
+      let target = getPageListenerTarget(this.tabActor);
+      for (let [type] of this.listeners) {
+        target.removeEventListener(type, this, true);
+      }
+    }
+    this.listeners.clear();
+  },
+
   getElement: function(id) {
     let self = this;
     return {
       getTextContent: () => self.getTextContentForElement(id),
       setTextContent: text => self.setTextContentForElement(id, text),
       setAttribute: (name, value) => self.setAttributeForElement(id, name, value),
       getAttribute: name => self.getAttributeForElement(id, name),
-      removeAttribute: name => self.removeAttributeForElement(id, name)
+      removeAttribute: name => self.removeAttributeForElement(id, name),
+      addEventListener: (type, handler) => self.addEventListenerForElement(id, type, handler),
+      removeEventListener: (type, handler) => self.removeEventListenerForElement(id, type, handler)
     };
   },
 
   get content() {
     if (!this._content || Cu.isDeadWrapper(this._content)) {
       return null;
     }
     return this._content;
@@ -832,21 +941,16 @@ function BoxModelHighlighter(tabActor) {
   this._currentNode = null;
 }
 
 BoxModelHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
   typeName: "BoxModelHighlighter",
 
   ID_CLASS_PREFIX: "box-model-",
 
-  get zoom() {
-    return this.win.QueryInterface(Ci.nsIInterfaceRequestor)
-               .getInterface(Ci.nsIDOMWindowUtils).fullZoom;
-  },
-
   get currentNode() {
     return this._currentNode;
   },
 
   set currentNode(node) {
     this._currentNode = node;
     this._computedStyle = null;
   },
@@ -869,19 +973,19 @@ BoxModelHighlighter.prototype = Heritage
 
     // Building the SVG element with its polygons and lines
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: rootWrapper,
       attributes: {
         "id": "elements",
-        "width": "100%",
-        "height": "100%",
-        "style": "width:100%;height:100%;",
+        "class": "elements",
+        "width": this.win.innerWidth,
+        "height": this.win.innerHeight,
         "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     let regions = createSVGNode(this.win, {
       nodeType: "g",
       parent: svg,
@@ -999,16 +1103,20 @@ BoxModelHighlighter.prototype = Heritage
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
 
     this._currentNode = null;
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(this.ID_CLASS_PREFIX + id);
+  },
+
   /**
    * Show the highlighter on a given node
    */
   _show: function() {
     if (BOX_MODEL_REGIONS.indexOf(this.options.region) == -1)  {
       this.options.region = "content";
     }
 
@@ -1039,16 +1147,22 @@ BoxModelHighlighter.prototype = Heritage
   /**
    * Update the highlighter on the current highlighted node (the one that was
    * passed as an argument to show(node)).
    * Should be called whenever node size or attributes change
    */
   _update: function() {
     setIgnoreLayoutChanges(true);
 
+    let svg = this.getElement("elements");
+    svg.setAttribute("width",
+      LayoutHelpers.getCurrentZoom(this.currentNode) * this.win.innerWidth);
+    svg.setAttribute("height",
+      LayoutHelpers.getCurrentZoom(this.currentNode) * this.win.innerHeight);
+
     if (this._updateBoxModel()) {
       if (!this.options.hideInfoBar) {
         this._showInfobar();
       } else {
         this._hideInfobar();
       }
       this._showBoxModel();
     } else {
@@ -1071,74 +1185,68 @@ BoxModelHighlighter.prototype = Heritage
 
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   /**
    * Hide the infobar
    */
   _hideInfobar: function() {
-    this.markup.setAttributeForElement(
-      this.ID_CLASS_PREFIX + "nodeinfobar-container", "hidden", "true");
+    this.getElement("nodeinfobar-container").setAttribute("hidden", "true");
   },
 
   /**
    * Show the infobar
    */
   _showInfobar: function() {
-    this.markup.removeAttributeForElement(
-      this.ID_CLASS_PREFIX + "nodeinfobar-container", "hidden");
+    this.getElement("nodeinfobar-container").removeAttribute("hidden");
     this._updateInfobar();
   },
 
   /**
    * Hide the box model
    */
   _hideBoxModel: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden", "true");
+    this.getElement("elements").setAttribute("hidden", "true");
   },
 
   /**
    * Show the box model
    */
   _showBoxModel: function() {
-    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden");
+    this.getElement("elements").removeAttribute("hidden");
   },
 
   /**
    * Update the box model as per the current node.
    *
    * @return {boolean}
    *         True if the current node has a box model to be highlighted
    */
   _updateBoxModel: function() {
     this.options.region = this.options.region || "content";
 
     if (this._nodeNeedsHighlighting()) {
       for (let boxType of BOX_MODEL_REGIONS) {
         let {p1, p2, p3, p4} = this.currentQuads[boxType];
+        let box = this.getElement(boxType);
 
         if (this.regionFill[boxType]) {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "style", "fill:" + this.regionFill[boxType]);
+          box.setAttribute("style", "fill:" + this.regionFill[boxType]);
         } else {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "style", "");
+          box.setAttribute("style", "");
         }
 
         if (!this.options.showOnly || this.options.showOnly === boxType) {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "points", p1.x + "," + p1.y + " " +
-                      p2.x + "," + p2.y + " " +
-                      p3.x + "," + p3.y + " " +
-                      p4.x + "," + p4.y);
+          box.setAttribute("points", p1.x + "," + p1.y + " " +
+                                     p2.x + "," + p2.y + " " +
+                                     p3.x + "," + p3.y + " " +
+                                     p4.x + "," + p4.y);
         } else {
-          this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + boxType, "points");
+          box.removeAttribute("points");
         }
 
         if (boxType === this.options.region && !this.options.hideGuides) {
           this._showGuides(p1, p2, p3, p4);
         } else if (this.options.hideGuides) {
           this._hideGuides();
         }
       }
@@ -1237,59 +1345,58 @@ BoxModelHighlighter.prototype = Heritage
     this._updateGuide("top", toShowY[0]);
     this._updateGuide("right", toShowX[1]);
     this._updateGuide("bottom", toShowY[1]);
     this._updateGuide("left", toShowX[0]);
   },
 
   _hideGuides: function() {
     for (let side of BOX_MODEL_SIDES) {
-      this.markup.setAttributeForElement(
-        this.ID_CLASS_PREFIX + "guide-" + side, "hidden", "true");
+      this.getElement("guide-" + side).setAttribute("hidden", "true");
     }
   },
 
   /**
    * Move a guide to the appropriate position and display it. If no point is
    * passed then the guide is hidden.
    *
    * @param  {String} side
    *         The guide to update
    * @param  {Integer} point
    *         x or y co-ordinate. If this is undefined we hide the guide.
    */
   _updateGuide: function(side, point=-1) {
-    let guideId = this.ID_CLASS_PREFIX + "guide-" + side;
+    let guide = this.getElement("guide-" + side);
 
     if (point <= 0) {
-      this.markup.setAttributeForElement(guideId, "hidden", "true");
+      guide.setAttribute("hidden", "true");
       return false;
     }
 
     let offset = GUIDE_STROKE_WIDTH / 2;
 
     if (side === "top" || side === "left") {
       point -= offset;
     } else {
       point += offset;
     }
 
     if (side === "top" || side === "bottom") {
-      this.markup.setAttributeForElement(guideId, "x1", "0");
-      this.markup.setAttributeForElement(guideId, "y1", point + "");
-      this.markup.setAttributeForElement(guideId, "x2", "100%");
-      this.markup.setAttributeForElement(guideId, "y2", point + "");
+      guide.setAttribute("x1", "0");
+      guide.setAttribute("y1", point + "");
+      guide.setAttribute("x2", "100%");
+      guide.setAttribute("y2", point + "");
     } else {
-      this.markup.setAttributeForElement(guideId, "x1", point + "");
-      this.markup.setAttributeForElement(guideId, "y1", "0");
-      this.markup.setAttributeForElement(guideId, "x2", point + "");
-      this.markup.setAttributeForElement(guideId, "y2", "100%");
+      guide.setAttribute("x1", point + "");
+      guide.setAttribute("y1", "0");
+      guide.setAttribute("x2", point + "");
+      guide.setAttribute("y2", "100%");
     }
 
-    this.markup.removeAttributeForElement(guideId, "hidden");
+    guide.removeAttribute("hidden");
 
     return true;
   },
 
   /**
    * Update node information (tagName#id.class)
    */
   _updateInfobar: function() {
@@ -1314,74 +1421,74 @@ BoxModelHighlighter.prototype = Heritage
       // Display :after as ::after
       pseudos += ":" + pseudo;
     }
 
     let rect = this.currentQuads.border.bounds;
     let dim = parseFloat(rect.width.toPrecision(6)) + " \u00D7 " + parseFloat(rect.height.toPrecision(6));
 
     let elementId = this.ID_CLASS_PREFIX + "nodeinfobar-";
-    this.markup.setTextContentForElement(elementId + "tagname", tagName);
-    this.markup.setTextContentForElement(elementId + "id", id);
-    this.markup.setTextContentForElement(elementId + "classes", classList);
-    this.markup.setTextContentForElement(elementId + "pseudo-classes", pseudos);
-    this.markup.setTextContentForElement(elementId + "dimensions", dim);
+    this.getElement("nodeinfobar-tagname").setTextContent(tagName);
+    this.getElement("nodeinfobar-id").setTextContent(id);
+    this.getElement("nodeinfobar-classes").setTextContent(classList);
+    this.getElement("nodeinfobar-pseudo-classes").setTextContent(pseudos);
+    this.getElement("nodeinfobar-dimensions").setTextContent(dim);
 
     this._moveInfobar();
   },
 
   /**
    * Move the Infobar to the right place in the highlighter.
    */
   _moveInfobar: function() {
     let bounds = this._getOuterBounds();
-    let winHeight = this.win.innerHeight * this.zoom;
-    let winWidth = this.win.innerWidth * this.zoom;
+    let winHeight = this.win.innerHeight * LayoutHelpers.getCurrentZoom(this.win);
+    let winWidth = this.win.innerWidth * LayoutHelpers.getCurrentZoom(this.win);
 
     // Ensure that containerBottom and containerTop are at least zero to avoid
     // showing tooltips outside the viewport.
     let containerBottom = Math.max(0, bounds.bottom) + NODE_INFOBAR_ARROW_SIZE;
     let containerTop = Math.min(winHeight, bounds.top);
-    let containerId = this.ID_CLASS_PREFIX + "nodeinfobar-container";
+    let container = this.getElement("nodeinfobar-container");
 
     // Can the bar be above the node?
     let top;
     if (containerTop < NODE_INFOBAR_HEIGHT) {
       // No. Can we move the bar under the node?
       if (containerBottom + NODE_INFOBAR_HEIGHT > winHeight) {
         // No. Let's move it inside.
         top = containerTop;
-        this.markup.setAttributeForElement(containerId, "position", "overlap");
+        container.setAttribute("position", "overlap");
       } else {
         // Yes. Let's move it under the node.
         top = containerBottom;
-        this.markup.setAttributeForElement(containerId, "position", "bottom");
+        container.setAttribute("position", "bottom");
       }
     } else {
       // Yes. Let's move it on top of the node.
       top = containerTop - NODE_INFOBAR_HEIGHT;
-      this.markup.setAttributeForElement(containerId, "position", "top");
+      container.setAttribute("position", "top");
     }
 
     // Align the bar with the box's center if possible.
     let left = bounds.right - bounds.width / 2;
     // Make sure the while infobar is visible.
     let buffer = 100;
     if (left < buffer) {
       left = buffer;
-      this.markup.setAttributeForElement(containerId, "hide-arrow", "true");
+      container.setAttribute("hide-arrow", "true");
     } else if (left > winWidth - buffer) {
       left = winWidth - buffer;
-      this.markup.setAttributeForElement(containerId, "hide-arrow", "true");
+      container.setAttribute("hide-arrow", "true");
     } else {
-      this.markup.removeAttributeForElement(containerId, "hide-arrow");
+      container.removeAttribute("hide-arrow");
     }
 
     let style = "top:" + top + "px;left:" + left + "px;";
-    this.markup.setAttributeForElement(containerId, "style", style);
+    container.setAttribute("style", style);
   }
 });
 register(BoxModelHighlighter);
 exports.BoxModelHighlighter = BoxModelHighlighter;
 
 /**
  * The CssTransformHighlighter is the class that draws an outline around a
  * transformed element and an outline around where it would be if untransformed
@@ -1421,18 +1528,18 @@ CssTransformHighlighter.prototype = Heri
     });
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: rootWrapper,
       attributes: {
         "id": "elements",
         "hidden": "true",
-        "width": "100%",
-        "height": "100%"
+        "width": this.win.innerWidth,
+        "height": this.win.innerHeight
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     // Add a marker tag to the svg root for the arrow tip
     this.markerId = "arrow-marker-" + MARKER_COUNTER;
     MARKER_COUNTER ++;
     let marker = createSVGNode(this.win, {
@@ -1504,16 +1611,20 @@ CssTransformHighlighter.prototype = Heri
   /**
    * Destroy the nodes. Remove listeners.
    */
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
     this.markup.destroy();
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(this.ID_CLASS_PREFIX + id);
+  },
+
   /**
    * Show the highlighter on a given node
    * @param {DOMNode} node
    */
   _show: function() {
     if (!this._isTransformed(this.currentNode)) {
       this.hide();
       return;
@@ -1530,44 +1641,48 @@ CssTransformHighlighter.prototype = Heri
     return style && (style.transform !== "none" && style.display !== "inline");
   },
 
   _setPolygonPoints: function(quad, id) {
     let points = [];
     for (let point of ["p1","p2", "p3", "p4"]) {
       points.push(quad[point].x + "," + quad[point].y);
     }
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id,
-                                       "points",
-                                       points.join(" "));
+    this.getElement(id).setAttribute("points", points.join(" "));
   },
 
   _setLinePoints: function(p1, p2, id) {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "x1", p1.x);
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "y1", p1.y);
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "x2", p2.x);
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "y2", p2.y);
+    let line = this.getElement(id);
+    line.setAttribute("x1", p1.x);
+    line.setAttribute("y1", p1.y);
+    line.setAttribute("x2", p2.x);
+    line.setAttribute("y2", p2.y);
 
     let dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
     if (dist < ARROW_LINE_MIN_DISTANCE) {
-      this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + id, "marker-end");
+      line.removeAttribute("marker-end");
     } else {
-      this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "marker-end",
-                                         "url(#" + this.markerId + ")");
+      line.setAttribute("marker-end", "url(#" + this.markerId + ")");
     }
   },
 
   /**
    * Update the highlighter on the current highlighted node (the one that was
    * passed as an argument to show(node)).
    * Should be called whenever node size or attributes change
    */
   _update: function() {
     setIgnoreLayoutChanges(true);
 
+    let svg = this.getElement("elements");
+    svg.setAttribute("width",
+      LayoutHelpers.getCurrentZoom(this.currentNode) * this.win.innerWidth);
+    svg.setAttribute("height",
+      LayoutHelpers.getCurrentZoom(this.currentNode) * this.win.innerHeight);
+
     // Getting the points for the transformed shape
     let quad = this.currentQuads.border;
     if (!quad || quad.bounds.width <= 0 || quad.bounds.height <= 0) {
       this._hideShapes();
       return null;
     }
 
     // Getting the points for the untransformed shape
@@ -1592,23 +1707,21 @@ CssTransformHighlighter.prototype = Heri
    */
   _hide: function() {
     setIgnoreLayoutChanges(true);
     this._hideShapes();
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   _hideShapes: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden", "true");
+    this.getElement("elements").setAttribute("hidden", "true");
   },
 
   _showShapes: function() {
-    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden");
+    this.getElement("elements").removeAttribute("hidden");
   }
 });
 register(CssTransformHighlighter);
 exports.CssTransformHighlighter = CssTransformHighlighter;
 
 
 /**
  * The SelectorHighlighter runs a given selector through querySelectorAll on the
@@ -1868,19 +1981,18 @@ GeometryEditorHighlighter.prototype = He
       prefix: this.ID_CLASS_PREFIX
     });
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: root,
       attributes: {
         "id": "elements",
-        "width": "100%",
-        "height": "100%",
-        "style": "width:100%;height:100%;"
+        "width": this.win.innerWidth,
+        "height": this.win.innerHeight
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     // Offset parent node highlighter.
     createSVGNode(this.win, {
       nodeType: "polygon",
       parent: svg,
@@ -2014,16 +2126,20 @@ GeometryEditorHighlighter.prototype = He
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
     this.definedProperties.clear();
     this.definedProperties = null;
     this.offsetParent = null;
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(this.ID_CLASS_PREFIX + id);
+  },
+
   /**
    * Get the list of geometry properties that are actually set on the current
    * node.
    * @return {Map} A map indexed by property name and where the value is an
    * object having the cssRule property.
    */
   getDefinedGeometryProperties: function() {
     let props = new Map();
@@ -2108,16 +2224,22 @@ GeometryEditorHighlighter.prototype = He
 
     if (!this.definedProperties.size) {
       console.warn("The element does not have editable geometry properties");
       return false;
     }
 
     setIgnoreLayoutChanges(true);
 
+    let svg = this.getElement("elements");
+    svg.setAttribute("width",
+      LayoutHelpers.getCurrentZoom(this.currentNode) * this.win.innerWidth);
+    svg.setAttribute("height",
+      LayoutHelpers.getCurrentZoom(this.currentNode) * this.win.innerHeight);
+
     // Update the highlighters and arrows.
     this.updateOffsetParent();
     this.updateCurrentNode();
     this.updateArrows();
     this.updateSize();
 
     // Avoid zooming the arrows when content is zoomed.
     this.markup.scaleRootElement(this.currentNode, this.ID_CLASS_PREFIX + "root");
@@ -2140,17 +2262,17 @@ GeometryEditorHighlighter.prototype = He
    */
   updateOffsetParent: function() {
     // Get the offsetParent, if any.
     this.offsetParent = getOffsetParent(this.currentNode);
     // And the offsetParent quads.
     this.parentQuads = this.layoutHelpers
                        .getAdjustedQuads(this.offsetParent.element, "padding");
 
-    let el = this.markup.getElement(this.ID_CLASS_PREFIX + "offset-parent");
+    let el = this.getElement("offset-parent");
 
     let isPositioned = this.computedStyle.position === "absolute" ||
                        this.computedStyle.position === "fixed";
     let isRelative = this.computedStyle.position === "relative";
     let isHighlighted = false;
 
     if (this.offsetParent.element && isPositioned) {
       let {p1, p2, p3, p4} = this.parentQuads;
@@ -2177,51 +2299,48 @@ GeometryEditorHighlighter.prototype = He
     if (isHighlighted) {
       el.removeAttribute("hidden");
     } else {
       el.setAttribute("hidden", "true");
     }
   },
 
   updateCurrentNode: function() {
-    let box = this.markup.getElement(this.ID_CLASS_PREFIX + "current-node");
+    let box = this.getElement("current-node");
     let {p1, p2, p3, p4} = this.currentQuads.margin;
     let attr = p1.x + "," + p1.y + " " +
                p2.x + "," + p2.y + " " +
                p3.x + "," + p3.y + " " +
                p4.x + "," + p4.y;
     box.setAttribute("points", attr);
     box.removeAttribute("hidden");
   },
 
   _hide: function() {
     setIgnoreLayoutChanges(true);
 
-    let id = this.ID_CLASS_PREFIX;
-    this.markup.setAttributeForElement(id + "current-node", "hidden", "true");
-    this.markup.setAttributeForElement(id + "offset-parent", "hidden", "true");
+    this.getElement("current-node").setAttribute("hidden", "true");
+    this.getElement("offset-parent").setAttribute("hidden", "true");
     this.hideArrows();
     this.hideSize();
 
     this.definedProperties.clear();
 
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   hideArrows: function() {
     for (let side of GeoProp.SIDES) {
-      let id = this.ID_CLASS_PREFIX;
-      this.markup.setAttributeForElement(id + "arrow-" + side, "hidden", "true");
-      this.markup.setAttributeForElement(id + "label-" + side, "hidden", "true");
+      this.getElement("arrow-" + side).setAttribute("hidden", "true");
+      this.getElement("label-" + side).setAttribute("hidden", "true");
     }
   },
 
   hideSize: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "label-size",
-      "hidden", "true");
+    this.getElement("label-size").setAttribute("hidden", "true");
   },
 
   updateSize: function() {
     this.hideSize();
 
     let labels = [];
     let width = this.definedProperties.get("width");
     let height = this.definedProperties.get("height");
@@ -2229,19 +2348,18 @@ GeometryEditorHighlighter.prototype = He
     if (width) {
       labels.push("↔ " + width.cssRule.style.getPropertyValue("width"));
     }
     if (height) {
       labels.push("↕ " + height.cssRule.style.getPropertyValue("height"));
     }
 
     if (labels.length) {
-      let id = this.ID_CLASS_PREFIX;
-      let labelEl = this.markup.getElement(id + "label-size");
-      let labelTextEl = this.markup.getElement(id + "label-text-size");
+      let labelEl = this.getElement("label-size");
+      let labelTextEl = this.getElement("label-text-size");
 
       let {bounds} = this.currentQuads.margin;
 
       labelEl.setAttribute("transform", "translate(" +
         (bounds.left + bounds.width/2) + " " +
         (bounds.top + bounds.height/2) + ")");
       labelEl.removeAttribute("hidden");
       labelTextEl.setTextContent(labels.join(" "));
@@ -2309,20 +2427,19 @@ GeometryEditorHighlighter.prototype = He
                          marginBox[GeoProp.crossAxisSize(side)] / 2;
 
       this.updateArrow(side, mainAxisStartPos, mainAxisEndPos, crossAxisPos,
                        sideProp.cssRule.style.getPropertyValue(side));
     }
   },
 
   updateArrow: function(side, mainStart, mainEnd, crossPos, labelValue) {
-    let id = this.ID_CLASS_PREFIX;
-    let arrowEl = this.markup.getElement(id + "arrow-" + side);
-    let labelEl = this.markup.getElement(id + "label-" + side);
-    let labelTextEl = this.markup.getElement(id + "label-text-" + side);
+    let arrowEl = this.getElement("arrow-" + side);
+    let labelEl = this.getElement("label-" + side);
+    let labelTextEl = this.getElement("label-text-" + side);
 
     // Position the arrow <line>.
     arrowEl.setAttribute(GeoProp.axis(side) + "1", mainStart);
     arrowEl.setAttribute(GeoProp.crossAxis(side) + "1", crossPos);
     arrowEl.setAttribute(GeoProp.axis(side) + "2", mainEnd);
     arrowEl.setAttribute(GeoProp.crossAxis(side) + "2", crossPos);
     arrowEl.removeAttribute("hidden");
 
diff --git a/toolkit/devtools/server/tests/browser/browser.ini b/toolkit/devtools/server/tests/browser/browser.ini
--- a/toolkit/devtools/server/tests/browser/browser.ini
+++ b/toolkit/devtools/server/tests/browser/browser.ini
@@ -20,16 +20,20 @@ support-files =
 [browser_animation_actors_03.js]
 [browser_animation_actors_04.js]
 [browser_animation_actors_05.js]
 [browser_animation_actors_06.js]
 [browser_animation_actors_07.js]
 [browser_animation_actors_08.js]
 [browser_animation_actors_09.js]
 [browser_animation_actors_10.js]
+[browser_canvasframe_helper_01.js]
+[browser_canvasframe_helper_02.js]
+[browser_canvasframe_helper_03.js]
+[browser_canvasframe_helper_04.js]
 [browser_navigateEvents.js]
 [browser_storage_dynamic_windows.js]
 [browser_storage_listings.js]
 [browser_storage_updates.js]
 [browser_timeline.js]
 skip-if = buildapp == 'mulet'
 [browser_timeline_actors.js]
 skip-if = buildapp == 'mulet'
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_01.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_01.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_01.js
@@ -0,0 +1,89 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Simple CanvasFrameAnonymousContentHelper tests.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const TEST_URL = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    child.textContent = "test element";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+
+  ok(helper.content instanceof AnonymousContent,
+    "The helper owns the AnonymousContent object");
+  ok(helper.getTextContentForElement,
+    "The helper has the getTextContentForElement method");
+  ok(helper.setTextContentForElement,
+    "The helper has the setTextContentForElement method");
+  ok(helper.setAttributeForElement,
+    "The helper has the setAttributeForElement method");
+  ok(helper.getAttributeForElement,
+    "The helper has the getAttributeForElement method");
+  ok(helper.removeAttributeForElement,
+    "The helper has the removeAttributeForElement method");
+  ok(helper.addEventListenerForElement,
+    "The helper has the addEventListenerForElement method");
+  ok(helper.removeEventListenerForElement,
+    "The helper has the removeEventListenerForElement method");
+  ok(helper.getElement,
+    "The helper has the getElement method");
+  ok(helper.scaleRootElement,
+    "The helper has the scaleRootElement method");
+
+  is(helper.getTextContentForElement("child-element"), "test element",
+    "The text content was retrieve correctly");
+  is(helper.getAttributeForElement("child-element", "id"), "child-element",
+    "The ID attribute was retrieve correctly");
+  is(helper.getAttributeForElement("child-element", "class"), "child-element",
+    "The class attribute was retrieve correctly");
+
+  let el = helper.getElement("child-element");
+  ok(el, "The DOMNode-like element was created");
+
+  is(el.getTextContent(), "test element",
+    "The text content was retrieve correctly");
+  is(el.getAttribute("id"), "child-element",
+    "The ID attribute was retrieve correctly");
+  is(el.getAttribute("class"), "child-element",
+    "The class attribute was retrieve correctly");
+
+  info("Destroying the helper");
+  helper.destroy();
+
+  ok(!helper.getTextContentForElement("child-element"),
+    "No text content was retrieved after the helper was destroyed");
+  ok(!helper.getAttributeForElement("child-element", "id"),
+    "No ID attribute was retrieved after the helper was destroyed");
+  ok(!helper.getAttributeForElement("child-element", "class"),
+    "No class attribute was retrieved after the helper was destroyed");
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_02.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_02.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_02.js
@@ -0,0 +1,44 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the CanvasFrameAnonymousContentHelper does not insert content in
+// XUL windows.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+
+add_task(function*() {
+  let doc = yield addTab("about:preferences");
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    child.textContent = "test element";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+  ok(!helper.content, "The AnonymousContent was not inserted in the window");
+  ok(!helper.getTextContentForElement("child-element"),
+    "No text content is returned");
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_03.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_03.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_03.js
@@ -0,0 +1,99 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test the CanvasFrameAnonymousContentHelper event handling mechanism.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const TEST_URL = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "pointer-events:auto;width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+
+  let el = helper.getElement("child-element");
+
+  info("Adding an event listener on the inserted element");
+  let mouseDownHandled = 0;
+  function onMouseDown(e, id) {
+    is(id, "child-element", "The mousedown event was triggered on the element");
+    mouseDownHandled ++;
+  }
+  el.addEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing an event on the inserted element");
+  let onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1, "The mousedown event was handled once on the element");
+
+  info("Synthesizing an event somewhere else");
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(400, 400, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1, "The mousedown event was not handled on the element");
+
+  info("Removing the event listener");
+  el.removeEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing another event after the listener has been removed");
+  // Using a document event listener to know when the event has been synthesized.
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1,
+    "The mousedown event hasn't been handled after the listener was removed");
+
+  info("Adding again the event listener");
+  el.addEventListener("mousedown", onMouseDown);
+
+  info("Destroying the helper");
+  helper.destroy();
+
+  info("Synthesizing another event after the helper has been destroyed");
+  // Using a document event listener to know when the event has been synthesized.
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1,
+    "The mousedown event hasn't been handled after the helper was destroyed");
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
+
+function synthesizeMouseDown(x, y, win) {
+  // It looks like we need to wait a bit before synthesizing the event if we
+  // want it to be handled by the native anonymous content.
+  executeSoon(() => {
+    EventUtils.synthesizeMouseAtPoint(x, y, {type: "mousedown"}, win);
+  });
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_04.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_04.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_04.js
@@ -0,0 +1,100 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test the CanvasFrameAnonymousContentHelper re-inserts the content when the
+// page reloads.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const events = require("sdk/event/core");
+const TEST_URL_1 = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test 1";
+const TEST_URL_2 = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test 2";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL_2);
+
+  let tabActor = getTabActor(doc.defaultView);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "pointer-events:auto;width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    child.textContent= "test content";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(tabActor, nodeBuilder);
+
+  info("Get an element from the helper");
+  let el = helper.getElement("child-element");
+
+  info("Try to access the element");
+  is(el.getAttribute("class"), "child-element",
+    "The attribute is correct before navigation");
+  is(el.getTextContent(), "test content",
+    "The text content is correct before navigation");
+
+  info("Add an event listener on the element");
+  let mouseDownHandled = 0;
+  function onMouseDown(e, id) {
+    is(id, "child-element", "The mousedown event was triggered on the element");
+    mouseDownHandled ++;
+  }
+  el.addEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing an event on the element");
+  let onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+  is(mouseDownHandled, 1, "The mousedown event was handled once before navigation");
+
+  info("Navigating to a new page");
+  let loaded = once(gBrowser.selectedBrowser, "load", true);
+  content.location = TEST_URL_2;
+  yield loaded;
+  doc = gBrowser.selectedBrowser.contentWindow.document;
+
+  info("And faking the 'navigate' event on the tabActor");
+  events.emit(tabActor, "navigate", {window: doc.defaultView, isTopLevel: true});
+
+  info("Try to access the element again");
+  is(el.getAttribute("class"), "child-element",
+    "The attribute is correct after navigation");
+  is(el.getTextContent(), "test content",
+    "The text content is correct after navigation");
+
+  info("Synthesizing an event on the element again");
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+  is(mouseDownHandled, 1, "The mousedown event was not handled after navigation");
+
+  info("Destroying the helper");
+  helper.destroy();
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
+
+function synthesizeMouseDown(x, y, win) {
+  // It looks like we need to wait a bit before synthesizing the event if we
+  // want it to be handled by the native anonymous content.
+  executeSoon(() => {
+    EventUtils.synthesizeMouseAtPoint(x, y, {type: "mousedown"}, win);
+  });
+}
