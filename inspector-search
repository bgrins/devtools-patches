# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  3e73d9b001c38e4190a9d8bfa55099792b223b03
Bug 835896 - Inspector searchbox should also provide a way to search plain text on the page

diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -298,23 +298,40 @@ InspectorPanel.prototype = {
   markDirty: function InspectorPanel_markDirty() {
     this.isDirty = true;
   },
 
   /**
    * Hooks the searchbar to show result and auto completion suggestions.
    */
   setupSearchBox: function InspectorPanel_setupSearchBox() {
-    // Initiate the selectors search object.
-    if (this.searchSuggestions) {
-      this.searchSuggestions.destroy();
-      this.searchSuggestions = null;
+    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
+    this.search = new SelectorSearch(this, this.searchBox);
+    this.searchLabel = this.searchBox.ownerDocument.createElement("box");
+    this.searchBox.parentNode.insertBefore(this.searchLabel, this.searchBox);
+
+    this._updateSearchLabel = this._updateSearchLabel.bind(this);
+    this.search.on("search-cleared", this._updateSearchLabel);
+    this.search.on("search-no-result", this._updateSearchLabel);
+    this.search.on("search-result", this._updateSearchLabel);
+  },
+
+  _updateSearchLabel: function(event, result) {
+    let str = "";
+    if (result) {
+      str = this.strings.formatStringFromName(
+        "inspector.searchResultsCount",
+        [result.resultsIndex, result.resultsLength], 2);
+    } else if (event === "search-no-result") {
+      str = this.strings.GetStringFromName("inspector.searchResultsNone");
     }
-    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
-    this.searchSuggestions = new SelectorSearch(this, this.searchBox);
+
+    // XXX Clear the label when clear button is clicked.
+
+    this.searchLabel.textContent = str;
   },
 
   /**
    * Build the sidebar.
    */
   setupSidebar: function InspectorPanel_setupSidebar() {
     let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
     this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
@@ -388,17 +405,16 @@ InspectorPanel.prototype = {
       this.selection.setNodeFront(defaultNode, "navigateaway");
 
       this._initMarkup();
       this.once("markuploaded", () => {
         if (!this.markup) {
           return;
         }
         this.markup.expandNode(this.selection.nodeFront);
-        this.setupSearchBox();
         this.emit("new-root");
       });
     };
     this._pendingSelection = onNodeSelected;
     this._getDefaultNodeForSelection().then(onNodeSelected, console.error);
   },
 
   _selectionCssSelector: null,
@@ -581,32 +597,32 @@ InspectorPanel.prototype = {
     this.sidebar = null;
 
     this.nodemenu.removeEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.removeEventListener("popuphiding", this._resetNodeMenu, true);
     this.breadcrumbs.destroy();
     this._paneToggleButton.removeEventListener("mousedown",
       this.onPaneToggleButtonClicked);
     this._paneToggleButton = null;
-    this.searchSuggestions.destroy();
-    this.searchBox = null;
     this.selection.off("new-node-front", this.onNewSelection);
     this.selection.off("before-new-node", this.onBeforeNewSelection);
     this.selection.off("before-new-node-front", this.onBeforeNewSelection);
     this.selection.off("detached-front", this.onDetached);
     let markupDestroyer = this._destroyMarkup();
     this.panelWin.inspector = null;
     this.target = null;
     this.panelDoc = null;
     this.panelWin = null;
     this.breadcrumbs = null;
-    this.searchSuggestions = null;
     this.lastNodemenuItem = null;
     this.nodemenu = null;
     this._toolbox = null;
+    this.search.destroy();
+    this.search = null;
+    this.searchBox = null;
 
     this._panelDestroyer = promise.all([
       sidebarDestroyer,
       markupDestroyer
     ]);
 
     return this._panelDestroyer;
   },
diff --git a/browser/devtools/inspector/inspector.xul b/browser/devtools/inspector/inspector.xul
--- a/browser/devtools/inspector/inspector.xul
+++ b/browser/devtools/inspector/inspector.xul
@@ -120,17 +120,17 @@
         <arrowscrollbox id="inspector-breadcrumbs"
           class="breadcrumbs-widget-container"
           flex="1" orient="horizontal"
           clicktoscroll="true"/>
         <textbox id="inspector-searchbox"
           type="search"
           timeout="50"
           class="devtools-searchinput"
-          placeholder="&inspectorSearchHTML.label2;"/>
+          placeholder="&inspectorSearchHTML.label3;"/>
         <toolbarbutton id="inspector-pane-toggle"
           class="devtools-toolbarbutton"
           tabindex="0" />
       </toolbar>
       <vbox flex="1" id="markup-box">
       </vbox>
     </vbox>
     <splitter class="devtools-side-splitter"/>
diff --git a/browser/devtools/inspector/selector-search.js b/browser/devtools/inspector/selector-search.js
--- a/browser/devtools/inspector/selector-search.js
+++ b/browser/devtools/inspector/selector-search.js
@@ -1,48 +1,153 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-const { Cu } = require("chrome");
+const {Cu, Ci} = require("chrome");
 
 const promise = require("resource://gre/modules/Promise.jsm").Promise;
 loader.lazyGetter(this, "EventEmitter", () => require("devtools/toolkit/event-emitter"));
 loader.lazyGetter(this, "AutocompletePopup", () => require("devtools/shared/autocomplete-popup").AutocompletePopup);
 
 // Maximum number of selector suggestions shown in the panel.
 const MAX_SUGGESTIONS = 15;
 
+
+/**
+ * Converts any input field into a document search box.
+ *
+ * @param {InspectorPanel} inspector The InspectorPanel whose `walker` attribute
+ * should be used for document traversal.
+ * @param {DomNode} input The input element to which the panel will be attached
+ * and from where search input will be taken.
+ *
+ * Emits the following events:
+ * - search-cleared: when the search box is emptied
+ * - search-no-result: when a search is made that yields no result
+ * - search-result: when a search is made and a result is selected
+ */
+function SelectorSearch(inspector, input) {
+  this.inspector = inspector;
+  this.searchBox = input;
+  this._lastSearched = null;
+
+  this._onKeyDown = this._onKeyDown.bind(this);
+  this.searchBox.addEventListener("keydown", this._onKeyDown, true);
+
+  // For testing, we need to be able to wait for the most recent node request
+  // to finish.  Tests can watch this promise for that.
+  this._lastQuery = promise.resolve(null);
+
+  this.autocompleter = new SelectorAutocompleter(inspector, input);
+  EventEmitter.decorate(this);
+}
+
+exports.SelectorSearch = SelectorSearch;
+
+SelectorSearch.prototype = {
+  get walker() this.inspector.walker,
+
+  destroy: function() {
+    this.searchBox.removeEventListener("keydown", this._onKeyDown, true);
+    this.searchBox = null;
+    this.autocompleter.destroy();
+  },
+
+  _onSearch: Task.async(function*(reverse = false) {
+    if (typeof this.hasWalkerSearch === "undefined") {
+      let target = this.inspector.toolbox.target;
+      this.hasWalkerSearch = yield target.actorHasMethod("domwalker",
+        "search");
+    }
+    if (typeof this.hasMultiFrameSearch === "undefined") {
+      let target = this.inspector.toolbox.target;
+      this.hasMultiFrameSearch = yield target.actorHasMethod("domwalker",
+        "multiFrameQuerySelectorAll");
+    }
+
+    // If we are talking to an old server, then don't perform any
+    // search.
+    this._lastQuery = this.doFullTextSearch(this.searchBox.value, reverse);
+  }),
+
+  doFullTextSearch: Task.async(function*(query, reverse) {
+    this._lastSearched = query;
+
+    if (query.length == 0) {
+      this.searchBox.removeAttribute("filled");
+      this.searchBox.classList.remove("devtools-no-search-result");
+      this.emit("search-cleared");
+      return;
+    }
+
+    this.searchBox.setAttribute("filled", true);
+    let res = yield this.walker.search(query, {
+      reverse: reverse,
+      hasMultiFrameSearch: this.hasMultiFrameSearch,
+      hasWalkerSearch: this.hasWalkerSearch,
+      selectorOnly: true
+    });
+
+    // Value has changed since we started this request, we're done.
+    if (query != this.searchBox.value) {
+      return;
+    }
+
+    if (res) {
+      this.inspector.selection.setNodeFront(res.node, "selectorsearch");
+      this.searchBox.classList.remove("devtools-no-search-result");
+
+      res.query = query;
+      this.emit("search-result", res);
+    } else {
+      this.searchBox.classList.add("devtools-no-search-result");
+      this.emit("search-no-result");
+    }
+  }),
+
+  _onKeyDown: function(event) {
+    if (event.keyCode === event.DOM_VK_RETURN) {
+      this._onSearch();
+    } if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_G && event.metaKey) {
+      this._onSearch(event.shiftKey);
+      event.preventDefault();
+    }
+  }
+};
+
+
+
 /**
  * Converts any input box on a page to a CSS selector search and suggestion box.
  *
  * Emits 'processing-done' event when it is done processing the current
  * keypress, search request or selection from the list, whether that led to a
  * search or not.
  *
  * @constructor
  * @param InspectorPanel aInspector
  *        The InspectorPanel whose `walker` attribute should be used for
  *        document traversal.
  * @param nsiInputElement aInputNode
  *        The input element to which the panel will be attached and from where
  *        search input will be taken.
  */
-function SelectorSearch(aInspector, aInputNode) {
+function SelectorAutocompleter(aInspector, aInputNode) {
   this.inspector = aInspector;
   this.searchBox = aInputNode;
   this.panelDoc = this.searchBox.ownerDocument;
 
   // initialize variables.
   this._lastSearched = null;
   this._lastValidSearch = "";
   this._lastToLastValidSearch = null;
-  this._searchResults = null;
+  this._searchResults = [];
   this._searchSuggestions = {};
   this._searchIndex = 0;
 
   // bind!
   this._showPopup = this._showPopup.bind(this);
   this._onHTMLSearch = this._onHTMLSearch.bind(this);
   this._onSearchKeypress = this._onSearchKeypress.bind(this);
   this._onListBoxKeypress = this._onListBoxKeypress.bind(this);
@@ -54,30 +159,32 @@ function SelectorSearch(aInspector, aInp
     autoSelect: true,
     position: "before_start",
     direction: "ltr",
     theme: "auto",
     onClick: this._onListBoxKeypress,
     onKeypress: this._onListBoxKeypress
   };
   this.searchPopup = new AutocompletePopup(this.panelDoc, options);
-
-  // event listeners.
-  this.searchBox.addEventListener("command", this._onHTMLSearch, true);
+  this.searchBox.addEventListener("input", () => {
+    this.showSuggestions();
+  }, true);
+  // // event listeners.
+  // this.searchBox.addEventListener("command", this._onHTMLSearch, true);
   this.searchBox.addEventListener("keypress", this._onSearchKeypress, true);
 
-  // For testing, we need to be able to wait for the most recent node request
-  // to finish.  Tests can watch this promise for that.
-  this._lastQuery = promise.resolve(null);
+  // // For testing, we need to be able to wait for the most recent node request
+  // // to finish.  Tests can watch this promise for that.
+  // this._lastQuery = promise.resolve(null);
   EventEmitter.decorate(this);
 }
 
-exports.SelectorSearch = SelectorSearch;
+exports.SelectorAutocompleter = SelectorAutocompleter;
 
-SelectorSearch.prototype = {
+SelectorAutocompleter.prototype = {
 
   get walker() this.inspector.walker,
 
   // The possible states of the query.
   States: {
     CLASS: "class",
     ID: "id",
     TAG: "tag",
@@ -197,148 +304,63 @@ SelectorSearch.prototype = {
     }
   }),
 
   /**
    * The command callback for the input box. This function is automatically
    * invoked as the user is typing if the input box type is search.
    */
   _onHTMLSearch: function() {
-    let query = this.searchBox.value;
-    if (query == this._lastSearched) {
-      this.emit("processing-done");
-      return;
-    }
-    this._lastSearched = query;
-    this._searchResults = [];
-    this._searchIndex = 0;
+    this.hidePopup();
+  },
 
-    if (query.length == 0) {
-      this._lastValidSearch = "";
-      this.searchBox.removeAttribute("filled");
-      this.searchBox.classList.remove("devtools-no-search-result");
+
+  hidePopup: function() {
       if (this.searchPopup.isOpen) {
         this.searchPopup.hidePopup();
       }
-      this.emit("processing-done");
-      return;
-    }
-
-    this.searchBox.setAttribute("filled", true);
-    let queryList = null;
-
-    this._lastQuery = this._queryNodes(query).then(list => {
-      return list;
-    }, (err) => {
-      // Failures are ok here, just use a null item list;
-      return null;
-    }).then(queryList => {
-      // Value has changed since we started this request, we're done.
-      if (query != this.searchBox.value) {
-        if (queryList) {
-          queryList.release();
-        }
-        return promise.reject(null);
-      }
-
-      this._searchResults = queryList || [];
-      if (this._searchResults && this._searchResults.length > 0) {
-        this._lastValidSearch = query;
-        // Even though the selector matched atleast one node, there is still
-        // possibility of suggestions.
-        if (query.match(/[\s>+]$/)) {
-          // If the query has a space or '>' at the end, create a selector to match
-          // the children of the selector inside the search box by adding a '*'.
-          this._lastValidSearch += "*";
-        }
-        else if (query.match(/[\s>+][\.#a-zA-Z][\.#>\s+]*$/)) {
-          // If the query is a partial descendant selector which does not matches
-          // any node, remove the last incomplete part and add a '*' to match
-          // everything. For ex, convert 'foo > b' to 'foo > *' .
-          let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+]*$/)[0];
-          this._lastValidSearch = query.slice(0, -1 * lastPart.length + 1) + "*";
-        }
-
-        if (!query.slice(-1).match(/[\.#\s>+]/)) {
-          // Hide the popup if we have some matching nodes and the query is not
-          // ending with [.# >] which means that the selector is not at the
-          // beginning of a new class, tag or id.
-          if (this.searchPopup.isOpen) {
-            this.searchPopup.hidePopup();
-          }
-          this.searchBox.classList.remove("devtools-no-search-result");
-
-          return this._selectResult(0);
-        }
-        return this._selectResult(0).then(() => {
-          this.searchBox.classList.remove("devtools-no-search-result");
-        }).then(() => this.showSuggestions());
-      }
-      if (query.match(/[\s>+]$/)) {
-        this._lastValidSearch = query + "*";
-      }
-      else if (query.match(/[\s>+][\.#a-zA-Z][\.#>\s+]*$/)) {
-        let lastPart = query.match(/[\s+>][\.#a-zA-Z][^>\s+]*$/)[0];
-        this._lastValidSearch = query.slice(0, -1 * lastPart.length + 1) + "*";
-      }
-      this.searchBox.classList.add("devtools-no-search-result");
-      return this.showSuggestions();
-    }).then(() => this.emit("processing-done"), Cu.reportError);
   },
 
   /**
    * Handles keypresses inside the input box.
    */
   _onSearchKeypress: function(aEvent) {
     let query = this.searchBox.value;
     switch(aEvent.keyCode) {
       case aEvent.DOM_VK_RETURN:
-        if (query == this._lastSearched && this._searchResults) {
-          this._searchIndex = (this._searchIndex + 1) % this._searchResults.length;
-        }
-        else {
-          this._onHTMLSearch();
-          return;
+      case aEvent.DOM_VK_TAB:
+        if (this.searchPopup.isOpen &&
+            this.searchPopup.getItemAtIndex(this.searchPopup.itemCount - 1)
+                .preLabel == query) {
+          this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
+          this.searchBox.value = this.searchPopup.selectedItem.label;
+          this.hidePopup();
         }
         break;
 
       case aEvent.DOM_VK_UP:
         if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
           this.searchPopup.focus();
           if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
             this.searchPopup.selectedIndex =
               Math.max(0, this.searchPopup.itemCount - 2);
           }
           else {
             this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
           }
           this.searchBox.value = this.searchPopup.selectedItem.label;
         }
-        else if (--this._searchIndex < 0) {
-          this._searchIndex = this._searchResults.length - 1;
-        }
         break;
 
       case aEvent.DOM_VK_DOWN:
         if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
           this.searchPopup.focus();
           this.searchPopup.selectedIndex = 0;
           this.searchBox.value = this.searchPopup.selectedItem.label;
         }
-        this._searchIndex = (this._searchIndex + 1) % this._searchResults.length;
-        break;
-
-      case aEvent.DOM_VK_TAB:
-        if (this.searchPopup.isOpen &&
-            this.searchPopup.getItemAtIndex(this.searchPopup.itemCount - 1)
-                .preLabel == query) {
-          this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
-          this.searchBox.value = this.searchPopup.selectedItem.label;
-          this._onHTMLSearch();
-        }
         break;
 
       case aEvent.DOM_VK_BACK_SPACE:
       case aEvent.DOM_VK_DELETE:
         // need to throw away the lastValidSearch.
         this._lastToLastValidSearch = null;
         // This gets the most complete selector from the query. For ex.
         // '.foo.ba' returns '.foo' , '#foo > .bar.baz' returns '#foo > .bar'
@@ -406,17 +428,16 @@ SelectorSearch.prototype = {
       case aEvent.DOM_VK_BACK_SPACE:
         aEvent.stopPropagation();
         aEvent.preventDefault();
         this.searchBox.focus();
         if (this.searchBox.selectionStart > 0) {
           this.searchBox.value =
             this.searchBox.value.substring(0, this.searchBox.selectionStart - 1);
         }
-        this._lastToLastValidSearch = null;
         let query = this.searchBox.value;
         this._lastValidSearch = (query.match(/(.*)[\.#][^\.# ]{0,}$/) ||
                                  query.match(/(.*[\s>+])[a-zA-Z][^\.# ]{0,}$/) ||
                                  ["",""])[1];
         this._onHTMLSearch();
         break;
     }
     this.emit("processing-done");
@@ -440,37 +461,37 @@ SelectorSearch.prototype = {
         let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+\.#]*$/)[0];
         value = query.slice(0, -1 * lastPart.length + 1) + value;
       }
       // for cases like 'div.class' or '#foo.bar' and likewise
       else if (query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)) {
         let lastPart = query.match(/[a-zA-Z][#\.][^#\.\s>+]*$/)[0];
         value = query.slice(0, -1 * lastPart.length + 1) + value;
       }
-
+
       let item = {
         preLabel: query,
         label: value,
         count: count
       };
-
-      // In case of tagNames, change te case to small
+
+      // In case of tagNames, change te case to small
       if (value.match(/.*[\.#][^\.#]{0,}$/) == null) {
         item.label = value.toLowerCase();
       }
-
-      // In case the query's state is tag and the item's state is id or class
-      // adjust the preLabel
-      if (aState === this.States.TAG && state === this.States.CLASS) {
-        item.preLabel = "." + item.preLabel;
-      }
-      if (aState === this.States.TAG && state === this.States.ID) {
-        item.preLabel = "#" + item.preLabel;
-      }
-
+
+      // In case the query's state is tag and the item's state is id or class
+      // adjust the preLabel
+      if (aState === this.States.TAG && state === this.States.CLASS) {
+        item.preLabel = "." + item.preLabel;
+      }
+      if (aState === this.States.TAG && state === this.States.ID) {
+        item.preLabel = "#" + item.preLabel;
+      }
+
       items.unshift(item);
       if (++total > MAX_SUGGESTIONS - 1) {
         break;
       }
     }
     if (total > 0) {
       this.searchPopup.setItems(items);
       this.searchPopup.openPopup(this.searchBox);
@@ -481,19 +502,19 @@ SelectorSearch.prototype = {
   },
 
   /**
    * Suggests classes,ids and tags based on the user input as user types in the
    * searchbox.
    */
   showSuggestions: function() {
     let query = this.searchBox.value;
-    let state = this.state;
+    let state = this.state;
     let firstPart = "";
-
+
     if (state == this.States.TAG) {
       // gets the tag that is being completed. For ex. 'div.foo > s' returns 's',
       // 'di' returns 'di' and likewise.
       firstPart = (query.match(/[\s>+]?([a-zA-Z]*)$/) || ["", query])[1];
       query = query.slice(0, query.length - firstPart.length);
     }
     else if (state == this.States.CLASS) {
       // gets the class that is being completed. For ex. '.foo.b' returns 'b'
@@ -505,29 +526,553 @@ SelectorSearch.prototype = {
       firstPart = query.match(/#([^#]*)$/)[1];
       query = query.slice(0, query.length - firstPart.length - 1);
     }
     // TODO: implement some caching so that over the wire request is not made
     // everytime.
     if (/[\s+>~]$/.test(query)) {
       query += "*";
     }
-
+
     this._currentSuggesting = query;
     return this.walker.getSuggestionsForQuery(query, firstPart, state).then(result => {
       if (this._currentSuggesting != result.query) {
         // This means that this response is for a previous request and the user
         // as since typed something extra leading to a new request.
         return;
       }
-      this._lastToLastValidSearch = this._lastValidSearch;
-
+
       if (state == this.States.CLASS) {
         firstPart = "." + firstPart;
       }
       else if (state == this.States.ID) {
         firstPart = "#" + firstPart;
       }
-
+
       this._showPopup(result.suggestions, firstPart, state);
     });
   }
 };
+
+
+
+
+
+// XXX: Here is the autocomplete part
+
+/**
+ * Converts any input box on a page to a CSS selector search and suggestion box.
+ *
+ * Emits 'processing-done' event when it is done processing the current
+ * keypress, search request or selection from the list, whether that led to a
+ * search or not.
+ *
+ * @constructor
+ * @param InspectorPanel aInspector
+ *        The InspectorPanel whose `walker` attribute should be used for
+ *        document traversal.
+ * @param nsiInputElement aInputNode
+ *        The input element to which the panel will be attached and from where
+ *        search input will be taken.
+ */
+// function SelectorAutocompleterOriginal(aInspector, aInputNode) {
+//   this.inspector = aInspector;
+//   this.searchBox = aInputNode;
+//   this.panelDoc = this.searchBox.ownerDocument;
+
+//   // initialize variables.
+//   this._lastSearched = null;
+//   this._lastValidSearch = "";
+//   this._lastToLastValidSearch = null;
+//   this._searchResults = null;
+//   this._searchSuggestions = {};
+//   this._searchIndex = 0;
+
+//   // bind!
+//   this._showPopup = this._showPopup.bind(this);
+//   this._onHTMLSearch = this._onHTMLSearch.bind(this);
+//   this._onSearchKeypress = this._onSearchKeypress.bind(this);
+//   this._onListBoxKeypress = this._onListBoxKeypress.bind(this);
+
+//   // Options for the AutocompletePopup.
+//   let options = {
+//     panelId: "inspector-searchbox-panel",
+//     listBoxId: "searchbox-panel-listbox",
+//     autoSelect: true,
+//     position: "before_start",
+//     direction: "ltr",
+//     theme: "auto",
+//     onClick: this._onListBoxKeypress,
+//     onKeypress: this._onListBoxKeypress
+//   };
+//   this.searchPopup = new AutocompletePopup(this.panelDoc, options);
+
+//   // event listeners.
+//   this.searchBox.addEventListener("command", this._onHTMLSearch, true);
+//   this.searchBox.addEventListener("keypress", this._onSearchKeypress, true);
+
+//   // For testing, we need to be able to wait for the most recent node request
+//   // to finish.  Tests can watch this promise for that.
+//   this._lastQuery = promise.resolve(null);
+//   EventEmitter.decorate(this);
+// }
+
+// exports.SelectorAutocompleterOriginal = SelectorAutocompleterOriginal;
+
+// SelectorAutocompleterOriginal.prototype = {
+
+//   get walker() this.inspector.walker,
+
+//   // The possible states of the query.
+//   States: {
+//     CLASS: "class",
+//     ID: "id",
+//     TAG: "tag",
+//   },
+
+//   // The current state of the query.
+//   _state: null,
+
+//   // The query corresponding to last state computation.
+//   _lastStateCheckAt: null,
+
+//   /**
+//    * Computes the state of the query. State refers to whether the query
+//    * currently requires a class suggestion, or a tag, or an Id suggestion.
+//    * This getter will effectively compute the state by traversing the query
+//    * character by character each time the query changes.
+//    *
+//    * @example
+//    *        '#f' requires an Id suggestion, so the state is States.ID
+//    *        'div > .foo' requires class suggestion, so state is States.CLASS
+//    */
+//   get state() {
+//     if (!this.searchBox || !this.searchBox.value) {
+//       return null;
+//     }
+
+//     let query = this.searchBox.value;
+//     if (this._lastStateCheckAt == query) {
+//       // If query is the same, return early.
+//       return this._state;
+//     }
+//     this._lastStateCheckAt = query;
+
+//     this._state = null;
+//     let subQuery = "";
+//     // Now we iterate over the query and decide the state character by character.
+//     // The logic here is that while iterating, the state can go from one to
+//     // another with some restrictions. Like, if the state is Class, then it can
+//     // never go to Tag state without a space or '>' character; Or like, a Class
+//     // state with only '.' cannot go to an Id state without any [a-zA-Z] after
+//     // the '.' which means that '.#' is a selector matching a class name '#'.
+//     // Similarily for '#.' which means a selctor matching an id '.'.
+//     for (let i = 1; i <= query.length; i++) {
+//       // Calculate the state.
+//       subQuery = query.slice(0, i);
+//       let [secondLastChar, lastChar] = subQuery.slice(-2);
+//       switch (this._state) {
+//         case null:
+//           // This will happen only in the first iteration of the for loop.
+//           lastChar = secondLastChar;
+//         case this.States.TAG:
+//           this._state = lastChar == "."
+//             ? this.States.CLASS
+//             : lastChar == "#"
+//               ? this.States.ID
+//               : this.States.TAG;
+//           break;
+
+//         case this.States.CLASS:
+//           if (subQuery.match(/[\.]+[^\.]*$/)[0].length > 2) {
+//             // Checks whether the subQuery has atleast one [a-zA-Z] after the '.'.
+//             this._state = (lastChar == " " || lastChar == ">")
+//             ? this.States.TAG
+//             : lastChar == "#"
+//               ? this.States.ID
+//               : this.States.CLASS;
+//           }
+//           break;
+
+//         case this.States.ID:
+//           if (subQuery.match(/[#]+[^#]*$/)[0].length > 2) {
+//             // Checks whether the subQuery has atleast one [a-zA-Z] after the '#'.
+//             this._state = (lastChar == " " || lastChar == ">")
+//             ? this.States.TAG
+//             : lastChar == "."
+//               ? this.States.CLASS
+//               : this.States.ID;
+//           }
+//           break;
+//       }
+//     }
+//     return this._state;
+//   },
+
+//   /**
+//    * Removes event listeners and cleans up references.
+//    */
+//   destroy: function() {
+//     // event listeners.
+//     this.searchBox.removeEventListener("command", this._onHTMLSearch, true);
+//     this.searchBox.removeEventListener("keypress", this._onSearchKeypress, true);
+//     this.searchPopup.destroy();
+//     this.searchPopup = null;
+//     this.searchBox = null;
+//     this.panelDoc = null;
+//     this._searchResults = null;
+//     this._searchSuggestions = null;
+//   },
+
+//   _selectResult: function(index) {
+//     return this._searchResults.item(index).then(node => {
+//       this.inspector.selection.setNodeFront(node, "selectorsearch");
+//     });
+//   },
+
+//   _queryNodes: Task.async(function*(query) {
+//     if (typeof this.hasMultiFrameSearch === "undefined") {
+//       let target = this.inspector.toolbox.target;
+//       this.hasMultiFrameSearch = yield target.actorHasMethod("domwalker",
+//         "multiFrameQuerySelectorAll");
+//     }
+
+//     if (this.hasMultiFrameSearch) {
+//       return yield this.walker.multiFrameQuerySelectorAll(query);
+//     } else {
+//       return yield this.walker.querySelectorAll(this.walker.rootNode, query);
+//     }
+//   }),
+
+//   /**
+//    * The command callback for the input box. This function is automatically
+//    * invoked as the user is typing if the input box type is search.
+//    */
+//   _onHTMLSearch: function() {
+//     let query = this.searchBox.value;
+//     if (query == this._lastSearched) {
+//       this.emit("processing-done");
+//       return;
+//     }
+//     this._lastSearched = query;
+//     this._searchResults = [];
+//     this._searchIndex = 0;
+
+//     if (query.length == 0) {
+//       this._lastValidSearch = "";
+//       this.searchBox.removeAttribute("filled");
+//       this.searchBox.classList.remove("devtools-no-search-result");
+//       if (this.searchPopup.isOpen) {
+//         this.searchPopup.hidePopup();
+//       }
+//       this.emit("processing-done");
+//       return;
+//     }
+
+//     this.searchBox.setAttribute("filled", true);
+//     let queryList = null;
+
+//     this._lastQuery = this._queryNodes(query).then(list => {
+//       return list;
+//     }, (err) => {
+//       // Failures are ok here, just use a null item list;
+//       return null;
+//     }).then(queryList => {
+//       // Value has changed since we started this request, we're done.
+//       if (query != this.searchBox.value) {
+//         if (queryList) {
+//           queryList.release();
+//         }
+//         return promise.reject(null);
+//       }
+
+//       this._searchResults = queryList || [];
+//       if (this._searchResults && this._searchResults.length > 0) {
+//         this._lastValidSearch = query;
+//         // Even though the selector matched atleast one node, there is still
+//         // possibility of suggestions.
+//         if (query.match(/[\s>+]$/)) {
+//           // If the query has a space or '>' at the end, create a selector to match
+//           // the children of the selector inside the search box by adding a '*'.
+//           this._lastValidSearch += "*";
+//         }
+//         else if (query.match(/[\s>+][\.#a-zA-Z][\.#>\s+]*$/)) {
+//           // If the query is a partial descendant selector which does not matches
+//           // any node, remove the last incomplete part and add a '*' to match
+//           // everything. For ex, convert 'foo > b' to 'foo > *' .
+//           let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+]*$/)[0];
+//           this._lastValidSearch = query.slice(0, -1 * lastPart.length + 1) + "*";
+//         }
+
+//         if (!query.slice(-1).match(/[\.#\s>+]/)) {
+//           // Hide the popup if we have some matching nodes and the query is not
+//           // ending with [.# >] which means that the selector is not at the
+//           // beginning of a new class, tag or id.
+//           if (this.searchPopup.isOpen) {
+//             this.searchPopup.hidePopup();
+//           }
+//           this.searchBox.classList.remove("devtools-no-search-result");
+
+//           return this._selectResult(0);
+//         }
+//         return this._selectResult(0).then(() => {
+//           this.searchBox.classList.remove("devtools-no-search-result");
+//         }).then(() => this.showSuggestions());
+//       }
+//       if (query.match(/[\s>+]$/)) {
+//         this._lastValidSearch = query + "*";
+//       }
+//       else if (query.match(/[\s>+][\.#a-zA-Z][\.#>\s+]*$/)) {
+//         let lastPart = query.match(/[\s+>][\.#a-zA-Z][^>\s+]*$/)[0];
+//         this._lastValidSearch = query.slice(0, -1 * lastPart.length + 1) + "*";
+//       }
+//       this.searchBox.classList.add("devtools-no-search-result");
+//       return this.showSuggestions();
+//     }).then(() => this.emit("processing-done"), Cu.reportError);
+//   },
+
+//   /**
+//    * Handles keypresses inside the input box.
+//    */
+//   _onSearchKeypress: function(aEvent) {
+//     let query = this.searchBox.value;
+//     switch(aEvent.keyCode) {
+//       case aEvent.DOM_VK_RETURN:
+//         if (query == this._lastSearched && this._searchResults) {
+//           this._searchIndex = (this._searchIndex + 1) % this._searchResults.length;
+//         }
+//         else {
+//           this._onHTMLSearch();
+//           return;
+//         }
+//         break;
+
+//       case aEvent.DOM_VK_UP:
+//         if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
+//           this.searchPopup.focus();
+//           if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
+//             this.searchPopup.selectedIndex =
+//               Math.max(0, this.searchPopup.itemCount - 2);
+//           }
+//           else {
+//             this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
+//           }
+//           this.searchBox.value = this.searchPopup.selectedItem.label;
+//         }
+//         else if (--this._searchIndex < 0) {
+//           this._searchIndex = this._searchResults.length - 1;
+//         }
+//         break;
+
+//       case aEvent.DOM_VK_DOWN:
+//         if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
+//           this.searchPopup.focus();
+//           this.searchPopup.selectedIndex = 0;
+//           this.searchBox.value = this.searchPopup.selectedItem.label;
+//         }
+//         this._searchIndex = (this._searchIndex + 1) % this._searchResults.length;
+//         break;
+
+//       case aEvent.DOM_VK_TAB:
+//         if (this.searchPopup.isOpen &&
+//             this.searchPopup.getItemAtIndex(this.searchPopup.itemCount - 1)
+//                 .preLabel == query) {
+//           this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
+//           this.searchBox.value = this.searchPopup.selectedItem.label;
+//           this._onHTMLSearch();
+//         }
+//         break;
+
+//       case aEvent.DOM_VK_BACK_SPACE:
+//       case aEvent.DOM_VK_DELETE:
+//         // need to throw away the lastValidSearch.
+//         this._lastToLastValidSearch = null;
+//         // This gets the most complete selector from the query. For ex.
+//         // '.foo.ba' returns '.foo' , '#foo > .bar.baz' returns '#foo > .bar'
+//         // '.foo +bar' returns '.foo +' and likewise.
+//         this._lastValidSearch = (query.match(/(.*)[\.#][^\.# ]{0,}$/) ||
+//                                  query.match(/(.*[\s>+])[a-zA-Z][^\.# ]{0,}$/) ||
+//                                  ["",""])[1];
+//         return;
+
+//       default:
+//         return;
+//     }
+
+//     aEvent.preventDefault();
+//     aEvent.stopPropagation();
+//     if (this._searchResults && this._searchResults.length > 0) {
+//       this._lastQuery = this._selectResult(this._searchIndex).then(() => this.emit("processing-done"));
+//     }
+//     else {
+//       this.emit("processing-done");
+//     }
+//   },
+
+//   /**
+//    * Handles keypress and mouse click on the suggestions richlistbox.
+//    */
+//   _onListBoxKeypress: function(aEvent) {
+//     switch(aEvent.keyCode || aEvent.button) {
+//       case aEvent.DOM_VK_RETURN:
+//       case aEvent.DOM_VK_TAB:
+//       case 0: // left mouse button
+//         aEvent.stopPropagation();
+//         aEvent.preventDefault();
+//         this.searchBox.value = this.searchPopup.selectedItem.label;
+//         this.searchBox.focus();
+//         this._onHTMLSearch();
+//         break;
+
+//       case aEvent.DOM_VK_UP:
+//         if (this.searchPopup.selectedIndex == 0) {
+//           this.searchPopup.selectedIndex = -1;
+//           aEvent.stopPropagation();
+//           aEvent.preventDefault();
+//           this.searchBox.focus();
+//         }
+//         else {
+//           let index = this.searchPopup.selectedIndex;
+//           this.searchBox.value = this.searchPopup.getItemAtIndex(index - 1).label;
+//         }
+//         break;
+
+//       case aEvent.DOM_VK_DOWN:
+//         if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
+//           this.searchPopup.selectedIndex = -1;
+//           aEvent.stopPropagation();
+//           aEvent.preventDefault();
+//           this.searchBox.focus();
+//         }
+//         else {
+//           let index = this.searchPopup.selectedIndex;
+//           this.searchBox.value = this.searchPopup.getItemAtIndex(index + 1).label;
+//         }
+//         break;
+
+//       case aEvent.DOM_VK_BACK_SPACE:
+//         aEvent.stopPropagation();
+//         aEvent.preventDefault();
+//         this.searchBox.focus();
+//         if (this.searchBox.selectionStart > 0) {
+//           this.searchBox.value =
+//             this.searchBox.value.substring(0, this.searchBox.selectionStart - 1);
+//         }
+//         this._lastToLastValidSearch = null;
+//         let query = this.searchBox.value;
+//         this._lastValidSearch = (query.match(/(.*)[\.#][^\.# ]{0,}$/) ||
+//                                  query.match(/(.*[\s>+])[a-zA-Z][^\.# ]{0,}$/) ||
+//                                  ["",""])[1];
+//         this._onHTMLSearch();
+//         break;
+//     }
+//     this.emit("processing-done");
+//   },
+
+//   /**
+//    * Populates the suggestions list and show the suggestion popup.
+//    */
+//   _showPopup: function(aList, aFirstPart, aState) {
+//     let total = 0;
+//     let query = this.searchBox.value;
+//     let items = [];
+
+//     for (let [value, count, state] of aList) {
+//       // for cases like 'div ' or 'div >' or 'div+'
+//       if (query.match(/[\s>+]$/)) {
+//         value = query + value;
+//       }
+//       // for cases like 'div #a' or 'div .a' or 'div > d' and likewise
+//       else if (query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#]*$/)) {
+//         let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+\.#]*$/)[0];
+//         value = query.slice(0, -1 * lastPart.length + 1) + value;
+//       }
+//       // for cases like 'div.class' or '#foo.bar' and likewise
+//       else if (query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)) {
+//         let lastPart = query.match(/[a-zA-Z][#\.][^#\.\s>+]*$/)[0];
+//         value = query.slice(0, -1 * lastPart.length + 1) + value;
+//       }
+
+//       let item = {
+//         preLabel: query,
+//         label: value,
+//         count: count
+//       };
+
+//       // In case of tagNames, change te case to small
+//       if (value.match(/.*[\.#][^\.#]{0,}$/) == null) {
+//         item.label = value.toLowerCase();
+//       }
+
+//       // In case the query's state is tag and the item's state is id or class
+//       // adjust the preLabel
+//       if (aState === this.States.TAG && state === this.States.CLASS) {
+//         item.preLabel = "." + item.preLabel;
+//       }
+//       if (aState === this.States.TAG && state === this.States.ID) {
+//         item.preLabel = "#" + item.preLabel;
+//       }
+
+//       items.unshift(item);
+//       if (++total > MAX_SUGGESTIONS - 1) {
+//         break;
+//       }
+//     }
+//     if (total > 0) {
+//       this.searchPopup.setItems(items);
+//       this.searchPopup.openPopup(this.searchBox);
+//     }
+//     else {
+//       this.searchPopup.hidePopup();
+//     }
+//   },
+
+//   /**
+//    * Suggests classes,ids and tags based on the user input as user types in the
+//    * searchbox.
+//    */
+//   showSuggestions: function() {
+//     let query = this.searchBox.value;
+//     let state = this.state;
+//     let firstPart = "";
+
+//     if (state == this.States.TAG) {
+//       // gets the tag that is being completed. For ex. 'div.foo > s' returns 's',
+//       // 'di' returns 'di' and likewise.
+//       firstPart = (query.match(/[\s>+]?([a-zA-Z]*)$/) || ["", query])[1];
+//       query = query.slice(0, query.length - firstPart.length);
+//     }
+//     else if (state == this.States.CLASS) {
+//       // gets the class that is being completed. For ex. '.foo.b' returns 'b'
+//       firstPart = query.match(/\.([^\.]*)$/)[1];
+//       query = query.slice(0, query.length - firstPart.length - 1);
+//     }
+//     else if (state == this.States.ID) {
+//       // gets the id that is being completed. For ex. '.foo#b' returns 'b'
+//       firstPart = query.match(/#([^#]*)$/)[1];
+//       query = query.slice(0, query.length - firstPart.length - 1);
+//     }
+//     // TODO: implement some caching so that over the wire request is not made
+//     // everytime.
+//     if (/[\s+>~]$/.test(query)) {
+//       query += "*";
+//     }
+
+//     this._currentSuggesting = query;
+//     return this.walker.getSuggestionsForQuery(query, firstPart, state).then(result => {
+//       if (this._currentSuggesting != result.query) {
+//         // This means that this response is for a previous request and the user
+//         // as since typed something extra leading to a new request.
+//         return;
+//       }
+//       this._lastToLastValidSearch = this._lastValidSearch;
+
+//       if (state == this.States.CLASS) {
+//         firstPart = "." + firstPart;
+//       }
+//       else if (state == this.States.ID) {
+//         firstPart = "#" + firstPart;
+//       }
+
+//       this._showPopup(result.suggestions, firstPart, state);
+//     });
+//   }
+// };
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -108,16 +108,24 @@ function MarkupView(aInspector, aFrame, 
   this._onNewSelection();
 
   this._boundKeyDown = this._onKeyDown.bind(this);
   this._frame.contentWindow.addEventListener("keydown", this._boundKeyDown, false);
 
   this._boundFocus = this._onFocus.bind(this);
   this._frame.addEventListener("focus", this._boundFocus, false);
 
+  // Listen to inspector search to highlight results
+  this._unhighlightSearchResult = this._unhighlightSearchResult.bind(this);
+  this._highlightSearchResult = this._highlightSearchResult.bind(this);
+  let search = this._inspector.search;
+  search.on("search-cleared", this._unhighlightSearchResult);
+  search.on("search-no-result", this._unhighlightSearchResult);
+  search.on("search-result", this._highlightSearchResult);
+
   this._makeTooltipPersistent = this._makeTooltipPersistent.bind(this);
 
   this._initPreview();
   this._initTooltips();
   this._initHighlighter();
 
   EventEmitter.decorate(this);
 }
@@ -329,16 +337,33 @@ MarkupView.prototype = {
     this._clearBriefBoxModelTimer();
     this._showBoxModel(nodeFront);
 
     this._briefBoxModelTimer = setTimeout(() => {
       this._hideBoxModel();
     }, NEW_SELECTION_HIGHLIGHTER_TIMER);
   },
 
+  _highlightSearchResult: function(event, {node, type, matched, query}) {
+    this._unhighlightSearchResult();
+
+    // Search results are selected in the view, so wait for updates
+    this._waitForChildren().then(() => {
+      let editor = this.getContainer(node).editor;
+
+      if (editor.highlightPart) {
+        editor.highlightPart(type, matched, query);
+      }
+    });
+  },
+
+  _unhighlightSearchResult: function() {
+    this.doc.defaultView.getSelection().removeAllRanges();
+  },
+
   template: function(aName, aDest, aOptions={stack: "markup-view.xhtml"}) {
     let node = this.doc.getElementById("template-" + aName).cloneNode(true);
     node.removeAttribute("id");
     template(node, aDest, aOptions);
     return node;
   },
 
   /**
@@ -1426,16 +1451,21 @@ MarkupView.prototype = {
     this._boundKeyDown = null;
 
     this._inspector.selection.off("new-node-front", this._boundOnNewSelection);
     this._boundOnNewSelection = null;
 
     this.walker.off("mutations", this._boundMutationObserver);
     this._boundMutationObserver = null;
 
+    let search = this._inspector.search;
+    search.off("search-cleared", this._unhighlightSearchResult);
+    search.off("search-no-result", this._unhighlightSearchResult);
+    search.off("search-result", this._highlightSearchResult);
+
     this.walker.off("display-change", this._boundOnDisplayChange);
     this._boundOnDisplayChange = null;
 
     this._elt.removeEventListener("mousemove", this._onMouseMove, false);
     this._elt.removeEventListener("mouseleave", this._onMouseLeave, false);
     this._elt = null;
 
     for (let [key, container] of this._containers) {
@@ -1986,16 +2016,47 @@ MarkupContainer.prototype = {
   _onToggle: function(event) {
     this.markup.navigate(this);
     if (this.hasChildren) {
       this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
     }
     event.stopPropagation();
   },
 
+  highlightPart: function(type, value, part) {
+    if (type === "selector") {
+      // No need to highlight anything if the type is selector
+      return;
+    }
+    // FIXME: if the node isn't imported yet, we have a race condition and t
+    // range isn't visible
+    let range = this.markup.doc.createRange();
+    // Get the node that contains the part
+    let node;
+    switch (type) {
+      case "attributeValue":
+        node = this.getAttributeElementByValue(value);
+        break;
+      case "attributeName":
+        node = this.getAttributeElement(value)
+          .parentNode.querySelector(".attr-name");
+        break;
+      case "tag":
+        node = this.tag;
+        break;
+    }
+    // Get the textnode to set the range in
+    node = node.firstChild;
+    let start = node.textContent.toLowerCase().indexOf(part.toLowerCase());
+    let end = start + part.length;
+    range.setStart(node, start);
+    range.setEnd(node, end);
+    this.markup.doc.defaultView.getSelection().addRange(range);
+  },
+
   /**
    * Get rid of event listeners and references, when the container is no longer
    * needed
    */
   destroy: function() {
     // Remove event listeners
     this.elt.removeEventListener("mousedown", this._onMouseDown, false);
     this.elt.removeEventListener("dblclick", this._onToggle, false);
@@ -2243,21 +2304,23 @@ GenericEditor.prototype = {
  * Creates a simple text editor node, used for TEXT and COMMENT
  * nodes.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param DOMNode aNode The node being edited.
  * @param string aTemplate The template id to use to build the editor.
  */
 function TextEditor(aContainer, aNode, aTemplate) {
+  this.doc = aContainer.doc;
   this.container = aContainer;
   this.markup = this.container.markup;
   this.node = aNode;
   this.template = this.markup.template.bind(aTemplate);
   this._selected = false;
+  this.updating = promise.resolve();
 
   this.markup.template(aTemplate, this);
 
   editableField({
     element: this.value,
     stopOnReturn: true,
     trigger: "dblclick",
     multiline: true,
@@ -2300,28 +2363,51 @@ TextEditor.prototype = {
     if (!this.selected || !this.node.incompleteValue) {
       let text = this.node.shortValue;
       if (this.node.incompleteValue) {
         text += ELLIPSIS;
       }
       this.value.textContent = text;
     } else {
       let longstr = null;
-      this.node.getNodeValue().then(ret => {
+      this.updating = this.node.getNodeValue().then(ret => {
         longstr = ret;
         return longstr.string();
       }).then(str => {
         longstr.release().then(null, console.error);
         if (this.selected) {
           this.value.textContent = str;
         }
       }).then(null, console.error);
     }
   },
 
+  highlightPart: function(type, value, part) {
+    // Make sure the highlight is done after update to avoid race conditions
+    this.updating.then(() => {
+      let range = this.markup.doc.createRange();
+      let textNode = this.value.firstChild;
+
+      let start = textNode.textContent.toLowerCase().indexOf(part.toLowerCase());
+      let end = start + part.length;
+
+      range.setStart(textNode, start);
+      range.setEnd(textNode, end);
+
+      this.markup.doc.defaultView.getSelection().addRange(range);
+
+      // XXX: Some weird try to change the color of the selection.
+      // this.markup.doc.designMode = "on";
+      // this.markup.doc.execCommand("BackColor", false, "yellow");
+      // this.markup.doc.execCommand("HiliteColor", false, "yellow");
+      // this.markup.doc.designMode = "off";
+
+    });
+  },
+
   destroy: function() {}
 };
 
 /**
  * Creates an editor for an Element node.
  *
  * @param MarkupContainer aContainer The container owning this editor.
  * @param Element aNode The node being edited.
@@ -2472,16 +2558,30 @@ ElementEditor.prototype = {
   removeAttribute: function(attrName) {
     let attr = this.attrElements.get(attrName);
     if (attr) {
       this.attrElements.delete(attrName);
       attr.remove();
     }
   },
 
+  /**
+   * Get the element used for one of the attributes of this element given its
+   * value
+   * @param string attrValue The value of the attribute to get the element for
+   * @return DOMElement
+   */
+  getAttributeElementByValue: function(attrValue) {
+    for (let attr of this.attrList.querySelectorAll(".attr-value")) {
+      if (attr.textContent === attrValue) {
+        return attr;
+      }
+    }
+  },
+
   _createAttribute: function(aAttr, aBefore = null) {
     // Create the template editor, which will save some variables here.
     let data = {
       attrName: aAttr.name,
     };
     this.template("attribute", data);
     var {attr, inner, name, val} = data;
 
diff --git a/browser/locales/en-US/chrome/browser/devtools/inspector.dtd b/browser/locales/en-US/chrome/browser/devtools/inspector.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/inspector.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/inspector.dtd
@@ -79,17 +79,17 @@
      current node -->
 <!ENTITY inspectorHTMLDelete.label          "Delete Node">
 <!ENTITY inspectorHTMLDelete.accesskey      "D">
 
 <!ENTITY inspector.selectButton.tooltip     "Select element with mouse">
 
 <!-- LOCALIZATION NOTE (inspectorSearchHTML.label2): This is the label shown as
      the placeholder in inspector search box -->
-<!ENTITY inspectorSearchHTML.label2          "Search with CSS Selectors">
+<!ENTITY inspectorSearchHTML.label3          "Search HTML">
 <!ENTITY inspectorSearchHTML.key            "F">
 
 <!-- LOCALIZATION NOTE (inspectorCopyImageDataUri.label): This is the label
      shown in the inspector contextual-menu for the item that lets users copy
      the URL embedding the image data encoded in Base 64 (what we name
      here Image Data URL). For more information:
      https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs -->
 <!ENTITY inspectorCopyImageDataUri.label       "Copy Image Data-URL">
diff --git a/browser/locales/en-US/chrome/browser/devtools/inspector.properties b/browser/locales/en-US/chrome/browser/devtools/inspector.properties
--- a/browser/locales/en-US/chrome/browser/devtools/inspector.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/inspector.properties
@@ -59,8 +59,14 @@ eventsTooltip.openInDebugger=Open in Deb
 # that collapses the right panel (rules, computed, box-model, etc...) in the
 # inspector UI.
 inspector.collapsePane=Collapse pane
 
 # LOCALIZATION NOTE (inspector.expandPane): This is the tooltip for the button
 # that expands the right panel (rules, computed, box-model, etc...) in the
 # inspector UI.
 inspector.expandPane=Expand pane
+
+# LOCALIZATION NOTE (inspector.searchResultsCount)
+inspector.searchResultsCount=%S of %S
+
+# LOCALIZATION NOTE (inspector.searchResultsNone)
+inspector.searchResultsNone=No matches
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -56,16 +56,17 @@ const protocol = require("devtools/serve
 const {Arg, Option, method, RetVal, types} = protocol;
 const {LongStringActor, ShortLongString} = require("devtools/server/actors/string");
 const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 const {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 const object = require("sdk/util/object");
 const events = require("sdk/event/core");
 const {Unknown} = require("sdk/platform/xpcom");
 const {Class} = require("sdk/core/heritage");
+const {WalkerSearch} = require("devtools/server/actors/utils/walker-search");
 const {PageStyleActor, getFontPreviewData} = require("devtools/server/actors/styles");
 const {
   HighlighterActor,
   CustomHighlighterActor,
   isTypeRegistered,
 } = require("devtools/server/actors/highlighter");
 const {getLayoutChangesObserver, releaseLayoutChangesObserver} =
   require("devtools/server/actors/layout");
@@ -106,17 +107,16 @@ const PSEUDO_SELECTORS = [
   [":empty", 0],
   [":target", 0],
   [":enabled", 0],
   [":disabled", 0],
   [":checked", 1],
   ["::selection", 0]
 ];
 
-
 let HELPER_SHEET = ".__fx-devtools-hide-shortcut__ { visibility: hidden !important } ";
 HELPER_SHEET += ":-moz-devtools-highlighted { outline: 2px dashed #F06!important; outline-offset: -2px!important } ";
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
@@ -985,16 +985,24 @@ types.addDictType("disconnectedNodeArray
   nodes: "array:domnode",
 
   // Nodes that are needed to connect those nodes to the root.
   newParents: "array:domnode"
 });
 
 types.addDictType("dommutation", {});
 
+types.addDictType("searchresult", {
+  node: "disconnectedNode",
+  type: "string",
+  resultsLength: "number",
+  resultsIndex: "number",
+  matched: "string"
+});
+
 /**
  * Server side of a node list as returned by querySelectorAll()
  */
 var NodeListActor = exports.NodeListActor = protocol.ActorClass({
   typeName: "domnodelist",
 
   initialize: function(walker, nodeList) {
     protocol.Actor.prototype.initialize.call(this);
@@ -1164,16 +1172,18 @@ var WalkerActor = protocol.ActorClass({
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
     this.showAllAnonymousContent = options.showAllAnonymousContent;
 
     this.layoutHelpers = new LayoutHelpers(this.rootWin);
 
+    this.WalkerSearch = new WalkerSearch(this);
+
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
     this._orphaned = new Set();
 
     // The client can tell the walker that it is interested in a node
     // even when it is orphaned with the `retainNode` method.  This
     // list contains orphaned nodes that were so retained.
@@ -1218,16 +1228,17 @@ var WalkerActor = protocol.ActorClass({
       this._destroyed = true;
 
       this.clearPseudoClassLocks();
       this._activePseudoClassLocks = null;
 
       this._hoveredNode = null;
       this.rootDoc = null;
 
+      this.WalkerSearch.destroy();
       this.reflowObserver.off("reflows", this._onReflows);
       this.reflowObserver = null;
       releaseLayoutChangesObserver(this.tabActor);
 
       events.emit(this, "destroyed");
     } catch(e) {
       console.error(e);
     }
@@ -1854,16 +1865,77 @@ var WalkerActor = protocol.ActorClass({
       selector: Arg(0)
     },
     response: {
       list: RetVal("domnodelist")
     }
   }),
 
   /**
+   * Incrementally search the document for a given string. Results will be
+   * searched with the walker-search module (searches through tag names,
+   * attribute names and values, and text contents).
+   * Only 1 result is sent back, and calling the method again with the same
+   * query will send the next result. When there are no more results to be sent
+   * back, null is sent
+   * @param {String} query
+   * @param {Object} options
+   *    - "reset": forces a new search even if the same query is passed
+   *    - "reverse": search backwards
+   */
+  search: method(function(query, options) {
+
+    // Search if no search has been done before, or if asked to reset or if the
+    // query has changed
+    if (this._lastSearch !== query || options.reset) {
+      this._lastSearch = query;
+      this._lastSearchIndex = -1;
+      this._lastSearchResults = this.WalkerSearch.search(query);
+    }
+
+    if (!this._lastSearchResults.length) {
+      return null;
+    }
+
+    // Move search result cursor and cycle if necessary
+    if (options.reverse) {
+      this._lastSearchIndex--;
+    } else {
+      this._lastSearchIndex++;
+    }
+
+    if (this._lastSearchIndex >= this._lastSearchResults.length) {
+      this._lastSearchIndex = 0;
+    }
+    if (this._lastSearchIndex < 0) {
+      this._lastSearchIndex = this._lastSearchResults.length - 1;
+    }
+
+    let res = this._lastSearchResults[this._lastSearchIndex];
+
+
+    return {
+      node: this.attachElement(res.node),
+      type: res.type,
+      matched: res.matched,
+      resultsLength: this._lastSearchResults.length,
+      resultsIndex: this._lastSearchIndex + 1
+    };
+  }, {
+    request: {
+      query: Arg(0),
+      reset: Option(1, "boolean"),
+      reverse: Option(1, "boolean")
+    },
+    response: {
+      node: RetVal("nullable:searchresult")
+    }
+  }),
+
+  /**
    * Returns a list of matching results for CSS selector autocompletion.
    *
    * @param string query
    *        The selector query being completed
    * @param string completing
    *        The exact token being completed out of the query
    * @param string selectorState
    *        One of "pseudo", "id", "tag", "class", "null"
@@ -3045,16 +3117,95 @@ var WalkerFront = exports.WalkerFront = 
   getStyleSheetOwnerNode: protocol.custom(function(styleSheetActorID) {
     return this._getStyleSheetOwnerNode(styleSheetActorID).then(response => {
       return response ? response.node : null;
     });
   }, {
     impl: "_getStyleSheetOwnerNode"
   }),
 
+  /*
+   * XXX: Document this
+   */
+  search: protocol.custom(Task.async(function*(query, options) {
+
+
+    console.log("Search called on Front", options);
+    let output;
+
+    // Backwards compat.  Use selector only search if the new
+    // search functionality isn't implemented, or if the caller
+    // only wants it.
+    // XXX: It seems silly that we need to tell the front which capabilities
+    // it's actor has.  It'd be handy if we could check actorHasMethod here,
+    // since this call is already async
+    if (options.selectorOnly || !options.hasWalkerSearch) {
+      if (!this.compatSearchData) {
+        this.compatSearchData = {};
+      }
+
+      let response;
+      if (options.hasMultiFrameSearch) {
+        response = yield this.multiFrameQuerySelectorAll(query);
+      } else {
+        response = yield this.querySelectorAll(this.rootNode, query);
+      }
+
+      if (this.compatSearchData._lastSearch !== query) {
+        this.compatSearchData._lastSearch = query;
+        this.compatSearchData._lastSearchIndex = -1;
+        this.compatSearchData._lastSearchResults = response;
+      }
+
+      if (!response.length) {
+        return null;
+      }
+
+      // Move search result cursor and cycle if necessary
+      if (options.reverse) {
+        this.compatSearchData._lastSearchIndex--;
+      } else {
+        this.compatSearchData._lastSearchIndex++;
+      }
+
+      if (this.compatSearchData._lastSearchIndex >= this.compatSearchData._lastSearchResults.length) {
+        this.compatSearchData._lastSearchIndex = 0;
+      }
+      if (this.compatSearchData._lastSearchIndex < 0) {
+        this.compatSearchData._lastSearchIndex = this.compatSearchData._lastSearchResults.length - 1;
+      }
+
+      let node = yield response.item(this.compatSearchData._lastSearchIndex);
+
+      console.log("Selector search returning", response, node, response.length);
+      output = {
+        type: "selector",
+        matched: node.nodeName,
+        node: node,
+        resultsLength: response.length,
+        resultsIndex: this.compatSearchData._lastSearchIndex + 1
+      };
+    } else {
+      let response = yield this._search(query, options);
+      if (response) {
+        output = {
+          type: response.type,
+          matched: response.matched,
+          node: response.node.node,
+          resultsLength: response.resultsLength,
+          resultsIndex: response.resultsIndex
+        };
+      }
+    }
+
+    return output;
+  }), {
+    impl: "_search"
+  }),
+
   _releaseFront: function(node, force) {
     if (node.retained && !force) {
       node.reparent(null);
       this._retainedOrphans.add(node);
       return;
     }
 
     if (node.retained) {
@@ -3548,16 +3699,20 @@ DocumentWalker.prototype = {
   get whatToShow() this.walker.whatToShow,
   get currentNode() this.walker.currentNode,
   set currentNode(aVal) this.walker.currentNode = aVal,
 
   parentNode: function() {
     return this.walker.parentNode();
   },
 
+  nextNode: function() {
+    return this.walker.nextNode();
+  },
+
   firstChild: function() {
     let node = this.walker.currentNode;
     if (!node)
       return null;
 
     let firstChild = this.walker.firstChild();
     while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       firstChild = this.walker.nextSibling();
diff --git a/toolkit/devtools/server/actors/utils/walker-search.js b/toolkit/devtools/server/actors/utils/walker-search.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/actors/utils/walker-search.js
@@ -0,0 +1,257 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ * The walker-search module provides a simple API to index and search strings
+ * and elements inside a given document.
+ * It indexes tag names, attribute names and values, and text contents.
+ * It provides a simple search function that returns a list of nodes that
+ * matched.
+ */
+
+const {Ci, Cu} = require("chrome");
+
+/**
+ * The WalkerIndex class indexes the given document provides the data.
+ * The document is only indexed the first time the data is accessed and will be
+ * re-indexed when the data is accessed if markup-mutations were observed in the
+ * meantime.
+ *
+ * Usage example:
+ * let index = new WalkerIndex(doc);
+ * index.data; // returns the indexed data as a Map of with strings as keys
+ * index.destroy();
+ *
+ * @param {Walker} walker The walker to be indexed
+ */
+function WalkerIndex(walker) {
+  this.walker = walker;
+  this.clearIndex = this.clearIndex.bind(this);
+
+  // Kill the index when mutations occur, the next data get will re-index.
+
+  // XXX: This is limited because the walker won't emit mutations for documents
+  // that aren't used in other tools.  We will need probably need to set up observers
+  // using the tabActors windows and listen for frame load and unload.
+  // So for now the index gets killed on every fetch
+  this.walker.on("new-mutations", this.clearIndex);
+}
+
+WalkerIndex.prototype = {
+  /**
+   * Destroy this instance, releasing all data and references
+   */
+  destroy: function() {
+    this.walker.off("new-mutations", this.clearIndex);
+  },
+
+  clearIndex: function() {
+    this._data = null;
+  },
+
+  get doc() {
+    return this.walker.rootDoc;
+  },
+
+  /**
+   * Get the indexed data
+   * This getter also indexes if it hasn't been done yet or if the state is
+   * dirty
+   */
+  get data() {
+    if (!this._data) {
+      this._data = new Map();
+      this.index();
+    }
+
+    // XXX: Right now we are busting the cache every time it is fetched,
+    // until there is a solution for the observer above.
+    let data = this._data;
+    this.clearIndex();
+    return data;
+  },
+
+  _addToIndex: function(type, node, value) {
+    // Add an entry for this value if there isn't one
+    let entry = this._data.get(value);
+    if (!entry) {
+      this._data.set(value, []);
+    }
+
+    // Add the type/node to the list
+    this._data.get(value).push({
+      type: type,
+      node: node
+    });
+  },
+
+  index: function() {
+    let documentWalker = this.walker.getDocumentWalker(this.doc);
+    while (documentWalker.nextNode()) {
+      let node = documentWalker.currentNode;
+
+      if (node.nodeType === 1) {
+        // For each element node, we get the tagname and all attributes names
+        // and values
+        this._addToIndex("tag", node, node.localName);
+        for (let {name, value} of node.attributes) {
+          this._addToIndex("attributeName", node, name);
+          this._addToIndex("attributeValue", node, value);
+        }
+      } else if (node.textContent && node.textContent.trim().length) {
+        // For comments and text nodes, we get the text
+        this._addToIndex("text", node, node.textContent.trim());
+      }
+    }
+  }
+};
+
+exports.WalkerIndex = WalkerIndex;
+
+/**
+ * The WalkerSearch class provides a way to search an indexed document as well
+ * as find elements that match a given css selector.
+ *
+ * Usage example:
+ * let s = new WalkerSearch(doc);
+ * let res = s.search("lang", index);
+ * for (let {matched, results} of res) {
+ *   for (let {node, type} of results) {
+ *     console.log("The query matched a node's " + type);
+ *     console.log("String matched: " + matched);
+ *     console.log("Node that matched", node);
+ *    }
+ * }
+ * s.destroy();
+ *
+ * @param {Walker} the walker to be searched
+ */
+function WalkerSearch(walker) {
+  this.walker = walker;
+  this.index = new WalkerIndex(this.walker);
+}
+
+WalkerSearch.prototype = {
+  destroy: function() {
+    this.index.destroy();
+    this.walker = null;
+  },
+
+  _addResult: function(node, type, matched, results) {
+    if (!results.has(node)) {
+      results.set(node, []);
+    }
+
+    let matches = results.get(node);
+
+    // Do not add if the exact same result is already in the list
+    let isKnown = false;
+    for (let match of matches) {
+      if (match.type === type && match.matched === matched) {
+        isKnown = true;
+        break;
+      }
+    }
+
+    if (!isKnown) {
+      matches.push({
+        matched: matched,
+        type: type
+      });
+    }
+  },
+
+  _searchIndex: function(query, options, results) {
+    for (let [matched, res] of this.index.data) {
+      if (options.searchMethod(query, matched)) {
+        // Filtering out all unwanted types
+        res = res.filter(entry => options.types.indexOf(entry.type) !== -1);
+        if (res.length) {
+          res.forEach(({node, type}) => {
+            this._addResult(node, type, matched, results);
+          });
+        }
+      }
+    }
+  },
+
+  _searchSelectors: function(query, options, results) {
+    // If the query is just one "word", no need to search because _searchIndex
+    // will lead the same results since it has access to tagnames anyway
+    let isSelector = query.match(/[ >~.#\[\]]/);
+    if (options.types.indexOf("selector") === -1 || !isSelector) {
+      return;
+    }
+
+    let nodes = this.walker._multiFrameQuerySelectorAll(query);
+    for (let node of nodes) {
+      let lastPart = query.split(/[ ~>]/).pop();
+      let matched = node.localName;
+      let type = "selector";
+
+      this._addResult(node, type, matched, results);
+    }
+  },
+
+  /**
+   * Search the document
+   * @param {String} query What to search for
+   * @param {Object} options The following options are accepted:
+   * - searchMethod {String} one of WalkerSearch.SEARCH_METHOD_*
+   *   defaults to WalkerSearch.SEARCH_METHOD_CONTAINS (does not apply to
+   *   selector search type)
+   * - types {Array} a list of things to search for (tag, text, attributes, etc)
+   *   defaults to WalkerSearch.ALL_RESULTS_TYPES
+   * @return {Array} An array is returned with each item being an object like:
+   * {
+   *   node: <the dom node that matched>,
+   *   matched: <the string that matched within that node>,
+   *   type: <the type of match: one of WalkerSearch.ALL_RESULTS_TYPES>
+   * }
+   */
+  search: function(query, options={}) {
+    options.searchMethod = options.searchMethod || WalkerSearch.SEARCH_METHOD_CONTAINS;
+    options.types = options.types || WalkerSearch.ALL_RESULTS_TYPES;
+
+    // Store results in a map indexed by nodes to avoid duplicate results
+    let results = new Map();
+
+    // Search through the indexed data
+    this._searchIndex(query, options, results);
+    // Search with querySelectorAll
+    this._searchSelectors(query, options, results);
+
+    // Make a usable output
+    let resultList = [];
+    for (let [node, matches] of results) {
+      for (let {type, matched} of matches) {
+        resultList.push({
+          node: node,
+          type: type,
+          matched: matched
+        });
+      }
+    }
+
+    // Sort the resulting nodes by order of appearance in the DOM
+    resultList.sort((a,b) => {
+      return a.node.compareDocumentPosition(b.node) & 4 ? -1 : 1;
+    });
+
+    return resultList;
+  }
+};
+
+WalkerSearch.SEARCH_METHOD_CONTAINS = (query, candidate) => {
+  return candidate.toLowerCase().indexOf(query.toLowerCase()) !== -1;
+};
+WalkerSearch.SEARCH_METHOD_STARTSWITH = (query, candidate) => {
+  return candidate.toLowerCase().startsWith(query.toLowerCase());
+};
+WalkerSearch.ALL_RESULTS_TYPES = ["tag", "text", "attributeName",
+                                    "attributeValue", "selector"];
+
+exports.WalkerSearch = WalkerSearch;
diff --git a/toolkit/devtools/server/moz.build b/toolkit/devtools/server/moz.build
--- a/toolkit/devtools/server/moz.build
+++ b/toolkit/devtools/server/moz.build
@@ -76,12 +76,13 @@ EXTRA_JS_MODULES.devtools.server.actors 
 EXTRA_JS_MODULES.devtools.server.actors.utils += [
     'actors/utils/actor-registry-utils.js',
     'actors/utils/audionodes.json',
     'actors/utils/automation-timeline.js',
     'actors/utils/make-debugger.js',
     'actors/utils/map-uri-to-addon-id.js',
     'actors/utils/ScriptStore.js',
     'actors/utils/stack.js',
-    'actors/utils/TabSources.js'
+    'actors/utils/TabSources.js',
+    'actors/utils/walker-search.js',
 ]
 
 FAIL_ON_WARNINGS = True
diff --git a/toolkit/devtools/server/tests/mochitest/chrome.ini b/toolkit/devtools/server/tests/mochitest/chrome.ini
--- a/toolkit/devtools/server/tests/mochitest/chrome.ini
+++ b/toolkit/devtools/server/tests/mochitest/chrome.ini
@@ -80,8 +80,9 @@ skip-if = buildapp == 'mulet'
 [test_settings.html]
 [test_connectToChild.html]
 skip-if = buildapp == 'mulet'
 [test_getProcess.html]
 skip-if = buildapp == 'mulet'
 [test_director.html]
 [test_director_connectToChild.html]
 skip-if = buildapp == 'mulet'
+[test_walker_search_01.html]
diff --git a/toolkit/devtools/server/tests/mochitest/test_walker_search_01.html b/toolkit/devtools/server/tests/mochitest/test_walker_search_01.html
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/mochitest/test_walker_search_01.html
@@ -0,0 +1,67 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=835896
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 835896</title>
+
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+  <script type="application/javascript;version=1.8" src="inspector-helpers.js"></script>
+  <script type="application/javascript;version=1.8">
+window.onload = function() {
+  Components.utils.import("resource://gre/modules/devtools/Loader.jsm");
+  const {Promise: promise} =
+    Components.utils.import("resource://gre/modules/Promise.jsm", {});
+  const {InspectorFront} =
+    devtools.require("devtools/server/actors/inspector");
+  SimpleTest.waitForExplicitFinish();
+
+  let walker = null;
+  let client = null;
+  let inspectee = null;
+  let inspector = null;
+
+  addAsyncTest(function* setup() {
+    info ("Setting up inspector and walker actors.");
+
+    let url = document.getElementById("inspectorContent").href;
+    let urlAttached = promise.defer();
+
+    attachURL(url, function(err, client, tab, doc) {
+      inspectee = doc;
+      inspector = InspectorFront(client, tab);
+      urlAttached.resolve();
+    });
+
+    yield urlAttached.promise;
+
+    walker = yield inspector.getWalker();
+    ok(walker, "getWalker() should return an actor.");
+    runNextTest();
+  });
+
+  addAsyncTest(function* testSearchExists() {
+    info ("Testing basic search APIs exist.");
+
+    ok(walker.search, "search is here");
+    runNextTest();
+  });
+
+  runNextTest();
+};
+  </script>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=">Mozilla Bug </a>
+<a id="inspectorContent" target="_blank" href="inspector-traversal-data.html">Test Document</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+</body>
+</html>
