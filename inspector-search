# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c921afa9fc3e164ab52dc4564349a92e16663317
Bug 835896 - Inspector searchbox should also provide a way to search plain text on the page;r=pbrosset

diff --git a/devtools/client/framework/selection.js b/devtools/client/framework/selection.js
--- a/devtools/client/framework/selection.js
+++ b/devtools/client/framework/selection.js
@@ -157,16 +157,22 @@ Selection.prototype = {
       return this.node.ownerDocument;
     }
     return null;
   },
 
   setNodeFront: function(value, reason="unknown") {
     this.reason = reason;
 
+    // If a singleTextChild text node is being set, then set it's parent instead.
+    let parentNode = value && value.parentNode();
+    if (value && parentNode && parentNode.singleTextChild === value) {
+      value = parentNode;
+    }
+
     // We used to return here if the node had not changed but we now need to
     // set the node even if it is already set otherwise it is not possible to
     // e.g. highlight the same node twice.
     let rawValue = null;
     if (value && value.isLocal_toBeDeprecated()) {
       rawValue = value.rawNode();
     }
     this.emit("before-new-node", rawValue, reason);
diff --git a/devtools/client/inspector/inspector-panel.js b/devtools/client/inspector/inspector-panel.js
--- a/devtools/client/inspector/inspector-panel.js
+++ b/devtools/client/inspector/inspector-panel.js
@@ -11,17 +11,17 @@ Cu.import("resource://gre/modules/Servic
 var promise = require("promise");
 var EventEmitter = require("devtools/shared/event-emitter");
 var clipboard = require("sdk/clipboard");
 var {HostType} = require("devtools/client/framework/toolbox").Toolbox;
 
 loader.lazyGetter(this, "MarkupView", () => require("devtools/client/markupview/markup-view").MarkupView);
 loader.lazyGetter(this, "HTMLBreadcrumbs", () => require("devtools/client/inspector/breadcrumbs").HTMLBreadcrumbs);
 loader.lazyGetter(this, "ToolSidebar", () => require("devtools/client/framework/sidebar").ToolSidebar);
-loader.lazyGetter(this, "SelectorSearch", () => require("devtools/client/inspector/selector-search").SelectorSearch);
+loader.lazyGetter(this, "InspectorSearch", () => require("devtools/client/inspector/inspector-search").InspectorSearch);
 
 loader.lazyGetter(this, "strings", () => {
   return Services.strings.createBundle("chrome://devtools/locale/inspector.properties");
 });
 loader.lazyGetter(this, "toolboxStrings", () => {
   return Services.strings.createBundle("chrome://devtools/locale/toolbox.properties");
 });
 loader.lazyGetter(this, "clipboardHelper", () => {
@@ -73,17 +73,30 @@ const LAYOUT_CHANGE_TIMER = 250;
 function InspectorPanel(iframeWindow, toolbox) {
   this._toolbox = toolbox;
   this._target = toolbox._target;
   this.panelDoc = iframeWindow.document;
   this.panelWin = iframeWindow;
   this.panelWin.inspector = this;
 
   this.nodeMenuTriggerInfo = null;
+
   this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
+  this.onNewRoot = this.onNewRoot.bind(this);
+  this._setupNodeMenu = this._setupNodeMenu.bind(this);
+  this._resetNodeMenu = this._resetNodeMenu.bind(this);
+  this._updateSearchLabel = this._updateSearchLabel.bind(this);
+  this.onNewSelection = this.onNewSelection.bind(this);
+  this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
+  this.onDetached = this.onDetached.bind(this);
+  this.onToolboxHostChanged = this.onToolboxHostChanged.bind(this);
+  this.scheduleLayoutChange = this.scheduleLayoutChange.bind(this);
+  this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
+  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);
+
   this._target.on("will-navigate", this._onBeforeNavigate);
 
   EventEmitter.decorate(this);
 }
 
 exports.InspectorPanel = InspectorPanel;
 
 InspectorPanel.prototype = {
@@ -134,41 +147,33 @@ InspectorPanel.prototype = {
 
   get canPasteInnerOrAdjacentHTML() {
     return this._target.client.traits.pasteHTML;
   },
 
   _deferredOpen: function(defaultSelection) {
     let deferred = promise.defer();
 
-    this.onNewRoot = this.onNewRoot.bind(this);
     this.walker.on("new-root", this.onNewRoot);
 
     this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
     this.lastNodemenuItem = this.nodemenu.lastChild;
-    this._setupNodeMenu = this._setupNodeMenu.bind(this);
-    this._resetNodeMenu = this._resetNodeMenu.bind(this);
     this.nodemenu.addEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.addEventListener("popuphiding", this._resetNodeMenu, true);
 
-    this.onNewSelection = this.onNewSelection.bind(this);
     this.selection.on("new-node-front", this.onNewSelection);
-    this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
     this.selection.on("before-new-node-front", this.onBeforeNewSelection);
-    this.onDetached = this.onDetached.bind(this);
     this.selection.on("detached-front", this.onDetached);
 
     this.breadcrumbs = new HTMLBreadcrumbs(this);
 
-    this.onToolboxHostChanged = this.onToolboxHostChanged.bind(this);
     this._toolbox.on("host-changed", this.onToolboxHostChanged);
 
     if (this.target.isLocalTab) {
       this.browser = this.target.tab.linkedBrowser;
-      this.scheduleLayoutChange = this.scheduleLayoutChange.bind(this);
       this.browser.addEventListener("resize", this.scheduleLayoutChange, true);
 
       // Show a warning when the debugger is paused.
       // We show the warning only when the inspector
       // is selected.
       this.updateDebuggerPausedWarning = () => {
         let notificationBox = this._toolbox.getNotificationBox();
         let notification = notificationBox.getNotificationWithValue("inspector-script-paused");
@@ -304,23 +309,42 @@ InspectorPanel.prototype = {
   markDirty: function() {
     this.isDirty = true;
   },
 
   /**
    * Hooks the searchbar to show result and auto completion suggestions.
    */
   setupSearchBox: function() {
-    // Initiate the selectors search object.
-    if (this.searchSuggestions) {
-      this.searchSuggestions.destroy();
-      this.searchSuggestions = null;
+    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
+    this.searchLabel = this.panelDoc.getElementById("inspector-searchlabel");
+
+    this.search = new InspectorSearch(this, this.searchBox);
+    this.search.on("search-cleared", this._updateSearchLabel);
+    this.search.on("search-no-result", this._updateSearchLabel);
+    this.search.on("search-result", this._updateSearchLabel);
+  },
+
+  get searchSuggestions() {
+    return this.search.autocompleter;
+  },
+
+  _updateSearchLabel: function(event, result) {
+    let str = "";
+    if (event !== "search-cleared") {
+      if (result) {
+        str = strings.formatStringFromName(
+          "inspector.searchResultsCount2",
+          [result.resultsIndex + 1, result.resultsLength], 2);
+      } else if (event === "search-no-result") {
+        str = strings.GetStringFromName("inspector.searchResultsNone");
+      }
     }
-    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
-    this.searchSuggestions = new SelectorSearch(this, this.searchBox);
+
+    this.searchLabel.textContent = str;
   },
 
   /**
    * Build the sidebar.
    */
   setupSidebar: function() {
     let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
     this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
@@ -364,17 +388,16 @@ InspectorPanel.prototype = {
     this.setupSidebarToggle();
   },
 
   /**
    * Add the expand/collapse behavior for the sidebar panel.
    */
   setupSidebarToggle: function() {
     this._paneToggleButton = this.panelDoc.getElementById("inspector-pane-toggle");
-    this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
     this._paneToggleButton.addEventListener("mousedown",
       this.onPaneToggleButtonClicked);
     this.updatePaneToggleButton();
   },
 
   /**
    * Reset the inspector on new root mutation.
    */
@@ -394,17 +417,16 @@ InspectorPanel.prototype = {
       this.selection.setNodeFront(defaultNode, "navigateaway");
 
       this._initMarkup();
       this.once("markuploaded", () => {
         if (!this.markup) {
           return;
         }
         this.markup.expandNode(this.selection.nodeFront);
-        this.setupSearchBox();
         this.emit("new-root");
       });
     };
     this._pendingSelection = onNodeSelected;
     this._getDefaultNodeForSelection().then(onNodeSelected, console.error);
   },
 
   _selectionCssSelector: null,
@@ -585,32 +607,32 @@ InspectorPanel.prototype = {
     this.sidebar = null;
 
     this.nodemenu.removeEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.removeEventListener("popuphiding", this._resetNodeMenu, true);
     this.breadcrumbs.destroy();
     this._paneToggleButton.removeEventListener("mousedown",
       this.onPaneToggleButtonClicked);
     this._paneToggleButton = null;
-    this.searchSuggestions.destroy();
-    this.searchBox = null;
     this.selection.off("new-node-front", this.onNewSelection);
     this.selection.off("before-new-node", this.onBeforeNewSelection);
     this.selection.off("before-new-node-front", this.onBeforeNewSelection);
     this.selection.off("detached-front", this.onDetached);
     let markupDestroyer = this._destroyMarkup();
     this.panelWin.inspector = null;
     this.target = null;
     this.panelDoc = null;
     this.panelWin = null;
     this.breadcrumbs = null;
-    this.searchSuggestions = null;
     this.lastNodemenuItem = null;
     this.nodemenu = null;
     this._toolbox = null;
+    this.search.destroy();
+    this.search = null;
+    this.searchBox = null;
 
     this._panelDestroyer = promise.all([
       sidebarDestroyer,
       markupDestroyer
     ]);
 
     return this._panelDestroyer;
   },
@@ -909,46 +931,41 @@ InspectorPanel.prototype = {
 
     // create tool iframe
     this._markupFrame = doc.createElement("iframe");
     this._markupFrame.setAttribute("flex", "1");
     this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
     this._markupFrame.setAttribute("context", "inspector-node-popup");
 
     // This is needed to enable tooltips inside the iframe document.
-    this._boundMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);
-    this._markupFrame.addEventListener("load", this._boundMarkupFrameLoad, true);
+    this._markupFrame.addEventListener("load", this._onMarkupFrameLoad, true);
 
     this._markupBox.setAttribute("collapsed", true);
     this._markupBox.appendChild(this._markupFrame);
     this._markupFrame.setAttribute("src", "chrome://devtools/content/markupview/markup-view.xhtml");
     this._markupFrame.setAttribute("aria-label", strings.GetStringFromName("inspector.panelLabel.markupView"));
   },
 
   _onMarkupFrameLoad: function() {
-    this._markupFrame.removeEventListener("load", this._boundMarkupFrameLoad, true);
-    delete this._boundMarkupFrameLoad;
+    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
 
     this._markupFrame.contentWindow.focus();
 
     this._markupBox.removeAttribute("collapsed");
 
     let controllerWindow = this._toolbox.doc.defaultView;
     this.markup = new MarkupView(this, this._markupFrame, controllerWindow);
 
     this.emit("markuploaded");
   },
 
   _destroyMarkup: function() {
     let destroyPromise;
 
-    if (this._boundMarkupFrameLoad) {
-      this._markupFrame.removeEventListener("load", this._boundMarkupFrameLoad, true);
-      this._boundMarkupFrameLoad = null;
-    }
+    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
 
     if (this.markup) {
       destroyPromise = this.markup.destroy();
       this.markup = null;
     } else {
       destroyPromise = promise.resolve();
     }
 
diff --git a/devtools/client/inspector/selector-search.js b/devtools/client/inspector/inspector-search.js
rename from devtools/client/inspector/selector-search.js
rename to devtools/client/inspector/inspector-search.js
--- a/devtools/client/inspector/selector-search.js
+++ b/devtools/client/inspector/inspector-search.js
@@ -1,54 +1,145 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-const { Cu } = require("chrome");
+const {Cu, Ci} = require("chrome");
 
 const promise = require("promise");
 loader.lazyGetter(this, "EventEmitter", () => require("devtools/shared/event-emitter"));
 loader.lazyGetter(this, "AutocompletePopup", () => require("devtools/client/shared/autocomplete-popup").AutocompletePopup);
 
 // Maximum number of selector suggestions shown in the panel.
 const MAX_SUGGESTIONS = 15;
 
+
+/**
+ * Converts any input field into a document search box.
+ *
+ * @param {InspectorPanel} inspector The InspectorPanel whose `walker` attribute
+ * should be used for document traversal.
+ * @param {DOMNode} input The input element to which the panel will be attached
+ * and from where search input will be taken.
+ *
+ * Emits the following events:
+ * - search-cleared: when the search box is emptied
+ * - search-no-result: when a search is made that yields no result
+ * - search-result: when a search is made and a result is selected
+ */
+function InspectorSearch(inspector, input) {
+  this.inspector = inspector;
+  this.searchBox = input;
+  this._lastSearched = null;
+
+  this._onKeyDown = this._onKeyDown.bind(this);
+  this._onCommand = this._onCommand.bind(this);
+  this.searchBox.addEventListener("keydown", this._onKeyDown, true);
+  this.searchBox.addEventListener("command", this._onCommand, true);
+
+  // For testing, we need to be able to wait for the most recent node request
+  // to finish.  Tests can watch this promise for that.
+  this._lastQuery = promise.resolve(null);
+
+  this.autocompleter = new SelectorAutocompleter(inspector, input);
+  EventEmitter.decorate(this);
+}
+
+exports.InspectorSearch = InspectorSearch;
+
+InspectorSearch.prototype = {
+  get walker() this.inspector.walker,
+
+  destroy: function() {
+    this.searchBox.removeEventListener("keydown", this._onKeyDown, true);
+    this.searchBox.removeEventListener("command", this._onCommand, true);
+    this.searchBox = null;
+    this.autocompleter.destroy();
+  },
+
+  _onSearch: Task.async(function*(reverse = false) {
+    this._lastQuery = this.doFullTextSearch(this.searchBox.value, reverse)
+                          .catch(e => console.error(e));
+  }),
+
+  doFullTextSearch: Task.async(function*(query, reverse) {
+    let lastSearched = this._lastSearched;
+    this._lastSearched = query;
+
+    if (query.length === 0) {
+      this.searchBox.classList.remove("devtools-no-search-result");
+      if (!lastSearched || lastSearched.length > 0) {
+        this.emit("search-cleared");
+      }
+      return;
+    }
+
+    let res = yield this.walker.search(query, { reverse });
+
+    // Value has changed since we started this request, we're done.
+    if (query != this.searchBox.value) {
+      return;
+    }
+
+    if (res) {
+      this.inspector.selection.setNodeFront(res.node, "inspectorsearch");
+      this.searchBox.classList.remove("devtools-no-search-result");
+
+      res.query = query;
+      this.emit("search-result", res);
+    } else {
+      this.searchBox.classList.add("devtools-no-search-result");
+      this.emit("search-no-result");
+    }
+  }),
+
+  _onCommand: function() {
+    if (this.searchBox.value.length === 0) {
+      this._onSearch();
+    }
+  },
+
+  _onKeyDown: function(event) {
+    if (this.searchBox.value.length === 0) {
+      this.searchBox.removeAttribute("filled");
+    } else {
+      this.searchBox.setAttribute("filled", true);
+    }
+    if (event.keyCode === event.DOM_VK_RETURN) {
+      this._onSearch();
+    } if (event.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_G && event.metaKey) {
+      this._onSearch(event.shiftKey);
+      event.preventDefault();
+    }
+  }
+};
+
 /**
  * Converts any input box on a page to a CSS selector search and suggestion box.
  *
  * Emits 'processing-done' event when it is done processing the current
  * keypress, search request or selection from the list, whether that led to a
  * search or not.
  *
  * @constructor
- * @param InspectorPanel aInspector
+ * @param InspectorPanel inspector
  *        The InspectorPanel whose `walker` attribute should be used for
  *        document traversal.
- * @param nsiInputElement aInputNode
+ * @param nsiInputElement inputNode
  *        The input element to which the panel will be attached and from where
  *        search input will be taken.
  */
-function SelectorSearch(aInspector, aInputNode) {
-  this.inspector = aInspector;
-  this.searchBox = aInputNode;
+function SelectorAutocompleter(inspector, inputNode) {
+  this.inspector = inspector;
+  this.searchBox = inputNode;
   this.panelDoc = this.searchBox.ownerDocument;
 
-  // initialize variables.
-  this._lastSearched = null;
-  this._lastValidSearch = "";
-  this._lastToLastValidSearch = null;
-  this._searchResults = null;
-  this._searchSuggestions = {};
-  this._searchIndex = 0;
-
-  // bind!
-  this._showPopup = this._showPopup.bind(this);
-  this._onHTMLSearch = this._onHTMLSearch.bind(this);
+  this.showSuggestions = this.showSuggestions.bind(this);
   this._onSearchKeypress = this._onSearchKeypress.bind(this);
   this._onListBoxKeypress = this._onListBoxKeypress.bind(this);
   this._onMarkupMutation = this._onMarkupMutation.bind(this);
 
   // Options for the AutocompletePopup.
   let options = {
     panelId: "inspector-searchbox-panel",
     listBoxId: "searchbox-panel-listbox",
@@ -56,30 +147,29 @@ function SelectorSearch(aInspector, aInp
     position: "before_start",
     direction: "ltr",
     theme: "auto",
     onClick: this._onListBoxKeypress,
     onKeypress: this._onListBoxKeypress
   };
   this.searchPopup = new AutocompletePopup(this.panelDoc, options);
 
-  // event listeners.
-  this.searchBox.addEventListener("command", this._onHTMLSearch, true);
+  this.searchBox.addEventListener("input", this.showSuggestions, true);
   this.searchBox.addEventListener("keypress", this._onSearchKeypress, true);
   this.inspector.on("markupmutation", this._onMarkupMutation);
 
   // For testing, we need to be able to wait for the most recent node request
   // to finish.  Tests can watch this promise for that.
   this._lastQuery = promise.resolve(null);
   EventEmitter.decorate(this);
 }
 
-exports.SelectorSearch = SelectorSearch;
+exports.SelectorAutocompleter = SelectorAutocompleter;
 
-SelectorSearch.prototype = {
+SelectorAutocompleter.prototype = {
   get walker() {
     return this.inspector.walker;
   },
 
   // The possible states of the query.
   States: {
     CLASS: "class",
     ID: "id",
@@ -164,268 +254,123 @@ SelectorSearch.prototype = {
     }
     return this._state;
   },
 
   /**
    * Removes event listeners and cleans up references.
    */
   destroy: function() {
-    // event listeners.
-    this.searchBox.removeEventListener("command", this._onHTMLSearch, true);
+    this.searchBox.removeEventListener("input", this.showSuggestions, true);
     this.searchBox.removeEventListener("keypress", this._onSearchKeypress, true);
     this.inspector.off("markupmutation", this._onMarkupMutation);
     this.searchPopup.destroy();
     this.searchPopup = null;
     this.searchBox = null;
     this.panelDoc = null;
-    this._searchResults = null;
-    this._searchSuggestions = null;
-  },
-
-  _selectResult: function(index) {
-    return this._searchResults.item(index).then(node => {
-      this.inspector.selection.setNodeFront(node, "selectorsearch");
-    });
-  },
-
-  _queryNodes: Task.async(function*(query) {
-    if (typeof this.hasMultiFrameSearch === "undefined") {
-      let target = this.inspector.toolbox.target;
-      this.hasMultiFrameSearch = yield target.actorHasMethod("domwalker",
-        "multiFrameQuerySelectorAll");
-    }
-
-    if (this.hasMultiFrameSearch) {
-      return yield this.walker.multiFrameQuerySelectorAll(query);
-    } else {
-      return yield this.walker.querySelectorAll(this.walker.rootNode, query);
-    }
-  }),
-
-  /**
-   * The command callback for the input box. This function is automatically
-   * invoked as the user is typing if the input box type is search.
-   */
-  _onHTMLSearch: function() {
-    let query = this.searchBox.value;
-    if (query == this._lastSearched) {
-      this.emit("processing-done");
-      return;
-    }
-    this._lastSearched = query;
-    this._searchResults = [];
-    this._searchIndex = 0;
-
-    if (query.length == 0) {
-      this._lastValidSearch = "";
-      this.searchBox.removeAttribute("filled");
-      this.searchBox.classList.remove("devtools-no-search-result");
-      if (this.searchPopup.isOpen) {
-        this.searchPopup.hidePopup();
-      }
-      this.emit("processing-done");
-      return;
-    }
-
-    this.searchBox.setAttribute("filled", true);
-    let queryList = null;
-
-    this._lastQuery = this._queryNodes(query).then(list => {
-      return list;
-    }, (err) => {
-      // Failures are ok here, just use a null item list;
-      return null;
-    }).then(queryList => {
-      // Value has changed since we started this request, we're done.
-      if (query != this.searchBox.value) {
-        if (queryList) {
-          queryList.release();
-        }
-        return promise.reject(null);
-      }
-
-      this._searchResults = queryList || [];
-      if (this._searchResults && this._searchResults.length > 0) {
-        this._lastValidSearch = query;
-        // Even though the selector matched atleast one node, there is still
-        // possibility of suggestions.
-        if (query.match(/[\s>+]$/)) {
-          // If the query has a space or '>' at the end, create a selector to match
-          // the children of the selector inside the search box by adding a '*'.
-          this._lastValidSearch += "*";
-        }
-        else if (query.match(/[\s>+][\.#a-zA-Z][\.#>\s+]*$/)) {
-          // If the query is a partial descendant selector which does not matches
-          // any node, remove the last incomplete part and add a '*' to match
-          // everything. For ex, convert 'foo > b' to 'foo > *' .
-          let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+]*$/)[0];
-          this._lastValidSearch = query.slice(0, -1 * lastPart.length + 1) + "*";
-        }
-
-        if (!query.slice(-1).match(/[\.#\s>+]/)) {
-          // Hide the popup if we have some matching nodes and the query is not
-          // ending with [.# >] which means that the selector is not at the
-          // beginning of a new class, tag or id.
-          if (this.searchPopup.isOpen) {
-            this.searchPopup.hidePopup();
-          }
-          this.searchBox.classList.remove("devtools-no-search-result");
-
-          return this._selectResult(0);
-        }
-        return this._selectResult(0).then(() => {
-          this.searchBox.classList.remove("devtools-no-search-result");
-        }).then(() => this.showSuggestions());
-      }
-      if (query.match(/[\s>+]$/)) {
-        this._lastValidSearch = query + "*";
-      }
-      else if (query.match(/[\s>+][\.#a-zA-Z][\.#>\s+]*$/)) {
-        let lastPart = query.match(/[\s+>][\.#a-zA-Z][^>\s+]*$/)[0];
-        this._lastValidSearch = query.slice(0, -1 * lastPart.length + 1) + "*";
-      }
-      this.searchBox.classList.add("devtools-no-search-result");
-      return this.showSuggestions();
-    }).then(() => this.emit("processing-done"), Cu.reportError);
   },
 
   /**
    * Handles keypresses inside the input box.
    */
-  _onSearchKeypress: function(aEvent) {
+  _onSearchKeypress: function(event) {
     let query = this.searchBox.value;
-    switch(aEvent.keyCode) {
-      case aEvent.DOM_VK_RETURN:
-        if (query == this._lastSearched && this._searchResults) {
-          this._searchIndex = (this._searchIndex + 1) % this._searchResults.length;
-        }
-        else {
-          this._onHTMLSearch();
-          return;
+    switch(event.keyCode) {
+      case event.DOM_VK_RETURN:
+      case event.DOM_VK_TAB:
+        if (this.searchPopup.isOpen &&
+            this.searchPopup.getItemAtIndex(this.searchPopup.itemCount - 1)
+                .preLabel == query) {
+          this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
+          this.searchBox.value = this.searchPopup.selectedItem.label;
+          this.hidePopup();
         }
         break;
 
-      case aEvent.DOM_VK_UP:
+      case event.DOM_VK_UP:
         if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
           this.searchPopup.focus();
           if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
             this.searchPopup.selectedIndex =
               Math.max(0, this.searchPopup.itemCount - 2);
           }
           else {
             this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
           }
           this.searchBox.value = this.searchPopup.selectedItem.label;
         }
-        else if (--this._searchIndex < 0) {
-          this._searchIndex = this._searchResults.length - 1;
-        }
         break;
 
-      case aEvent.DOM_VK_DOWN:
+      case event.DOM_VK_DOWN:
         if (this.searchPopup.isOpen && this.searchPopup.itemCount > 0) {
           this.searchPopup.focus();
           this.searchPopup.selectedIndex = 0;
           this.searchBox.value = this.searchPopup.selectedItem.label;
         }
-        this._searchIndex = (this._searchIndex + 1) % this._searchResults.length;
         break;
 
-      case aEvent.DOM_VK_TAB:
-        if (this.searchPopup.isOpen &&
-            this.searchPopup.getItemAtIndex(this.searchPopup.itemCount - 1)
-                .preLabel == query) {
-          this.searchPopup.selectedIndex = this.searchPopup.itemCount - 1;
-          this.searchBox.value = this.searchPopup.selectedItem.label;
-          this._onHTMLSearch();
-        }
-        break;
-
-      case aEvent.DOM_VK_BACK_SPACE:
-      case aEvent.DOM_VK_DELETE:
-        // need to throw away the lastValidSearch.
-        this._lastToLastValidSearch = null;
-        // This gets the most complete selector from the query. For ex.
-        // '.foo.ba' returns '.foo' , '#foo > .bar.baz' returns '#foo > .bar'
-        // '.foo +bar' returns '.foo +' and likewise.
-        this._lastValidSearch = (query.match(/(.*)[\.#][^\.# ]{0,}$/) ||
-                                 query.match(/(.*[\s>+])[a-zA-Z][^\.# ]{0,}$/) ||
-                                 ["",""])[1];
-        return;
-
       default:
         return;
     }
 
-    aEvent.preventDefault();
-    aEvent.stopPropagation();
-    if (this._searchResults && this._searchResults.length > 0) {
-      this._lastQuery = this._selectResult(this._searchIndex).then(() => this.emit("processing-done"));
-    }
-    else {
-      this.emit("processing-done");
-    }
+    event.preventDefault();
+    event.stopPropagation();
+    this.emit("processing-done");
   },
 
   /**
    * Handles keypress and mouse click on the suggestions richlistbox.
    */
-  _onListBoxKeypress: function(aEvent) {
-    switch(aEvent.keyCode || aEvent.button) {
-      case aEvent.DOM_VK_RETURN:
-      case aEvent.DOM_VK_TAB:
+  _onListBoxKeypress: function(event) {
+    switch(event.keyCode || event.button) {
+      case event.DOM_VK_RETURN:
+      case event.DOM_VK_TAB:
       case 0: // left mouse button
-        aEvent.stopPropagation();
-        aEvent.preventDefault();
+        event.stopPropagation();
+        event.preventDefault();
         this.searchBox.value = this.searchPopup.selectedItem.label;
         this.searchBox.focus();
-        this._onHTMLSearch();
+        this.hidePopup();
         break;
 
-      case aEvent.DOM_VK_UP:
+      case event.DOM_VK_UP:
         if (this.searchPopup.selectedIndex == 0) {
           this.searchPopup.selectedIndex = -1;
-          aEvent.stopPropagation();
-          aEvent.preventDefault();
+          event.stopPropagation();
+          event.preventDefault();
           this.searchBox.focus();
         }
         else {
           let index = this.searchPopup.selectedIndex;
           this.searchBox.value = this.searchPopup.getItemAtIndex(index - 1).label;
         }
         break;
 
-      case aEvent.DOM_VK_DOWN:
+      case event.DOM_VK_DOWN:
         if (this.searchPopup.selectedIndex == this.searchPopup.itemCount - 1) {
           this.searchPopup.selectedIndex = -1;
-          aEvent.stopPropagation();
-          aEvent.preventDefault();
+          event.stopPropagation();
+          event.preventDefault();
           this.searchBox.focus();
         }
         else {
           let index = this.searchPopup.selectedIndex;
           this.searchBox.value = this.searchPopup.getItemAtIndex(index + 1).label;
         }
         break;
 
-      case aEvent.DOM_VK_BACK_SPACE:
-        aEvent.stopPropagation();
-        aEvent.preventDefault();
+      case event.DOM_VK_BACK_SPACE:
+        event.stopPropagation();
+        event.preventDefault();
         this.searchBox.focus();
         if (this.searchBox.selectionStart > 0) {
           this.searchBox.value =
             this.searchBox.value.substring(0, this.searchBox.selectionStart - 1);
         }
-        this._lastToLastValidSearch = null;
-        let query = this.searchBox.value;
-        this._lastValidSearch = (query.match(/(.*)[\.#][^\.# ]{0,}$/) ||
-                                 query.match(/(.*[\s>+])[a-zA-Z][^\.# ]{0,}$/) ||
-                                 ["",""])[1];
-        this._onHTMLSearch();
+        this.hidePopup();
         break;
     }
     this.emit("processing-done");
   },
 
   /**
    * Reset previous search results on markup-mutations to make sure we search
    * again after nodes have been added/removed/changed.
@@ -433,22 +378,22 @@ SelectorSearch.prototype = {
   _onMarkupMutation: function() {
     this._searchResults = null;
     this._lastSearched = null;
   },
 
   /**
    * Populates the suggestions list and show the suggestion popup.
    */
-  _showPopup: function(aList, aFirstPart, aState) {
+  _showPopup: function(list, firstPart, aState) {
     let total = 0;
     let query = this.searchBox.value;
     let items = [];
 
-    for (let [value, count, state] of aList) {
+    for (let [value, /*count*/, state] of list) {
       // for cases like 'div ' or 'div >' or 'div+'
       if (query.match(/[\s>+]$/)) {
         value = query + value;
       }
       // for cases like 'div #a' or 'div .a' or 'div > d' and likewise
       else if (query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#]*$/)) {
         let lastPart = query.match(/[\s>+][\.#a-zA-Z][^>\s+\.#]*$/)[0];
         value = query.slice(0, -1 * lastPart.length + 1) + value;
@@ -456,18 +401,17 @@ SelectorSearch.prototype = {
       // for cases like 'div.class' or '#foo.bar' and likewise
       else if (query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)) {
         let lastPart = query.match(/[a-zA-Z][#\.][^#\.\s>+]*$/)[0];
         value = query.slice(0, -1 * lastPart.length + 1) + value;
       }
 
       let item = {
         preLabel: query,
-        label: value,
-        count: count
+        label: value
       };
 
       // In case of tagNames, change the case to small
       if (value.match(/.*[\.#][^\.#]{0,}$/) == null) {
         item.label = value.toLowerCase();
       }
 
       // In case the query's state is tag and the item's state is id or class
@@ -484,63 +428,81 @@ SelectorSearch.prototype = {
         break;
       }
     }
     if (total > 0) {
       this.searchPopup.setItems(items);
       this.searchPopup.openPopup(this.searchBox);
     }
     else {
+      this.hidePopup();
+    }
+  },
+
+
+  /**
+   * Hide the suggestion popup if necessary.
+   */
+  hidePopup: function() {
+    if (this.searchPopup.isOpen) {
       this.searchPopup.hidePopup();
     }
   },
 
   /**
    * Suggests classes,ids and tags based on the user input as user types in the
    * searchbox.
    */
   showSuggestions: function() {
     let query = this.searchBox.value;
     let state = this.state;
     let firstPart = "";
 
-    if (state == this.States.TAG) {
+    if (state === this.States.TAG) {
       // gets the tag that is being completed. For ex. 'div.foo > s' returns 's',
       // 'di' returns 'di' and likewise.
       firstPart = (query.match(/[\s>+]?([a-zA-Z]*)$/) || ["", query])[1];
       query = query.slice(0, query.length - firstPart.length);
     }
-    else if (state == this.States.CLASS) {
+    else if (state === this.States.CLASS) {
       // gets the class that is being completed. For ex. '.foo.b' returns 'b'
       firstPart = query.match(/\.([^\.]*)$/)[1];
       query = query.slice(0, query.length - firstPart.length - 1);
     }
-    else if (state == this.States.ID) {
+    else if (state === this.States.ID) {
       // gets the id that is being completed. For ex. '.foo#b' returns 'b'
       firstPart = query.match(/#([^#]*)$/)[1];
       query = query.slice(0, query.length - firstPart.length - 1);
     }
     // TODO: implement some caching so that over the wire request is not made
     // everytime.
     if (/[\s+>~]$/.test(query)) {
       query += "*";
     }
 
-    this._currentSuggesting = query;
-    return this.walker.getSuggestionsForQuery(query, firstPart, state).then(result => {
-      if (this._currentSuggesting != result.query) {
+    this._lastQuery = this.walker.getSuggestionsForQuery(query, firstPart, state).then(result => {
+      this.emit("processing-done");
+      if (result.query !== query) {
         // This means that this response is for a previous request and the user
         // as since typed something extra leading to a new request.
         return;
       }
-      this._lastToLastValidSearch = this._lastValidSearch;
 
-      if (state == this.States.CLASS) {
+      if (state === this.States.CLASS) {
         firstPart = "." + firstPart;
-      }
-      else if (state == this.States.ID) {
+      } else if (state === this.States.ID) {
         firstPart = "#" + firstPart;
       }
 
+      // If there is a single tag match and it's what the user typed, then
+      // don't need to show a popup.
+      if (result.suggestions.length === 1 &&
+          result.suggestions[0][0] === firstPart) {
+        result.suggestions = [];
+      }
+
+
       this._showPopup(result.suggestions, firstPart, state);
     });
+
+    return this._lastQuery;
   }
 };
diff --git a/devtools/client/inspector/inspector.xul b/devtools/client/inspector/inspector.xul
--- a/devtools/client/inspector/inspector.xul
+++ b/devtools/client/inspector/inspector.xul
@@ -149,21 +149,22 @@
     <vbox flex="1" class="devtools-main-content">
       <toolbar id="inspector-toolbar"
         class="devtools-toolbar"
         nowindowdrag="true">
         <arrowscrollbox id="inspector-breadcrumbs"
           class="breadcrumbs-widget-container"
           flex="1" orient="horizontal"
           clicktoscroll="true"/>
+        <box id="inspector-searchlabel" />
         <textbox id="inspector-searchbox"
           type="search"
           timeout="50"
           class="devtools-searchinput"
-          placeholder="&inspectorSearchHTML.label2;"/>
+          placeholder="&inspectorSearchHTML.label3;"/>
         <toolbarbutton id="inspector-pane-toggle"
           class="devtools-toolbarbutton"
           tabindex="0" />
       </toolbar>
       <vbox flex="1" id="markup-box">
       </vbox>
     </vbox>
     <splitter class="devtools-side-splitter"/>
diff --git a/devtools/client/inspector/moz.build b/devtools/client/inspector/moz.build
--- a/devtools/client/inspector/moz.build
+++ b/devtools/client/inspector/moz.build
@@ -1,12 +1,12 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DevToolsModules(
     'breadcrumbs.js',
     'inspector-commands.js',
     'inspector-panel.js',
-    'selector-search.js'
+    'inspector-search.js'
 )
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
diff --git a/devtools/client/inspector/test/browser_inspector_search-02.js b/devtools/client/inspector/test/browser_inspector_search-02.js
--- a/devtools/client/inspector/test/browser_inspector_search-02.js
+++ b/devtools/client/inspector/test/browser_inspector_search-02.js
@@ -11,84 +11,89 @@ const TEST_URL = TEST_URL_ROOT + "doc_in
 // An array of (key, suggestions) pairs where key is a key to press and
 // suggestions is an array of suggestions that should be shown in the popup.
 // Suggestion is an object with label of the entry and optional count
 // (defaults to 1)
 const TEST_DATA = [
   {
     key: "d",
     suggestions: [
-      {label: "div", count: 4},
-      {label: "#d1", count: 1},
-      {label: "#d2", count: 1}
+      {label: "div"},
+      {label: "#d1"},
+      {label: "#d2"}
     ]
   },
   {
     key: "i",
-    suggestions: [{label: "div", count: 4}]
+    suggestions: [{label: "div"}]
   },
   {
     key: "v",
     suggestions: []
   },
   {
     key: " ",
     suggestions: [
-      {label: "div div", count: 2},
-      {label: "div span", count: 2}
+      {label: "div div"},
+      {label: "div span"}
     ]
   },
   {
     key: ">",
     suggestions: [
-      {label: "div >div", count: 2},
-      {label: "div >span", count: 2}
+      {label: "div >div"},
+      {label: "div >span"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: "div div", count: 2 },
-      {label: "div span", count: 2}
+      {label: "div div"},
+      {label: "div span"}
     ]
   },
   {
     key: "+",
     suggestions: [{label: "div +span"}]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: "div div", count: 2 },
-      {label: "div span", count: 2}
+      {label: "div div"},
+      {label: "div span"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: "VK_BACK_SPACE",
-    suggestions: [{label: "div", count: 4}]
+    suggestions: [{label: "div"}]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: "div", count: 4},
-      {label: "#d1", count: 1},
-      {label: "#d2", count: 1}
+      {label: "div"},
+      {label: "#d1"},
+      {label: "#d2"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: "p",
-    suggestions: []
+    suggestions: [
+      {label: "p"},
+      {label: "#p1"},
+      {label: "#p2"},
+      {label: "#p3"},
+    ]
   },
   {
     key: " ",
     suggestions: [{label: "p strong"}]
   },
   {
     key: "+",
     suggestions: [
@@ -148,19 +153,17 @@ add_task(function* () {
     let actualSuggestions = popup.getItems().reverse();
 
     is(popup.isOpen ? actualSuggestions.length: 0, suggestions.length,
        "There are expected number of suggestions.");
 
     for (let i = 0; i < suggestions.length; i++) {
       is(actualSuggestions[i].label, suggestions[i].label,
          "The suggestion at " + i + "th index is correct.");
-      is(actualSuggestions[i].count, suggestions[i].count || 1,
-         "The count for suggestion at " + i + "th index is correct.");
     }
   }
 });
 
 function formatSuggestions(suggestions) {
   return "[" + suggestions
-                .map(s => "'" + s.label + "' (" + (s.count || 1) + ")")
+                .map(s => "'" + s.label + "'")
                 .join(", ") + "]";
 }
diff --git a/devtools/client/inspector/test/browser_inspector_search-03.js b/devtools/client/inspector/test/browser_inspector_search-03.js
--- a/devtools/client/inspector/test/browser_inspector_search-03.js
+++ b/devtools/client/inspector/test/browser_inspector_search-03.js
@@ -11,24 +11,24 @@ const TEST_URL = TEST_URL_ROOT + "doc_in
 // An array of (key, suggestions) pairs where key is a key to press and
 // suggestions is an array of suggestions that should be shown in the popup.
 // Suggestion is an object with label of the entry and optional count
 // (defaults to 1)
 var TEST_DATA = [
   {
     key: "d",
     suggestions: [
-      {label: "div", count: 2},
-      {label: "#d1", count: 1},
-      {label: "#d2", count: 1}
+      {label: "div"},
+      {label: "#d1"},
+      {label: "#d2"}
     ]
   },
   {
     key: "i",
-    suggestions: [{label: "div", count: 2}]
+    suggestions: [{label: "div"}]
   },
   {
     key: "v",
     suggestions: []
   },
   {
     key: ".",
     suggestions: [{label: "div.c1"}]
@@ -45,52 +45,52 @@ var TEST_DATA = [
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: "VK_BACK_SPACE",
-    suggestions: [{label: "div", count: 2}]
+    suggestions: [{label: "div"}]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: "div", count: 2},
-      {label: "#d1", count: 1},
-      {label: "#d2", count: 1}
+      {label: "div"},
+      {label: "#d1"},
+      {label: "#d2"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: ".",
     suggestions: [
-      {label: ".c1", count: 3},
+      {label: ".c1"},
       {label: ".c2"}
     ]
   },
   {
     key: "c",
     suggestions: [
-      {label: ".c1", count: 3},
+      {label: ".c1"},
       {label: ".c2"}
     ]
   },
   {
     key: "2",
     suggestions: []
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: ".c1", count: 3},
+      {label: ".c1"},
       {label: ".c2"}
     ]
   },
   {
     key: "1",
     suggestions: []
   },
   {
@@ -103,24 +103,24 @@ var TEST_DATA = [
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: ".c1", count: 3},
+      {label: ".c1"},
       {label: ".c2"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: ".c1", count: 3},
+      {label: ".c1"},
       {label: ".c2"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
@@ -184,19 +184,17 @@ add_task(function* () {
     let actualSuggestions = popup.getItems().reverse();
 
     is(popup.isOpen ? actualSuggestions.length: 0, suggestions.length,
        "There are expected number of suggestions.");
 
     for (let i = 0; i < suggestions.length; i++) {
       is(actualSuggestions[i].label, suggestions[i].label,
          "The suggestion at " + i + "th index is correct.");
-      is(actualSuggestions[i].count, suggestions[i].count || 1,
-         "The count for suggestion at " + i + "th index is correct.");
     }
   }
 });
 
 function formatSuggestions(suggestions) {
   return "[" + suggestions
-                .map(s => "'" + s.label + "' (" + (s.count || 1) + ")")
+                .map(s => "'" + s.label + "'")
                 .join(", ") + "]";
 }
diff --git a/devtools/client/inspector/test/browser_inspector_search-04.js b/devtools/client/inspector/test/browser_inspector_search-04.js
--- a/devtools/client/inspector/test/browser_inspector_search-04.js
+++ b/devtools/client/inspector/test/browser_inspector_search-04.js
@@ -14,67 +14,67 @@ const TEST_URL = "data:text/html;charset
 // An array of (key, suggestions) pairs where key is a key to press and
 // suggestions is an array of suggestions that should be shown in the popup.
 // Suggestion is an object with label of the entry and optional count
 // (defaults to 1)
 var TEST_DATA = [
   {
     key: "d",
     suggestions: [
-      {label: "div", count: 5},
-      {label: "#d1", count: 2},
-      {label: "#d2", count: 2}
+      {label: "div"},
+      {label: "#d1"},
+      {label: "#d2"}
     ]
   },
   {
     key: "i",
-    suggestions: [{label: "div", count: 5}]
+    suggestions: [{label: "div"}]
   },
   {
     key: "v",
     suggestions: []
   },
   {
     key: "VK_BACK_SPACE",
-    suggestions: [{label: "div", count: 5}]
+    suggestions: [{label: "div"}]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: [
-      {label: "div", count: 5},
-      {label: "#d1", count: 2},
-      {label: "#d2", count: 2}
+      {label: "div"},
+      {label: "#d1"},
+      {label: "#d2"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: ".",
     suggestions: [
-      {label: ".c1", count: 7},
-      {label: ".c2", count: 3}
+      {label: ".c1"},
+      {label: ".c2"}
     ]
   },
   {
     key: "VK_BACK_SPACE",
     suggestions: []
   },
   {
     key: "#",
     suggestions: [
-      {label: "#b1", count: 2},
-      {label: "#d1", count: 2},
-      {label: "#d2", count: 2},
-      {label: "#p1", count: 2},
-      {label: "#p2", count: 2},
-      {label: "#p3", count: 2},
-      {label: "#s1", count: 2},
-      {label: "#s2", count: 2}
+      {label: "#b1"},
+      {label: "#d1"},
+      {label: "#d2"},
+      {label: "#p1"},
+      {label: "#p2"},
+      {label: "#p3"},
+      {label: "#s1"},
+      {label: "#s2"}
     ]
   },
 ];
 
 add_task(function* () {
   let {inspector} = yield openInspectorForURL(TEST_URL);
   let searchBox = inspector.searchBox;
   let popup = inspector.searchSuggestions.searchPopup;
@@ -95,19 +95,17 @@ add_task(function* () {
     let actualSuggestions = popup.getItems().reverse();
 
     is(popup.isOpen ? actualSuggestions.length: 0, suggestions.length,
        "There are expected number of suggestions.");
 
     for (let i = 0; i < suggestions.length; i++) {
       is(actualSuggestions[i].label, suggestions[i].label,
          "The suggestion at " + i + "th index is correct.");
-      is(actualSuggestions[i].count, suggestions[i].count || 1,
-         "The count for suggestion at " + i + "th index is correct.");
     }
   }
 });
 
 function formatSuggestions(suggestions) {
   return "[" + suggestions
-                .map(s => "'" + s.label + "' (" + (s.count || 1) + ")")
+                .map(s => "'" + s.label + "'")
                 .join(", ") + "]";
 }
diff --git a/devtools/client/locales/en-US/inspector.dtd b/devtools/client/locales/en-US/inspector.dtd
--- a/devtools/client/locales/en-US/inspector.dtd
+++ b/devtools/client/locales/en-US/inspector.dtd
@@ -108,19 +108,18 @@
 
 <!ENTITY inspector.selectButton.tooltip     "Select element with mouse">
 
 <!-- LOCALIZATION NOTE (inspectorSearchHTML.label2): This is the label shown as
      the placeholder in inspector search box -->
 <!ENTITY inspectorSearchHTML.label2          "Search with CSS Selectors">
 <!ENTITY inspectorSearchHTML.key            "F">
 
-<!-- LOCALIZATION NOTE (inspectorSearchHTML.label3): This is the label that will
-     be shown as the placeholder in the future, once the inspector search box
-     supports the full text HTML search in Bug 835896. -->
+<!-- LOCALIZATION NOTE (inspectorSearchHTML.label3): This is the label that is
+     shown as the placeholder for the markup view search in the inspector. -->
 <!ENTITY inspectorSearchHTML.label3 "Search HTML">
 
 <!-- LOCALIZATION NOTE (inspectorCopyImageDataUri.label): This is the label
      shown in the inspector contextual-menu for the item that lets users copy
      the URL embedding the image data encoded in Base 64 (what we name
      here Image Data URL). For more information:
      https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs -->
 <!ENTITY inspectorCopyImageDataUri.label       "Copy Image Data-URL">
diff --git a/devtools/client/themes/inspector.css b/devtools/client/themes/inspector.css
--- a/devtools/client/themes/inspector.css
+++ b/devtools/client/themes/inspector.css
@@ -10,16 +10,20 @@
 }
 
 #inspector-toolbar:-moz-locale-dir(rtl) {
   padding-left: 4px;
 }
 
 %endif
 
+#inspector-searchlabel {
+  overflow: hidden;
+}
+
 #inspector-searchbox {
   transition-property: max-width, -moz-padding-end, -moz-padding-start;
   transition-duration: 250ms;
   transition-timing-function: ease;
 }
 
 #inspector-searchbox:not([focused]):not([filled]) > .textbox-input-box {
   overflow: hidden;
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -56,16 +56,17 @@ const protocol = require("devtools/serve
 const {Arg, Option, method, RetVal, types} = protocol;
 const {LongStringActor, ShortLongString} = require("devtools/server/actors/string");
 const promise = require("promise");
 const {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 const object = require("sdk/util/object");
 const events = require("sdk/event/core");
 const {Unknown} = require("sdk/platform/xpcom");
 const {Class} = require("sdk/core/heritage");
+const {WalkerSearch} = require("devtools/server/actors/utils/walker-search");
 const {PageStyleActor, getFontPreviewData} = require("devtools/server/actors/styles");
 const {
   HighlighterActor,
   CustomHighlighterActor,
   isTypeRegistered,
 } = require("devtools/server/actors/highlighters");
 const {
   isAnonymous,
@@ -1117,16 +1118,23 @@ types.addDictType("disconnectedNodeArray
   nodes: "array:domnode",
 
   // Nodes that are needed to connect those nodes to the root.
   newParents: "array:domnode"
 });
 
 types.addDictType("dommutation", {});
 
+types.addDictType("searchresult", {
+  list: "domnodelist",
+  // Right now there is isn't anything required for metadata,
+  // but it's json so it can be extended with extra data.
+  metadata: "array:json"
+});
+
 /**
  * Server side of a node list as returned by querySelectorAll()
  */
 var NodeListActor = exports.NodeListActor = protocol.ActorClass({
   typeName: "domnodelist",
 
   initialize: function(walker, nodeList) {
     protocol.Actor.prototype.initialize.call(this);
@@ -1294,16 +1302,18 @@ var WalkerActor = protocol.ActorClass({
     this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
     this.showAllAnonymousContent = options.showAllAnonymousContent;
 
+    this.walkerSearch = new WalkerSearch(this);
+
     // Nodes which have been removed from the client's known
     // ownership tree are considered "orphaned", and stored in
     // this set.
     this._orphaned = new Set();
 
     // The client can tell the walker that it is interested in a node
     // even when it is orphaned with the `retainNode` method.  This
     // list contains orphaned nodes that were so retained.
@@ -1329,17 +1339,23 @@ var WalkerActor = protocol.ActorClass({
   form: function() {
     return {
       actor: this.actorID,
       root: this.rootNode.form(),
       traits: {
         // FF42+ Inspector starts managing the Walker, while the inspector also
         // starts cleaning itself up automatically on client disconnection.
         // So that there is no need to manually release the walker anymore.
-        autoReleased: true
+        autoReleased: true,
+        // XXX: It seems silly that we need to tell the front which capabilities
+        // its actor has in this way when the target can use actorHasMethod.  If
+        // this was ported to the protocol (Bug 1157048) we could call that inside
+        // of custom front methods and not need to do traits for this.
+        multiFrameQuerySelectorAll: true,
+        textSearch: true,
       }
     }
   },
 
   toString: function() {
     return "[WalkerActor " + this.actorID + "]";
   },
 
@@ -1371,16 +1387,17 @@ var WalkerActor = protocol.ActorClass({
       this._refMap = null;
 
       events.off(this.tabActor, "will-navigate", this.onFrameUnload);
       events.off(this.tabActor, "navigate", this.onFrameLoad);
 
       this.onFrameLoad = null;
       this.onFrameUnload = null;
 
+      this.walkerSearch.destroy();
       this.reflowObserver.off("reflows", this._onReflows);
       this.reflowObserver = null;
       this._onReflows = null;
       releaseLayoutChangesObserver(this.tabActor);
 
       this.onMutations = null;
 
       this.tabActor = null;
@@ -2044,16 +2061,43 @@ var WalkerActor = protocol.ActorClass({
       selector: Arg(0)
     },
     response: {
       list: RetVal("domnodelist")
     }
   }),
 
   /**
+   * Search the document for a given string.
+   * Results will be searched with the walker-search module (searches through
+   * tag names, attribute names and values, and text contents).
+   *
+   * @returns {searchresult}
+   *            - {NodeList} list
+   *            - {Array<Object>} metadata. Extra information with indices that
+   *                              match up with node list.
+   */
+  search: method(function(query) {
+    let results = this.walkerSearch.search(query);
+    let nodeList = new NodeListActor(this, results.map(r => r.node));
+
+    return {
+      list: nodeList,
+      metadata: []
+    }
+  }, {
+    request: {
+      query: Arg(0),
+    },
+    response: {
+      list: RetVal("searchresult"),
+    }
+  }),
+
+  /**
    * Returns a list of matching results for CSS selector autocompletion.
    *
    * @param string query
    *        The selector query being completed
    * @param string completing
    *        The exact token being completed out of the query
    * @param string selectorState
    *        One of "pseudo", "id", "tag", "class", "null"
@@ -2833,16 +2877,21 @@ var WalkerActor = protocol.ActorClass({
 
   /**
    * Handles mutations from the DOM mutation observer API.
    *
    * @param array[MutationRecord] mutations
    *    See https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationRecord
    */
   onMutations: function(mutations) {
+    // Notify any observers that want *all* mutations (even on nodes that aren't
+    // referenced).  This is not sent over the protocol so can only be used by
+    // scripts running in the server process.
+    events.emit(this, "any-mutation");
+
     for (let change of mutations) {
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
       let type = change.type;
       let mutation = {
@@ -3310,16 +3359,85 @@ var WalkerFront = exports.WalkerFront = 
   getNodeFromActor: protocol.custom(function(actorID, path) {
     return this._getNodeFromActor(actorID, path).then(response => {
       return response ? response.node : null;
     });
   }, {
     impl: "_getNodeFromActor"
   }),
 
+  /*
+   * Incrementally search the document for a given string.
+   * For modern servers, results will be searched with using the WalkerActor
+   * `search` function (includes tag names, attributes, and text contents).
+   * Only 1 result is sent back, and calling the method again with the same
+   * query will send the next result. When there are no more results to be sent
+   * back, null is sent.
+   * @param {String} query
+   * @param {Object} options
+   *    - "reverse": search backwards
+   *    - "selectorOnly": treat input as a selector string (don't search text
+   *                      tags, attributes, etc)
+   */
+  search: protocol.custom(Task.async(function*(query, options = { }) {
+    let nodeList;
+    let searchType;
+    let searchData = this.searchData = this.searchData || { };
+    let selectorOnly = !!options.selectorOnly;
+
+    // Backwards compat.  Use selector only search if the new
+    // search functionality isn't implemented, or if the caller (tests)
+    // want it.
+    if (selectorOnly || !this.traits.textSearch) {
+      searchType = "selector";
+      if (this.traits.multiFrameQuerySelectorAll) {
+        nodeList = yield this.multiFrameQuerySelectorAll(query);
+      } else {
+        nodeList = yield this.querySelectorAll(this.rootNode, query);
+      }
+    } else {
+      searchType = "search";
+      let result = yield this._search(query, options);
+      nodeList = result.list;
+    }
+
+    // If this is a new search, start at the beginning.
+    if (searchData.query !== query ||
+        searchData.selectorOnly !== selectorOnly) {
+      searchData.selectorOnly = selectorOnly;
+      searchData.query = query;
+      searchData.index = -1;
+    }
+
+    if (!nodeList.length) {
+      return null;
+    }
+
+    // Move search result cursor and cycle if necessary.
+    searchData.index = options.reverse ? searchData.index - 1 :
+                                         searchData.index + 1;
+    if (searchData.index >= nodeList.length) {
+      searchData.index = 0;
+    }
+    if (searchData.index < 0) {
+      searchData.index = nodeList.length - 1;
+    }
+
+    // Send back the single node, along with any relevant search data
+    let node = yield nodeList.item(searchData.index);
+    return {
+      type: searchType,
+      node: node,
+      resultsLength: nodeList.length,
+      resultsIndex: searchData.index,
+    };
+  }), {
+    impl: "_search"
+  }),
+
   _releaseFront: function(node, force) {
     if (node.retained && !force) {
       node.reparent(null);
       this._retainedOrphans.add(node);
       return;
     }
 
     if (node.retained) {
@@ -3870,33 +3988,49 @@ DocumentWalker.prototype = {
   set currentNode(aVal) {
     this.walker.currentNode = aVal;
   },
 
   parentNode: function() {
     return this.walker.parentNode();
   },
 
+  nextNode: function() {
+    let node = this.walker.currentNode;
+    if (!node) {
+      return null;
+    }
+
+    let nextNode = this.walker.nextNode();
+    while (nextNode && this.filter(nextNode) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+      nextNode = this.walker.nextNode();
+    }
+
+    return nextNode;
+  },
+
   firstChild: function() {
     let node = this.walker.currentNode;
-    if (!node)
+    if (!node) {
       return null;
+    }
 
     let firstChild = this.walker.firstChild();
     while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       firstChild = this.walker.nextSibling();
     }
 
     return firstChild;
   },
 
   lastChild: function() {
     let node = this.walker.currentNode;
-    if (!node)
+    if (!node) {
       return null;
+    }
 
     let lastChild = this.walker.lastChild();
     while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       lastChild = this.walker.previousSibling();
     }
 
     return lastChild;
   },
diff --git a/devtools/server/actors/utils/moz.build b/devtools/server/actors/utils/moz.build
--- a/devtools/server/actors/utils/moz.build
+++ b/devtools/server/actors/utils/moz.build
@@ -7,10 +7,11 @@
 DevToolsModules(
     'actor-registry-utils.js',
     'audionodes.json',
     'automation-timeline.js',
     'make-debugger.js',
     'map-uri-to-addon-id.js',
     'ScriptStore.js',
     'stack.js',
-    'TabSources.js'
+    'TabSources.js',
+    'walker-search.js'
 )
diff --git a/devtools/server/actors/utils/walker-search.js b/devtools/server/actors/utils/walker-search.js
new file mode 100644
--- /dev/null
+++ b/devtools/server/actors/utils/walker-search.js
@@ -0,0 +1,267 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+/**
+ * The walker-search module provides a simple API to index and search strings
+ * and elements inside a given document.
+ * It indexes tag names, attribute names and values, and text contents.
+ * It provides a simple search function that returns a list of nodes that
+ * matched.
+ */
+
+const {Ci, Cu} = require("chrome");
+
+/**
+ * The WalkerIndex class indexes the document (and all subdocs) from
+ * a given walker.
+ *
+ * It is only indexed the first time the data is accessed and will be
+ * re-indexed if a mutation happens between requests.
+ *
+ * @param {Walker} walker The walker to be indexed
+ */
+function WalkerIndex(walker) {
+  this.walker = walker;
+  this.clearIndex = this.clearIndex.bind(this);
+
+  // Kill the index when mutations occur, the next data get will re-index.
+  this.walker.on("any-mutation", this.clearIndex);
+}
+
+WalkerIndex.prototype = {
+  /**
+   * Destroy this instance, releasing all data and references
+   */
+  destroy: function() {
+    this.walker.off("any-mutation", this.clearIndex);
+  },
+
+  clearIndex: function() {
+    if (!this.currentlyIndexing) {
+      this._data = null;
+    }
+  },
+
+  get doc() {
+    return this.walker.rootDoc;
+  },
+
+  /**
+   * Get the indexed data
+   * This getter also indexes if it hasn't been done yet or if the state is
+   * dirty
+   *
+   * @returns Map<String, Array<{type:String, node:DOMNode}>>
+   *          A Map keyed on the searchable value, containing an array with
+   *          objects containing the 'type' (one of ALL_RESULTS_TYPES), and
+   *          the DOM Node.
+   */
+  get data() {
+    if (!this._data) {
+      this._data = new Map();
+      this.index();
+    }
+
+    return this._data;
+  },
+
+  _addToIndex: function(type, node, value) {
+    // Add an entry for this value if there isn't one
+    let entry = this._data.get(value);
+    if (!entry) {
+      this._data.set(value, []);
+    }
+
+    // Add the type/node to the list
+    this._data.get(value).push({
+      type: type,
+      node: node
+    });
+  },
+
+  index: function() {
+    // Handle case where iterating nextNode() with the deepTreeWalker triggers
+    // a mutation (Bug XXX)
+    this.currentlyIndexing = true;
+
+    let documentWalker = this.walker.getDocumentWalker(this.doc);
+    while (documentWalker.nextNode()) {
+      let node = documentWalker.currentNode;
+
+      if (node.nodeType === 1) {
+        // For each element node, we get the tagname and all attributes names
+        // and values
+        let localName = node.localName;
+        if (localName === "_moz_generated_content_before") {
+          this._addToIndex("tag", node, "::before");
+          this._addToIndex("text", node, node.textContent.trim());
+        } else if (localName === "_moz_generated_content_after") {
+          this._addToIndex("tag", node, "::after");
+          this._addToIndex("text", node, node.textContent.trim());
+        } else {
+          this._addToIndex("tag", node, node.localName);
+        }
+
+        for (let {name, value} of node.attributes) {
+          this._addToIndex("attributeName", node, name);
+          this._addToIndex("attributeValue", node, value);
+        }
+      } else if (node.textContent && node.textContent.trim().length) {
+        // For comments and text nodes, we get the text
+        this._addToIndex("text", node, node.textContent.trim());
+      }
+    }
+
+    this.currentlyIndexing = false;
+  }
+};
+
+exports.WalkerIndex = WalkerIndex;
+
+/**
+ * The WalkerSearch class provides a way to search an indexed document as well
+ * as find elements that match a given css selector.
+ *
+ * Usage example:
+ * let s = new WalkerSearch(doc);
+ * let res = s.search("lang", index);
+ * for (let {matched, results} of res) {
+ *   for (let {node, type} of results) {
+ *     console.log("The query matched a node's " + type);
+ *     console.log("Node that matched", node);
+ *    }
+ * }
+ * s.destroy();
+ *
+ * @param {Walker} the walker to be searched
+ */
+function WalkerSearch(walker) {
+  this.walker = walker;
+  this.index = new WalkerIndex(this.walker);
+}
+
+WalkerSearch.prototype = {
+  destroy: function() {
+    this.index.destroy();
+    this.walker = null;
+  },
+
+  _addResult: function(node, type, results) {
+    if (!results.has(node)) {
+      results.set(node, []);
+    }
+
+    let matches = results.get(node);
+
+    // Do not add if the exact same result is already in the list
+    let isKnown = false;
+    for (let match of matches) {
+      if (match.type === type) {
+        isKnown = true;
+        break;
+      }
+    }
+
+    if (!isKnown) {
+      matches.push({type});
+    }
+  },
+
+  _searchIndex: function(query, options, results) {
+    for (let [matched, res] of this.index.data) {
+      if (!options.searchMethod(query, matched)) {
+        continue;
+      }
+
+      // Add any relevant results (skipping non-requested options).
+      res.filter(entry => {
+        return options.types.indexOf(entry.type) !== -1;
+      }).forEach(({node, type}) => {
+        this._addResult(node, type, results);
+      });
+    }
+  },
+
+  _searchSelectors: function(query, options, results) {
+    // If the query is just one "word", no need to search because _searchIndex
+    // will lead the same results since it has access to tagnames anyway
+    let isSelector = query && query.match(/[ >~.#\[\]]/);
+    if (options.types.indexOf("selector") === -1 || !isSelector) {
+      return;
+    }
+
+    let nodes = this.walker._multiFrameQuerySelectorAll(query);
+    for (let node of nodes) {
+      this._addResult(node, "selector", results);
+    }
+  },
+
+  /**
+   * Search the document
+   * @param {String} query What to search for
+   * @param {Object} options The following options are accepted:
+   * - searchMethod {String} one of WalkerSearch.SEARCH_METHOD_*
+   *   defaults to WalkerSearch.SEARCH_METHOD_CONTAINS (does not apply to
+   *   selector search type)
+   * - types {Array} a list of things to search for (tag, text, attributes, etc)
+   *   defaults to WalkerSearch.ALL_RESULTS_TYPES
+   * @return {Array} An array is returned with each item being an object like:
+   * {
+   *   node: <the dom node that matched>,
+   *   type: <the type of match: one of WalkerSearch.ALL_RESULTS_TYPES>
+   * }
+   */
+  search: function(query, options={}) {
+    options.searchMethod = options.searchMethod || WalkerSearch.SEARCH_METHOD_CONTAINS;
+    options.types = options.types || WalkerSearch.ALL_RESULTS_TYPES;
+
+    // Empty strings will return no results, as will non-string input
+    if (typeof query !== "string") {
+      query = "";
+    }
+
+    // Store results in a map indexed by nodes to avoid duplicate results
+    let results = new Map();
+
+    // Search through the indexed data
+    this._searchIndex(query, options, results);
+
+    // Search with querySelectorAll
+    this._searchSelectors(query, options, results);
+
+    // Concatenate all results into an Array to return
+    let resultList = [];
+    for (let [node, matches] of results) {
+      for (let {type} of matches) {
+        resultList.push({
+          node: node,
+          type: type,
+        });
+
+        // For now, just do one result per node since the frontend
+        // doesn't have a way to highlight each result individually
+        // yet.
+        break;
+      }
+    }
+
+    // Sort the resulting nodes by order of appearance in the DOM
+    resultList.sort((a,b) => {
+      return a.node.compareDocumentPosition(b.node) & 4 ? -1 : 1;
+    });
+
+    return resultList;
+  }
+};
+
+WalkerSearch.SEARCH_METHOD_CONTAINS = (query, candidate) => {
+  return query && candidate.toLowerCase().indexOf(query.toLowerCase()) !== -1;
+};
+
+WalkerSearch.ALL_RESULTS_TYPES = ["tag", "text", "attributeName",
+                                  "attributeValue", "selector"];
+
+exports.WalkerSearch = WalkerSearch;
diff --git a/devtools/server/tests/mochitest/chrome.ini b/devtools/server/tests/mochitest/chrome.ini
--- a/devtools/server/tests/mochitest/chrome.ini
+++ b/devtools/server/tests/mochitest/chrome.ini
@@ -5,16 +5,17 @@ support-files =
   Debugger.Source.prototype.element.js
   Debugger.Source.prototype.element-2.js
   Debugger.Source.prototype.element.html
   director-helpers.js
   hello-actor.js
   inspector_getImageData.html
   inspector-delay-image-response.sjs
   inspector-helpers.js
+  inspector-search-data.html
   inspector-styles-data.css
   inspector-styles-data.html
   inspector-traversal-data.html
   large-image.jpg
   memory-helpers.js
   memprof-helpers.js
   nonchrome_unsafeDereference.html
   small-image.gif
@@ -72,16 +73,18 @@ skip-if = buildapp == 'mulet'
 [test_inspector-mutations-frameload.html]
 [test_inspector-mutations-value.html]
 [test_inspector-pseudoclass-lock.html]
 [test_inspector-release.html]
 [test_inspector-reload.html]
 [test_inspector-remove.html]
 [test_inspector-resolve-url.html]
 [test_inspector-retain.html]
+[test_inspector-search.html]
+[test_inspector-search-front.html]
 [test_inspector-scroll-into-view.html]
 [test_inspector-traversal.html]
 [test_makeGlobalObjectReference.html]
 [test_memory.html]
 [test_memory_allocations_01.html]
 [test_memory_allocations_02.html]
 [test_memory_allocations_03.html]
 [test_memory_allocations_04.html]
diff --git a/devtools/server/tests/mochitest/inspector-search-data.html b/devtools/server/tests/mochitest/inspector-search-data.html
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/mochitest/inspector-search-data.html
@@ -0,0 +1,52 @@
+<html>
+<head>
+  <meta charset="UTF-8">
+  <title>Inspector Search Test Data</title>
+  <style>
+    #pseudo {
+      display: block;
+      margin: 0;
+    }
+    #pseudo:before {
+      content: "before element";
+    }
+    #pseudo:after {
+      content: "after element";
+    }
+  </style>
+  <script type="text/javascript">
+    window.onload = function() {
+      window.opener.postMessage('ready', '*');
+    };
+  </script>
+</head>
+</body>
+  <!-- A comment
+       spread across multiple lines -->
+
+  <img width="100" height="100" src="large-image.jpg" />
+
+  <h1 id="pseudo">Heading 1</h1>
+  <p>A p tag with the text 'h1' inside of it.
+    <strong>A strong h1 result</strong>
+  </p>
+
+  <div id="arrows" northwest="↖" northeast="↗" southeast="↘" southwest="↙">
+    Unicode arrows
+  </div>
+
+  <h2>Heading 2</h2>
+  <h2>Heading 2</h2>
+  <h2>Heading 2</h2>
+
+  <h3>Heading 3</h3>
+  <h3>Heading 3</h3>
+  <h3>Heading 3</h3>
+
+  <h4>Heading 4</h4>
+  <h4>Heading 4</h4>
+  <h4>Heading 4</h4>
+
+  <div class="💩" id="💩" 💩="💩"></div>
+</body>
+</html>
\ No newline at end of file
diff --git a/devtools/server/tests/mochitest/test_inspector-search-front.html b/devtools/server/tests/mochitest/test_inspector-search-front.html
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/mochitest/test_inspector-search-front.html
@@ -0,0 +1,220 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=835896
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 835896</title>
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+  <script type="application/javascript;version=1.8" src="inspector-helpers.js"></script>
+  <script type="application/javascript;version=1.8">
+window.onload = function() {
+  const Cu = Components.utils;
+  Cu.import("resource://gre/modules/devtools/Loader.jsm");
+  const {Promise: promise} =
+    Cu.import("resource://gre/modules/Promise.jsm", {});
+  const {InspectorFront} =
+    devtools.require("devtools/server/actors/inspector");
+  const {console} =
+    Cu.import("resource://gre/modules/devtools/shared/Console.jsm", {});
+
+  SimpleTest.waitForExplicitFinish();
+
+  let walkerFront = null;
+  let inspectee = null;
+  let inspector = null;
+
+  // WalkerFront specific tests.  These aren't to excercise search
+  // edge cases so much as to test the state the Front maintains between
+  // searches.
+  // See also test_inspector-search.html
+
+  addAsyncTest(function* setup() {
+    info ("Setting up inspector and walker actors.");
+
+    let url = document.getElementById("inspectorContent").href;
+
+    yield new Promise(resolve => {
+      attachURL(url, function(err, client, tab, doc) {
+        inspectee = doc;
+        inspector = InspectorFront(client, tab);
+        resolve();
+      });
+    });
+
+    walkerFront = yield inspector.getWalker();
+    ok(walkerFront, "getWalker() should return an actor.");
+
+    runNextTest();
+  });
+
+  addAsyncTest(function* testWalkerFrontDefaults() {
+    info ("Testing search API using WalkerFront.");
+    let nodes = yield walkerFront.querySelectorAll(walkerFront.rootNode, "h2");
+    let fronts = yield nodes.items();
+
+    let frontResult = yield walkerFront.search("");
+    ok(!frontResult, "Null result on front when searching for ''");
+
+    let results = yield walkerFront.search("h2");
+    isDeeply(results, {
+      node: fronts[0],
+      type: "search",
+      resultsIndex: 0,
+      resultsLength: 3
+    }, "Default options work");
+
+    results = yield walkerFront.search("h2", { });
+    isDeeply(results, {
+      node: fronts[1],
+      type: "search",
+      resultsIndex: 1,
+      resultsLength: 3
+    }, "Search works with empty options");
+
+    // Clear search data to remove result state on the front
+    yield walkerFront.search("");
+    runNextTest();
+  });
+
+  addAsyncTest(function* testMultipleSearches() {
+    info ("Testing search API using WalkerFront (reverse=false)");
+    let nodes = yield walkerFront.querySelectorAll(walkerFront.rootNode, "h2");
+    let fronts = yield nodes.items();
+
+    let results = yield walkerFront.search("h2");
+    isDeeply(results, {
+      node: fronts[0],
+      type: "search",
+      resultsIndex: 0,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=false)");
+
+    results = yield walkerFront.search("h2");
+    isDeeply(results, {
+      node: fronts[1],
+      type: "search",
+      resultsIndex: 1,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=false)");
+
+    results = yield walkerFront.search("h2");
+    isDeeply(results, {
+      node: fronts[2],
+      type: "search",
+      resultsIndex: 2,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=false)");
+
+    results = yield walkerFront.search("h2");
+    isDeeply(results, {
+      node: fronts[0],
+      type: "search",
+      resultsIndex: 0,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=false)");
+
+    // Clear search data to remove result state on the front
+    yield walkerFront.search("");
+    runNextTest();
+  });
+
+  addAsyncTest(function* testMultipleSearchesReverse() {
+    info ("Testing search API using WalkerFront (reverse=true)");
+    let nodes = yield walkerFront.querySelectorAll(walkerFront.rootNode, "h2");
+    let fronts = yield nodes.items();
+
+    let results = yield walkerFront.search("h2", {reverse: true});
+    isDeeply(results, {
+      node: fronts[2],
+      type: "search",
+      resultsIndex: 2,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=true)");
+
+    results = yield walkerFront.search("h2", {reverse: true});
+    isDeeply(results, {
+      node: fronts[1],
+      type: "search",
+      resultsIndex: 1,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=true)");
+
+    results = yield walkerFront.search("h2", {reverse: true});
+    isDeeply(results, {
+      node: fronts[0],
+      type: "search",
+      resultsIndex: 0,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=true)");
+
+    results = yield walkerFront.search("h2", {reverse: true});
+    isDeeply(results, {
+      node: fronts[2],
+      type: "search",
+      resultsIndex: 2,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=true)");
+
+    results = yield walkerFront.search("h2", {reverse: false});
+    isDeeply(results, {
+      node: fronts[0],
+      type: "search",
+      resultsIndex: 0,
+      resultsLength: 3
+    }, "Search works with multiple results (reverse=false)");
+
+    // Clear search data to remove result state on the front
+    yield walkerFront.search("");
+    runNextTest();
+  });
+
+
+  addAsyncTest(function* testBackwardsCompat() {
+    info ("Simulating a server that doesn't have the new search functionality.");
+    walkerFront.traits.textSearch = false;
+    let front = yield walkerFront.querySelector(walkerFront.rootNode, "h1");
+
+    let results = yield walkerFront.search("h1");
+    isDeeply(results, {
+      node: front,
+      type: "selector",
+      resultsIndex: 0,
+      resultsLength: 1
+    }, "Only querySelectorAll results being returned");
+
+    // Clear search data to remove result state on the front
+    yield walkerFront.search("");
+
+    // Reset the normal textSearch behavior
+    walkerFront.traits.textSearch = true;
+
+    results = yield walkerFront.search("h1");
+    isDeeply(results, {
+      node: front,
+      type: "search",
+      resultsIndex: 0,
+      resultsLength: 3
+    }, "Other results being included");
+
+    // Clear search data to remove result state on the front
+    yield walkerFront.search("");
+    runNextTest();
+  });
+
+  runNextTest();
+};
+  </script>
+</head>
+<body>
+<a id="inspectorContent" target="_blank" href="inspector-search-data.html">Test Document</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+</body>
+</html>
diff --git a/devtools/server/tests/mochitest/test_inspector-search.html b/devtools/server/tests/mochitest/test_inspector-search.html
new file mode 100644
--- /dev/null
+++ b/devtools/server/tests/mochitest/test_inspector-search.html
@@ -0,0 +1,300 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=835896
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 835896</title>
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css">
+  <script type="application/javascript;version=1.8" src="inspector-helpers.js"></script>
+  <script type="application/javascript;version=1.8">
+window.onload = function() {
+  const Cu = Components.utils;
+  Cu.import("resource://gre/modules/devtools/Loader.jsm");
+  const {Promise: promise} =
+    Cu.import("resource://gre/modules/Promise.jsm", {});
+  const {InspectorFront} =
+    devtools.require("devtools/server/actors/inspector");
+  const {WalkerSearch, WalkerIndex} =
+    devtools.require("devtools/server/actors/utils/walker-search");
+  const {console} =
+    Cu.import("resource://gre/modules/devtools/shared/Console.jsm", {});
+
+  SimpleTest.waitForExplicitFinish();
+
+  let walkerActor = null;
+  let walkerSearch = null;
+  let inspectee = null;
+  let inspector = null;
+
+  // WalkerSearch specific tests.  This is to make sure search results are
+  // coming back as expected.
+  // See also test_inspector-search-front.html.
+
+  addAsyncTest(function* setup() {
+    info ("Setting up inspector and walker actors.");
+
+    let url = document.getElementById("inspectorContent").href;
+
+    yield new Promise(resolve => {
+      attachURL(url, function(err, client, tab, doc) {
+        inspectee = doc;
+        inspector = InspectorFront(client, tab);
+        resolve();
+      });
+    });
+
+    let walkerFront = yield inspector.getWalker();
+    ok(walkerFront, "getWalker() should return an actor.");
+
+    let serverConnection = walkerFront.conn._transport._serverConnection;
+    walkerActor = serverConnection.getActor(walkerFront.actorID);
+    ok(walkerActor,
+      "Got a reference to the walker actor (" + walkerFront.actorID + ")");
+
+    walkerSearch = walkerActor.walkerSearch;
+
+    runNextTest();
+  });
+
+  addAsyncTest(function* testIndexExists() {
+    info ("Testing basic index APIs exist.");
+
+    let index = new WalkerIndex(walkerActor);
+    ok(index.data.size > 0, "public index is filled after getting");
+
+    index.clearIndex();
+    ok(!index._data, "private index is empty after clearing");
+    ok(index.data.size > 0, "public index is filled after getting");
+
+    index.destroy();
+    runNextTest();
+  });
+
+  addAsyncTest(function* testSearchExists() {
+    info ("Testing basic search APIs exist.");
+
+    ok(walkerSearch, "walker search exists on the WalkerActor");
+    ok(walkerSearch.search, "walker search has `search` method");
+    ok(walkerSearch.index, "walker search has `index` property");
+    is(walkerSearch.walker, walkerActor, "referencing the correct WalkerActor");
+
+    let search = new WalkerSearch(walkerActor);
+    ok(search, "a new search instance can be created");
+    ok(search.search, "new search instance has `search` method");
+    ok(search.index, "new search instance has `index` property");
+    isnot(search, walkerSearch, "new search instance differs from the WalkerActor's");
+
+    search.destroy();
+    runNextTest();
+  });
+
+  addAsyncTest(function* testEmptySearch() {
+    info ("Testing search with an empty query.");
+    results = walkerSearch.search("");
+    is(results.length, 0, "No results when searching for ''");
+
+    results = walkerSearch.search(null);
+    is(results.length, 0, "No results when searching for null");
+
+    results = walkerSearch.search(undefined);
+    is(results.length, 0, "No results when searching for undefined");
+
+    results = walkerSearch.search(10);
+    is(results.length, 0, "No results when searching for 10");
+
+    runNextTest();
+  });
+
+  addAsyncTest(function* testBasicSearchData() {
+    let testData = [
+    {
+      desc: "Search for tag with one result.",
+      search: "body",
+      expected: [
+        {node: inspectee.body, type: "tag"}
+      ]
+    },
+    {
+      desc: "Search for tag with multiple results",
+      search: "h2",
+      expected: [
+        {node: inspectee.querySelectorAll("h2")[0], type: "tag"},
+        {node: inspectee.querySelectorAll("h2")[1], type: "tag"},
+        {node: inspectee.querySelectorAll("h2")[2], type: "tag"},
+      ]
+    },
+    {
+      desc: "Search for selector with multiple results",
+      search: "body > h2",
+      expected: [
+        {node: inspectee.querySelectorAll("h2")[0], type: "selector"},
+        {node: inspectee.querySelectorAll("h2")[1], type: "selector"},
+        {node: inspectee.querySelectorAll("h2")[2], type: "selector"},
+      ]
+    },
+    {
+      desc: "Search for selector with multiple results",
+      search: ":root h2",
+      expected: [
+        {node: inspectee.querySelectorAll("h2")[0], type: "selector"},
+        {node: inspectee.querySelectorAll("h2")[1], type: "selector"},
+        {node: inspectee.querySelectorAll("h2")[2], type: "selector"},
+      ]
+    },
+    {
+      desc: "Search for selector with multiple results",
+      search: "* h2",
+      expected: [
+        {node: inspectee.querySelectorAll("h2")[0], type: "selector"},
+        {node: inspectee.querySelectorAll("h2")[1], type: "selector"},
+        {node: inspectee.querySelectorAll("h2")[2], type: "selector"},
+      ]
+    },
+    {
+      desc: "Search with multiple matches in a single tag expecting a single result",
+      search: "💩",
+      expected: [
+        {node: inspectee.getElementById("💩"), type: "attributeName"}
+      ]
+    },
+    {
+      desc: "Search that has tag and text results",
+      search: "h1",
+      expected: [
+        {node: inspectee.querySelector("h1"), type: "tag"},
+        {node: inspectee.querySelector("h1 + p").childNodes[0], type: "text"},
+        {node: inspectee.querySelector("h1 + p > strong").childNodes[0], type: "text"},
+      ]
+    },
+    ]
+
+    for (let {desc, search, expected} of testData) {
+      info("Running test: " + desc);
+      let results = walkerSearch.search(search);
+      isDeeply(results, expected,
+        "Search returns correct results with '" + search + "'");
+    }
+
+    runNextTest();
+  });
+
+  addAsyncTest(function* testPseudoElements() {
+    info ("Testing ::before and ::after element matching");
+
+    let beforeElt = new _documentWalker(inspectee.querySelector("#pseudo"),
+                                        inspectee.defaultView).firstChild();
+    let afterElt = new _documentWalker(inspectee.querySelector("#pseudo"),
+                                       inspectee.defaultView).lastChild();
+    let styleText = inspectee.querySelector("style").childNodes[0];
+
+    // ::before
+    let results = walkerSearch.search("::before");
+    isDeeply(results, [ {node: beforeElt, type: "tag"} ],
+             "Tag search works for pseudo element");
+
+    results = walkerSearch.search("_moz_generated_content_before");
+    is(results.length, 0, "No results for anon tag name");
+
+    results = walkerSearch.search("before element");
+    isDeeply(results, [
+      {node: styleText, type: "text"},
+      {node: beforeElt, type: "text"}
+    ], "Text search works for pseudo element");
+
+    // ::after
+    results = walkerSearch.search("::after");
+    isDeeply(results, [ {node: afterElt, type: "tag"} ],
+             "Tag search works for pseudo element");
+
+    results = walkerSearch.search("_moz_generated_content_after");
+    is(results.length, 0, "No results for anon tag name");
+
+    results = walkerSearch.search("after element");
+    isDeeply(results, [
+      {node: styleText, type: "text"},
+      {node: afterElt, type: "text"}
+    ], "Text search works for pseudo element");
+
+    runNextTest();
+  });
+
+  addAsyncTest(function* testSearchMutationChangeResults() {
+    info ("Testing search before and after a mutation.");
+    let expected = [
+      {node: inspectee.querySelectorAll("h3")[0], type: "tag"},
+      {node: inspectee.querySelectorAll("h3")[1], type: "tag"},
+      {node: inspectee.querySelectorAll("h3")[2], type: "tag"},
+    ];
+
+    let results = walkerSearch.search("h3");
+    isDeeply(results, expected, "Search works with tag results");
+
+    yield mutateDocumentAndWaitForMutation(() => {
+      expected[0].node.remove();
+    });
+
+    results = walkerSearch.search("h3");
+    isDeeply(results, [
+      expected[1],
+      expected[2]
+    ], "Results are updated after removal");
+
+    yield new Promise(resolve => {
+      info("Waiting for a mutation to happen");
+      let observer = new inspectee.defaultView.MutationObserver(() => {
+        resolve();
+      });
+      observer.observe(inspectee, {attributes: true, subtree: true});
+      inspectee.body.setAttribute("h3", "true");
+    });
+
+    results = walkerSearch.search("h3");
+    isDeeply(results, [
+      {node: inspectee.body, type: "attributeName"},
+      expected[1],
+      expected[2]
+    ], "Results are updated after addition");
+
+    yield new Promise(resolve => {
+      info("Waiting for a mutation to happen");
+      let observer = new inspectee.defaultView.MutationObserver(() => {
+        resolve();
+      });
+      observer.observe(inspectee, {attributes: true, childList: true, subtree: true});
+      inspectee.body.removeAttribute("h3");
+      expected[1].node.remove();
+      expected[2].node.remove();
+    });
+
+    results = walkerSearch.search("h3");
+    is(results.length, 0, "Results are updated after removal");
+
+    runNextTest();
+  });
+
+  runNextTest();
+
+  function mutateDocumentAndWaitForMutation(mutationFn) {
+    return new Promise(resolve => {
+      info("Listening to markup mutation on the inspectee");
+      let observer = new inspectee.defaultView.MutationObserver(resolve);
+      observer.observe(inspectee, {childList: true, subtree: true});
+      mutationFn();
+    });
+  }
+};
+  </script>
+</head>
+<body>
+<a id="inspectorContent" target="_blank" href="inspector-search-data.html">Test Document</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+</body>
+</html>
