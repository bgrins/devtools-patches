
# HG changeset patch
# User Andrew Swan <aswan@mozilla.com>
# Date 1560291861 25200
# Node ID c163881a80c9a032b40f7d965fad6a6850fcf8a4
# Parent  ffb971149fbbd52fdec1dca0c0c73ee73cb5cf44
Bug 1555060 Convert <tabs> to a custom element

Most of the work here is in the tab strip (#tabbrowser-tabs).
The current code is full of assumptions that the dom structure
looks like a <tabs> element with individual <tab> elements as
its immediate and only children.  Rather than try to preserve
that structure, this patch adds new properties on tabs and tab
elements (tabs.tabChildren and tab.container) to navigate the
logical <tabs>/<tab> relationships instead of using the dom
directly.

Differential Revision: https://phabricator.services.mozilla.com/D32855

diff --git a/accessible/xul/XULTabAccessible.cpp b/accessible/xul/XULTabAccessible.cpp
--- a/accessible/xul/XULTabAccessible.cpp
+++ b/accessible/xul/XULTabAccessible.cpp
@@ -85,16 +85,23 @@ uint64_t XULTabAccessible::NativeInterac
 Relation XULTabAccessible::RelationByType(RelationType aType) const {
   Relation rel = AccessibleWrap::RelationByType(aType);
   if (aType != RelationType::LABEL_FOR) return rel;
 
   // Expose 'LABEL_FOR' relation on tab accessible for tabpanel accessible.
   nsIContent* parent = mContent->GetParent();
   if (!parent) return rel;
 
+  // A <tab> inside <tabs is="tabbrowser-tabs" ...> has an <arrowscrollbox>
+  // inserted as its parent, go up one more level in that case to find
+  // the enclosing <tabs>.
+  if (!parent->NodeName().LowerCaseEqualsLiteral("tabs")) {
+    parent = parent->GetParent();
+  }
+
   nsCOMPtr<nsIDOMXULRelatedElement> tabsElm =
       parent->AsElement()->AsXULRelated();
   if (!tabsElm) return rel;
 
   RefPtr<mozilla::dom::Element> tabpanelElement;
   tabsElm->GetRelatedElement(GetNode(), getter_AddRefs(tabpanelElement));
   if (!tabpanelElement) return rel;
 
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -121,20 +121,16 @@ panelview[mainview] > .panel-header {
   position: absolute;
 }
 
 .panel-viewstack {
   overflow: visible;
   transition: height var(--panelui-subview-transition-duration);
 }
 
-#tabbrowser-tabs {
-  -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-tabs");
-}
-
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   #tabbrowser-tabs {
     /* Without this, the tabs container width extends beyond the window width */
     width: 0;
   }
   .tab-stack {
     /* Without this, pinned tabs get a bit too tall when the tabstrip overflows. */
     vertical-align: top;
@@ -198,23 +194,23 @@ panelview[mainview] > .panel-header {
 %ifdef NIGHTLY_BUILD
 @supports -moz-bool-pref("browser.tabs.hideThrobber") {
   .tab-throbber {
     display: none !important;
   }
 }
 %endif
 
-#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-tab[pinned] {
+#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[pinned] {
   position: fixed !important;
   display: block; /* position:fixed already does this (bug 579776), but let's be explicit */
 }
 
-#tabbrowser-tabs[movingtab] > .tabbrowser-tab[selected],
-#tabbrowser-tabs[movingtab] > .tabbrowser-tab[multiselected] {
+#tabbrowser-tabs[movingtab] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[selected],
+#tabbrowser-tabs[movingtab] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[multiselected] {
   position: relative;
   z-index: 2;
   pointer-events: none; /* avoid blocking dragover events on scroll buttons */
 }
 
 .tabbrowser-tab[tab-grouping],
 .tabbrowser-tab[tabdrop-samewindow],
 #tabbrowser-tabs[movingtab] > .tabbrowser-tab[fadein]:not([selected]):not([multiselected]) {
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -91,16 +91,17 @@
   }
   Services.scriptloader.loadSubScript("chrome://browser/content/browser-media.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/browser-pageActions.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/browser-plugins.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/browser-sidebar.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/browser-tabsintitlebar.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/tabbrowser.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/tabbrowser-tab.js", this);
+  Services.scriptloader.loadSubScript("chrome://browser/content/tabbrowser-tabs.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/search/autocomplete-popup.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/search/searchbar.js", this);
 
   window.onload = gBrowserInit.onLoad.bind(gBrowserInit);
   window.onunload = gBrowserInit.onUnload.bind(gBrowserInit);
   window.onclose = WindowIsClosing;
 
   window.addEventListener("MozBeforeInitialXULLayout",
@@ -719,16 +720,17 @@
                context="toolbar-context-menu"
                flex="1">
 
         <hbox class="titlebar-spacer" type="pre-tabs"/>
 
         <hbox flex="1" align="end" class="toolbar-items">
           <hbox id="TabsToolbar-customization-target" flex="1">
             <tabs id="tabbrowser-tabs"
+                  is="tabbrowser-tabs"
                   flex="1"
                   setfocus="false"
                   tooltip="tabbrowser-tab-tooltip"
                   stopwatchid="FX_TAB_CLICK_MS">
               <tab is="tabbrowser-tab" class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
             </tabs>
 
             <toolbarbutton id="new-tab-button"
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser-tabs.js
rename from browser/base/content/tabbrowser.xml
rename to browser/base/content/tabbrowser-tabs.js
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser-tabs.js
@@ -1,1915 +1,1846 @@
-<?xml version="1.0"?>
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* eslint-env mozilla/browser-window */
+
+"use strict";
 
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+// This is loaded into all browser.xul windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+class MozTabbrowserTabs extends MozElements.TabsBase {
+  constructor() {
+    super();
+
+    this.addEventListener("TabSelect", (event) => {
+      this._handleTabSelect();
+    });
 
-<bindings id="tabBrowserBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:xbl="http://www.mozilla.org/xbl">
-  <binding id="tabbrowser-tabs"
-           extends="chrome://global/content/bindings/tabbox.xml#tabs">
-    <content>
-      <xul:hbox class="tab-drop-indicator-box">
-        <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
-      </xul:hbox>
-      <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
-                          style="min-width: 1px;"
-                          clicktoscroll="true"
-                          class="tabbrowser-arrowscrollbox">
-<!--
- This is a hack to circumvent bug 472020, otherwise the tabs show up on the
- right of the newtab button.
--->
-        <children includes="tab"/>
-<!--
-  This is to ensure anything extensions put here will go before the newtab
-  button, necessary due to the previous hack.
--->
-        <children/>
-        <xul:toolbarbutton class="tabs-newtab-button toolbarbutton-1"
-                           anonid="tabs-newtab-button"
-                           command="cmd_newNavigatorTab"
-                           onclick="checkForMiddleClick(this, event);"
-                           />
-        <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
-                    style="width: 0;"/>
-      </xul:arrowscrollbox>
-    </content>
+    this.addEventListener("TabClose", (event) => {
+      this._hiddenSoundPlayingStatusChanged(event.target, { closed: true });
+    });
+
+    this.addEventListener("TabAttrModified", (event) => {
+      if (event.detail.changed.includes("soundplaying") && event.target.hidden) {
+        this._hiddenSoundPlayingStatusChanged(event.target);
+      }
+    });
 
-    <implementation implements="nsIObserver">
-      <constructor>
-        <![CDATA[
-          this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
-          this._hiddenSoundPlayingTabs = new Set();
+    this.addEventListener("TabHide", (event) => {
+      if (event.target.soundPlaying) {
+        this._hiddenSoundPlayingStatusChanged(event.target);
+      }
+    });
 
-          let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
-              "emptyPrivateTabTitle" : "emptyTabTitle";
-          this.emptyTabTitle = gTabBrowserBundle.GetStringFromName("tabs." + strId);
-
-          var tab = this.firstElementChild;
-          tab.label = this.emptyTabTitle;
+    this.addEventListener("TabShow", (event) => {
+      if (event.target.soundPlaying) {
+        this._hiddenSoundPlayingStatusChanged(event.target);
+      }
+    });
 
-          let newTabButton = document.getAnonymousElementByAttribute(
-            this, "anonid", "tabs-newtab-button");
-          newTabButton.setAttribute("tooltiptext", GetDynamicShortcutTooltipText("tabs-newtab-button"));
+    this.addEventListener("transitionend", (event) => {
+      if (event.propertyName != "max-width") {
+        return;
+      }
 
-          window.addEventListener("resize", this);
-
-          Services.prefs.addObserver("privacy.userContext", this);
-          this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
+      let tab = event.target ? event.target.closest("tab") : null;
 
-          XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
-            "browser.tabs.tabMinWidth", null,
-            (pref, prevValue, newValue) => this._tabMinWidth = newValue,
-            newValue => {
-              const LIMIT = 50;
-              return Math.max(newValue, LIMIT);
-            },
-          );
+      if (tab.getAttribute("fadein") == "true") {
+        if (tab._fullyOpen) {
+          this._updateCloseButtons();
+        } else {
+          this._handleNewTab(tab);
+        }
+      } else if (tab.closing) {
+        gBrowser._endRemoveTab(tab);
+      }
 
-          this._tabMinWidth = this._tabMinWidthPref;
-
-          XPCOMUtils.defineLazyPreferenceGetter(this, "_multiselectEnabledPref",
-            "browser.tabs.multiselect", null,
-            (pref, prevValue, newValue) => this._multiselectEnabled = newValue);
-          this._multiselectEnabled = this._multiselectEnabledPref;
-
-          this._setPositionalAttributes();
+      let evt = new CustomEvent("TabAnimationEnd", { bubbles: true });
+      tab.dispatchEvent(evt);
+    });
 
-          CustomizableUI.addListener(this);
-          this._updateNewTabVisibility();
-          this._initializeArrowScrollbox();
+    this.addEventListener("dblclick", (event) => {
+      // When the tabbar has an unified appearance with the titlebar
+      // and menubar, a double-click in it should have the same behavior
+      // as double-clicking the titlebar
+      if (TabsInTitlebar.enabled)
+        return;
 
-          XPCOMUtils.defineLazyPreferenceGetter(this, "_closeTabByDblclick",
-            "browser.tabs.closeTabByDblclick", false);
-
-          if (gMultiProcessBrowser) {
-            this.tabbox.tabpanels.setAttribute("async", "true");
-          }
-        ]]>
-      </constructor>
+      if (event.button != 0 ||
+          event.originalTarget.localName != "scrollbox")
+        return;
 
-      <destructor>
-        <![CDATA[
-          Services.prefs.removeObserver("privacy.userContext", this);
-
-          CustomizableUI.removeListener(this);
-        ]]>
-      </destructor>
+      if (!this._blockDblClick)
+        BrowserOpenTab();
 
-      <field name="tabbox" readonly="true">
-        document.getElementById("tabbrowser-tabbox");
-      </field>
+      event.preventDefault();
+    });
 
-      <field name="contextMenu" readonly="true">
-        document.getElementById("tabContextMenu");
-      </field>
+    this.addEventListener("click", (event) => {
+      if (event.button != 0) {
+        return;
+      }
 
-      <field name="arrowScrollbox">
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
-      </field>
-
-      <field name="_firstTab">null</field>
-      <field name="_lastTab">null</field>
-      <field name="_beforeSelectedTab">null</field>
-      <field name="_beforeHoveredTab">null</field>
-      <field name="_afterHoveredTab">null</field>
-      <field name="_hoveredTab">null</field>
-
-      <property name="_tabMinWidth">
-        <setter>
-          this.style.setProperty("--tab-min-width", val + "px");
-          return val;
-        </setter>
-      </property>
-
-      <property name="_multiselectEnabled">
-        <setter>
-          // Unlike boolean HTML attributes, the value of boolean ARIA attributes actually matters.
-          this.setAttribute("aria-multiselectable", !!val);
-          return val;
-        </setter>
-        <getter>
-          return this.getAttribute("aria-multiselectable") == "true";
-        </getter>
-      </property>
-
-      <method name="_initializeArrowScrollbox">
-        <body><![CDATA[
-          let arrowScrollbox = this.arrowScrollbox;
-          arrowScrollbox.addEventListener("underflow", event => {
-            // Ignore underflow events:
-            // - from nested scrollable elements
-            // - for vertical orientation
-            // - corresponding to an overflow event that we ignored
-            if (event.originalTarget != arrowScrollbox.scrollbox ||
-                event.detail == 0 ||
-                !this.hasAttribute("overflow")) {
-              return;
-            }
-
-            this.removeAttribute("overflow");
-
-            if (this._lastTabClosedByMouse) {
-              this._expandSpacerBy(this._scrollButtonWidth);
-            }
-
-            for (let tab of Array.from(gBrowser._removingTabs)) {
-              gBrowser.removeTab(tab);
-            }
-
-            this._positionPinnedTabs();
-          }, true);
+      /* Catches extra clicks meant for the in-tab close button.
+       * Placed here to avoid leaking (a temporary handler added from the
+       * in-tab close button binding would close over the tab and leak it
+       * until the handler itself was removed). (bug 897751)
+       *
+       * The only sequence in which a second click event (i.e. dblclik)
+       * can be dispatched on an in-tab close button is when it is shown
+       * after the first click (i.e. the first click event was dispatched
+       * on the tab). This happens when we show the close button only on
+       * the active tab. (bug 352021)
+       * The only sequence in which a third click event can be dispatched
+       * on an in-tab close button is when the tab was opened with a
+       * double click on the tabbar. (bug 378344)
+       * In both cases, it is most likely that the close button area has
+       * been accidentally clicked, therefore we do not close the tab.
+       *
+       * We don't want to ignore processing of more than one click event,
+       * though, since the user might actually be repeatedly clicking to
+       * close many tabs at once.
+       */
+      let target = event.originalTarget;
+      if (target.classList.contains("tab-close-button")) {
+        // We preemptively set this to allow the closing-multiple-tabs-
+        // in-a-row case.
+        if (this._blockDblClick) {
+          target._ignoredCloseButtonClicks = true;
+        } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {
+          target._ignoredCloseButtonClicks = true;
+          event.stopPropagation();
+          return;
+        } else {
+          // Reset the "ignored click" flag
+          target._ignoredCloseButtonClicks = false;
+        }
+      }
 
-          arrowScrollbox.addEventListener("overflow", event => {
-            // Ignore overflow events:
-            // - from nested scrollable elements
-            // - for vertical orientation
-            if (event.originalTarget != arrowScrollbox.scrollbox ||
-                event.detail == 0) {
-              return;
-            }
+      /* Protects from close-tab-button errant doubleclick:
+       * Since we're removing the event target, if the user
+       * double-clicks the button, the dblclick event will be dispatched
+       * with the tabbar as its event target (and explicit/originalTarget),
+       * which treats that as a mouse gesture for opening a new tab.
+       * In this context, we're manually blocking the dblclick event.
+       */
+      if (this._blockDblClick) {
+        if (!("_clickedTabBarOnce" in this)) {
+          this._clickedTabBarOnce = true;
+          return;
+        }
+        delete this._clickedTabBarOnce;
+        this._blockDblClick = false;
+      }
+    }, true);
 
-            this.setAttribute("overflow", "true");
-            this._positionPinnedTabs();
-            this._handleTabSelect(true);
-          });
-
-          // Override scrollbox.xml method, since our scrollbox's children are
-          // inherited from the scrollbox binding parent (this).
-          arrowScrollbox._getScrollableElements = () => {
-            return Array.prototype.filter.call(this.children, arrowScrollbox._canScrollToElement);
-          };
-          arrowScrollbox._canScrollToElement = tab => {
-            return !tab._pinnedUnscrollable && !tab.hidden;
-          };
-        ]]></body>
-      </method>
+    this.addEventListener("click", (event) => {
+      if (event.button != 1) {
+        return;
+      }
 
-      <method name="observe">
-        <parameter name="aSubject"/>
-        <parameter name="aTopic"/>
-        <parameter name="aData"/>
-        <body><![CDATA[
-          switch (aTopic) {
-            case "nsPref:changed":
-              // This is has to deal with changes in
-              // privacy.userContext.enabled and
-              // privacy.userContext.longPressBehavior.
-              let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled")
-                                        && !PrivateBrowsingUtils.isWindowPrivate(window);
-
-              // This pref won't change so often, so just recreate the menu.
-              let longPressBehavior = Services.prefs.getIntPref("privacy.userContext.longPressBehavior");
+      let tab = event.target ? event.target.closest("tab") : null;
+      if (tab) {
+        gBrowser.removeTab(tab, {
+          animate: true,
+          byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,
+        });
+      } else if (event.originalTarget.localName == "scrollbox") {
+        // The user middleclicked on the tabstrip. Check whether the click
+        // was dispatched on the open space of it.
+        let visibleTabs = this._getVisibleTabs();
+        let lastTab = visibleTabs[visibleTabs.length - 1];
+        let winUtils = window.windowUtils;
+        let endOfTab = winUtils.getBoundsWithoutFlushing(lastTab)[RTL_UI ? "left" : "right"];
+        if ((!RTL_UI && event.clientX > endOfTab) ||
+            (RTL_UI && event.clientX < endOfTab)) {
+              BrowserOpenTab();
+        }
+      } else {
+        return;
+      }
 
-              // If longPressBehavior pref is set to 0 (or any invalid value)
-              // long press menu is disabled.
-              if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
-                containersEnabled = false;
-              }
+      event.stopPropagation();
+    });
+
+    this.addEventListener("keydown", (event) => {
+      let { altKey, shiftKey } = event;
+      let [accel, nonAccel] = AppConstants.platform == "macosx" ? [event.metaKey, event.ctrlKey] : [event.ctrlKey, event.metaKey];
 
-              // There are separate "new tab" buttons for when the tab strip
-              // is overflowed and when it is not.  Attach the long click
-              // popup to both of them.
-              const newTab = document.getElementById("new-tab-button");
-              const newTab2 = document.getAnonymousElementByAttribute(this, "anonid", "tabs-newtab-button");
+      let keyComboForMove = accel && shiftKey && !altKey && !nonAccel;
+      let keyComboForFocus = accel && !shiftKey && !altKey && !nonAccel;
 
-              for (let parent of [newTab, newTab2]) {
-                if (!parent)
-                  continue;
+      if (!keyComboForMove && !keyComboForFocus) {
+        return;
+      }
 
-                gClickAndHoldListenersOnElement.remove(parent);
-                parent.removeAttribute("type");
-                if (parent.menupopup) {
-                  parent.menupopup.remove();
-                }
-
-                if (containersEnabled) {
-                  let popup = document.createElementNS(
-                                "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
-                                "menupopup");
-                  if (parent.id) {
-                    popup.id = "newtab-popup";
-                  } else {
-                    popup.setAttribute("anonid", "newtab-popup");
-                  }
-                  popup.className = "new-tab-popup";
-                  popup.setAttribute("position", "after_end");
-                  popup.addEventListener("popupshowing", event => {
-                    createUserContextMenu(event, {
-                      useAccessKeys: false,
-                      showDefaultTab: Services.prefs.getIntPref("privacy.userContext.longPressBehavior") == 1,
-                    });
-                  });
-                  parent.prepend(popup);
-
-                  // longPressBehavior == 2 means that the menu is shown after X
-                  // millisecs. Otherwise, with 1, the menu is open immediatelly.
-                  if (longPressBehavior == 2) {
-                    gClickAndHoldListenersOnElement.add(parent);
-                  }
-
-                  parent.setAttribute("type", "menu");
-                }
-              }
-
-              break;
+      // Don't check if the event was already consumed because tab navigation
+      // should work always for better user experience.
+      let { visibleTabs, selectedTab } = gBrowser;
+      let { arrowKeysShouldWrap } = this;
+      let focusedTabIndex = this.ariaFocusedIndex;
+      if (focusedTabIndex == -1) {
+        focusedTabIndex = visibleTabs.indexOf(selectedTab);
+      }
+      let lastFocusedTabIndex = focusedTabIndex;
+      switch (event.keyCode) {
+        case KeyEvent.DOM_VK_UP:
+          if (keyComboForMove) {
+            gBrowser.moveTabBackward();
+          } else {
+            focusedTabIndex--;
+          }
+          break;
+        case KeyEvent.DOM_VK_DOWN:
+          if (keyComboForMove) {
+            gBrowser.moveTabForward();
+          } else {
+            focusedTabIndex++;
           }
-        ]]></body>
-      </method>
-
-      <property name="_isCustomizing" readonly="true">
-        <getter><![CDATA[
-          return document.documentElement.getAttribute("customizing") == "true";
-        ]]></getter>
-      </property>
-
-      <method name="_getVisibleTabs">
-        <body><![CDATA[
-          // Cannot access gBrowser before it's initialized.
-          if (!gBrowser) {
-            return [ this.firstElementChild ];
+          break;
+        case KeyEvent.DOM_VK_RIGHT:
+        case KeyEvent.DOM_VK_LEFT:
+          if (keyComboForMove) {
+            gBrowser.moveTabOver(event);
+          } else if ((!RTL_UI && event.keyCode == KeyEvent.DOM_VK_RIGHT) ||
+                     (RTL_UI && event.keyCode == KeyEvent.DOM_VK_LEFT)) {
+                       focusedTabIndex++;
+          } else {
+            focusedTabIndex--;
+          }
+          break;
+        case KeyEvent.DOM_VK_HOME:
+          if (keyComboForMove) {
+            gBrowser.moveTabToStart();
+          } else {
+            focusedTabIndex = 0;
           }
-
-          return gBrowser.visibleTabs;
-        ]]></body>
-      </method>
+          break;
+        case KeyEvent.DOM_VK_END:
+          if (keyComboForMove) {
+            gBrowser.moveTabToEnd();
+          } else {
+            focusedTabIndex = visibleTabs.length - 1;
+          }
+          break;
+        case KeyEvent.DOM_VK_SPACE:
+          if (visibleTabs[lastFocusedTabIndex].multiselected) {
+            gBrowser.removeFromMultiSelectedTabs(visibleTabs[lastFocusedTabIndex]);
+          } else {
+            gBrowser.addToMultiSelectedTabs(visibleTabs[lastFocusedTabIndex], false);
+          }
+          break;
+        default:
+          // Consume the keydown event for the above keyboard
+          // shortcuts only.
+          return;
+      }
 
-      <method name="_setPositionalAttributes">
-        <body><![CDATA[
-          let visibleTabs = this._getVisibleTabs();
-          if (!visibleTabs.length) {
-            return;
-          }
-          let selectedTab = this.selectedItem;
-          let selectedIndex = visibleTabs.indexOf(selectedTab);
-          if (this._beforeSelectedTab) {
-            this._beforeSelectedTab.removeAttribute("beforeselected-visible");
-          }
+      if (arrowKeysShouldWrap) {
+        if (focusedTabIndex >= visibleTabs.length) {
+          focusedTabIndex = 0;
+        } else if (focusedTabIndex < 0) {
+          focusedTabIndex = visibleTabs.length - 1;
+        }
+      } else {
+        focusedTabIndex = Math.min(visibleTabs.length - 1, Math.max(0, focusedTabIndex));
+      }
 
-          if (selectedTab.closing || selectedIndex <= 0) {
-            this._beforeSelectedTab = null;
-          } else {
-            let beforeSelectedTab = visibleTabs[selectedIndex - 1];
-            let separatedByScrollButton = this.getAttribute("overflow") == "true" &&
-              beforeSelectedTab.pinned && !selectedTab.pinned;
-            if (!separatedByScrollButton) {
-              this._beforeSelectedTab = beforeSelectedTab;
-              this._beforeSelectedTab.setAttribute("beforeselected-visible",
-                                                   "true");
-            }
-          }
+      if (keyComboForFocus &&
+          focusedTabIndex != lastFocusedTabIndex) {
+            this.ariaFocusedItem = visibleTabs[focusedTabIndex];
+      }
+
+      event.preventDefault();
+    }, { mozSystemGroup: true });
+
+    this.addEventListener("dragstart", (event) => {
+      var tab = this._getDragTargetTab(event, false);
+      if (!tab || this._isCustomizing)
+        return;
 
-          if (this._firstTab)
-            this._firstTab.removeAttribute("first-visible-tab");
-          this._firstTab = visibleTabs[0];
-          this._firstTab.setAttribute("first-visible-tab", "true");
-          if (this._lastTab)
-            this._lastTab.removeAttribute("last-visible-tab");
-          this._lastTab = visibleTabs[visibleTabs.length - 1];
-          this._lastTab.setAttribute("last-visible-tab", "true");
+      let selectedTabs = gBrowser.selectedTabs;
+      let otherSelectedTabs = selectedTabs.filter(selectedTab => selectedTab != tab);
+      let dataTransferOrderedTabs = [tab].concat(otherSelectedTabs);
+
+      let dt = event.dataTransfer;
+      for (let i = 0; i < dataTransferOrderedTabs.length; i++) {
+        let dtTab = dataTransferOrderedTabs[i];
+
+        dt.mozSetDataAt(TAB_DROP_TYPE, dtTab, i);
+        let dtBrowser = dtTab.linkedBrowser;
 
-          let hoveredTab = this._hoveredTab;
-          if (hoveredTab) {
-            hoveredTab._mouseleave();
-          }
-          hoveredTab = this.querySelector("tab:hover");
-          if (hoveredTab) {
-            hoveredTab._mouseenter();
-          }
+        // We must not set text/x-moz-url or text/plain data here,
+        // otherwise trying to detach the tab by dropping it on the desktop
+        // may result in an "internet shortcut"
+        dt.mozSetDataAt("text/x-moz-text-internal", dtBrowser.currentURI.spec, i);
+      }
 
-          // Update before-multiselected attributes.
-          // gBrowser may not be initialized yet, so avoid using it
-          for (let i = 0; i < visibleTabs.length - 1; i++) {
-            let tab = visibleTabs[i];
-            let nextTab = visibleTabs[i + 1];
-            tab.removeAttribute("before-multiselected");
-            if (nextTab.multiselected) {
-              tab.setAttribute("before-multiselected", "true");
-            }
-          }
-        ]]></body>
-      </method>
+      // Set the cursor to an arrow during tab drags.
+      dt.mozCursor = "default";
 
-      <field name="_blockDblClick">false</field>
+      // Set the tab as the source of the drag, which ensures we have a stable
+      // node to deliver the `dragend` event.  See bug 1345473.
+      dt.addElement(tab);
+
+      if (tab.multiselected) {
+        this._groupSelectedTabs(tab);
+      }
 
-      <field name="_tabDropIndicator">
-        document.getAnonymousElementByAttribute(this, "anonid", "tab-drop-indicator");
-      </field>
-
-      <field name="_dragOverDelay">350</field>
-      <field name="_dragTime">0</field>
-
-      <field name="_closeButtonsUpdatePending">false</field>
-      <method name="_updateCloseButtons">
-        <body><![CDATA[
-          // If we're overflowing, tabs are at their minimum widths.
-          if (this.getAttribute("overflow") == "true") {
-            this.setAttribute("closebuttons", "activetab");
-            return;
-          }
-
-          if (this._closeButtonsUpdatePending) {
-            return;
-          }
-          this._closeButtonsUpdatePending = true;
-
-          // Wait until after the next paint to get current layout data from
-          // getBoundsWithoutFlushing.
-          window.requestAnimationFrame(() => {
-            window.requestAnimationFrame(() => {
-              this._closeButtonsUpdatePending = false;
+      // Create a canvas to which we capture the current tab.
+      // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired
+      // canvas size (in CSS pixels) to the window's backing resolution in order
+      // to get a full-resolution drag image for use on HiDPI displays.
+      let windowUtils = window.windowUtils;
+      let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;
+      let canvas = this._dndCanvas;
+      if (!canvas) {
+        this._dndCanvas = canvas =
+        document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
+        canvas.style.width = "100%";
+        canvas.style.height = "100%";
+        canvas.mozOpaque = true;
+      }
 
-              // The scrollbox may have started overflowing since we checked
-              // overflow earlier, so check again.
-              if (this.getAttribute("overflow") == "true") {
-                this.setAttribute("closebuttons", "activetab");
-                return;
-              }
+      canvas.width = 160 * scale;
+      canvas.height = 90 * scale;
+      let toDrag = canvas;
+      let dragImageOffset = -16;
+      let browser = tab.linkedBrowser;
+      if (gMultiProcessBrowser) {
+        var context = canvas.getContext("2d");
+        context.fillStyle = "white";
+        context.fillRect(0, 0, canvas.width, canvas.height);
 
-              // Check if tab widths are below the threshold where we want to
-              // remove close buttons from background tabs so that people don't
-              // accidentally close tabs by selecting them.
-              let rect = ele => {
-                return window.windowUtils.getBoundsWithoutFlushing(ele);
-              };
-              let tab = this._getVisibleTabs()[gBrowser._numPinnedTabs];
-              if (tab && rect(tab).width <= this._tabClipWidth) {
-                this.setAttribute("closebuttons", "activetab");
-              } else {
-                this.removeAttribute("closebuttons");
-              }
-            });
-          });
-        ]]></body>
-      </method>
-
-      <method name="_updateHiddenTabsStatus">
-        <body><![CDATA[
-          if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {
-            this.setAttribute("hashiddentabs", "true");
-          } else {
-            this.removeAttribute("hashiddentabs");
+        let captureListener;
+        let platform = AppConstants.platform;
+        // On Windows and Mac we can update the drag image during a drag
+        // using updateDragImage. On Linux, we can use a panel.
+        if (platform == "win" || platform == "macosx") {
+          captureListener = function() {
+            dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);
+          };
+        } else {
+          // Create a panel to use it in setDragImage
+          // which will tell xul to render a panel that follows
+          // the pointer while a dnd session is on.
+          if (!this._dndPanel) {
+            this._dndCanvas = canvas;
+            this._dndPanel = document.createXULElement("panel");
+            this._dndPanel.className = "dragfeedback-tab";
+            this._dndPanel.setAttribute("type", "drag");
+            let wrapper = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
+            wrapper.style.width = "160px";
+            wrapper.style.height = "90px";
+            wrapper.appendChild(canvas);
+            this._dndPanel.appendChild(wrapper);
+            document.documentElement.appendChild(this._dndPanel);
           }
-        ]]></body>
-      </method>
-
-      <method name="_handleTabSelect">
-        <parameter name="aInstant"/>
-        <body><![CDATA[
-          let selectedTab = this.selectedItem;
-          if (this.getAttribute("overflow") == "true")
-            this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);
+          toDrag = this._dndPanel;
+        }
+        // PageThumb is async with e10s but that's fine
+        // since we can update the image during the dnd.
+        PageThumbs.captureToCanvas(browser, canvas, captureListener);
+      } else {
+        // For the non e10s case we can just use PageThumbs
+        // sync, so let's use the canvas for setDragImage.
+        PageThumbs.captureToCanvas(browser, canvas);
+        dragImageOffset = dragImageOffset * scale;
+      }
+      dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);
 
-          selectedTab._notselectedsinceload = false;
-        ]]></body>
-      </method>
+      // _dragData.offsetX/Y give the coordinates that the mouse should be
+      // positioned relative to the corner of the new window created upon
+      // dragend such that the mouse appears to have the same position
+      // relative to the corner of the dragged tab.
+      function clientX(ele) {
+        return ele.getBoundingClientRect().left;
+      }
+      let tabOffsetX = clientX(tab) - clientX(this);
+      tab._dragData = {
+        offsetX: event.screenX - window.screenX - tabOffsetX,
+        offsetY: event.screenY - window.screenY,
+        scrollX: this.arrowScrollbox.scrollbox.scrollLeft,
+        screenX: event.screenX,
+        movingTabs: (tab.multiselected ? gBrowser.selectedTabs : [tab])
+                        .filter(t => t.pinned == tab.pinned),
+      };
 
-      <field name="_closingTabsSpacer">
-        document.getAnonymousElementByAttribute(this, "anonid", "closing-tabs-spacer");
-      </field>
+      event.stopPropagation();
+    });
 
-      <field name="_tabDefaultMaxWidth">NaN</field>
-      <field name="_lastTabClosedByMouse">false</field>
-      <field name="_hasTabTempMaxWidth">false</field>
-      <field name="_scrollButtonWidth">0</field>
+    this.addEventListener("dragover", (event) => {
+      var effects = this._getDropEffectForTabDrag(event);
 
-      <!-- Try to keep the active tab's close button under the mouse cursor -->
-      <method name="_lockTabSizing">
-        <parameter name="aTab"/>
-        <parameter name="aTabWidth"/>
-        <body><![CDATA[
-          let tabs = this._getVisibleTabs();
-          if (!tabs.length) {
-            return;
-          }
+      var ind = this._tabDropIndicator;
+      if (effects == "" || effects == "none") {
+        ind.collapsed = true;
+        return;
+      }
+      event.preventDefault();
+      event.stopPropagation();
 
-          var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);
+      var arrowScrollbox = this.arrowScrollbox;
 
-          if (!this._tabDefaultMaxWidth) {
-            this._tabDefaultMaxWidth =
-              parseFloat(window.getComputedStyle(aTab).maxWidth);
-          }
-          this._lastTabClosedByMouse = true;
-          this._scrollButtonWidth = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox._scrollButtonDown).width;
+      // autoscroll the tab strip if we drag over the scroll
+      // buttons, even if we aren't dragging a tab, but then
+      // return to avoid drawing the drop indicator
+      var pixelsToScroll = 0;
+      if (this.getAttribute("overflow") == "true") {
+        var targetAnonid = event.originalTarget.getAttribute("anonid");
+        switch (targetAnonid) {
+          case "scrollbutton-up":
+            pixelsToScroll = arrowScrollbox.scrollIncrement * -1;
+            break;
+          case "scrollbutton-down":
+            pixelsToScroll = arrowScrollbox.scrollIncrement;
+            break;
+        }
+        if (pixelsToScroll)
+          arrowScrollbox.scrollByPixels((RTL_UI ? -1 : 1) * pixelsToScroll, true);
+      }
 
-          if (this.getAttribute("overflow") == "true") {
-            // Don't need to do anything if we're in overflow mode and aren't scrolled
-            // all the way to the right, or if we're closing the last tab.
-            if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {
-              return;
-            }
-            // If the tab has an owner that will become the active tab, the owner will
-            // be to the left of it, so we actually want the left tab to slide over.
-            // This can't be done as easily in non-overflow mode, so we don't bother.
-            if (aTab.owner) {
-              return;
-            }
-            this._expandSpacerBy(aTabWidth);
-          } else { // non-overflow mode
-            // Locking is neither in effect nor needed, so let tabs expand normally.
-            if (isEndTab && !this._hasTabTempMaxWidth) {
+      let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
+      if ((effects == "move" || effects == "copy") &&
+          this == draggedTab.container) {
+            ind.collapsed = true;
+
+            if (!this._isGroupTabsAnimationOver()) {
+              // Wait for grouping tabs animation to finish
               return;
             }
-            let numPinned = gBrowser._numPinnedTabs;
-            // Force tabs to stay the same width, unless we're closing the last tab,
-            // which case we need to let them expand just enough so that the overall
-            // tabbar width is the same.
-            if (isEndTab) {
-              let numNormalTabs = tabs.length - numPinned;
-              aTabWidth = aTabWidth * (numNormalTabs + 1) / numNormalTabs;
-              if (aTabWidth > this._tabDefaultMaxWidth) {
-                aTabWidth = this._tabDefaultMaxWidth;
-              }
-            }
-            aTabWidth += "px";
-            let tabsToReset = [];
-            for (let i = numPinned; i < tabs.length; i++) {
-              let tab = tabs[i];
-              tab.style.setProperty("max-width", aTabWidth, "important");
-              if (!isEndTab) { // keep tabs the same width
-                tab.style.transition = "none";
-                tabsToReset.push(tab);
-              }
-            }
-
-            if (tabsToReset.length) {
-              window.promiseDocumentFlushed(() => {}).then(() => {
-                window.requestAnimationFrame(() => {
-                  for (let tab of tabsToReset) {
-                    tab.style.transition = "";
-                  }
-                });
-              });
-            }
-
-            this._hasTabTempMaxWidth = true;
-            gBrowser.addEventListener("mousemove", this);
-            window.addEventListener("mouseout", this);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_expandSpacerBy">
-        <parameter name="pixels"/>
-        <body><![CDATA[
-          let spacer = this._closingTabsSpacer;
-          spacer.style.width = parseFloat(spacer.style.width) + pixels + "px";
-          this.setAttribute("using-closing-tabs-spacer", "true");
-          gBrowser.addEventListener("mousemove", this);
-          window.addEventListener("mouseout", this);
-        ]]></body>
-      </method>
-
-      <method name="_unlockTabSizing">
-        <body><![CDATA[
-          gBrowser.removeEventListener("mousemove", this);
-          window.removeEventListener("mouseout", this);
-
-          if (this._hasTabTempMaxWidth) {
-            this._hasTabTempMaxWidth = false;
-            let tabs = this._getVisibleTabs();
-            for (let i = 0; i < tabs.length; i++) {
-              tabs[i].style.maxWidth = "";
-            }
-          }
-
-          if (this.hasAttribute("using-closing-tabs-spacer")) {
-            this.removeAttribute("using-closing-tabs-spacer");
-            this._closingTabsSpacer.style.width = 0;
-          }
-        ]]></body>
-      </method>
-
-      <method name="uiDensityChanged">
-        <body><![CDATA[
-          this._positionPinnedTabs();
-          this._updateCloseButtons();
-          this._handleTabSelect(true);
-        ]]></body>
-      </method>
-
-      <field name="_lastNumPinned">0</field>
-      <field name="_pinnedTabsLayoutCache">null</field>
-      <method name="_positionPinnedTabs">
-        <body><![CDATA[
-          let numPinned = gBrowser._numPinnedTabs;
-          let doPosition = this.getAttribute("overflow") == "true" &&
-                           this._getVisibleTabs().length > numPinned &&
-                           numPinned > 0;
-
-          if (doPosition) {
-            this.setAttribute("positionpinnedtabs", "true");
-
-            let layoutData = this._pinnedTabsLayoutCache;
-            let uiDensity = document.documentElement.getAttribute("uidensity");
-            if (!layoutData ||
-                layoutData.uiDensity != uiDensity) {
-              let arrowScrollbox = this.arrowScrollbox;
-              layoutData = this._pinnedTabsLayoutCache = {
-                uiDensity,
-                pinnedTabWidth: this.children[0].getBoundingClientRect().width,
-                scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width,
-              };
-            }
-
-            let width = 0;
-            for (let i = numPinned - 1; i >= 0; i--) {
-              let tab = this.children[i];
-              width += layoutData.pinnedTabWidth;
-              tab.style.setProperty("margin-inline-start",
-                -(width + layoutData.scrollButtonWidth) + "px", "important");
-              tab._pinnedUnscrollable = true;
-            }
-            this.style.paddingInlineStart = width + "px";
-          } else {
-            this.removeAttribute("positionpinnedtabs");
-
-            for (let i = 0; i < numPinned; i++) {
-              let tab = this.children[i];
-              tab.style.marginInlineStart = "";
-              tab._pinnedUnscrollable = false;
-            }
-
-            this.style.paddingInlineStart = "";
-          }
-
-          if (this._lastNumPinned != numPinned) {
-            this._lastNumPinned = numPinned;
-            this._handleTabSelect(true);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_animateTabMove">
-        <parameter name="event"/>
-        <body><![CDATA[
-          let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
-          let movingTabs = draggedTab._dragData.movingTabs;
-
-          if (this.getAttribute("movingtab") != "true") {
-            this.setAttribute("movingtab", "true");
-            gNavToolbox.setAttribute("movingtab", "true");
-            if (!draggedTab.multiselected)
-              this.selectedItem = draggedTab;
-          }
-
-          if (!("animLastScreenX" in draggedTab._dragData))
-            draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;
-
-          let screenX = event.screenX;
-          if (screenX == draggedTab._dragData.animLastScreenX)
-            return;
-
-          // Direction of the mouse movement.
-          let ltrMove = screenX > draggedTab._dragData.animLastScreenX;
-
-          draggedTab._dragData.animLastScreenX = screenX;
-
-          let pinned = draggedTab.pinned;
-          let numPinned = gBrowser._numPinnedTabs;
-          let tabs = this._getVisibleTabs()
-                         .slice(pinned ? 0 : numPinned,
-                                pinned ? numPinned : undefined);
+            this._finishGroupSelectedTabs(draggedTab);
 
-          if (RTL_UI) {
-            tabs.reverse();
-            // Copy moving tabs array to avoid infinite reversing.
-            movingTabs = [...movingTabs].reverse();
-          }
-          let tabWidth = draggedTab.getBoundingClientRect().width;
-          let shiftWidth = tabWidth * movingTabs.length;
-          draggedTab._dragData.tabWidth = tabWidth;
-
-          // Move the dragged tab based on the mouse position.
-
-          let leftTab = tabs[0];
-          let rightTab = tabs[tabs.length - 1];
-          let rightMovingTabScreenX = movingTabs[movingTabs.length - 1].screenX;
-          let leftMovingTabScreenX = movingTabs[0].screenX;
-          let translateX = screenX - draggedTab._dragData.screenX;
-          if (!pinned) {
-            translateX += this.arrowScrollbox.scrollbox.scrollLeft - draggedTab._dragData.scrollX;
-          }
-          let leftBound = leftTab.screenX - leftMovingTabScreenX;
-          let rightBound = (rightTab.screenX + rightTab.getBoundingClientRect().width) -
-                           (rightMovingTabScreenX + tabWidth);
-          translateX = Math.min(Math.max(translateX, leftBound), rightBound);
-
-          for (let tab of movingTabs) {
-            tab.style.transform = "translateX(" + translateX + "px)";
-          }
-
-          draggedTab._dragData.translateX = translateX;
-
-          // Determine what tab we're dragging over.
-          // * Single tab dragging: Point of reference is the center of the dragged tab. If that
-          //   point touches a background tab, the dragged tab would take that
-          //   tab's position when dropped.
-          // * Multiple tabs dragging: All dragged tabs are one "giant" tab with two
-          //   points of reference (center of tabs on the extremities). When
-          //   mouse is moving from left to right, the right reference gets activated,
-          //   otherwise the left reference will be used. Everything else works the same
-          //   as single tab dragging.
-          // * We're doing a binary search in order to reduce the amount of
-          //   tabs we need to check.
-
-          tabs = tabs.filter(t => !movingTabs.includes(t) || t == draggedTab);
-          let leftTabCenter = leftMovingTabScreenX + translateX + tabWidth / 2;
-          let rightTabCenter = rightMovingTabScreenX + translateX + tabWidth / 2;
-          let tabCenter = ltrMove ? rightTabCenter : leftTabCenter;
-          let newIndex = -1;
-          let oldIndex = "animDropIndex" in draggedTab._dragData ?
-                         draggedTab._dragData.animDropIndex : movingTabs[0]._tPos;
-          let low = 0;
-          let high = tabs.length - 1;
-          while (low <= high) {
-            let mid = Math.floor((low + high) / 2);
-            if (tabs[mid] == draggedTab && ++mid > high)
-              break;
-            screenX = tabs[mid].screenX + getTabShift(tabs[mid], oldIndex);
-            if (screenX > tabCenter) {
-              high = mid - 1;
-            } else if (screenX + tabs[mid].getBoundingClientRect().width < tabCenter) {
-              low = mid + 1;
-            } else {
-              newIndex = tabs[mid]._tPos;
-              break;
-            }
-          }
-          if (newIndex >= oldIndex)
-            newIndex++;
-          if (newIndex < 0 || newIndex == oldIndex)
-            return;
-          draggedTab._dragData.animDropIndex = newIndex;
-
-          // Shift background tabs to leave a gap where the dragged tab
-          // would currently be dropped.
-
-          for (let tab of tabs) {
-            if (tab != draggedTab) {
-              let shift = getTabShift(tab, newIndex);
-              tab.style.transform = shift ? "translateX(" + shift + "px)" : "";
-            }
-          }
-
-          function getTabShift(tab, dropIndex) {
-            if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)
-              return (RTL_UI ? -shiftWidth : shiftWidth);
-            if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)
-              return (RTL_UI ? shiftWidth : -shiftWidth);
-            return 0;
-          }
-        ]]></body>
-      </method>
-
-      <method name="_finishAnimateTabMove">
-        <body><![CDATA[
-          if (this.getAttribute("movingtab") != "true") {
-            return;
-          }
-
-          for (let tab of this._getVisibleTabs()) {
-            tab.style.transform = "";
-          }
-
-          this.removeAttribute("movingtab");
-          gNavToolbox.removeAttribute("movingtab");
-
-          this._handleTabSelect();
-        ]]></body>
-      </method>
-
-      <!--  Regroup all selected tabs around the
-            tab in param  -->
-      <method name="_groupSelectedTabs">
-        <parameter name="tab"/>
-        <body><![CDATA[
-          let draggedTabPos = tab._tPos;
-          let selectedTabs = gBrowser.selectedTabs;
-          let animate = gBrowser.animationsEnabled;
-
-          tab.groupingTabsData = {
-            finished: !animate,
-          };
-
-
-          // Animate left selected tabs
-
-          let insertAtPos = draggedTabPos - 1;
-          for (let i = selectedTabs.indexOf(tab) - 1; i > -1; i--) {
-            let movingTab = selectedTabs[i];
-            insertAtPos = newIndex(movingTab, insertAtPos);
-
-            if (animate) {
-              movingTab.groupingTabsData = {};
-              addAnimationData(movingTab, insertAtPos, "left");
-            } else {
-              gBrowser.moveTabTo(movingTab, insertAtPos);
-            }
-            insertAtPos--;
-          }
-
-          // Animate right selected tabs
-
-          insertAtPos = draggedTabPos + 1;
-          for (let i = selectedTabs.indexOf(tab) + 1; i < selectedTabs.length; i++) {
-            let movingTab = selectedTabs[i];
-            insertAtPos = newIndex(movingTab, insertAtPos);
-
-            if (animate) {
-              movingTab.groupingTabsData = {};
-              addAnimationData(movingTab, insertAtPos, "right");
-            } else {
-              gBrowser.moveTabTo(movingTab, insertAtPos);
-            }
-            insertAtPos++;
-          }
-
-          // Slide the relevant tabs to their new position.
-          for (let t of this._getVisibleTabs()) {
-            if (t.groupingTabsData && t.groupingTabsData.translateX) {
-              let translateX = (RTL_UI ? -1 : 1) * t.groupingTabsData.translateX;
-              t.style.transform = "translateX(" + translateX + "px)";
-            }
-          }
-
-          function newIndex(aTab, index) {
-            // Don't allow mixing pinned and unpinned tabs.
-            if (aTab.pinned) {
-              return Math.min(index, gBrowser._numPinnedTabs - 1);
-            }
-            return Math.max(index, gBrowser._numPinnedTabs);
-          }
-
-          function addAnimationData(movingTab, movingTabNewIndex, side) {
-            let movingTabOldIndex = movingTab._tPos;
-
-            if (movingTabOldIndex == movingTabNewIndex) {
-              // movingTab is already at the right position
-              // and thus don't need to be animated.
+            if (effects == "move") {
+              this._animateTabMove(event);
               return;
             }
-
-            let movingTabWidth = movingTab.getBoundingClientRect().width;
-            let shift = (movingTabNewIndex - movingTabOldIndex) * movingTabWidth;
-
-            movingTab.groupingTabsData.animate = true;
-            movingTab.setAttribute("tab-grouping", "true");
-
-            movingTab.groupingTabsData.translateX = shift;
-
-            let onTransitionEnd = transitionendEvent => {
-              if (transitionendEvent.propertyName != "transform" ||
-                  transitionendEvent.originalTarget != movingTab) {
-                return;
-              }
-              movingTab.removeEventListener("transitionend", onTransitionEnd);
-              movingTab.groupingTabsData.newIndex = movingTabNewIndex;
-              movingTab.groupingTabsData.animate = false;
-            };
-
-            movingTab.addEventListener("transitionend", onTransitionEnd);
-
-            // Add animation data for tabs between movingTab (selected
-            // tab moving towards the dragged tab) and draggedTab.
-            // Those tabs in the middle should move in
-            // the opposite direction of movingTab.
-
-            let lowerIndex = Math.min(movingTabOldIndex, draggedTabPos);
-            let higherIndex = Math.max(movingTabOldIndex, draggedTabPos);
-
-            for (let i = lowerIndex + 1; i < higherIndex; i++) {
-              let middleTab = gBrowser.visibleTabs[i];
-
-              if (middleTab.pinned != movingTab.pinned) {
-                // Don't mix pinned and unpinned tabs
-                break;
-              }
-
-              if (middleTab.multiselected) {
-                // Skip because this selected tab should
-                // be shifted towards the dragged Tab.
-                continue;
-              }
-
-              if (!middleTab.groupingTabsData || !middleTab.groupingTabsData.translateX) {
-                middleTab.groupingTabsData = { translateX: 0};
-              }
-              if (side == "left") {
-                middleTab.groupingTabsData.translateX -= movingTabWidth;
-              } else {
-                middleTab.groupingTabsData.translateX += movingTabWidth;
-              }
-
-              middleTab.setAttribute("tab-grouping", "true");
-            }
-          }
-        ]]></body>
-      </method>
-
-      <method name="_finishGroupSelectedTabs">
-        <parameter name="tab"/>
-        <body><![CDATA[
-          if (!tab.groupingTabsData || tab.groupingTabsData.finished)
-            return;
-
-          tab.groupingTabsData.finished = true;
-
-          let selectedTabs = gBrowser.selectedTabs;
-          let tabIndex = selectedTabs.indexOf(tab);
-
-          // Moving left tabs
-          for (let i = tabIndex - 1; i > -1; i--) {
-            let movingTab = selectedTabs[i];
-            if (movingTab.groupingTabsData.newIndex) {
-              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);
-            }
-          }
-
-          // Moving right tabs
-          for (let i = tabIndex + 1; i < selectedTabs.length; i++) {
-            let movingTab = selectedTabs[i];
-            if (movingTab.groupingTabsData.newIndex) {
-              gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);
-            }
-          }
-
-          for (let t of this._getVisibleTabs()) {
-            t.style.transform = "";
-            t.removeAttribute("tab-grouping");
-            delete t.groupingTabsData;
-          }
-        ]]></body>
-      </method>
-
-      <method name="_isGroupTabsAnimationOver">
-        <body><![CDATA[
-          for (let tab of gBrowser.selectedTabs) {
-            if (tab.groupingTabsData && tab.groupingTabsData.animate)
-              return false;
-          }
-          return true;
-        ]]></body>
-      </method>
-
-      <method name="handleEvent">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          switch (aEvent.type) {
-            case "resize":
-              if (aEvent.target != window)
-                break;
-
-              this._updateCloseButtons();
-              this._handleTabSelect(true);
-              break;
-            case "mouseout":
-              // If the "related target" (the node to which the pointer went) is not
-              // a child of the current document, the mouse just left the window.
-              let relatedTarget = aEvent.relatedTarget;
-              if (relatedTarget && relatedTarget.ownerDocument == document)
-                break;
-            case "mousemove":
-              if (document.getElementById("tabContextMenu").state != "open")
-                this._unlockTabSizing();
-              break;
-          }
-        ]]></body>
-      </method>
-
-      <field name="_animateElement">
-        this.arrowScrollbox._scrollButtonDown;
-      </field>
-
-      <method name="_notifyBackgroundTab">
-        <parameter name="aTab"/>
-        <body><![CDATA[
-          if (aTab.pinned || aTab.hidden || this.getAttribute("overflow") != "true")
-            return;
-
-          this._lastTabToScrollIntoView = aTab;
-          if (!this._backgroundTabScrollPromise) {
-            this._backgroundTabScrollPromise = window.promiseDocumentFlushed(() => {
-              let lastTabRect = this._lastTabToScrollIntoView.getBoundingClientRect();
-              let selectedTab = this.selectedItem;
-              if (selectedTab.pinned) {
-                selectedTab = null;
-              } else {
-                selectedTab = selectedTab.getBoundingClientRect();
-                selectedTab = {left: selectedTab.left, right: selectedTab.right};
-              }
-              return [
-                this._lastTabToScrollIntoView,
-                this.arrowScrollbox.scrollClientRect,
-                {left: lastTabRect.left, right: lastTabRect.right},
-                selectedTab,
-              ];
-            }).then(([tabUsed, scrollRect, tabRect, selectedRect]) => {
-              // First off, remove the promise so we can re-enter if necessary.
-              delete this._backgroundTabScrollPromise;
-              // Then, if the layout info isn't for the last-scrolled-to-tab, re-run
-              // the code above to get layout info for *that* tab, and don't do
-              // anything here, as we really just want to run this for the last-opened tab.
-              if (this._lastTabToScrollIntoView != tabUsed) {
-                this._notifyBackgroundTab(this._lastTabToScrollIntoView);
-                return;
-              }
-              delete this._lastTabToScrollIntoView;
-              // Is the new tab already completely visible?
-              if (scrollRect.left <= tabRect.left && tabRect.right <= scrollRect.right)
-                return;
-
-              if (this.arrowScrollbox.smoothScroll) {
-                // Can we make both the new tab and the selected tab completely visible?
-                if (!selectedRect ||
-                    Math.max(tabRect.right - selectedRect.left, selectedRect.right - tabRect.left) <=
-                      scrollRect.width) {
-                  this.arrowScrollbox.ensureElementIsVisible(aTab);
-                  return;
-                }
-
-                this.arrowScrollbox.scrollByPixels(RTL_UI ?
-                                                     selectedRect.right - scrollRect.right :
-                                                     selectedRect.left - scrollRect.left);
-              }
+      }
 
-              if (!this._animateElement.hasAttribute("highlight")) {
-                this._animateElement.setAttribute("highlight", "true");
-                setTimeout(function(ele) {
-                  ele.removeAttribute("highlight");
-                }, 150, this._animateElement);
-              }
-            });
-          }
-        ]]></body>
-      </method>
-
-      <method name="_getDragTargetTab">
-        <parameter name="event"/>
-        <parameter name="isLink"/>
-        <body><![CDATA[
-          let tab = event.target;
-          while (tab && tab.localName != "tab") {
-            tab = tab.parentNode;
-          }
-          if (tab && isLink) {
-            let {width} = tab.getBoundingClientRect();
-            if (event.screenX < tab.screenX + width * .25 ||
-                event.screenX > tab.screenX + width * .75)
-              return null;
-          }
-          return tab;
-        ]]></body>
-      </method>
-
-      <method name="_getDropIndex">
-        <parameter name="event"/>
-        <parameter name="isLink"/>
-        <body><![CDATA[
-          var tabs = this.children;
-          var tab = this._getDragTargetTab(event, isLink);
-          if (!RTL_UI) {
-            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
-              if (event.screenX < tabs[i].screenX + tabs[i].getBoundingClientRect().width / 2)
-                return i;
-          } else {
-            for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
-              if (event.screenX > tabs[i].screenX + tabs[i].getBoundingClientRect().width / 2)
-                return i;
-          }
-          return tabs.length;
-        ]]></body>
-      </method>
-
-      <method name="_getDropEffectForTabDrag">
-        <parameter name="event"/>
-        <body><![CDATA[
-          var dt = event.dataTransfer;
-
-          let isMovingTabs = dt.mozItemCount > 0;
-          for (let i = 0; i < dt.mozItemCount; i++) {
-            // tabs are always added as the first type
-            let types = dt.mozTypesAt(0);
-            if (types[0] != TAB_DROP_TYPE) {
-              isMovingTabs = false;
-              break;
-            }
-          }
-
-          if (isMovingTabs) {
-            let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
-            if (sourceNode instanceof XULElement &&
-                sourceNode.localName == "tab" &&
-                sourceNode.ownerGlobal.isChromeWindow &&
-                sourceNode.ownerDocument.documentElement.getAttribute("windowtype") == "navigator:browser" &&
-                sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.parentNode) {
-              // Do not allow transfering a private tab to a non-private window
-              // and vice versa.
-              if (PrivateBrowsingUtils.isWindowPrivate(window) !=
-                  PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))
-                return "none";
-
-              if (window.gMultiProcessBrowser !=
-                  sourceNode.ownerGlobal.gMultiProcessBrowser)
-                return "none";
-
-              return dt.dropEffect == "copy" ? "copy" : "move";
-            }
-          }
-
-          if (browserDragAndDrop.canDropLink(event)) {
-            return "link";
-          }
-          return "none";
-        ]]></body>
-      </method>
-
-      <method name="_handleNewTab">
-        <parameter name="tab"/>
-        <body><![CDATA[
-          if (tab.parentNode != this) {
-            return;
-          }
-          tab._fullyOpen = true;
-          gBrowser.tabAnimationsInProgress--;
-
-          this._updateCloseButtons();
-
-          if (tab.getAttribute("selected") == "true") {
-            this._handleTabSelect();
-          } else if (!tab.hasAttribute("skipbackgroundnotify")) {
-            this._notifyBackgroundTab(tab);
-          }
-
-          // XXXmano: this is a temporary workaround for bug 345399
-          // We need to manually update the scroll buttons disabled state
-          // if a tab was inserted to the overflow area or removed from it
-          // without any scrolling and when the tabbar has already
-          // overflowed.
-          this.arrowScrollbox._updateScrollButtonsDisabledState();
-
-          // If this browser isn't lazy (indicating it's probably created by
-          // session restore), preload the next about:newtab if we don't
-          // already have a preloaded browser.
-          if (tab.linkedPanel) {
-            NewTabPagePreloading.maybeCreatePreloadedBrowser(window);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_canAdvanceToTab">
-        <parameter name="aTab"/>
-        <body>
-        <![CDATA[
-          return !aTab.closing;
-        ]]>
-        </body>
-      </method>
-
-      <method name="getRelatedElement">
-        <parameter name="aTab"/>
-        <body>
-        <![CDATA[
-          if (!aTab) {
-            return null;
-          }
-
-          // Cannot access gBrowser before it's initialized.
-          if (!gBrowser) {
-            return this.tabbox.tabpanels.firstElementChild;
-          }
-
-          // If the tab's browser is lazy, we need to `_insertBrowser` in order
-          // to have a linkedPanel.  This will also serve to bind the browser
-          // and make it ready to use when the tab is selected.
-          gBrowser._insertBrowser(aTab);
-          return document.getElementById(aTab.linkedPanel);
-        ]]>
-        </body>
-      </method>
-
-      <method name="_updateNewTabVisibility">
-        <body><![CDATA[
-          // Helper functions to help deal with customize mode wrapping some items
-          let wrap = n => n.parentNode.localName == "toolbarpaletteitem" ? n.parentNode : n;
-          let unwrap = n => n && n.localName == "toolbarpaletteitem" ? n.firstElementChild : n;
-
-          // Starting from the tabs element, find the next sibling that:
-          // - isn't hidden; and
-          // - isn't the all-tabs button.
-          // If it's the new tab button, consider the new tab button adjacent to the tabs.
-          // If the new tab button is marked as adjacent and the tabstrip doesn't
-          // overflow, we'll display the 'new tab' button inline in the tabstrip.
-          // In all other cases, the separate new tab button is displayed in its
-          // customized location.
-          let sib = this;
-          do {
-            sib = unwrap(wrap(sib).nextElementSibling);
-          } while (sib && (sib.hidden ||
-                           sib.id == "alltabs-button"));
-
-          const kAttr = "hasadjacentnewtabbutton";
-          if (sib && sib.id == "new-tab-button") {
-            this.setAttribute(kAttr, "true");
-          } else {
-            this.removeAttribute(kAttr);
-          }
-        ]]></body>
-      </method>
-
-      <method name="onWidgetAfterDOMChange">
-        <parameter name="aNode"/>
-        <parameter name="aNextNode"/>
-        <parameter name="aContainer"/>
-        <body><![CDATA[
-          if (aContainer.ownerDocument == document &&
-              aContainer.id == "TabsToolbar-customization-target") {
-            this._updateNewTabVisibility();
-          }
-        ]]></body>
-      </method>
+      this._finishAnimateTabMove();
 
-      <method name="onAreaNodeRegistered">
-        <parameter name="aArea"/>
-        <parameter name="aContainer"/>
-        <body><![CDATA[
-          if (aContainer.ownerDocument == document &&
-              aArea == "TabsToolbar") {
-            this._updateNewTabVisibility();
-          }
-        ]]></body>
-      </method>
-
-      <method name="onAreaReset">
-        <parameter name="aArea"/>
-        <parameter name="aContainer"/>
-        <body><![CDATA[
-          this.onAreaNodeRegistered(aArea, aContainer);
-        ]]></body>
-      </method>
-
-      <method name="_hiddenSoundPlayingStatusChanged">
-        <parameter name="tab"/>
-        <parameter name="opts"/>
-        <body><![CDATA[
-          let closed = opts && opts.closed;
-          if (!closed && tab.soundPlaying && tab.hidden) {
-            this._hiddenSoundPlayingTabs.add(tab);
-            this.setAttribute("hiddensoundplaying", "true");
-          } else {
-            this._hiddenSoundPlayingTabs.delete(tab);
-            if (this._hiddenSoundPlayingTabs.size == 0) {
-              this.removeAttribute("hiddensoundplaying");
-            }
-          }
-        ]]></body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <handler event="TabSelect"><![CDATA[
-        this._handleTabSelect();
-      ]]></handler>
-
-      <handler event="TabClose"><![CDATA[
-        this._hiddenSoundPlayingStatusChanged(event.target, {closed: true});
-      ]]></handler>
-
-      <handler event="TabAttrModified"><![CDATA[
-        if (event.detail.changed.includes("soundplaying") && event.target.hidden) {
-          this._hiddenSoundPlayingStatusChanged(event.target);
-        }
-      ]]></handler>
-
-      <handler event="TabHide"><![CDATA[
-        if (event.target.soundPlaying) {
-          this._hiddenSoundPlayingStatusChanged(event.target);
-        }
-      ]]></handler>
-
-      <handler event="TabShow"><![CDATA[
-        if (event.target.soundPlaying) {
-          this._hiddenSoundPlayingStatusChanged(event.target);
-        }
-      ]]></handler>
-
-      <handler event="transitionend"><![CDATA[
-        if (event.propertyName != "max-width") {
-          return;
-        }
-
-        let tab = event.target.closest("tab");
-        if (!tab) {
-          return;
-        }
-
-        if (tab.getAttribute("fadein") == "true") {
-          if (tab._fullyOpen) {
-            this._updateCloseButtons();
-          } else {
-            this._handleNewTab(tab);
-          }
-        } else if (tab.closing) {
-          gBrowser._endRemoveTab(tab);
-        }
-
-        let evt = new CustomEvent("TabAnimationEnd", { bubbles: true });
-        tab.dispatchEvent(evt);
-      ]]></handler>
-
-      <handler event="dblclick"><![CDATA[
-        // When the tabbar has an unified appearance with the titlebar
-        // and menubar, a double-click in it should have the same behavior
-        // as double-clicking the titlebar
-        if (TabsInTitlebar.enabled)
-          return;
-
-        if (event.button != 0 ||
-            event.originalTarget.localName != "scrollbox")
-          return;
-
-        if (!this._blockDblClick)
-          BrowserOpenTab();
-
-        event.preventDefault();
-      ]]></handler>
-
-      <handler event="click" button="0" phase="capturing"><![CDATA[
-        /* Catches extra clicks meant for the in-tab close button.
-         * Placed here to avoid leaking (a temporary handler added from the
-         * in-tab close button binding would close over the tab and leak it
-         * until the handler itself was removed). (bug 897751)
-         *
-         * The only sequence in which a second click event (i.e. dblclik)
-         * can be dispatched on an in-tab close button is when it is shown
-         * after the first click (i.e. the first click event was dispatched
-         * on the tab). This happens when we show the close button only on
-         * the active tab. (bug 352021)
-         * The only sequence in which a third click event can be dispatched
-         * on an in-tab close button is when the tab was opened with a
-         * double click on the tabbar. (bug 378344)
-         * In both cases, it is most likely that the close button area has
-         * been accidentally clicked, therefore we do not close the tab.
-         *
-         * We don't want to ignore processing of more than one click event,
-         * though, since the user might actually be repeatedly clicking to
-         * close many tabs at once.
-         */
-        let target = event.originalTarget;
-        if (target.classList.contains("tab-close-button")) {
-          // We preemptively set this to allow the closing-multiple-tabs-
-          // in-a-row case.
-          if (this._blockDblClick) {
-            target._ignoredCloseButtonClicks = true;
-          } else if (event.detail > 1 && !target._ignoredCloseButtonClicks) {
-            target._ignoredCloseButtonClicks = true;
-            event.stopPropagation();
-            return;
-          } else {
-            // Reset the "ignored click" flag
-            target._ignoredCloseButtonClicks = false;
-          }
-        }
-
-        /* Protects from close-tab-button errant doubleclick:
-         * Since we're removing the event target, if the user
-         * double-clicks the button, the dblclick event will be dispatched
-         * with the tabbar as its event target (and explicit/originalTarget),
-         * which treats that as a mouse gesture for opening a new tab.
-         * In this context, we're manually blocking the dblclick event.
-         */
-        if (this._blockDblClick) {
-          if (!("_clickedTabBarOnce" in this)) {
-            this._clickedTabBarOnce = true;
-            return;
-          }
-          delete this._clickedTabBarOnce;
-          this._blockDblClick = false;
-        }
-      ]]></handler>
-
-      <handler event="click"><![CDATA[
-        if (event.button != 1) {
-          return;
-        }
-
-        let tab = event.target.closest("tab");
+      if (effects == "link") {
+        let tab = this._getDragTargetTab(event, true);
         if (tab) {
-          gBrowser.removeTab(tab, {
-            animate: true,
-            byMouse: event.mozInputSource == MouseEvent.MOZ_SOURCE_MOUSE,
-          });
-        } else if (event.originalTarget.localName == "scrollbox") {
-          // The user middleclicked on the tabstrip. Check whether the click
-          // was dispatched on the open space of it.
-          let visibleTabs = this._getVisibleTabs();
-          let lastTab = visibleTabs[visibleTabs.length - 1];
-          let winUtils = window.windowUtils;
-          let endOfTab = winUtils.getBoundsWithoutFlushing(lastTab)[RTL_UI ? "left" : "right"];
-          if ((!RTL_UI && event.clientX > endOfTab) ||
-              (RTL_UI && event.clientX < endOfTab)) {
-            BrowserOpenTab();
-          }
-        } else {
-          return;
-        }
-
-        event.stopPropagation();
-      ]]></handler>
-
-      <handler event="keydown" group="system"><![CDATA[
-        let {altKey, shiftKey} = event;
-        let [accel, nonAccel] = AppConstants.platform == "macosx" ? [event.metaKey, event.ctrlKey] : [event.ctrlKey, event.metaKey];
-
-        let keyComboForMove = accel && shiftKey && !altKey && !nonAccel;
-        let keyComboForFocus = accel && !shiftKey && !altKey && !nonAccel;
-
-        if (!keyComboForMove && !keyComboForFocus) {
-          return;
-        }
-
-        // Don't check if the event was already consumed because tab navigation
-        // should work always for better user experience.
-        let {visibleTabs, selectedTab} = gBrowser;
-        let {arrowKeysShouldWrap} = this;
-        let focusedTabIndex = this.ariaFocusedIndex;
-        if (focusedTabIndex == -1) {
-          focusedTabIndex = visibleTabs.indexOf(selectedTab);
-        }
-        let lastFocusedTabIndex = focusedTabIndex;
-        switch (event.keyCode) {
-          case KeyEvent.DOM_VK_UP:
-            if (keyComboForMove) {
-              gBrowser.moveTabBackward();
-            } else {
-              focusedTabIndex--;
-            }
-            break;
-          case KeyEvent.DOM_VK_DOWN:
-            if (keyComboForMove) {
-              gBrowser.moveTabForward();
-            } else {
-              focusedTabIndex++;
-            }
-            break;
-          case KeyEvent.DOM_VK_RIGHT:
-          case KeyEvent.DOM_VK_LEFT:
-            if (keyComboForMove) {
-              gBrowser.moveTabOver(event);
-            } else if ((!RTL_UI && event.keyCode == KeyEvent.DOM_VK_RIGHT) ||
-                       (RTL_UI && event.keyCode == KeyEvent.DOM_VK_LEFT)) {
-              focusedTabIndex++;
-            } else {
-              focusedTabIndex--;
-            }
-            break;
-          case KeyEvent.DOM_VK_HOME:
-            if (keyComboForMove) {
-              gBrowser.moveTabToStart();
-            } else {
-              focusedTabIndex = 0;
-            }
-            break;
-          case KeyEvent.DOM_VK_END:
-            if (keyComboForMove) {
-              gBrowser.moveTabToEnd();
-            } else {
-              focusedTabIndex = visibleTabs.length - 1;
-            }
-            break;
-          case KeyEvent.DOM_VK_SPACE:
-            if (visibleTabs[lastFocusedTabIndex].multiselected) {
-              gBrowser.removeFromMultiSelectedTabs(visibleTabs[lastFocusedTabIndex]);
-            } else {
-              gBrowser.addToMultiSelectedTabs(visibleTabs[lastFocusedTabIndex], false);
-            }
-            break;
-          default:
-            // Consume the keydown event for the above keyboard
-            // shortcuts only.
-            return;
-        }
-
-        if (arrowKeysShouldWrap) {
-          if (focusedTabIndex >= visibleTabs.length) {
-            focusedTabIndex = 0;
-          } else if (focusedTabIndex < 0) {
-            focusedTabIndex = visibleTabs.length - 1;
-          }
-        } else {
-          focusedTabIndex = Math.min(visibleTabs.length - 1, Math.max(0, focusedTabIndex));
-        }
-
-        if (keyComboForFocus &&
-            focusedTabIndex != lastFocusedTabIndex) {
-          this.ariaFocusedItem = visibleTabs[focusedTabIndex];
-        }
-
-        event.preventDefault();
-      ]]></handler>
-
-      <handler event="dragstart"><![CDATA[
-        var tab = this._getDragTargetTab(event, false);
-        if (!tab || this._isCustomizing)
-          return;
-
-        let selectedTabs = gBrowser.selectedTabs;
-        let otherSelectedTabs = selectedTabs.filter(selectedTab => selectedTab != tab);
-        let dataTransferOrderedTabs = [tab].concat(otherSelectedTabs);
-
-        let dt = event.dataTransfer;
-        for (let i = 0; i < dataTransferOrderedTabs.length; i++) {
-          let dtTab = dataTransferOrderedTabs[i];
-
-          dt.mozSetDataAt(TAB_DROP_TYPE, dtTab, i);
-          let dtBrowser = dtTab.linkedBrowser;
-
-          // We must not set text/x-moz-url or text/plain data here,
-          // otherwise trying to detach the tab by dropping it on the desktop
-          // may result in an "internet shortcut"
-          dt.mozSetDataAt("text/x-moz-text-internal", dtBrowser.currentURI.spec, i);
-        }
-
-        // Set the cursor to an arrow during tab drags.
-        dt.mozCursor = "default";
-
-        // Set the tab as the source of the drag, which ensures we have a stable
-        // node to deliver the `dragend` event.  See bug 1345473.
-        dt.addElement(tab);
-
-        if (tab.multiselected) {
-          this._groupSelectedTabs(tab);
-        }
-
-        // Create a canvas to which we capture the current tab.
-        // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired
-        // canvas size (in CSS pixels) to the window's backing resolution in order
-        // to get a full-resolution drag image for use on HiDPI displays.
-        let windowUtils = window.windowUtils;
-        let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;
-        let canvas = this._dndCanvas;
-        if (!canvas) {
-          this._dndCanvas = canvas =
-            document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
-          canvas.style.width = "100%";
-          canvas.style.height = "100%";
-          canvas.mozOpaque = true;
-        }
-
-        canvas.width = 160 * scale;
-        canvas.height = 90 * scale;
-        let toDrag = canvas;
-        let dragImageOffset = -16;
-        let browser = tab.linkedBrowser;
-        if (gMultiProcessBrowser) {
-          var context = canvas.getContext("2d");
-          context.fillStyle = "white";
-          context.fillRect(0, 0, canvas.width, canvas.height);
-
-          let captureListener;
-          let platform = AppConstants.platform;
-          // On Windows and Mac we can update the drag image during a drag
-          // using updateDragImage. On Linux, we can use a panel.
-          if (platform == "win" || platform == "macosx") {
-            captureListener = function() {
-              dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);
-            };
-          } else {
-            // Create a panel to use it in setDragImage
-            // which will tell xul to render a panel that follows
-            // the pointer while a dnd session is on.
-            if (!this._dndPanel) {
-              this._dndCanvas = canvas;
-              this._dndPanel = document.createXULElement("panel");
-              this._dndPanel.className = "dragfeedback-tab";
-              this._dndPanel.setAttribute("type", "drag");
-              let wrapper = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
-              wrapper.style.width = "160px";
-              wrapper.style.height = "90px";
-              wrapper.appendChild(canvas);
-              this._dndPanel.appendChild(wrapper);
-              document.documentElement.appendChild(this._dndPanel);
-            }
-            toDrag = this._dndPanel;
-          }
-          // PageThumb is async with e10s but that's fine
-          // since we can update the image during the dnd.
-          PageThumbs.captureToCanvas(browser, canvas, captureListener);
-        } else {
-          // For the non e10s case we can just use PageThumbs
-          // sync, so let's use the canvas for setDragImage.
-          PageThumbs.captureToCanvas(browser, canvas);
-          dragImageOffset = dragImageOffset * scale;
-        }
-        dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);
-
-        // _dragData.offsetX/Y give the coordinates that the mouse should be
-        // positioned relative to the corner of the new window created upon
-        // dragend such that the mouse appears to have the same position
-        // relative to the corner of the dragged tab.
-        function clientX(ele) {
-          return ele.getBoundingClientRect().left;
-        }
-        let tabOffsetX = clientX(tab) - clientX(this);
-        tab._dragData = {
-          offsetX: event.screenX - window.screenX - tabOffsetX,
-          offsetY: event.screenY - window.screenY,
-          scrollX: this.arrowScrollbox.scrollbox.scrollLeft,
-          screenX: event.screenX,
-          movingTabs: (tab.multiselected ? gBrowser.selectedTabs : [tab])
-                      .filter(t => t.pinned == tab.pinned),
-        };
-
-        event.stopPropagation();
-      ]]></handler>
-
-      <handler event="dragover"><![CDATA[
-        var effects = this._getDropEffectForTabDrag(event);
-
-        var ind = this._tabDropIndicator;
-        if (effects == "" || effects == "none") {
+          if (!this._dragTime)
+            this._dragTime = Date.now();
+          if (Date.now() >= this._dragTime + this._dragOverDelay)
+            this.selectedItem = tab;
           ind.collapsed = true;
           return;
         }
-        event.preventDefault();
-        event.stopPropagation();
-
-        var arrowScrollbox = this.arrowScrollbox;
+      }
 
-        // autoscroll the tab strip if we drag over the scroll
-        // buttons, even if we aren't dragging a tab, but then
-        // return to avoid drawing the drop indicator
-        var pixelsToScroll = 0;
-        if (this.getAttribute("overflow") == "true") {
-          var targetAnonid = event.originalTarget.getAttribute("anonid");
-          switch (targetAnonid) {
-            case "scrollbutton-up":
-              pixelsToScroll = arrowScrollbox.scrollIncrement * -1;
-              break;
-            case "scrollbutton-down":
-              pixelsToScroll = arrowScrollbox.scrollIncrement;
-              break;
+      var rect = arrowScrollbox.getBoundingClientRect();
+      var newMargin;
+      if (pixelsToScroll) {
+        // if we are scrolling, put the drop indicator at the edge
+        // so that it doesn't jump while scrolling
+        let scrollRect = arrowScrollbox.scrollClientRect;
+        let minMargin = scrollRect.left - rect.left;
+        let maxMargin = Math.min(minMargin + scrollRect.width,
+                                 scrollRect.right);
+        if (RTL_UI) {
+          [minMargin, maxMargin] = [this.clientWidth - maxMargin,
+                                    this.clientWidth - minMargin];
+        }
+        newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
+      } else {
+        let newIndex = this._getDropIndex(event, effects == "link");
+        let children = this.allTabs;
+        if (newIndex == children.length) {
+          let tabRect = children[newIndex - 1].getBoundingClientRect();
+          if (RTL_UI) {
+            newMargin = rect.right - tabRect.left;
+          } else {
+            newMargin = tabRect.right - rect.left;
           }
-          if (pixelsToScroll)
-            arrowScrollbox.scrollByPixels((RTL_UI ? -1 : 1) * pixelsToScroll, true);
-        }
-
-        let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
-        if ((effects == "move" || effects == "copy") &&
-            this == draggedTab.parentNode) {
-          ind.collapsed = true;
-
-          if (!this._isGroupTabsAnimationOver()) {
-            // Wait for grouping tabs animation to finish
-            return;
-          }
-          this._finishGroupSelectedTabs(draggedTab);
-
-          if (effects == "move") {
-            this._animateTabMove(event);
-            return;
+        } else {
+          let tabRect = children[newIndex].getBoundingClientRect();
+          if (RTL_UI) {
+            newMargin = rect.right - tabRect.right;
+          } else {
+            newMargin = tabRect.left - rect.left;
           }
         }
+      }
 
-        this._finishAnimateTabMove();
+      ind.collapsed = false;
 
-        if (effects == "link") {
-          let tab = this._getDragTargetTab(event, true);
-          if (tab) {
-            if (!this._dragTime)
-              this._dragTime = Date.now();
-            if (Date.now() >= this._dragTime + this._dragOverDelay)
-              this.selectedItem = tab;
-            ind.collapsed = true;
-            return;
-          }
-        }
+      newMargin += ind.clientWidth / 2;
+      if (RTL_UI) {
+        newMargin *= -1;
+      }
+
+      ind.style.transform = "translate(" + Math.round(newMargin) + "px)";
+      ind.style.marginInlineStart = (-ind.clientWidth) + "px";
+    });
 
-        var rect = arrowScrollbox.getBoundingClientRect();
-        var newMargin;
-        if (pixelsToScroll) {
-          // if we are scrolling, put the drop indicator at the edge
-          // so that it doesn't jump while scrolling
-          let scrollRect = arrowScrollbox.scrollClientRect;
-          let minMargin = scrollRect.left - rect.left;
-          let maxMargin = Math.min(minMargin + scrollRect.width,
-                                   scrollRect.right);
-          if (RTL_UI) {
-            [minMargin, maxMargin] = [this.clientWidth - maxMargin,
-                                      this.clientWidth - minMargin];
-          }
-          newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
-        } else {
-          let newIndex = this._getDropIndex(event, effects == "link");
-          if (newIndex == this.children.length) {
-            let tabRect = this.children[newIndex - 1].getBoundingClientRect();
-            if (RTL_UI) {
-              newMargin = rect.right - tabRect.left;
-            } else {
-              newMargin = tabRect.right - rect.left;
-            }
-          } else {
-            let tabRect = this.children[newIndex].getBoundingClientRect();
-            if (RTL_UI) {
-              newMargin = rect.right - tabRect.right;
-            } else {
-              newMargin = tabRect.left - rect.left;
-            }
-          }
+    this.addEventListener("drop", (event) => {
+      var dt = event.dataTransfer;
+      var dropEffect = dt.dropEffect;
+      var draggedTab;
+      let movingTabs;
+      if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move
+        draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+        // not our drop then
+        if (!draggedTab)
+          return;
+        movingTabs = draggedTab._dragData.movingTabs;
+        draggedTab.container._finishGroupSelectedTabs(draggedTab);
+      }
+
+      this._tabDropIndicator.collapsed = true;
+      event.stopPropagation();
+      if (draggedTab && dropEffect == "copy") {
+        // copy the dropped tab (wherever it's from)
+        let newIndex = this._getDropIndex(event, false);
+        let draggedTabCopy;
+        for (let tab of movingTabs) {
+          let newTab = gBrowser.duplicateTab(tab);
+          gBrowser.moveTabTo(newTab, newIndex++);
+          if (tab == draggedTab)
+            draggedTabCopy = newTab;
+        }
+        if (draggedTab.container != this || event.shiftKey) {
+          this.selectedItem = draggedTabCopy;
+        }
+      } else if (draggedTab && draggedTab.container == this) {
+        let oldTranslateX = Math.round(draggedTab._dragData.translateX);
+        let tabWidth = Math.round(draggedTab._dragData.tabWidth);
+        let translateOffset = oldTranslateX % tabWidth;
+        let newTranslateX = oldTranslateX - translateOffset;
+        if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {
+          newTranslateX += tabWidth;
+        } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {
+          newTranslateX -= tabWidth;
         }
 
-        ind.collapsed = false;
-
-        newMargin += ind.clientWidth / 2;
-        if (RTL_UI) {
-          newMargin *= -1;
-        }
-
-        ind.style.transform = "translate(" + Math.round(newMargin) + "px)";
-        ind.style.marginInlineStart = (-ind.clientWidth) + "px";
-      ]]></handler>
-
-      <handler event="drop"><![CDATA[
-        var dt = event.dataTransfer;
-        var dropEffect = dt.dropEffect;
-        var draggedTab;
-        let movingTabs;
-        if (dt.mozTypesAt(0)[0] == TAB_DROP_TYPE) { // tab copy or move
-          draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
-          // not our drop then
-          if (!draggedTab)
-            return;
-          movingTabs = draggedTab._dragData.movingTabs;
-          draggedTab.parentNode._finishGroupSelectedTabs(draggedTab);
+        let dropIndex = "animDropIndex" in draggedTab._dragData &&
+                        draggedTab._dragData.animDropIndex;
+        let incrementDropIndex = true;
+        if (dropIndex && dropIndex > movingTabs[0]._tPos) {
+          dropIndex--;
+          incrementDropIndex = false;
         }
 
-        this._tabDropIndicator.collapsed = true;
-        event.stopPropagation();
-        if (draggedTab && dropEffect == "copy") {
-          // copy the dropped tab (wherever it's from)
-          let newIndex = this._getDropIndex(event, false);
-          let draggedTabCopy;
+        let animate = gBrowser.animationsEnabled;
+        if (oldTranslateX && oldTranslateX != newTranslateX && animate) {
           for (let tab of movingTabs) {
-            let newTab = gBrowser.duplicateTab(tab);
-            gBrowser.moveTabTo(newTab, newIndex++);
-            if (tab == draggedTab)
-              draggedTabCopy = newTab;
-          }
-          if (draggedTab.parentNode != this || event.shiftKey) {
-            this.selectedItem = draggedTabCopy;
-          }
-        } else if (draggedTab && draggedTab.parentNode == this) {
-          let oldTranslateX = Math.round(draggedTab._dragData.translateX);
-          let tabWidth = Math.round(draggedTab._dragData.tabWidth);
-          let translateOffset = oldTranslateX % tabWidth;
-          let newTranslateX = oldTranslateX - translateOffset;
-          if (oldTranslateX > 0 && translateOffset > tabWidth / 2) {
-            newTranslateX += tabWidth;
-          } else if (oldTranslateX < 0 && -translateOffset > tabWidth / 2) {
-            newTranslateX -= tabWidth;
-          }
+            tab.setAttribute("tabdrop-samewindow", "true");
+            tab.style.transform = "translateX(" + newTranslateX + "px)";
+            let onTransitionEnd = transitionendEvent => {
+              if (transitionendEvent.propertyName != "transform" ||
+                  transitionendEvent.originalTarget != tab) {
+                    return;
+              }
+              tab.removeEventListener("transitionend", onTransitionEnd);
 
-          let dropIndex = "animDropIndex" in draggedTab._dragData &&
-                          draggedTab._dragData.animDropIndex;
-          let incrementDropIndex = true;
-          if (dropIndex && dropIndex > movingTabs[0]._tPos) {
-            dropIndex--;
-            incrementDropIndex = false;
-          }
+              tab.removeAttribute("tabdrop-samewindow");
 
-          let animate = gBrowser.animationsEnabled;
-          if (oldTranslateX && oldTranslateX != newTranslateX && animate) {
-            for (let tab of movingTabs) {
-              tab.setAttribute("tabdrop-samewindow", "true");
-              tab.style.transform = "translateX(" + newTranslateX + "px)";
-              let onTransitionEnd = transitionendEvent => {
-                if (transitionendEvent.propertyName != "transform" ||
-                    transitionendEvent.originalTarget != tab) {
-                  return;
-                }
-                tab.removeEventListener("transitionend", onTransitionEnd);
-
-                tab.removeAttribute("tabdrop-samewindow");
-
-                this._finishAnimateTabMove();
-                if (dropIndex !== false) {
-                  gBrowser.moveTabTo(tab, dropIndex);
-                  if (incrementDropIndex)
-                    dropIndex++;
-                }
-
-                gBrowser.syncThrobberAnimations(tab);
-              };
-              tab.addEventListener("transitionend", onTransitionEnd);
-            }
-          } else {
-            this._finishAnimateTabMove();
-            if (dropIndex !== false) {
-              for (let tab of movingTabs) {
+              this._finishAnimateTabMove();
+              if (dropIndex !== false) {
                 gBrowser.moveTabTo(tab, dropIndex);
                 if (incrementDropIndex)
                   dropIndex++;
               }
+
+              gBrowser.syncThrobberAnimations(tab);
+            };
+            tab.addEventListener("transitionend", onTransitionEnd);
+          }
+        } else {
+          this._finishAnimateTabMove();
+          if (dropIndex !== false) {
+            for (let tab of movingTabs) {
+              gBrowser.moveTabTo(tab, dropIndex);
+              if (incrementDropIndex)
+                dropIndex++;
             }
           }
-        } else if (draggedTab) {
-          let newIndex = this._getDropIndex(event, false);
-          let newTabs = [];
-          for (let tab of movingTabs) {
-            let newTab = gBrowser.adoptTab(tab, newIndex++, tab == draggedTab);
-            newTabs.push(newTab);
+        }
+      } else if (draggedTab) {
+        let newIndex = this._getDropIndex(event, false);
+        let newTabs = [];
+        for (let tab of movingTabs) {
+          let newTab = gBrowser.adoptTab(tab, newIndex++, tab == draggedTab);
+          newTabs.push(newTab);
+        }
+
+        // Restore tab selection
+        gBrowser.addRangeToMultiSelectedTabs(newTabs[0], newTabs[newTabs.length - 1]);
+      } else {
+        // Pass true to disallow dropping javascript: or data: urls
+        let links;
+        try {
+          links = browserDragAndDrop.dropLinks(event, true);
+        } catch (ex) {}
+
+        if (!links || links.length === 0)
+          return;
+
+        let inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
+        if (event.shiftKey)
+          inBackground = !inBackground;
+
+        let targetTab = this._getDragTargetTab(event, true);
+        let userContextId = this.selectedItem.getAttribute("usercontextid");
+        let replace = !!targetTab;
+        let newIndex = this._getDropIndex(event, true);
+        let urls = links.map(link => link.url);
+
+        let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);
+
+        (async () => {
+          if (urls.length >= Services.prefs.getIntPref("browser.tabs.maxOpenBeforeWarn")) {
+            // Sync dialog cannot be used inside drop event handler.
+            let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(urls.length,
+                                                                        window);
+            if (!answer) {
+              return;
+            }
           }
 
-          // Restore tab selection
-          gBrowser.addRangeToMultiSelectedTabs(newTabs[0], newTabs[newTabs.length - 1]);
-        } else {
-          // Pass true to disallow dropping javascript: or data: urls
-          let links;
-          try {
-            links = browserDragAndDrop.dropLinks(event, true);
-          } catch (ex) {}
+          gBrowser.loadTabs(urls, {
+            inBackground,
+            replace,
+            allowThirdPartyFixup: true,
+            targetTab,
+            newIndex,
+            userContextId,
+            triggeringPrincipal,
+          });
+        })();
+      }
+
+      if (draggedTab) {
+        delete draggedTab._dragData;
+      }
+    });
+
+    this.addEventListener("dragend", (event) => {
+      var dt = event.dataTransfer;
+      var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+
+      // Prevent this code from running if a tabdrop animation is
+      // running since calling _finishAnimateTabMove would clear
+      // any CSS transition that is running.
+      if (draggedTab.hasAttribute("tabdrop-samewindow"))
+        return;
+
+      this._finishGroupSelectedTabs(draggedTab);
+      this._finishAnimateTabMove();
+
+      if (dt.mozUserCancelled || dt.dropEffect != "none" || this._isCustomizing) {
+        delete draggedTab._dragData;
+        return;
+      }
+
+      // Disable detach within the browser toolbox
+      var eX = event.screenX;
+      var eY = event.screenY;
+      var wX = window.screenX;
+      // check if the drop point is horizontally within the window
+      if (eX > wX && eX < (wX + window.outerWidth)) {
+        // also avoid detaching if the the tab was dropped too close to
+        // the tabbar (half a tab)
+        let rect = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox);
+        let detachTabThresholdY = window.screenY + rect.top + 1.5 * rect.height;
+        if (eY < detachTabThresholdY && eY > window.screenY)
+          return;
+      }
+
+      // screen.availLeft et. al. only check the screen that this window is on,
+      // but we want to look at the screen the tab is being dropped onto.
+      var screen = Cc["@mozilla.org/gfx/screenmanager;1"]
+                               .getService(Ci.nsIScreenManager)
+                               .screenForRect(eX, eY, 1, 1);
+      var fullX = {},
+          fullY = {},
+          fullWidth = {},
+          fullHeight = {};
+      var availX = {},
+          availY = {},
+          availWidth = {},
+          availHeight = {};
+      // get full screen rect and available rect, both in desktop pix
+      screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);
+      screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);
+
+      // scale factor to convert desktop pixels to CSS px
+      var scaleFactor =
+      screen.contentsScaleFactor / screen.defaultCSSScaleFactor;
+      // synchronize CSS-px top-left coordinates with the screen's desktop-px
+      // coordinates, to ensure uniqueness across multiple screens
+      // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()
+      // and related methods)
+      availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;
+      availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;
+      availWidth.value *= scaleFactor;
+      availHeight.value *= scaleFactor;
+
+      // ensure new window entirely within screen
+      var winWidth = Math.min(window.outerWidth, availWidth.value);
+      var winHeight = Math.min(window.outerHeight, availHeight.value);
+      var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),
+                          availX.value + availWidth.value - winWidth);
+      var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),
+                         availY.value + availHeight.value - winHeight);
+
+      delete draggedTab._dragData;
 
-          if (!links || links.length === 0)
-            return;
+      if (gBrowser.tabs.length == 1) {
+        // resize _before_ move to ensure the window fits the new screen.  if
+        // the window is too large for its screen, the window manager may do
+        // automatic repositioning.
+        window.resizeTo(winWidth, winHeight);
+        window.moveTo(left, top);
+        window.focus();
+      } else {
+        let props = { screenX: left, screenY: top, suppressanimation: 1 };
+        if (AppConstants.platform != "win") {
+          props.outerWidth = winWidth;
+          props.outerHeight = winHeight;
+        }
+        gBrowser.replaceTabsWithWindow(draggedTab, props);
+      }
+      event.stopPropagation();
+    });
+
+    this.addEventListener("dragexit", (event) => {
+      this._dragTime = 0;
+
+      // This does not work at all (see bug 458613)
+      var target = event.relatedTarget;
+      while (target && target != this)
+        target = target.parentNode;
+      if (target)
+        return;
+
+      this._tabDropIndicator.collapsed = true;
+      event.stopPropagation();
+    });
+  }
+
+  get tabbox() {
+    return document.getElementById("tabbrowser-tabbox");
+  }
+
+  get newTabButton() {
+    return this.querySelector(".tabs-newtab-button");
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
 
-          let inBackground = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
-          if (event.shiftKey)
-            inBackground = !inBackground;
+    let children = Array.from(this.children);
+    this.appendChild(MozXULElement.parseXULToFragment(`
+      <hbox class="tab-drop-indicator-box">
+        <image class="tab-drop-indicator" collapsed="true"></image>
+      </hbox>
+      <arrowscrollbox orient="horizontal" flex="1" style="min-width: 1px;" clicktoscroll="true" class="tabbrowser-arrowscrollbox">
+        <toolbarbutton class="tabs-newtab-button toolbarbutton-1" command="cmd_newNavigatorTab" onclick="checkForMiddleClick(this, event);"></toolbarbutton>
+        <spacer class="closing-tabs-spacer" style="width: 0;"></spacer>
+      </arrowscrollbox>
+    `));
+
+    this.arrowScrollbox = this.querySelector("arrowscrollbox");
+    let el = this.arrowScrollbox.firstChild;
+    for (let child of children) {
+      this.arrowScrollbox.insertBefore(child, el);
+    }
+
+    this.initializeAttributeInheritance();
+
+    this.baseConnect();
+
+    this._firstTab = null;
+    this._lastTab = null;
+    this._beforeSelectedTab = null;
+    this._beforeHoveredTab = null;
+    this._afterHoveredTab = null;
+    this._hoveredTab = null;
+    this._blockDblClick = false;
+    this._tabDropIndicator = this.querySelector(".tab-drop-indicator");
+    this._dragOverDelay = 350;
+    this._dragTime = 0;
+    this._closeButtonsUpdatePending = false;
+    this._closingTabsSpacer = this.querySelector(".closing-tabs-spacer");
+    this._tabDefaultMaxWidth = NaN;
+    this._lastTabClosedByMouse = false;
+    this._hasTabTempMaxWidth = false;
+    this._scrollButtonWidth = 0;
+    this._lastNumPinned = 0;
+    this._pinnedTabsLayoutCache = null;
+    this._animateElement = this.arrowScrollbox._scrollButtonDown;
+    this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
+    this._hiddenSoundPlayingTabs = new Set();
+
+    let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
+                "emptyPrivateTabTitle" : "emptyTabTitle";
+    this.emptyTabTitle = gTabBrowserBundle.GetStringFromName("tabs." + strId);
+
+    var tab = this.firstTab;
+    tab.label = this.emptyTabTitle;
+
+    this.newTabButton.setAttribute("tooltiptext", GetDynamicShortcutTooltipText("tabs-newtab-button"));
+
+    window.addEventListener("resize", this);
+
+    Services.prefs.addObserver("privacy.userContext", (...args) => this.observe(...args));
+    this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
 
-          let targetTab = this._getDragTargetTab(event, true);
-          let userContextId = this.selectedItem.getAttribute("usercontextid");
-          let replace = !!targetTab;
-          let newIndex = this._getDropIndex(event, true);
-          let urls = links.map(link => link.url);
+    XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
+                                          "browser.tabs.tabMinWidth", null,
+                                          (pref, prevValue, newValue) => this._tabMinWidth = newValue,
+                                          newValue => {
+                                            const LIMIT = 50;
+                                            return Math.max(newValue, LIMIT);
+                                          },
+    );
+
+    this._tabMinWidth = this._tabMinWidthPref;
+
+    XPCOMUtils.defineLazyPreferenceGetter(this, "_multiselectEnabledPref",
+                                          "browser.tabs.multiselect", null,
+                                          (pref, prevValue, newValue) => this._multiselectEnabled = newValue);
+    this._multiselectEnabled = this._multiselectEnabledPref;
+
+    this._setPositionalAttributes();
+
+    CustomizableUI.addListener(this);
+    this._updateNewTabVisibility();
+    this._initializeArrowScrollbox();
+
+    XPCOMUtils.defineLazyPreferenceGetter(this, "_closeTabByDblclick",
+                                          "browser.tabs.closeTabByDblclick", false);
+
+    if (gMultiProcessBrowser) {
+      this.tabbox.tabpanels.setAttribute("async", "true");
+    }
+  }
+
+  // Accessors for tabs.  arrowScrollbox has two non-tab elements at the
+  // end, everything else is <tab>s
+  get firstTab() {
+    let {arrowScrollbox} = this;
+    return (arrowScrollbox.children.length > 2) ? arrowScrollbox.firstChild : null;
+  }
+
+  get lastTab() {
+    let {children} = this.arrowScrollbox;
+    let {length} = children;
+    return (length > 2) ? children.item(length - 3) : null;
+  }
 
-          let triggeringPrincipal = browserDragAndDrop.getTriggeringPrincipal(event);
+  get tabCount() {
+    return this.arrowScrollbox.children.length - 2;
+  }
+
+  get allTabs() {
+    let children = Array.from(this.arrowScrollbox.children);
+    children.pop();
+    children.pop();
+    return children;
+  }
+
+  appendChild(tab) {
+    return this.insertBefore(tab, null);
+  }
+
+  insertBefore(tab, node) {
+    if (!this.arrowScrollbox) {
+      return super.insertBefore(tab, node);
+    }
+
+    let {arrowScrollbox} = this;
+    if (node == null) {
+      // we have a toolbarbutton and a space at the end of the scrollbox
+      node = arrowScrollbox.lastChild.previousSibling;
+    }
+    return arrowScrollbox.insertBefore(tab, node);
+  }
+
+  set _tabMinWidth(val) {
+    this.style.setProperty("--tab-min-width", val + "px");
+    return val;
+  }
+
+  set _multiselectEnabled(val) {
+    // Unlike boolean HTML attributes, the value of boolean ARIA attributes actually matters.
+    this.setAttribute("aria-multiselectable", !!val);
+    return val;
+  }
+
+  get _multiselectEnabled() {
+    return this.getAttribute("aria-multiselectable") == "true";
+  }
+
+  get _isCustomizing() {
+    return document.documentElement.getAttribute("customizing") == "true";
+  }
 
-          (async () => {
-            if (urls.length >= Services.prefs.getIntPref("browser.tabs.maxOpenBeforeWarn")) {
-              // Sync dialog cannot be used inside drop event handler.
-              let answer = await OpenInTabsUtils.promiseConfirmOpenInTabs(urls.length,
-                                                                          window);
-              if (!answer) {
-                return;
-              }
+  _initializeArrowScrollbox() {
+    let arrowScrollbox = this.arrowScrollbox;
+    arrowScrollbox.addEventListener("underflow", event => {
+      // Ignore underflow events:
+      // - from nested scrollable elements
+      // - for vertical orientation
+      // - corresponding to an overflow event that we ignored
+      if (event.originalTarget != arrowScrollbox.scrollbox ||
+          event.detail == 0 ||
+          !this.hasAttribute("overflow")) {
+            return;
+      }
+
+      this.removeAttribute("overflow");
+
+      if (this._lastTabClosedByMouse) {
+        this._expandSpacerBy(this._scrollButtonWidth);
+      }
+
+      for (let tab of Array.from(gBrowser._removingTabs)) {
+        gBrowser.removeTab(tab);
+      }
+
+      this._positionPinnedTabs();
+    }, true);
+
+    arrowScrollbox.addEventListener("overflow", event => {
+      // Ignore overflow events:
+      // - from nested scrollable elements
+      // - for vertical orientation
+      if (event.originalTarget != arrowScrollbox.scrollbox ||
+          event.detail == 0) {
+            return;
+      }
+
+      this.setAttribute("overflow", "true");
+      this._positionPinnedTabs();
+      this._handleTabSelect(true);
+    });
+
+    // Override scrollbox.xml method, since our scrollbox's children are
+    // inherited from the scrollbox binding parent (this).
+    arrowScrollbox._getScrollableElements = () => {
+      return Array.prototype.filter.call(this.allTabs, arrowScrollbox._canScrollToElement);
+    };
+    arrowScrollbox._canScrollToElement = tab => {
+      return !tab._pinnedUnscrollable && !tab.hidden;
+    };
+  }
+
+  observe(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "nsPref:changed":
+        // This is has to deal with changes in
+        // privacy.userContext.enabled and
+        // privacy.userContext.longPressBehavior.
+        let containersEnabled = Services.prefs.getBoolPref("privacy.userContext.enabled") &&
+                                !PrivateBrowsingUtils.isWindowPrivate(window);
+
+        // This pref won't change so often, so just recreate the menu.
+        let longPressBehavior = Services.prefs.getIntPref("privacy.userContext.longPressBehavior");
+
+        // If longPressBehavior pref is set to 0 (or any invalid value)
+        // long press menu is disabled.
+        if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
+          containersEnabled = false;
+        }
+
+        // There are separate "new tab" buttons for when the tab strip
+        // is overflowed and when it is not.  Attach the long click
+        // popup to both of them.
+        const newTab = document.getElementById("new-tab-button");
+        const newTab2 = this.newTabButton;
+
+        for (let parent of [newTab, newTab2]) {
+          if (!parent)
+            continue;
+
+          gClickAndHoldListenersOnElement.remove(parent);
+          parent.removeAttribute("type");
+          if (parent.menupopup) {
+            parent.menupopup.remove();
+          }
+
+          if (containersEnabled) {
+            let popup = document.createElementNS(
+              "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+              "menupopup");
+            if (parent.id) {
+              popup.id = "newtab-popup";
+            } else {
+              popup.setAttribute("anonid", "newtab-popup");
+            }
+            popup.className = "new-tab-popup";
+            popup.setAttribute("position", "after_end");
+            popup.addEventListener("popupshowing", event => {
+              createUserContextMenu(event, {
+                useAccessKeys: false,
+                showDefaultTab: Services.prefs.getIntPref("privacy.userContext.longPressBehavior") == 1,
+              });
+            });
+            parent.prepend(popup);
+
+            // longPressBehavior == 2 means that the menu is shown after X
+            // millisecs. Otherwise, with 1, the menu is open immediatelly.
+            if (longPressBehavior == 2) {
+              gClickAndHoldListenersOnElement.add(parent);
             }
 
-            gBrowser.loadTabs(urls, {
-              inBackground,
-              replace,
-              allowThirdPartyFixup: true,
-              targetTab,
-              newIndex,
-              userContextId,
-              triggeringPrincipal,
-            });
-          })();
+            parent.setAttribute("type", "menu");
+          }
         }
 
-        if (draggedTab) {
-          delete draggedTab._dragData;
-        }
-      ]]></handler>
+        break;
+    }
+  }
+
+  _getVisibleTabs() {
+    // Cannot access gBrowser before it's initialized.
+    if (!gBrowser) {
+      return [this.firstElementChild];
+    }
+
+    return gBrowser.visibleTabs;
+  }
 
-      <handler event="dragend"><![CDATA[
-        var dt = event.dataTransfer;
-        var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+  _setPositionalAttributes() {
+    let visibleTabs = this._getVisibleTabs();
+    if (!visibleTabs.length) {
+      return;
+    }
+    let selectedTab = this.selectedItem;
+    let selectedIndex = visibleTabs.indexOf(selectedTab);
+    if (this._beforeSelectedTab) {
+      this._beforeSelectedTab.removeAttribute("beforeselected-visible");
+    }
+
+    if (selectedTab.closing || selectedIndex <= 0) {
+      this._beforeSelectedTab = null;
+    } else {
+      let beforeSelectedTab = visibleTabs[selectedIndex - 1];
+      let separatedByScrollButton = this.getAttribute("overflow") == "true" &&
+                                    beforeSelectedTab.pinned && !selectedTab.pinned;
+      if (!separatedByScrollButton) {
+        this._beforeSelectedTab = beforeSelectedTab;
+        this._beforeSelectedTab.setAttribute("beforeselected-visible",
+                                             "true");
+      }
+    }
 
-        // Prevent this code from running if a tabdrop animation is
-        // running since calling _finishAnimateTabMove would clear
-        // any CSS transition that is running.
-        if (draggedTab.hasAttribute("tabdrop-samewindow"))
-          return;
+    if (this._firstTab)
+      this._firstTab.removeAttribute("first-visible-tab");
+    this._firstTab = visibleTabs[0];
+    this._firstTab.setAttribute("first-visible-tab", "true");
+    if (this._lastTab)
+      this._lastTab.removeAttribute("last-visible-tab");
+    this._lastTab = visibleTabs[visibleTabs.length - 1];
+    this._lastTab.setAttribute("last-visible-tab", "true");
+
+    let hoveredTab = this._hoveredTab;
+    if (hoveredTab) {
+      hoveredTab._mouseleave();
+    }
+    hoveredTab = this.querySelector("tab:hover");
+    if (hoveredTab) {
+      hoveredTab._mouseenter();
+    }
 
-        this._finishGroupSelectedTabs(draggedTab);
-        this._finishAnimateTabMove();
+    // Update before-multiselected attributes.
+    // gBrowser may not be initialized yet, so avoid using it
+    for (let i = 0; i < visibleTabs.length - 1; i++) {
+      let tab = visibleTabs[i];
+      let nextTab = visibleTabs[i + 1];
+      tab.removeAttribute("before-multiselected");
+      if (nextTab.multiselected) {
+        tab.setAttribute("before-multiselected", "true");
+      }
+    }
+  }
 
-        if (dt.mozUserCancelled || dt.dropEffect != "none" || this._isCustomizing) {
-          delete draggedTab._dragData;
+  _updateCloseButtons() {
+    // If we're overflowing, tabs are at their minimum widths.
+    if (this.getAttribute("overflow") == "true") {
+      this.setAttribute("closebuttons", "activetab");
+      return;
+    }
+
+    if (this._closeButtonsUpdatePending) {
+      return;
+    }
+    this._closeButtonsUpdatePending = true;
+
+    // Wait until after the next paint to get current layout data from
+    // getBoundsWithoutFlushing.
+    window.requestAnimationFrame(() => {
+      window.requestAnimationFrame(() => {
+        this._closeButtonsUpdatePending = false;
+
+        // The scrollbox may have started overflowing since we checked
+        // overflow earlier, so check again.
+        if (this.getAttribute("overflow") == "true") {
+          this.setAttribute("closebuttons", "activetab");
           return;
         }
 
-        // Disable detach within the browser toolbox
-        var eX = event.screenX;
-        var eY = event.screenY;
-        var wX = window.screenX;
-        // check if the drop point is horizontally within the window
-        if (eX > wX && eX < (wX + window.outerWidth)) {
-          // also avoid detaching if the the tab was dropped too close to
-          // the tabbar (half a tab)
-          let rect = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox);
-          let detachTabThresholdY = window.screenY + rect.top + 1.5 * rect.height;
-          if (eY < detachTabThresholdY && eY > window.screenY)
-            return;
+        // Check if tab widths are below the threshold where we want to
+        // remove close buttons from background tabs so that people don't
+        // accidentally close tabs by selecting them.
+        let rect = ele => {
+          return window.windowUtils.getBoundsWithoutFlushing(ele);
+        };
+        let tab = this._getVisibleTabs()[gBrowser._numPinnedTabs];
+        if (tab && rect(tab).width <= this._tabClipWidth) {
+          this.setAttribute("closebuttons", "activetab");
+        } else {
+          this.removeAttribute("closebuttons");
+        }
+      });
+    });
+  }
+
+  _updateHiddenTabsStatus() {
+    if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {
+      this.setAttribute("hashiddentabs", "true");
+    } else {
+      this.removeAttribute("hashiddentabs");
+    }
+  }
+
+  _handleTabSelect(aInstant) {
+    let selectedTab = this.selectedItem;
+    if (this.getAttribute("overflow") == "true")
+      this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);
+
+    selectedTab._notselectedsinceload = false;
+  }
+
+  /**
+   * Try to keep the active tab's close button under the mouse cursor
+   */
+  _lockTabSizing(aTab, aTabWidth) {
+    let tabs = this._getVisibleTabs();
+    if (!tabs.length) {
+      return;
+    }
+
+    var isEndTab = (aTab._tPos > tabs[tabs.length - 1]._tPos);
+
+    if (!this._tabDefaultMaxWidth) {
+      this._tabDefaultMaxWidth =
+      parseFloat(window.getComputedStyle(aTab).maxWidth);
+    }
+    this._lastTabClosedByMouse = true;
+    this._scrollButtonWidth = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox._scrollButtonDown).width;
+
+    if (this.getAttribute("overflow") == "true") {
+      // Don't need to do anything if we're in overflow mode and aren't scrolled
+      // all the way to the right, or if we're closing the last tab.
+      if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {
+        return;
+      }
+      // If the tab has an owner that will become the active tab, the owner will
+      // be to the left of it, so we actually want the left tab to slide over.
+      // This can't be done as easily in non-overflow mode, so we don't bother.
+      if (aTab.owner) {
+        return;
+      }
+      this._expandSpacerBy(aTabWidth);
+    } else { // non-overflow mode
+      // Locking is neither in effect nor needed, so let tabs expand normally.
+      if (isEndTab && !this._hasTabTempMaxWidth) {
+        return;
+      }
+      let numPinned = gBrowser._numPinnedTabs;
+      // Force tabs to stay the same width, unless we're closing the last tab,
+      // which case we need to let them expand just enough so that the overall
+      // tabbar width is the same.
+      if (isEndTab) {
+        let numNormalTabs = tabs.length - numPinned;
+        aTabWidth = aTabWidth * (numNormalTabs + 1) / numNormalTabs;
+        if (aTabWidth > this._tabDefaultMaxWidth) {
+          aTabWidth = this._tabDefaultMaxWidth;
+        }
+      }
+      aTabWidth += "px";
+      let tabsToReset = [];
+      for (let i = numPinned; i < tabs.length; i++) {
+        let tab = tabs[i];
+        tab.style.setProperty("max-width", aTabWidth, "important");
+        if (!isEndTab) { // keep tabs the same width
+          tab.style.transition = "none";
+          tabsToReset.push(tab);
+        }
+      }
+
+      if (tabsToReset.length) {
+        window.promiseDocumentFlushed(() => {}).then(() => {
+          window.requestAnimationFrame(() => {
+            for (let tab of tabsToReset) {
+              tab.style.transition = "";
+            }
+          });
+        });
+      }
+
+      this._hasTabTempMaxWidth = true;
+      gBrowser.addEventListener("mousemove", this);
+      window.addEventListener("mouseout", this);
+    }
+  }
+
+  _expandSpacerBy(pixels) {
+    let spacer = this._closingTabsSpacer;
+    spacer.style.width = parseFloat(spacer.style.width) + pixels + "px";
+    this.setAttribute("using-closing-tabs-spacer", "true");
+    gBrowser.addEventListener("mousemove", this);
+    window.addEventListener("mouseout", this);
+  }
+
+  _unlockTabSizing() {
+    gBrowser.removeEventListener("mousemove", this);
+    window.removeEventListener("mouseout", this);
+
+    if (this._hasTabTempMaxWidth) {
+      this._hasTabTempMaxWidth = false;
+      let tabs = this._getVisibleTabs();
+      for (let i = 0; i < tabs.length; i++) {
+        tabs[i].style.maxWidth = "";
+      }
+    }
+
+    if (this.hasAttribute("using-closing-tabs-spacer")) {
+      this.removeAttribute("using-closing-tabs-spacer");
+      this._closingTabsSpacer.style.width = 0;
+    }
+  }
+
+  uiDensityChanged() {
+    this._positionPinnedTabs();
+    this._updateCloseButtons();
+    this._handleTabSelect(true);
+  }
+
+  _positionPinnedTabs() {
+    let numPinned = gBrowser._numPinnedTabs;
+    let doPosition = this.getAttribute("overflow") == "true" &&
+                     this._getVisibleTabs().length > numPinned &&
+                     numPinned > 0;
+    let tabs = this.allTabs;
+
+    if (doPosition) {
+      this.setAttribute("positionpinnedtabs", "true");
+
+      let layoutData = this._pinnedTabsLayoutCache;
+      let uiDensity = document.documentElement.getAttribute("uidensity");
+      if (!layoutData ||
+          layoutData.uiDensity != uiDensity) {
+            let arrowScrollbox = this.arrowScrollbox;
+            layoutData = this._pinnedTabsLayoutCache = {
+              uiDensity,
+              pinnedTabWidth: this.firstTab.getBoundingClientRect().width,
+              scrollButtonWidth: arrowScrollbox._scrollButtonDown.getBoundingClientRect().width,
+            };
+      }
+
+      let width = 0;
+      for (let i = numPinned - 1; i >= 0; i--) {
+        let tab = tabs[i];
+        width += layoutData.pinnedTabWidth;
+        tab.style.setProperty("margin-inline-start",
+                             -(width + layoutData.scrollButtonWidth) + "px", "important");
+        tab._pinnedUnscrollable = true;
+      }
+      this.style.paddingInlineStart = width + "px";
+    } else {
+      this.removeAttribute("positionpinnedtabs");
+
+      for (let i = 0; i < numPinned; i++) {
+        let tab = tabs[i];
+        tab.style.marginInlineStart = "";
+        tab._pinnedUnscrollable = false;
+      }
+
+      this.style.paddingInlineStart = "";
+    }
+
+    if (this._lastNumPinned != numPinned) {
+      this._lastNumPinned = numPinned;
+      this._handleTabSelect(true);
+    }
+  }
+
+  _animateTabMove(event) {
+    let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
+    let movingTabs = draggedTab._dragData.movingTabs;
+
+    if (this.getAttribute("movingtab") != "true") {
+      this.setAttribute("movingtab", "true");
+      gNavToolbox.setAttribute("movingtab", "true");
+      if (!draggedTab.multiselected)
+        this.selectedItem = draggedTab;
+    }
+
+    if (!("animLastScreenX" in draggedTab._dragData))
+      draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;
+
+    let screenX = event.screenX;
+    if (screenX == draggedTab._dragData.animLastScreenX)
+      return;
+
+    // Direction of the mouse movement.
+    let ltrMove = screenX > draggedTab._dragData.animLastScreenX;
+
+    draggedTab._dragData.animLastScreenX = screenX;
+
+    let pinned = draggedTab.pinned;
+    let numPinned = gBrowser._numPinnedTabs;
+    let tabs = this._getVisibleTabs()
+                   .slice(pinned ? 0 : numPinned,
+                          pinned ? numPinned : undefined);
+
+    if (RTL_UI) {
+      tabs.reverse();
+      // Copy moving tabs array to avoid infinite reversing.
+      movingTabs = [...movingTabs].reverse();
+    }
+    let tabWidth = draggedTab.getBoundingClientRect().width;
+    let shiftWidth = tabWidth * movingTabs.length;
+    draggedTab._dragData.tabWidth = tabWidth;
+
+    // Move the dragged tab based on the mouse position.
+
+    let leftTab = tabs[0];
+    let rightTab = tabs[tabs.length - 1];
+    let rightMovingTabScreenX = movingTabs[movingTabs.length - 1].screenX;
+    let leftMovingTabScreenX = movingTabs[0].screenX;
+    let translateX = screenX - draggedTab._dragData.screenX;
+    if (!pinned) {
+      translateX += this.arrowScrollbox.scrollbox.scrollLeft - draggedTab._dragData.scrollX;
+    }
+    let leftBound = leftTab.screenX - leftMovingTabScreenX;
+    let rightBound = (rightTab.screenX + rightTab.getBoundingClientRect().width) -
+                     (rightMovingTabScreenX + tabWidth);
+    translateX = Math.min(Math.max(translateX, leftBound), rightBound);
+
+    for (let tab of movingTabs) {
+      tab.style.transform = "translateX(" + translateX + "px)";
+    }
+
+    draggedTab._dragData.translateX = translateX;
+
+    // Determine what tab we're dragging over.
+    // * Single tab dragging: Point of reference is the center of the dragged tab. If that
+    //   point touches a background tab, the dragged tab would take that
+    //   tab's position when dropped.
+    // * Multiple tabs dragging: All dragged tabs are one "giant" tab with two
+    //   points of reference (center of tabs on the extremities). When
+    //   mouse is moving from left to right, the right reference gets activated,
+    //   otherwise the left reference will be used. Everything else works the same
+    //   as single tab dragging.
+    // * We're doing a binary search in order to reduce the amount of
+    //   tabs we need to check.
+
+    tabs = tabs.filter(t => !movingTabs.includes(t) || t == draggedTab);
+    let leftTabCenter = leftMovingTabScreenX + translateX + tabWidth / 2;
+    let rightTabCenter = rightMovingTabScreenX + translateX + tabWidth / 2;
+    let tabCenter = ltrMove ? rightTabCenter : leftTabCenter;
+    let newIndex = -1;
+    let oldIndex = "animDropIndex" in draggedTab._dragData ?
+                   draggedTab._dragData.animDropIndex : movingTabs[0]._tPos;
+    let low = 0;
+    let high = tabs.length - 1;
+    while (low <= high) {
+      let mid = Math.floor((low + high) / 2);
+      if (tabs[mid] == draggedTab && ++mid > high)
+        break;
+      screenX = tabs[mid].screenX + getTabShift(tabs[mid], oldIndex);
+      if (screenX > tabCenter) {
+        high = mid - 1;
+      } else if (screenX + tabs[mid].getBoundingClientRect().width < tabCenter) {
+        low = mid + 1;
+      } else {
+        newIndex = tabs[mid]._tPos;
+        break;
+      }
+    }
+    if (newIndex >= oldIndex)
+      newIndex++;
+    if (newIndex < 0 || newIndex == oldIndex)
+      return;
+    draggedTab._dragData.animDropIndex = newIndex;
+
+    // Shift background tabs to leave a gap where the dragged tab
+    // would currently be dropped.
+
+    for (let tab of tabs) {
+      if (tab != draggedTab) {
+        let shift = getTabShift(tab, newIndex);
+        tab.style.transform = shift ? "translateX(" + shift + "px)" : "";
+      }
+    }
+
+    function getTabShift(tab, dropIndex) {
+      if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)
+        return (RTL_UI ? -shiftWidth : shiftWidth);
+      if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)
+        return (RTL_UI ? shiftWidth : -shiftWidth);
+      return 0;
+    }
+  }
+
+  _finishAnimateTabMove() {
+    if (this.getAttribute("movingtab") != "true") {
+      return;
+    }
+
+    for (let tab of this._getVisibleTabs()) {
+      tab.style.transform = "";
+    }
+
+    this.removeAttribute("movingtab");
+    gNavToolbox.removeAttribute("movingtab");
+
+    this._handleTabSelect();
+  }
+
+  /**
+   * Regroup all selected tabs around the
+   * tab in param
+   */
+  _groupSelectedTabs(tab) {
+    let draggedTabPos = tab._tPos;
+    let selectedTabs = gBrowser.selectedTabs;
+    let animate = gBrowser.animationsEnabled;
+
+    tab.groupingTabsData = {
+      finished: !animate,
+    };
+
+    // Animate left selected tabs
+
+    let insertAtPos = draggedTabPos - 1;
+    for (let i = selectedTabs.indexOf(tab) - 1; i > -1; i--) {
+      let movingTab = selectedTabs[i];
+      insertAtPos = newIndex(movingTab, insertAtPos);
+
+      if (animate) {
+        movingTab.groupingTabsData = {};
+        addAnimationData(movingTab, insertAtPos, "left");
+      } else {
+        gBrowser.moveTabTo(movingTab, insertAtPos);
+      }
+      insertAtPos--;
+    }
+
+    // Animate right selected tabs
+
+    insertAtPos = draggedTabPos + 1;
+    for (let i = selectedTabs.indexOf(tab) + 1; i < selectedTabs.length; i++) {
+      let movingTab = selectedTabs[i];
+      insertAtPos = newIndex(movingTab, insertAtPos);
+
+      if (animate) {
+        movingTab.groupingTabsData = {};
+        addAnimationData(movingTab, insertAtPos, "right");
+      } else {
+        gBrowser.moveTabTo(movingTab, insertAtPos);
+      }
+      insertAtPos++;
+    }
+
+    // Slide the relevant tabs to their new position.
+    for (let t of this._getVisibleTabs()) {
+      if (t.groupingTabsData && t.groupingTabsData.translateX) {
+        let translateX = (RTL_UI ? -1 : 1) * t.groupingTabsData.translateX;
+        t.style.transform = "translateX(" + translateX + "px)";
+      }
+    }
+
+    function newIndex(aTab, index) {
+      // Don't allow mixing pinned and unpinned tabs.
+      if (aTab.pinned) {
+        return Math.min(index, gBrowser._numPinnedTabs - 1);
+      }
+      return Math.max(index, gBrowser._numPinnedTabs);
+    }
+
+    function addAnimationData(movingTab, movingTabNewIndex, side) {
+      let movingTabOldIndex = movingTab._tPos;
+
+      if (movingTabOldIndex == movingTabNewIndex) {
+        // movingTab is already at the right position
+        // and thus don't need to be animated.
+        return;
+      }
+
+      let movingTabWidth = movingTab.getBoundingClientRect().width;
+      let shift = (movingTabNewIndex - movingTabOldIndex) * movingTabWidth;
+
+      movingTab.groupingTabsData.animate = true;
+      movingTab.setAttribute("tab-grouping", "true");
+
+      movingTab.groupingTabsData.translateX = shift;
+
+      let onTransitionEnd = transitionendEvent => {
+        if (transitionendEvent.propertyName != "transform" ||
+            transitionendEvent.originalTarget != movingTab) {
+              return;
+        }
+        movingTab.removeEventListener("transitionend", onTransitionEnd);
+        movingTab.groupingTabsData.newIndex = movingTabNewIndex;
+        movingTab.groupingTabsData.animate = false;
+      };
+
+      movingTab.addEventListener("transitionend", onTransitionEnd);
+
+      // Add animation data for tabs between movingTab (selected
+      // tab moving towards the dragged tab) and draggedTab.
+      // Those tabs in the middle should move in
+      // the opposite direction of movingTab.
+
+      let lowerIndex = Math.min(movingTabOldIndex, draggedTabPos);
+      let higherIndex = Math.max(movingTabOldIndex, draggedTabPos);
+
+      for (let i = lowerIndex + 1; i < higherIndex; i++) {
+        let middleTab = gBrowser.visibleTabs[i];
+
+        if (middleTab.pinned != movingTab.pinned) {
+          // Don't mix pinned and unpinned tabs
+          break;
         }
 
-        // screen.availLeft et. al. only check the screen that this window is on,
-        // but we want to look at the screen the tab is being dropped onto.
-        var screen = Cc["@mozilla.org/gfx/screenmanager;1"]
-                       .getService(Ci.nsIScreenManager)
-                       .screenForRect(eX, eY, 1, 1);
-        var fullX = {}, fullY = {}, fullWidth = {}, fullHeight = {};
-        var availX = {}, availY = {}, availWidth = {}, availHeight = {};
-        // get full screen rect and available rect, both in desktop pix
-        screen.GetRectDisplayPix(fullX, fullY, fullWidth, fullHeight);
-        screen.GetAvailRectDisplayPix(availX, availY, availWidth, availHeight);
+        if (middleTab.multiselected) {
+          // Skip because this selected tab should
+          // be shifted towards the dragged Tab.
+          continue;
+        }
+
+        if (!middleTab.groupingTabsData || !middleTab.groupingTabsData.translateX) {
+          middleTab.groupingTabsData = { translateX: 0 };
+        }
+        if (side == "left") {
+          middleTab.groupingTabsData.translateX -= movingTabWidth;
+        } else {
+          middleTab.groupingTabsData.translateX += movingTabWidth;
+        }
+
+        middleTab.setAttribute("tab-grouping", "true");
+      }
+    }
+  }
+
+  _finishGroupSelectedTabs(tab) {
+    if (!tab.groupingTabsData || tab.groupingTabsData.finished)
+      return;
+
+    tab.groupingTabsData.finished = true;
 
-        // scale factor to convert desktop pixels to CSS px
-        var scaleFactor =
-          screen.contentsScaleFactor / screen.defaultCSSScaleFactor;
-        // synchronize CSS-px top-left coordinates with the screen's desktop-px
-        // coordinates, to ensure uniqueness across multiple screens
-        // (compare the equivalent adjustments in nsGlobalWindow::GetScreenXY()
-        // and related methods)
-        availX.value = (availX.value - fullX.value) * scaleFactor + fullX.value;
-        availY.value = (availY.value - fullY.value) * scaleFactor + fullY.value;
-        availWidth.value *= scaleFactor;
-        availHeight.value *= scaleFactor;
+    let selectedTabs = gBrowser.selectedTabs;
+    let tabIndex = selectedTabs.indexOf(tab);
+
+    // Moving left tabs
+    for (let i = tabIndex - 1; i > -1; i--) {
+      let movingTab = selectedTabs[i];
+      if (movingTab.groupingTabsData.newIndex) {
+        gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);
+      }
+    }
+
+    // Moving right tabs
+    for (let i = tabIndex + 1; i < selectedTabs.length; i++) {
+      let movingTab = selectedTabs[i];
+      if (movingTab.groupingTabsData.newIndex) {
+        gBrowser.moveTabTo(movingTab, movingTab.groupingTabsData.newIndex);
+      }
+    }
+
+    for (let t of this._getVisibleTabs()) {
+      t.style.transform = "";
+      t.removeAttribute("tab-grouping");
+      delete t.groupingTabsData;
+    }
+  }
 
-        // ensure new window entirely within screen
-        var winWidth = Math.min(window.outerWidth, availWidth.value);
-        var winHeight = Math.min(window.outerHeight, availHeight.value);
-        var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, availX.value),
-                            availX.value + availWidth.value - winWidth);
-        var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, availY.value),
-                           availY.value + availHeight.value - winHeight);
+  _isGroupTabsAnimationOver() {
+    for (let tab of gBrowser.selectedTabs) {
+      if (tab.groupingTabsData && tab.groupingTabsData.animate)
+        return false;
+    }
+    return true;
+  }
+
+  handleEvent(aEvent) {
+    switch (aEvent.type) {
+      case "resize":
+        if (aEvent.target != window)
+          break;
 
-        delete draggedTab._dragData;
+        this._updateCloseButtons();
+        this._handleTabSelect(true);
+        break;
+      case "mouseout":
+        // If the "related target" (the node to which the pointer went) is not
+        // a child of the current document, the mouse just left the window.
+        let relatedTarget = aEvent.relatedTarget;
+        if (relatedTarget && relatedTarget.ownerDocument == document)
+          break;
+      case "mousemove":
+        if (document.getElementById("tabContextMenu").state != "open")
+          this._unlockTabSizing();
+        break;
+    }
+  }
 
-        if (gBrowser.tabs.length == 1) {
-          // resize _before_ move to ensure the window fits the new screen.  if
-          // the window is too large for its screen, the window manager may do
-          // automatic repositioning.
-          window.resizeTo(winWidth, winHeight);
-          window.moveTo(left, top);
-          window.focus();
+  _notifyBackgroundTab(aTab) {
+    if (aTab.pinned || aTab.hidden || this.getAttribute("overflow") != "true")
+      return;
+
+    this._lastTabToScrollIntoView = aTab;
+    if (!this._backgroundTabScrollPromise) {
+      this._backgroundTabScrollPromise = window.promiseDocumentFlushed(() => {
+        let lastTabRect = this._lastTabToScrollIntoView.getBoundingClientRect();
+        let selectedTab = this.selectedItem;
+        if (selectedTab.pinned) {
+          selectedTab = null;
         } else {
-          let props = { screenX: left, screenY: top, suppressanimation: 1 };
-          if (AppConstants.platform != "win") {
-            props.outerWidth = winWidth;
-            props.outerHeight = winHeight;
-          }
-          gBrowser.replaceTabsWithWindow(draggedTab, props);
+          selectedTab = selectedTab.getBoundingClientRect();
+          selectedTab = { left: selectedTab.left, right: selectedTab.right };
         }
-        event.stopPropagation();
-      ]]></handler>
-
-      <handler event="dragexit"><![CDATA[
-        this._dragTime = 0;
-
-        // This does not work at all (see bug 458613)
-        var target = event.relatedTarget;
-        while (target && target != this)
-          target = target.parentNode;
-        if (target)
+        return [
+          this._lastTabToScrollIntoView,
+          this.arrowScrollbox.scrollClientRect,
+          { left: lastTabRect.left, right: lastTabRect.right },
+          selectedTab,
+        ];
+      }).then(([tabUsed, scrollRect, tabRect, selectedRect]) => {
+        // First off, remove the promise so we can re-enter if necessary.
+        delete this._backgroundTabScrollPromise;
+        // Then, if the layout info isn't for the last-scrolled-to-tab, re-run
+        // the code above to get layout info for *that* tab, and don't do
+        // anything here, as we really just want to run this for the last-opened tab.
+        if (this._lastTabToScrollIntoView != tabUsed) {
+          this._notifyBackgroundTab(this._lastTabToScrollIntoView);
+          return;
+        }
+        delete this._lastTabToScrollIntoView;
+        // Is the new tab already completely visible?
+        if (scrollRect.left <= tabRect.left && tabRect.right <= scrollRect.right)
           return;
 
-        this._tabDropIndicator.collapsed = true;
-        event.stopPropagation();
-      ]]></handler>
-    </handlers>
-  </binding>
-</bindings>
+        if (this.arrowScrollbox.smoothScroll) {
+          // Can we make both the new tab and the selected tab completely visible?
+          if (!selectedRect ||
+              Math.max(tabRect.right - selectedRect.left, selectedRect.right - tabRect.left) <=
+            scrollRect.width) {
+              this.arrowScrollbox.ensureElementIsVisible(aTab);
+              return;
+          }
+
+          this.arrowScrollbox.scrollByPixels(RTL_UI ?
+                                             selectedRect.right - scrollRect.right :
+                                             selectedRect.left - scrollRect.left);
+        }
+
+        if (!this._animateElement.hasAttribute("highlight")) {
+          this._animateElement.setAttribute("highlight", "true");
+          setTimeout(function(ele) {
+            ele.removeAttribute("highlight");
+          }, 150, this._animateElement);
+        }
+      });
+    }
+  }
+
+  _getDragTargetTab(event, isLink) {
+    let tab = event.target;
+    while (tab && tab.localName != "tab") {
+      tab = tab.parentNode;
+    }
+    if (tab && isLink) {
+      let { width } = tab.getBoundingClientRect();
+      if (event.screenX < tab.screenX + width * .25 ||
+          event.screenX > tab.screenX + width * .75)
+        return null;
+    }
+    return tab;
+  }
+
+  _getDropIndex(event, isLink) {
+    var tabs = this.allTabs;
+    var tab = this._getDragTargetTab(event, isLink);
+    if (!RTL_UI) {
+      for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
+        if (event.screenX < tabs[i].screenX + tabs[i].getBoundingClientRect().width / 2)
+        return i;
+    } else {
+      for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
+        if (event.screenX > tabs[i].screenX + tabs[i].getBoundingClientRect().width / 2)
+        return i;
+    }
+    return tabs.length;
+  }
+
+  _getDropEffectForTabDrag(event) {
+    var dt = event.dataTransfer;
+
+    let isMovingTabs = dt.mozItemCount > 0;
+    for (let i = 0; i < dt.mozItemCount; i++) {
+      // tabs are always added as the first type
+      let types = dt.mozTypesAt(0);
+      if (types[0] != TAB_DROP_TYPE) {
+        isMovingTabs = false;
+        break;
+      }
+    }
+
+    if (isMovingTabs) {
+      let sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
+      if (sourceNode instanceof XULElement &&
+          sourceNode.localName == "tab" &&
+          sourceNode.ownerGlobal.isChromeWindow &&
+          sourceNode.ownerDocument.documentElement.getAttribute("windowtype") == "navigator:browser" &&
+          sourceNode.ownerGlobal.gBrowser.tabContainer == sourceNode.container) {
+            // Do not allow transfering a private tab to a non-private window
+            // and vice versa.
+            if (PrivateBrowsingUtils.isWindowPrivate(window) !=
+              PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerGlobal))
+              return "none";
+
+            if (window.gMultiProcessBrowser !=
+              sourceNode.ownerGlobal.gMultiProcessBrowser)
+              return "none";
+
+            return dt.dropEffect == "copy" ? "copy" : "move";
+      }
+    }
+
+    if (browserDragAndDrop.canDropLink(event)) {
+      return "link";
+    }
+    return "none";
+  }
+
+  _handleNewTab(tab) {
+    if (tab.container != this) {
+      return;
+    }
+    tab._fullyOpen = true;
+    gBrowser.tabAnimationsInProgress--;
+
+    this._updateCloseButtons();
+
+    if (tab.getAttribute("selected") == "true") {
+      this._handleTabSelect();
+    } else if (!tab.hasAttribute("skipbackgroundnotify")) {
+      this._notifyBackgroundTab(tab);
+    }
+
+    // XXXmano: this is a temporary workaround for bug 345399
+    // We need to manually update the scroll buttons disabled state
+    // if a tab was inserted to the overflow area or removed from it
+    // without any scrolling and when the tabbar has already
+    // overflowed.
+    this.arrowScrollbox._updateScrollButtonsDisabledState();
+
+    // If this browser isn't lazy (indicating it's probably created by
+    // session restore), preload the next about:newtab if we don't
+    // already have a preloaded browser.
+    if (tab.linkedPanel) {
+      NewTabPagePreloading.maybeCreatePreloadedBrowser(window);
+    }
+  }
+
+  _canAdvanceToTab(aTab) {
+    return !aTab.closing;
+  }
+
+  getRelatedElement(aTab) {
+    if (!aTab) {
+      return null;
+    }
+
+    // Cannot access gBrowser before it's initialized.
+    if (!gBrowser) {
+      return this.tabbox.tabpanels.firstElementChild;
+    }
+
+    // If the tab's browser is lazy, we need to `_insertBrowser` in order
+    // to have a linkedPanel.  This will also serve to bind the browser
+    // and make it ready to use when the tab is selected.
+    gBrowser._insertBrowser(aTab);
+    return document.getElementById(aTab.linkedPanel);
+  }
+
+  _updateNewTabVisibility() {
+    // Helper functions to help deal with customize mode wrapping some items
+    let wrap = n => n.parentNode.localName == "toolbarpaletteitem" ? n.parentNode : n;
+    let unwrap = n => n && n.localName == "toolbarpaletteitem" ? n.firstElementChild : n;
+
+    // Starting from the tabs element, find the next sibling that:
+    // - isn't hidden; and
+    // - isn't the all-tabs button.
+    // If it's the new tab button, consider the new tab button adjacent to the tabs.
+    // If the new tab button is marked as adjacent and the tabstrip doesn't
+    // overflow, we'll display the 'new tab' button inline in the tabstrip.
+    // In all other cases, the separate new tab button is displayed in its
+    // customized location.
+    let sib = this;
+    do {
+      sib = unwrap(wrap(sib).nextElementSibling);
+    } while (sib && (sib.hidden ||
+                     sib.id == "alltabs-button"));
+
+    const kAttr = "hasadjacentnewtabbutton";
+    if (sib && sib.id == "new-tab-button") {
+      this.setAttribute(kAttr, "true");
+    } else {
+      this.removeAttribute(kAttr);
+    }
+  }
+
+  onWidgetAfterDOMChange(aNode, aNextNode, aContainer) {
+    if (aContainer.ownerDocument == document &&
+        aContainer.id == "TabsToolbar-customization-target") {
+          this._updateNewTabVisibility();
+    }
+  }
+
+  onAreaNodeRegistered(aArea, aContainer) {
+    if (aContainer.ownerDocument == document &&
+        aArea == "TabsToolbar") {
+          this._updateNewTabVisibility();
+    }
+  }
+
+  onAreaReset(aArea, aContainer) {
+    this.onAreaNodeRegistered(aArea, aContainer);
+  }
+
+  _hiddenSoundPlayingStatusChanged(tab, opts) {
+    let closed = opts && opts.closed;
+    if (!closed && tab.soundPlaying && tab.hidden) {
+      this._hiddenSoundPlayingTabs.add(tab);
+      this.setAttribute("hiddensoundplaying", "true");
+    } else {
+      this._hiddenSoundPlayingTabs.delete(tab);
+      if (this._hiddenSoundPlayingTabs.size == 0) {
+        this.removeAttribute("hiddensoundplaying");
+      }
+    }
+  }
+  disconnectedCallback() {
+    Services.prefs.removeObserver("privacy.userContext", this);
+
+    CustomizableUI.removeListener(this);
+  }
+}
+
+MozXULElement.implementCustomInterface(MozTabbrowserTabs, [Ci.nsIObserver]);
+customElements.define("tabbrowser-tabs", MozTabbrowserTabs, {extends: "tabs"});
+}
diff --git a/browser/base/content/tabbrowser.css b/browser/base/content/tabbrowser.css
--- a/browser/base/content/tabbrowser.css
+++ b/browser/base/content/tabbrowser.css
@@ -1,14 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 .tab-close-button[pinned],
-#tabbrowser-tabs[closebuttons="activetab"] > .tabbrowser-tab > .tab-stack > .tab-content > .tab-close-button:not([selected="true"]),
+#tabbrowser-tabs[closebuttons="activetab"] > .tabbrowser-arrowscrollbox > .tabbrowser-tab > .tab-stack > .tab-content > .tab-close-button:not([selected="true"]),
 .tab-icon-pending:not([pendingicon]),
 .tab-icon-pending[busy],
 .tab-icon-pending[pinned],
 .tab-icon-image:not([src]):not([pinned]):not([crashed])[selected],
 .tab-icon-image:not([src]):not([pinned]):not([crashed]):not([sharing]),
 .tab-icon-image[busy],
 .tab-throbber:not([busy]),
 .tab-icon-pip:not([pictureinpicture]),
diff --git a/browser/base/content/test/performance/browser_tabclose.js b/browser/base/content/test/performance/browser_tabclose.js
--- a/browser/base/content/test/performance/browser_tabclose.js
+++ b/browser/base/content/test/performance/browser_tabclose.js
@@ -21,20 +21,18 @@ const EXPECTED_REFLOWS = [
  */
 add_task(async function() {
   await ensureNoPreloadedBrowser();
 
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser);
   await BrowserTestUtils.waitForCondition(() => tab._fullyOpen);
 
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
-  let newTabButtonRect =
-    document.getAnonymousElementByAttribute(gBrowser.tabContainer,
-                                            "anonid", "tabs-newtab-button")
-            .getBoundingClientRect();
+  let newTabButtonRect = gBrowser.tabContainer.newTabButton
+                                 .getBoundingClientRect();
   let inRange = (val, min, max) => min <= val && val <= max;
 
   // Add a reflow observer and open a new tab.
   await withPerfObserver(async function() {
     let switchDone = BrowserTestUtils.waitForEvent(window, "TabSwitchDone");
     gBrowser.removeTab(tab, { animate: true });
     await BrowserTestUtils.waitForEvent(tab, "TabAnimationEnd");
     await switchDone;
diff --git a/browser/base/content/test/performance/browser_tabdetach.js b/browser/base/content/test/performance/browser_tabdetach.js
--- a/browser/base/content/test/performance/browser_tabdetach.js
+++ b/browser/base/content/test/performance/browser_tabdetach.js
@@ -7,28 +7,28 @@
  * be modifying your code to avoid the reflow.
  *
  * See https://developer.mozilla.org/en-US/Firefox/Performance_best_practices_for_Firefox_fe_engineers
  * for tips on how to do that.
  */
 const EXPECTED_REFLOWS = [
   {
     stack: [
-      "clientX@chrome://browser/content/tabbrowser.xml",
-      "onxbldragstart@chrome://browser/content/tabbrowser.xml",
+      "clientX@chrome://browser/content/tabbrowser-tabs.js",
+      "MozTabbrowserTabs/<@chrome://browser/content/tabbrowser-tabs.js",
       "synthesizeMouseAtPoint@chrome://mochikit/content/tests/SimpleTest/EventUtils.js",
       "synthesizeMouse@chrome://mochikit/content/tests/SimpleTest/EventUtils.js",
       "synthesizePlainDragAndDrop@chrome://mochikit/content/tests/SimpleTest/EventUtils.js",
     ],
     maxCount: 2,
   },
 
   {
     stack: [
-      "onxbldragstart@chrome://browser/content/tabbrowser.xml",
+      "MozTabbrowserTabs/<@chrome://browser/content/tabbrowser-tabs.js",
       "synthesizeMouseAtPoint@chrome://mochikit/content/tests/SimpleTest/EventUtils.js",
       "synthesizeMouse@chrome://mochikit/content/tests/SimpleTest/EventUtils.js",
       "synthesizePlainDragAndDrop@chrome://mochikit/content/tests/SimpleTest/EventUtils.js",
     ],
   },
 ];
 
 /**
diff --git a/browser/base/content/test/performance/head.js b/browser/base/content/test/performance/head.js
--- a/browser/base/content/test/performance/head.js
+++ b/browser/base/content/test/performance/head.js
@@ -273,19 +273,17 @@ async function ensureFocusedUrlbar() {
  * tabstrip without causing it to overflow.
  *
  * @return int
  *         The maximum additional tabs that can be fit into the
  *         tabstrip without causing it to overflow.
  */
 function computeMaxTabCount() {
   let currentTabCount = gBrowser.tabs.length;
-  let newTabButton =
-    document.getAnonymousElementByAttribute(gBrowser.tabContainer,
-                                            "anonid", "tabs-newtab-button");
+  let newTabButton = gBrowser.tabContainer.newTabButton;
   let newTabRect = newTabButton.getBoundingClientRect();
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
   let availableTabStripWidth = tabStripRect.width - newTabRect.width;
 
   let tabMinWidth =
     parseInt(getComputedStyle(gBrowser.selectedTab, null).minWidth, 10);
 
   let maxTabCount = Math.floor(availableTabStripWidth / tabMinWidth) - currentTabCount;
diff --git a/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js b/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js
--- a/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js
+++ b/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js
@@ -16,18 +16,17 @@ add_task(async function test() {
   await triggerClickOn(tab2, {ctrlKey: true});
 
   ok(tab1.multiselected, "Tab1 is multi-selected");
   ok(tab2.multiselected, "Tab2 is multi-selected");
   ok(!tab3.multiselected, "Tab3 is not multi-selected");
 
   let metaKeyEvent = AppConstants.platform == "macosx" ? {metaKey: true} : {ctrlKey: true};
 
-  let tabs = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(tabs, "anonid", "tabs-newtab-button");
+  let newTabButton = gBrowser.tabContainer.newTabButton;
   let promiseTabOpened = BrowserTestUtils.waitForEvent(gBrowser.tabContainer, "TabOpen");
   EventUtils.synthesizeMouseAtCenter(newTabButton, metaKeyEvent);
   let openEvent = await promiseTabOpened;
   let newTab = openEvent.target;
 
   is(newTab.previousElementSibling, tab2,
     "New tab should be opened after tab2 when tab1 and tab2 are multiselected");
   is(newTab.nextElementSibling, tab3,
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -87,17 +87,17 @@ browser.jar:
         content/browser/sanitize.xul                  (content/sanitize.xul)
         content/browser/sanitizeDialog.js             (content/sanitizeDialog.js)
         content/browser/sanitizeDialog.css            (content/sanitizeDialog.css)
         content/browser/contentSearchUI.js            (content/contentSearchUI.js)
         content/browser/contentSearchUI.css           (content/contentSearchUI.css)
         content/browser/tabbrowser.css                (content/tabbrowser.css)
         content/browser/tabbrowser.js                 (content/tabbrowser.js)
         content/browser/tabbrowser-tab.js             (content/tabbrowser-tab.js)
-        content/browser/tabbrowser.xml                (content/tabbrowser.xml)
+        content/browser/tabbrowser-tabs.js            (content/tabbrowser-tabs.js)
 *       content/browser/urlbarBindings.xml            (content/urlbarBindings.xml)
         content/browser/utilityOverlay.js             (content/utilityOverlay.js)
         content/browser/webext-panels.js              (content/webext-panels.js)
 *       content/browser/webext-panels.xul             (content/webext-panels.xul)
         content/browser/nsContextMenu.js              (content/nsContextMenu.js)
         content/browser/contentTheme.js               (content/contentTheme.js)
 #ifdef XP_MACOSX
 # XXX: We should exclude this one as well (bug 71895)
diff --git a/browser/components/contextualidentity/test/browser/browser_newtabButton.js b/browser/components/contextualidentity/test/browser/browser_newtabButton.js
--- a/browser/components/contextualidentity/test/browser/browser_newtabButton.js
+++ b/browser/components/contextualidentity/test/browser/browser_newtabButton.js
@@ -1,25 +1,30 @@
 "use strict";
 
 // Testing that when the user opens the add tab menu and clicks menu items
 // the correct context id is opened
 
+function findPopup(browser = gBrowser) {
+  return browser.tabContainer.querySelector(".new-tab-popup");
+}
+
 add_task(async function test_menu_with_timeout() {
   await SpecialPowers.pushPrefEnv({"set": [
       ["privacy.userContext.enabled", true],
       ["privacy.userContext.longPressBehavior", 2],
   ]});
 
-  let newTab = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(newTab, "anonid", "tabs-newtab-button");
+  let newTabButton = gBrowser.tabContainer.newTabButton;
   ok(newTabButton, "New tab button exists");
   ok(!newTabButton.hidden, "New tab button is visible");
-  await BrowserTestUtils.waitForCondition(() => !!document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup"), "Wait for popup to exist");
-  let popup = document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
+
+  await BrowserTestUtils.waitForCondition(() => !!findPopup(), "Wait for popup to exist");
+
+  let popup = findPopup();
 
   for (let i = 1; i <= 4; i++) {
     let popupShownPromise = BrowserTestUtils.waitForEvent(popup, "popupshown");
     EventUtils.synthesizeMouseAtCenter(newTabButton, {type: "mousedown"});
 
     await popupShownPromise;
     let contextIdItem = popup.querySelector(`menuitem[data-usercontextid="${i}"]`);
 
@@ -36,22 +41,22 @@ add_task(async function test_menu_with_t
 });
 
 add_task(async function test_menu_without_timeout() {
   await SpecialPowers.pushPrefEnv({"set": [
       ["privacy.userContext.enabled", true],
       ["privacy.userContext.longPressBehavior", 1],
   ]});
 
-  let newTab = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(newTab, "anonid", "tabs-newtab-button");
+  let newTabButton = gBrowser.tabContainer.newTabButton;
   ok(newTabButton, "New tab button exists");
   ok(!newTabButton.hidden, "New tab button is visible");
-  await BrowserTestUtils.waitForCondition(() => !!document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup"), "Wait for popup to exist");
-  let popup = document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
+
+  await BrowserTestUtils.waitForCondition(() => !!findPopup(), "Wait for popup to exist");
+  let popup = findPopup();
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(popup, "popupshown");
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(popup, "popuphidden");
   EventUtils.synthesizeMouseAtCenter(newTabButton, {type: "mousedown"});
   await popupShownPromise;
   let contextIdItems = popup.querySelectorAll("menuitem");
   // 4 + default + manage containers
   is(contextIdItems.length, 6, "Has 6 menu items");
@@ -83,29 +88,29 @@ add_task(async function test_menu_withou
 });
 
 add_task(async function test_no_menu() {
   await SpecialPowers.pushPrefEnv({"set": [
       ["privacy.userContext.enabled", true],
       ["privacy.userContext.longPressBehavior", 0],
   ]});
 
-  let newTab = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(newTab, "anonid", "tabs-newtab-button");
+  let newTabButton = gBrowser.tabContainer.newTabButton;
   ok(newTabButton, "New tab button exists");
   ok(!newTabButton.hidden, "New tab button is visible");
-  let popup = document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
+  let popup = findPopup();
   ok(!popup, "new tab should not have a popup");
 });
 
 add_task(async function test_private_mode() {
   let privateWindow = await BrowserTestUtils.openNewBrowserWindow({private: true});
   let privateDocument = privateWindow.document;
   let {tabContainer} = privateWindow.gBrowser;
-  let newTab = privateDocument.getAnonymousElementByAttribute(tabContainer, "anonid", "tabs-newtab-button");
+  let newTab = tabContainer.newTabButton;
   let newTab2 = privateDocument.getElementById("new-tab-button");
   // Check to ensure we are talking about the right button
   ok(!!newTab.clientWidth, "new tab button should not be hidden");
   ok(!newTab2.clientWidth, "overflow new tab button should be hidden");
-  let popup = privateDocument.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
+  let popup = findPopup(privateWindow.gBrowser);
   ok(!popup, "new tab should not have a popup");
   await BrowserTestUtils.closeWindow(privateWindow);
 });
+
diff --git a/browser/components/customizableui/test/browser_newtab_button_customizemode.js b/browser/components/customizableui/test/browser_newtab_button_customizemode.js
--- a/browser/components/customizableui/test/browser_newtab_button_customizemode.js
+++ b/browser/components/customizableui/test/browser_newtab_button_customizemode.js
@@ -4,17 +4,17 @@
 "use strict";
 
 /**
  * Tests in this file check that user customizations to the tabstrip show
  * the correct type of new tab button while the tabstrip isn't overflowing.
  */
 
 const kGlobalNewTabButton = document.getElementById("new-tab-button");
-const kInnerNewTabButton = document.getAnonymousElementByAttribute(gBrowser.tabContainer, "anonid", "tabs-newtab-button");
+const kInnerNewTabButton = gBrowser.tabContainer.newTabButton;
 
 function assertNewTabButton(which) {
   if (which == "global") {
     isnot(kGlobalNewTabButton.getBoundingClientRect().width, 0,
       "main new tab button should be visible");
     is(kInnerNewTabButton.getBoundingClientRect().width, 0,
       "inner new tab button should be hidden");
   } else if (which == "inner") {
diff --git a/browser/themes/shared/tabs.inc.css b/browser/themes/shared/tabs.inc.css
--- a/browser/themes/shared/tabs.inc.css
+++ b/browser/themes/shared/tabs.inc.css
@@ -44,17 +44,17 @@
     /* Value for --in-content-page-background for dark mode in in-content/common.inc.css */
     background-color: #2A2A2E;
   }
 }
 }
 
 #tabbrowser-tabs,
 #tabbrowser-tabs > .tabbrowser-arrowscrollbox,
-#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-tab[pinned] {
+#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[pinned] {
   min-height: var(--tab-min-height);
 }
 
 .tab-stack {
   min-height: inherit;
 }
 
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
@@ -537,18 +537,18 @@
 }
 
 /*
  * LightweightThemeConsumer will set the current lightweight theme's header
  * image to the lwt-header-image variable, used in each of the following rulesets.
  */
 
 /* Lightweight theme on tabs */
-#tabbrowser-tabs:not([movingtab]) > .tabbrowser-tab > .tab-stack > .tab-background[multiselected=true]:-moz-lwtheme,
-#tabbrowser-tabs:not([movingtab]) > .tabbrowser-tab > .tab-stack > .tab-background[selected=true]:-moz-lwtheme {
+#tabbrowser-tabs:not([movingtab]) > .tabbrowser-arrowscrollbox > .tabbrowser-tab > .tab-stack > .tab-background[multiselected=true]:-moz-lwtheme,
+#tabbrowser-tabs:not([movingtab]) > .tabbrowser-arrowscrollbox > .tabbrowser-tab > .tab-stack > .tab-background[selected=true]:-moz-lwtheme {
   background-attachment: scroll, scroll, fixed;
   background-color: transparent;
   background-image: linear-gradient(var(--lwt-selected-tab-background-color, transparent), var(--lwt-selected-tab-background-color, transparent)),
                     linear-gradient(var(--toolbar-bgcolor), var(--toolbar-bgcolor)),
                     var(--lwt-header-image, none);
   background-position: 0 0, 0 0, right top;
   background-repeat: repeat-x, repeat-x, no-repeat;
   background-size: auto 100%, auto 100%, auto auto;
@@ -582,29 +582,29 @@
 
 .tabbrowser-tab:hover > .tab-stack > .tab-background > .tab-line[multiselected]:not([selected=true]) {
   opacity: 0.5;
 }
 
 /* Pinned tabs */
 
 /* Pinned tab separators need position: absolute when positioned (during overflow). */
-#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-tab[pinned]::after {
+#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[pinned]::after {
   position: absolute;
   top: 0;
   bottom: 0;
   right: 0;
 }
 
-#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-tab[pinned]:-moz-locale-dir(rtl)::after {
+#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[pinned]:-moz-locale-dir(rtl)::after {
   right: unset;
   left: 0;
 }
 
-#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-tab[pinned] > .tab-stack {
+#tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[pinned] > .tab-stack {
   border-inline-end: 1px solid transparent;
 }
 
 .tabbrowser-tab:-moz-any([image], [pinned]) > .tab-stack > .tab-content[attention]:not([selected="true"]),
 .tabbrowser-tab > .tab-stack > .tab-content[pinned][titlechanged]:not([selected="true"]) {
   background-image: url(chrome://browser/skin/tabbrowser/indicator-tab-attention.svg);
   background-position: center bottom calc(-4px + var(--tabs-navbar-shadow-size));
   background-repeat: no-repeat;
@@ -664,36 +664,36 @@
 
 %ifdef MENUBAR_CAN_AUTOHIDE
 :root[tabsintitlebar]:not([extradragspace]) #toolbar-menubar[autohide=true] + #TabsToolbar .tabbrowser-tab::after,
 %else
 :root[tabsintitlebar]:not([extradragspace]) .tabbrowser-tab::after,
 %endif
 /* Show full height tab separators on hover and multiselection. */
 .tabbrowser-tab:hover::after,
-#tabbrowser-tabs:not([movingtab]) > .tabbrowser-tab[beforehovered]::after,
+#tabbrowser-tabs:not([movingtab]) > .tabbrowser-arrowscrollbox > .tabbrowser-tab[beforehovered]::after,
 .tabbrowser-tab[multiselected]::after,
-#tabbrowser-tabs:not([movingtab]) > .tabbrowser-tab[before-multiselected]::after {
+#tabbrowser-tabs:not([movingtab]) > .tabbrowser-arrowscrollbox > .tabbrowser-tab[before-multiselected]::after {
   margin-top: var(--tabs-top-border-width);
   margin-bottom: 0;
 }
 
 /* Show full height tab separators on selected tabs. */
-#tabbrowser-tabs:not([movingtab]) > .tabbrowser-tab[beforeselected-visible]::after,
-#tabbrowser-tabs[movingtab] > .tabbrowser-tab[visuallyselected]::before,
+#tabbrowser-tabs:not([movingtab]) > .tabbrowser-arrowscrollbox > .tabbrowser-tab[beforeselected-visible]::after,
+#tabbrowser-tabs[movingtab] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[visuallyselected]::before,
 .tabbrowser-tab[visuallyselected]::after {
   border-color: var(--tabs-border-color);
   margin-top: 0;
   margin-bottom: var(--tabs-navbar-shadow-size);
   opacity: 1;
 }
 
 .tabbrowser-tab::after,
 /* Also show separators beside the selected tab when dragging it. */
-#tabbrowser-tabs[movingtab] > .tabbrowser-tab[visuallyselected]::before {
+#tabbrowser-tabs[movingtab] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[visuallyselected]::before {
   content: "";
   display: -moz-box;
 }
 
 /* Tab bar scroll arrows */
 
 .tabbrowser-arrowscrollbox > .scrollbutton-up,
 .tabbrowser-arrowscrollbox > .scrollbutton-down {
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -66,17 +66,16 @@ toolkit.jar:
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/richlistbox.xml     (widgets/richlistbox.xml)
    content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
-   content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/autocomplete-popup.js              (widgets/autocomplete-popup.js)
    content/global/elements/autocomplete-richlistitem.js       (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
    content/global/elements/button.js           (widgets/button.js)
diff --git a/toolkit/content/widgets/tabbox.js b/toolkit/content/widgets/tabbox.js
--- a/toolkit/content/widgets/tabbox.js
+++ b/toolkit/content/widgets/tabbox.js
@@ -425,9 +425,378 @@ MozElements.MozTab = class MozTab extend
 
   get linkedPanel() {
     return this.getAttribute("linkedpanel");
   }
 };
 
 MozXULElement.implementCustomInterface(MozElements.MozTab, [Ci.nsIDOMXULSelectControlItemElement]);
 customElements.define("tab", MozElements.MozTab);
+
+class TabsBase extends MozElements.BaseControl {
+  constructor() {
+    super();
+
+    this.addEventListener("DOMMouseScroll", (event) => {
+      if (Services.prefs.getBoolPref("toolkit.tabbox.switchByScrolling")) {
+        if (event.detail > 0) {
+          this.advanceSelectedTab(1, false);
+        } else {
+          this.advanceSelectedTab(-1, false);
+        }
+        event.stopPropagation();
+      }
+    });
+  }
+
+  // to be called from derived class connectedCallback
+  baseConnect() {
+    this._tabbox = null;
+    this.ACTIVE_DESCENDANT_ID = "keyboard-focused-tab-" + Math.trunc(Math.random() * 1000000);
+
+    if (!this.hasAttribute("orient"))
+      this.setAttribute("orient", "horizontal");
+
+    if (this.tabbox && this.tabbox.hasAttribute("selectedIndex")) {
+      let selectedIndex = parseInt(this.tabbox.getAttribute("selectedIndex"));
+      this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;
+      return;
+    }
+
+    let children = this.allTabs;
+    let length = children.length;
+    for (var i = 0; i < length; i++) {
+      if (children[i].getAttribute("selected") == "true") {
+        this.selectedIndex = i;
+        return;
+      }
+    }
+
+    var value = this.value;
+    if (value)
+      this.value = value;
+    else
+      this.selectedIndex = 0;
+  }
+
+  /**
+   * nsIDOMXULSelectControlElement
+   */
+  get itemCount() {
+    return this.tabCount;
+  }
+
+  set value(val) {
+    this.setAttribute("value", val);
+    var children = this.allTabs;
+    for (var c = children.length - 1; c >= 0; c--) {
+      if (children[c].value == val) {
+        this.selectedIndex = c;
+        break;
+      }
+    }
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+
+  get tabbox() {
+    // Memoize the result in a field rather than replacing this property,
+    // so that it can be reset along with the binding.
+    if (this._tabbox) {
+      return this._tabbox;
+    }
+
+    let parent = this.parentNode;
+    while (parent) {
+      if (parent.localName == "tabbox") {
+        break;
+      }
+      parent = parent.parentNode;
+    }
+
+    return this._tabbox = parent;
+  }
+
+  set selectedIndex(val) {
+    var tab = this.getItemAtIndex(val);
+    if (tab) {
+      for (let otherTab of this.allTabs) {
+        if (otherTab != tab && otherTab.selected) {
+          otherTab._selected = false;
+        }
+      }
+      tab._selected = true;
+
+      this.setAttribute("value", tab.value);
+
+      let linkedPanel = this.getRelatedElement(tab);
+      if (linkedPanel) {
+        this.tabbox.setAttribute("selectedIndex", val);
+
+        // This will cause an onselect event to fire for the tabpanel
+        // element.
+        this.tabbox.tabpanels.selectedPanel = linkedPanel;
+      }
+    }
+    return val;
+  }
+
+  get selectedIndex() {
+    const tabs = this.allTabs;
+    for (var i = 0; i < tabs.length; i++) {
+      if (tabs[i].selected)
+        return i;
+    }
+    return -1;
+  }
+
+  set selectedItem(val) {
+    if (val && !val.selected)
+      // The selectedIndex setter ignores invalid values
+      // such as -1 if |val| isn't one of our child nodes.
+      this.selectedIndex = this.getIndexOfItem(val);
+    return val;
+  }
+
+  get selectedItem() {
+    const tabs = this.allTabs;
+    for (var i = 0; i < tabs.length; i++) {
+      if (tabs[i].selected)
+        return tabs[i];
+    }
+    return null;
+  }
+
+  get ariaFocusedIndex() {
+    const tabs = this.allTabs;
+    for (var i = 0; i < tabs.length; i++) {
+      if (tabs[i].id == this.ACTIVE_DESCENDANT_ID)
+        return i;
+    }
+    return -1;
+  }
+
+  set ariaFocusedItem(val) {
+    let setNewItem = val && this.getIndexOfItem(val) != -1;
+    let clearExistingItem = this.ariaFocusedItem && (!val || setNewItem);
+    if (clearExistingItem) {
+      let ariaFocusedItem = this.ariaFocusedItem;
+      ariaFocusedItem.classList.remove("keyboard-focused-tab");
+      ariaFocusedItem.id = "";
+      this.selectedItem.removeAttribute("aria-activedescendant");
+    }
+
+    if (setNewItem) {
+      this.ariaFocusedItem = null;
+      val.id = this.ACTIVE_DESCENDANT_ID;
+      val.classList.add("keyboard-focused-tab");
+      this.selectedItem.setAttribute("aria-activedescendant", this.ACTIVE_DESCENDANT_ID);
+    }
+
+    return val;
+  }
+
+  get ariaFocusedItem() {
+    return document.getElementById(this.ACTIVE_DESCENDANT_ID);
+  }
+
+  /**
+   * nsIDOMXULRelatedElement
+   */
+  getRelatedElement(aTabElm) {
+    if (!aTabElm)
+      return null;
+
+    let tabboxElm = this.tabbox;
+    if (!tabboxElm)
+      return null;
+
+    let tabpanelsElm = tabboxElm.tabpanels;
+    if (!tabpanelsElm)
+      return null;
+
+    // Get linked tab panel by 'linkedpanel' attribute on the given tab
+    // element.
+    let linkedPanelId = aTabElm.linkedPanel;
+    if (linkedPanelId) {
+      let ownerDoc = this.ownerDocument;
+
+      // XXX bug 565858: if XUL tab element is anonymous element then
+      // suppose linked tab panel is hosted within the same XBL binding
+      // and search it by ID attribute inside an anonymous content of
+      // the binding. This is not robust assumption since tab elements may
+      // live outside a tabbox element so that for example tab elements
+      // can be explicit content but tab panels can be anonymous.
+
+      let bindingParent = ownerDoc.getBindingParent(aTabElm);
+      if (bindingParent)
+        return ownerDoc.getAnonymousElementByAttribute(bindingParent,
+                                                       "id",
+                                                       linkedPanelId);
+
+      return ownerDoc.getElementById(linkedPanelId);
+    }
+
+    // otherwise linked tabpanel element has the same index as the given
+    // tab element.
+    let tabElmIdx = this.getIndexOfItem(aTabElm);
+    return tabpanelsElm.children[tabElmIdx];
+  }
+
+  getIndexOfItem(item) {
+    return Array.prototype.indexOf.call(this.allTabs, item);
+  }
+
+  // XXX move me to derived classes
+  getItemAtIndex(index) {
+    return this.allTabs[index] || null;
+  }
+
+  /**
+   * Find an adjacent tab.
+   *
+   * @param {Node} startTab    A <tab> element to start searching from.
+   * @param {Number} direction 1 to search forward, -1 to search backward.
+   * @param {Boolean} wrap     If true, wrap around if the search reaches
+   *                           the end (or beginning) of the tab strip.
+   * @param {Boolean} advance  If false, start searching with startTab.  If
+   *                           true, start searching with an adjacent tab.
+   * @param {Function} filter  A function to select which tabs to return.
+   *
+   * @return {Node | null}     The next <tab> element or, if none exists, null.
+   */
+  findNextTab(startTab, direction, wrap, advance = false, filter = tab => true) {
+    let tab = startTab;
+    if (!advance && filter(tab)) {
+      return tab;
+    }
+
+    let children = this.allTabs;
+    let i = children.indexOf(tab);
+    if (i < 0) {
+      return null;
+    }
+
+    while (true) {
+      i += direction;
+      if (wrap) {
+        if (i < 0) {
+          i = children.length - 1;
+        } else if (i >= children.length) {
+          i = 0;
+        }
+      } else if (i < 0 || i >= children.length) {
+        return null;
+      }
+
+      tab = children[i];
+      if (tab == startTab) {
+        return null;
+      }
+      if (filter(tab)) {
+        return tab;
+      }
+    }
+  }
+
+  _selectNewTab(aNewTab, aFallbackDir, aWrap) {
+    this.ariaFocusedItem = null;
+
+    aNewTab = this.findNextTab(aNewTab, aFallbackDir, aWrap, false,
+                               tab => !tab.hidden && !tab.disabled && this._canAdvanceToTab(tab));
+
+    var isTabFocused = false;
+    try {
+      isTabFocused =
+      (document.commandDispatcher.focusedElement == this.selectedItem);
+    } catch (e) {}
+    this.selectedItem = aNewTab;
+    if (isTabFocused) {
+      aNewTab.focus();
+    } else if (this.getAttribute("setfocus") != "false") {
+      let selectedPanel = this.tabbox.selectedPanel;
+      document.commandDispatcher.advanceFocusIntoSubtree(selectedPanel);
+
+      // Make sure that the focus doesn't move outside the tabbox
+      if (this.tabbox) {
+        try {
+          let el = document.commandDispatcher.focusedElement;
+          while (el && el != this.tabbox.tabpanels) {
+            if (el == this.tabbox || el == selectedPanel)
+              return;
+            el = el.parentNode;
+          }
+          aNewTab.focus();
+        } catch (e) {}
+      }
+    }
+  }
+
+  _canAdvanceToTab(aTab) {
+    return true;
+  }
+
+  advanceSelectedTab(aDir, aWrap) {
+    let startTab = this.ariaFocusedItem || this.selectedItem;
+    let newTab = this.findNextTab(startTab, aDir, aWrap, true);
+    this._selectNewTab(newTab, aDir, aWrap);
+  }
+
+  appendItem(label, value) {
+    var tab = document.createXULElement("tab");
+    tab.setAttribute("label", label);
+    tab.setAttribute("value", value);
+    this.appendChild(tab);
+    return tab;
+  }
 }
+
+MozXULElement.implementCustomInterface(TabsBase, [Ci.nsIDOMXULSelectControlElement, Ci.nsIDOMXULRelatedElement]);
+
+MozElements.TabsBase = TabsBase;
+
+class MozTabs extends TabsBase {
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    let start = MozXULElement.parseXULToFragment(`<spacer class="tabs-left"></spacer>`);
+    this.insertBefore(start, this.firstChild);
+
+    let end = MozXULElement.parseXULToFragment(`<spacer class="tabs-right" flex="1"></spacer>`);
+    // this.appendChild(end);
+    this.insertBefore(end, null);
+
+    this.baseConnect();
+  }
+
+  // Accessors for tabs.  This element has spacers as the first and
+  // last elements and <tab>s are everything in between.
+  get firstTab() {
+    return this.children.item(1);
+  }
+
+  get lastTab() {
+    let len = this.children.length;
+    return (len > 2) ? this.children.item(len - 2) : null;
+  }
+
+  get tabCount() {
+    return this.children.length - 2;
+  }
+
+  get allTabs() {
+    let children = Array.from(this.children);
+    return children.splice(1, children.length - 2);
+  }
+
+  appendChild(tab) {
+    // insert before the end spacer.
+    this.insertBefore(tab, this.lastChild);
+  }
+}
+
+customElements.define("tabs", MozTabs);
+}
diff --git a/toolkit/content/widgets/tabbox.xml b/toolkit/content/widgets/tabbox.xml
deleted file mode 100644
--- a/toolkit/content/widgets/tabbox.xml
+++ /dev/null
@@ -1,438 +0,0 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-
-<bindings id="tabBindings"
-          xmlns="http://www.mozilla.org/xbl"
-          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-          xmlns:xbl="http://www.mozilla.org/xbl">
-  <binding id="tabs"
-           extends="chrome://global/content/bindings/general.xml#basecontrol">
-    <content>
-      <xul:spacer class="tabs-left"/>
-      <children/>
-      <xul:spacer class="tabs-right" flex="1"/>
-    </content>
-
-    <implementation implements="nsIDOMXULSelectControlElement, nsIDOMXULRelatedElement">
-      <constructor>
-      <![CDATA[
-
-        if (!this.hasAttribute("orient"))
-          this.setAttribute("orient", "horizontal");
-
-        if (this.tabbox && this.tabbox.hasAttribute("selectedIndex")) {
-          let selectedIndex = parseInt(this.tabbox.getAttribute("selectedIndex"));
-          this.selectedIndex = selectedIndex > 0 ? selectedIndex : 0;
-          return;
-        }
-
-        var children = this.children;
-        var length = children.length;
-        for (var i = 0; i < length; i++) {
-          if (children[i].getAttribute("selected") == "true") {
-            this.selectedIndex = i;
-            return;
-          }
-        }
-
-        var value = this.value;
-        if (value)
-          this.value = value;
-        else
-          this.selectedIndex = 0;
-      ]]>
-      </constructor>
-
-      <property name="firstTab">
-        <getter>
-          return this.firstElementChild;
-        </getter>
-      </property>
-
-      <property name="lastTab">
-        <getter>
-          return this.lastElementChild;
-        </getter>
-      </property>
-
-      <property name="tabCount">
-        <getter>
-          return this.childElementCount;
-        </getter>
-      </property>
-
-      <property name="allTabs">
-        <getter>
-          return Array.from(this.children);
-        </getter>
-      </property>
-
-      <!-- nsIDOMXULRelatedElement -->
-      <method name="getRelatedElement">
-        <parameter name="aTabElm"/>
-        <body>
-        <![CDATA[
-          if (!aTabElm)
-            return null;
-
-          let tabboxElm = this.tabbox;
-          if (!tabboxElm)
-            return null;
-
-          let tabpanelsElm = tabboxElm.tabpanels;
-          if (!tabpanelsElm)
-            return null;
-
-          // Get linked tab panel by 'linkedpanel' attribute on the given tab
-          // element.
-          let linkedPanelId = aTabElm.linkedPanel;
-          if (linkedPanelId) {
-            let ownerDoc = this.ownerDocument;
-
-            // XXX bug 565858: if XUL tab element is anonymous element then
-            // suppose linked tab panel is hosted within the same XBL binding
-            // and search it by ID attribute inside an anonymous content of
-            // the binding. This is not robust assumption since tab elements may
-            // live outside a tabbox element so that for example tab elements
-            // can be explicit content but tab panels can be anonymous.
-
-            let bindingParent = ownerDoc.getBindingParent(aTabElm);
-            if (bindingParent)
-              return ownerDoc.getAnonymousElementByAttribute(bindingParent,
-                                                             "id",
-                                                             linkedPanelId);
-
-            return ownerDoc.getElementById(linkedPanelId);
-          }
-
-          // otherwise linked tabpanel element has the same index as the given
-          // tab element.
-          let tabElmIdx = this.getIndexOfItem(aTabElm);
-          return tabpanelsElm.children[tabElmIdx];
-        ]]>
-        </body>
-      </method>
-
-      <!-- nsIDOMXULSelectControlElement -->
-      <property name="itemCount" readonly="true"
-                onget="return this.children.length"/>
-
-      <property name="value" onget="return this.getAttribute('value');">
-        <setter>
-          <![CDATA[
-            this.setAttribute("value", val);
-            var children = this.children;
-            for (var c = children.length - 1; c >= 0; c--) {
-              if (children[c].value == val) {
-                this.selectedIndex = c;
-                break;
-              }
-            }
-            return val;
-          ]]>
-        </setter>
-      </property>
-
-      <field name="_tabbox">null</field>
-      <property name="tabbox" readonly="true">
-        <getter><![CDATA[
-          // Memoize the result in a field rather than replacing this property,
-          // so that it can be reset along with the binding.
-          if (this._tabbox) {
-            return this._tabbox;
-          }
-
-          let parent = this.parentNode;
-          while (parent) {
-            if (parent.localName == "tabbox") {
-              break;
-            }
-            parent = parent.parentNode;
-          }
-
-          return this._tabbox = parent;
-        ]]></getter>
-      </property>
-
-      <!-- _tabbox is deprecated, it exists only for backwards compatibility. -->
-      <field name="_tabbox" readonly="true"><![CDATA[
-        this.tabbox;
-      ]]></field>
-
-      <field name="_prefService" readonly="true"><![CDATA[
-        Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
-      ]]></field>
-
-      <property name="selectedIndex">
-        <getter>
-        <![CDATA[
-          const tabs = this.children;
-          for (var i = 0; i < tabs.length; i++) {
-            if (tabs[i].selected)
-              return i;
-          }
-          return -1;
-        ]]>
-        </getter>
-
-        <setter>
-        <![CDATA[
-          var tab = this.getItemAtIndex(val);
-          if (tab) {
-            for (let otherTab of this.children) {
-              if (otherTab != tab && otherTab.selected) {
-                otherTab._selected = false;
-              }
-            }
-            tab._selected = true;
-
-            this.setAttribute("value", tab.value);
-
-            let linkedPanel = this.getRelatedElement(tab);
-            if (linkedPanel) {
-              this.tabbox.setAttribute("selectedIndex", val);
-
-              // This will cause an onselect event to fire for the tabpanel
-              // element.
-              this.tabbox.tabpanels.selectedPanel = linkedPanel;
-            }
-          }
-          return val;
-        ]]>
-        </setter>
-      </property>
-
-      <property name="selectedItem">
-        <getter>
-        <![CDATA[
-          const tabs = this.children;
-          for (var i = 0; i < tabs.length; i++) {
-            if (tabs[i].selected)
-              return tabs[i];
-          }
-          return null;
-        ]]>
-        </getter>
-
-        <setter>
-        <![CDATA[
-          if (val && !val.selected)
-            // The selectedIndex setter ignores invalid values
-            // such as -1 if |val| isn't one of our child nodes.
-            this.selectedIndex = this.getIndexOfItem(val);
-          return val;
-        ]]>
-        </setter>
-      </property>
-
-      <field name="ACTIVE_DESCENDANT_ID" readonly="true"><![CDATA[
-        "keyboard-focused-tab-" + Math.trunc(Math.random() * 1000000);
-      ]]></field>
-
-      <property name="ariaFocusedIndex" readonly="true">
-        <getter>
-        <![CDATA[
-          const tabs = this.children;
-          for (var i = 0; i < tabs.length; i++) {
-            if (tabs[i].id == this.ACTIVE_DESCENDANT_ID)
-              return i;
-          }
-          return -1;
-        ]]>
-        </getter>
-      </property>
-
-      <property name="ariaFocusedItem">
-        <getter>
-        <![CDATA[
-          return document.getElementById(this.ACTIVE_DESCENDANT_ID);
-        ]]>
-        </getter>
-
-        <setter>
-        <![CDATA[
-          let setNewItem = val && this.getIndexOfItem(val) != -1;
-          let clearExistingItem = this.ariaFocusedItem && (!val || setNewItem);
-          if (clearExistingItem) {
-            let ariaFocusedItem = this.ariaFocusedItem;
-            ariaFocusedItem.classList.remove("keyboard-focused-tab");
-            ariaFocusedItem.id = "";
-            this.selectedItem.removeAttribute("aria-activedescendant");
-          }
-
-          if (setNewItem) {
-            this.ariaFocusedItem = null;
-            val.id = this.ACTIVE_DESCENDANT_ID;
-            val.classList.add("keyboard-focused-tab");
-            this.selectedItem.setAttribute("aria-activedescendant", this.ACTIVE_DESCENDANT_ID);
-          }
-
-          return val;
-        ]]>
-        </setter>
-      </property>
-
-      <method name="getIndexOfItem">
-        <parameter name="item"/>
-        <body>
-        <![CDATA[
-          return Array.prototype.indexOf.call(this.children, item);
-        ]]>
-        </body>
-      </method>
-
-      <method name="getItemAtIndex">
-        <parameter name="index"/>
-        <body>
-        <![CDATA[
-          return this.children.item(index);
-        ]]>
-        </body>
-      </method>
-
-      <method name="findNextTab">
-        <parameter name="startTab"/>
-        <parameter name="direction"/>
-        <parameter name="wrap"/>
-        <parameter name="advance"/>
-        <parameter name="filter"/>
-        <body>
-        <![CDATA[
-          if (advance === undefined) {
-            advance = false;
-          }
-          if (filter === undefined) {
-            filter = tab => true;
-          }
-
-          let tab = startTab;
-          if (!advance && filter(tab)) {
-            return tab;
-          }
-
-          let tabs = this.allTabs;
-          let i = tabs.indexOf(tab);
-          if (i < 0) {
-            return null;
-          }
-
-          while (true) {
-            i += direction;
-            if (wrap) {
-              if (i < 0) {
-                i = tabs.length - 1;
-              } else if (i >= tabs.length) {
-                i = 0;
-              }
-            } else if (i < 0 || i >= tabs.length) {
-              return null;
-            }
-
-            tab = tabs[i];
-            if (tab == startTab) {
-              return null;
-            }
-            if (filter(tab)) {
-              return tab;
-            }
-          }
-        ]]>
-        </body>
-      </method>
-
-      <method name="_selectNewTab">
-        <parameter name="aNewTab"/>
-        <parameter name="aFallbackDir"/>
-        <parameter name="aWrap"/>
-        <body>
-        <![CDATA[
-          this.ariaFocusedItem = null;
-
-          aNewTab = this.findNextTab(aNewTab, aFallbackDir, aWrap, false,
-                                     tab => !tab.hidden && !tab.disabled && this._canAdvanceToTab(tab));
-
-          var isTabFocused = false;
-          try {
-            isTabFocused =
-              (document.commandDispatcher.focusedElement == this.selectedItem);
-          } catch (e) {}
-          this.selectedItem = aNewTab;
-          if (isTabFocused) {
-            aNewTab.focus();
-          } else if (this.getAttribute("setfocus") != "false") {
-            let selectedPanel = this.tabbox.selectedPanel;
-            document.commandDispatcher.advanceFocusIntoSubtree(selectedPanel);
-
-            // Make sure that the focus doesn't move outside the tabbox
-            if (this.tabbox) {
-              try {
-                let el = document.commandDispatcher.focusedElement;
-                while (el && el != this.tabbox.tabpanels) {
-                  if (el == this.tabbox || el == selectedPanel)
-                    return;
-                  el = el.parentNode;
-                }
-                aNewTab.focus();
-              } catch (e) {
-              }
-            }
-          }
-        ]]>
-        </body>
-      </method>
-
-      <method name="_canAdvanceToTab">
-        <parameter name="aTab"/>
-        <body>
-        <![CDATA[
-          return true;
-        ]]>
-        </body>
-      </method>
-
-      <method name="advanceSelectedTab">
-        <parameter name="aDir"/>
-        <parameter name="aWrap"/>
-        <body>
-        <![CDATA[
-          var startTab = this.ariaFocusedItem || this.selectedItem;
-          let newTab = this.findNextTab(startTab, aDir, aWrap, true);
-          this._selectNewTab(newTab, aDir, aWrap);
-        ]]>
-        </body>
-      </method>
-
-      <method name="appendItem">
-        <parameter name="label"/>
-        <parameter name="value"/>
-        <body>
-        <![CDATA[
-          var tab = document.createXULElement("tab");
-          tab.setAttribute("label", label);
-          tab.setAttribute("value", value);
-          this.appendChild(tab);
-          return tab;
-        ]]>
-        </body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <handler event="DOMMouseScroll">
-      <![CDATA[
-        if (this._prefService.getBoolPref("toolkit.tabbox.switchByScrolling")) {
-          if (event.detail > 0) {
-            this.advanceSelectedTab(1, false);
-          } else {
-            this.advanceSelectedTab(-1, false);
-          }
-          event.stopPropagation();
-        }
-      ]]>
-      </handler>
-    </handlers>
-  </binding>
-</bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -403,17 +403,16 @@ stack {
 
 /********** tabbox *********/
 
 tabbox {
   -moz-box-orient: vertical;
 }
 
 tabs {
-  -moz-binding: url("chrome://global/content/bindings/tabbox.xml#tabs");
   -moz-box-orient: horizontal;
 }
 
 tab {
   -moz-box-align: center;
   -moz-box-pack: center;
 }
 

