# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b3a8be45ab9b8248eb9770d29d52196ba09d5ce0

diff --git a/toolkit/components/extensions/ExtensionParent.jsm b/toolkit/components/extensions/ExtensionParent.jsm
--- a/toolkit/components/extensions/ExtensionParent.jsm
+++ b/toolkit/components/extensions/ExtensionParent.jsm
@@ -1306,21 +1306,25 @@ class HiddenXULWindow {
       attrs.privateBrowsingId = 1;
       chromeShell.setOriginAttributes(attrs);
     }
 
     let system = Services.scriptSecurityManager.getSystemPrincipal();
     chromeShell.createAboutBlankContentViewer(system, system);
     chromeShell.useGlobalHistory = false;
 
+    chromeShell.document.ownerGlobal.isDummyExtensionDocument = true;
+    console.log(chromeShell.document.readyState, windowlessBrowser.document.ownerGlobal.location.toString(), chromeShell.document.ownerGlobal.isDummyExtensionDocument);
     Services.scriptloader.loadSubScript(
       "chrome://global/content/customElements.js",
       windowlessBrowser.document.ownerGlobal
     );
     this._windowlessBrowser = windowlessBrowser;
+
+    await new Promise(r=>chromeShell.document.ownerGlobal.setTimeout(r, 1000))
   }
 
   /**
    * Creates the browser XUL element that will contain the WebExtension Page.
    *
    * @param {Object} xulAttributes
    *        An object that contains the xul attributes to set of the newly
    *        created browser XUL element.
@@ -1352,16 +1356,17 @@ class HiddenXULWindow {
     }
 
     let awaitFrameLoader = Promise.resolve();
 
     if (browser.getAttribute("remote") === "true") {
       awaitFrameLoader = promiseEvent(browser, "XULFrameLoaderCreated");
     }
 
+    console.log(chromeDoc, chromeDoc.documentElement);
     chromeDoc.documentElement.appendChild(browser);
     await awaitFrameLoader;
 
     return browser;
   }
 }
 
 const SharedWindow = {
diff --git a/toolkit/components/extensions/parent/ext-backgroundPage.js b/toolkit/components/extensions/parent/ext-backgroundPage.js
--- a/toolkit/components/extensions/parent/ext-backgroundPage.js
+++ b/toolkit/components/extensions/parent/ext-backgroundPage.js
@@ -62,16 +62,17 @@ class BackgroundPage extends HiddenExten
 
       let contextPromise = promiseExtensionViewLoaded(this.browser);
       this.browser.loadURI(this.url, {
         triggeringPrincipal: extension.principal,
       });
 
       context = await contextPromise;
     } catch (e) {
+      debugger;
       // Extension was down before the background page has loaded.
       Cu.reportError(e);
       ExtensionTelemetry.backgroundPageLoad.stopwatchCancel(extension, this);
       EventManager.clearPrimedListeners(this.extension, false);
       extension.emit("background-page-aborted");
       return;
     }
 
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -201,37 +201,40 @@
       },
     });
   }
 
   // The listener of DOMContentLoaded must be set on window, rather than
   // document, because the window can go away before the event is fired.
   // In that case, we don't want to initialize anything, otherwise we
   // may be leaking things because they will never be destroyed after.
-  let gIsDOMContentLoaded = false;
+  let gIsDOMContentLoaded = window.location.toString() == "about:blank";
   const gElementsPendingConnection = new Set();
-  window.addEventListener(
-    "DOMContentLoaded",
-    () => {
-      gIsDOMContentLoaded = true;
-      for (let element of gElementsPendingConnection) {
-        try {
-          if (element.isConnected) {
-            element.isRunningDelayedConnectedCallback = true;
-            element.connectedCallback();
+
+  if (!gIsDOMContentLoaded) {
+    window.addEventListener(
+      "DOMContentLoaded",
+      () => {
+        gIsDOMContentLoaded = true;
+        for (let element of gElementsPendingConnection) {
+          try {
+            if (element.isConnected) {
+              element.isRunningDelayedConnectedCallback = true;
+              element.connectedCallback();
+            }
+          } catch (ex) {
+            console.error(ex);
           }
-        } catch (ex) {
-          console.error(ex);
+          element.isRunningDelayedConnectedCallback = false;
         }
-        element.isRunningDelayedConnectedCallback = false;
-      }
-      gElementsPendingConnection.clear();
-    },
-    { once: true, capture: true }
-  );
+        gElementsPendingConnection.clear();
+      },
+      { once: true, capture: true }
+    );
+  }
 
   const gXULDOMParser = new DOMParser();
   gXULDOMParser.forceEnableXULXBL();
 
   MozElements.MozElementMixin = Base => {
     let MozElementBase = class extends Base {
       constructor() {
         super();
@@ -744,19 +747,17 @@
     Services.scriptloader.loadSubScript(
       "chrome://global/content/elements/browser-custom-element.js",
       window
     );
   });
 
   // For now, don't load any elements in the extension dummy document.
   // We will want to load <browser> when that's migrated (bug 1441935).
-  const isDummyDocument =
-    document.documentURI == "chrome://extensions/content/dummy.xul";
-  if (!isDummyDocument) {
+  if (!window.isDummyExtensionDocument) {
     for (let script of [
       "chrome://global/content/elements/dialog.js",
       "chrome://global/content/elements/general.js",
       "chrome://global/content/elements/button.js",
       "chrome://global/content/elements/checkbox.js",
       "chrome://global/content/elements/menu.js",
       "chrome://global/content/elements/menupopup.js",
       "chrome://global/content/elements/notificationbox.js",
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -374,19 +374,19 @@
 
       this._autoScrollPresShellId = null;
     }
 
     connectedCallback() {
       // We typically use this to avoid running JS that triggers a layout during parse
       // (see comment on the delayConnectedCallback implementation). In this case, we
       // are using it to avoid a leak - see https://bugzilla.mozilla.org/show_bug.cgi?id=1441935#c20.
-      if (this.delayConnectedCallback()) {
-        return;
-      }
+      // if (this.delayConnectedCallback()) {
+      //   return;
+      // }
 
       this.construct();
     }
 
     disconnectedCallback() {
       this.destroy();
     }
 
