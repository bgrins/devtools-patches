# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2608d55b561a01464d8b823f4114c0d43ef0b1b4

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -3,38 +3,60 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
+  window.addEventListener("keypress", (e) => {
+    if (e.originalTarget instanceof MozTextLabel) {
+      e.originalTarget._onKeyPress(e);
+    }
+  });
+
+  window.addEventListener("click", (e) => {
+    if (e.originalTarget instanceof MozTextLabel) {
+      e.originalTarget._onClick(e);
+    }
+  }, true);
+
+  let waitingForFormat = true;
+  let waitingSet = new Set();
+  window.addEventListener("load", () => {
+    waitingForFormat = false;
+    for (let el of waitingSet) {
+      el.formatAccessKey();
+    }
+    waitingSet.clear();
+  }, { once: true });
+
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
+
+  constructor() {
+    super();
+    setGlobalAccessKeyFormattingState();
+    this._lastFormattedAccessKey = null;
+    // this.addEventListener("click", this, true);
+    // this.addEventListener("keypress", this);
+  }
+
   static get observedAttributes() {
-    return ["accesskey", "text"];
+    return ["accesskey"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue == newValue) {
       return;
     }
     this.formatAccessKey();
   }
 
-  get needsFormatting() {
-    return true;
-    // return !this.closest("groupbox[hidden]");
-    // return this.hasAttribute("control") ||
-    //        this.classList.contains("radio-label") ||
-    //        this.classList.contains("checkbox-label") ||
-    //        this.classList.contains("toolbarbutton-multiline-text");
-  }
-
   _onClick(event) {
     if (this.isTextLink) {
       if (event.button == 0 || event.button == 1) {
         this.openLink(event);
       }
       return;
     }
 
@@ -56,53 +78,39 @@ class MozTextLabel extends MozElementMix
   }
 
   _onKeyPress(event) {
     if (event.keyCode == 13) {
       this.click();
     }
   }
 
-  handleEvent(event) {
-    if (event.type == "click") {
-      this._onClick(event);
-    } else if (event.type == "keypress") {
-      this._onKeyPress(event);
-    }
-  }
+  // handleEvent(event) {
+  //   if (event.type == "click") {
+  //     this._onClick(event);
+  //   } else if (event.type == "keypress") {
+  //     this._onKeyPress(event);
+  //   }
+  // }
 
   connectedCallback() {
-    if (this.delayConnectedCallback()) {
-      return;
-    }
-
-    if (!this.connectedOnce) {
-      this.connectedOnce = true;
-      this._lastFormattedAccessKey = null;
-      this.addEventListener("click", this, true);
-      if (this.isTextLink) {
-        this.addEventListener("keypress", this);
-      }
-    }
-
-    setGlobalAccessKeyFormattingState();
     this.formatAccessKey();
   }
 
   get isTextLink() {
     return this.classList.contains("text-link") || this.hasAttribute("onClick");
   }
 
   set accessKey(val) {
     this.setAttribute("accesskey", val);
   }
 
   get accessKey() {
     let accessKey = this.getAttribute("accesskey");
-    return accessKey ? accessKey[0] : null;
+    return (accessKey && accessKey[0]) || null;
   }
 
   get labeledControlElement() {
     let control = this.control;
     return control ? document.getElementById(control) : null;
   }
 
   set control(val) {
@@ -119,26 +127,31 @@ class MozTextLabel extends MozElementMix
 
   get href() {
     return this.getAttribute("href");
   }
 
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey() {
+    if (waitingForFormat) {
+      waitingSet.add(this);
+      return;
+    }
+
     // Skip doing any DOM manipulation whenever possible:
     let accessKey = this.accessKey;
     if (!gUnderlineAccesskey ||
+        !this.isConnectedAndReady ||
         this._lastFormattedAccessKey == accessKey ||
-        !this.textContent ||
-        !this.needsFormatting) {
+        !this.textContent) {
       return;
     }
+
     this._lastFormattedAccessKey = accessKey;
-
     if (this.accessKeySpan) { // Clear old accesskey
       mergeElement(this.accessKeySpan);
       this.accessKeySpan = null;
     }
 
     if (this.hiddenColon) {
       mergeElement(this.hiddenColon);
       this.hiddenColon = null;
@@ -325,17 +338,17 @@ function wrapChar(parent, element, index
   element.appendChild(node);
 }
 
 let gInsertSeparator;
 let gUnderlineAccesskey;
 let gAlwaysAppendAccessKey = false;
 function setGlobalAccessKeyFormattingState() {
   if (gUnderlineAccesskey === undefined) {
-    gUnderlineAccesskey = true; // Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+    gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
   }
   if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
     return;
   }
   try {
     const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
     const prefNameInsertSeparator =
       "intl.menuitems.insertseparatorbeforeaccesskeys";
