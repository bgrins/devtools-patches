# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2608d55b561a01464d8b823f4114c0d43ef0b1b4

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -3,30 +3,51 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
+  let waitingForFormat = true;
+  let waitingSet = new Set();
+  window.addEventListener("load", () => {
+    waitingForFormat = false;
+    // let d = Date.now();
+    for (let el of waitingSet) {
+      el.formatAccessKey();
+    }
+    // console.log(Date.now() - d);
+    waitingSet.clear();
+  }, { once: true });
+
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
+
+  constructor() {
+    super();
+    setGlobalAccessKeyFormattingState();
+    this._lastFormattedAccessKey = null;
+    this.addEventListener("click", this, true);
+    this.addEventListener("keypress", this);
+  }
   static get observedAttributes() {
     return ["accesskey", "text"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue == newValue) {
       return;
     }
     this.formatAccessKey();
   }
 
   get needsFormatting() {
+
     return true;
     // return !this.closest("groupbox[hidden]");
     // return this.hasAttribute("control") ||
     //        this.classList.contains("radio-label") ||
     //        this.classList.contains("checkbox-label") ||
     //        this.classList.contains("toolbarbutton-multiline-text");
   }
 
@@ -65,44 +86,44 @@ class MozTextLabel extends MozElementMix
     if (event.type == "click") {
       this._onClick(event);
     } else if (event.type == "keypress") {
       this._onKeyPress(event);
     }
   }
 
   connectedCallback() {
-    if (this.delayConnectedCallback()) {
-      return;
-    }
+    // if (this.delayConnectedCallback()) {
+    //   console.log("Delaying");
+    //   return;
+    // }
 
-    if (!this.connectedOnce) {
-      this.connectedOnce = true;
-      this._lastFormattedAccessKey = null;
-      this.addEventListener("click", this, true);
-      if (this.isTextLink) {
-        this.addEventListener("keypress", this);
-      }
-    }
-
-    setGlobalAccessKeyFormattingState();
+    // if (!this.connectedOnce) {
+    //   this.connectedOnce = true;
+    //   this._lastFormattedAccessKey = null;
+    //   this.addEventListener("click", this, true);
+    //   if (this.isTextLink) {
+    //     this.addEventListener("keypress", this);
+    //   }
+    // }
+    // setGlobalAccessKeyFormattingState();
     this.formatAccessKey();
   }
 
   get isTextLink() {
     return this.classList.contains("text-link") || this.hasAttribute("onClick");
   }
 
   set accessKey(val) {
     this.setAttribute("accesskey", val);
   }
 
   get accessKey() {
     let accessKey = this.getAttribute("accesskey");
-    return accessKey ? accessKey[0] : null;
+    return (accessKey && accessKey[0]) || null;
   }
 
   get labeledControlElement() {
     let control = this.control;
     return control ? document.getElementById(control) : null;
   }
 
   set control(val) {
@@ -119,41 +140,53 @@ class MozTextLabel extends MozElementMix
 
   get href() {
     return this.getAttribute("href");
   }
 
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey() {
+    if (waitingForFormat) {
+      waitingSet.add(this);
+      return;
+    }
+
     // Skip doing any DOM manipulation whenever possible:
     let accessKey = this.accessKey;
+
     if (!gUnderlineAccesskey ||
+        !this.isConnectedAndReady ||
         this._lastFormattedAccessKey == accessKey ||
-        !this.textContent ||
-        !this.needsFormatting) {
+        !this.textContent) {
       return;
     }
+
     this._lastFormattedAccessKey = accessKey;
-
     if (this.accessKeySpan) { // Clear old accesskey
       mergeElement(this.accessKeySpan);
       this.accessKeySpan = null;
     }
 
     if (this.hiddenColon) {
       mergeElement(this.hiddenColon);
       this.hiddenColon = null;
     }
 
     if (this.accessKeyParens) {
       this.accessKeyParens.remove();
       this.accessKeyParens = null;
     }
 
+    // let hiddenGroupbox = this.closest("groupbox[hidden]");
+    // if (hiddenGroupbox) {
+    //   waitForVisible(hiddenGroupbox, this);
+    //   return;
+    // }
+
     // If we used to have an accessKey but not anymore, we're done here
     if (!accessKey) {
       return;
     }
 
     let labelText = this.textContent;
     let accessKeyIndex = -1;
     if (!gAlwaysAppendAccessKey) {
@@ -287,16 +320,33 @@ class MozTextLabel extends MozElementMix
         win = win.opener;
     }
     win.open(href);
   }
 }
 
 customElements.define("label", MozTextLabel);
 
+// let waitingForVisibleElements = new WeakMap();
+// function waitForVisible(el, label) {
+//   if (!waitingForVisibleElements.has(el)) {
+//     // Create an observer instance linked to the callback function
+//     var observer = new MutationObserver((mutationsList) => {
+//       console.log("Got", el.id, mutationsList, waitingForVisibleElements.get(el));
+//       observer.disconnect();
+//     });
+//     console.log(el.hidden);
+//     // Start observing the target node for configured mutations
+//     observer.observe(el, { attributes: true, attributeFilter: ["hidden"] });
+//     waitingForVisibleElements.set(el, new Set());
+//   }
+
+//   waitingForVisibleElements.get(el).add(label);
+// }
+
 function mergeElement(element) {
   // If the element has been removed already, return:
   if (!element.isConnected) {
     return;
   }
   if (element.previousSibling instanceof Text) {
     element.previousSibling.appendData(element.textContent);
   } else {
@@ -325,17 +375,17 @@ function wrapChar(parent, element, index
   element.appendChild(node);
 }
 
 let gInsertSeparator;
 let gUnderlineAccesskey;
 let gAlwaysAppendAccessKey = false;
 function setGlobalAccessKeyFormattingState() {
   if (gUnderlineAccesskey === undefined) {
-    gUnderlineAccesskey = true; // Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+    gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
   }
   if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
     return;
   }
   try {
     const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
     const prefNameInsertSeparator =
       "intl.menuitems.insertseparatorbeforeaccesskeys";
