# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2608d55b561a01464d8b823f4114c0d43ef0b1b4

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -3,38 +3,58 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
+  window.addEventListener("keypress", (e) => {
+
+  });
+
+  window.addEventListener("click", (e) => {
+
+  });
+
+  let waitingForFormat = true;
+  let waitingSet = new Set();
+  window.addEventListener("load", () => {
+    waitingForFormat = false;
+    // let d = Date.now();
+    for (let el of waitingSet) {
+      el.formatAccessKey();
+    }
+    // console.log(Date.now() - d);
+    waitingSet.clear();
+  }, { once: true });
+
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
+
+  constructor() {
+    super();
+    setGlobalAccessKeyFormattingState();
+    this._lastFormattedAccessKey = null;
+    // this.addEventListener("click", this, true);
+    // this.addEventListener("keypress", this);
+  }
+
   static get observedAttributes() {
-    return ["accesskey", "text"];
+    return ["accesskey"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue == newValue) {
       return;
     }
     this.formatAccessKey();
   }
 
-  get needsFormatting() {
-    return true;
-    // return !this.closest("groupbox[hidden]");
-    // return this.hasAttribute("control") ||
-    //        this.classList.contains("radio-label") ||
-    //        this.classList.contains("checkbox-label") ||
-    //        this.classList.contains("toolbarbutton-multiline-text");
-  }
-
   _onClick(event) {
     if (this.isTextLink) {
       if (event.button == 0 || event.button == 1) {
         this.openLink(event);
       }
       return;
     }
 
@@ -65,44 +85,30 @@ class MozTextLabel extends MozElementMix
     if (event.type == "click") {
       this._onClick(event);
     } else if (event.type == "keypress") {
       this._onKeyPress(event);
     }
   }
 
   connectedCallback() {
-    if (this.delayConnectedCallback()) {
-      return;
-    }
-
-    if (!this.connectedOnce) {
-      this.connectedOnce = true;
-      this._lastFormattedAccessKey = null;
-      this.addEventListener("click", this, true);
-      if (this.isTextLink) {
-        this.addEventListener("keypress", this);
-      }
-    }
-
-    setGlobalAccessKeyFormattingState();
     this.formatAccessKey();
   }
 
   get isTextLink() {
     return this.classList.contains("text-link") || this.hasAttribute("onClick");
   }
 
   set accessKey(val) {
     this.setAttribute("accesskey", val);
   }
 
   get accessKey() {
     let accessKey = this.getAttribute("accesskey");
-    return accessKey ? accessKey[0] : null;
+    return (accessKey && accessKey[0]) || null;
   }
 
   get labeledControlElement() {
     let control = this.control;
     return control ? document.getElementById(control) : null;
   }
 
   set control(val) {
@@ -119,41 +125,52 @@ class MozTextLabel extends MozElementMix
 
   get href() {
     return this.getAttribute("href");
   }
 
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey() {
+    if (waitingForFormat) {
+      waitingSet.add(this);
+      return;
+    }
+
     // Skip doing any DOM manipulation whenever possible:
     let accessKey = this.accessKey;
     if (!gUnderlineAccesskey ||
+        !this.isConnectedAndReady ||
         this._lastFormattedAccessKey == accessKey ||
-        !this.textContent ||
-        !this.needsFormatting) {
+        !this.textContent) {
       return;
     }
+
     this._lastFormattedAccessKey = accessKey;
-
     if (this.accessKeySpan) { // Clear old accesskey
       mergeElement(this.accessKeySpan);
       this.accessKeySpan = null;
     }
 
     if (this.hiddenColon) {
       mergeElement(this.hiddenColon);
       this.hiddenColon = null;
     }
 
     if (this.accessKeyParens) {
       this.accessKeyParens.remove();
       this.accessKeyParens = null;
     }
 
+    // let hiddenGroupbox = this.closest("groupbox[hidden]");
+    // if (hiddenGroupbox) {
+    //   waitForVisible(hiddenGroupbox, this);
+    //   return;
+    // }
+
     // If we used to have an accessKey but not anymore, we're done here
     if (!accessKey) {
       return;
     }
 
     let labelText = this.textContent;
     let accessKeyIndex = -1;
     if (!gAlwaysAppendAccessKey) {
@@ -287,30 +304,50 @@ class MozTextLabel extends MozElementMix
         win = win.opener;
     }
     win.open(href);
   }
 }
 
 customElements.define("label", MozTextLabel);
 
+// let waitingForVisibleElements = new WeakMap();
+// function waitForVisible(el, label) {
+//   if (!waitingForVisibleElements.has(el)) {
+//     // Create an observer instance linked to the callback function
+//     var observer = new MutationObserver((mutationsList) => {
+//       console.log("Got", el.id, mutationsList, waitingForVisibleElements.get(el));
+//       observer.disconnect();
+//     });
+//     console.log(el.hidden);
+//     // Start observing the target node for configured mutations
+//     observer.observe(el, { attributes: true, attributeFilter: ["hidden"] });
+//     waitingForVisibleElements.set(el, new Set());
+//   }
+
+//   waitingForVisibleElements.get(el).add(label);
+// }
+
 function mergeElement(element) {
   // If the element has been removed already, return:
   if (!element.isConnected) {
     return;
   }
   if (element.previousSibling instanceof Text) {
     element.previousSibling.appendData(element.textContent);
   } else {
     element.parentNode.insertBefore(element.firstChild, element);
   }
   element.remove();
 }
 
 function wrapChar(parent, element, index) {
+  if (parent.childNodes.length != 1) {
+    console.log("More than one node", parent);
+  }
   let treeWalker = document.createNodeIterator(parent,
     NodeFilter.SHOW_TEXT,
     null);
   let node = treeWalker.nextNode();
   while (index >= node.length) {
     index -= node.length;
     node = treeWalker.nextNode();
   }
