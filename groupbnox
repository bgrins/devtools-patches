# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  2608d55b561a01464d8b823f4114c0d43ef0b1b4

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -3,38 +3,73 @@
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
+// Queue up all formatting until so we don't block page load
+// doing a bunch of work in the DOM.
+let waitingForFormat = true;
+let waitingSet = new Set();
+let gInsertSeparator = false;
+let gUnderlineAccesskey = false;
+let gAlwaysAppendAccessKey = false;
+window.addEventListener("load", () => {
+  gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+  if (gUnderlineAccesskey) {
+    try {
+      const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
+      const prefNameInsertSeparator =
+        "intl.menuitems.insertseparatorbeforeaccesskeys";
+      const prefNameAlwaysAppendAccessKey =
+        "intl.menuitems.alwaysappendaccesskeys";
+
+      let val = Services.prefs.getComplexValue(prefNameInsertSeparator,
+        nsIPrefLocalizedString).data;
+      gInsertSeparator = val == "true";
+
+      val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+        nsIPrefLocalizedString).data;
+      gAlwaysAppendAccessKey = val == "true";
+    } catch (e) {
+      gInsertSeparator = gAlwaysAppendAccessKey = true;
+    }
+  }
+
+  waitingForFormat = false;
+  for (let el of waitingSet) {
+    el.formatAccessKey();
+  }
+  waitingSet.clear();
+}, { once: true });
+
 /* globals MozElementMixin,XULTextElement */
 class MozTextLabel extends MozElementMixin(XULTextElement) {
+
+  constructor() {
+    super();
+    // setGlobalAccessKeyFormattingState();
+    this._lastFormattedAccessKey = null;
+    this._connectedOnce = false;
+  }
+
   static get observedAttributes() {
-    return ["accesskey", "text"];
+    return ["accesskey"];
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue == newValue) {
       return;
     }
     this.formatAccessKey();
   }
 
-  get needsFormatting() {
-    return true;
-    // return !this.closest("groupbox[hidden]");
-    // return this.hasAttribute("control") ||
-    //        this.classList.contains("radio-label") ||
-    //        this.classList.contains("checkbox-label") ||
-    //        this.classList.contains("toolbarbutton-multiline-text");
-  }
-
   _onClick(event) {
     if (this.isTextLink) {
       if (event.button == 0 || event.button == 1) {
         this.openLink(event);
       }
       return;
     }
 
@@ -56,53 +91,38 @@ class MozTextLabel extends MozElementMix
   }
 
   _onKeyPress(event) {
     if (event.keyCode == 13) {
       this.click();
     }
   }
 
-  handleEvent(event) {
-    if (event.type == "click") {
-      this._onClick(event);
-    } else if (event.type == "keypress") {
-      this._onKeyPress(event);
-    }
-  }
-
   connectedCallback() {
-    if (this.delayConnectedCallback()) {
-      return;
-    }
-
-    if (!this.connectedOnce) {
-      this.connectedOnce = true;
-      this._lastFormattedAccessKey = null;
-      this.addEventListener("click", this, true);
+    this.formatAccessKey();
+    if (!this._connectedOnce) {
+      this._connectedOnce = true;
+      this.addEventListener("click", this._onClick, true);
       if (this.isTextLink) {
-        this.addEventListener("keypress", this);
+        this.addEventListener("keypress", this._onKeyPress);
       }
     }
-
-    setGlobalAccessKeyFormattingState();
-    this.formatAccessKey();
   }
 
   get isTextLink() {
     return this.classList.contains("text-link") || this.hasAttribute("onClick");
   }
 
   set accessKey(val) {
     this.setAttribute("accesskey", val);
   }
 
   get accessKey() {
     let accessKey = this.getAttribute("accesskey");
-    return accessKey ? accessKey[0] : null;
+    return (accessKey && accessKey[0]) || null;
   }
 
   get labeledControlElement() {
     let control = this.control;
     return control ? document.getElementById(control) : null;
   }
 
   set control(val) {
@@ -119,26 +139,31 @@ class MozTextLabel extends MozElementMix
 
   get href() {
     return this.getAttribute("href");
   }
 
   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
   // label uses [value]). So this is just for when we have textContent.
   formatAccessKey() {
+    if (waitingForFormat) {
+      waitingSet.add(this);
+      return;
+    }
+
     // Skip doing any DOM manipulation whenever possible:
     let accessKey = this.accessKey;
     if (!gUnderlineAccesskey ||
+        !this.isConnectedAndReady ||
         this._lastFormattedAccessKey == accessKey ||
-        !this.textContent ||
-        !this.needsFormatting) {
+        !this.textContent) {
       return;
     }
+
     this._lastFormattedAccessKey = accessKey;
-
     if (this.accessKeySpan) { // Clear old accesskey
       mergeElement(this.accessKeySpan);
       this.accessKeySpan = null;
     }
 
     if (this.hiddenColon) {
       mergeElement(this.hiddenColon);
       this.hiddenColon = null;
@@ -320,38 +345,9 @@ function wrapChar(parent, element, index
 
   node.parentNode.insertBefore(element, node);
   if (node.length > 1) {
     node.splitText(1);
   }
   element.appendChild(node);
 }
 
-let gInsertSeparator;
-let gUnderlineAccesskey;
-let gAlwaysAppendAccessKey = false;
-function setGlobalAccessKeyFormattingState() {
-  if (gUnderlineAccesskey === undefined) {
-    gUnderlineAccesskey = true; // Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
-  }
-  if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
-    return;
-  }
-  try {
-    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
-    const prefNameInsertSeparator =
-      "intl.menuitems.insertseparatorbeforeaccesskeys";
-    const prefNameAlwaysAppendAccessKey =
-      "intl.menuitems.alwaysappendaccesskeys";
-
-    let val = Services.prefs.getComplexValue(prefNameInsertSeparator,
-      nsIPrefLocalizedString).data;
-    gInsertSeparator = val == "true";
-
-    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
-      nsIPrefLocalizedString).data;
-    gAlwaysAppendAccessKey = val == "true";
-  } catch (e) {
-    gInsertSeparator = gAlwaysAppendAccessKey = true;
-  }
 }
-
-}
