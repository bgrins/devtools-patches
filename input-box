# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5bbe54174894e1b71aaf83006c2744bb8836816e
Bug XXX - migrate input-box and input-box-spell to customized built ins

diff --git a/browser/base/content/test/contextMenu/browser_contextmenu_touch.js b/browser/base/content/test/contextMenu/browser_contextmenu_touch.js
--- a/browser/base/content/test/contextMenu/browser_contextmenu_touch.js
+++ b/browser/base/content/test/contextMenu/browser_contextmenu_touch.js
@@ -19,16 +19,17 @@ async function openAndCheckContextMenu(c
 
   popupshown = BrowserTestUtils.waitForEvent(contextMenu, "popupshown");
   EventUtils.synthesizeMouseAtCenter(target, {type: "contextmenu"});
   await popupshown;
 
   is(contextMenu.state, "open", "Context menu is open.");
   ok(!contextMenu.hasAttribute("touchmode"), "Context menu is not in touchmode.");
 
+
   contextMenu.hidePopup();
 }
 
 // Ensure that we can run touch events properly for windows [10]
 add_task(async function setup() {
   let isWindows = AppConstants.isPlatformAndVersionAtLeast("win", "10.0");
   await SpecialPowers.pushPrefEnv({
     set: [
@@ -71,13 +72,12 @@ add_task(async function test_toolbar_con
   let target = document.getElementById("PanelUI-menu-button");
   await openAndCheckContextMenu(toolbarContextMenu, target);
 });
 
 // Test the urlbar input context menu.
 add_task(async function test_urlbar_contextmenu_touch() {
   let urlbar = document.getElementById("urlbar");
   let textBox = document.getAnonymousElementByAttribute(urlbar,
-                                      "anonid", "textbox-input-box");
-  let menu = document.getAnonymousElementByAttribute(textBox,
-                                      "anonid", "input-box-contextmenu");
+                                      "is", "textbox-input-box");
+  let menu = textBox.menuPopup;
   await openAndCheckContextMenu(menu, textBox);
 });
diff --git a/browser/base/content/test/performance/browser_appmenu.js b/browser/base/content/test/performance/browser_appmenu.js
--- a/browser/base/content/test/performance/browser_appmenu.js
+++ b/browser/base/content/test/performance/browser_appmenu.js
@@ -38,17 +38,17 @@ const EXPECTED_APPMENU_OPEN_REFLOWS = [
     maxCount: 7, // This number should only ever go down - never up.
   },
 ];
 
 add_task(async function() {
   await ensureNoPreloadedBrowser();
 
   let textBoxRect = document.getAnonymousElementByAttribute(gURLBar,
-    "anonid", "textbox-input-box").getBoundingClientRect();
+    "is", "textbox-input-box").getBoundingClientRect();
   let menuButtonRect =
     document.getElementById("PanelUI-menu-button").getBoundingClientRect();
   let frameExpectations = {
     filter: rects => rects.filter(r => !(
       // We expect the menu button to get into the active state.
       r.y1 >= menuButtonRect.top && r.y2 <= menuButtonRect.bottom &&
       r.x1 >= menuButtonRect.left && r.x2 <= menuButtonRect.right
       // XXX For some reason the menu panel isn't in our screenshots,
diff --git a/browser/base/content/test/performance/browser_tabopen.js b/browser/base/content/test/performance/browser_tabopen.js
--- a/browser/base/content/test/performance/browser_tabopen.js
+++ b/browser/base/content/test/performance/browser_tabopen.js
@@ -27,17 +27,17 @@ add_task(async function() {
 
   // Prepare the window to avoid flicker and reflow that's unrelated to our
   // tab opening operation.
   await ensureFocusedUrlbar();
 
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
   let firstTabRect = gBrowser.selectedTab.getBoundingClientRect();
   let textBoxRect = document.getAnonymousElementByAttribute(gURLBar,
-    "anonid", "textbox-input-box").getBoundingClientRect();
+    "is", "textbox-input-box").getBoundingClientRect();
   let inRange = (val, min, max) => min <= val && val <= max;
 
   // Add a reflow observer and open a new tab.
   await withPerfObserver(async function() {
     let switchDone = BrowserTestUtils.waitForEvent(window, "TabSwitchDone");
     BrowserOpenTab();
     await BrowserTestUtils.waitForEvent(gBrowser.selectedTab, "transitionend",
                                         false, e => e.propertyName === "max-width");
diff --git a/browser/base/content/test/performance/browser_tabopen_squeeze.js b/browser/base/content/test/performance/browser_tabopen_squeeze.js
--- a/browser/base/content/test/performance/browser_tabopen_squeeze.js
+++ b/browser/base/content/test/performance/browser_tabopen_squeeze.js
@@ -30,17 +30,17 @@ add_task(async function() {
   const TAB_COUNT_FOR_SQUEEZE = computeMaxTabCount() - 1;
 
   await createTabs(TAB_COUNT_FOR_SQUEEZE);
 
   await ensureFocusedUrlbar();
 
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
   let textBoxRect = document.getAnonymousElementByAttribute(gURLBar,
-    "anonid", "textbox-input-box").getBoundingClientRect();
+    "is", "textbox-input-box").getBoundingClientRect();
 
   await withPerfObserver(async function() {
     let switchDone = BrowserTestUtils.waitForEvent(window, "TabSwitchDone");
     BrowserOpenTab();
     await BrowserTestUtils.waitForEvent(gBrowser.selectedTab, "transitionend",
       false, e => e.propertyName === "max-width");
     await switchDone;
   }, {expectedReflows: EXPECTED_REFLOWS,
diff --git a/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js b/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
--- a/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
+++ b/browser/base/content/test/performance/browser_tabstrip_overflow_underflow.js
@@ -34,17 +34,17 @@ add_task(async function() {
   const TAB_COUNT_FOR_OVERFLOW = computeMaxTabCount();
 
   await createTabs(TAB_COUNT_FOR_OVERFLOW);
 
   await ensureFocusedUrlbar();
 
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
   let textBoxRect = document.getAnonymousElementByAttribute(gURLBar,
-    "anonid", "textbox-input-box").getBoundingClientRect();
+    "is", "textbox-input-box").getBoundingClientRect();
   let ignoreTabstripRects = {
     filter: rects => rects.filter(r => !(
       // We expect plenty of changed rects within the tab strip.
       r.y1 >= tabStripRect.top && r.y2 <= tabStripRect.bottom &&
       r.x1 >= tabStripRect.left && r.x2 <= tabStripRect.right
     )),
     exceptions: [
       {name: "the urlbar placeolder moves up and down by a few pixels",
diff --git a/browser/base/content/test/performance/browser_urlbar_keyed_search.js b/browser/base/content/test/performance/browser_urlbar_keyed_search.js
--- a/browser/base/content/test/performance/browser_urlbar_keyed_search.js
+++ b/browser/base/content/test/performance/browser_urlbar_keyed_search.js
@@ -154,17 +154,17 @@ add_task(async function() {
   let popup = URLBar.popup;
 
   URLBar.focus();
   URLBar.value = "";
 
   let dropmarkerRect = document.getAnonymousElementByAttribute(gURLBar,
     "anonid", "historydropmarker").getBoundingClientRect();
   let textBoxRect = document.getAnonymousElementByAttribute(gURLBar,
-    "anonid", "textbox-input-box").getBoundingClientRect();
+    "is", "textbox-input-box").getBoundingClientRect();
 
   await withPerfObserver(async function() {
     let oldInvalidate = popup.invalidate.bind(popup);
     let oldResultsAdded = popup.onResultsAdded.bind(popup);
 
     // We need to invalidate the frame tree outside of the normal
     // mechanism since invalidations and result additions to the
     // URL bar occur without firing JS events (which is how we
diff --git a/browser/base/content/test/performance/browser_urlbar_search.js b/browser/base/content/test/performance/browser_urlbar_search.js
--- a/browser/base/content/test/performance/browser_urlbar_search.js
+++ b/browser/base/content/test/performance/browser_urlbar_search.js
@@ -190,17 +190,17 @@ add_task(async function() {
     let hiddenPromise = BrowserTestUtils.waitForEvent(URLBar.popup, "popuphidden");
     EventUtils.synthesizeKey("VK_ESCAPE", {}, win);
     await hiddenPromise;
   };
 
   let dropmarkerRect = document.getAnonymousElementByAttribute(gURLBar,
     "anonid", "historydropmarker").getBoundingClientRect();
   let textBoxRect = document.getAnonymousElementByAttribute(gURLBar,
-    "anonid", "textbox-input-box").getBoundingClientRect();
+    "is", "textbox-input-box").getBoundingClientRect();
   let expectedRects = {
     filter: rects => rects.filter(r => !(
       // We put text into the urlbar so expect its textbox to change.
       (r.x1 >= textBoxRect.left && r.x2 <= textBoxRect.right &&
        r.y1 >= textBoxRect.top && r.y2 <= textBoxRect.bottom) ||
       // The dropmarker is displayed as active during some of the test.
       // dropmarkerRect.left isn't always an integer, hence the - 1 and + 1
       (r.x1 >= dropmarkerRect.left - 1 && r.x2 <= dropmarkerRect.right + 1 &&
diff --git a/browser/base/content/test/urlbar/browser_pasteAndGo.js b/browser/base/content/test/urlbar/browser_pasteAndGo.js
--- a/browser/base/content/test/urlbar/browser_pasteAndGo.js
+++ b/browser/base/content/test/urlbar/browser_pasteAndGo.js
@@ -14,24 +14,22 @@ add_task(async function() {
       await new Promise((resolve, reject) => {
         waitForClipboard(url, function() {
           clipboardHelper.copyString(url);
         }, resolve,
           () => reject(new Error(`Failed to copy string '${url}' to clipboard`))
         );
       });
       let textBox = document.getAnonymousElementByAttribute(gURLBar,
-        "anonid", "textbox-input-box");
-      let cxmenu = document.getAnonymousElementByAttribute(textBox,
-        "anonid", "input-box-contextmenu");
+        "is", "textbox-input-box");
+      let cxmenu = textBox.menuPopup;
       let cxmenuPromise = BrowserTestUtils.waitForEvent(cxmenu, "popupshown");
       EventUtils.synthesizeMouseAtCenter(gURLBar, {type: "contextmenu", button: 2});
       await cxmenuPromise;
-      let menuitem = document.getAnonymousElementByAttribute(textBox,
-        "anonid", "paste-and-go");
+      let menuitem = textBox.getMenuItem("paste-and-go");
       let browserLoadedPromise = BrowserTestUtils.browserLoaded(browser, false, url.replace(/\n/g, ""));
       EventUtils.synthesizeMouseAtCenter(menuitem, {});
       // Using toSource in order to get the newlines escaped:
       info("Paste and go, loading " + url.toSource());
       await browserLoadedPromise;
       ok(true, "Successfully loaded " + url);
     });
   }
@@ -44,24 +42,22 @@ add_task(async function() {
     await new Promise((resolve, reject) => {
       waitForClipboard(url, function() {
         clipboardHelper.copyString(url);
       }, resolve,
         () => reject(new Error(`Failed to copy string '${url}' to clipboard`))
       );
     });
     let textBox = document.getAnonymousElementByAttribute(gURLBar,
-      "anonid", "textbox-input-box");
-    let cxmenu = document.getAnonymousElementByAttribute(textBox,
-      "anonid", "input-box-contextmenu");
+      "is", "textbox-input-box");
+    let cxmenu = textBox.menuPopup;
     let cxmenuPromise = BrowserTestUtils.waitForEvent(cxmenu, "popupshown");
     EventUtils.synthesizeMouseAtCenter(gURLBar, {type: "contextmenu", button: 2});
     await cxmenuPromise;
-    let menuitem = document.getAnonymousElementByAttribute(textBox,
-      "anonid", "paste-and-go");
+    let menuitem = textBox.getMenuItem("paste-and-go");
     let browserLoadedPromise = BrowserTestUtils.browserLoaded(browser, false, url.replace(/\u2028/g, ""));
     EventUtils.synthesizeMouseAtCenter(menuitem, {});
     // Using toSource in order to get the newlines escaped:
     info("Paste and go, loading " + url.toSource());
     await browserLoadedPromise;
     ok(true, "Successfully loaded " + url);
   });
 });
diff --git a/browser/base/content/urlbarBindings.xml b/browser/base/content/urlbarBindings.xml
--- a/browser/base/content/urlbarBindings.xml
+++ b/browser/base/content/urlbarBindings.xml
@@ -21,18 +21,18 @@ file, You can obtain one at http://mozil
           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
           xmlns:xbl="http://www.mozilla.org/xbl">
 
   <binding id="urlbar" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete">
 
     <content sizetopopup="pref">
       <xul:hbox flex="1" class="urlbar-textbox-container">
         <children includes="image|deck|stack|box"/>
-        <xul:hbox anonid="textbox-input-box"
-                  class="textbox-input-box urlbar-input-box"
+        <xul:hbox is="textbox-input-box"
+                  class="urlbar-input-box"
                   flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
           <children/>
           <html:input anonid="input"
                       class="autocomplete-textbox urlbar-input textbox-input"
                       allowevents="true"
                       inputmode="mozAwesomebar"
                       xbl:inherits="tooltiptext=inputtooltiptext,value,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,focused,textoverflow"/>
         </xul:hbox>
@@ -85,19 +85,19 @@ file, You can obtain one at http://mozil
         this.inputField.addEventListener("paste", this);
         this.inputField.addEventListener("mousedown", this);
         this.inputField.addEventListener("mousemove", this);
         this.inputField.addEventListener("mouseout", this);
         this.inputField.addEventListener("overflow", this);
         this.inputField.addEventListener("underflow", this);
 
         var textBox = document.getAnonymousElementByAttribute(this,
-                                                "anonid", "textbox-input-box");
-        var cxmenu = document.getAnonymousElementByAttribute(textBox,
-                                            "anonid", "input-box-contextmenu");
+                                                "is", "textbox-input-box");
+        customElements.upgrade(textBox);
+        var cxmenu = textBox.menuPopup;
         var pasteAndGo;
         cxmenu.addEventListener("popupshowing", function() {
           if (!pasteAndGo)
             return;
           var controller = document.commandDispatcher.getControllerForCommand("cmd_paste");
           var enabled = controller.isCommandEnabled("cmd_paste");
           if (enabled)
             pasteAndGo.removeAttribute("disabled");
diff --git a/browser/components/customizableui/test/browser_940307_panel_click_closure_handling.js b/browser/components/customizableui/test/browser_940307_panel_click_closure_handling.js
--- a/browser/components/customizableui/test/browser_940307_panel_click_closure_handling.js
+++ b/browser/components/customizableui/test/browser_940307_panel_click_closure_handling.js
@@ -40,18 +40,18 @@ add_task(async function searchbar_in_pan
   await SpecialPowers.pushPrefEnv({set: [["browser.search.suggest.enabled", false]]});
   let dontShowPopup = e => e.preventDefault();
   let searchbarPopup = searchbar.textbox.popup;
   searchbarPopup.addEventListener("popupshowing", dontShowPopup);
 
   searchbar.value = "foo";
   searchbar.focus();
   // Reaching into this context menu is pretty evil, but hey... it's a test.
-  let textbox = document.getAnonymousElementByAttribute(searchbar.textbox, "anonid", "textbox-input-box");
-  let contextmenu = document.getAnonymousElementByAttribute(textbox, "anonid", "input-box-contextmenu");
+  let textbox = document.getAnonymousElementByAttribute(searchbar.textbox, "is", "textbox-input-box");
+  let contextmenu = textbox.menuPopup;
   let contextMenuShown = promisePanelElementShown(window, contextmenu);
   EventUtils.synthesizeMouseAtCenter(searchbar, {type: "contextmenu", button: 2});
   await contextMenuShown;
 
   ok(isOverflowOpen(), "Panel should still be open");
 
   let selectAll = contextmenu.querySelector("[cmd='cmd_selectAll']");
   let contextMenuHidden = promisePanelElementHidden(window, contextmenu);
diff --git a/browser/components/search/content/search.xml b/browser/components/search/content/search.xml
--- a/browser/components/search/content/search.xml
+++ b/browser/components/search/content/search.xml
@@ -496,19 +496,20 @@
         if (document.getBindingParent(this).parentNode.parentNode.localName ==
             "toolbarpaletteitem")
           return;
 
         if (Services.prefs.getBoolPref("browser.urlbar.clickSelectsAll"))
           this.setAttribute("clickSelectsAll", true);
 
         var textBox = document.getAnonymousElementByAttribute(this,
-                                              "anonid", "textbox-input-box");
-        var cxmenu = document.getAnonymousElementByAttribute(textBox,
-                                          "anonid", "input-box-contextmenu");
+                                              "is", "textbox-input-box");
+
+        customElements.upgrade(textBox);
+        var cxmenu = textBox.menuPopup;
         cxmenu.addEventListener("popupshowing",
                                 () => { this.initContextMenu(cxmenu); },
                                 {capturing: true, once: true});
 
         this.setAttribute("aria-owns", this.popup.id);
         document.getBindingParent(this)._textboxInitialized = true;
       ]]></constructor>
 
diff --git a/browser/components/search/test/browser_searchbar_openpopup.js b/browser/components/search/test/browser_searchbar_openpopup.js
--- a/browser/components/search/test/browser_searchbar_openpopup.js
+++ b/browser/components/search/test/browser_searchbar_openpopup.js
@@ -196,17 +196,17 @@ add_task(async function click_opens_popu
   textbox.value = "";
 });
 
 // Right clicking in a non-empty search box when unfocused should open the edit context menu.
 add_no_popup_task(async function right_click_doesnt_open_popup() {
   gURLBar.focus();
   textbox.value = "foo";
 
-  let contextPopup = document.getAnonymousElementByAttribute(textbox.inputField.parentNode, "anonid", "input-box-contextmenu");
+  let contextPopup = textbox.inputField.parentNode.menuPopup;
   let promise = promiseEvent(contextPopup, "popupshown");
   context_click(textbox);
   await promise;
 
   is(Services.focus.focusedElement, textbox.inputField, "Should have focused the search bar");
   is(textbox.selectionStart, 0, "Should have selected all of the text");
   is(textbox.selectionEnd, 3, "Should have selected all of the text");
 
@@ -298,19 +298,17 @@ add_task(async function contextmenu_clos
 
   promise = promiseEvent(searchPopup, "popuphidden");
 
   // synthesizeKey does not work with VK_CONTEXT_MENU (bug 1127368)
   EventUtils.synthesizeMouseAtCenter(textbox, { type: "contextmenu", button: null });
 
   await promise;
 
-  let contextPopup =
-    document.getAnonymousElementByAttribute(textbox.inputField.parentNode,
-                                            "anonid", "input-box-contextmenu");
+  let contextPopup = textbox.inputField.parentNode.menuPopup;
   promise = promiseEvent(contextPopup, "popuphidden");
   contextPopup.hidePopup();
   await promise;
 
   textbox.value = "";
 });
 
 // Tabbing to the search box should open the popup if it contains text.
diff --git a/browser/themes/osx/browser.css b/browser/themes/osx/browser.css
--- a/browser/themes/osx/browser.css
+++ b/browser/themes/osx/browser.css
@@ -564,17 +564,17 @@ html|input.urlbar-input {
   }
 
   #editBookmarkPanel .expander-up > .button-box > .button-icon,
   #editBookmarkPanel .expander-down > .button-box > .button-icon {
     width: 9px;
   }
 }
 
-#editBMPanel_tagsField > .textbox-input-box > html|*.textbox-input::placeholder {
+#editBMPanel_tagsField > [is=textbox-input-box] > html|*.textbox-input::placeholder {
   opacity: 1.0;
   color: #bbb;
 }
 
 /* ----- SIDEBAR ELEMENTS ----- */
 
 %include ../shared/sidebar.inc.css
 
diff --git a/browser/themes/windows/browser.css b/browser/themes/windows/browser.css
--- a/browser/themes/windows/browser.css
+++ b/browser/themes/windows/browser.css
@@ -542,17 +542,17 @@ menuitem.bookmark-item {
 @media (-moz-windows-default-theme: 0) {
   #urlbar:not(:-moz-lwtheme):not([focused="true"]),
   .searchbar-textbox:not(:-moz-lwtheme):not([focused="true"]) {
     border-color: ThreeDShadow;
   }
 }
 
 html|*.urlbar-input:-moz-lwtheme::placeholder,
-.searchbar-textbox:-moz-lwtheme > .urlbar-textbox-container > .textbox-input-box > html|*.textbox-input::placeholder {
+.searchbar-textbox:-moz-lwtheme > .urlbar-textbox-container > [is=textbox-input-box] > html|*.textbox-input::placeholder {
   opacity: 1.0;
   color: #777;
 }
 
 /* ::::: URL Bar Zoom Reset Button ::::: */
 @keyframes urlbar-zoom-reset-pulse {
   0% {
     transform: scale(0);
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -32,42 +32,241 @@ class MozXULElement extends XULElement {
    * the reflector is garbage collected and the element is touched again.
    *
    * @param str
    *        String with the XML representation of XUL elements.
    *
    * @return DocumentFragment containing the corresponding element tree, including
    *         element nodes but excluding any text node.
    */
-  static parseXULToFragment(str) {
+  static parseXULToFragment(str, entities = "") {
     let doc = gXULDOMParser.parseFromString(`
+      ${entities}
       <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
         ${str}
       </box>
     `, "application/xml");
     // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
     // does not do this. Most XUL code assumes that the whitespace has been
     // stripped out, so we simply remove all text nodes after using the parser.
     let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
     let currentNode = nodeIterator.nextNode();
     while (currentNode) {
       currentNode.remove();
       currentNode = nodeIterator.nextNode();
     }
     // We use a range here so that we don't access the inner DOM elements from
     // JavaScript before they are imported and inserted into a document.
     let range = doc.createRange();
-    range.selectNodeContents(doc.firstChild);
+    range.selectNodeContents(doc.querySelector("box"));
     return range.extractContents();
   }
 }
 
 // Attach the base class to the window so other scripts can use it:
 window.MozXULElement = MozXULElement;
 
 for (let script of [
   "chrome://global/content/elements/stringbundle.js",
   "chrome://global/content/elements/general.js",
 ]) {
   Services.scriptloader.loadSubScript(script, window);
 }
 
+class InputBox extends MozXULElement {
+  connectedCallback() {
+    if (this.menuPopup) {
+      this.menuPopup.remove();
+    }
+
+    this.setAttribute("context", "_child");
+    this.appendChild(this._getContextMenu());
+
+    this.menuPopup = this.querySelector(".textbox-contextmenu");
+
+    this.menuPopup.addEventListener("popupshowing", event => {
+      var input = this.getElementsByAttribute("anonid", "input")[0];
+      if (document.commandDispatcher.focusedElement != input)
+        input.focus();
+      this._doPopupItemEnabling(event.target);
+    });
+    this.menuPopup.addEventListener("command", event => {
+      var cmd = event.originalTarget.getAttribute("cmd");
+      if (cmd) {
+        this.doCommand(cmd);
+        event.stopPropagation();
+      }
+    });
+  }
+
+  _getContextMenu() {
+    return MozXULElement.parseXULToFragment(`
+      <menupopup anonid="input-box-contextmenu" class="textbox-contextmenu">
+        <menuitem label="&undoCmd.label;" accesskey="&undoCmd.accesskey;" cmd="cmd_undo"></menuitem>
+        <menuseparator></menuseparator>
+        <menuitem label="&cutCmd.label;" accesskey="&cutCmd.accesskey;" cmd="cmd_cut"></menuitem>
+        <menuitem label="&copyCmd.label;" accesskey="&copyCmd.accesskey;" cmd="cmd_copy"></menuitem>
+        <menuitem label="&pasteCmd.label;" accesskey="&pasteCmd.accesskey;" cmd="cmd_paste"></menuitem>
+        <menuitem label="&deleteCmd.label;" accesskey="&deleteCmd.accesskey;" cmd="cmd_delete"></menuitem>
+        <menuseparator></menuseparator>
+        <menuitem label="&selectAllCmd.label;" accesskey="&selectAllCmd.accesskey;" cmd="cmd_selectAll"></menuitem>
+      </menupopup>
+    `, `
+    <!DOCTYPE bindings [
+      <!ENTITY % textcontextDTD SYSTEM "chrome://global/locale/textcontext.dtd" >
+      %textcontextDTD;
+    ]>`);
+  }
+
+  _doPopupItemEnabling(popupNode) {
+    var children = popupNode.childNodes;
+    for (var i = 0; i < children.length; i++) {
+      var command = children[i].getAttribute("cmd");
+      if (command) {
+        var controller = document.commandDispatcher.getControllerForCommand(command);
+        var enabled = controller.isCommandEnabled(command);
+        if (enabled)
+          children[i].removeAttribute("disabled");
+        else
+          children[i].setAttribute("disabled", "true");
+      }
+    }
+  }
+
+  getMenuItem(anonid) {
+    return this.querySelector(`[anonid="${anonid}"]`);
+  }
+
+  _setMenuItemVisibility(anonid, visible) {
+    this.getMenuItem(anonid).hidden = !visible;
+  }
+
+  doCommand(command) {
+    var controller = document.commandDispatcher.getControllerForCommand(command);
+    controller.doCommand(command);
+  }
 }
+
+customElements.define("textbox-input-box", InputBox, { extends: "hbox" });
+
+// class FirefoxInputBoxSpell extends FirefoxInputBox {
+//   connectedCallback() {
+//     super.connectedCallback()
+//     this.innerHTML = `
+//       <menupopup anonid="input-box-contextmenu" class="textbox-contextmenu" onpopupshowing="var input =
+//                                        this.parentNode.getElementsByAttribute('anonid', 'input')[0];
+//                                      if (document.commandDispatcher.focusedElement != input)
+//                                        input.focus();
+//                                      this.parentNode._doPopupItemEnablingSpell(this);" onpopuphiding="this.parentNode._doPopupItemDisabling(this);" oncommand="var cmd = event.originalTarget.getAttribute('cmd'); if(cmd) { this.parentNode.doCommand(cmd); event.stopPropagation(); }">
+//         <menuitem label="&spellNoSuggestions.label;" anonid="spell-no-suggestions" disabled="true"></menuitem>
+//         <menuitem label="&spellAddToDictionary.label;" accesskey="&spellAddToDictionary.accesskey;" anonid="spell-add-to-dictionary" oncommand="this.parentNode.parentNode.spellCheckerUI.addToDictionary();"></menuitem>
+//         <menuitem label="&spellUndoAddToDictionary.label;" accesskey="&spellUndoAddToDictionary.accesskey;" anonid="spell-undo-add-to-dictionary" oncommand="this.parentNode.parentNode.spellCheckerUI.undoAddToDictionary();"></menuitem>
+//         <menuseparator anonid="spell-suggestions-separator"></menuseparator>
+//         <menuitem label="&undoCmd.label;" accesskey="&undoCmd.accesskey;" cmd="cmd_undo"></menuitem>
+//         <menuseparator></menuseparator>
+//         <menuitem label="&cutCmd.label;" accesskey="&cutCmd.accesskey;" cmd="cmd_cut"></menuitem>
+//         <menuitem label="&copyCmd.label;" accesskey="&copyCmd.accesskey;" cmd="cmd_copy"></menuitem>
+//         <menuitem label="&pasteCmd.label;" accesskey="&pasteCmd.accesskey;" cmd="cmd_paste"></menuitem>
+//         <menuitem label="&deleteCmd.label;" accesskey="&deleteCmd.accesskey;" cmd="cmd_delete"></menuitem>
+//         <menuseparator></menuseparator>
+//         <menuitem label="&selectAllCmd.label;" accesskey="&selectAllCmd.accesskey;" cmd="cmd_selectAll"></menuitem>
+//         <menuseparator anonid="spell-check-separator"></menuseparator>
+//         <menuitem label="&spellCheckToggle.label;" type="checkbox" accesskey="&spellCheckToggle.accesskey;" anonid="spell-check-enabled" oncommand="this.parentNode.parentNode.spellCheckerUI.toggleEnabled();"></menuitem>
+//         <menu label="&spellDictionaries.label;" accesskey="&spellDictionaries.accesskey;" anonid="spell-dictionaries">
+//           <menupopup anonid="spell-dictionaries-menu" onpopupshowing="event.stopPropagation();" onpopuphiding="event.stopPropagation();"></menupopup>
+//         </menu>
+//       </menupopup>
+//     `;
+//     this._spellCheckInitialized = false;
+
+//     this._enabledCheckbox = document.getAnonymousElementByAttribute(this, "anonid", "spell-check-enabled");
+
+//     this._suggestionsSeparator = document.getAnonymousElementByAttribute(this, "anonid", "spell-no-suggestions");
+
+//     this._dictionariesMenu = document.getAnonymousElementByAttribute(this, "anonid", "spell-dictionaries-menu");
+
+//     this._setupEventListeners();
+//   }
+
+//   get spellCheckerUI() {
+//     if (!this._spellCheckInitialized) {
+//       this._spellCheckInitialized = true;
+
+//       if (ChromeUtils.getClassName(document) != "XULDocument")
+//         return null;
+
+//       var textbox = document.getBindingParent(this);
+//       if (!textbox || textbox.localName != "textbox")
+//         return null;
+
+//       try {
+//         ChromeUtils.import("resource://gre/modules/InlineSpellChecker.jsm", this);
+//         this.InlineSpellCheckerUI = new this.InlineSpellChecker(textbox.editor);
+//       } catch (ex) {}
+//     }
+
+//     return this.InlineSpellCheckerUI;
+//   }
+
+//   _doPopupItemEnablingSpell(popupNode) {
+//     var spellui = this.spellCheckerUI;
+//     if (!spellui || !spellui.canSpellCheck) {
+//       this._setMenuItemVisibility("spell-no-suggestions", false);
+//       this._setMenuItemVisibility("spell-check-enabled", false);
+//       this._setMenuItemVisibility("spell-check-separator", false);
+//       this._setMenuItemVisibility("spell-add-to-dictionary", false);
+//       this._setMenuItemVisibility("spell-undo-add-to-dictionary", false);
+//       this._setMenuItemVisibility("spell-suggestions-separator", false);
+//       this._setMenuItemVisibility("spell-dictionaries", false);
+//       return;
+//     }
+
+//     spellui.initFromEvent(document.popupRangeParent,
+//       document.popupRangeOffset);
+
+//     var enabled = spellui.enabled;
+//     var showUndo = spellui.canSpellCheck && spellui.canUndo();
+//     this._enabledCheckbox.setAttribute("checked", enabled);
+
+//     var overMisspelling = spellui.overMisspelling;
+//     this._setMenuItemVisibility("spell-add-to-dictionary", overMisspelling);
+//     this._setMenuItemVisibility("spell-undo-add-to-dictionary", showUndo);
+//     this._setMenuItemVisibility("spell-suggestions-separator", overMisspelling || showUndo);
+
+//     // suggestion list
+//     var numsug = spellui.addSuggestionsToMenu(popupNode, this._suggestionsSeparator, 5);
+//     this._setMenuItemVisibility("spell-no-suggestions", overMisspelling && numsug == 0);
+
+//     // dictionary list
+//     var numdicts = spellui.addDictionaryListToMenu(this._dictionariesMenu, null);
+//     this._setMenuItemVisibility("spell-dictionaries", enabled && numdicts > 1);
+
+//     this._doPopupItemEnabling(popupNode);
+//   }
+
+//   _doPopupItemDisabling() {
+//     if (this.spellCheckerUI) {
+//       this.spellCheckerUI.clearSuggestionsFromMenu();
+//       this.spellCheckerUI.clearDictionaryListFromMenu();
+//     }
+//   }
+
+//   _setupEventListeners() {
+
+//   }
+// }
+
+
+// }, { extends: "toolbar" });
+
+
+
+// window.addEventListener("contextmenu", e => {
+//   console.log(e, e.target);
+//   if (e.target.matches("textbox")) {
+//     console.log("Matches");
+//   }
+// }, true);
+
+
+
+
+}
diff --git a/toolkit/content/tests/chrome/test_textbox_dictionary.xul b/toolkit/content/tests/chrome/test_textbox_dictionary.xul
--- a/toolkit/content/tests/chrome/test_textbox_dictionary.xul
+++ b/toolkit/content/tests/chrome/test_textbox_dictionary.xul
@@ -46,27 +46,27 @@ function startTests()
     bringUpContextMenu(textbox);
   });
 }
 
 function runContextMenuTest()
 {
   SimpleTest.executeSoon( function() {
     // The textbox has its children in an hbox XUL element, so get that first
-    var hbox = document.getAnonymousNodes(textbox).item(0);
+    var inputBox = document.getAnonymousElementByAttribute(textbox, "is", "textbox-input-box");
     
-    var contextMenu = document.getAnonymousElementByAttribute(hbox, "anonid", "input-box-contextmenu");
+    var contextMenu = inputBox.menuPopup;
    
     switch(testNum)
     {
       case 0: // "Add to Dictionary" button
-        var addToDict = contextMenu.querySelector("[anonid=spell-add-to-dictionary]");
+        var addToDict = inputBox.getMenuItem("spell-add-to-dictionary");
         ok(!addToDict.hidden, "Is Add to Dictionary visible?");
 
-        var separator = contextMenu.querySelector("[anonid=spell-suggestions-separator]");
+        var separator = inputBox.getMenuItem("spell-suggestions-separator");
         ok(!separator.hidden, "Is separator visible?");
 
         addToDict.doCommand();
         
         contextMenu.hidePopup();
         testNum++;
         
         onSpellCheck(textbox, function () {
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -14,17 +14,17 @@
     <resources>
       <stylesheet src="chrome://global/content/autocomplete.css"/>
       <stylesheet src="chrome://global/skin/autocomplete.css"/>
     </resources>
 
     <content sizetopopup="pref">
       <children includes="image|deck|stack|box"/>
 
-      <xul:hbox anonid="textbox-input-box" class="textbox-input-box" flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
+      <xul:hbox is="textbox-input-box" flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
         <children/>
         <html:input anonid="input" class="autocomplete-textbox textbox-input"
                     allowevents="true"
                     xbl:inherits="tooltiptext=inputtooltiptext,value,type=inputtype,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint"/>
       </xul:hbox>
       <children includes="hbox"/>
 
       <xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
diff --git a/toolkit/content/widgets/numberbox.xml b/toolkit/content/widgets/numberbox.xml
--- a/toolkit/content/widgets/numberbox.xml
+++ b/toolkit/content/widgets/numberbox.xml
@@ -13,17 +13,17 @@
   <binding id="numberbox"
            extends="chrome://global/content/bindings/textbox.xml#textbox">
 
     <resources>
       <stylesheet src="chrome://global/skin/numberbox.css"/>
     </resources>
 
     <content>
-      <xul:hbox class="textbox-input-box numberbox-input-box" flex="1" xbl:inherits="context,disabled,focused">
+      <xul:hbox is="textbox-input-box" class="numberbox-input-box" flex="1" xbl:inherits="context,disabled,focused">
         <html:input class="numberbox-input textbox-input" type="number" anonid="input"
                     xbl:inherits="value,min,max,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey"/>
       </xul:hbox>
     </content>
 
     <implementation>
       <field name="_valueEntered">false</field>
       <field name="_value">0</field>
diff --git a/toolkit/content/widgets/textbox.xml b/toolkit/content/widgets/textbox.xml
--- a/toolkit/content/widgets/textbox.xml
+++ b/toolkit/content/widgets/textbox.xml
@@ -21,17 +21,17 @@
   <binding id="textbox">
     <resources>
       <stylesheet src="chrome://global/content/textbox.css"/>
       <stylesheet src="chrome://global/skin/textbox.css"/>
     </resources>
 
     <content>
       <children/>
-      <xul:hbox class="textbox-input-box" flex="1" xbl:inherits="context,spellcheck">
+      <xul:hbox is="textbox-input-box" flex="1" xbl:inherits="context,spellcheck">
         <html:input class="textbox-input" anonid="input"
                     xbl:inherits="value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,noinitialfocus,mozactionhint,spellcheck"/>
       </xul:hbox>
     </content>
 
     <implementation implements="nsIDOMXULLabeledControlElement">
       <!-- nsIDOMXULLabeledControlElement -->
       <field name="crop">""</field>
@@ -244,35 +244,35 @@
         ]]>
       </handler>
 
       <handler event="click" action="this._maybeSelectAll();"/>
 
 #ifndef XP_WIN
       <handler event="contextmenu">
         // Only care about context clicks on the textbox itself.
+        console.log("Equal?", event.target != this, event.target, this);
         if (event.target != this)
           return;
 
         if (!event.button) // context menu opened via keyboard shortcut
           return;
         this._maybeSelectAll();
         // see bug 576135 comment 4
         let box = this.inputField.parentNode;
-        let menu = document.getAnonymousElementByAttribute(box, "anonid", "input-box-contextmenu");
-        box._doPopupItemEnabling(menu);
+        box._doPopupItemEnabling(box.menuPopup);
       </handler>
 #endif
     </handlers>
   </binding>
 
   <binding id="search-textbox" extends="chrome://global/content/bindings/textbox.xml#textbox">
     <content>
       <children/>
-      <xul:hbox class="textbox-input-box" flex="1" xbl:inherits="context,spellcheck" align="center">
+      <xul:hbox is="textbox-input-box" flex="1" xbl:inherits="context,spellcheck" align="center">
         <xul:image class="textbox-search-sign"/>
         <html:input class="textbox-input" anonid="input" mozactionhint="search"
                     xbl:inherits="value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey,mozactionhint,spellcheck"/>
         <xul:deck class="textbox-search-icons" anonid="search-icons">
           <xul:image class="textbox-search-icon" anonid="searchbutton-icon"
                      xbl:inherits="src=image,label=searchbuttonlabel,searchbutton,disabled"/>
           <xul:image class="textbox-search-clear"
                      onclick="document.getBindingParent(this)._clearSearch();"
@@ -395,17 +395,17 @@
           event.stopPropagation();
         ]]>
       </handler>
     </handlers>
   </binding>
 
   <binding id="textarea" extends="chrome://global/content/bindings/textbox.xml#textbox">
     <content>
-      <xul:hbox class="textbox-input-box" flex="1" xbl:inherits="context,spellcheck">
+      <xul:hbox is="textbox-input-box" flex="1" xbl:inherits="context,spellcheck">
         <html:textarea class="textbox-textarea" anonid="input"
                        xbl:inherits="xbl:text=value,disabled,tabindex,rows,cols,readonly,wrap,placeholder,mozactionhint,spellcheck"><children/></html:textarea>
       </xul:hbox>
     </content>
   </binding>
 
   <binding id="input-box">
     <content context="_child">
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -705,32 +705,24 @@ textbox {
   -moz-user-select: text;
   text-shadow: none;
 }
 
 textbox[multiline="true"] {
   -moz-binding: url("chrome://global/content/bindings/textbox.xml#textarea");
 }
 
-.textbox-input-box {
-  -moz-binding: url("chrome://global/content/bindings/textbox.xml#input-box");
-}
-
 html|textarea.textbox-textarea {
   resize: none;
 }
 
-textbox[resizable="true"] > .textbox-input-box > html|textarea.textbox-textarea {
+textbox[resizable="true"] > [is=textbox-input-box] > html|textarea.textbox-textarea {
   resize: both;
 }
 
-.textbox-input-box[spellcheck="true"] {
-  -moz-binding: url("chrome://global/content/bindings/textbox.xml#input-box-spell");
-}
-
 textbox[type="search"] {
   -moz-binding: url("chrome://global/content/bindings/textbox.xml#search-textbox");
 }
 
 textbox[type="number"] {
   -moz-binding: url("chrome://global/content/bindings/numberbox.xml#numberbox");
 }
 
diff --git a/toolkit/themes/linux/global/autocomplete.css b/toolkit/themes/linux/global/autocomplete.css
--- a/toolkit/themes/linux/global/autocomplete.css
+++ b/toolkit/themes/linux/global/autocomplete.css
@@ -108,12 +108,12 @@ html|span.ac-tag {
 .ac-action-text,
 .ac-text-overflow-container {
   padding: 0 !important;
   margin: 0 !important;
 }
 
 /* ::::: textboxes inside toolbarpaletteitems ::::: */
 
-toolbarpaletteitem > toolbaritem > textbox > .textbox-input-box > html|*.textbox-input,
-toolbarpaletteitem > toolbaritem > * > textbox > .textbox-input-box > html|*.textbox-input {
+toolbarpaletteitem > toolbaritem > textbox > [is=textbox-input-box] > html|*.textbox-input,
+toolbarpaletteitem > toolbaritem > * > textbox > [is=textbox-input-box] > html|*.textbox-input {
   visibility: hidden;
 }
diff --git a/toolkit/themes/linux/global/textbox.css b/toolkit/themes/linux/global/textbox.css
--- a/toolkit/themes/linux/global/textbox.css
+++ b/toolkit/themes/linux/global/textbox.css
@@ -62,17 +62,17 @@ textbox.plain {
 
 textbox.plain html|*.textbox-input,
 textbox.plain html|*.textbox-textarea {
   padding: 0px !important;
 }
 
 /* ::::: search textbox ::::: */
 
-textbox:not([searchbutton]) > .textbox-input-box > .textbox-search-sign {
+textbox:not([searchbutton]) > [is=textbox-input-box] > .textbox-search-sign {
   list-style-image: url(chrome://global/skin/icons/search-textbox.svg);
   margin-inline-end: 5px;
 }
 
 .textbox-search-icon[searchbutton] {
   list-style-image: url(chrome://global/skin/icons/search-textbox.svg);
 }
 
@@ -82,11 +82,11 @@ textbox:not([searchbutton]) > .textbox-i
 
 .textbox-search-icon[searchbutton]:not([disabled]) ,
 .textbox-search-clear:not([disabled]) {
   cursor: pointer;
 }
 
 /* ::::: textboxes inside toolbarpaletteitems ::::: */
 
-toolbarpaletteitem > toolbaritem > textbox > .textbox-input-box > html|*.textbox-input {
+toolbarpaletteitem > toolbaritem > textbox > [is=textbox-input-box] > html|*.textbox-input {
   visibility: hidden;
 }
diff --git a/toolkit/themes/osx/global/autocomplete.css b/toolkit/themes/osx/global/autocomplete.css
--- a/toolkit/themes/osx/global/autocomplete.css
+++ b/toolkit/themes/osx/global/autocomplete.css
@@ -96,12 +96,12 @@ html|span.ac-tag {
 .ac-action-text,
 .ac-text-overflow-container {
   padding: 0 !important;
   margin: 0 !important;
 }
 
 /* ::::: textboxes inside toolbarpaletteitems ::::: */
 
-toolbarpaletteitem > toolbaritem > textbox > .textbox-input-box > html|*.textbox-input,
-toolbarpaletteitem > toolbaritem > * > textbox > .textbox-input-box > html|*.textbox-input {
+toolbarpaletteitem > toolbaritem > textbox > [is=textbox-input-box] > html|*.textbox-input,
+toolbarpaletteitem > toolbaritem > * > textbox > [is=textbox-input-box] > html|*.textbox-input {
   visibility: hidden;
 }
diff --git a/toolkit/themes/osx/global/in-content/common.css b/toolkit/themes/osx/global/in-content/common.css
--- a/toolkit/themes/osx/global/in-content/common.css
+++ b/toolkit/themes/osx/global/in-content/common.css
@@ -81,17 +81,17 @@ xul|radio[focused="true"] > .radio-check
 html|*.numberbox-input::-moz-number-spin-up {
   border-radius: 4px 4px 0 0;
 }
 
 html|*.numberbox-input::-moz-number-spin-down  {
   border-radius: 0 0 4px 4px;
 }
 
-xul|textbox[type="search"]:not([searchbutton]) > .textbox-input-box > .textbox-search-sign {
+xul|textbox[type="search"]:not([searchbutton]) > [is=textbox-input-box] > .textbox-search-sign {
   list-style-image: url(chrome://global/skin/icons/search-textbox.svg);
   margin-inline-end: 5px;
 }
 
 html|button {
   /* XUL button min-width */
   min-width: 79px;
 }
diff --git a/toolkit/themes/osx/global/textbox.css b/toolkit/themes/osx/global/textbox.css
--- a/toolkit/themes/osx/global/textbox.css
+++ b/toolkit/themes/osx/global/textbox.css
@@ -66,17 +66,17 @@ textbox[type="search"] {
   margin-bottom: 1px;
 }
 
 textbox[type="search"].compact {
   padding: 0;
   font-size: 11px;
 }
 
-textbox[type="search"].compact > .textbox-input-box > .textbox-search-icons > .textbox-search-clear {
+textbox[type="search"].compact > [is=textbox-input-box] > .textbox-search-icons > .textbox-search-clear {
   width: 11px;
 }
 
 .textbox-search-clear:not([disabled]) {
   cursor: default;
 }
  
 .textbox-search-icons:not([selectedIndex="1"]) {
diff --git a/toolkit/themes/windows/global/autocomplete.css b/toolkit/themes/windows/global/autocomplete.css
--- a/toolkit/themes/windows/global/autocomplete.css
+++ b/toolkit/themes/windows/global/autocomplete.css
@@ -106,12 +106,12 @@ html|span.ac-tag {
 .ac-action-text,
 .ac-text-overflow-container {
   padding: 0 !important;
   margin: 0 !important;
 }
 
 /* ::::: textboxes inside toolbarpaletteitems ::::: */
 
-toolbarpaletteitem > toolbaritem > textbox > .textbox-input-box> html|*.textbox-input,
-toolbarpaletteitem > toolbaritem > * > textbox > .textbox-input-box > html|*.textbox-input {
+toolbarpaletteitem > toolbaritem > textbox > [is=textbox-input-box] > html|*.textbox-input,
+toolbarpaletteitem > toolbaritem > * > textbox > [is=textbox-input-box]  > html|*.textbox-input {
   visibility: hidden;
 }
diff --git a/toolkit/themes/windows/global/textbox.css b/toolkit/themes/windows/global/textbox.css
--- a/toolkit/themes/windows/global/textbox.css
+++ b/toolkit/themes/windows/global/textbox.css
@@ -68,17 +68,17 @@ textbox.plain {
 
 textbox.plain html|*.textbox-input,
 textbox.plain html|*.textbox-textarea {
   padding: 0px !important;
 }
 
 /* ::::: search textbox ::::: */
 
-textbox:not([searchbutton]) > .textbox-input-box > .textbox-search-sign {
+textbox:not([searchbutton]) > [is=textbox-input-box] > .textbox-search-sign {
   list-style-image: url(chrome://global/skin/icons/search-textbox.svg);
   margin-inline-end: 5px;
 }
 
 .textbox-search-icon[searchbutton] {
   list-style-image: url(chrome://global/skin/icons/search-textbox.svg);
 }
 
@@ -104,12 +104,12 @@ textbox:not([searchbutton]) > .textbox-i
 }
 
 .textbox-search-clear:not([disabled]):hover:active {
   -moz-image-region: rect(0, 48px, 16px, 32px);
 }
 
 /* ::::: textboxes inside toolbarpaletteitems ::::: */
 
-toolbarpaletteitem > toolbaritem > textbox > .textbox-input-box > html|*.textbox-input {
+toolbarpaletteitem > toolbaritem > textbox > [is=textbox-input-box] > html|*.textbox-input {
   visibility: hidden;
 }
 
