diff --git a/accessible/tests/mochitest/events/test_focus_listcontrols.xul b/accessible/tests/mochitest/events/test_focus_listcontrols.xul
--- a/accessible/tests/mochitest/events/test_focus_listcontrols.xul
+++ b/accessible/tests/mochitest/events/test_focus_listcontrols.xul
@@ -50,23 +50,14 @@
       todo(false, "Bug 746531 - timeouts of last three menulist tests on OS X");
 }
 
-      var textentry = getAccessible("emenulist").firstChild;
-      gQueue.push(new synthFocus("emenulist", new focusChecker(textentry)));
-      gQueue.push(new synthDownKey(textentry, new nofocusChecker("eml_tangerine")));
-      gQueue.push(new synthUpKey(textentry, new focusChecker("eml_marmalade")));
-      gQueue.push(new synthEnterKey("eml_marmalade", new focusChecker(textentry)));
-      gQueue.push(new synthOpenComboboxKey("emenulist", new focusChecker("eml_marmalade")));
-      gQueue.push(new synthEscapeKey("eml_marmalade", new focusChecker(textentry)));
-
       // no focus events for unfocused list controls when current item is
       // changed.
       gQueue.push(new synthFocus("emptyrichlistbox"));
 
       gQueue.push(new changeCurrentItem("richlistbox", "rlb_item1"));
 if (!MAC) {
       gQueue.push(new changeCurrentItem("menulist", WIN ? "ml_marmalade" : "ml_tangerine"));
 }
-      gQueue.push(new changeCurrentItem("emenulist", "eml_tangerine"));
 
       gQueue.invoke(); // Will call SimpleTest.finish();
     }
@@ -124,12 +115,6 @@
           <menuitem id="ml_strawberry" label="strawberry fields"/>
         </menupopup>
       </menulist>
-      <menulist id="emenulist" editable="true">
-        <menupopup>
-          <menuitem id="eml_tangerine" label="tangerine trees"/>
-          <menuitem id="eml_marmalade" label="marmalade skies"/>
-        </menupopup>
-      </menulist>
 
       <vbox id="eventdump"/>
     </vbox>
diff --git a/accessible/tests/mochitest/tree/test_combobox.xul b/accessible/tests/mochitest/tree/test_combobox.xul
--- a/accessible/tests/mochitest/tree/test_combobox.xul
+++ b/accessible/tests/mochitest/tree/test_combobox.xul
@@ -55,48 +55,6 @@
       testAccessibleTree("menulist", accTree);
 
       //////////////////////////////////////////////////////////////////////////
-      // editable menulist
-
-      accTree = {
-        role: ROLE_COMBOBOX,
-        children: [
-          {
-            role: ROLE_ENTRY,
-            children: [
-              // no text leaf accessible for text node
-            ]
-          },
-          {
-            role: ROLE_COMBOBOX_LIST, // context menu
-            children: []
-          },
-          {
-            role: ROLE_PUSHBUTTON, // dropmarker
-            children: []
-          },
-          {
-            role: ROLE_COMBOBOX_LIST, // option list
-            children: [
-              {
-                role: ROLE_COMBOBOX_OPTION,
-                children: []
-              },
-              {
-                role: ROLE_COMBOBOX_OPTION,
-                children: []
-              }
-            ]
-          }
-        ]
-      };
-
-      if (!MAC) {
-        testAccessibleTree("menulist2", accTree);
-      } else {
-        todo(false, "Make this test pass on OSX (bug 551957)");
-      }
-
-      //////////////////////////////////////////////////////////////////////////
       // textbox@type=autocomplete #1 (history)
 
       accTree = {
@@ -195,13 +153,6 @@
         </menupopup>
       </menulist>
 
-      <menulist id="menulist2" editable="true">
-        <menupopup>
-          <menuitem label="item"/>
-          <menuitem label="item"/>
-        </menupopup>
-      </menulist>
-
       <textbox id="autocomplete" type="autocomplete"
                autocompletesearch="unifiedcomplete"
                value="http://mochi.test:8888/redirect-a11y.html"/>
diff --git a/accessible/xul/XULComboboxAccessible.cpp b/accessible/xul/XULComboboxAccessible.cpp
--- a/accessible/xul/XULComboboxAccessible.cpp
+++ b/accessible/xul/XULComboboxAccessible.cpp
@@ -32,13 +32,10 @@
   else
     mGenericTypes |= eCombobox;
 
-  // Both the XUL <textbox type="autocomplete"> and <menulist editable="true">
-  // widgets use XULComboboxAccessible. We need to walk the anonymous children
-  // for these so that the entry field is a child. Otherwise no XBL children.
-  if (!mContent->NodeInfo()->Equals(nsGkAtoms::textbox, kNameSpaceID_XUL) &&
-      !mContent->AsElement()->AttrValueIs(kNameSpaceID_None,
-                                          nsGkAtoms::editable, nsGkAtoms::_true,
-                                          eIgnoreCase)) {
+  // The XUL <textbox type="autocomplete"> uses XULComboboxAccessible. We need
+  // to walk the anonymous children for these so that the entry field is a
+  // child. Otherwise no XBL children.
+  if (!mContent->NodeInfo()->Equals(nsGkAtoms::textbox, kNameSpaceID_XUL)) {
     mStateFlags |= eNoXBLKids;
   }
 }
diff --git a/layout/reftests/native-theme/menulist-mirrored-when-rtl-ref.xul b/layout/reftests/native-theme/menulist-mirrored-when-rtl-ref.xul
--- a/layout/reftests/native-theme/menulist-mirrored-when-rtl-ref.xul
+++ b/layout/reftests/native-theme/menulist-mirrored-when-rtl-ref.xul
@@ -5,7 +5,6 @@
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
   <hbox>
     <menulist width="200" style="-moz-transform: scaleX(-1);"/>
-    <menulist editable="true" width="200" style="-moz-transform: scaleX(-1);"/>
     <spacer flex="1"/>
   </hbox>
 </window>
diff --git a/layout/reftests/native-theme/menulist-mirrored-when-rtl.xul b/layout/reftests/native-theme/menulist-mirrored-when-rtl.xul
--- a/layout/reftests/native-theme/menulist-mirrored-when-rtl.xul
+++ b/layout/reftests/native-theme/menulist-mirrored-when-rtl.xul
@@ -5,7 +5,6 @@
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
   <hbox>
     <menulist width="200" style="direction: rtl;"/>
-    <menulist editable="true" width="200" style="direction: rtl;"/>
     <spacer flex="1"/>
   </hbox>
 </window>
diff --git a/layout/xul/crashtests/237787-1.xul b/layout/xul/crashtests/237787-1.xul
deleted file mode 100644
--- a/layout/xul/crashtests/237787-1.xul
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0"?>
-<window	xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-	<toolbar>
-		<arrowscrollbox>
-			<menulist editable="true">
-			</menulist>
-		</arrowscrollbox>
-	</toolbar>
-</window>
diff --git a/layout/xul/crashtests/crashtests.list b/layout/xul/crashtests/crashtests.list
--- a/layout/xul/crashtests/crashtests.list
+++ b/layout/xul/crashtests/crashtests.list
@@ -4,7 +4,6 @@
 load 151826-1.xul
 load 168724-1.xul
 load 189814-1.xul
-load 237787-1.xul
 load 289410-1.xul
 load 290743.html
 load 291702-1.xul
diff --git a/layout/xul/nsMenuFrame.h b/layout/xul/nsMenuFrame.h
--- a/layout/xul/nsMenuFrame.h
+++ b/layout/xul/nsMenuFrame.h
@@ -50,8 +50,7 @@
 
 enum nsMenuListType {
   eNotMenuList,      // not a menulist
-  eReadonlyMenuList, // <menulist/>
-  eEditableMenuList  // <menulist editable="true"/>
+  eReadonlyMenuList  // <menulist/>
 };
 
 class nsMenuFrame;
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -831,9 +831,7 @@
     if (parentMenu) {
       nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(parentMenu->GetContent());
       if (menulist) {
-        bool isEditable = false;
-        menulist->GetEditable(&isEditable);
-        return isEditable ? eEditableMenuList : eReadonlyMenuList;
+        return eReadonlyMenuList;
       }
     }
   }
@@ -1185,10 +1183,6 @@
   if (!shouldBlink)
     return false;
 
-  // Don't blink in editable menulists.
-  if (GetParentMenuListType() == eEditableMenuList)
-    return false;
-
   return true;
 }
 
diff --git a/layout/xul/nsXULPopupManager.cpp b/layout/xul/nsXULPopupManager.cpp
--- a/layout/xul/nsXULPopupManager.cpp
+++ b/layout/xul/nsXULPopupManager.cpp
@@ -729,14 +729,7 @@
 
 #ifdef XP_MACOSX
   nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(aMenu);
-  bool isNonEditableMenulist = false;
   if (menulist) {
-    bool editable;
-    menulist->GetEditable(&editable);
-    isNonEditableMenulist = !editable;
-  }
-
-  if (isNonEditableMenulist) {
     position.AssignLiteral("selection");
   }
   else
diff --git a/toolkit/content/tests/chrome/test_bug557987.xul b/toolkit/content/tests/chrome/test_bug557987.xul
--- a/toolkit/content/tests/chrome/test_bug557987.xul
+++ b/toolkit/content/tests/chrome/test_bug557987.xul
@@ -14,8 +14,7 @@
                                          oncommand="eventReceived('command');">
     <menupopup onpopupshowing="eventReceived('popupshowing'); return false;" />
   </toolbarbutton>
-  <menulist id="menulist" editable="true" value="Test bug 557987" 
-                                          onfocus="eventReceived('focus')" />
+
   <!-- test results are displayed in the html:body -->
   <body xmlns="http://www.w3.org/1999/xhtml" style="height: 300px; overflow: auto;"/>
 
@@ -39,11 +38,6 @@
 
   synthesizeMouse(button, rightEdge, centerY, {}, window);
   synthesizeMouse(button, centerX, centerY, {}, window);
-  
-  let menulist = $("menulist");
-  centerX = menulist.getBoundingClientRect().width / 2;
-  centerY = menulist.getBoundingClientRect().height / 2;
-  synthesizeMouse(menulist, centerX, centerY, {}, window);
 
   synthesizeMouse(document.getElementsByTagName("body")[0], 0, 0, {}, window);
 
@@ -56,7 +50,7 @@
   is(eventCount.command, 0, "Correct number of command events received");
   is(eventCount.popupshowing, 1, "Correct number of popupshowing events received");
   is(eventCount.click, 2, "Correct number of click events received");
-  is(eventCount.focus, 1, "Correct number of focus events received");
+  is(eventCount.focus, 0, "Correct number of focus events received");
 
   SimpleTest.finish();
 }
diff --git a/toolkit/content/tests/chrome/test_focus_anons.xul b/toolkit/content/tests/chrome/test_focus_anons.xul
--- a/toolkit/content/tests/chrome/test_focus_anons.xul
+++ b/toolkit/content/tests/chrome/test_focus_anons.xul
@@ -9,15 +9,11 @@
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>      
   <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>      
 
-<label accesskey="a" control="menulist"/>
-<label accesskey="b" control="textbox"/>
+<label accesskey="a" control="textbox"/>
+<label accesskey="b" control="textbox2"/>
 
-<menulist id="menulist" editable="true">
-  <menupopup>
-    <menuitem label="One"/>
-  </menupopup>
-</menulist>
 <textbox id="textbox"/>
+<textbox id="textbox2"/>
 
 <script class="testbody" type="application/javascript">
 <![CDATA[
@@ -44,32 +40,32 @@
   addEventListener("blur", blurOccurred, true);
 
   gExpectedBlur = null;
-  gExpectedFocus = $("menulist").inputField;
-  $("menulist").focus();
+  gExpectedFocus = $("textbox").inputField;
+  $("textbox").focus();
 
   gExpectedBlur = gExpectedFocus;
-  gExpectedFocus = $("textbox").inputField;
-  $("textbox").focus();
+  gExpectedFocus = $("textbox2").inputField;
+  $("textbox2").focus();
 
   var accessKeyDetails = (navigator.platform.includes("Mac")) ?
                          {altKey: true, ctrlKey: true} :
                          {altKey: true, shiftKey: true};
 
   gExpectedBlur = gExpectedFocus;
-  gExpectedFocus = $("menulist").inputField;
+  gExpectedFocus = $("textbox").inputField;
   synthesizeKey("a", accessKeyDetails);
 
   gExpectedBlur = gExpectedFocus;
-  gExpectedFocus = $("textbox").inputField;
+  gExpectedFocus = $("textbox2").inputField;
   synthesizeKey("b", accessKeyDetails);
 
   if (!navigator.platform.includes("Mac")) {
     gExpectedBlur = gExpectedFocus;
-    gExpectedFocus = $("menulist").inputField;
+    gExpectedFocus = $("textbox").inputField;
     synthesizeKey("KEY_Tab", {shiftKey: true});
 
     gExpectedBlur = gExpectedFocus;
-    gExpectedFocus = $("textbox").inputField;
+    gExpectedFocus = $("textbox2").inputField;
     synthesizeKey("KEY_Tab");
 
     is(gBlurs, 5, "correct number of blurs");
diff --git a/toolkit/content/tests/chrome/test_menulist.xul b/toolkit/content/tests/chrome/test_menulist.xul
--- a/toolkit/content/tests/chrome/test_menulist.xul
+++ b/toolkit/content/tests/chrome/test_menulist.xul
@@ -43,10 +43,6 @@
   </menulist>
 </hbox>
 
-<menulist id="menulist-editable" editable="true">
-  <menupopup id="menulist-popup-editable"/>
-</menulist>
-
 <menulist id="menulist-initwithvalue" value="two">
   <menupopup>
     <menuitem label="One" value="one"/>
@@ -61,20 +57,6 @@
     <menuitem label="Three" value="three" selected="true"/>
   </menupopup>
 </menulist>
-<menulist id="menulist-editable-initwithvalue" editable="true" value="Two">
-  <menupopup>
-    <menuitem label="One" value="one"/>
-    <menuitem label="Two" value="two"/>
-    <menuitem label="Three" value="three"/>
-  </menupopup>
-</menulist>
-<menulist id="menulist-editable-initwithselected" editable="true" value="two">
-  <menupopup>
-    <menuitem label="One" value="one"/>
-    <menuitem label="Two" value="two"/>
-    <menuitem label="Three" value="three" selected="true"/>
-  </menupopup>
-</menulist>
 
 <menulist id="menulist-clipped">
   <menupopup height="65">
@@ -99,62 +81,33 @@
   testtag_menulist_UI_start($("menulist"), false);
 }
 
-function testtag_menulist_UI_start(element, editable)
+function testtag_menulist_UI_start(element)
 {
-  var testprefix = editable ? "editable" : "";
-
   // check the menupopup property
   var popup = element.menupopup;
   ok(popup && popup.localName == "menupopup" &&
-              popup.parentNode == element, testprefix + " menupopup");
+              popup.parentNode == element, "menupopup");
 
   // test the interfaces that menulist implements
-  test_nsIDOMXULMenuListElement(element, testprefix, editable);
+  test_nsIDOMXULMenuListElement(element);
 }
 
-function testtag_menulist_UI_finish(element, editable)
+function testtag_menulist_UI_finish(element)
 {
   element.value = "";
 
-  test_nsIDOMXULSelectControlElement(element, "menuitem",
-                                     editable ? "editable" : null);
+  test_nsIDOMXULSelectControlElement(element, "menuitem", null);
 
-  if (!editable) {
-    testtag_menulist_UI_start($("menulist-editable"), true);
-  }
-  else {
-    // bug 566154, the menulist width should account for vertical scrollbar
-    ok(document.getElementById("menulist-size").getBoundingClientRect().width >= 210,
-       "menulist popup width includes scrollbar width");
+  // bug 566154, the menulist width should account for vertical scrollbar
+  ok(document.getElementById("menulist-size").getBoundingClientRect().width >= 210,
+     "menulist popup width includes scrollbar width");
 
-    $("menulist").open = true;
-  }
+  $("menulist").open = true;
 }
 
-function test_nsIDOMXULMenuListElement(element, testprefix, editable)
+function test_nsIDOMXULMenuListElement(element)
 {
-  is(element.open, false, testprefix + " open");
-  is(element.editable, editable, testprefix + " editable");
-
-  if (editable) {
-    var inputField = element.inputField;
-    is(inputField &&
-                  inputField instanceof HTMLInputElement,
-                  true, testprefix + " inputField");
-
-    // check if the select method works
-    inputField.select();
-    is(inputField.selectionStart, 0, testprefix + " empty select selectionStart");
-    is(inputField.selectionEnd, 0, testprefix + " empty select selectionEnd");
-
-    element.value = "Some Text";
-    inputField.select();
-    is(inputField.selectionStart, 0, testprefix + " empty select selectionStart");
-    is(inputField.selectionEnd, 9, testprefix + " empty select selectionEnd");
-  }
-  else {
-    is(element.inputField, null , testprefix + " inputField");
-  }
+  is(element.open, false, "open");
 
   element.appendItem("Item One", "one");
   var seconditem = element.appendItem("Item Two", "two");
@@ -167,85 +120,76 @@
   thirditem.setAttribute("description", "This is the third description");
 
   // check the image and description properties
-  // editable menulists don't use the image or description properties currently
-  if (editable) {
-    element.selectedIndex = 1;
-    is(element.image, "", testprefix + " image set to selected");
-    is(element.description, "", testprefix + " description set to selected");
-    test_nsIDOMXULMenuListElement_finish(element, testprefix, editable);
-  }
-  else {
-    element.selectedIndex = 1;
-    is(element.image, "happy.png", testprefix + " image set to selected");
-    is(element.description, "This is the second description", testprefix + " description set to selected");
-    element.selectedIndex = -1;
-    is(element.image, "", testprefix + " image set when none selected");
-    is(element.description, "", testprefix + " description set when none selected");
-    element.selectedIndex = 2;
-    is(element.image, "happy.png", testprefix + " image set to selected again");
-    is(element.description, "This is the third description", testprefix + " description set to selected again");
+  element.selectedIndex = 1;
+  is(element.image, "happy.png", "image set to selected");
+  is(element.description, "This is the second description", "description set to selected");
+  element.selectedIndex = -1;
+  is(element.image, "", "image set when none selected");
+  is(element.description, "", "description set when none selected");
+  element.selectedIndex = 2;
+  is(element.image, "happy.png", "image set to selected again");
+  is(element.description, "This is the third description", "description set to selected again");
 
-    // check that changing the properties of the selected item changes the menulist's properties
-    let properties = [{attr: "label", value: "Item Number Three"},
-                      {attr: "value", value: "item-three"},
-                      {attr: "image", value: "smile.png"},
-                      {attr: "description", value: "Changed description"}];
-    test_nsIDOMXULMenuListElement_properties(element, testprefix, editable, thirditem, properties);
-  }
+  // check that changing the properties of the selected item changes the menulist's properties
+  let properties = [{attr: "label", value: "Item Number Three"},
+                    {attr: "value", value: "item-three"},
+                    {attr: "image", value: "smile.png"},
+                    {attr: "description", value: "Changed description"}];
+  test_nsIDOMXULMenuListElement_properties(element, thirditem, properties);
 }
 
-function test_nsIDOMXULMenuListElement_properties(element, testprefix, editable, thirditem, properties)
+function test_nsIDOMXULMenuListElement_properties(element, thirditem, properties)
 {
   let {attr, value} = properties.shift();
   let last = (properties.length == 0);
 
   let mutObserver = new MutationObserver(() => {
-    is(element.getAttribute(attr), value, `${testprefix} ${attr} modified`);
+    is(element.getAttribute(attr), value, `${attr} modified`);
     done();
   });
   mutObserver.observe(element, { attributeFilter: [attr] });
 
   let failureTimeout = setTimeout(() => {
-    ok(false, `${testprefix} ${attr} should have updated`);
+    ok(false, `${attr} should have updated`);
     done();
   }, 2000);
 
   function done()
   {
     clearTimeout(failureTimeout);
     mutObserver.disconnect();
     if (!last) {
-      test_nsIDOMXULMenuListElement_properties(element, testprefix, editable, thirditem, properties);
+      test_nsIDOMXULMenuListElement_properties(element, thirditem, properties);
     }
     else {
-      test_nsIDOMXULMenuListElement_unselected(element, testprefix, editable, thirditem);
+      test_nsIDOMXULMenuListElement_unselected(element, thirditem);
     }
   }
 
   thirditem.setAttribute(attr, value)
 }
 
-function test_nsIDOMXULMenuListElement_unselected(element, testprefix, editable, thirditem)
+function test_nsIDOMXULMenuListElement_unselected(element, thirditem)
 {
   let seconditem = thirditem.previousElementSibling;
   seconditem.label = "Changed Label 2";
-  is(element.label, "Item Number Three", testprefix + " label of another item modified");
+  is(element.label, "Item Number Three", "label of another item modified");
 
   element.selectedIndex = 0;
-  is(element.image, "", testprefix + " image set to selected with no image");
-  is(element.description, "", testprefix + " description set to selected with no description");
-  test_nsIDOMXULMenuListElement_finish(element, testprefix, editable);
+  is(element.image, "", "image set to selected with no image");
+  is(element.description, "", "description set to selected with no description");
+  test_nsIDOMXULMenuListElement_finish(element);
 }
 
-function test_nsIDOMXULMenuListElement_finish(element, testprefix, editable)
+function test_nsIDOMXULMenuListElement_finish(element)
 {
   // check the removeAllItems method
   element.appendItem("An Item", "anitem");
   element.appendItem("Another Item", "anotheritem");
   element.removeAllItems();
-  is(element.itemCount, 0, testprefix + " removeAllItems");
+  is(element.itemCount, 0, "removeAllItems");
 
-  testtag_menulist_UI_finish(element, editable);
+  testtag_menulist_UI_finish(element);
 }
 
 function test_menulist_open(element, scroller)
@@ -286,15 +230,6 @@
   is($("scroller").scrollTop, 0, "mousewheel on menulist does not scroll vbox parent");
   is($("scroller-in-listbox").scrollTop, 0, "mousewheel on menulist does not scroll listbox parent");
 
-  // bug 561243, outline causes the mouse click to be targeted incorrectly
-  var editableMenulist = $("menulist-editable");
-  editableMenulist.className = "outlined";
-
-  synthesizeMouse(editableMenulist.inputField, 25, 8, { type: "mousedown" });
-  synthesizeMouse(editableMenulist.inputField, 25, 8, { type: "mouseup" });
-  isnot(editableMenulist.inputField.selectionStart, editableMenulist.inputField.textLength,
-        "mouse event on editable menulist with outline caret position");
-
   let menulist = $("menulist-size");
   menulist.addEventListener("popupshown", function testAltClose() {
     menulist.removeEventListener("popupshown", testAltClose);
@@ -382,9 +317,6 @@
 </script>
 
 <body xmlns="http://www.w3.org/1999/xhtml">
-<style>
-.outlined > .menulist-editable-box { outline: 1px solid black; }
-</style>
 <p id="display">
 </p>
 <div id="content" style="display: none">
diff --git a/toolkit/content/tests/chrome/xul_selectcontrol.js b/toolkit/content/tests/chrome/xul_selectcontrol.js
--- a/toolkit/content/tests/chrome/xul_selectcontrol.js
+++ b/toolkit/content/tests/chrome/xul_selectcontrol.js
@@ -41,14 +41,6 @@
   var testid = (testprefix) ? testprefix + " " : "";
   testid += element.localName + " nsIDOMXULSelectControlElement ";
 
-  // editable menulists use the label as the value instead
-  var firstvalue = "first", secondvalue = "second", fourthvalue = "fourth";
-  if (element.localName == "menulist" && element.editable) {
-    firstvalue = "First Item";
-    secondvalue = "Second Item";
-    fourthvalue = "Fourth Item";
-  }
-
   // 'initial' - check if the initial state of the element is correct
   test_nsIDOMXULSelectControlElement_States(element, testid + "initial", 0, null, -1, "");
 
@@ -64,29 +56,29 @@
 
   // 'selectedIndex' - check if an item may be selected
   element.selectedIndex = 0;
-  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedIndex", 1, firstitem, 0, firstvalue);
+  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedIndex", 1, firstitem, 0, "first");
 
   // 'appendItem 2' - check if a second item may be added
   var seconditem = element.appendItem("Second Item", "second");
-  test_nsIDOMXULSelectControlElement_States(element, testid + "appendItem 2", 2, firstitem, 0, firstvalue);
+  test_nsIDOMXULSelectControlElement_States(element, testid + "appendItem 2", 2, firstitem, 0, "first");
 
   // 'selectedItem' - check if the second item may be selected
   element.selectedItem = seconditem;
-  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedItem", 2, seconditem, 1, secondvalue);
+  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedItem", 2, seconditem, 1, "second");
 
   // 'selectedIndex 2' - check if selectedIndex may be set to -1 to deselect items
   var selectionRequired = behaviourContains(element.localName, "selection-required");
   element.selectedIndex = -1;
   test_nsIDOMXULSelectControlElement_States(element, testid + "selectedIndex 2", 2,
         selectionRequired ? seconditem : null, selectionRequired ? 1 : -1,
-        selectionRequired ? secondvalue : "");
+        selectionRequired ? "second" : "");
 
   // 'selectedItem 2' - check if the selectedItem property may be set to null
   element.selectedIndex = 1;
   element.selectedItem = null;
   test_nsIDOMXULSelectControlElement_States(element, testid + "selectedItem 2", 2,
         selectionRequired ? seconditem : null, selectionRequired ? 1 : -1,
-        selectionRequired ? secondvalue : "");
+        selectionRequired ? "second" : "");
 
   // 'getIndexOfItem' - check if getIndexOfItem returns the right index
   is(element.getIndexOfItem(firstitem), 0, testid + "getIndexOfItem - first item at index 0");
@@ -102,10 +94,10 @@
   is(element.getItemAtIndex(2), null, testid + "getItemAtIndex - index 2 is null");
 
   // check if setting the value changes the selection
-  element.value = firstvalue;
-  test_nsIDOMXULSelectControlElement_States(element, testid + "set value 1", 2, firstitem, 0, firstvalue);
-  element.value = secondvalue;
-  test_nsIDOMXULSelectControlElement_States(element, testid + "set value 2", 2, seconditem, 1, secondvalue);
+  element.value = "first";
+  test_nsIDOMXULSelectControlElement_States(element, testid + "set value 1", 2, firstitem, 0, "first");
+  element.value = "second";
+  test_nsIDOMXULSelectControlElement_States(element, testid + "set value 2", 2, seconditem, 1, "second");
   // setting the value attribute to one not in the list doesn't change the selection.
   // The value is only changed for elements which support having a value other than the
   // selection.
@@ -115,19 +107,19 @@
   test_nsIDOMXULSelectControlElement_States(element, testid + "set value other", 2,
                                             otherValueClearsSelection ? null : seconditem,
                                             otherValueClearsSelection ? -1 : 1,
-                                            allowOtherValue ? "other" : secondvalue);
+                                            allowOtherValue ? "other" : "second");
   if (allowOtherValue)
     element.value = "";
 
-  var fourthitem = element.appendItem("Fourth Item", fourthvalue);
+  var fourthitem = element.appendItem("Fourth Item", "fourth");
   element.selectedIndex = 0;
   fourthitem.disabled = true;
   element.selectedIndex = 2;
-  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedIndex disabled", 3, fourthitem, 2, fourthvalue);
+  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedIndex disabled", 3, fourthitem, 2, "fourth");
 
   element.selectedIndex = 0;
   element.selectedItem = fourthitem;
-  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedItem disabled", 3, fourthitem, 2, fourthvalue);
+  test_nsIDOMXULSelectControlElement_States(element, testid + "selectedItem disabled", 3, fourthitem, 2, "fourth");
 
   if (element.menupopup) {
     element.menupopup.textContent = "";
@@ -137,24 +129,19 @@
 }
 
 function test_nsIDOMXULSelectControlElement_init(element, testprefix) {
-  // editable menulists use the label as the value
-  var isEditable = (element.localName == "menulist" && element.editable);
-
   var id = element.id;
   element = document.getElementById(id + "-initwithvalue");
   if (element) {
     var seconditem = element.getItemAtIndex(1);
     test_nsIDOMXULSelectControlElement_States(element, testprefix + " value initialization",
-                                              3, seconditem, 1,
-                                              isEditable ? seconditem.label : seconditem.value);
+                                              3, seconditem, 1, seconditem.value);
   }
 
   element = document.getElementById(id + "-initwithselected");
   if (element) {
     var thirditem = element.getItemAtIndex(2);
     test_nsIDOMXULSelectControlElement_States(element, testprefix + " selected initialization",
-                                              3, thirditem, 2,
-                                              isEditable ? thirditem.label : thirditem.value);
+                                              3, thirditem, 2, thirditem.value);
   }
 }
 
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -62,7 +62,6 @@
 
     <implementation implements="nsIDOMXULMenuListElement">
       <constructor>
-        this.mInputField = null;
         this.mSelectedInternal = null;
         this.mAttributeObserver = null;
         this.menuBoxObject = this.boxObject;
@@ -114,32 +113,14 @@
         </setter>
       </property>
 
-      <property name="inputField" readonly="true" onget="return null;"/>
-
       <property name="crop" onset="this.setAttribute('crop',val); return val;"
                             onget="return this.getAttribute('crop');"/>
       <property name="image"  onset="this.setAttribute('image',val); return val;"
                               onget="return this.getAttribute('image');"/>
       <property name="label" readonly="true" onget="return this.getAttribute('label');"/>
       <property name="description" onset="this.setAttribute('description',val); return val;"
                                    onget="return this.getAttribute('description');"/>
 
-      <property name="editable" onget="return this.getAttribute('editable') == 'true';">
-        <setter>
-          <![CDATA[
-            if (!val && this.editable) {
-              // If we were focused and transition from editable to not editable,
-              // focus the parent menulist so that the focus does not get stuck.
-              if (this.inputField == document.activeElement)
-                window.setTimeout(() => this.focus(), 0);
-            }
-
-            this.setAttribute("editable", val);
-            return val;
-          ]]>
-        </setter>
-      </property>
-
       <property name="open" onset="this.menuBoxObject.openMenu(val);
                                    return val;"
                             onget="return this.hasAttribute('open');"/>
@@ -353,198 +334,6 @@
     </implementation>
   </binding>
 
-  <binding id="menulist-editable" extends="chrome://global/content/bindings/menulist.xml#menulist">
-    <content sizetopopup="pref">
-      <xul:moz-input-box class="menulist-editable-box moz-input-box" xbl:inherits="context,disabled,readonly,focused" flex="1">
-        <html:input class="menulist-editable-input" anonid="input" allowevents="true"
-                    xbl:inherits="value=label,value,disabled,tabindex,readonly,placeholder"/>
-      </xul:moz-input-box>
-      <xul:dropmarker class="menulist-dropmarker" type="menu"
-                      xbl:inherits="open,disabled,parentfocused=focused"/>
-      <children includes="menupopup"/>
-    </content>
-
-    <implementation>
-      <method name="_selectInputFieldValueInList">
-        <body>
-        <![CDATA[
-          if (this.hasAttribute("disableautoselect"))
-            return;
-
-          // Find and select the menuitem that matches inputField's "value"
-          var arr = null;
-          var popup = this.menupopup;
-
-          if (popup)
-            arr = popup.getElementsByAttribute("label", this.inputField.value);
-
-          this.setSelectionInternal(arr ? arr.item(0) : null);
-        ]]>
-        </body>
-      </method>
-
-      <method name="setSelectionInternal">
-        <parameter name="val"/>
-        <body>
-          <![CDATA[
-            // This is called internally to set selected item
-            //  without triggering infinite loop
-            //  when using selectedItem's setter
-            if (this.mSelectedInternal == val)
-              return val;
-
-            if (this.mSelectedInternal)
-              this.mSelectedInternal.removeAttribute("selected");
-
-            this.mSelectedInternal = val;
-
-            if (val)
-              val.setAttribute("selected", "true");
-
-            // Do NOT change the "value", which is owned by inputField
-            return val;
-          ]]>
-        </body>
-      </method>
-
-      <property name="inputField" readonly="true">
-        <getter><![CDATA[
-          if (!this.mInputField)
-            this.mInputField = document.getAnonymousElementByAttribute(this, "anonid", "input");
-          return this.mInputField;
-        ]]></getter>
-      </property>
-
-      <property name="label"      onset="this.inputField.value = val; return val;"
-                                  onget="return this.inputField.value;"/>
-
-      <property name="value"      onget="return this.inputField.value;">
-        <setter>
-        <![CDATA[
-          // Override menulist's value setter to refer to the inputField's value
-          // (Allows using "menulist.value" instead of "menulist.inputField.value")
-          this.inputField.value = val;
-          this.setAttribute("value", val);
-          this.setAttribute("label", val);
-          this._selectInputFieldValueInList();
-          return val;
-        ]]>
-        </setter>
-      </property>
-
-      <property name="selectedItem">
-        <getter>
-          <![CDATA[
-            // Make sure internally-selected item
-            //  is in sync with inputField.value
-            this._selectInputFieldValueInList();
-            return this.mSelectedInternal;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-            var oldval = this.mSelectedInternal;
-            if (oldval == val)
-              return val;
-
-            if (val && !this.contains(val))
-              return val;
-
-            // This doesn't touch inputField.value or "value" and "label" attributes
-            this.setSelectionInternal(val);
-            if (val) {
-              // Editable menulist uses "label" as its "value"
-              var label = val.getAttribute("label");
-              this.inputField.value = label;
-              this.setAttribute("value", label);
-              this.setAttribute("label", label);
-            } else {
-              this.inputField.value = "";
-              this.removeAttribute("value");
-              this.removeAttribute("label");
-            }
-
-            var event = document.createEvent("Events");
-            event.initEvent("select", true, true);
-            this.dispatchEvent(event);
-
-            event = document.createEvent("Events");
-            event.initEvent("ValueChange", true, true);
-            this.dispatchEvent(event);
-
-            return val;
-          ]]>
-        </setter>
-      </property>
-      <property name="disableautoselect"
-                onset="if (val) this.setAttribute('disableautoselect','true');
-                       else this.removeAttribute('disableautoselect'); return val;"
-                onget="return this.hasAttribute('disableautoselect');"/>
-
-      <property name="editor" readonly="true">
-        <getter><![CDATA[
-          return this.inputField.editor;
-        ]]></getter>
-      </property>
-
-      <property name="readOnly"   onset="this.inputField.readOnly = val;
-                                         if (val) this.setAttribute('readonly', 'true');
-                                         else this.removeAttribute('readonly'); return val;"
-                                  onget="return this.inputField.readOnly;"/>
-
-      <method name="select">
-        <body>
-          this.inputField.select();
-        </body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <handler event="focus" phase="capturing">
-        <![CDATA[
-          this.setAttribute("focused", "true");
-        ]]>
-      </handler>
-
-      <handler event="blur" phase="capturing">
-        <![CDATA[
-          this.removeAttribute("focused");
-        ]]>
-      </handler>
-
-      <handler event="popupshowing">
-        <![CDATA[
-          // editable menulists elements aren't in the focus order,
-          // so when the popup opens we need to force the focus to the inputField
-          if (event.target.parentNode == this) {
-            if (document.commandDispatcher.focusedElement != this.inputField)
-              this.inputField.focus();
-
-            this.menuBoxObject.activeChild = null;
-            if (this.selectedItem)
-              // Not ready for auto-setting the active child in hierarchies yet.
-              // For now, only do this when the outermost menupopup opens.
-              this.menuBoxObject.activeChild = this.mSelectedInternal;
-          }
-        ]]>
-      </handler>
-
-      <handler event="keypress">
-        <![CDATA[
-          // open popup if key is up arrow, down arrow, or F4
-          if (!event.ctrlKey && !event.shiftKey) {
-            if (event.keyCode == KeyEvent.DOM_VK_UP ||
-                event.keyCode == KeyEvent.DOM_VK_DOWN ||
-                (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
-              event.preventDefault();
-              this.open = true;
-            }
-          }
-        ]]>
-      </handler>
-    </handlers>
-  </binding>
-
   <binding id="menulist-popuponly" display="xul:menu"
            extends="chrome://global/content/bindings/menulist.xml#menulist">
     <content sizetopopup="pref">
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -84,10 +84,6 @@
   -moz-user-focus: normal;
 }
 
-menulist[editable="true"] {
-  -moz-user-focus: ignore;
-}
-
 /******** window & page ******/
 
 window,
@@ -702,20 +698,10 @@
   border: 0 !important;
 }
 
-menulist[editable="true"] {
-  -moz-binding: url("chrome://global/content/bindings/menulist.xml#menulist-editable");
-}
-
 menulist > menupopup > menuitem {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic-noaccel");
 }
 
-html|*.menulist-editable-input {
-  -moz-appearance: none !important;
-  background: transparent ! important;
-  -moz-box-flex: 1;
-}
-
 dropmarker > .dropmarker-icon {
   pointer-events: none;
 }
diff --git a/toolkit/themes/linux/global/in-content/common.css b/toolkit/themes/linux/global/in-content/common.css
--- a/toolkit/themes/linux/global/in-content/common.css
+++ b/toolkit/themes/linux/global/in-content/common.css
@@ -39,7 +39,7 @@
   font-size: inherit;
 }
 
-xul|menulist:not([editable="true"]) > xul|*.menulist-dropmarker {
+xul|*.menulist-dropmarker {
   display: -moz-box;
   margin-top: 6px;
   margin-bottom: 6px;
diff --git a/toolkit/themes/linux/global/menulist.css b/toolkit/themes/linux/global/menulist.css
--- a/toolkit/themes/linux/global/menulist.css
+++ b/toolkit/themes/linux/global/menulist.css
@@ -48,30 +48,3 @@
 menulist[disabled="true"]:hover:active {
   color: GrayText;
 }
-
-/* ::::: editable menulists ::::: */
-
-menulist[editable="true"] {
-  -moz-appearance: none;
-  color: -moz-FieldText;
-}
-
-.menulist-editable-box {
-  -moz-appearance: menulist-textfield;
-  padding-top: 3px;
-  padding-bottom: 3px;
-  padding-inline-start: 2px;
-  padding-inline-end: 0px;
-}
-
-menulist[editable="true"] > .menulist-dropmarker {
-  display: -moz-box;
-  -moz-appearance: -moz-menulist-button;
-}
-
-html|*.menulist-editable-input {
-  margin: 0px !important;
-  border: none !important;
-  padding: 0px !important;
-  font: inherit;
-}
diff --git a/toolkit/themes/osx/global/in-content/common.css b/toolkit/themes/osx/global/in-content/common.css
--- a/toolkit/themes/osx/global/in-content/common.css
+++ b/toolkit/themes/osx/global/in-content/common.css
@@ -27,12 +27,12 @@
   padding: 0;
 }
 
-xul|menulist:not([editable="true"]) > xul|menupopup > xul|menuitem[checked="true"]::before,
-xul|menulist:not([editable="true"]) > xul|menupopup > xul|menuitem[selected="true"]::before {
+xul|menulist > xul|menupopup > xul|menuitem[checked="true"]::before,
+xul|menulist > xul|menupopup > xul|menuitem[selected="true"]::before {
   display: none;
 }
 
-xul|menulist:not([editable="true"]) > xul|*.menulist-dropmarker {
+xul|*.menulist-dropmarker {
   display: -moz-box;
   margin-top: 1px;
   margin-bottom: 1px;
diff --git a/toolkit/themes/osx/global/menu.css b/toolkit/themes/osx/global/menu.css
--- a/toolkit/themes/osx/global/menu.css
+++ b/toolkit/themes/osx/global/menu.css
@@ -147,26 +147,15 @@
   color: -moz-FieldText;
 }
 
-/* ::::: menuitems in editable menulist popups ::::: */
-
-menulist[editable="true"] > menupopup > menuitem,
-menulist[editable="true"] > menupopup > menucaption {
-  -moz-appearance: none;
-}
-
-menulist[editable="true"] > menupopup > :-moz-any(menuitem, menucaption) > .menu-iconic-left {
-  display: none;
-}
-
 /* ::::: checked menuitems ::::: */
 
 :not(menulist) > menupopup > menuitem[checked="true"],
 :not(menulist) > menupopup > menuitem[selected="true"] {
   -moz-appearance: checkmenuitem;
 }
 
-menulist:not([editable="true"]) > menupopup > menuitem[checked="true"]::before,
-menulist:not([editable="true"]) > menupopup > menuitem[selected="true"]::before {
+menulist > menupopup > menuitem[checked="true"]::before,
+menulist > menupopup > menuitem[selected="true"]::before {
   content: '\2713'; /* a checkmark */
   display: block;
   width: 15px;
diff --git a/toolkit/themes/osx/global/menulist.css b/toolkit/themes/osx/global/menulist.css
--- a/toolkit/themes/osx/global/menulist.css
+++ b/toolkit/themes/osx/global/menulist.css
@@ -42,18 +42,3 @@
 menulist[disabled="true"] > .menulist-dropmarker {
   padding-inline-start: 7px !important;
 }
-
-/* ::::: editable menulists ::::: */
-
-menulist[editable="true"] {
-  -moz-appearance: menulist-textfield;
-  margin: 4px 2px;
-}
-
-html|*.menulist-editable-input {
-  margin: 0px !important;
-  border: none !important;
-  padding: 0px !important;
-  background: inherit;
-  font: inherit;
-}
diff --git a/toolkit/themes/osx/global/popup.css b/toolkit/themes/osx/global/popup.css
--- a/toolkit/themes/osx/global/popup.css
+++ b/toolkit/themes/osx/global/popup.css
@@ -93,25 +93,18 @@
 
 menulist > menupopup {
   min-width: 0px;
+  padding: 4px 0;
 }
 
 menulist > menupopup:not([position]) {
   margin-inline-start: -13px;
   margin-top: -2px;
 }
 
-menulist[editable="true"] > menupopup {
-  -moz-appearance: none;
-}
-
 menulist > menupopup > .popup-internal-box {
   padding: 0;
 }
 
-menulist:not([editable="true"]) > menupopup {
-  padding: 4px 0;
-}
-
 menupopup[customoptionstyling="true"] {
   -moz-appearance: none;
   padding-top: 0;
diff --git a/toolkit/themes/osx/reftests/baseline.xul b/toolkit/themes/osx/reftests/baseline.xul
--- a/toolkit/themes/osx/reftests/baseline.xul
+++ b/toolkit/themes/osx/reftests/baseline.xul
@@ -11,7 +11,7 @@
  *
  * It works like this:
  * For every combination of two different widgets (where widget is one of
- * label, radio, checkbox, button, textbox, menulist, menulist[editable="true"]),
+ * label, radio, checkbox, button, textbox, menulist)
  * there's a stack with two layers. The back layer in the stack is
  * just a vertically centered label with a bunch of underscores. This is the
  * baseline that the text on the widgets should hit.
diff --git a/toolkit/themes/osx/reftests/nostretch-ref.xul b/toolkit/themes/osx/reftests/nostretch-ref.xul
--- a/toolkit/themes/osx/reftests/nostretch-ref.xul
+++ b/toolkit/themes/osx/reftests/nostretch-ref.xul
@@ -69,17 +69,12 @@
   list.appendChild(popup);
   return list;
 }
-function createEditableMenulist(v) {
-  let list = createMenulist(v);
-  list.setAttribute("editable", "true");
-  return list;
-}
 function loaded() {
   let template = document.getElementById("template");
   ["regular", "small"].forEach(function(size) {
     let wrapper = document.querySelectorAll("#wrapper > ." + size)[0];
     allPairs([
-      createButton, createMenulist, createTextField, createEditableMenulist,
+      createButton, createMenulist, createTextField,
     ]).forEach(function(elemList) {
       let newBox = template.cloneNode(true);
       newBox.className = "spacer";
diff --git a/toolkit/themes/osx/reftests/nostretch.xul b/toolkit/themes/osx/reftests/nostretch.xul
--- a/toolkit/themes/osx/reftests/nostretch.xul
+++ b/toolkit/themes/osx/reftests/nostretch.xul
@@ -82,17 +82,12 @@
   list.appendChild(popup);
   return list;
 }
-function createEditableMenulist(v) {
-  let list = createMenulist(v);
-  list.setAttribute("editable", "true");
-  return list;
-}
 function loaded() {
   let template = document.getElementById("template");
   ["regular", "small"].forEach(function(size) {
     let wrapper = document.querySelectorAll("#wrapper > ." + size)[0];
     allPairs([
-      createButton, createMenulist, createTextField, createEditableMenulist,
+      createButton, createMenulist, createTextField,
     ]).forEach(function(elemList) {
       let newBox = template.cloneNode(true);
       newBox.className = "spacer";
diff --git a/toolkit/themes/shared/in-content/common.inc.css b/toolkit/themes/shared/in-content/common.inc.css
--- a/toolkit/themes/shared/in-content/common.inc.css
+++ b/toolkit/themes/shared/in-content/common.inc.css
@@ -377,7 +377,7 @@
   background-image: url("chrome://global/skin/arrow/arrow-dn.gif");
 }
 
-xul|menulist:not([editable="true"]) > xul|*.menulist-dropmarker {
+xul|*.menulist-dropmarker {
   -moz-appearance: none;
   margin-inline-end: 4px;
   padding: 0;
@@ -388,12 +388,12 @@
   fill: -moz-DialogText;
 }
 
-xul|menulist:not([editable="true"]) > xul|*.menulist-dropmarker > xul|*.dropmarker-icon {
+xul|*.menulist-dropmarker > xul|*.dropmarker-icon {
   width: 18px;
   height: 18px;
 }
 
-xul|menulist[disabled="true"]:not([editable="true"]) > xul|*.menulist-dropmarker {
+xul|menulist[disabled="true"] > xul|*.menulist-dropmarker {
   fill: GrayText;
 }
 
diff --git a/toolkit/themes/windows/global/in-content/common.css b/toolkit/themes/windows/global/in-content/common.css
--- a/toolkit/themes/windows/global/in-content/common.css
+++ b/toolkit/themes/windows/global/in-content/common.css
@@ -8,7 +8,7 @@
   background-color: transparent;
 }
 
-xul|menulist:not([editable="true"]) > xul|*.menulist-dropmarker {
+xul|*.menulist-dropmarker {
   margin-top: 1px;
   margin-bottom: 1px;
 }
diff --git a/toolkit/themes/windows/global/menulist.css b/toolkit/themes/windows/global/menulist.css
--- a/toolkit/themes/windows/global/menulist.css
+++ b/toolkit/themes/windows/global/menulist.css
@@ -48,23 +48,6 @@
   color: GrayText;
 }
 
-/* ::::: editable menulists ::::: */
-
-.menulist-editable-box {
-  padding-top: 3px;
-  padding-bottom: 3px;
-  padding-inline-start: 2px;
-  padding-inline-end: 0px;
-}
-
-html|*.menulist-editable-input {
-  margin: 0px !important;
-  border: none !important;
-  padding: 0px !important;
-  background: inherit;
-  font: inherit;
-}
-
 @media (-moz-windows-default-theme) {
   .menulist-label-box {
     background-color: transparent !important;
@@ -77,7 +60,7 @@
     margin-bottom: -1px !important;
   }
 
-  menulist:not([editable="true"]) > .menulist-dropmarker {
+  .menulist-dropmarker {
     margin-top: -2px;
     margin-inline-start: 3px;
     margin-inline-end: -3px;
diff --git a/widget/nsNativeTheme.h b/widget/nsNativeTheme.h
--- a/widget/nsNativeTheme.h
+++ b/widget/nsNativeTheme.h
@@ -164,8 +164,6 @@
   // True if it's not a menubar item or menulist item
   bool IsRegularMenuItem(nsIFrame *aFrame);
 
-  bool IsMenuListEditable(nsIFrame *aFrame);
-
   nsIPresShell *GetPresShell(nsIFrame* aFrame);
   static bool CheckBooleanAttr(nsIFrame* aFrame, nsAtom* aAtom);
   static int32_t CheckIntAttr(nsIFrame* aFrame, nsAtom* aAtom, int32_t defaultValue);
diff --git a/widget/nsNativeTheme.cpp b/widget/nsNativeTheme.cpp
--- a/widget/nsNativeTheme.cpp
+++ b/widget/nsNativeTheme.cpp
@@ -642,16 +642,6 @@
 }
 
 bool
-nsNativeTheme::IsMenuListEditable(nsIFrame *aFrame)
-{
-  bool isEditable = false;
-  nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(aFrame->GetContent());
-  if (menulist)
-    menulist->GetEditable(&isEditable);
-  return isEditable;
-}
-
-bool
 nsNativeTheme::QueueAnimatedContentForRefresh(nsIContent* aContent,
                                               uint32_t aMinimumFrameRate)
 {
diff --git a/widget/windows/nsNativeThemeWin.cpp b/widget/windows/nsNativeThemeWin.cpp
--- a/widget/windows/nsNativeThemeWin.cpp
+++ b/widget/windows/nsNativeThemeWin.cpp
@@ -1274,9 +1274,7 @@
     }
     case StyleAppearance::Menulist: {
       nsIContent* content = aFrame->GetContent();
-      bool isHTML = content && content->IsHTMLElement();
-      bool isChrome = aFrame->GetContent()->IsInChromeDocument();
-      bool useDropBorder = isHTML || (isChrome && IsMenuListEditable(aFrame));
+      bool useDropBorder = content && content->IsHTMLElement();
       EventStates eventState = GetContentState(aFrame, aWidgetType);
 
       /* On Vista/Win7, we use CBP_DROPBORDER instead of DROPFRAME for HTML
@@ -1338,8 +1336,7 @@
       else
         isOpen = IsOpenButton(aFrame);
 
-      bool isChrome = aFrame->GetContent()->IsInChromeDocument();
-      if (isHTML || (isChrome && IsMenuListEditable(aFrame))) {
+      if (isHTML) {
         if (isOpen) {
           /* Hover is propagated, but we need to know whether we're hovering
            * just the combobox frame, not the dropdown frame. But, we can't get

