
# HG changeset patch
# User Brendan Dahl <bdahl@mozilla.com>
# Date 1548280907 28800
# Node ID 4797fa1ec4e91f8a0d66e5434fb0476928d48c68
# Parent  d0a6668cf2fe907399cff20030b7b8218d56f005
Delay layout and and skip incremental flushing.


diff --git a/dom/base/nsContentSink.cpp b/dom/base/nsContentSink.cpp
--- a/dom/base/nsContentSink.cpp
+++ b/dom/base/nsContentSink.cpp
@@ -110,17 +110,18 @@ nsContentSink::nsContentSink()
       mDeflectedCount(0),
       mHasPendingEvent(false),
       mCurrentParseEndTime(0),
       mBeginLoadTime(0),
       mLastSampledUserEventTime(0),
       mInMonolithicContainer(0),
       mInNotification(0),
       mUpdatesInNotification(0),
-      mPendingSheetCount(0) {
+      mPendingSheetCount(0),
+      mFastLoad(false) {
   NS_ASSERTION(!mLayoutStarted, "What?");
   NS_ASSERTION(!mDynamicLowerValue, "What?");
   NS_ASSERTION(!mParsing, "What?");
   NS_ASSERTION(mLastSampledUserEventTime == 0, "What?");
   NS_ASSERTION(mDeflectedCount == 0, "What?");
   NS_ASSERTION(!mDroppedTimer, "What?");
   NS_ASSERTION(mInMonolithicContainer == 0, "What?");
   NS_ASSERTION(mInNotification == 0, "What?");
@@ -188,16 +189,27 @@ nsresult nsContentSink::Init(Document* a
   MOZ_ASSERT(aURI, "null ptr");
 
   if (!aDoc || !aURI) {
     return NS_ERROR_NULL_POINTER;
   }
 
   mDocument = aDoc;
 
+  if (aChannel) {
+    nsCOMPtr<nsIURI> url;
+    aChannel->GetOriginalURI(getter_AddRefs(url));
+    if (Substring(url->GetSpecOrDefault(), url->GetSpecOrDefault().Length() - 13)
+            .EqualsLiteral("browser.xhtml")) {
+      mFastLoad = true;
+      printf(">>> fast load!\n");
+    }
+  }
+
+
   mDocumentURI = aURI;
   mDocShell = do_QueryInterface(aContainer);
   mScriptLoader = mDocument->ScriptLoader();
 
   if (!mRunsToCompletion) {
     if (mDocShell) {
       uint32_t loadType = 0;
       mDocShell->GetLoadType(&loadType);
@@ -1338,17 +1350,17 @@ nsresult nsContentSink::WillResumeImpl()
              SINK_TRACE_CALLS, ("nsContentSink::WillResume: this=%p", this));
 
   mParsing = true;
 
   return NS_OK;
 }
 
 nsresult nsContentSink::DidProcessATokenImpl() {
-  if (mRunsToCompletion || !mParser) {
+  if (mRunsToCompletion || !mParser || mFastLoad) {
     return NS_OK;
   }
 
   // Get the current user event time
   nsIPresShell* shell = mDocument->GetShell();
   if (!shell) {
     // If there's no pres shell in the document, return early since
     // we're not laying anything out here.
@@ -1486,17 +1498,17 @@ void nsContentSink::DropParserAndPerfHin
   }
 }
 
 bool nsContentSink::IsScriptExecutingImpl() {
   return !!mScriptLoader->GetCurrentScript();
 }
 
 nsresult nsContentSink::WillParseImpl(void) {
-  if (mRunsToCompletion || !mDocument) {
+  if (mRunsToCompletion || !mDocument || mFastLoad) {
     return NS_OK;
   }
 
   nsIPresShell* shell = mDocument->GetShell();
   if (!shell) {
     return NS_OK;
   }
 
diff --git a/dom/base/nsContentSink.h b/dom/base/nsContentSink.h
--- a/dom/base/nsContentSink.h
+++ b/dom/base/nsContentSink.h
@@ -331,16 +331,18 @@ class nsContentSink : public nsICSSLoade
   int32_t mInNotification;
   uint32_t mUpdatesInNotification;
 
   uint32_t mPendingSheetCount;
 
   nsRevocableEventPtr<nsRunnableMethod<nsContentSink, void, false> >
       mProcessLinkHeaderEvent;
 
+  bool mFastLoad;
+
   // Do we notify based on time?
   static bool sNotifyOnTimer;
   // Back off timer notification after count.
   static int32_t sBackoffCount;
   // Notification interval in microseconds
   static int32_t sNotificationInterval;
   // How many times to deflect in interactive/perf modes
   static int32_t sInteractiveDeflectCount;
diff --git a/dom/xml/nsXMLContentSink.cpp b/dom/xml/nsXMLContentSink.cpp
--- a/dom/xml/nsXMLContentSink.cpp
+++ b/dom/xml/nsXMLContentSink.cpp
@@ -296,31 +296,39 @@ nsXMLContentSink::DidBuildModel(bool aTe
       // stylesheet loads
       if (mDocument->CSSLoader()->HasPendingLoads()) {
         mDocument->CSSLoader()->AddObserver(this);
         // wait for those sheets to load
         startLayout = false;
       }
     }
 
-    if (startLayout) {
-      StartLayout(false);
+    KickTheTires();
+  }
+
+  return NS_OK;
+}
 
-      ScrollToRef();
+void nsXMLContentSink::KickTheTires() {
+    if (mPendingSheetCount > 0) {
+      // Style sheet load will kick off layout.
+      return;
     }
 
+    mDeferredLayoutStart = true;
+    StartLayout(false);
+
+    ScrollToRef();
+
     mDocument->RemoveObserver(this);
     mIsDocumentObserver = false;
 
     mDocument->EndLoad();
 
     DropParserAndPerfHint();
-  }
-
-  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsXMLContentSink::OnDocumentCreated(Document* aResultDocument) {
   NS_ENSURE_ARG(aResultDocument);
 
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aResultDocument);
   if (htmlDoc) {
@@ -604,16 +612,22 @@ nsresult nsXMLContentSink::CloseElement(
 
   return rv;
 }
 
 nsresult nsXMLContentSink::AddContentAsLeaf(nsIContent* aContent) {
   nsresult result = NS_OK;
 
   if (mState == eXMLContentSinkState_InProlog) {
+    nsINode* nodeToInsertBefore = mDocument->GetFirstChild();
+    mDocument->InsertChildBefore(aContent, nodeToInsertBefore ? nodeToInsertBefore->AsContent() : nullptr, false);
+    return NS_OK;
+  }
+
+  if (mState == eXMLContentSinkState_InProlog) {
     NS_ASSERTION(mDocument, "Fragments have no prolog");
     mDocumentChildren.AppendElement(aContent);
   } else if (mState == eXMLContentSinkState_InEpilog) {
     NS_ASSERTION(mDocument, "Fragments have no epilog");
     if (mXSLTProcessor) {
       mDocumentChildren.AppendElement(aContent);
     } else {
       mDocument->AppendChildTo(aContent, false);
@@ -828,22 +842,23 @@ bool nsXMLContentSink::HaveNotifiedForCu
     const StackNode& stackNode = mContentStack[stackLength - 1];
     nsIContent* parent = stackNode.mContent;
     return stackNode.mNumFlushed == parent->GetChildCount();
   }
   return true;
 }
 
 void nsXMLContentSink::MaybeStartLayout(bool aIgnorePendingSheets) {
+  return;
   // XXXbz if aIgnorePendingSheets is true, what should we do when
   // mXSLTProcessor or CanStillPrettyPrint()?
-  if (mLayoutStarted || mXSLTProcessor || CanStillPrettyPrint()) {
-    return;
-  }
-  StartLayout(aIgnorePendingSheets);
+  // if (mLayoutStarted || mXSLTProcessor || CanStillPrettyPrint()) {
+  //   return;
+  // }
+  // StartLayout(aIgnorePendingSheets);
 }
 
 ////////////////////////////////////////////////////////////////////////
 
 bool nsXMLContentSink::SetDocElement(int32_t aNameSpaceID, nsAtom* aTagName,
                                      nsIContent* aContent) {
   if (mDocElement) return false;
 
@@ -1192,16 +1207,18 @@ nsXMLContentSink::HandleProcessingInstru
     // a CSS one if the type is set to something else.
     ssle->SetEnableUpdates(true);
     auto updateOrError =
         ssle->UpdateStyleSheet(mRunsToCompletion ? nullptr : this);
     if (updateOrError.isErr()) {
       return updateOrError.unwrapErr();
     }
 
+
+
     auto update = updateOrError.unwrap();
     if (update.WillNotify()) {
       // Successfully started a stylesheet load
       if (update.ShouldBlock() && !mRunsToCompletion) {
         ++mPendingSheetCount;
         mScriptLoader->AddParserBlockingScriptExecutionBlocker();
       }
       return NS_OK;
diff --git a/dom/xml/nsXMLContentSink.h b/dom/xml/nsXMLContentSink.h
--- a/dom/xml/nsXMLContentSink.h
+++ b/dom/xml/nsXMLContentSink.h
@@ -170,16 +170,18 @@ class nsXMLContentSink : public nsConten
 
   nsresult HandleStartElement(const char16_t* aName, const char16_t** aAtts,
                               uint32_t aAttsCount, uint32_t aLineNumber,
                               uint32_t aColumnNumber, bool aInterruptable);
   nsresult HandleEndElement(const char16_t* aName, bool aInterruptable);
   nsresult HandleCharacterData(const char16_t* aData, uint32_t aLength,
                                bool aInterruptable);
 
+  void KickTheTires();
+
   nsCOMPtr<nsIContent> mDocElement;
   nsCOMPtr<nsIContent> mCurrentHead;  // When set, we're in an XHTML <haed>
 
   XMLContentSinkState mState;
 
   // The length of the valid data in mText.
   int32_t mTextLength;
 

