# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1579107871 28800
#      Wed Jan 15 09:04:31 2020 -0800
# Node ID 9f34c6f3c5b30f025578ce33f71e402414f93de0
# Parent  46e1717494fbf0f1913e22052c3304fe9f7c19b8
Bug 1608278 - Automated rewrite away from assigning properties to `this` in JSM files in devtools;r=jdescottes

This patch was generated with the script https://github.com/bgrins/jsm-rewrites/blob/d2bbd6c459294b65955442e45b5a7f5dba11e639/no-this-property-assign.js
using the following command:

cp .gitignore .rgignore && rg -l -g '*.jsm' '' devtools | jscodeshift --stdin --transform ~/Code/jsm-rewrites/no-this-property-assign.js && ./mach eslint --outgoing --fix

There's also a manual fixup in Loader.jsm from const to var for a couple exports.

Differential Revision: https://phabricator.services.mozilla.com/D60030

diff --git a/devtools/client/framework/browser-toolbox/Launcher.jsm b/devtools/client/framework/browser-toolbox/Launcher.jsm
--- a/devtools/client/framework/browser-toolbox/Launcher.jsm
+++ b/devtools/client/framework/browser-toolbox/Launcher.jsm
@@ -33,32 +33,32 @@ XPCOMUtils.defineLazyGetter(this, "Telem
   return require("devtools/client/shared/telemetry");
 });
 XPCOMUtils.defineLazyGetter(this, "EventEmitter", function() {
   return require("devtools/shared/event-emitter");
 });
 
 const Services = require("Services");
 
-this.EXPORTED_SYMBOLS = ["BrowserToolboxLauncher"];
+const EXPORTED_SYMBOLS = ["BrowserToolboxLauncher"];
 
 var processes = new Set();
 
 /**
  * Constructor for creating a process that will hold a chrome toolbox.
  *
  * @param function onClose [optional]
  *        A function called when the process stops running.
  * @param function onRun [optional]
  *        A function called when the process starts running.
  * @param boolean overwritePreferences [optional]
  *        Set to force overwriting the toolbox profile's preferences with the
  *        current set of preferences.
  */
-this.BrowserToolboxLauncher = function BrowserToolboxLauncher(
+function BrowserToolboxLauncher(
   onClose,
   onRun,
   overwritePreferences,
   binaryPath
 ) {
   const emitter = new EventEmitter();
   this.on = emitter.on.bind(emitter);
   this.off = emitter.off.bind(emitter);
@@ -80,17 +80,17 @@ this.BrowserToolboxLauncher = function B
 
   this.close = this.close.bind(this);
   Services.obs.addObserver(this.close, "quit-application");
   this._initServer();
   this._initProfile(overwritePreferences);
   this._create(binaryPath);
 
   processes.add(this);
-};
+}
 
 EventEmitter.decorate(BrowserToolboxLauncher);
 
 /**
  * Initializes and starts a chrome toolbox process.
  * @return object
  */
 BrowserToolboxLauncher.init = function(
diff --git a/devtools/client/shared/SplitView.jsm b/devtools/client/shared/SplitView.jsm
--- a/devtools/client/shared/SplitView.jsm
+++ b/devtools/client/shared/SplitView.jsm
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const { require } = ChromeUtils.import("resource://devtools/shared/Loader.jsm");
 const { KeyCodes } = require("devtools/client/shared/keycodes");
 
-this.EXPORTED_SYMBOLS = ["SplitView"];
+const EXPORTED_SYMBOLS = ["SplitView"];
 
 /* this must be kept in sync with CSS (ie. splitview.css) */
 const LANDSCAPE_MEDIA_QUERY = "(min-width: 701px)";
 
 var bindings = new WeakMap();
 
 /**
  * SplitView constructor
@@ -22,17 +22,17 @@ var bindings = new WeakMap();
  * A split view contains items, each of those having one summary and one details
  * elements.
  * It is adaptive as it behaves similarly to a richlistbox when there the aspect
  * ratio is narrow or as a pair listbox-box otherwise.
  *
  * @param DOMElement aRoot
  * @see appendItem
  */
-this.SplitView = function SplitView(aRoot) {
+function SplitView(aRoot) {
   this._root = aRoot;
   this._controller = aRoot.querySelector(".splitview-controller");
   this._nav = aRoot.querySelector(".splitview-nav");
   this._side = aRoot.querySelector(".splitview-side-details");
   this._activeSummary = null;
 
   this._mql = aRoot.ownerDocument.defaultView.matchMedia(LANDSCAPE_MEDIA_QUERY);
 
@@ -83,17 +83,17 @@ this.SplitView = function SplitView(aRoo
       aEvent.stopPropagation();
       const el = this.getSummaryElementByOrdinal(newFocusOrdinal);
       if (el) {
         el.focus();
       }
       return false;
     }
   });
-};
+}
 
 SplitView.prototype = {
   /**
    * Retrieve whether the UI currently has a landscape orientation.
    *
    * @return boolean
    */
   get isLandscape() {
diff --git a/devtools/client/shared/widgets/AbstractTreeItem.jsm b/devtools/client/shared/widgets/AbstractTreeItem.jsm
--- a/devtools/client/shared/widgets/AbstractTreeItem.jsm
+++ b/devtools/client/shared/widgets/AbstractTreeItem.jsm
@@ -6,17 +6,17 @@
 const { require, loader } = ChromeUtils.import(
   "resource://devtools/shared/Loader.jsm"
 );
 const { ViewHelpers } = require("devtools/client/shared/widgets/view-helpers");
 const { KeyCodes } = require("devtools/client/shared/keycodes");
 
 loader.lazyRequireGetter(this, "EventEmitter", "devtools/shared/event-emitter");
 
-this.EXPORTED_SYMBOLS = ["AbstractTreeItem"];
+const EXPORTED_SYMBOLS = ["AbstractTreeItem"];
 
 /**
  * A very generic and low-level tree view implementation. It is not intended
  * to be used alone, but as a base class that you can extend to build your
  * own custom implementation.
  *
  * Language:
  *   - An "item" is an instance of an AbstractTreeItem.
@@ -118,17 +118,16 @@ function AbstractTreeItem({ parent, leve
   this._childTreeItems = [];
 
   // Events are always propagated through the root item. Decorating every
   // tree item as an event emitter is a very costly operation.
   if (this == this._rootItem) {
     EventEmitter.decorate(this);
   }
 }
-this.AbstractTreeItem = AbstractTreeItem;
 
 AbstractTreeItem.prototype = {
   _containerNode: null,
   _targetNode: null,
   _arrowNode: null,
   _constructed: false,
   _populated: false,
   _expanded: false,
diff --git a/devtools/client/storage/VariablesView.jsm b/devtools/client/storage/VariablesView.jsm
--- a/devtools/client/storage/VariablesView.jsm
+++ b/devtools/client/storage/VariablesView.jsm
@@ -33,17 +33,17 @@ const HTML_NS = "http://www.w3.org/1999/
 
 XPCOMUtils.defineLazyServiceGetter(
   this,
   "clipboardHelper",
   "@mozilla.org/widget/clipboardhelper;1",
   "nsIClipboardHelper"
 );
 
-this.EXPORTED_SYMBOLS = ["VariablesView", "escapeHTML"];
+const EXPORTED_SYMBOLS = ["VariablesView", "escapeHTML"];
 
 /**
  * A tree view for inspecting scopes, objects and properties.
  * Iterable via "for (let [id, scope] of instance) { }".
  * Requires the devtools common.css and debugger.css skin stylesheets.
  *
  * To allow replacing variable or property values in this view, provide an
  * "eval" function property. To allow replacing variable or property names,
@@ -51,17 +51,17 @@ this.EXPORTED_SYMBOLS = ["VariablesView"
  * provide a "delete" function.
  *
  * @param Node aParentNode
  *        The parent node to hold this view.
  * @param object aFlags [optional]
  *        An object contaning initialization options for this view.
  *        e.g. { lazyEmpty: true, searchEnabled: true ... }
  */
-this.VariablesView = function VariablesView(aParentNode, aFlags = {}) {
+function VariablesView(aParentNode, aFlags = {}) {
   this._store = []; // Can't use a Map because Scope names needn't be unique.
   this._itemsByElement = new WeakMap();
   this._prevHierarchy = new Map();
   this._currHierarchy = new Map();
 
   this._parent = aParentNode;
   this._parent.classList.add("variables-view-container");
   this._parent.classList.add("theme-body");
@@ -77,17 +77,17 @@ this.VariablesView = function VariablesV
   this._list.addEventListener("keydown", this._onViewKeyDown);
   this._parent.appendChild(this._list);
 
   for (const name in aFlags) {
     this[name] = aFlags[name];
   }
 
   EventEmitter.decorate(this);
-};
+}
 
 VariablesView.prototype = {
   /**
    * Helper setter for populating this container with a raw object.
    *
    * @param object aObject
    *        The raw object to display. You can only provide this object
    *        if you want the variables view to work in sync mode.
diff --git a/devtools/client/styleeditor/StyleEditorUI.jsm b/devtools/client/styleeditor/StyleEditorUI.jsm
--- a/devtools/client/styleeditor/StyleEditorUI.jsm
+++ b/devtools/client/styleeditor/StyleEditorUI.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["StyleEditorUI"];
+const EXPORTED_SYMBOLS = ["StyleEditorUI"];
 
 const { loader, require } = ChromeUtils.import(
   "resource://devtools/shared/Loader.jsm"
 );
 const Services = require("Services");
 const { NetUtil } = require("resource://gre/modules/NetUtil.jsm");
 const { OS } = require("resource://gre/modules/osfile.jsm");
 const EventEmitter = require("devtools/shared/event-emitter");
@@ -112,17 +112,16 @@ function StyleEditorUI(toolbox, panelDoc
 
   this._prefObserver = new PrefObserver("devtools.styleeditor.");
   this._prefObserver.on(PREF_MEDIA_SIDEBAR, this._onMediaPrefChanged);
   this._sourceMapPrefObserver = new PrefObserver(
     "devtools.source-map.client-service."
   );
   this._sourceMapPrefObserver.on(PREF_ORIG_SOURCES, this._onNewDocument);
 }
-this.StyleEditorUI = StyleEditorUI;
 
 StyleEditorUI.prototype = {
   get currentTarget() {
     return this._toolbox.targetList.targetFront;
   },
 
   /*
    * Index of selected stylesheet in document.styleSheets
diff --git a/devtools/client/styleeditor/StyleEditorUtil.jsm b/devtools/client/styleeditor/StyleEditorUtil.jsm
--- a/devtools/client/styleeditor/StyleEditorUtil.jsm
+++ b/devtools/client/styleeditor/StyleEditorUtil.jsm
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* All top-level definitions here are exports.  */
 /* eslint no-unused-vars: [2, {"vars": "local"}] */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   "getString",
   "assert",
   "log",
   "text",
   "wire",
   "showFilePicker",
   "optionsPopupMenu",
 ];
diff --git a/devtools/client/styleeditor/StyleSheetEditor.jsm b/devtools/client/styleeditor/StyleSheetEditor.jsm
--- a/devtools/client/styleeditor/StyleSheetEditor.jsm
+++ b/devtools/client/styleeditor/StyleSheetEditor.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["StyleSheetEditor"];
+const EXPORTED_SYMBOLS = ["StyleSheetEditor"];
 
 const { require } = ChromeUtils.import("resource://devtools/shared/Loader.jsm");
 const Editor = require("devtools/client/shared/sourceeditor/editor");
 const promise = require("promise");
 const {
   shortSource,
   prettifyCSS,
 } = require("devtools/shared/inspector/css-logic");
@@ -134,17 +134,16 @@ function StyleSheetEditor(styleSheet, wi
       .getMediaRules()
       .then(this._onMediaRulesChanged, console.error);
   }
   this.cssSheet.on("media-rules-changed", this._onMediaRulesChanged);
   this.cssSheet.on("style-applied", this._onStyleApplied);
   this.savedFile = file;
   this.linkCSSFile();
 }
-this.StyleSheetEditor = StyleSheetEditor;
 
 StyleSheetEditor.prototype = {
   /**
    * Whether there are unsaved changes in the editor
    */
   get unsaved() {
     return this.sourceEditor && !this.sourceEditor.isClean();
   },
diff --git a/devtools/server/startup/content-process.jsm b/devtools/server/startup/content-process.jsm
--- a/devtools/server/startup/content-process.jsm
+++ b/devtools/server/startup/content-process.jsm
@@ -9,17 +9,17 @@
  * process.  Loaded into content processes by the main process during
  * content-process-connector.js' `connectToContentProcess` via the process
  * script `content-process.js`.
  *
  * The actual server startup itself is in this JSM so that code can be cached.
  */
 
 /* exported init */
-this.EXPORTED_SYMBOLS = ["init"];
+const EXPORTED_SYMBOLS = ["init"];
 
 let gLoader;
 
 function setupServer(mm) {
   // Prevent spawning multiple server per process, even if the caller call us
   // multiple times
   if (gLoader) {
     return gLoader;
diff --git a/devtools/shared/Loader.jsm b/devtools/shared/Loader.jsm
--- a/devtools/shared/Loader.jsm
+++ b/devtools/shared/Loader.jsm
@@ -11,17 +11,17 @@
 var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 var { Loader, Require, resolveURI, unload } = ChromeUtils.import(
   "resource://devtools/shared/base-loader.js"
 );
 var { requireRawId } = ChromeUtils.import(
   "resource://devtools/shared/loader-plugin-raw.jsm"
 );
 
-this.EXPORTED_SYMBOLS = [
+const EXPORTED_SYMBOLS = [
   "DevToolsLoader",
   "require",
   "loader",
   // Export StructuredCloneHolder for its use from builtin-modules
   "StructuredCloneHolder",
 ];
 
 var gNextLoaderID = 0;
@@ -40,17 +40,17 @@ var gNextLoaderID = 0;
  *        If true, the modules will be forced to be loaded in a distinct
  *        compartment. It is typically used to load the modules in a distinct
  *        system compartment, different from the main one, which is shared by
  *        all JSMs, XPCOMs and modules loaded with this flag set to true.
  *        We use this in order to debug modules loaded in this shared system
  *        compartment. The debugger actor has to be running in a distinct
  *        compartment than the context it is debugging.
  */
-this.DevToolsLoader = function DevToolsLoader({
+function DevToolsLoader({
   invisibleToDebugger = false,
   freshCompartment = false,
 } = {}) {
   const paths = {
     // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
     devtools: "resource://devtools",
     // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
     acorn: "resource://devtools/shared/acorn",
@@ -142,17 +142,17 @@ this.DevToolsLoader = function DevToolsL
   // created for objects in the recording/replaying process.
   if (globals.isReplaying) {
     const oldHook = this.loader.requireHook;
     const ReplayInspector = this.require(
       "devtools/server/actors/replay/inspector"
     );
     this.loader.requireHook = ReplayInspector.wrapRequireHook(oldHook);
   }
-};
+}
 
 DevToolsLoader.prototype = {
   destroy: function(reason = "shutdown") {
     unload(this.loader, reason);
     delete this.loader;
   },
 
   /**
@@ -160,22 +160,22 @@ DevToolsLoader.prototype = {
    * loader plugin.
    */
   isLoaderPluginId: function(id) {
     return id.startsWith("raw!");
   },
 };
 
 // Export the standard instance of DevToolsLoader used by the tools.
-this.loader = new DevToolsLoader({
+var loader = new DevToolsLoader({
   /**
    * Sets whether the compartments loaded by this instance should be invisible
    * to the debugger.  Invisibility is needed for loaders that support debugging
    * of chrome code.  This is true of remote target environments, like Fennec or
    * B2G.  It is not the default case for desktop Firefox because we offer the
    * Browser Toolbox for chrome debugging there, which uses its own, separate
    * loader instance.
    * @see devtools/client/framework/browser-toolbox/Launcher.jsm
    */
   invisibleToDebugger: Services.appinfo.name !== "Firefox",
 });
 
-this.require = this.loader.require;
+var require = loader.require;
diff --git a/devtools/shared/heapsnapshot/tests/unit/Census.jsm b/devtools/shared/heapsnapshot/tests/unit/Census.jsm
--- a/devtools/shared/heapsnapshot/tests/unit/Census.jsm
+++ b/devtools/shared/heapsnapshot/tests/unit/Census.jsm
@@ -1,185 +1,180 @@
 // Functions for checking results returned by
 // Debugger.Memory.prototype.takeCensus and
 // HeapSnapshot.prototype.takeCensus. Adapted from js/src/jit-test/lib/census.js.
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["Census"];
+const EXPORTED_SYMBOLS = ["Census"];
 
-this.Census = (function() {
-  const Census = {};
-
-  function dumpn(msg) {
-    dump("DBG-TEST: Census.jsm: " + msg + "\n");
-  }
+const Census = {};
+function dumpn(msg) {
+  dump("DBG-TEST: Census.jsm: " + msg + "\n");
+}
 
-  // Census.walkCensus(subject, name, walker)
-  //
-  // Use |walker| to check |subject|, a census object of the sort returned by
-  // Debugger.Memory.prototype.takeCensus: a tree of objects with integers at the
-  // leaves. Use |name| as the name for |subject| in diagnostic messages. Return
-  // the number of leaves of |subject| we visited.
-  //
-  // A walker is an object with three methods:
-  //
-  // - enter(prop): Return the walker we should use to check the property of the
-  //   subject census named |prop|. This is for recursing into the subobjects of
-  //   the subject.
-  //
-  // - done(): Called after we have called 'enter' on every property of the
-  //   subject.
-  //
-  // - check(value): Check |value|, a leaf in the subject.
-  //
-  // Walker methods are expected to simply throw if a node we visit doesn't look
-  // right.
-  Census.walkCensus = (subject, name, walker) => walk(subject, name, walker, 0);
-  function walk(subject, name, walker, count) {
-    if (typeof subject === "object") {
-      dumpn(name);
-      for (const prop in subject) {
-        count = walk(
-          subject[prop],
-          name + "[" + uneval(prop) + "]",
-          walker.enter(prop),
-          count
-        );
-      }
-      walker.done();
-    } else {
-      dumpn(name + " = " + uneval(subject));
-      walker.check(subject);
-      count++;
+// Census.walkCensus(subject, name, walker)
+//
+// Use |walker| to check |subject|, a census object of the sort returned by
+// Debugger.Memory.prototype.takeCensus: a tree of objects with integers at the
+// leaves. Use |name| as the name for |subject| in diagnostic messages. Return
+// the number of leaves of |subject| we visited.
+//
+// A walker is an object with three methods:
+//
+// - enter(prop): Return the walker we should use to check the property of the
+//   subject census named |prop|. This is for recursing into the subobjects of
+//   the subject.
+//
+// - done(): Called after we have called 'enter' on every property of the
+//   subject.
+//
+// - check(value): Check |value|, a leaf in the subject.
+//
+// Walker methods are expected to simply throw if a node we visit doesn't look
+// right.
+Census.walkCensus = (subject, name, walker) => walk(subject, name, walker, 0);
+function walk(subject, name, walker, count) {
+  if (typeof subject === "object") {
+    dumpn(name);
+    for (const prop in subject) {
+      count = walk(
+        subject[prop],
+        name + "[" + uneval(prop) + "]",
+        walker.enter(prop),
+        count
+      );
     }
-
-    return count;
-  }
-
-  // A walker that doesn't check anything.
-  Census.walkAnything = {
-    enter: () => Census.walkAnything,
-    done: () => undefined,
-    check: () => undefined,
-  };
-
-  // A walker that requires all leaves to be zeros.
-  Census.assertAllZeros = {
-    enter: () => Census.assertAllZeros,
-    done: () => undefined,
-    check: elt => {
-      if (elt !== 0) {
-        throw new Error("Census mismatch: expected zero, found " + elt);
-      }
-    },
-  };
-
-  function expectedObject() {
-    throw new Error(
-      "Census mismatch: subject has leaf where basis has nested object"
-    );
-  }
-
-  function expectedLeaf() {
-    throw new Error(
-      "Census mismatch: subject has nested object where basis has leaf"
-    );
+    walker.done();
+  } else {
+    dumpn(name + " = " + uneval(subject));
+    walker.check(subject);
+    count++;
   }
 
-  // Return a function that, given a 'basis' census, returns a census walker that
-  // compares the subject census against the basis. The returned walker calls the
-  // given |compare|, |missing|, and |extra| functions as follows:
-  //
-  // - compare(subjectLeaf, basisLeaf): Check a leaf of the subject against the
-  //   corresponding leaf of the basis.
-  //
-  // - missing(prop, value): Called when the subject is missing a property named
-  //   |prop| which is present in the basis with value |value|.
-  //
-  // - extra(prop): Called when the subject has a property named |prop|, but the
-  //   basis has no such property. This should return a walker that can check
-  //   the subject's value.
-  function makeBasisChecker({ compare, missing, extra }) {
-    return function makeWalker(basis) {
-      if (typeof basis === "object") {
-        const unvisited = new Set(Object.getOwnPropertyNames(basis));
-        return {
-          enter: prop => {
-            unvisited.delete(prop);
-            if (prop in basis) {
-              return makeWalker(basis[prop]);
-            }
+  return count;
+}
+
+// A walker that doesn't check anything.
+Census.walkAnything = {
+  enter: () => Census.walkAnything,
+  done: () => undefined,
+  check: () => undefined,
+};
+
+// A walker that requires all leaves to be zeros.
+Census.assertAllZeros = {
+  enter: () => Census.assertAllZeros,
+  done: () => undefined,
+  check: elt => {
+    if (elt !== 0) {
+      throw new Error("Census mismatch: expected zero, found " + elt);
+    }
+  },
+};
+
+function expectedObject() {
+  throw new Error(
+    "Census mismatch: subject has leaf where basis has nested object"
+  );
+}
 
-            return extra(prop);
-          },
+function expectedLeaf() {
+  throw new Error(
+    "Census mismatch: subject has nested object where basis has leaf"
+  );
+}
 
-          done: () => unvisited.forEach(prop => missing(prop, basis[prop])),
-          check: expectedObject,
-        };
-      }
+// Return a function that, given a 'basis' census, returns a census walker that
+// compares the subject census against the basis. The returned walker calls the
+// given |compare|, |missing|, and |extra| functions as follows:
+//
+// - compare(subjectLeaf, basisLeaf): Check a leaf of the subject against the
+//   corresponding leaf of the basis.
+//
+// - missing(prop, value): Called when the subject is missing a property named
+//   |prop| which is present in the basis with value |value|.
+//
+// - extra(prop): Called when the subject has a property named |prop|, but the
+//   basis has no such property. This should return a walker that can check
+//   the subject's value.
+function makeBasisChecker({ compare, missing, extra }) {
+  return function makeWalker(basis) {
+    if (typeof basis === "object") {
+      const unvisited = new Set(Object.getOwnPropertyNames(basis));
+      return {
+        enter: prop => {
+          unvisited.delete(prop);
+          if (prop in basis) {
+            return makeWalker(basis[prop]);
+          }
 
-      return {
-        enter: expectedLeaf,
-        done: expectedLeaf,
-        check: elt => compare(elt, basis),
+          return extra(prop);
+        },
+
+        done: () => unvisited.forEach(prop => missing(prop, basis[prop])),
+        check: expectedObject,
       };
+    }
+
+    return {
+      enter: expectedLeaf,
+      done: expectedLeaf,
+      check: elt => compare(elt, basis),
     };
-  }
+  };
+}
 
-  function missingProp(prop) {
-    throw new Error(
-      "Census mismatch: subject lacks property present in basis: " + prop
-    );
-  }
+function missingProp(prop) {
+  throw new Error(
+    "Census mismatch: subject lacks property present in basis: " + prop
+  );
+}
 
-  function extraProp(prop) {
-    throw new Error(
-      "Census mismatch: subject has property not present in basis: " + prop
-    );
-  }
+function extraProp(prop) {
+  throw new Error(
+    "Census mismatch: subject has property not present in basis: " + prop
+  );
+}
 
-  // Return a walker that checks that the subject census has counts all equal to
-  // |basis|.
-  Census.assertAllEqual = makeBasisChecker({
-    compare: (a, b) => {
-      if (a !== b) {
-        throw new Error("Census mismatch: expected " + a + " got " + b);
-      }
-    },
-    missing: missingProp,
-    extra: extraProp,
-  });
+// Return a walker that checks that the subject census has counts all equal to
+// |basis|.
+Census.assertAllEqual = makeBasisChecker({
+  compare: (a, b) => {
+    if (a !== b) {
+      throw new Error("Census mismatch: expected " + a + " got " + b);
+    }
+  },
+  missing: missingProp,
+  extra: extraProp,
+});
+
+function ok(val) {
+  if (!val) {
+    throw new Error("Census mismatch: expected truthy, got " + val);
+  }
+}
 
-  function ok(val) {
-    if (!val) {
-      throw new Error("Census mismatch: expected truthy, got " + val);
-    }
-  }
+// Return a walker that checks that the subject census has at least as many
+// items of each category as |basis|.
+Census.assertAllNotLessThan = makeBasisChecker({
+  compare: (subject, basis) => ok(subject >= basis),
+  missing: missingProp,
+  extra: () => Census.walkAnything,
+});
 
-  // Return a walker that checks that the subject census has at least as many
-  // items of each category as |basis|.
-  Census.assertAllNotLessThan = makeBasisChecker({
-    compare: (subject, basis) => ok(subject >= basis),
+// Return a walker that checks that the subject census has at most as many
+// items of each category as |basis|.
+Census.assertAllNotMoreThan = makeBasisChecker({
+  compare: (subject, basis) => ok(subject <= basis),
+  missing: missingProp,
+  extra: () => Census.walkAnything,
+});
+
+// Return a walker that checks that the subject census has within |fudge|
+// items of each category of the count in |basis|.
+Census.assertAllWithin = function(fudge, basis) {
+  return makeBasisChecker({
+    compare: (subject, base) => ok(Math.abs(subject - base) <= fudge),
     missing: missingProp,
     extra: () => Census.walkAnything,
-  });
-
-  // Return a walker that checks that the subject census has at most as many
-  // items of each category as |basis|.
-  Census.assertAllNotMoreThan = makeBasisChecker({
-    compare: (subject, basis) => ok(subject <= basis),
-    missing: missingProp,
-    extra: () => Census.walkAnything,
-  });
-
-  // Return a walker that checks that the subject census has within |fudge|
-  // items of each category of the count in |basis|.
-  Census.assertAllWithin = function(fudge, basis) {
-    return makeBasisChecker({
-      compare: (subject, base) => ok(Math.abs(subject - base) <= fudge),
-      missing: missingProp,
-      extra: () => Census.walkAnything,
-    })(basis);
-  };
-
-  return Census;
-})();
+  })(basis);
+};
diff --git a/devtools/shared/heapsnapshot/tests/unit/Match.jsm b/devtools/shared/heapsnapshot/tests/unit/Match.jsm
--- a/devtools/shared/heapsnapshot/tests/unit/Match.jsm
+++ b/devtools/shared/heapsnapshot/tests/unit/Match.jsm
@@ -1,18 +1,18 @@
 // A little pattern-matching library.
 //
 // Ported from js/src/tests/js1_8_5/reflect-parse/Match.js for use with devtools
 // server xpcshell tests.
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["Match"];
+const EXPORTED_SYMBOLS = ["Match"];
 
-this.Match = (function() {
+const Match = (function() {
   function Pattern(template) {
     // act like a constructor even as a function
     if (!(this instanceof Pattern)) {
       return new Pattern(template);
     }
 
     this.template = template;
   }
diff --git a/devtools/shared/loader-plugin-raw.jsm b/devtools/shared/loader-plugin-raw.jsm
--- a/devtools/shared/loader-plugin-raw.jsm
+++ b/devtools/shared/loader-plugin-raw.jsm
@@ -7,17 +7,17 @@
 const { NetUtil } = ChromeUtils.import("resource://gre/modules/NetUtil.jsm");
 
 /**
  * A function that can be used as part of a require hook for a
  * loader.js Loader.
  * This function handles "raw!" and "theme-loader!" requires.
  * See also: https://github.com/webpack/raw-loader.
  */
-this.requireRawId = function(id, require) {
+const requireRawId = function(id, require) {
   const index = id.indexOf("!");
   const rawId = id.slice(index + 1);
   let uri = require.resolve(rawId);
   // If the original string did not end with ".js", then
   // require.resolve might have added the suffix.  We don't want to
   // add a suffix for a raw load (if needed the caller can specify it
   // manually), so remove it here.
   if (!id.endsWith(".js") && uri.endsWith(".js")) {
@@ -35,9 +35,9 @@ this.requireRawId = function(id, require
   });
   stream.close();
 
   // For the time being it doesn't seem worthwhile to cache the
   // result here.
   return data;
 };
 
-this.EXPORTED_SYMBOLS = ["requireRawId"];
+const EXPORTED_SYMBOLS = ["requireRawId"];
diff --git a/devtools/startup/DevToolsShim.jsm b/devtools/startup/DevToolsShim.jsm
--- a/devtools/startup/DevToolsShim.jsm
+++ b/devtools/startup/DevToolsShim.jsm
@@ -25,34 +25,34 @@ XPCOMUtils.defineLazyGetter(this, "Telem
   const Telemetry = require("devtools/client/shared/telemetry");
 
   return Telemetry;
 });
 
 const DEVTOOLS_ENABLED_PREF = "devtools.enabled";
 const DEVTOOLS_POLICY_DISABLED_PREF = "devtools.policy.disabled";
 
-this.EXPORTED_SYMBOLS = ["DevToolsShim"];
+const EXPORTED_SYMBOLS = ["DevToolsShim"];
 
 function removeItem(array, callback) {
   const index = array.findIndex(callback);
   if (index >= 0) {
     array.splice(index, 1);
   }
 }
 
 /**
  * DevToolsShim is a singleton that provides a set of helpers to interact with DevTools,
  * that work whether Devtools are enabled or not.
  *
  * It can be used to start listening to devtools events before DevTools are ready. As soon
  * as DevTools are enabled, the DevToolsShim will forward all the requests received until
  * then to the real DevTools instance.
  */
-this.DevToolsShim = {
+const DevToolsShim = {
   _gDevTools: null,
   listeners: [],
 
   get telemetry() {
     if (!this._telemetry) {
       this._telemetry = new Telemetry();
       this._telemetry.setEventRecordingEnabled(true);
     }
@@ -312,17 +312,17 @@ const webExtensionsMethods = [
   "createTargetForTab",
   "createWebExtensionInspectedWindowFront",
   "getTargetForTab",
   "getTheme",
   "openBrowserConsole",
 ];
 
 for (const method of webExtensionsMethods) {
-  this.DevToolsShim[method] = function() {
+  DevToolsShim[method] = function() {
     if (!this.isEnabled()) {
       throw new Error(
         "Could not call a DevToolsShim webextension method ('" +
           method +
           "'): DevTools are not initialized."
       );
     }
 
