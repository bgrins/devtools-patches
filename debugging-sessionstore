# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0cf9eded35d8150796eda1f892666d0a778bd488

diff --git a/browser/components/sessionstore/content/aboutSessionRestore.js b/browser/components/sessionstore/content/aboutSessionRestore.js
--- a/browser/components/sessionstore/content/aboutSessionRestore.js
+++ b/browser/components/sessionstore/content/aboutSessionRestore.js
@@ -63,16 +63,17 @@ window.onload = function() {
 
   var errorTryAgainButton = document.getElementById("errorTryAgain");
   errorTryAgainButton.addEventListener("command", restoreSession);
 
   // the crashed session state is kept inside a textbox so that SessionStore picks it up
   // (for when the tab is closed or the session crashes right again)
   var sessionData = document.getElementById("sessionData");
   if (!sessionData.value) {
+    console.log("Fail");
     errorTryAgainButton.disabled = true;
     return;
   }
 
   gStateObject = JSON.parse(sessionData.value);
 
   // make sure the data is tracked to be restored in case of a subsequent crash
   var event = document.createEvent("UIEvents");
diff --git a/toolkit/components/sessionstore/SessionStoreUtils.cpp b/toolkit/components/sessionstore/SessionStoreUtils.cpp
--- a/toolkit/components/sessionstore/SessionStoreUtils.cpp
+++ b/toolkit/components/sessionstore/SessionStoreUtils.cpp
@@ -478,16 +478,17 @@ static void AppendValueToCollectedData(D
                                        Nullable<CollectedData>& aRetVal) {
   if (!aId.IsEmpty()) {
     // We want to avoid saving data for about:sessionrestore as a string.
     // Since it's stored in the form as stringified JSON, stringifying
     // further causes an explosion of escape characters. cf. bug 467409
     if (aId.EqualsLiteral("sessionData")) {
       nsAutoCString url;
       Unused << aDocument.GetDocumentURI()->GetSpecIgnoringRef(url);
+      printf("AppendValueToCollectedData: %s\n", url.get());
       if (url.EqualsLiteral("about:sessionrestore") ||
           url.EqualsLiteral("about:welcomeback")) {
         JS::Rooted<JS::Value> jsval(aCx);
         if (JS_ParseJSON(aCx, aValue.get(), aValue.Length(), &jsval) &&
             jsval.isObject()) {
           Record<nsString, OwningStringOrBooleanOrObject>::EntryType* entry =
               AppendEntryToCollectedData(aNode, aId, aGeneratedCount, aRetVal);
           entry->mValue.SetAsObject() = &jsval.toObject();
