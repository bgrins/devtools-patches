# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  0548263bba74748823aa05551fc2a38cce4dfd46
Bug 1363288 - Console.time() prints a warning if used twice with the same label, r?bgrins

diff --git a/devtools/client/locales/en-US/webconsole.properties b/devtools/client/locales/en-US/webconsole.properties
--- a/devtools/client/locales/en-US/webconsole.properties
+++ b/devtools/client/locales/en-US/webconsole.properties
@@ -90,16 +90,18 @@ noCounterLabel=<no label>
 # console.group messages with no label provided.
 noGroupLabel=<no group label>
 
 # LOCALIZATION NOTE (Autocomplete.blank): this string is used when inputnode
 # string containing anchor doesn't matches to any property in the content.
 Autocomplete.blank=  <- no result
 
 maxTimersExceeded=The maximum allowed number of timers in this page was exceeded.
+timerAlreadyExists=Timer %S already exists.
+timerJSError=Failed to process the timer name.
 
 # LOCALIZATION NOTE (maxCountersExceeded): Error message shown when the maximum
 # number of console.count()-counters was exceeded.
 maxCountersExceeded=The maximum allowed number of counters in this page was exceeded.
 
 # LOCALIZATION NOTE (longStringEllipsis): the string displayed after a long
 # string. This string is clickable such that the rest of the string is
 # retrieved from the server.
diff --git a/devtools/client/webconsole/new-console-output/utils/messages.js b/devtools/client/webconsole/new-console-output/utils/messages.js
--- a/devtools/client/webconsole/new-console-output/utils/messages.js
+++ b/devtools/client/webconsole/new-console-output/utils/messages.js
@@ -60,19 +60,24 @@ function transformPacket(packet) {
           // Chrome RDP doesn't have a special type for count.
           type = MESSAGE_TYPE.LOG;
           let {counter} = message;
           let label = counter.label ? counter.label : l10n.getStr("noCounterLabel");
           messageText = `${label}: ${counter.count}`;
           parameters = null;
           break;
         case "time":
-          // We don't show anything for console.time calls to match Chrome's behaviour.
           parameters = null;
-          type = MESSAGE_TYPE.NULL_MESSAGE;
+          if (timer && timer.error) {
+            messageText = l10n.getFormatStr(timer.error, [timer.name]);
+            level = MESSAGE_LEVEL.WARN;
+          } else {
+            // We don't show anything for console.time calls to match Chrome's behaviour.
+            type = MESSAGE_TYPE.NULL_MESSAGE;
+          }
           break;
         case "timeEnd":
           parameters = null;
           if (timer) {
             // We show the duration to users when calls console.timeEnd() is called,
             // if corresponding console.time() was called before.
             let duration = Math.round(timer.duration * 100) / 100;
             messageText = l10n.getFormatStr("timeEnd", [timer.name, duration]);
diff --git a/devtools/client/webconsole/webconsole.js b/devtools/client/webconsole/webconsole.js
--- a/devtools/client/webconsole/webconsole.js
+++ b/devtools/client/webconsole/webconsole.js
@@ -1344,17 +1344,18 @@ WebConsoleFrame.prototype = {
         break;
 
       case "time": {
         let timer = message.timer;
         if (!timer) {
           return null;
         }
         if (timer.error) {
-          console.error(new Error(l10n.getStr(timer.error)));
+          console.error(new Error(l10n.getFormatStr(timer.error,
+                                                    [timer.name])));
           return null;
         }
         body = l10n.getFormatStr("timerStarted", [timer.name]);
         clipboardText = body;
         break;
       }
 
       case "timeEnd": {
diff --git a/dom/console/Console.cpp b/dom/console/Console.cpp
--- a/dom/console/Console.cpp
+++ b/dom/console/Console.cpp
@@ -85,17 +85,17 @@ class ConsoleCallData final
 {
 public:
   NS_INLINE_DECL_REFCOUNTING(ConsoleCallData)
 
   ConsoleCallData()
     : mMethodName(Console::MethodLog)
     , mTimeStamp(JS_Now() / PR_USEC_PER_MSEC)
     , mStartTimerValue(0)
-    , mStartTimerStatus(false)
+    , mStartTimerStatus(Console::eTimerUnknown)
     , mStopTimerDuration(0)
     , mStopTimerStatus(false)
     , mCountValue(MAX_PAGE_COUNTERS)
     , mIDType(eUnknown)
     , mOuterIDNumber(0)
     , mInnerIDNumber(0)
     , mStatus(eUnused)
   {}
@@ -212,17 +212,17 @@ public:
   // creation of it. If status is false, something went wrong. User
   // DOMHighResTimeStamp instead mozilla::TimeStamp because we use
   // monotonicTimer from Performance.now();
   // They will be set on the owning thread and never touched again on that
   // thread. They will be used in order to create a ConsoleTimerStart dictionary
   // when console.time() is used.
   DOMHighResTimeStamp mStartTimerValue;
   nsString mStartTimerLabel;
-  bool mStartTimerStatus;
+  Console::StartTimerStatus mStartTimerStatus;
 
   // These values are set in the owning thread and they contain the duration,
   // the name and the status of the StopTimer method. If status is false,
   // something went wrong. They will be set on the owning thread and never
   // touched again on that thread. They will be used in order to create a
   // ConsoleTimerEnd dictionary. This members are set when
   // console.timeEnd() is called.
   double mStopTimerDuration;
@@ -2001,61 +2001,90 @@ Console::UnstoreGroupName(nsAString& aNa
   }
 
   uint32_t pos = mGroupStack.Length() - 1;
   aName = mGroupStack[pos];
   mGroupStack.RemoveElementAt(pos);
   return true;
 }
 
-bool
+Console::StartTimerStatus
 Console::StartTimer(JSContext* aCx, const JS::Value& aName,
                     DOMHighResTimeStamp aTimestamp,
                     nsAString& aTimerLabel,
                     DOMHighResTimeStamp* aTimerValue)
 {
   AssertIsOnOwningThread();
   MOZ_ASSERT(aTimerValue);
 
   *aTimerValue = 0;
 
   if (NS_WARN_IF(mTimerRegistry.Count() >= MAX_PAGE_TIMERS)) {
-    return false;
+    return eTimerMaxReached;
   }
 
   JS::Rooted<JS::Value> name(aCx, aName);
   JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, name));
   if (NS_WARN_IF(!jsString)) {
-    return false;
+    return eTimerJSException;
   }
 
   nsAutoJSString label;
   if (NS_WARN_IF(!label.init(aCx, jsString))) {
-    return false;
+    return eTimerJSException;
   }
 
+  aTimerLabel = label;
+
   DOMHighResTimeStamp entry = 0;
-  if (!mTimerRegistry.Get(label, &entry)) {
-    mTimerRegistry.Put(label, aTimestamp);
-  } else {
-    aTimestamp = entry;
+  if (mTimerRegistry.Get(label, &entry)) {
+    return eTimerAlreadyExists;
   }
 
-  aTimerLabel = label;
+  mTimerRegistry.Put(label, aTimestamp);
+
   *aTimerValue = aTimestamp;
-  return true;
+  return eTimerStarted;
+}
+
+void
+Console::StartTimerStatusToError(StartTimerStatus aStatus,
+                                 ConsoleTimerError& aError) const
+{
+  switch (aStatus) {
+  case eTimerAlreadyExists:
+    aError.mError.AssignLiteral("timerAlreadyExists");
+    break;
+
+  case eTimerJSException:
+    aError.mError.AssignLiteral("timerJSError");
+    break;
+
+  case eTimerMaxReached:
+    aError.mError.AssignLiteral("maxTimersExceeded");
+    break;
+
+  default:
+    MOZ_CRASH("Unsupported status");
+    break;
+  }
 }
 
 JS::Value
 Console::CreateStartTimerValue(JSContext* aCx, const nsAString& aTimerLabel,
-                               bool aTimerStatus) const
+                               StartTimerStatus aTimerStatus) const
 {
-  if (!aTimerStatus) {
+  MOZ_ASSERT(aTimerStatus != eTimerUnknown);
+
+  if (aTimerStatus != eTimerStarted) {
     RootedDictionary<ConsoleTimerError> error(aCx);
 
+    error.mName = aTimerLabel;
+    StartTimerStatusToError(aTimerStatus, error);
+
     JS::Rooted<JS::Value> value(aCx);
     if (!ToJSValue(aCx, error, &value)) {
       return JS::UndefinedValue();
     }
 
     return value;
   }
 
diff --git a/dom/console/Console.h b/dom/console/Console.h
--- a/dom/console/Console.h
+++ b/dom/console/Console.h
@@ -24,16 +24,17 @@ class nsIPrincipal;
 namespace mozilla {
 namespace dom {
 
 class AnyCallback;
 class ConsoleCallData;
 class ConsoleRunnable;
 class ConsoleCallDataRunnable;
 class ConsoleProfileRunnable;
+struct ConsoleTimerError;
 struct ConsoleStackEntry;
 
 class Console final : public nsIObserver
                     , public nsSupportsWeakReference
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(Console, nsIObserver)
@@ -257,43 +258,54 @@ private:
   ComposeAndStoreGroupName(JSContext* aCx, const Sequence<JS::Value>& aData,
                            nsAString& aName);
 
   // Remove the last group name and return that name. It returns false if
   // mGroupStack is empty.
   bool
   UnstoreGroupName(nsAString& aName);
 
+  enum StartTimerStatus {
+    eTimerUnknown,
+    eTimerStarted,
+    eTimerAlreadyExists,
+    eTimerJSException,
+    eTimerMaxReached,
+  };
+
   // StartTimer is called on the owning thread and populates aTimerLabel and
-  // aTimerValue. It returns false if a JS exception is thrown or if
-  // the max number of timers is reached.
+  // aTimerValue.
   // * aCx - the JSContext rooting aName.
   // * aName - this is (should be) the name of the timer as JS::Value.
   // * aTimestamp - the monotonicTimer for this context taken from
   //                performance.now().
   // * aTimerLabel - This label will be populated with the aName converted to a
   //                 string.
   // * aTimerValue - the StartTimer value stored into (or taken from)
   //                 mTimerRegistry.
-  bool
+  StartTimerStatus
   StartTimer(JSContext* aCx, const JS::Value& aName,
              DOMHighResTimeStamp aTimestamp,
              nsAString& aTimerLabel,
              DOMHighResTimeStamp* aTimerValue);
 
   // CreateStartTimerValue generates a ConsoleTimerStart dictionary exposed as
   // JS::Value. If aTimerStatus is false, it generates a ConsoleTimerError
   // instead. It's called only after the execution StartTimer on the owning
   // thread.
   // * aCx - this is the context that will root the returned value.
   // * aTimerLabel - this label must be what StartTimer received as aTimerLabel.
   // * aTimerStatus - the return value of StartTimer.
   JS::Value
   CreateStartTimerValue(JSContext* aCx, const nsAString& aTimerLabel,
-                        bool aTimerStatus) const;
+                        StartTimerStatus aTimerStatus) const;
+
+  void
+  StartTimerStatusToError(StartTimerStatus aStatus,
+                          ConsoleTimerError& aError) const;
 
   // StopTimer follows the same pattern as StartTimer: it runs on the
   // owning thread and populates aTimerLabel and aTimerDuration, used by
   // CreateStopTimerValue. It returns false if a JS exception is thrown or if
   // the aName timer doesn't exist in the mTimerRegistry.
   // * aCx - the JSContext rooting aName.
   // * aName - this is (should be) the name of the timer as JS::Value.
   // * aTimestamp - the monotonicTimer for this context taken from
diff --git a/dom/webidl/Console.webidl b/dom/webidl/Console.webidl
--- a/dom/webidl/Console.webidl
+++ b/dom/webidl/Console.webidl
@@ -102,17 +102,18 @@ dictionary ConsoleTimerStart {
 };
 
 dictionary ConsoleTimerEnd {
   DOMString name = "";
   double duration = 0;
 };
 
 dictionary ConsoleTimerError {
-  DOMString error = "maxTimersExceeded";
+  DOMString error = "";
+  DOMString name = "";
 };
 
 dictionary ConsoleCounter {
   DOMString label = "";
   unsigned long count = 0;
 };
 
 dictionary ConsoleCounterError {
