# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  d2f9df3de68759a6b1f0139302f5588cee646190

diff --git a/browser/components/places/content/places-menupopup.js b/browser/components/places/content/places-menupopup.js
--- a/browser/components/places/content/places-menupopup.js
+++ b/browser/components/places/content/places-menupopup.js
@@ -25,32 +25,35 @@
         "drop",
         "dragover",
         "dragexit",
         "dragend",
       ];
       for (let event_name of event_names) {
         this.addEventListener(event_name, ev => this[`on_${event_name}`](ev));
       }
-
-      this._indicatorBar = this.shadowRoot.querySelector(
-        "[part=drop-indicator-bar]"
-      );
-      this._scrollBox = this.shadowRoot.querySelector(".popup-internal-box");
     }
 
     get fragment() {
       if (!this.constructor.hasOwnProperty("_fragment")) {
         this.constructor._fragment = MozXULElement.parseXULToFragment(
           this.markup
         );
       }
       return document.importNode(this.constructor._fragment, true);
     }
 
+    get _indicatorBar() {
+      return this.shadowRoot.querySelector("[part=drop-indicator-bar]");
+    }
+
+    get _scrollBox() {
+      return this.shadowRoot.querySelector(".popup-internal-box");
+    }
+
     get markup() {
       return `
       <html:link rel="stylesheet" href="chrome://global/skin/global.css" />
       <hbox flex="1" part="innerbox">
         <vbox part="drop-indicator-bar" hidden="true">
           <image part="drop-indicator" mousethrough="always"></image>
         </vbox>
         <arrowscrollbox class="popup-internal-box" flex="1" orient="vertical"
diff --git a/toolkit/content/widgets/menupopup.js b/toolkit/content/widgets/menupopup.js
--- a/toolkit/content/widgets/menupopup.js
+++ b/toolkit/content/widgets/menupopup.js
@@ -17,17 +17,21 @@
 
       this.AUTOSCROLL_INTERVAL = 25;
       this.NOT_DRAGGING = 0;
       this.DRAG_OVER_BUTTON = -1;
       this.DRAG_OVER_POPUP = 1;
       this._draggingState = this.NOT_DRAGGING;
       this._scrollTimer = 0;
 
+      // We intentionally don't attach the shadow root here because there are a
+      // ton of menupopups that get constructed at startup. Instead we wait until
+      // the popup is going to be visible and call render() then.
       this.addEventListener("popupshowing", event => {
+        this.shadowRoot; // This forces the shadowRoot to get attached (see the getter)
         let array = [];
         let width = 0;
         for (
           let menuitem = this.firstElementChild;
           menuitem;
           menuitem = menuitem.nextElementSibling
         ) {
           if (
@@ -40,32 +44,32 @@
               if (accel.boxObject.width > width) {
                 width = accel.boxObject.width;
               }
             }
           }
         }
         array.forEach(accel => (accel.width = width));
       });
-
-      this.attachShadow({ mode: "open" });
-      this.shadowRoot.appendChild(this.fragment);
-
-      this.scrollBox = this.shadowRoot.querySelector(".popup-internal-box");
+    }
 
-      // Retarget events from shadow DOM scrolbox to the popup itself.
-      this.scrollBox.addEventListener("scroll", ev =>
-        this.dispatchEvent(new Event("scroll"))
-      );
-      this.scrollBox.addEventListener("overflow", ev =>
-        this.dispatchEvent(new Event("overflow"))
-      );
-      this.scrollBox.addEventListener("underflow", ev =>
-        this.dispatchEvent(new Event("underflow"))
-      );
+    // We want to lazily attach the shadow root until the popup is going
+    // to be visible or until some code accesses it. By overriding the getter
+    // we can handle the second case without remembering to call .render()
+    // everywhere that wants to access the root:
+    get shadowRoot() {
+      if (!super.shadowRoot) {
+        this.attachShadow({ mode: "open" });
+        this.shadowRoot.appendChild(this.fragment);
+      }
+      return super.shadowRoot;
+    }
+
+    get scrollBox() {
+      return this.shadowRoot.querySelector(".popup-internal-box");
     }
 
     connectedCallback() {
       if (this.delayConnectedCallback() || this.hasConnected) {
         return;
       }
 
       this.hasConnected = true;
@@ -84,16 +88,19 @@
     }
 
     get markup() {
       return `
         <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
         <html:style>${this.styles}</html:style>
         <arrowscrollbox class="popup-internal-box"
                         flex="1"
+                        onoverflow="this.parentNode.host.dispatchEvent(new Event('overflow'));"
+                        onunderflow="this.parentNode.host.dispatchEvent(new Event('underflow'));"
+                        onscroll="this.parentNode.host.dispatchEvent(new Event('scroll'));"
                         orient="vertical"
                         smoothscroll="false">
           <html:slot></html:slot>
         </arrowscrollbox>
       `;
     }
 
     get styles() {
