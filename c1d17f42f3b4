
# HG changeset patch
# User Alexander Surkov <surkov.alexander@gmail.com>
# Date 1549312132 18000
# Node ID c1d17f42f3b4dc0b08056dbb29854bfbb23294c3
# Parent  b5e6469c172ea421230dae45e944c819ae2f3a13
Bug 1525101 - convert autocomplete-rich-result-popup into CE, r=bgrins

Differential Revision: https://phabricator.services.mozilla.com/D20506

diff --git a/accessible/tests/mochitest/events/test_focus_autocomplete.xul b/accessible/tests/mochitest/events/test_focus_autocomplete.xul
--- a/accessible/tests/mochitest/events/test_focus_autocomplete.xul
+++ b/accessible/tests/mochitest/events/test_focus_autocomplete.xul
@@ -492,17 +492,20 @@
 
     <vbox flex="1">
       <textbox id="autocomplete" type="autocomplete"
                autocompletesearch="test-a11y-search"/>
 
       <textbox id="richautocomplete" type="autocomplete"
                autocompletesearch="test-a11y-search"
                autocompletepopup="richpopup"/>
-      <panel id="richpopup" type="autocomplete-richlistbox" noautofocus="true"/>
+      <panel is="autocomplete-richlistbox-popup"
+             id="richpopup"
+             type="autocomplete-richlistbox"
+             noautofocus="true"/>
 
       <iframe id="iframe"/>
 
       <iframe id="iframe2"/>
 
       <searchbar id="searchbar"/>
 
       <vbox id="eventdump"/>
diff --git a/accessible/tests/mochitest/tree/test_txtctrl.xul b/accessible/tests/mochitest/tree/test_txtctrl.xul
--- a/accessible/tests/mochitest/tree/test_txtctrl.xul
+++ b/accessible/tests/mochitest/tree/test_txtctrl.xul
@@ -131,17 +131,17 @@
       SimpleTest.ok(txc, "Testing (New) Toolkit autocomplete widget.");
 
       // Dumb access to trigger popup lazy creation.
       dump("Trigget popup lazy creation");
       waitForEvent(EVENT_REORDER, txc, () => {
         testAccessibleTree("txc_autocomplete", accTree);
         SimpleTest.finish();
       });
-      txc.popup;
+      txc.popup.initialize();
     }
 
     SimpleTest.waitForExplicitFinish();
     addA11yLoadEvent(doTest);
   ]]>
   </script>
 
   <hbox flex="1" style="overflow: auto;">
diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -231,17 +231,18 @@ xmlns="http://www.w3.org/1999/xhtml"
                onpopupshowing="return FillHistoryMenu(event.target);"
                oncommand="gotoHistoryIndex(event); event.stopPropagation();"
                onclick="checkForMiddleClick(this, event);"/>
     <tooltip id="aHTMLTooltip" page="true"/>
     <tooltip id="remoteBrowserTooltip"/>
 
     <!-- for search and content formfill/pw manager -->
 
-    <panel type="autocomplete-richlistbox"
+    <panel is="autocomplete-richlistbox-popup"
+           type="autocomplete-richlistbox"
            id="PopupAutoComplete"
            role="group"
            noautofocus="true"
            hidden="true"
            overflowpadding="4"
            norolluponanchor="true"
            nomaxresults="true" />
 
diff --git a/browser/base/content/webext-panels.xul b/browser/base/content/webext-panels.xul
--- a/browser/base/content/webext-panels.xul
+++ b/browser/base/content/webext-panels.xul
@@ -35,17 +35,18 @@
              disabled="true"/>
     <command id="Browser:Stop" oncommand="PanelBrowserStop();"/>
     <command id="Browser:Reload" oncommand="PanelBrowserReload();"/>
   </commandset>
 
   <popupset id="mainPopupSet">
     <tooltip id="aHTMLTooltip" page="true"/>
 
-    <panel type="autocomplete-richlistbox"
+    <panel is="autocomplete-richlistbox-popup"
+           type="autocomplete-richlistbox"
            id="PopupAutoComplete"
            noautofocus="true"
            hidden="true"
            overflowpadding="4"
            norolluponanchor="true" />
 
     <menupopup id="contentAreaContextMenu" pagemenu="start"
                onpopupshowing="if (event.target != this)
diff --git a/toolkit/components/passwordmgr/test/browser/browser_autocomplete_footer.js b/toolkit/components/passwordmgr/test/browser/browser_autocomplete_footer.js
--- a/toolkit/components/passwordmgr/test/browser/browser_autocomplete_footer.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_autocomplete_footer.js
@@ -52,17 +52,17 @@ add_task(async function test_autocomplet
     // Focus the username field to open the popup.
     await ContentTask.spawn(browser, null, function openAutocomplete() {
       content.document.getElementById("form-basic-username").focus();
     });
 
     await promiseShown;
     ok(promiseShown, "autocomplete shown");
 
-    let footer = document.getAnonymousElementByAttribute(popup, "originaltype", "loginsFooter");
+    let footer = popup.querySelector(`[originaltype="loginsFooter"]`);
     ok(footer, "Got footer richlistitem");
 
     await TestUtils.waitForCondition(() => {
       return !EventUtils.isHidden(footer);
     }, "Waiting for footer to become visible");
 
     EventUtils.synthesizeMouseAtCenter(footer, {});
     await TestUtils.waitForCondition(() => {
diff --git a/toolkit/components/passwordmgr/test/browser/browser_autocomplete_insecure_warning.js b/toolkit/components/passwordmgr/test/browser/browser_autocomplete_insecure_warning.js
--- a/toolkit/components/passwordmgr/test/browser/browser_autocomplete_insecure_warning.js
+++ b/toolkit/components/passwordmgr/test/browser/browser_autocomplete_insecure_warning.js
@@ -21,17 +21,17 @@ add_task(async function test_clickInsecu
     // Focus the username field to open the popup.
     await ContentTask.spawn(browser, null, function openAutocomplete() {
       content.document.getElementById("form-basic-username").focus();
     });
 
     await promiseShown;
     ok(promiseShown, "autocomplete shown");
 
-    let warningItem = document.getAnonymousElementByAttribute(popup, "type", "insecureWarning");
+    let warningItem = popup.querySelector(`[type="insecureWarning"]`);
     ok(warningItem, "Got warning richlistitem");
 
     await BrowserTestUtils.waitForCondition(() => !warningItem.collapsed, "Wait for warning to show");
 
     info("Clicking on warning");
     let supportTabPromise = BrowserTestUtils.waitForNewTab(gBrowser, EXPECTED_SUPPORT_URL);
     EventUtils.synthesizeMouseAtCenter(warningItem, {});
     let supportTab = await supportTabPromise;
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -500,16 +500,17 @@ const isDummyDocument = document.documen
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/menu.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/popupnotification.js",
     "chrome://global/content/elements/radio.js",
     "chrome://global/content/elements/richlistbox.js",
+    "chrome://global/content/elements/autocomplete.js",
     "chrome://global/content/elements/autocomplete-richlistitem.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
     "chrome://global/content/elements/tree.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -79,16 +79,17 @@ toolkit.jar:
    content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
    content/global/bindings/text.xml            (widgets/text.xml)
    content/global/elements/text.js             (widgets/text.js)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
+   content/global/elements/autocomplete.js     (widgets/autocomplete.js)
    content/global/elements/autocomplete-richlistitem.js       (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
diff --git a/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul b/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul
--- a/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul
+++ b/toolkit/content/tests/chrome/test_autocomplete_emphasis.xul
@@ -9,17 +9,20 @@
           src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>
   <script type="application/javascript"
           src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"/>
 
 <textbox id="richautocomplete" type="autocomplete"
          autocompletesearch="simple"
          onsearchcomplete="checkSearchCompleted();"
          autocompletepopup="richpopup"/>
-<panel id="richpopup" type="autocomplete-richlistbox" noautofocus="true"/>
+<panel is="autocomplete-richlistbox-popup"
+       id="richpopup"
+       type="autocomplete-richlistbox"
+       noautofocus="true"/>
 
 <script class="testbody" type="application/javascript">
 <![CDATA[
 
 ChromeUtils.import("resource://gre/modules/Services.jsm");
 
 const ACR = Ci.nsIAutoCompleteResult;
 
diff --git a/toolkit/content/widgets/autocomplete.js b/toolkit/content/widgets/autocomplete.js
--- a/toolkit/content/widgets/autocomplete.js
+++ b/toolkit/content/widgets/autocomplete.js
@@ -1,600 +1,571 @@
-  <binding id="autocomplete-rich-result-popup" extends="chrome://global/content/bindings/popup.xml#popup">
-    <content ignorekeys="true" level="top" consumeoutsideclicks="never">
-      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox" flex="1"/>
-      <xul:hbox>
-        <children/>
-      </xul:hbox>
-    </content>
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+const MozPopupElement = MozElementMixin(XULPopupElement);
+MozElements.MozAutocompleteRichlistboxPopup = class MozAutocompleteRichlistboxPopup extends MozPopupElement {
+  constructor() {
+    super();
+
+    this.mInput = null;
+    this.mPopupOpen = false;
+    this._currentIndex = 0;
+
+    this.addEventListener("popupshowing", (event) => {
+      // If normalMaxRows wasn't already set by the input, then set it here
+      // so that we restore the correct number when the popup is hidden.
+
+      // Null-check this.mInput; see bug 1017914
+      if (this._normalMaxRows < 0 && this.mInput) {
+        this._normalMaxRows = this.mInput.maxRows;
+      }
+
+      // Set an attribute for styling the popup based on the input.
+      let inputID = "";
+      if (this.mInput && this.mInput.ownerDocument &&
+        this.mInput.ownerDocument.documentURIObject.schemeIs("chrome")) {
+        inputID = this.mInput.id;
+        // Take care of elements with no id that are inside xbl bindings
+        if (!inputID) {
+          let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);
+          if (bindingParent) {
+            inputID = bindingParent.id;
+          }
+        }
+      }
+      this.setAttribute("autocompleteinput", inputID);
+
+      this.mPopupOpen = true;
+    });
+
+    this.addEventListener("popupshown", (event) => {
+       if (this._adjustHeightOnPopupShown) {
+        delete this._adjustHeightOnPopupShown;
+        this.adjustHeight();
+      }
+    });
+
+    this.addEventListener("popuphiding", (event) => {
+      var isListActive = true;
+      if (this.selectedIndex == -1)
+        isListActive = false;
+      this.input.controller.stopSearch();
+
+      this.removeAttribute("autocompleteinput");
+      this.mPopupOpen = false;
+
+      // Reset the maxRows property to the cached "normal" value (if there's
+      // any), and reset normalMaxRows so that we can detect whether it was set
+      // by the input when the popupshowing handler runs.
 
-    <implementation implements="nsIAutoCompletePopup">
-      <field name="mInput">null</field>
-      <field name="mPopupOpen">false</field>
-      <field name="_currentIndex">0</field>
+      // Null-check this.mInput; see bug 1017914
+      if (this.mInput && this._normalMaxRows > 0) {
+        this.mInput.maxRows = this._normalMaxRows;
+      }
+      this._normalMaxRows = -1;
+      // If the list was being navigated and then closed, make sure
+      // we fire accessible focus event back to textbox
+
+      // Null-check this.mInput; see bug 1017914
+      if (isListActive && this.mInput) {
+        this.mInput.mIgnoreFocus = true;
+        this.mInput._focus();
+        this.mInput.mIgnoreFocus = false;
+      }
+    });
+  }
+
+  initialize() {
+    this.setAttribute("ignorekeys", "true");
+    this.setAttribute("level", "top");
+    this.setAttribute("consumeoutsideclicks", "never");
+
+    this.textContent = "";
+    this.appendChild(MozXULElement.parseXULToFragment(this._markup));
+
+    /**
+     * This is the default number of rows that we give the autocomplete
+     * popup when the textbox doesn't have a "maxrows" attribute
+     * for us to use.
+     */
+    this.defaultMaxRows = 6;
 
-      <constructor><![CDATA[
-        if (!this.listEvents) {
-          this.listEvents = {
-            handleEvent: event => {
-              if (!this.parentNode) {
+    /**
+     * In some cases (e.g. when the input's dropmarker button is clicked),
+     * the input wants to display a popup with more rows. In that case, it
+     * should increase its maxRows property and store the "normal" maxRows
+     * in this field. When the popup is hidden, we restore the input's
+     * maxRows to the value stored in this field.
+     *
+     * This field is set to -1 between uses so that we can tell when it's
+     * been set by the input and when we need to set it in the popupshowing
+     * handler.
+     */
+    this._normalMaxRows = -1;
+    this._previousSelectedIndex = -1;
+    this.mLastMoveTime = Date.now();
+    this.mousedOverIndex = -1;
+    this._richlistbox = this.querySelector(".autocomplete-richlistbox");
+
+    if (!this.listEvents) {
+      this.listEvents = {
+        handleEvent: event => {
+          if (!this.parentNode) {
+            return;
+          }
+
+          switch (event.type) {
+            case "mouseup":
+              // Don't call onPopupClick for the scrollbar buttons, thumb,
+              // slider, etc. If we hit the richlistbox and not a
+              // richlistitem, we ignore the event.
+              if (event.target.closest("richlistbox,richlistitem")
+                .localName == "richlistitem") {
+                this.onPopupClick(event);
+              }
+              break;
+            case "mousemove":
+              if (Date.now() - this.mLastMoveTime <= 30) {
+                return;
+              }
+
+              let item = event.target.closest("richlistbox,richlistitem");
+
+              // If we hit the richlistbox and not a richlistitem, we ignore
+              // the event.
+              if (item.localName == "richlistbox") {
                 return;
               }
 
-              switch (event.type) {
-                case "mouseup":
-                  // Don't call onPopupClick for the scrollbar buttons, thumb,
-                  // slider, etc. If we hit the richlistbox and not a
-                  // richlistitem, we ignore the event.
-                  if (event.target.closest("richlistbox,richlistitem")
-                                  .localName == "richlistitem") {
-                    this.onPopupClick(event);
-                  }
-                  break;
-                case "mousemove":
-                  if (Date.now() - this.mLastMoveTime <= 30) {
-                    return;
-                  }
-
-                  let item = event.target.closest("richlistbox,richlistitem");
-
-                  // If we hit the richlistbox and not a richlistitem, we ignore
-                  // the event.
-                  if (item.localName == "richlistbox") {
-                    return;
-                  }
-
-                  let index = this.richlistbox.getIndexOfItem(item);
-
-                  this.mousedOverIndex = index;
+              let index = this.richlistbox.getIndexOfItem(item);
 
-                  if (item.selectedByMouseOver) {
-                    this.richlistbox.selectedIndex = index;
-                  }
-
-                  this.mLastMoveTime = Date.now();
-                  break;
-              }
-            },
-          };
-          this.richlistbox.addEventListener("mouseup", this.listEvents);
-          this.richlistbox.addEventListener("mousemove", this.listEvents);
-        }
-      ]]></constructor>
-
-      <destructor><![CDATA[
-        if (this.listEvents) {
-          this.richlistbox.removeEventListener("mouseup", this.listEvents);
-          this.richlistbox.removeEventListener("mousemove", this.listEvents);
-          delete this.listEvents;
-        }
-      ]]></destructor>
-
-      <!-- =================== nsIAutoCompletePopup =================== -->
-
-      <property name="input" readonly="true"
-                onget="return this.mInput"/>
-
-      <property name="overrideValue" readonly="true"
-                onget="return null;"/>
-
-      <property name="popupOpen" readonly="true"
-                onget="return this.mPopupOpen;"/>
+              this.mousedOverIndex = index;
 
-      <method name="closePopup">
-        <body>
-          <![CDATA[
-          if (this.mPopupOpen) {
-            this.hidePopup();
-            this.removeAttribute("width");
-          }
-        ]]>
-        </body>
-      </method>
-
-      <!-- This is the default number of rows that we give the autocomplete
-           popup when the textbox doesn't have a "maxrows" attribute
-           for us to use. -->
-      <field name="defaultMaxRows" readonly="true">6</field>
-
-      <!-- In some cases (e.g. when the input's dropmarker button is clicked),
-           the input wants to display a popup with more rows. In that case, it
-           should increase its maxRows property and store the "normal" maxRows
-           in this field. When the popup is hidden, we restore the input's
-           maxRows to the value stored in this field.
-
-           This field is set to -1 between uses so that we can tell when it's
-           been set by the input and when we need to set it in the popupshowing
-           handler. -->
-      <field name="_normalMaxRows">-1</field>
-
-      <property name="maxRows" readonly="true">
-        <getter>
-          <![CDATA[
-          return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;
-        ]]>
-        </getter>
-      </property>
+              if (item.selectedByMouseOver) {
+                this.richlistbox.selectedIndex = index;
+              }
 
-      <method name="getNextIndex">
-        <parameter name="aReverse"/>
-        <parameter name="aAmount"/>
-        <parameter name="aIndex"/>
-        <parameter name="aMaxRow"/>
-        <body><![CDATA[
-          if (aMaxRow < 0)
-            return -1;
-
-          var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;
-          if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)
-            newIdx = aMaxRow;
-          else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)
-            newIdx = 0;
-
-          if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)
-            aIndex = -1;
-          else
-            aIndex = newIdx;
-
-          return aIndex;
-        ]]></body>
-      </method>
-
-      <method name="onPopupClick">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          this.input.controller.handleEnter(true, aEvent);
-        ]]></body>
-      </method>
-
-      <property name="selectedIndex"
-                onget="return this.richlistbox.selectedIndex;">
-        <setter>
-          <![CDATA[
-          if (val != this.richlistbox.selectedIndex) {
-            this._previousSelectedIndex = this.richlistbox.selectedIndex;
+              this.mLastMoveTime = Date.now();
+              break;
           }
-          this.richlistbox.selectedIndex = val;
-          // Since ensureElementIsVisible may cause an expensive Layout flush,
-          // invoke it only if there may be a scrollbar, so if we could fetch
-          // more results than we can show at once.
-          // maxResults is the maximum number of fetched results, maxRows is the
-          // maximum number of rows we show at once, without a scrollbar.
-          if (this.mPopupOpen && this.maxResults > this.maxRows) {
-            // when clearing the selection (val == -1, so selectedItem will be
-            // null), we want to scroll back to the top.  see bug #406194
-            this.richlistbox.ensureElementIsVisible(
-              this.richlistbox.selectedItem || this.richlistbox.firstElementChild);
-          }
-          return val;
-        ]]>
-        </setter>
-      </property>
+        },
+      };
+      this.richlistbox.addEventListener("mouseup", this.listEvents);
+      this.richlistbox.addEventListener("mousemove", this.listEvents);
+    }
+  }
+
+  get richlistbox() {
+    if (!this._richlistbox) {
+      this.initialize();
+    }
+    return this._richlistbox;
+  }
 
-      <field name="_previousSelectedIndex">-1</field>
-      <field name="mLastMoveTime">Date.now()</field>
-      <field name="mousedOverIndex">-1</field>
+  get _markup() {
+    return `
+      <richlistbox class="autocomplete-richlistbox" flex="1"></richlistbox>
+    `;
+  }
 
-      <method name="onSearchBegin">
-        <body><![CDATA[
-          this.mousedOverIndex = -1;
+  /**
+   * nsIAutoCompletePopup
+   */
+  get input() {
+    return this.mInput;
+  }
 
-          if (typeof this._onSearchBegin == "function") {
-            this._onSearchBegin();
-          }
-        ]]></body>
-      </method>
+  get overrideValue() {
+    return null;
+  }
+
+  get popupOpen() {
+    return this.mPopupOpen;
+  }
+
+  get maxRows() {
+    return (this.mInput && this.mInput.maxRows) || this.defaultMaxRows;
+  }
 
-      <method name="openAutocompletePopup">
-        <parameter name="aInput"/>
-        <parameter name="aElement"/>
-        <body>
-          <![CDATA[
-          // until we have "baseBinding", (see bug #373652) this allows
-          // us to override openAutocompletePopup(), but still call
-          // the method on the base class
-          this._openAutocompletePopup(aInput, aElement);
-        ]]>
-        </body>
-      </method>
+  set selectedIndex(val) {
+    if (val != this.richlistbox.selectedIndex) {
+      this._previousSelectedIndex = this.richlistbox.selectedIndex;
+    }
+    this.richlistbox.selectedIndex = val;
+    // Since ensureElementIsVisible may cause an expensive Layout flush,
+    // invoke it only if there may be a scrollbar, so if we could fetch
+    // more results than we can show at once.
+    // maxResults is the maximum number of fetched results, maxRows is the
+    // maximum number of rows we show at once, without a scrollbar.
+    if (this.mPopupOpen && this.maxResults > this.maxRows) {
+      // when clearing the selection (val == -1, so selectedItem will be
+      // null), we want to scroll back to the top.  see bug #406194
+      this.richlistbox.ensureElementIsVisible(
+        this.richlistbox.selectedItem || this.richlistbox.firstElementChild);
+    }
+    return val;
+  }
+
+  get selectedIndex() {
+    return this.richlistbox.selectedIndex;
+  }
 
-      <method name="_openAutocompletePopup">
-        <parameter name="aInput"/>
-        <parameter name="aElement"/>
-        <body>
-          <![CDATA[
-          if (!this.mPopupOpen) {
-            // It's possible that the panel is hidden initially
-            // to avoid impacting startup / new window performance
-            aInput.popup.hidden = false;
+  get maxResults() {
+    // This is how many richlistitems will be kept around.
+    // Note, this getter may be overridden, or instances
+    // can have the nomaxresults attribute set to have no
+    // limit.
+    if (this.getAttribute("nomaxresults") == "true") {
+      return Infinity;
+    }
+    return 20;
+  }
+
+  get matchCount() {
+    return Math.min(this.mInput.controller.matchCount, this.maxResults);
+  }
+
+  get overflowPadding() {
+    return Number(this.getAttribute("overflowpadding"));
+  }
 
-            this.mInput = aInput;
-            // clear any previous selection, see bugs 400671 and 488357
-            this.selectedIndex = -1;
+  set view(val) {
+    return val;
+  }
+
+  get view() {
+    return this.mInput.controller;
+  }
 
-            var width = aElement.getBoundingClientRect().width;
-            this.setAttribute("width", width > 100 ? width : 100);
-            // invalidate() depends on the width attribute
-            this._invalidate();
+  closePopup() {
+    if (this.mPopupOpen) {
+      this.hidePopup();
+      this.removeAttribute("width");
+    }
+  }
 
-            this.openPopup(aElement, "after_start", 0, 0, false, false);
-          }
-        ]]>
-        </body>
-      </method>
+  getNextIndex(aReverse, aAmount, aIndex, aMaxRow) {
+    if (aMaxRow < 0)
+      return -1;
 
-      <method name="invalidate">
-        <parameter name="reason"/>
-        <body>
-          <![CDATA[
-          // Don't bother doing work if we're not even showing
-          if (!this.mPopupOpen)
-            return;
+    var newIdx = aIndex + (aReverse ? -1 : 1) * aAmount;
+    if (aReverse && aIndex == -1 || newIdx > aMaxRow && aIndex != aMaxRow)
+      newIdx = aMaxRow;
+    else if (!aReverse && aIndex == -1 || newIdx < 0 && aIndex != 0)
+      newIdx = 0;
 
-          this._invalidate(reason);
-          ]]>
-        </body>
-      </method>
+    if (newIdx < 0 && aIndex == 0 || newIdx > aMaxRow && aIndex == aMaxRow)
+      aIndex = -1;
+    else
+      aIndex = newIdx;
+
+    return aIndex;
+  }
+
+  onPopupClick(aEvent) {
+    this.input.controller.handleEnter(true, aEvent);
+  }
+
+  onSearchBegin() {
+    this.mousedOverIndex = -1;
 
-      <method name="_invalidate">
-        <parameter name="reason"/>
-        <body>
-          <![CDATA[
-          // collapsed if no matches
-          this.richlistbox.collapsed = (this.matchCount == 0);
+    if (typeof this._onSearchBegin == "function") {
+      this._onSearchBegin();
+    }
+  }
+
+  openAutocompletePopup(aInput, aElement) {
+    // until we have "baseBinding", (see bug #373652) this allows
+    // us to override openAutocompletePopup(), but still call
+    // the method on the base class
+    this._openAutocompletePopup(aInput, aElement);
+  }
 
-          // Update the richlistbox height.
-          if (this._adjustHeightRAFToken) {
-            cancelAnimationFrame(this._adjustHeightRAFToken);
-            this._adjustHeightRAFToken = null;
-          }
+  _openAutocompletePopup(aInput, aElement) {
+    if (!this._initialized) {
+      this.initialize();
+      this._initialized = true;
+    }
 
-          if (this.mPopupOpen) {
-            delete this._adjustHeightOnPopupShown;
-            this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());
-          } else {
-            this._adjustHeightOnPopupShown = true;
-          }
+    if (!this.mPopupOpen) {
+      // It's possible that the panel is hidden initially
+      // to avoid impacting startup / new window performance
+      aInput.popup.hidden = false;
+
+      this.mInput = aInput;
+      // clear any previous selection, see bugs 400671 and 488357
+      this.selectedIndex = -1;
 
-          this._currentIndex = 0;
-          if (this._appendResultTimeout) {
-            clearTimeout(this._appendResultTimeout);
-          }
-          this._appendCurrentResult(reason);
-        ]]>
-        </body>
-      </method>
+      var width = aElement.getBoundingClientRect().width;
+      this.setAttribute("width", width > 100 ? width : 100);
+      // invalidate() depends on the width attribute
+      this._invalidate();
+
+      this.openPopup(aElement, "after_start", 0, 0, false, false);
+    }
+  }
 
-      <property name="maxResults" readonly="true">
-        <getter>
-          <![CDATA[
-            // This is how many richlistitems will be kept around.
-            // Note, this getter may be overridden, or instances
-            // can have the nomaxresults attribute set to have no
-            // limit.
-            if (this.getAttribute("nomaxresults") == "true") {
-              return Infinity;
-            }
+  invalidate(reason) {
+    // Don't bother doing work if we're not even showing
+    if (!this.mPopupOpen)
+      return;
+
+    this._invalidate(reason);
+  }
+
+  _invalidate(reason) {
+    // collapsed if no matches
+    this.richlistbox.collapsed = (this.matchCount == 0);
 
-            return 20;
-          ]]>
-        </getter>
-      </property>
+    // Update the richlistbox height.
+    if (this._adjustHeightRAFToken) {
+      cancelAnimationFrame(this._adjustHeightRAFToken);
+      this._adjustHeightRAFToken = null;
+    }
 
-      <property name="matchCount" readonly="true">
-        <getter>
-          <![CDATA[
-          return Math.min(this.mInput.controller.matchCount, this.maxResults);
-          ]]>
-        </getter>
-      </property>
+    if (this.mPopupOpen) {
+      delete this._adjustHeightOnPopupShown;
+      this._adjustHeightRAFToken = requestAnimationFrame(() => this.adjustHeight());
+    } else {
+      this._adjustHeightOnPopupShown = true;
+    }
 
-      <method name="_collapseUnusedItems">
-        <body>
-          <![CDATA[
-            let existingItemsCount = this.richlistbox.children.length;
-            for (let i = this.matchCount; i < existingItemsCount; ++i) {
-              let item = this.richlistbox.children[i];
+    this._currentIndex = 0;
+    if (this._appendResultTimeout) {
+      clearTimeout(this._appendResultTimeout);
+    }
+    this._appendCurrentResult(reason);
+  }
 
-              item.collapsed = true;
-              if (typeof item._onCollapse == "function") {
-                item._onCollapse();
-              }
-            }
-          ]]>
-        </body>
-      </method>
+  _collapseUnusedItems() {
+    let existingItemsCount = this.richlistbox.children.length;
+    for (let i = this.matchCount; i < existingItemsCount; ++i) {
+      let item = this.richlistbox.children[i];
+
+      item.collapsed = true;
+      if (typeof item._onCollapse == "function") {
+        item._onCollapse();
+      }
+    }
+  }
 
-      <method name="adjustHeight">
-        <body>
-          <![CDATA[
-          // Figure out how many rows to show
-          let rows = this.richlistbox.children;
-          let numRows = Math.min(this.matchCount, this.maxRows, rows.length);
+  adjustHeight() {
+    // Figure out how many rows to show
+    let rows = this.richlistbox.children;
+    let numRows = Math.min(this.matchCount, this.maxRows, rows.length);
 
-          // Default the height to 0 if we have no rows to show
-          let height = 0;
-          if (numRows) {
-            let firstRowRect = rows[0].getBoundingClientRect();
-            if (this._rlbPadding == undefined) {
-              let style = window.getComputedStyle(this.richlistbox);
-              let paddingTop = parseInt(style.paddingTop) || 0;
-              let paddingBottom = parseInt(style.paddingBottom) || 0;
-              this._rlbPadding = paddingTop + paddingBottom;
-            }
-
-            // The class `forceHandleUnderflow` is for the item might need to
-            // handle OverUnderflow or Overflow when the height of an item will
-            // be changed dynamically.
-            for (let i = 0; i < numRows; i++) {
-              if (rows[i].classList.contains("forceHandleUnderflow")) {
-                rows[i].handleOverUnderflow();
-              }
-            }
+    // Default the height to 0 if we have no rows to show
+    let height = 0;
+    if (numRows) {
+      let firstRowRect = rows[0].getBoundingClientRect();
+      if (this._rlbPadding == undefined) {
+        let style = window.getComputedStyle(this.richlistbox);
+        let paddingTop = parseInt(style.paddingTop) || 0;
+        let paddingBottom = parseInt(style.paddingBottom) || 0;
+        this._rlbPadding = paddingTop + paddingBottom;
+      }
 
-            let lastRowRect = rows[numRows - 1].getBoundingClientRect();
-            // Calculate the height to have the first row to last row shown
-            height = lastRowRect.bottom - firstRowRect.top +
-                     this._rlbPadding;
-          }
+      // The class `forceHandleUnderflow` is for the item might need to
+      // handle OverUnderflow or Overflow when the height of an item will
+      // be changed dynamically.
+      for (let i = 0; i < numRows; i++) {
+        if (rows[i].classList.contains("forceHandleUnderflow")) {
+          rows[i].handleOverUnderflow();
+        }
+      }
 
-          let currentHeight = this.richlistbox.getBoundingClientRect().height;
-          if (height <= currentHeight) {
-            this._collapseUnusedItems();
-          }
-          this.richlistbox.style.removeProperty("height");
-          // We need to get the ceiling of the calculated value to ensure that the box fully contains
-          // all of its contents and doesn't cause a scrollbar since nsIBoxObject only expects a
-          // `long`. e.g. if `height` is 99.5 the richlistbox would render at height 99px with a
-          // scrollbar for the extra 0.5px.
-          this.richlistbox.height = Math.ceil(height);
-          ]]>
-        </body>
-      </method>
+      let lastRowRect = rows[numRows - 1].getBoundingClientRect();
+      // Calculate the height to have the first row to last row shown
+      height = lastRowRect.bottom - firstRowRect.top +
+        this._rlbPadding;
+    }
 
-      <method name="_appendCurrentResult">
-        <parameter name="invalidateReason"/>
-        <body>
-          <![CDATA[
-          var controller = this.mInput.controller;
-          var matchCount = this.matchCount;
-          var existingItemsCount = this.richlistbox.children.length;
-
-          // Process maxRows per chunk to improve performance and user experience
-          for (let i = 0; i < this.maxRows; i++) {
-            if (this._currentIndex >= matchCount) {
-              break;
-            }
-            let item;
-            let itemExists = this._currentIndex < existingItemsCount;
+    let currentHeight = this.richlistbox.getBoundingClientRect().height;
+    if (height <= currentHeight) {
+      this._collapseUnusedItems();
+    }
+    this.richlistbox.style.removeProperty("height");
+    // We need to get the ceiling of the calculated value to ensure that the box fully contains
+    // all of its contents and doesn't cause a scrollbar since nsIBoxObject only expects a
+    // `long`. e.g. if `height` is 99.5 the richlistbox would render at height 99px with a
+    // scrollbar for the extra 0.5px.
+    this.richlistbox.height = Math.ceil(height);
+  }
 
-            let originalValue, originalText, originalType;
-            let style = controller.getStyleAt(this._currentIndex);
-            let value =
-              style && style.includes("autofill") ?
-              controller.getFinalCompleteValueAt(this._currentIndex) :
-              controller.getValueAt(this._currentIndex);
-            let label = controller.getLabelAt(this._currentIndex);
-            let comment = controller.getCommentAt(this._currentIndex);
-            let image = controller.getImageAt(this._currentIndex);
-            // trim the leading/trailing whitespace
-            let trimmedSearchString = controller.searchString.replace(/^\s+/, "").replace(/\s+$/, "");
+  _appendCurrentResult(invalidateReason) {
+    var controller = this.mInput.controller;
+    var matchCount = this.matchCount;
+    var existingItemsCount = this.richlistbox.children.length;
 
-            let reusable = false;
-            if (itemExists) {
-              item = this.richlistbox.children[this._currentIndex];
+    // Process maxRows per chunk to improve performance and user experience
+    for (let i = 0; i < this.maxRows; i++) {
+      if (this._currentIndex >= matchCount) {
+        break;
+      }
+      let item;
+      let itemExists = this._currentIndex < existingItemsCount;
 
-              // Url may be a modified version of value, see _adjustAcItem().
-              originalValue = item.getAttribute("url") || item.getAttribute("ac-value");
-              originalText = item.getAttribute("ac-text");
-              originalType = item.getAttribute("originaltype");
+      let originalValue, originalText, originalType;
+      let style = controller.getStyleAt(this._currentIndex);
+      let value =
+        style && style.includes("autofill") ?
+        controller.getFinalCompleteValueAt(this._currentIndex) :
+        controller.getValueAt(this._currentIndex);
+      let label = controller.getLabelAt(this._currentIndex);
+      let comment = controller.getCommentAt(this._currentIndex);
+      let image = controller.getImageAt(this._currentIndex);
+      // trim the leading/trailing whitespace
+      let trimmedSearchString = controller.searchString.replace(/^\s+/, "").replace(/\s+$/, "");
 
-              // The styles on the list which have different <content> structure and overrided
-              // _adjustAcItem() are unreusable.
-              const UNREUSEABLE_STYLES = [
-                "autofill-profile",
-                "autofill-footer",
-                "autofill-clear-button",
-                "autofill-insecureWarning",
-                "insecureWarning",
-                "loginsFooter",
-              ];
-              // Reuse the item when its style is exactly equal to the previous style or
-              // neither of their style are in the UNREUSEABLE_STYLES.
-              reusable = originalType === style ||
-                !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
-            }
+      let reusable = false;
+      if (itemExists) {
+        item = this.richlistbox.children[this._currentIndex];
+
+        // Url may be a modified version of value, see _adjustAcItem().
+        originalValue = item.getAttribute("url") || item.getAttribute("ac-value");
+        originalText = item.getAttribute("ac-text");
+        originalType = item.getAttribute("originaltype");
 
-            // If no reusable item available, then create a new item.
-            if (!reusable) {
-              let options = null;
-              switch (style) {
-                case "autofill-profile":
-                  options = { is: "autocomplete-profile-listitem" };
-                  break;
-                case "autofill-footer":
-                  options = { is: "autocomplete-profile-listitem-footer" };
-                  break;
-                case "autofill-clear-button":
-                  options = { is: "autocomplete-profile-listitem-clear-button" };
-                  break;
-                case "autofill-insecureWarning":
-                  options = { is: "autocomplete-creditcard-insecure-field" };
-                  break;
-                case "insecureWarning":
-                  options = { is: "autocomplete-richlistitem-insecure-warning" };
-                  break;
-                case "loginsFooter":
-                  options = { is: "autocomplete-richlistitem-logins-footer" };
-                  break;
-                default:
-                  options = { is: "autocomplete-richlistitem" };
-              }
-              item = document.createXULElement("richlistitem", options);
-              item.className = "autocomplete-richlistitem";
-            }
-
-            item.setAttribute("dir", this.style.direction);
-            item.setAttribute("ac-image", image);
-            item.setAttribute("ac-value", value);
-            item.setAttribute("ac-label", label);
-            item.setAttribute("ac-comment", comment);
-            item.setAttribute("ac-text", trimmedSearchString);
+        // The styles on the list which have different <content> structure and overrided
+        // _adjustAcItem() are unreusable.
+        const UNREUSEABLE_STYLES = [
+          "autofill-profile",
+          "autofill-footer",
+          "autofill-clear-button",
+          "autofill-insecureWarning",
+          "insecureWarning",
+          "loginsFooter",
+        ];
+        // Reuse the item when its style is exactly equal to the previous style or
+        // neither of their style are in the UNREUSEABLE_STYLES.
+        reusable = originalType === style ||
+          !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
+      }
 
-            // Completely reuse the existing richlistitem for invalidation
-            // due to new results, but only when: the item is the same, *OR*
-            // we are about to replace the currently moused-over item, to
-            // avoid surprising the user.
-            let iface = Ci.nsIAutoCompletePopup;
-            if (reusable &&
-                originalText == trimmedSearchString &&
-                invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&
-                (originalValue == value ||
-                 this.mousedOverIndex === this._currentIndex)) {
-              // try to re-use the existing item
-              let reused = item._reuseAcItem();
-              if (reused) {
-                this._currentIndex++;
-                continue;
-              }
-            } else {
-              if (typeof item._cleanup == "function") {
-                item._cleanup();
-              }
-              item.setAttribute("originaltype", style);
-            }
+      // If no reusable item available, then create a new item.
+      if (!reusable) {
+        let options = null;
+        switch (style) {
+          case "autofill-profile":
+            options = { is: "autocomplete-profile-listitem" };
+            break;
+          case "autofill-footer":
+            options = { is: "autocomplete-profile-listitem-footer" };
+            break;
+          case "autofill-clear-button":
+            options = { is: "autocomplete-profile-listitem-clear-button" };
+            break;
+          case "autofill-insecureWarning":
+            options = { is: "autocomplete-creditcard-insecure-field" };
+            break;
+          case "insecureWarning":
+            options = { is: "autocomplete-richlistitem-insecure-warning" };
+            break;
+          case "loginsFooter":
+            options = { is: "autocomplete-richlistitem-logins-footer" };
+            break;
+          default:
+            options = { is: "autocomplete-richlistitem" };
+        }
+        item = document.createXULElement("richlistitem", options);
+        item.className = "autocomplete-richlistitem";
+      }
 
-            if (reusable) {
-              // Adjust only when the result's type is reusable for existing
-              // item's. Otherwise, we might insensibly call old _adjustAcItem()
-              // as new binding has not been attached yet.
-              // We don't need to worry about switching to new binding, since
-              // _adjustAcItem() will fired by its own constructor accordingly.
-              item._adjustAcItem();
-              item.collapsed = false;
-            } else if (itemExists) {
-              let oldItem = this.richlistbox.children[this._currentIndex];
-              this.richlistbox.replaceChild(item, oldItem);
-            } else {
-              this.richlistbox.appendChild(item);
-            }
-
-            this._currentIndex++;
-          }
+      item.setAttribute("dir", this.style.direction);
+      item.setAttribute("ac-image", image);
+      item.setAttribute("ac-value", value);
+      item.setAttribute("ac-label", label);
+      item.setAttribute("ac-comment", comment);
+      item.setAttribute("ac-text", trimmedSearchString);
 
-          if (typeof this.onResultsAdded == "function") {
-            // The items bindings may not be attached yet, so we must delay this
-            // before we can properly handle items properly without breaking
-            // the richlistbox.
-            Services.tm.dispatchToMainThread(() => this.onResultsAdded());
-          }
-
-          if (this._currentIndex < matchCount) {
-            // yield after each batch of items so that typing the url bar is
-            // responsive
-            this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);
-          }
-        ]]>
-        </body>
-      </method>
-
-      <property name="overflowPadding"
-                onget="return Number(this.getAttribute('overflowpadding'))"
-                readonly="true" />
-
-      <method name="selectBy">
-        <parameter name="aReverse"/>
-        <parameter name="aPage"/>
-        <body>
-          <![CDATA[
-          try {
-            var amount = aPage ? 5 : 1;
+      // Completely reuse the existing richlistitem for invalidation
+      // due to new results, but only when: the item is the same, *OR*
+      // we are about to replace the currently moused-over item, to
+      // avoid surprising the user.
+      let iface = Ci.nsIAutoCompletePopup;
+      if (reusable &&
+        originalText == trimmedSearchString &&
+        invalidateReason == iface.INVALIDATE_REASON_NEW_RESULT &&
+        (originalValue == value ||
+          this.mousedOverIndex === this._currentIndex)) {
+        // try to re-use the existing item
+        let reused = item._reuseAcItem();
+        if (reused) {
+          this._currentIndex++;
+          continue;
+        }
+      } else {
+        if (typeof item._cleanup == "function") {
+          item._cleanup();
+        }
+        item.setAttribute("originaltype", style);
+      }
 
-            // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount
-            this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);
-            if (this.selectedIndex == -1) {
-              this.input._focus();
-            }
-          } catch (ex) {
-            // do nothing - occasionally timer-related js errors happen here
-            // e.g. "this.selectedIndex has no properties", when you type fast and hit a
-            // navigation key before this popup has opened
-          }
-            ]]>
-        </body>
-      </method>
+      if (reusable) {
+        // Adjust only when the result's type is reusable for existing
+        // item's. Otherwise, we might insensibly call old _adjustAcItem()
+        // as new binding has not been attached yet.
+        // We don't need to worry about switching to new binding, since
+        // _adjustAcItem() will fired by its own constructor accordingly.
+        item._adjustAcItem();
+        item.collapsed = false;
+      } else if (itemExists) {
+        let oldItem = this.richlistbox.children[this._currentIndex];
+        this.richlistbox.replaceChild(item, oldItem);
+      } else {
+        this.richlistbox.appendChild(item);
+      }
 
-      <field name="richlistbox">
-        document.getAnonymousElementByAttribute(this, "anonid", "richlistbox");
-      </field>
-
-      <property name="view"
-                onget="return this.mInput.controller;"
-                onset="return val;"/>
+      this._currentIndex++;
+    }
 
-    </implementation>
-    <handlers>
-      <handler event="popupshowing"><![CDATA[
-        // If normalMaxRows wasn't already set by the input, then set it here
-        // so that we restore the correct number when the popup is hidden.
+    if (typeof this.onResultsAdded == "function") {
+      // The items bindings may not be attached yet, so we must delay this
+      // before we can properly handle items properly without breaking
+      // the richlistbox.
+      Services.tm.dispatchToMainThread(() => this.onResultsAdded());
+    }
 
-        // Null-check this.mInput; see bug 1017914
-        if (this._normalMaxRows < 0 && this.mInput) {
-          this._normalMaxRows = this.mInput.maxRows;
-        }
+    if (this._currentIndex < matchCount) {
+      // yield after each batch of items so that typing the url bar is
+      // responsive
+      this._appendResultTimeout = setTimeout(() => this._appendCurrentResult(), 0);
+    }
+  }
 
-        // Set an attribute for styling the popup based on the input.
-        let inputID = "";
-        if (this.mInput && this.mInput.ownerDocument &&
-            this.mInput.ownerDocument.documentURIObject.schemeIs("chrome")) {
-          inputID = this.mInput.id;
-          // Take care of elements with no id that are inside xbl bindings
-          if (!inputID) {
-            let bindingParent = this.mInput.ownerDocument.getBindingParent(this.mInput);
-            if (bindingParent) {
-              inputID = bindingParent.id;
-            }
-          }
-        }
-        this.setAttribute("autocompleteinput", inputID);
+  selectBy(aReverse, aPage) {
+    try {
+      var amount = aPage ? 5 : 1;
 
-        this.mPopupOpen = true;
-      ]]></handler>
-
-      <handler event="popupshown">
-        <![CDATA[
-          if (this._adjustHeightOnPopupShown) {
-            delete this._adjustHeightOnPopupShown;
-            this.adjustHeight();
-          }
-      ]]>
-      </handler>
+      // because we collapsed unused items, we can't use this.richlistbox.getRowCount(), we need to use the matchCount
+      this.selectedIndex = this.getNextIndex(aReverse, amount, this.selectedIndex, this.matchCount - 1);
+      if (this.selectedIndex == -1) {
+        this.input._focus();
+      }
+    } catch (ex) {
+      // do nothing - occasionally timer-related js errors happen here
+      // e.g. "this.selectedIndex has no properties", when you type fast and hit a
+      // navigation key before this popup has opened
+    }
+  }
 
-      <handler event="popuphiding"><![CDATA[
-        var isListActive = true;
-        if (this.selectedIndex == -1)
-          isListActive = false;
-        this.input.controller.stopSearch();
-
-        this.removeAttribute("autocompleteinput");
-        this.mPopupOpen = false;
-
-        // Reset the maxRows property to the cached "normal" value (if there's
-        // any), and reset normalMaxRows so that we can detect whether it was set
-        // by the input when the popupshowing handler runs.
+  disconnectedCallback() {
+    if (this.listEvents) {
+      this.richlistbox.removeEventListener("mouseup", this.listEvents);
+      this.richlistbox.removeEventListener("mousemove", this.listEvents);
+      delete this.listEvents;
+    }
+  }
+};
 
-        // Null-check this.mInput; see bug 1017914
-        if (this.mInput && this._normalMaxRows > 0) {
-          this.mInput.maxRows = this._normalMaxRows;
-        }
-        this._normalMaxRows = -1;
-        // If the list was being navigated and then closed, make sure
-        // we fire accessible focus event back to textbox
+MozPopupElement.implementCustomInterface(MozElements.MozAutocompleteRichlistboxPopup, [Ci.nsIAutoCompletePopup]);
 
-        // Null-check this.mInput; see bug 1017914
-        if (isListActive && this.mInput) {
-          this.mInput.mIgnoreFocus = true;
-          this.mInput._focus();
-          this.mInput.mIgnoreFocus = false;
-        }
-      ]]></handler>
-    </handlers>
-  </binding>
+customElements.define("autocomplete-richlistbox-popup", MozElements.MozAutocompleteRichlistboxPopup, {
+  extends: "panel",
+});
+}
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -65,17 +65,17 @@
           }
 
           let popup = null;
           let popupId = this.getAttribute("autocompletepopup");
           if (popupId) {
             popup = document.getElementById(popupId);
           }
           if (!popup) {
-            popup = document.createXULElement("panel");
+            popup = document.createXULElement("panel", { is: "autocomplete-richlistbox-popup" });
             popup.setAttribute("type", "autocomplete-richlistbox");
             popup.setAttribute("noautofocus", "true");
 
             let popupset = document.getAnonymousElementByAttribute(this, "anonid", "popupset");
             popupset.appendChild(popup);
           }
           popup.mInput = this;
 
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -559,17 +559,17 @@ textbox[type="search"] {
 /* SeaMonkey uses its own autocomplete and the toolkit's autocomplete widget */
 %ifndef MOZ_SUITE
 
 textbox[type="autocomplete"] {
   -moz-binding: url("chrome://global/content/bindings/autocomplete.xml#autocomplete");
 }
 
 panel[type="autocomplete-richlistbox"] {
-  -moz-binding: url("chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup");
+  -moz-binding: none;
 }
 
 .autocomplete-richlistbox {
   -moz-user-focus: ignore;
   overflow-x: hidden !important;
 }
 
 .autocomplete-richlistitem {
diff --git a/toolkit/mozapps/extensions/content/extensions.xul b/toolkit/mozapps/extensions/content/extensions.xul
--- a/toolkit/mozapps/extensions/content/extensions.xul
+++ b/toolkit/mozapps/extensions/content/extensions.xul
@@ -63,17 +63,18 @@
                  activateontab="true" position="after_start"
                  level="parent"
 #ifdef XP_WIN
                  consumeoutsideclicks="false" ignorekeys="shortcuts"
 #endif
         />
     </menulist>
 
-    <panel type="autocomplete-richlistbox"
+    <panel is="autocomplete-richlistbox-popup"
+           type="autocomplete-richlistbox"
            id="PopupAutoComplete"
            noautofocus="true"
            hidden="true"
            norolluponanchor="true"
            nomaxresults="true" />
 
     <tooltip id="addonitem-tooltip"/>
 
