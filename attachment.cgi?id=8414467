# HG changeset patch
# Parent 2a0fee6f51f2331f01094d3e65f427d3222bbb29
# User Michael Ratcliffe <mratcliffe@mozilla.com>
# Date 1398780312 -3600

Bug 736078 - Show which elements have listeners attached r=jwalker

diff --git a/browser/devtools/markupview/markup-view.css b/browser/devtools/markupview/markup-view.css
--- a/browser/devtools/markupview/markup-view.css
+++ b/browser/devtools/markupview/markup-view.css
@@ -160,8 +160,13 @@
   position: absolute;
   top: 0;
   right: 5px;
   width: 80px;
   border: 1px dashed #888;
   background: rgba(205,205,255,0.2);
   outline: 1px solid transparent;
 }
+
+.markupview-events {
+  display: none;
+  cursor: pointer;
+}
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -80,16 +80,18 @@ function MarkupView(aInspector, aFrame, 
   this.undo = new UndoStack();
   this.undo.installController(aControllerWindow);
 
   this._containers = new Map();
 
   this._boundMutationObserver = this._mutationObserver.bind(this);
   this.walker.on("mutations", this._boundMutationObserver);
 
+  this._onMouseClick = this._onMouseClick.bind(this);
+
   this._boundOnNewSelection = this._onNewSelection.bind(this);
   this._inspector.selection.on("new-node-front", this._boundOnNewSelection);
   this._onNewSelection();
 
   this._boundKeyDown = this._onKeyDown.bind(this);
   this._frame.contentWindow.addEventListener("keydown", this._boundKeyDown, false);
 
   this._boundFocus = this._onFocus.bind(this);
@@ -104,34 +106,36 @@ function MarkupView(aInspector, aFrame, 
 
 exports.MarkupView = MarkupView;
 
 MarkupView.prototype = {
   _selectedContainer: null,
 
   _initTooltips: function() {
     this.tooltip = new Tooltip(this._inspector.panelDoc);
+    this.eventsTooltip = new Tooltip(this._inspector.panelDoc);
     this.tooltip.startTogglingOnHover(this._elt,
       this._isImagePreviewTarget.bind(this));
+    this._elt.addEventListener("click", this._onMouseClick, false);
   },
 
   _initHighlighter: function() {
     // Show the box model on markup-view mousemove
     this._onMouseMove = this._onMouseMove.bind(this);
     this._elt.addEventListener("mousemove", this._onMouseMove, false);
     this._onMouseLeave = this._onMouseLeave.bind(this);
     this._elt.addEventListener("mouseleave", this._onMouseLeave, false);
 
     // Show markup-containers as hovered on toolbox "picker-node-hovered" event
     // which happens when the "pick" button is pressed
     this._onToolboxPickerHover = (event, nodeFront) => {
       this.showNode(nodeFront, true).then(() => {
         this._showContainerAsHovered(nodeFront);
       });
-    }
+    };
     this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);
   },
 
   _onMouseMove: function(event) {
     let target = event.target;
 
     // Search target for a markupContainer reference, if not found, walk up
     while (!target.container) {
@@ -147,16 +151,36 @@ MarkupView.prototype = {
         this._showBoxModel(container.node);
       } else {
         this._hideBoxModel();
       }
     }
     this._showContainerAsHovered(container.node);
   },
 
+  _onMouseClick: function(event) {
+    // From the target passed here, let's find the parent MarkupContainer
+    // and ask it if the tooltip should be shown
+    let parentNode = event.target;
+    let container;
+    while (parentNode !== this.doc.body) {
+      if (parentNode.container) {
+        container = parentNode.container;
+        break;
+      }
+      parentNode = parentNode.parentNode;
+    }
+
+    if (container) {
+      // With the newly found container, delegate the tooltip content creation
+      // and decision to show or not the tooltip
+      return container._buildEventTooltipContent(event.target, this.eventsTooltip);
+    }
+  },
+
   _hoveredNode: null,
   _showContainerAsHovered: function(nodeFront) {
     if (this._hoveredNode !== nodeFront) {
       if (this._hoveredNode) {
         this._containers.get(this._hoveredNode).hovered = false;
       }
       this._containers.get(nodeFront).hovered = true;
 
@@ -238,17 +262,19 @@ MarkupView.prototype = {
    * tooltip.
    * Delegates the actual decision to the corresponding MarkupContainer instance
    * if one is found.
    * @return the promise returned by MarkupContainer._isImagePreviewTarget
    */
   _isImagePreviewTarget: function(target) {
     // From the target passed here, let's find the parent MarkupContainer
     // and ask it if the tooltip should be shown
-    let parent = target, container;
+    let parent = target;
+    let container;
+
     while (parent !== this.doc.body) {
       if (parent.container) {
         container = parent.container;
         break;
       }
       parent = parent.parentNode;
     }
 
@@ -1064,16 +1090,18 @@ MarkupView.prototype = {
     if (this._destroyer) {
       return this._destroyer;
     }
 
     // Note that if the toolbox is closed, this will work fine, but will fail
     // in case the browser is closed and will trigger a noSuchActor message.
     this._destroyer = this._hideBoxModel();
 
+    this._elt.removeEventListener("click", this._onMouseClick, false);
+
     this._hoveredNode = null;
     this._inspector.toolbox.off("picker-node-hovered", this._onToolboxPickerHover);
 
     this.htmlEditor.destroy();
     this.htmlEditor = null;
 
     this.undo.destroy();
     this.undo = null;
@@ -1117,16 +1145,19 @@ MarkupView.prototype = {
     for (let [key, container] of this._containers) {
       container.destroy();
     }
     this._containers = null;
 
     this.tooltip.destroy();
     this.tooltip = null;
 
+    this.eventsTooltip.destroy();
+    this.eventsTooltip = null;
+
     return this._destroyer;
   },
 
   /**
    * Initialize the preview panel.
    */
   _initPreview: function() {
     this._previewEnabled = Services.prefs.getBoolPref("devtools.inspector.markupPreview");
@@ -1347,16 +1378,32 @@ MarkupContainer.prototype = {
     // the tooltip, because we want the full-size image
     this.node.getImageData().then(data => {
       data.data.string().then(str => {
         clipboardHelper.copyString(str, this.markup.doc);
       });
     });
   },
 
+  _buildEventTooltipContent: function(target, tooltip) {
+    if (target.hasAttribute("data-event")) {
+      tooltip.hide(target);
+
+      this.node.getEventListenerInfo().then(listenerInfo => {
+        tooltip.setEventContent({
+          eventListenerInfos: listenerInfo,
+          toolbox: this._inspector.toolbox
+        });
+
+        tooltip.show(target);
+      });
+      return true;
+    }
+  },
+
   /**
    * True if the current node has children.  The MarkupView
    * will set this attribute for the MarkupContainer.
    */
   _hasChildren: false,
 
   get hasChildren() {
     return this._hasChildren;
@@ -1790,18 +1837,20 @@ function ElementEditor(aContainer, aNode
         });
       } catch(x) {
         console.error(x);
       }
     }
   });
 
   let tagName = this.node.nodeName.toLowerCase();
+
   this.tag.textContent = tagName;
   this.closeTag.textContent = tagName;
+  this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";
 
   this.update();
 }
 
 ElementEditor.prototype = {
   /**
    * Update the state of the editor from the node.
    */
@@ -2036,17 +2085,17 @@ ElementEditor.prototype = {
         this.markup.setNodeExpanded(this.node, newContainer.expanded);
         if (newContainer.selected) {
           this.markup.navigate(this.container);
         }
       });
     }).then(null, console.error);
   },
 
-  destroy: function() {}
+  destroy: function() { }
 };
 
 function nodeDocument(node) {
   return node.ownerDocument ||
     (node.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE ? node : null);
 }
 
 function truncateString(str, maxLength) {
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -25,17 +25,19 @@
       <li id="template-container" save="${elt}" class="child collapsed">
         <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span><span save="${expander}" class="theme-twisty expander"></span></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
       <li id="template-more-nodes" class="more-nodes devtools-class-comment" save="${elt}"><span>${showing}</span> <button href="#" onclick="${allButtonClick}">${showAll}</button></li>
     </ul>
 
-    <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span></span>
+    <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span>
+      <div save="${eventNode}" class="markupview-events" data-event="true">ev</div>
+    </span>
 
     <span id="template-attribute" save="${attr}" data-attr="${attrName}" class="attreditor" style="display:none"> <span class="editable" save="${inner}" tabindex="0"><span save="${name}" class="attr-name theme-fg-color2"></span>=&quot;<span save="${val}" class="attr-value theme-fg-color6"></span>&quot;</span></span>
 
     <span id="template-text" save="${elt}" class="editor text">
       <pre save="${value}" style="display:inline-block;" tabindex="0"></pre>
     </span>
 
     <span id="template-comment" save="${elt}" class="editor comment theme-comment"><span>&lt;!--</span><pre save="${value}" style="display:inline-block;" tabindex="0"></pre><span>--&gt;</span></span>
diff --git a/browser/devtools/markupview/test/browser.ini b/browser/devtools/markupview/test/browser.ini
--- a/browser/devtools/markupview/test/browser.ini
+++ b/browser/devtools/markupview/test/browser.ini
@@ -9,19 +9,21 @@ support-files =
   doc_markup_pagesize_01.html
   doc_markup_pagesize_02.html
   doc_markup_search.html
   doc_markup_toggle.html
   doc_markup_tooltip.png
   head.js
   helper_attributes_test_runner.js
   helper_outerhtml_test_runner.js
+  browser_markupview_events.html
 
 [browser_markupview_copy_image_data.js]
 [browser_markupview_css_completion_style_attribute.js]
+[browser_markupview_events.js]
 [browser_markupview_highlight_hover_01.js]
 [browser_markupview_highlight_hover_02.js]
 [browser_markupview_html_edit_01.js]
 [browser_markupview_html_edit_02.js]
 [browser_markupview_html_edit_03.js]
 [browser_markupview_image_tooltip.js]
 [browser_markupview_mutation_01.js]
 [browser_markupview_mutation_02.js]
diff --git a/browser/devtools/markupview/test/browser_markupview_events.html b/browser/devtools/markupview/test/browser_markupview_events.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_events.html
@@ -0,0 +1,91 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <style>
+    #container {
+      border: 1px solid #000;
+      width: 100px;
+      height: 135px;
+    }
+
+    #container > div {
+      border: 1px solid #000;
+      display: inline-block;
+      margin: 2px;
+    }
+
+    #output,
+    #noevents {
+      border: 1px solid #000;
+      width: 100px;
+      height: 50px;
+    }
+    </style>
+    <script type="application/javascript;version=1.8">
+      function init() {
+        let container = document.getElementById("container");
+        let multiple = document.getElementById("multiple");
+
+        container.addEventListener("mouseover", mouseoverHandler, true);
+        multiple.addEventListener("click", clickHandler, false);
+        multiple.addEventListener("mouseup", mouseupHandler, false);
+
+        new handleEventClick();
+      }
+
+      function mouseoverHandler(event) {
+        if (event.target.id !== "container") {
+          let output = document.getElementById("output");
+          output.textContent = event.target.textContent;
+        }
+      }
+
+      function clickHandler(event) {
+        let output = document.getElementById("output");
+        output.textContent = "click";
+      }
+
+      function mouseupHandler(event) {
+        let output = document.getElementById("output");
+        output.textContent = "mouseup";
+      }
+
+      function handleEventClick() {
+        let he = document.getElementById("he");
+        he.addEventListener("click", this);
+      }
+
+      handleEventClick.prototype = {
+        handleEvent: function() {
+          alert("handleEvent clicked");
+        }
+      };
+    </script>
+  </head>
+  <body onload="init();">
+    <div id="container">
+      <div>1</div>
+      <div>2</div>
+      <div>3</div>
+      <div>4</div>
+      <div>5</div>
+      <div>6</div>
+      <div>7</div>
+      <div>8</div>
+      <div>9</div>
+      <div>10</div>
+      <div>11</div>
+      <div>12</div>
+      <div>13</div>
+      <div>14</div>
+      <div>15</div>
+      <div>16</div>
+      <div id="multiple">multiple</div>
+    </div>
+    <div id="output"></div>
+    <div id="noevents">No events here</div>
+    <div id="DOM0" onclick="alert('hi')">DOM0 event here</div>
+    <br>
+    <div id="he">handleEvent event here</div>
+  </body>
+</html>
diff --git a/browser/devtools/markupview/test/browser_markupview_events.js b/browser/devtools/markupview/test/browser_markupview_events.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/markupview/test/browser_markupview_events.js
@@ -0,0 +1,106 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const TEST_URL = "http://example.com/browser/browser/devtools/" +
+                 "markupview/test/browser_markupview_events.html";
+
+let test = asyncTest(function*() {
+  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+
+  yield inspector.markup.expandAll();
+
+  yield checkEventsForNode(content.document.documentElement, [
+    {
+      heading: "load > \u2026wser_markupview_events.html (Bubbling, DOM0)",
+      handler: "init();"
+    }
+  ]);
+
+  yield checkEventsForNode(content.document.getElementById("container"), [
+    {
+      heading: "mouseover > \u2026r_markupview_events.html:36 (Capturing, DOM2)",
+      handler: 'function mouseoverHandler(event) {\n' +
+               '  if (event.target.id !== "container") {\n' +
+               '    let output = document.getElementById("output");\n' +
+               '    output.textContent = event.target.textContent;\n' +
+               '  }\n' +
+               '}'
+    }
+  ]);
+
+  yield checkEventsForNode(content.document.getElementById("multiple"), [
+    {
+      heading: "click > \u2026r_markupview_events.html:43 (Bubbling, DOM2)",
+      handler: 'function clickHandler(event) {\n' +
+               '  let output = document.getElementById("output");\n' +
+               '  output.textContent = "click";\n' +
+               '}'
+    },
+    {
+      heading: "mouseup > \u2026r_markupview_events.html:48 (Bubbling, DOM2)",
+      handler: 'function mouseupHandler(event) {\n' +
+               '  let output = document.getElementById("output");\n' +
+               '  output.textContent = "mouseup";\n' +
+               '}'
+    }
+  ]);
+
+
+  yield checkEventsForNode(content.document.getElementById("DOM0"), [
+    {
+      heading: "click > \u2026wser_markupview_events.html (Bubbling, DOM0)",
+      handler: "alert('hi')"
+    }
+  ]);
+
+  yield checkEventsForNode(content.document.getElementById("he"), [
+    {
+      heading: "click > \u2026r_markupview_events.html:59 (Bubbling, DOM2)",
+      handler: 'function () {\n' +
+               '  alert("handleEvent clicked");\n' +
+               '}'
+    }
+  ]);
+
+  function* checkEventsForNode(node, expected) {
+    let container = getContainerForRawNode(node, inspector);
+    let evHolder = container.elt.querySelector(".markupview-events");
+
+    evHolder.scrollIntoView();
+
+    // Wait for scrollIntoView to complete.
+    yield promiseNextTick();
+
+    // Click button to show tooltip
+    EventUtils.synthesizeMouseAtCenter(evHolder, {}, inspector.markup.doc.defaultView);
+    yield inspector.markup.eventsTooltip.once("shown");
+
+    // Check values
+    let content = inspector.markup.eventsTooltip.content;
+    let result = content.querySelectorAll(".event-tooltip-header-label,.event-tooltip-source");
+    let selector = node.nodeName + "#" + node.id;
+
+    let out = [];
+
+    for (let i = 0; i < result.length; i+=2) {
+      out.push({
+        heading: result[i].getAttribute("value"),
+        handler: result[i + 1].textContent
+      });
+    }
+
+    for (let i = 0; i < out.length; i++) {
+      is(out[i].heading, expected[i].heading, "headings match for " + selector);
+      is(out[i].handler, expected[i].handler, "handlers match for " + selector);
+    }
+  }
+
+  function promiseNextTick() {
+    let deferred = promise.defer();
+    executeSoon(deferred.resolve);
+    return deferred.promise;
+  }
+});
diff --git a/browser/devtools/shared/widgets/Tooltip.js b/browser/devtools/shared/widgets/Tooltip.js
--- a/browser/devtools/shared/widgets/Tooltip.js
+++ b/browser/devtools/shared/widgets/Tooltip.js
@@ -33,16 +33,18 @@ const GRADIENT_RE = /\b(repeating-)?(lin
 const BORDERCOLOR_RE = /^border-[-a-z]*color$/ig;
 const BORDER_RE = /^border(-(top|bottom|left|right))?$/ig;
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const SPECTRUM_FRAME = "chrome://browser/content/devtools/spectrum-frame.xhtml";
 const ESCAPE_KEYCODE = Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE;
 const RETURN_KEYCODE = Ci.nsIDOMKeyEvent.DOM_VK_RETURN;
 const POPUP_EVENTS = ["shown", "hidden", "showing", "hiding"];
 const FONT_FAMILY_PREVIEW_TEXT = "(ABCabc123&@%)";
+const EVENT_MAX_LINES = 4;
+const MAX_EVENT_SCRIPT_LENGTH = 27;
 
 /**
  * Tooltip widget.
  *
  * This widget is intended at any tool that may need to show rich content in the
  * form of floating panels.
  * A common use case is image previewing in the CSS rule view, but more complex
  * use cases may include color pickers, object inspection, etc...
@@ -512,16 +514,32 @@ Tooltip.prototype = {
       hbox.appendChild(vbox);
       this.content = hbox;
     } else {
       this.content = vbox;
     }
   },
 
   /**
+   * Sets some event listener info as the content of this tooltip.
+   *
+   * @param {array} eventListenerInfos
+   *        A list of event listeners.
+   * @param {toolbox} toolbox
+   *        toolbox used to select debugger panel.
+   */
+  setEventContent: function(
+    {
+      eventListenerInfos,
+      toolbox
+    }) {
+    new EventTooltip(this, eventListenerInfos, toolbox);
+  },
+
+  /**
    * Fill the tooltip with a variables view, inspecting an object via its
    * corresponding object actor, as specified in the remote debugging protocol.
    *
    * @param {object} objectActor
    *        The value grip for the object actor.
    * @param {object} viewOptions [optional]
    *        Options for the variables view visualization.
    * @param {object} controllerOptions [optional]
@@ -1054,16 +1072,196 @@ SwatchColorPickerTooltip.prototype = Her
     this.currentSwatchColor = null;
     this.spectrum.then(spectrum => {
       spectrum.off("changed", this._onSpectrumColorChange);
       spectrum.destroy();
     });
   }
 });
 
+function EventTooltip(tooltip, eventListenerInfos, toolbox) {
+  this._tooltip = tooltip;
+  this._eventListenerInfos = eventListenerInfos;
+  this._toolbox = toolbox;
+
+  this._nodeClicked = this._nodeClicked.bind(this);
+  this.destroy = this.destroy.bind(this);
+
+  this._init();
+}
+
+EventTooltip.prototype = {
+  _init: function() {
+    let doc = this._tooltip.doc;
+    let container = doc.createElement("vbox");
+    container.setAttribute("id", "devtools-tooltip-events-container");
+
+    for (let listener of this._eventListenerInfos) {
+      let phase = listener.capturing ? "Capturing" : "Bubbling";
+      let level = listener.DOM0 ? "DOM0" : "DOM2";
+      let uri;
+
+      if (listener.origin === "?") {
+        uri = l10n.strings.GetStringFromName("eventTooltip.URINotAvailable");
+      } else if (listener.origin.length > MAX_EVENT_SCRIPT_LENGTH) {
+        uri = "\u2026" + listener.origin.substr(-MAX_EVENT_SCRIPT_LENGTH);
+      } else {
+        uri = listener.origin;
+      }
+
+      let heading = listener.type + " > " + uri + " (" + phase + ", " + level + ")";
+
+      // Header
+      let header = doc.createElement("hbox");
+      header.className = "event-header devtools-toolbar";
+      container.appendChild(header);
+
+      let arrow = doc.createElement("hbox");
+      arrow.className = "arrow";
+      header.appendChild(arrow);
+
+      let headerLabel = doc.createElement("label");
+      headerLabel.className = "event-tooltip-header-label";
+      headerLabel.setAttribute("value", heading);
+      headerLabel.setAttribute("tooltiptext", listener.origin);
+      header.appendChild(headerLabel);
+
+      // Content
+      let content = doc.createElement("box");
+      content.className = "event-tooltip-content-box";
+      container.appendChild(content);
+
+      let sourceContainer = doc.createElement("box");
+      sourceContainer.className = "event-tooltip-source-container";
+      content.appendChild(sourceContainer);
+
+      let sourceDesc = doc.createElement("description");
+      sourceDesc.className = "event-tooltip-source";
+      if (listener.origin !== "?") {
+        sourceDesc.setAttribute("data-uri", listener.origin);
+      }
+      sourceContainer.appendChild(sourceDesc);
+
+      let sourceContent = doc.createTextNode(listener.script);
+      sourceDesc.appendChild(sourceContent);
+
+      // This hack is from the depths of the land of ugly. We count lines and
+      // calculate height using lineHeight. XUL panels need the height
+      // explicitly set in order to resize themselves properly and do not play
+      // well with max-height. This is the only way to get each section to size
+      // to x lines with a maximum of EVENT_MAX_LINES.
+      let lines = 2;
+      let matches = listener.script.match(/\n/g);
+
+      if (matches !== null) {
+        lines = matches.length + 1;
+      }
+
+      lines = Math.min(lines, EVENT_MAX_LINES);
+
+      let style = doc.ownerGlobal.getComputedStyle(sourceDesc);
+      let lineText = style.getPropertyCSSValue("line-height").cssText;
+      let lineHeight = parseFloat(lineText);
+
+      let height = lines * lineHeight + "px";
+      content.setAttribute("style", "height: " + height);
+
+      this._addContentListeners(header, sourceDesc, arrow, content);
+    }
+
+    this._tooltip.content = container;
+    this._tooltip.panel.setAttribute("clamped-dimensions-no-min-height", "");
+
+    this._tooltip.panel.addEventListener("popuphiding", () => {
+      this.destroy(container);
+    }, false);
+  },
+
+  _addContentListeners: function(header, sourceDesc, arrow, content) {
+    header.addEventListener("click", this._headerClicked);
+    sourceDesc.addEventListener("click", this._nodeClicked);
+  },
+
+  _headerClicked: function(event) {
+    let header = event.target;
+
+    if (!header.classList.contains("event-header")) {
+      header = header.parentNode;
+    }
+
+    let arrow = header.querySelector(".arrow");
+    let content = header.nextElementSibling;
+
+    if (arrow.hasAttribute("open")) {
+      arrow.removeAttribute("open");
+      content.removeAttribute("open");
+    } else {
+      arrow.setAttribute("open", "");
+      content.setAttribute("open", "");
+    }
+  },
+
+  _nodeClicked: function(event) {
+    let node = event.target;
+    let uri = node.getAttribute("data-uri");
+
+    if (uri && uri !== "?") {
+      // Save a copy of toolbox as it will be set to null when we hide the
+      // tooltip.
+      let toolbox = this._toolbox;
+
+      this._tooltip.hide();
+
+      uri = uri.replace(/"/g, "");
+
+      let showSource = ({ DebuggerView }) => {
+        let matches = uri.match(/(.*):(\d+$)/);
+        let line = 1;
+
+        if (matches) {
+          uri = matches[1];
+          line = matches[2];
+        }
+
+        if (DebuggerView.Sources.containsValue(uri)) {
+          DebuggerView.setEditorLocation(uri, line);
+        }
+      };
+
+      let debuggerAlreadyOpen = toolbox.getPanel("jsdebugger");
+      toolbox.selectTool("jsdebugger").then(({ panelWin: dbg }) => {
+        if (debuggerAlreadyOpen) {
+          showSource(dbg);
+        } else {
+          dbg.once(dbg.EVENTS.SOURCES_ADDED, () => showSource(dbg));
+        }
+      });
+    }
+  },
+
+  destroy: function(container) {
+    if (this._tooltip) {
+      this._tooltip.panel.removeEventListener("popuphiding", this.destroy, false);
+    }
+
+    let headerNodes = container.querySelectorAll(".event-header");
+
+    for (let node of headerNodes) {
+      node.removeEventListener("click", this._headerClicked);
+    }
+
+    let sourceNodes = container.querySelectorAll(".event-tooltip-source");
+    for (let node of sourceNodes) {
+      node.removeEventListener("click", this._nodeClicked);
+    }
+
+    this._tooltip = this._eventListenerInfos =  this._toolbox = null;
+  }
+};
+
 /**
  * Internal util, checks whether a css declaration is a gradient
  */
 function isGradientRule(property, value) {
   return (property === "background" || property === "background-image") &&
     value.match(GRADIENT_RE);
 }
 
diff --git a/browser/locales/en-US/chrome/browser/devtools/inspector.properties b/browser/locales/en-US/chrome/browser/devtools/inspector.properties
--- a/browser/locales/en-US/chrome/browser/devtools/inspector.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/inspector.properties
@@ -41,8 +41,11 @@ inspector.accesskey=I
 # When there are too many nodes to load at once, we will offer to
 # show all the nodes.
 markupView.more.showing=Some nodes were hidden.
 markupView.more.showAll=Show All %S Nodes
 inspector.tooltip=DOM and Style Inspector
 
 #LOCALIZATION NOTE: Used in the image preview tooltip when the image could not be loaded
 previewTooltip.image.brokenImage=Could not load the image
+
+#LOCALIZATION NOTE: Used in the event tooltip when the URI is not available.
+eventTooltip.URINotAvailable=URI unavailable
diff --git a/browser/themes/shared/devtools/common.css b/browser/themes/shared/devtools/common.css
--- a/browser/themes/shared/devtools/common.css
+++ b/browser/themes/shared/devtools/common.css
@@ -148,19 +148,30 @@
 }
 
 .devtools-tooltip[clamped-dimensions] {
   min-height: 100px;
   max-height: 400px;
   min-width: 100px;
   max-width: 400px;
 }
-.devtools-tooltip[clamped-dimensions] .panel-arrowcontent {
+.devtools-tooltip[clamped-dimensions-no-min-height] {
+  min-height: 0;
+  max-height: 400px;
+  min-width: 100px;
+  max-width: 400px;
+}
+.devtools-tooltip[clamped-dimensions] .panel-arrowcontent,
+.devtools-tooltip[clamped-dimensions-no-min-height] .panel-arrowcontent {
   overflow: hidden;
 }
+.devtools-debugger-link {
+  text-decoration: underline;
+  cursor: pointer;
+}
 
 /* Tooltip: Simple Text */
 
 .devtools-tooltip-simple-text {
   max-width: 400px;
   margin: 0 -4px; /* Compensate for the .panel-arrowcontent padding. */
   padding: 8px 12px;
   white-space: pre-wrap;
@@ -196,16 +207,59 @@
 }
 
 /* Tooltip: Variables View */
 
 .devtools-tooltip-variables-view-box {
   margin: -4px; /* Compensate for the .panel-arrowcontent padding. */
 }
 
+/* Tooltip: Events */
+
+#devtools-tooltip-events-container {
+  margin: -4px; /* Compensate for the .panel-arrowcontent padding. */
+}
+
+.event-header {
+  cursor: pointer;
+}
+
+.event-tooltip-header-label {
+  margin-left: 0;
+  cursor: pointer;
+}
+
+.event-tooltip-content-box {
+  display: none;
+  overflow: auto;
+  -moz-margin-end: 0;
+}
+
+.event-tooltip-content-box[open] {
+  display: block;
+}
+
+.event-tooltip-source-container {
+  margin-top: 5px;
+  margin-bottom: 10px;
+  -moz-margin-start: 5px;
+  -moz-margin-end: 0;
+}
+
+.event-tooltip-source {
+  white-space: pre;
+  margin-bottom: 0;
+}
+
+.event-tooltip-source:hover[data-uri] {
+  text-decoration: underline;
+  -moz-text-decoration-style: dotted;
+  cursor: pointer;
+}
+
 /* Tooltip: Tiles */
 
 .devtools-tooltip-tiles {
   background-color: #eee;
   background-image: linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc),
     linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc);
   background-size: 20px 20px;
   background-position: 0 0, 10px 10px;
diff --git a/browser/themes/shared/devtools/dark-theme.css b/browser/themes/shared/devtools/dark-theme.css
--- a/browser/themes/shared/devtools/dark-theme.css
+++ b/browser/themes/shared/devtools/dark-theme.css
@@ -330,9 +330,18 @@ div.CodeMirror span.eval-text {
 }
 
 .devtools-textinput,
 .devtools-searchinput {
   background-color: rgba(24, 29, 32, 1);
   color: rgba(184, 200, 217, 1);
 }
 
+.markupview-events {
+  background-color: #667380;
+  color: #0F0F0F;
+}
+
+.event-tooltip-source-container {
+  color: #B6BABF;
+}
+
 %include toolbars.inc.css
diff --git a/browser/themes/shared/devtools/light-theme.css b/browser/themes/shared/devtools/light-theme.css
--- a/browser/themes/shared/devtools/light-theme.css
+++ b/browser/themes/shared/devtools/light-theme.css
@@ -333,9 +333,18 @@ div.CodeMirror span.eval-text {
   border-bottom: 1px solid #aaa;
 }
 
 .devtools-side-splitter {
   -moz-border-end: 1px solid #aaa;
   border-color: #aaa; /* Needed for responsive container at low width. */
 }
 
+.markupview-events {
+  background-color: #667380;
+  color: #FFF;
+}
+
+.event-tooltip-source-container {
+  color: #191919;
+}
+
 %include toolbars.inc.css
diff --git a/browser/themes/shared/devtools/markup-view.css b/browser/themes/shared/devtools/markup-view.css
--- a/browser/themes/shared/devtools/markup-view.css
+++ b/browser/themes/shared/devtools/markup-view.css
@@ -28,8 +28,16 @@
 .theme-selected ~ .editor .theme-fg-color6,
 .theme-selected ~ .editor .theme-fg-color7 {
   color: #f5f7fa; /* Light foreground text */
 }
 
 .tag-line {
   padding-left: 2px;
 }
+
+.markupview-events {
+  font-size: 0.8em;
+  font-weight: bold;
+  line-height: 10px;
+  border-radius: 50%;
+  padding: 0px 2px;
+}
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -62,16 +62,17 @@ const {Unknown} = require("sdk/platform/
 const {Class} = require("sdk/core/heritage");
 const {PageStyleActor} = require("devtools/server/actors/styles");
 const {HighlighterActor} = require("devtools/server/actors/highlighter");
 
 const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
 const HIDDEN_CLASS = "__fx-devtools-hide-shortcut__";
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const IMAGE_FETCHING_TIMEOUT = 500;
+const NATIVE_CODE = "function () {\n    [native code]\n}";
 // The possible completions to a ':' with added score to give certain values
 // some preference.
 const PSEUDO_SELECTORS = [
   [":active", 1],
   [":hover", 1],
   [":focus", 1],
   [":visited", 0],
   [":link", 0],
@@ -106,16 +107,30 @@ HELPER_SHEET += ":-moz-devtools-highligh
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
   return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
 });
 
+loader.lazyGetter(this, "Debugger", function() {
+  let JsDebugger = require("resource://gre/modules/jsdebugger.jsm");
+
+  let global = Cu.getGlobalForObject({});
+  JsDebugger.addDebuggerToGlobal(global);
+
+  return global.Debugger;
+});
+
+loader.lazyGetter(this, "eventListenerService", function() {
+  return Cc["@mozilla.org/eventlistenerservice;1"]
+           .getService(Ci.nsIEventListenerService);
+});
+
 exports.register = function(handle) {
   handle.addGlobalActor(InspectorActor, "inspectorActor");
   handle.addTabActor(InspectorActor, "inspectorActor");
 };
 
 exports.unregister = function(handle) {
   handle.removeGlobalActor(InspectorActor);
   handle.removeTabActor(InspectorActor);
@@ -220,16 +235,18 @@ var NodeActor = exports.NodeActor = prot
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
 
       pseudoClassLocks: this.writePseudoClassLocks(),
+
+      hasEventListeners: this._hasEventListeners,
     };
 
     if (this.isDocumentElement()) {
       form.isDocumentElement = true;
     }
 
     if (this.rawNode.nodeValue) {
       // We only include a short version of the value if it's longer than
@@ -240,16 +257,37 @@ var NodeActor = exports.NodeActor = prot
       } else {
         form.shortValue = this.rawNode.nodeValue;
       }
     }
 
     return form;
   },
 
+  /**
+   * Are event listeners that are listening on this node?
+   */
+  get _hasEventListeners() {
+    let listeners;
+
+    if (this.rawNode.nodeName.toLowerCase() === "html") {
+      listeners = eventListenerService.getListenerInfoFor(this.rawNode.ownerGlobal);
+    } else {
+      listeners = eventListenerService.getListenerInfoFor(this.rawNode) || [];
+    }
+
+    listeners = listeners.filter(listener => {
+      return listener.listenerObject && listener.type;
+    });
+
+    let hasListeners = listeners.length > 0;
+
+    return hasListeners;
+  },
+
   writeAttrs: function() {
     if (!this.rawNode.attributes) {
       return undefined;
     }
     return [{namespace: attr.namespace, name: attr.name, value: attr.value }
             for (attr of this.rawNode.attributes)];
   },
 
@@ -262,16 +300,110 @@ var NodeActor = exports.NodeActor = prot
       if (DOMUtils.hasPseudoClassLock(this.rawNode, pseudo)) {
         ret = ret || [];
         ret.push(pseudo);
       }
     }
     return ret;
   },
 
+  getNodeName: function(node) {
+    let nodeName = (node.nodeName + "").toLowerCase();
+
+    if (node.id) {
+      nodeName += "#" + node.id;
+    }
+    if (node.className) {
+      nodeName += "." + node.className;
+    }
+    if (nodeName === "undefined") {
+      nodeName = "window " + node.document.location.href;
+    }
+    return nodeName;
+  },
+
+  getEventListeners: function(node) {
+    let global = node.ownerGlobal ?
+                 node.ownerGlobal.wrappedJSObject :
+                 node.wrappedJSObject;
+    let dbg = new Debugger();
+    let globalDebugObject = dbg.addDebuggee(global);
+    let handlers = eventListenerService.getListenerInfoFor(node);
+    let events = [];
+
+    for (let handler of handlers) {
+      let listener = handler.listenerObject;
+
+      if (listener) {
+        let listenerDebugObject = globalDebugObject.makeDebuggeeValue(listener);
+        let script = listenerDebugObject.script;
+        let scriptSource;
+
+        if (!script && listener.handleEvent) {
+          let desc = listenerDebugObject.proto.getOwnPropertyDescriptor("handleEvent");
+          if (desc) {
+            script = desc.value.script;
+            scriptSource = handler.listenerObject.handleEvent.toString();
+          }
+        }
+
+        if (script) {
+          let url = script.url;
+          let type = handler.type;
+          let dom0 = !!node["on" + type];
+          let line = script.startLine;
+
+          if (!scriptSource) {
+            scriptSource = dom0 ? script.source.text : listener.toString();
+          }
+
+          if (!dom0) {
+            let tmpScript = scriptSource.split(/[\r\n]+/);
+            let unindentTo = tmpScript[tmpScript.length -1 ].indexOf("}");
+
+            for (let i = 1; i < tmpScript.length; i++) {
+              tmpScript[i] = tmpScript[i].substr(unindentTo);
+            }
+
+            scriptSource = tmpScript.join("\n");
+          }
+
+          events.push({
+            type: type,
+            DOM0: dom0,
+            capturing: handler.capturing,
+            script: scriptSource,
+            origin: url + (dom0 ? "" : ":" + line)
+          });
+        } else if (listener.handleEvent) {
+          let type = handler.type;
+          let dom0 = !!node["on" + type];
+          let scriptSource = listener.handleEvent.toString();
+
+          // Comparing the script source itself seems to be the only way to
+          // identify real scripts across content and XUL
+          // i.e. not function () {[native code]}
+          if (scriptSource !== NATIVE_CODE) {
+            events.push({
+              type: type,
+              DOM0: dom0,
+              capturing: handler.capturing,
+              script: scriptSource,
+              origin: "?"
+            });
+          }
+        }
+      }
+    }
+
+    dbg.removeDebuggee(globalDebugObject);
+
+    return events;
+  },
+
   /**
    * Returns a LongStringActor with the node's value.
    */
   getNodeValue: method(function() {
     return new LongStringActor(this.conn, this.rawNode.nodeValue || "");
   }, {
     request: {},
     response: {
@@ -312,16 +444,31 @@ var NodeActor = exports.NodeActor = prot
       return promise.reject(new Error("Image not available"));
     }
   }, {
     request: {maxDim: Arg(0, "nullable:number")},
     response: RetVal("imageData")
   }),
 
   /**
+   * Get all event listeners that are listening on this node.
+   */
+  getEventListenerInfo: method(function() {
+    if (this.rawNode.nodeName.toLowerCase() === "html") {
+      return this.getEventListeners(this.rawNode.ownerGlobal);
+    }
+    return this.getEventListeners(this.rawNode);
+  }, {
+    request: {},
+    response: {
+      events: RetVal("json")
+    }
+  }),
+
+  /**
    * Modify a node's attributes.  Passed an array of modifications
    * similar in format to "attributes" mutations.
    * {
    *   attributeName: <string>
    *   attributeNamespace: <optional string>
    *   newValue: <optional string> - If null or undefined, the attribute
    *     will be removed.
    * }
@@ -473,16 +620,18 @@ let NodeFront = protocol.FrontClass(Node
 
   get className() {
     return this.getAttribute("class") || '';
   },
 
   get hasChildren() this._form.numChildren > 0,
   get numChildren() this._form.numChildren,
 
+  get hasEventListeners() this._form.hasEventListeners,
+
   get tagName() this.nodeType === Ci.nsIDOMNode.ELEMENT_NODE ? this.nodeName : null,
   get shortValue() this._form.shortValue,
   get incompleteValue() !!this._form.incompleteValue,
 
   get isDocumentElement() !!this._form.isDocumentElement,
 
   // doctype properties
   get name() this._form.name,
