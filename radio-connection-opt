# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0dbf75f9798a9c26cf688a5da7cd5bbd048a02a4

diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -111,17 +111,23 @@ class MozRadiogroup extends MozBaseContr
     });
   }
 
   connectedCallback() {
     if (this.waitForDOMReady()) {
       return;
     }
 
+    // While <radio> is XBL, the <constructor> for each radio will generally
+    // fire as a result of collecting radio children if they are hidden. To
+    // avoid churn where we keep wiping out _radioChildren as each radio
+    // gets constructed, keep track of this case with a flag:
+    this.connecting = true;
     this.init();
+    this.connecting = false;
     if (!this.value) {
       this.selectedIndex = 0;
     }
   }
 
   init() {
     this._radioChildren = null;
 
@@ -149,17 +155,24 @@ class MozRadiogroup extends MozBaseContr
    * construction (see Bug 1496137), or just due to normal DOM appending after
    * the <radiogroup> is created. When this happens, reinitialize the UI if
    * necessary to make sure the state is consistent.
    *
    * @param {DOMNode} child
    *                  The <radio> element that got added
    */
   radioChildConstructed(child) {
-    if (!this._radioChildren || !this._radioChildren.includes(child)) {
+    // If the radio XBL is constructed before this is connected, or if we are
+    // actively connecting, then don't worry about reinitializing:
+    if (typeof this.connecting === "undefined" || this.connecting) {
+      return;
+    }
+
+    // If this radio child is unknown to the group, then reinitialize:
+    if (!this.radioChildren || !this._radioChildren.includes(child)) {
       this.init();
     }
   }
 
   set value(val) {
     this.setAttribute("value", val);
     var children = this._getRadioChildren();
     for (var i = 0; i < children.length; i++) {
