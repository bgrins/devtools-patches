# HG changeset patch
# User Botond Ballo <botond@mozilla.com>
# Date 1568847245 14400
#      Wed Sep 18 18:54:05 2019 -0400
# Node ID 3ddbd48947cb373200bcca291665dbdb29ba0060
# Parent  9d6f81c0815eb17141f8d3235ac1faa9c2434327
Bug 1545496 - Handle the case where the root scroll metadata is neither 'root content', nor on the root layer. r=tnikkel

This can happen if the root chrome document is an HTML document, and the root
scroll metadata is generated by its root scroll frame. With containerless
scrollig, that metadata will go on the children of the root layer.

diff --git a/gfx/layers/composite/AsyncCompositionManager.cpp b/gfx/layers/composite/AsyncCompositionManager.cpp
--- a/gfx/layers/composite/AsyncCompositionManager.cpp
+++ b/gfx/layers/composite/AsyncCompositionManager.cpp
@@ -903,21 +903,25 @@ bool AsyncCompositionManager::ApplyAsync
 
   // Maps layers to their ClipParts. The parts are not stored individually
   // on the layer, but during AlignFixedAndStickyLayers we need access to
   // the individual parts for descendant layers.
   ClipPartsCache clipPartsCache;
 
   Layer* zoomContainer = nullptr;
   Maybe<LayerMetricsWrapper> zoomedMetrics;
+  uint32_t refLayerDepth = 0;
 
   ForEachNode<ForwardIterator>(
       aLayer,
       [&](Layer* layer) {
         stackDeferredClips.push(Maybe<ParentLayerIntRect>());
+        if (layer->AsRefLayer()) {
+          ++refLayerDepth;
+        }
 
         // If we encounter the async zoom container, find the corresponding
         // APZC and stash it into |zoomedMetrics|.
         // (We stash it in the form of a LayerMetricsWrapper because
         // APZSampler requires going through that rather than using the APZC
         // directly.)
         // We do this on the way down the tree (i.e. here in the pre-action)
         // so that by the time we encounter the layers with the RCD-RSF's
@@ -948,16 +952,20 @@ bool AsyncCompositionManager::ApplyAsync
         }
       },
       [&](Layer* layer) {
         Maybe<ParentLayerIntRect> clipDeferredFromChildren =
             stackDeferredClips.top();
         stackDeferredClips.pop();
         LayerToParentLayerMatrix4x4 oldTransform =
             layer->GetTransformTyped() * AsyncTransformMatrix();
+        if (layer->AsRefLayer()) {
+          MOZ_ASSERT(refLayerDepth > 0);
+          --refLayerDepth;
+        }
 
         AsyncTransformComponentMatrix combinedAsyncTransform;
         bool hasAsyncTransform = false;
         // Only set on the root layer for Android.
         ScreenMargin fixedLayerMargins;
 
         // Each layer has multiple clips:
         //  - Its local clip, which is fixed to the layer contents, i.e. it
@@ -1050,19 +1058,20 @@ bool AsyncCompositionManager::ApplyAsync
             // If we find a metrics which is the root content doc, use that. If
             // not, use the root layer. Since this function recurses on children
             // first we should only end up using the root layer if the entire
             // tree was devoid of a root content metrics. This is a temporary
             // solution; in the long term we should not need the root content
             // metrics at all. See bug 1201529 comment 6 for details.
             if (!(*aOutFoundRoot)) {
               *aOutFoundRoot =
-                  metrics.IsRootContent() ||        /* RCD */
-                  (layer->GetParent() == nullptr && /* rootmost metrics */
-                   i + 1 >= layer->GetScrollMetadataCount());
+                  metrics.IsRootContent() ||          /* RCD */
+                  (scrollMetadata.IsLayersIdRoot() && /* root metrics for root
+                                                         layer tree */
+                   refLayerDepth == 0);
               if (*aOutFoundRoot) {
                 mRootScrollableId = metrics.GetScrollId();
                 Compositor* compositor = mLayerManager->GetCompositor();
                 if (CompositorBridgeParent* bridge =
                         compositor->GetCompositorBridgeParent()) {
                   AndroidDynamicToolbarAnimator* animator =
                       bridge->GetAndroidDynamicToolbarAnimator();
 
