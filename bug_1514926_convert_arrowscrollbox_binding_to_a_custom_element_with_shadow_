# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1566929466 25200
#      Tue Aug 27 11:11:06 2019 -0700
# Node ID 9519666e4bfd93782269a591d70672032a552fa5
# Parent  0cf9eded35d8150796eda1f892666d0a778bd488
Bug 1514926 - Convert arrowscrollbox binding to a Custom Element with Shadow DOM

Differential Revision: https://phabricator.services.mozilla.com/D43651

diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -728,25 +728,17 @@
                   is="tabbrowser-tabs"
                   flex="1"
                   setfocus="false"
                   tooltip="tabbrowser-tab-tooltip"
                   stopwatchid="FX_TAB_CLICK_MS">
               <hbox class="tab-drop-indicator-box">
                 <image class="tab-drop-indicator" hidden="true"/>
               </hbox>
-              <arrowscrollbox orient="horizontal" flex="1" style="min-width: 1px;" clicktoscroll="true" class="tabbrowser-arrowscrollbox" scrolledtostart="true" scrolledtoend="true">
-                <tab is="tabbrowser-tab" class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
-                <toolbarbutton id="tabs-newtab-button"
-                               class="tabs-newtab-button toolbarbutton-1"
-                               command="cmd_newNavigatorTab"
-                               onclick="checkForMiddleClick(this, event);"
-                               tooltip="dynamic-shortcut-tooltip"/>
-                <spacer class="closing-tabs-spacer" style="width: 0;"/>
-              </arrowscrollbox>
+              <arrowscrollbox orient="horizontal" flex="1" style="min-width: 1px;" clicktoscroll="true" class="tabbrowser-arrowscrollbox" scrolledtostart="true" scrolledtoend="true" />
               <html:span id="tabbrowser-tab-a11y-desc" hidden="true"/>
             </tabs>
 
             <toolbarbutton id="new-tab-button"
                            class="toolbarbutton-1 chromeclass-toolbar-additional"
                            label="&tabCmd.label;"
                            command="cmd_newNavigatorTab"
                            onclick="checkForMiddleClick(this, event);"
diff --git a/browser/base/content/tabbrowser-tabs.js b/browser/base/content/tabbrowser-tabs.js
--- a/browser/base/content/tabbrowser-tabs.js
+++ b/browser/base/content/tabbrowser-tabs.js
@@ -27,16 +27,29 @@
       this.addEventListener("dragover", this);
       this.addEventListener("drop", this);
       this.addEventListener("dragend", this);
       this.addEventListener("dragexit", this);
     }
 
     init() {
       this.arrowScrollbox = this.querySelector("arrowscrollbox");
+      // XXX: Shadow DOM slotting gets confused if this is inline in browser.xhtml:
+      this.arrowScrollbox.prepend(
+        MozXULElement.parseXULToFragment(
+          `<tab is="tabbrowser-tab" class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
+            <toolbarbutton id="tabs-newtab-button"
+                          class="tabs-newtab-button toolbarbutton-1"
+                          command="cmd_newNavigatorTab"
+                          onclick="checkForMiddleClick(this, event);"
+                          tooltip="dynamic-shortcut-tooltip"/>
+            <spacer class="closing-tabs-spacer" style="width: 0;"/>
+          `
+        )
+      );
 
       this.baseConnect();
 
       this._firstTab = null;
       this._lastTab = null;
       this._beforeSelectedTab = null;
       this._beforeHoveredTab = null;
       this._afterHoveredTab = null;
@@ -951,17 +964,17 @@
     }
 
     get _isCustomizing() {
       return document.documentElement.getAttribute("customizing") == "true";
     }
 
     _initializeArrowScrollbox() {
       let arrowScrollbox = this.arrowScrollbox;
-      arrowScrollbox.addEventListener(
+      arrowScrollbox.shadowRoot.addEventListener(
         "underflow",
         event => {
           // Ignore underflow events:
           // - from nested scrollable elements
           // - for vertical orientation
           // - corresponding to an overflow event that we ignored
           if (
             event.originalTarget != arrowScrollbox.scrollbox ||
@@ -981,35 +994,36 @@
             gBrowser.removeTab(tab);
           }
 
           this._positionPinnedTabs();
         },
         true
       );
 
-      arrowScrollbox.addEventListener("overflow", event => {
+      arrowScrollbox.shadowRoot.addEventListener("overflow", event => {
         // Ignore overflow events:
         // - from nested scrollable elements
         // - for vertical orientation
         if (
           event.originalTarget != arrowScrollbox.scrollbox ||
           event.detail == 0
         ) {
           return;
         }
 
         this.setAttribute("overflow", "true");
         this._positionPinnedTabs();
         this._handleTabSelect(true);
       });
 
-      // Override scrollbox.xml method, since our scrollbox's children are
+      // Override arrowscrollbox.js method, since our scrollbox's children are
       // inherited from the scrollbox binding parent (this).
       arrowScrollbox._getScrollableElements = () => {
+        console.trace(this.allTabs);
         return this.allTabs.filter(arrowScrollbox._canScrollToElement);
       };
       arrowScrollbox._canScrollToElement = tab => {
         return !tab._pinnedUnscrollable && !tab.hidden;
       };
     }
 
     observe(aSubject, aTopic, aData) {
diff --git a/browser/themes/linux/browser.css b/browser/themes/linux/browser.css
--- a/browser/themes/linux/browser.css
+++ b/browser/themes/linux/browser.css
@@ -376,18 +376,18 @@ notification[value="translation"] menuli
 .tab-drop-indicator {
   list-style-image: url(chrome://browser/skin/tabbrowser/tabDragIndicator.png);
   margin-bottom: -9px;
   z-index: 3;
 }
 
 /* Tab bar scroll arrows */
 
-.tabbrowser-arrowscrollbox > .scrollbutton-up > .toolbarbutton-icon,
-.tabbrowser-arrowscrollbox > .scrollbutton-down > .toolbarbutton-icon {
+.tabbrowser-arrowscrollbox::part(scrollbutton-up) > .toolbarbutton-icon,
+.tabbrowser-arrowscrollbox::part(scrollbutton-down) > .toolbarbutton-icon {
   -moz-appearance: none;
 }
 
 /* All tabs menupopup */
 
 .alltabs-item[selected="true"] {
   font-weight: bold;
 }
diff --git a/browser/themes/shared/tabs.inc.css b/browser/themes/shared/tabs.inc.css
--- a/browser/themes/shared/tabs.inc.css
+++ b/browser/themes/shared/tabs.inc.css
@@ -58,17 +58,17 @@
 }
 
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   .tab-stack {
     /* Needed to allow tabs to shrink to be skinnier than their page-title: */
     min-width: 0;
   }
 
-  .tabbrowser-arrowscrollbox > .arrowscrollbox-scrollbox {
+  .tabbrowser-arrowscrollbox::part(arrowscrollbox-scrollbox) {
     /* Needed to prevent tabstrip from growing as wide as the sum of the tabs'
        page-title widths (when we'd rather have it be as wide as the window and
        compress the tabs to their minimum size): */
     max-width: 100%;
   }
 }
 
 .tabbrowser-tab {
@@ -429,54 +429,54 @@
 
 .tab-icon-sound[soundplaying-scheduledremoval]:not([muted]):not(:hover),
 .tab-icon-overlay[soundplaying-scheduledremoval]:not([muted]):not(:hover) {
   transition: opacity .3s linear var(--soundplaying-removal-delay);
   opacity: 0;
 }
 
 /* Tab Overflow */
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-start-indicator:not([collapsed]),
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-end-indicator:not([collapsed]) {
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-start-indicator):not([collapsed]),
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-end-indicator):not([collapsed]) {
   width: 18px;
   background-image: url(chrome://browser/skin/tabbrowser/tab-overflow-indicator.png);
   background-size: 17px 100%;
   background-repeat: no-repeat;
   border-left: 1px solid;
   border-image: linear-gradient(rgba(255,255,255,.2),
                                 rgba(255,255,255,.2) calc(100% - 1px - var(--tabs-navbar-shadow-size)),
                                 transparent calc(100% - 1px - var(--tabs-navbar-shadow-size)));
   border-image-slice: 1;
   pointer-events: none;
   position: relative;
   z-index: 3; /* the selected tab's z-index + 1 */
 }
 
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-start-indicator:-moz-locale-dir(rtl),
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-end-indicator:-moz-locale-dir(ltr) {
+.tabbrowser-arrowscrollbox:-moz-locale-dir(rtl)::part(arrowscrollbox-overflow-start-indicator),
+.tabbrowser-arrowscrollbox:-moz-locale-dir(ltr)::part(arrowscrollbox-overflow-end-indicator) {
   transform: scaleX(-1);
 }
 
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-start-indicator:not([collapsed]) {
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-start-indicator):not([collapsed]) {
   margin-inline-start: -1px;
   margin-inline-end: -17px;
 }
 
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-end-indicator:not([collapsed]) {
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-end-indicator):not([collapsed]) {
   margin-inline-start: -17px;
   margin-inline-end: -1px;
 }
 
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-start-indicator[collapsed],
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-end-indicator[collapsed] {
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-start-indicator)[collapsed],
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-end-indicator)[collapsed] {
   opacity: 0;
 }
 
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-start-indicator,
-.tabbrowser-arrowscrollbox > .arrowscrollbox-overflow-end-indicator {
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-start-indicator),
+.tabbrowser-arrowscrollbox::part(arrowscrollbox-overflow-end-indicator) {
   transition: opacity 150ms ease;
 }
 
 .tabbrowser-tab:not([visuallyselected=true]):not([multiselected]),
 .tabbrowser-tab:-moz-lwtheme {
   color: inherit;
 }
 
@@ -685,27 +685,27 @@
 /* Also show separators beside the selected tab when dragging it. */
 #tabbrowser-tabs[movingtab] > .tabbrowser-arrowscrollbox > .tabbrowser-tab[visuallyselected]::before {
   content: "";
   display: -moz-box;
 }
 
 /* Tab bar scroll arrows */
 
-.tabbrowser-arrowscrollbox > .scrollbutton-up,
-.tabbrowser-arrowscrollbox > .scrollbutton-down {
+.tabbrowser-arrowscrollbox::part(scrollbutton-up),
+.tabbrowser-arrowscrollbox::part(scrollbutton-down) {
   list-style-image: url(chrome://browser/skin/arrow-left.svg) !important;
   -moz-context-properties: fill, fill-opacity;
   fill: var(--lwt-toolbarbutton-icon-fill, currentColor);
   fill-opacity: var(--toolbarbutton-icon-fill-opacity);
   color: inherit;
 }
 
-.tabbrowser-arrowscrollbox > .scrollbutton-up:-moz-locale-dir(rtl),
-.tabbrowser-arrowscrollbox > .scrollbutton-down:-moz-locale-dir(ltr) {
+.tabbrowser-arrowscrollbox:-moz-locale-dir(rtl)::part(scrollbutton-up),
+.tabbrowser-arrowscrollbox:-moz-locale-dir(ltr)::part(scrollbutton-down) {
   transform: scaleX(-1);
 }
 
 /* New tab button */
 
 .tabs-newtab-button,
 #TabsToolbar #new-tab-button {
   list-style-image: url(chrome://browser/skin/add.svg);
diff --git a/browser/themes/shared/toolbarbuttons.inc.css b/browser/themes/shared/toolbarbuttons.inc.css
--- a/browser/themes/shared/toolbarbuttons.inc.css
+++ b/browser/themes/shared/toolbarbuttons.inc.css
@@ -50,18 +50,18 @@ toolbar[brighttext] {
 
   --backbutton-background: var(--toolbarbutton-hover-background);
   --backbutton-hover-background: var(--toolbarbutton-active-background);
   --backbutton-active-background: hsla(0,0%,100%,.4);
 }
 
 /* ::::: primary toolbar buttons ::::: */
 
-.tabbrowser-arrowscrollbox > .scrollbutton-up[disabled=true],
-.tabbrowser-arrowscrollbox > .scrollbutton-down[disabled=true],
+.tabbrowser-arrowscrollbox::part(scrollbutton-up)[disabled=true],
+.tabbrowser-arrowscrollbox::part(scrollbutton-down)[disabled=true],
 :root:not([customizing]) .toolbarbutton-1[disabled=true],
 /* specialcase the overflow and the hamburger button so they show up disabled in customize mode. */
 #nav-bar-overflow-button[disabled=true],
 #PanelUI-menu-button[disabled=true] {
   opacity: 0.4;
 }
 
 .toolbarbutton-1 > .toolbarbutton-icon {
@@ -69,32 +69,32 @@ toolbar[brighttext] {
 }
 
 .toolbarbutton-1 > .toolbarbutton-icon,
 .toolbarbutton-1 > .toolbarbutton-badge-stack > .toolbarbutton-icon {
   width: 16px;
 }
 
 #TabsToolbar .toolbarbutton-1,
-.tabbrowser-arrowscrollbox > .scrollbutton-up,
-.tabbrowser-arrowscrollbox > .scrollbutton-down {
+.tabbrowser-arrowscrollbox::part(scrollbutton-up),
+.tabbrowser-arrowscrollbox::part(scrollbutton-down) {
   margin: 0 0 var(--tabs-navbar-shadow-size) !important;
 }
 
-.tabbrowser-arrowscrollbox > .scrollbutton-up,
-.tabbrowser-arrowscrollbox > .scrollbutton-down {
+.tabbrowser-arrowscrollbox::part(scrollbutton-up),
+.tabbrowser-arrowscrollbox::part(scrollbutton-down) {
   -moz-appearance: none;
   padding: 0 var(--toolbarbutton-inner-padding) !important;
 }
 
-#navigator-toolbox:not(:hover) .tabbrowser-arrowscrollbox > .scrollbutton-down:not([highlight]) {
+#navigator-toolbox:not(:hover) .tabbrowser-arrowscrollbox::part(scrollbutton-down):not([highlight]) {
   transition: 1s background-color ease-out;
 }
 
-.tabbrowser-arrowscrollbox > .scrollbutton-down[highlight] {
+.tabbrowser-arrowscrollbox::part(scrollbutton-down)[highlight] {
   background-color: Highlight;
 }
 
 .findbar-button {
   -moz-appearance: none;
   color: inherit;
 }
 
@@ -170,18 +170,18 @@ toolbar .toolbaritem-combined-buttons:no
   opacity: .2;
 }
 
 toolbar[brighttext] .toolbaritem-combined-buttons > separator {
   opacity: .3;
 }
 
 #PersonalToolbar .toolbarbutton-1:not([disabled=true]):not([checked]):not([open]):not(:active):hover,
-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled=true]):hover,
-.tabbrowser-arrowscrollbox > .scrollbutton-down:not([disabled=true]):hover,
+.tabbrowser-arrowscrollbox::part(scrollbutton-up):not([disabled=true]):hover,
+.tabbrowser-arrowscrollbox::part(scrollbutton-down):not([disabled=true]):hover,
 .findbar-button:not(:-moz-any([checked="true"],[disabled="true"])):hover,
 toolbarbutton.bookmark-item:not(.subviewbutton):hover:not([disabled="true"]):not([open]),
 toolbar .toolbarbutton-1:not([disabled=true]):not([checked]):not([open]):not(:active):hover > .toolbarbutton-icon,
 toolbar .toolbarbutton-1:not([disabled=true]):not([checked]):not([open]):not(:active):hover > .toolbarbutton-text,
 toolbar .toolbarbutton-1:not([disabled=true]):not([checked]):not([open]):not(:active):hover > .toolbarbutton-badge-stack {
   background-color: var(--toolbarbutton-hover-background);
   color: inherit;
 }
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -746,16 +746,17 @@
   });
 
   // For now, don't load any elements in the extension dummy document.
   // We will want to load <browser> when that's migrated (bug 1441935).
   const isDummyDocument =
     document.documentURI == "chrome://extensions/content/dummy.xul";
   if (!isDummyDocument) {
     for (let script of [
+      "chrome://global/content/elements/arrowscrollbox.js",
       "chrome://global/content/elements/dialog.js",
       "chrome://global/content/elements/general.js",
       "chrome://global/content/elements/button.js",
       "chrome://global/content/elements/checkbox.js",
       "chrome://global/content/elements/menu.js",
       "chrome://global/content/elements/menupopup.js",
       "chrome://global/content/elements/notificationbox.js",
       "chrome://global/content/elements/popupnotification.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -63,17 +63,16 @@ toolkit.jar:
    content/global/widgets.css
    content/global/bindings/autocomplete.xml    (widgets/autocomplete.xml)
    content/global/bindings/calendar.js         (widgets/calendar.js)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
-   content/global/bindings/scrollbox.xml       (widgets/scrollbox.xml)
    content/global/bindings/spinner.js          (widgets/spinner.js)
    content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/elements/autocomplete-popup.js              (widgets/autocomplete-popup.js)
    content/global/elements/autocomplete-richlistitem.js       (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
    content/global/elements/button.js           (widgets/button.js)
@@ -88,16 +87,17 @@ toolkit.jar:
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
    content/global/elements/marquee.css         (widgets/marquee.css)
    content/global/elements/marquee.js          (widgets/marquee.js)
    content/global/elements/menulist.js         (widgets/menulist.js)
    content/global/elements/popupnotification.js  (widgets/popupnotification.js)
+   content/global/elements/arrowscrollbox.js     (widgets/arrowscrollbox.js)
    content/global/elements/search-textbox.js     (widgets/search-textbox.js)
    content/global/elements/stringbundle.js     (widgets/stringbundle.js)
    content/global/elements/tabbox.js           (widgets/tabbox.js)
    content/global/elements/text.js             (widgets/text.js)
    content/global/elements/textbox.js          (widgets/textbox.js)
    content/global/elements/toolbarbutton.js    (widgets/toolbarbutton.js)
    content/global/elements/videocontrols.js    (widgets/videocontrols.js)
    content/global/elements/tree.js             (widgets/tree.js)
diff --git a/toolkit/content/widgets/scrollbox.xml b/toolkit/content/widgets/arrowscrollbox.js
rename from toolkit/content/widgets/scrollbox.xml
rename to toolkit/content/widgets/arrowscrollbox.js
--- a/toolkit/content/widgets/scrollbox.xml
+++ b/toolkit/content/widgets/arrowscrollbox.js
@@ -1,695 +1,93 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-
-<bindings id="arrowscrollboxBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
-
-  <binding id="arrowscrollbox" extends="chrome://global/content/bindings/general.xml#basecontrol">
-    <content>
-      <xul:toolbarbutton class="scrollbutton-up"
-                         anonid="scrollbutton-up"
-                         xbl:inherits="orient,collapsed=notoverflowing,disabled=scrolledtostart"/>
-      <xul:spacer class="arrowscrollbox-overflow-start-indicator"
-                  xbl:inherits="collapsed=scrolledtostart"/>
-      <xul:scrollbox class="arrowscrollbox-scrollbox"
-                     anonid="scrollbox"
-                     flex="1"
-                     xbl:inherits="orient,align,pack,dir,smoothscroll">
-        <children/>
-      </xul:scrollbox>
-      <xul:spacer class="arrowscrollbox-overflow-end-indicator"
-                  xbl:inherits="collapsed=scrolledtoend"/>
-      <xul:toolbarbutton class="scrollbutton-down"
-                         anonid="scrollbutton-down"
-                         xbl:inherits="orient,collapsed=notoverflowing,disabled=scrolledtoend"/>
-    </content>
-
-    <implementation>
-      <constructor><![CDATA[
-        if (!this.hasAttribute("smoothscroll")) {
-          this.smoothScroll = this._prefBranch
-                                  .getBoolPref("toolkit.scrollbox.smoothScroll", true);
-        }
-
-        this.setAttribute("notoverflowing", "true");
-        this._updateScrollButtonsDisabledState();
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-        // Ultimately Bug 1514926 will convert arrowscrollbox binding to a custom element.
-        // For the needs of Bug 1497189, where we apply a custom CSP to about:addons, we had
-        // to remove inline handlers and hence added event listeners for mouse events here.
-        this.addEventListener("click", (e) => {
-          if (e.originalTarget != this._scrollButtonUp && e.originalTarget != this._scrollButtonDown) {
-            return;
-          }
-          this._onButtonClick(e);
-        });
-        this.addEventListener("mousedown", (e) => {
-          if (e.originalTarget == this._scrollButtonUp) {
-            this._onButtonMouseDown(e, -1);
-          }
-          if (e.originalTarget == this._scrollButtonDown) {
-            this._onButtonMouseDown(e, 1);
-          }
-        });
-        this.addEventListener("mouseup", (e) => {
-          if (e.originalTarget != this._scrollButtonUp && e.originalTarget != this._scrollButtonDown) {
-            return;
-          }
-          this._onButtonMouseUp(e);
-        });
-        this.addEventListener("mouseover", (e) => {
-          if (e.originalTarget == this._scrollButtonUp) {
-            this._onButtonMouseOver(-1);
-          }
-          if (e.originalTarget == this._scrollButtonDown) {
-            this._onButtonMouseOver(1);
-          }
-        });
-        this.addEventListener("mouseout", (e) => {
-          if (e.originalTarget != this._scrollButtonUp && e.originalTarget != this._scrollButtonDown) {
-            return;
-          }
-          this._onButtonMouseOut();
-        });
-      ]]></constructor>
-
-      <destructor><![CDATA[
-        // Release timer to avoid reference cycles.
-        if (this._scrollTimer) {
-          this._scrollTimer.cancel();
-          this._scrollTimer = null;
-        }
-      ]]></destructor>
-
-      <field name="scrollbox">
-        document.getAnonymousElementByAttribute(this, "anonid", "scrollbox");
-      </field>
-      <field name="_scrollButtonUp">
-        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up");
-      </field>
-      <field name="_scrollButtonDown">
-        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down");
-      </field>
-
-      <field name="_scrollIndex">0</field>
-
-      <field name="_arrowScrollAnim"><![CDATA[({
-        scrollbox: this,
-        requestHandle: 0, /* 0 indicates there is no pending request */
-        start: function arrowSmoothScroll_start() {
-          this.lastFrameTime = window.performance.now();
-          if (!this.requestHandle)
-            this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));
-        },
-        stop: function arrowSmoothScroll_stop() {
-          window.cancelAnimationFrame(this.requestHandle);
-          this.requestHandle = 0;
-        },
-        sample: function arrowSmoothScroll_handleEvent(timeStamp) {
-          const scrollIndex = this.scrollbox._scrollIndex;
-          const timePassed = timeStamp - this.lastFrameTime;
-          this.lastFrameTime = timeStamp;
-
-          const scrollDelta = 0.5 * timePassed * scrollIndex;
-          this.scrollbox.scrollByPixels(scrollDelta, true);
-          this.requestHandle = window.requestAnimationFrame(this.sample.bind(this));
-        },
-      })]]></field>
-
-      <property name="_clickToScroll" readonly="true">
-        <getter><![CDATA[
-          return this.hasAttribute("clicktoscroll");
-        ]]></getter>
-      </property>
-
-      <property name="_scrollDelay" readonly="true">
-        <getter><![CDATA[
-          if (this._clickToScroll) {
-            return this._prefBranch.getIntPref(
-                            "toolkit.scrollbox.clickToScroll.scrollDelay", 150);
-          }
-
-          // Use the same REPEAT_DELAY as "nsRepeatService.h".
-          return /Mac/.test(navigator.platform) ? 25 : 50;
-        ]]></getter>
-      </property>
-
-      <field name="__prefBranch">null</field>
-      <property name="_prefBranch" readonly="true">
-        <getter><![CDATA[
-          if (this.__prefBranch === null) {
-            this.__prefBranch = Cc["@mozilla.org/preferences-service;1"]
-                                  .getService(Ci.nsIPrefBranch);
-          }
-          return this.__prefBranch;
-        ]]></getter>
-      </property>
+"use strict";
 
-      <field name="_scrollIncrement">null</field>
-      <property name="scrollIncrement" readonly="true">
-        <getter><![CDATA[
-          if (this._scrollIncrement === null) {
-            this._scrollIncrement = this._prefBranch
-                                        .getIntPref("toolkit.scrollbox.scrollIncrement", 20);
-          }
-          return this._scrollIncrement;
-        ]]></getter>
-      </property>
-
-      <property name="smoothScroll">
-        <getter><![CDATA[
-          return this.getAttribute("smoothscroll") == "true";
-        ]]></getter>
-        <setter><![CDATA[
-          this.setAttribute("smoothscroll", !!val);
-          return val;
-        ]]></setter>
-      </property>
-
-      <property name="scrollClientRect" readonly="true">
-        <getter><![CDATA[
-          return this.scrollbox.getBoundingClientRect();
-        ]]></getter>
-      </property>
-
-      <property name="scrollClientSize" readonly="true">
-        <getter><![CDATA[
-          return this.orient == "vertical" ?
-                 this.scrollbox.clientHeight :
-                 this.scrollbox.clientWidth;
-        ]]></getter>
-      </property>
-
-      <property name="scrollSize" readonly="true">
-        <getter><![CDATA[
-          return this.orient == "vertical" ?
-                 this.scrollbox.scrollHeight :
-                 this.scrollbox.scrollWidth;
-        ]]></getter>
-      </property>
-
-      <property name="lineScrollAmount" readonly="true">
-        <getter><![CDATA[
-          // line scroll amout should be the width (at horizontal scrollbox) or
-          // the height (at vertical scrollbox) of the scrolled elements.
-          // However, the elements may have different width or height.  So,
-          // for consistent speed, let's use avalage with of the elements.
-          var elements = this._getScrollableElements();
-          return elements.length && (this.scrollSize / elements.length);
-        ]]></getter>
-      </property>
-
-      <property name="scrollPosition" readonly="true">
-        <getter><![CDATA[
-          return this.orient == "vertical" ?
-                 this.scrollbox.scrollTop :
-                 this.scrollbox.scrollLeft;
-        ]]></getter>
-      </property>
-
-      <field name="_startEndProps"><![CDATA[
-        this.orient == "vertical" ? ["top", "bottom"] : ["left", "right"];
-      ]]></field>
-
-      <field name="_isRTLScrollbox"><![CDATA[
-        this.orient != "vertical" &&
-        document.defaultView.getComputedStyle(this.scrollbox).direction == "rtl";
-      ]]></field>
-
-      <method name="_onButtonClick">
-        <parameter name="event"/>
-        <body><![CDATA[
-          if (this._clickToScroll) {
-            this._distanceScroll(event);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_onButtonMouseDown">
-        <parameter name="event"/>
-        <parameter name="index"/>
-        <body><![CDATA[
-          if (this._clickToScroll && event.button == 0) {
-            this._startScroll(index);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_onButtonMouseUp">
-        <parameter name="event"/>
-        <body><![CDATA[
-          if (this._clickToScroll && event.button == 0) {
-            this._stopScroll();
-          }
-        ]]></body>
-      </method>
-
-      <method name="_onButtonMouseOver">
-        <parameter name="index"/>
-        <body><![CDATA[
-          if (this._clickToScroll) {
-            this._continueScroll(index);
-          } else {
-            this._startScroll(index);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_onButtonMouseOut">
-        <parameter name="index"/>
-        <body><![CDATA[
-          if (this._clickToScroll) {
-            this._pauseScroll();
-          } else {
-            this._stopScroll();
-          }
-        ]]></body>
-      </method>
-
-      <method name="_boundsWithoutFlushing">
-        <parameter name="element"/>
-        <body><![CDATA[
-          if (!("_DOMWindowUtils" in this)) {
-            this._DOMWindowUtils = window.windowUtils;
-          }
-
-          return this._DOMWindowUtils ?
-                 this._DOMWindowUtils.getBoundsWithoutFlushing(element) :
-                 element.getBoundingClientRect();
-        ]]></body>
-      </method>
-
-      <method name="_canScrollToElement">
-        <parameter name="element"/>
-        <body><![CDATA[
-          if (element.hidden) {
-            return false;
-          }
-
-          // See if the element is hidden via CSS without the hidden attribute.
-          // If we get only zeros for the client rect, this means the element
-          // is hidden. As a performance optimization, we don't flush layout
-          // here which means that on the fly changes aren't fully supported.
-          let rect = this._boundsWithoutFlushing(element);
-          return !!(rect.top || rect.left || rect.width || rect.height);
-        ]]></body>
-      </method>
-
-      <field name="_ensureElementIsVisibleAnimationFrame">0</field>
-      <method name="ensureElementIsVisible">
-        <parameter name="element"/>
-        <parameter name="aInstant"/>
-        <body><![CDATA[
-          if (!this._canScrollToElement(element))
-            return;
-
-          if (this._ensureElementIsVisibleAnimationFrame) {
-            window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);
-          }
-          this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(() => {
-            element.scrollIntoView({ block: "nearest",
-                                     behavior: aInstant ? "instant" : "auto" });
-            this._ensureElementIsVisibleAnimationFrame = 0;
-          });
-        ]]></body>
-      </method>
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+  const { Services } = ChromeUtils.import(
+    "resource://gre/modules/Services.jsm"
+  );
 
-      <method name="scrollByIndex">
-        <parameter name="index"/>
-        <parameter name="aInstant"/>
-        <body><![CDATA[
-          if (index == 0)
-            return;
-
-          var rect = this.scrollClientRect;
-          var [start, end] = this._startEndProps;
-          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;
-          var nextElement = this._elementFromPoint(x, index);
-          if (!nextElement)
-            return;
-
-          var targetElement;
-          if (this._isRTLScrollbox)
-            index *= -1;
-          while (index < 0 && nextElement) {
-            if (this._canScrollToElement(nextElement))
-              targetElement = nextElement;
-            nextElement = nextElement.previousElementSibling;
-            index++;
-          }
-          while (index > 0 && nextElement) {
-            if (this._canScrollToElement(nextElement))
-              targetElement = nextElement;
-            nextElement = nextElement.nextElementSibling;
-            index--;
-          }
-          if (!targetElement)
-            return;
-
-          this.ensureElementIsVisible(targetElement, aInstant);
-        ]]></body>
-      </method>
-
-      <method name="_getScrollableElements">
-        <body><![CDATA[
-          let nodes = this.children;
-          if (nodes.length == 1) {
-            let node = nodes[0];
-            if (node.localName == "children" &&
-                node.namespaceURI == "http://www.mozilla.org/xbl") {
-              nodes = document.getBindingParent(this).children;
-            } else if (node.localName == "slot" &&
-                       node.namespaceURI == "http://www.w3.org/1999/xhtml") {
-              nodes = node.getRootNode().host.children;
-            }
-          }
-
-          return Array.prototype.filter.call(nodes, this._canScrollToElement, this);
-        ]]></body>
-      </method>
-
-      <method name="_elementFromPoint">
-        <parameter name="aX"/>
-        <parameter name="aPhysicalScrollDir"/>
-        <body><![CDATA[
-          var elements = this._getScrollableElements();
-          if (!elements.length)
-            return null;
-
-          if (this._isRTLScrollbox)
-            elements.reverse();
-
-          var [start, end] = this._startEndProps;
-          var low = 0;
-          var high = elements.length - 1;
-
-          if (aX < elements[low].getBoundingClientRect()[start] ||
-              aX > elements[high].getBoundingClientRect()[end])
-            return null;
-
-          var mid, rect;
-          while (low <= high) {
-            mid = Math.floor((low + high) / 2);
-            rect = elements[mid].getBoundingClientRect();
-            if (rect[start] > aX)
-              high = mid - 1;
-            else if (rect[end] < aX)
-              low = mid + 1;
-            else
-              return elements[mid];
-          }
-
-          // There's no element at the requested coordinate, but the algorithm
-          // from above yields an element next to it, in a random direction.
-          // The desired scrolling direction leads to the correct element.
-
-          if (!aPhysicalScrollDir)
-            return null;
-
-          if (aPhysicalScrollDir < 0 && rect[start] > aX)
-            mid = Math.max(mid - 1, 0);
-          else if (aPhysicalScrollDir > 0 && rect[end] < aX)
-            mid = Math.min(mid + 1, elements.length - 1);
-
-          return elements[mid];
-        ]]></body>
-      </method>
-
-      <method name="_startScroll">
-        <parameter name="index"/>
-        <body><![CDATA[
-          if (this._isRTLScrollbox) {
-            index *= -1;
-          }
-
-          if (this._clickToScroll) {
-            this._scrollIndex = index;
-            this._mousedown = true;
-
-            if (this.smoothScroll) {
-              this._arrowScrollAnim.start();
-              return;
-            }
-          }
-
-          if (!this._scrollTimer) {
-            this._scrollTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-          } else {
-            this._scrollTimer.cancel();
-          }
-
-          let callback;
-          if (this._clickToScroll) {
-            callback = () => {
-              if (!document && this._scrollTimer) {
-                this._scrollTimer.cancel();
-              }
-              this.scrollByIndex(this._scrollIndex);
-            };
-          } else {
-            callback = () => this.scrollByPixels(this.scrollIncrement * index);
-          }
-
-          this._scrollTimer.initWithCallback(callback, this._scrollDelay,
-                                             Ci.nsITimer.TYPE_REPEATING_SLACK);
-
-          callback();
-        ]]>
-        </body>
-      </method>
-
-      <method name="_stopScroll">
-        <body><![CDATA[
-          if (this._scrollTimer)
-            this._scrollTimer.cancel();
-
-          if (this._clickToScroll) {
-            this._mousedown = false;
-            if (!this._scrollIndex || !this.smoothScroll)
-              return;
-
-            this.scrollByIndex(this._scrollIndex);
-            this._scrollIndex = 0;
-
-            this._arrowScrollAnim.stop();
-          }
-        ]]></body>
-      </method>
+  class MozArrowScrollbox extends MozElements.BaseControl {
+    constructor() {
+      super();
+      this.attachShadow({ mode: "open" });
+      this.shadowRoot.appendChild(
+        MozXULElement.parseXULToFragment(`
+      <html:link rel="stylesheet" href="chrome://global/skin/global.css"/>
+      <toolbarbutton class="scrollbutton-up" part="scrollbutton-up"/>
+      <spacer part="arrowscrollbox-overflow-start-indicator"></spacer>
+      <scrollbox class="arrowscrollbox-scrollbox" part="scrollbox" flex="1">
+        <html:slot></html:slot>
+      </scrollbox>
+      <spacer part="arrowscrollbox-overflow-end-indicator"></spacer>
+      <toolbarbutton class="scrollbutton-down" part="scrollbutton-down"/>
+    `)
+      );
 
-      <method name="_pauseScroll">
-        <body><![CDATA[
-          if (this._mousedown) {
-            this._stopScroll();
-            this._mousedown = true;
-            document.addEventListener("mouseup", this);
-            document.addEventListener("blur", this, true);
-          }
-        ]]></body>
-      </method>
-
-      <method name="_continueScroll">
-        <parameter name="index"/>
-        <body><![CDATA[
-          if (this._mousedown)
-            this._startScroll(index);
-        ]]></body>
-      </method>
-
-      <method name="_distanceScroll">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          if (aEvent.detail < 2 || aEvent.detail > 3)
-            return;
-
-          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);
-          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;
-          var targetElement;
-
-          if (aEvent.detail == 2) {
-            // scroll by the size of the scrollbox
-            let [start, end] = this._startEndProps;
-            let x;
-            if (scrollLeftOrUp)
-              x = this.scrollClientRect[start] - this.scrollClientSize;
-            else
-              x = this.scrollClientRect[end] + this.scrollClientSize;
-            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);
-
-            // the next partly-hidden element will become fully visible,
-            // so don't scroll too far
-            if (targetElement)
-              targetElement = scrollBack ?
-                              targetElement.nextElementSibling :
-                              targetElement.previousElementSibling;
-          }
-
-          if (!targetElement) {
-            // scroll to the first resp. last element
-            let elements = this._getScrollableElements();
-            targetElement = scrollBack ?
-                            elements[0] :
-                            elements[elements.length - 1];
-          }
-
-          this.ensureElementIsVisible(targetElement);
-        ]]></body>
-      </method>
-
-      <method name="handleEvent">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          if (aEvent.type == "mouseup" ||
-              aEvent.type == "blur" && aEvent.target == document) {
-            this._mousedown = false;
-            document.removeEventListener("mouseup", this);
-            document.removeEventListener("blur", this, true);
-          }
-        ]]></body>
-      </method>
-
-      <method name="scrollByPixels">
-        <parameter name="aPixels"/>
-        <parameter name="aInstant"/>
-        <body><![CDATA[
-          let scrollOptions = { behavior: aInstant ? "instant" : "auto" };
-          scrollOptions[this._startEndProps[0]] = aPixels;
-          this.scrollbox.scrollBy(scrollOptions);
-        ]]></body>
-      </method>
+      this.scrollbox = this.shadowRoot.querySelector(
+        ".arrowscrollbox-scrollbox"
+      );
+      this._scrollButtonUp = this.shadowRoot.querySelector(".scrollbutton-up");
+      this._scrollButtonDown = this.shadowRoot.querySelector(
+        ".scrollbutton-down"
+      );
 
-      <field name="_prevMouseScrolls">[null, null]</field>
-
-      <field name="_touchStart">-1</field>
-
-      <field name="_scrollButtonUpdatePending">false</field>
-      <method name="_updateScrollButtonsDisabledState">
-        <body><![CDATA[
-          if (this.hasAttribute("notoverflowing")) {
-            this.setAttribute("scrolledtoend", "true");
-            this.setAttribute("scrolledtostart", "true");
-            return;
-          }
-
-          if (this._scrollButtonUpdatePending) {
-            return;
-          }
-          this._scrollButtonUpdatePending = true;
-
-          // Wait until after the next paint to get current layout data from
-          // getBoundsWithoutFlushing.
-          window.requestAnimationFrame(() => {
-            setTimeout(() => {
-              if (!this._startEndProps) {
-                // We've been destroyed in the meantime.
-                return;
-              }
-
-              this._scrollButtonUpdatePending = false;
-
-              let scrolledToStart = false;
-              let scrolledToEnd = false;
-
-              if (this.hasAttribute("notoverflowing")) {
-                scrolledToStart = true;
-                scrolledToEnd = true;
-              } else {
-                let [leftOrTop, rightOrBottom] = this._startEndProps;
-                let leftOrTopEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);
-                let rightOrBottomEdge = ele => Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);
-
-                let elements = this._getScrollableElements();
-                let [leftOrTopElement, rightOrBottomElement] = [elements[0], elements[elements.length - 1]];
-                if (this._isRTLScrollbox) {
-                  [leftOrTopElement, rightOrBottomElement] = [rightOrBottomElement, leftOrTopElement];
-                }
-
-                if (leftOrTopElement &&
-                    leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)) {
-                  scrolledToStart = !this._isRTLScrollbox;
-                  scrolledToEnd = this._isRTLScrollbox;
-                } else if (rightOrBottomElement &&
-                           rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this.scrollbox)) {
-                  scrolledToStart = this._isRTLScrollbox;
-                  scrolledToEnd = !this._isRTLScrollbox;
-                }
-              }
-
-              if (scrolledToEnd) {
-                this.setAttribute("scrolledtoend", "true");
-              } else {
-                this.removeAttribute("scrolledtoend");
-              }
-
-              if (scrolledToStart) {
-                this.setAttribute("scrolledtostart", "true");
-              } else {
-                this.removeAttribute("scrolledtostart");
-              }
-            }, 0);
-          });
-        ]]></body>
-      </method>
-
-      <field name="_isScrolling">false</field>
-      <field name="_destination">0</field>
-      <field name="_direction">0</field>
-    </implementation>
-
-    <handlers>
-      <handler event="wheel"><![CDATA[
+      this.addEventListener("wheel", event => {
         // Don't consume the event if we can't scroll.
         if (this.hasAttribute("notoverflowing")) {
           return;
         }
 
         let doScroll = false;
         let instant;
         let scrollAmount = 0;
         if (this.orient == "vertical") {
           doScroll = true;
-          if (event.deltaMode == event.DOM_DELTA_PIXEL)
+          if (event.deltaMode == event.DOM_DELTA_PIXEL) {
             scrollAmount = event.deltaY;
-          else if (event.deltaMode == event.DOM_DELTA_PAGE)
+          } else if (event.deltaMode == event.DOM_DELTA_PAGE) {
             scrollAmount = event.deltaY * this.scrollClientSize;
-          else
+          } else {
             scrollAmount = event.deltaY * this.lineScrollAmount;
+          }
         } else {
           // We allow vertical scrolling to scroll a horizontal scrollbox
           // because many users have a vertical scroll wheel but no
           // horizontal support.
           // Because of this, we need to avoid scrolling chaos on trackpads
           // and mouse wheels that support simultaneous scrolling in both axes.
           // We do this by scrolling only when the last two scroll events were
           // on the same axis as the current scroll event.
           // For diagonal scroll events we only respect the dominant axis.
           let isVertical = Math.abs(event.deltaY) > Math.abs(event.deltaX);
           let delta = isVertical ? event.deltaY : event.deltaX;
-          let scrollByDelta = isVertical && this._isRTLScrollbox ? -delta : delta;
+          let scrollByDelta =
+            isVertical && this._isRTLScrollbox ? -delta : delta;
 
           if (this._prevMouseScrolls.every(prev => prev == isVertical)) {
             doScroll = true;
             if (event.deltaMode == event.DOM_DELTA_PIXEL) {
               scrollAmount = scrollByDelta;
               instant = true;
             } else if (event.deltaMode == event.DOM_DELTA_PAGE) {
               scrollAmount = scrollByDelta * this.scrollClientSize;
             } else {
               scrollAmount = scrollByDelta * this.lineScrollAmount;
             }
           }
 
-          if (this._prevMouseScrolls.length > 1)
+          if (this._prevMouseScrolls.length > 1) {
             this._prevMouseScrolls.shift();
+          }
           this._prevMouseScrolls.push(isVertical);
         }
 
         if (doScroll) {
           let direction = scrollAmount < 0 ? -1 : 1;
           let startPos = this.scrollPosition;
 
           if (!this._isScrolling || this._direction != direction) {
@@ -700,107 +98,729 @@
             this._destination = this._destination + scrollAmount;
             scrollAmount = this._destination - startPos;
           }
           this.scrollByPixels(scrollAmount, instant);
         }
 
         event.stopPropagation();
         event.preventDefault();
-      ]]></handler>
+      });
 
-      <handler event="touchstart"><![CDATA[
+      this.addEventListener("touchstart", event => {
         if (event.touches.length > 1) {
           // Multiple touch points detected, abort. In particular this aborts
           // the panning gesture when the user puts a second finger down after
           // already panning with one finger. Aborting at this point prevents
           // the pan gesture from being resumed until all fingers are lifted
           // (as opposed to when the user is back down to one finger).
           this._touchStart = -1;
         } else {
-          this._touchStart = (this.orient == "vertical"
-                ? event.touches[0].screenY
-                : event.touches[0].screenX);
+          this._touchStart =
+            this.orient == "vertical"
+              ? event.touches[0].screenY
+              : event.touches[0].screenX;
         }
-      ]]></handler>
+      });
 
-      <handler event="touchmove"><![CDATA[
-        if (event.touches.length == 1 &&
-            this._touchStart >= 0) {
-          var touchPoint = (this.orient == "vertical"
-                ? event.touches[0].screenY
-                : event.touches[0].screenX);
+      this.addEventListener("touchmove", event => {
+        if (event.touches.length == 1 && this._touchStart >= 0) {
+          var touchPoint =
+            this.orient == "vertical"
+              ? event.touches[0].screenY
+              : event.touches[0].screenX;
           var delta = this._touchStart - touchPoint;
           if (Math.abs(delta) > 0) {
             this.scrollByPixels(delta, true);
             this._touchStart = touchPoint;
           }
           event.preventDefault();
         }
-      ]]></handler>
+      });
+
+      this.addEventListener("touchend", event => {
+        this._touchStart = -1;
+      });
+
+      this.shadowRoot.addEventListener(
+        "underflow",
+        event => {
+          // Ignore underflow events:
+          // - from nested scrollable elements
+          // - corresponding to an overflow event that we ignored
+          if (
+            event.target != this.scrollbox ||
+            this.hasAttribute("notoverflowing")
+          ) {
+            return;
+          }
 
-      <handler event="touchend"><![CDATA[
-        this._touchStart = -1;
-      ]]></handler>
+          // Ignore events that doesn't match our orientation.
+          // Scrollport event orientation:
+          //   0: vertical
+          //   1: horizontal
+          //   2: both
+          if (this.orient == "vertical") {
+            if (event.detail == 1) {
+              return;
+            }
+          } else if (event.detail == 0) {
+            // horizontal scrollbox
+            return;
+          }
+
+          this.setAttribute("notoverflowing", "true");
+          this._updateScrollButtonsDisabledState();
+        },
+        true
+      );
+
+      this.shadowRoot.addEventListener(
+        "overflow",
+        event => {
+          // Ignore overflow events:
+          // - from nested scrollable elements
+          if (event.target != this.scrollbox) {
+            return;
+          }
 
-      <handler event="underflow" phase="capturing"><![CDATA[
-        // Ignore underflow events:
-        // - from nested scrollable elements
-        // - corresponding to an overflow event that we ignored
-        if (event.target != this ||
-            this.hasAttribute("notoverflowing")) {
+          // Ignore events that doesn't match our orientation.
+          // Scrollport event orientation:
+          //   0: vertical
+          //   1: horizontal
+          //   2: both
+          if (this.orient == "vertical") {
+            if (event.detail == 1) {
+              return;
+            }
+          } else if (event.detail == 0) {
+            // horizontal scrollbox
+            return;
+          }
+
+          this.removeAttribute("notoverflowing");
+          this._updateScrollButtonsDisabledState();
+        },
+        true
+      );
+
+      this.shadowRoot.addEventListener("scroll", event => {
+        this._isScrolling = true;
+        this._updateScrollButtonsDisabledState();
+      });
+
+      this.shadowRoot.addEventListener("scrollend", event => {
+        this._isScrolling = false;
+        this._destination = 0;
+        this._direction = 0;
+      });
+
+      // Ultimately Bug 1514926 will convert arrowscrollbox binding to a custom element.
+      // For the needs of Bug 1497189, where we apply a custom CSP to about:addons, we had
+      // to remove inline handlers and hence added event listeners for mouse events here.
+      this.shadowRoot.addEventListener("click", e => {
+        if (
+          e.originalTarget != this._scrollButtonUp &&
+          e.originalTarget != this._scrollButtonDown
+        ) {
+          return;
+        }
+        this._onButtonClick(e);
+      });
+      this.shadowRoot.addEventListener("mousedown", e => {
+        if (e.originalTarget == this._scrollButtonUp) {
+          this._onButtonMouseDown(e, -1);
+        }
+        if (e.originalTarget == this._scrollButtonDown) {
+          this._onButtonMouseDown(e, 1);
+        }
+      });
+      this.shadowRoot.addEventListener("mouseup", e => {
+        if (
+          e.originalTarget != this._scrollButtonUp &&
+          e.originalTarget != this._scrollButtonDown
+        ) {
+          return;
+        }
+        this._onButtonMouseUp(e);
+      });
+      this.shadowRoot.addEventListener("mouseover", e => {
+        if (e.originalTarget == this._scrollButtonUp) {
+          this._onButtonMouseOver(-1);
+        }
+        if (e.originalTarget == this._scrollButtonDown) {
+          this._onButtonMouseOver(1);
+        }
+      });
+      this.shadowRoot.addEventListener("mouseout", e => {
+        if (
+          e.originalTarget != this._scrollButtonUp &&
+          e.originalTarget != this._scrollButtonDown
+        ) {
           return;
         }
+        this._onButtonMouseOut();
+      });
+    }
 
-        // Ignore events that doesn't match our orientation.
-        // Scrollport event orientation:
-        //   0: vertical
-        //   1: horizontal
-        //   2: both
-        if (this.orient == "vertical") {
-          if (event.detail == 1)
-            return;
-        } else if (event.detail == 0) {
-          // horizontal scrollbox
+    static get inheritedAttributes() {
+      return {
+        ".scrollbutton-up":
+          "orient,collapsed=notoverflowing,disabled=scrolledtostart",
+        ".arrowscrollbox-overflow-start-indicator": "collapsed=scrolledtostart",
+        ".arrowscrollbox-scrollbox": "orient,align,pack,dir,smoothscroll",
+        ".arrowscrollbox-overflow-end-indicator": "collapsed=scrolledtoend",
+        ".scrollbutton-down":
+          "orient,collapsed=notoverflowing,disabled=scrolledtoend",
+      };
+    }
+
+    connectedCallback() {
+      if (this.hasConnected) {
+        return;
+      }
+
+      this.hasConnected = true;
+      this.initializeAttributeInheritance();
+      this._scrollIndex = 0;
+
+      this._arrowScrollAnim = {
+        scrollbox: this,
+        requestHandle: 0,
+        /* 0 indicates there is no pending request */
+        start: function arrowSmoothScroll_start() {
+          this.lastFrameTime = window.performance.now();
+          if (!this.requestHandle) {
+            this.requestHandle = window.requestAnimationFrame(
+              this.sample.bind(this)
+            );
+          }
+        },
+        stop: function arrowSmoothScroll_stop() {
+          window.cancelAnimationFrame(this.requestHandle);
+          this.requestHandle = 0;
+        },
+        sample: function arrowSmoothScroll_handleEvent(timeStamp) {
+          const scrollIndex = this.scrollbox._scrollIndex;
+          const timePassed = timeStamp - this.lastFrameTime;
+          this.lastFrameTime = timeStamp;
+
+          const scrollDelta = 0.5 * timePassed * scrollIndex;
+          this.scrollbox.scrollByPixels(scrollDelta, true);
+          this.requestHandle = window.requestAnimationFrame(
+            this.sample.bind(this)
+          );
+        },
+      };
+
+      this._scrollIncrement = null;
+
+      this._startEndProps =
+        this.orient == "vertical" ? ["top", "bottom"] : ["left", "right"];
+
+      this._isRTLScrollbox =
+        this.orient != "vertical" &&
+        document.defaultView.getComputedStyle(this.scrollbox).direction ==
+          "rtl";
+
+      this._ensureElementIsVisibleAnimationFrame = 0;
+
+      this._prevMouseScrolls = [null, null];
+
+      this._touchStart = -1;
+
+      this._scrollButtonUpdatePending = false;
+
+      this._isScrolling = false;
+
+      this._destination = 0;
+
+      this._direction = 0;
+
+      if (!this.hasAttribute("smoothscroll")) {
+        this.smoothScroll = Services.prefs.getBoolPref(
+          "toolkit.scrollbox.smoothScroll",
+          true
+        );
+      }
+
+      this.setAttribute("notoverflowing", "true");
+      this._updateScrollButtonsDisabledState();
+    }
+
+    get _clickToScroll() {
+      return this.hasAttribute("clicktoscroll");
+    }
+
+    get _scrollDelay() {
+      if (this._clickToScroll) {
+        return Services.prefs.getIntPref(
+          "toolkit.scrollbox.clickToScroll.scrollDelay",
+          150
+        );
+      }
+
+      // Use the same REPEAT_DELAY as "nsRepeatService.h".
+      return /Mac/.test(navigator.platform) ? 25 : 50;
+    }
+
+    get scrollIncrement() {
+      if (this._scrollIncrement === null) {
+        this._scrollIncrement = Services.prefs.getIntPref(
+          "toolkit.scrollbox.scrollIncrement",
+          20
+        );
+      }
+      return this._scrollIncrement;
+    }
+
+    set smoothScroll(val) {
+      this.setAttribute("smoothscroll", !!val);
+      return val;
+    }
+
+    get smoothScroll() {
+      return this.getAttribute("smoothscroll") == "true";
+    }
+
+    get scrollClientRect() {
+      return this.scrollbox.getBoundingClientRect();
+    }
+
+    get scrollClientSize() {
+      return this.orient == "vertical"
+        ? this.scrollbox.clientHeight
+        : this.scrollbox.clientWidth;
+    }
+
+    get scrollSize() {
+      return this.orient == "vertical"
+        ? this.scrollbox.scrollHeight
+        : this.scrollbox.scrollWidth;
+    }
+
+    get lineScrollAmount() {
+      // line scroll amout should be the width (at horizontal scrollbox) or
+      // the height (at vertical scrollbox) of the scrolled elements.
+      // However, the elements may have different width or height.  So,
+      // for consistent speed, let's use avalage with of the elements.
+      var elements = this._getScrollableElements();
+      return elements.length && this.scrollSize / elements.length;
+    }
+
+    get scrollPosition() {
+      return this.orient == "vertical"
+        ? this.scrollbox.scrollTop
+        : this.scrollbox.scrollLeft;
+    }
+
+    _onButtonClick(event) {
+      if (this._clickToScroll) {
+        this._distanceScroll(event);
+      }
+    }
+
+    _onButtonMouseDown(event, index) {
+      if (this._clickToScroll && event.button == 0) {
+        this._startScroll(index);
+      }
+    }
+
+    _onButtonMouseUp(event) {
+      if (this._clickToScroll && event.button == 0) {
+        this._stopScroll();
+      }
+    }
+
+    _onButtonMouseOver(index) {
+      if (this._clickToScroll) {
+        this._continueScroll(index);
+      } else {
+        this._startScroll(index);
+      }
+    }
+
+    _onButtonMouseOut(index) {
+      if (this._clickToScroll) {
+        this._pauseScroll();
+      } else {
+        this._stopScroll();
+      }
+    }
+
+    _boundsWithoutFlushing(element) {
+      if (!("_DOMWindowUtils" in this)) {
+        this._DOMWindowUtils = window.windowUtils;
+      }
+
+      return this._DOMWindowUtils
+        ? this._DOMWindowUtils.getBoundsWithoutFlushing(element)
+        : element.getBoundingClientRect();
+    }
+
+    _canScrollToElement(element) {
+      if (element.hidden) {
+        return false;
+      }
+
+      // See if the element is hidden via CSS without the hidden attribute.
+      // If we get only zeros for the client rect, this means the element
+      // is hidden. As a performance optimization, we don't flush layout
+      // here which means that on the fly changes aren't fully supported.
+      let rect = this._boundsWithoutFlushing(element);
+      return !!(rect.top || rect.left || rect.width || rect.height);
+    }
+
+    ensureElementIsVisible(element, aInstant) {
+      if (!this._canScrollToElement(element)) {
+        return;
+      }
+
+      if (this._ensureElementIsVisibleAnimationFrame) {
+        window.cancelAnimationFrame(this._ensureElementIsVisibleAnimationFrame);
+      }
+      this._ensureElementIsVisibleAnimationFrame = window.requestAnimationFrame(
+        () => {
+          element.scrollIntoView({
+            block: "nearest",
+            behavior: aInstant ? "instant" : "auto",
+          });
+          this._ensureElementIsVisibleAnimationFrame = 0;
+        }
+      );
+    }
+
+    scrollByIndex(index, aInstant) {
+      if (index == 0) {
+        return;
+      }
+
+      var rect = this.scrollClientRect;
+      var [start, end] = this._startEndProps;
+      var x = index > 0 ? rect[end] + 1 : rect[start] - 1;
+      var nextElement = this._elementFromPoint(x, index);
+      if (!nextElement) {
+        return;
+      }
+
+      var targetElement;
+      if (this._isRTLScrollbox) {
+        index *= -1;
+      }
+      while (index < 0 && nextElement) {
+        if (this._canScrollToElement(nextElement)) {
+          targetElement = nextElement;
+        }
+        nextElement = nextElement.previousElementSibling;
+        index++;
+      }
+      while (index > 0 && nextElement) {
+        if (this._canScrollToElement(nextElement)) {
+          targetElement = nextElement;
+        }
+        nextElement = nextElement.nextElementSibling;
+        index--;
+      }
+      if (!targetElement) {
+        return;
+      }
+
+      this.ensureElementIsVisible(targetElement, aInstant);
+    }
+
+    _getScrollableElements() {
+      let nodes = this.children;
+      if (nodes.length == 1) {
+        let node = nodes[0];
+        if (
+          node.localName == "children" &&
+          node.namespaceURI == "http://www.mozilla.org/xbl"
+        ) {
+          nodes = document.getBindingParent(this).children;
+        } else if (
+          node.localName == "slot" &&
+          node.namespaceURI == "http://www.w3.org/1999/xhtml"
+        ) {
+          nodes = node.getRootNode().host.children;
+        }
+      }
+      return Array.prototype.filter.call(nodes, this._canScrollToElement, this);
+    }
+
+    _elementFromPoint(aX, aPhysicalScrollDir) {
+      var elements = this._getScrollableElements();
+      if (!elements.length) {
+        return null;
+      }
+
+      if (this._isRTLScrollbox) {
+        elements.reverse();
+      }
+
+      var [start, end] = this._startEndProps;
+      var low = 0;
+      var high = elements.length - 1;
+
+      if (
+        aX < elements[low].getBoundingClientRect()[start] ||
+        aX > elements[high].getBoundingClientRect()[end]
+      ) {
+        return null;
+      }
+
+      var mid, rect;
+      while (low <= high) {
+        mid = Math.floor((low + high) / 2);
+        rect = elements[mid].getBoundingClientRect();
+        if (rect[start] > aX) {
+          high = mid - 1;
+        } else if (rect[end] < aX) {
+          low = mid + 1;
+        } else {
+          return elements[mid];
+        }
+      }
+
+      // There's no element at the requested coordinate, but the algorithm
+      // from above yields an element next to it, in a random direction.
+      // The desired scrolling direction leads to the correct element.
+
+      if (!aPhysicalScrollDir) {
+        return null;
+      }
+
+      if (aPhysicalScrollDir < 0 && rect[start] > aX) {
+        mid = Math.max(mid - 1, 0);
+      } else if (aPhysicalScrollDir > 0 && rect[end] < aX) {
+        mid = Math.min(mid + 1, elements.length - 1);
+      }
+
+      return elements[mid];
+    }
+
+    _startScroll(index) {
+      if (this._isRTLScrollbox) {
+        index *= -1;
+      }
+
+      if (this._clickToScroll) {
+        this._scrollIndex = index;
+        this._mousedown = true;
+
+        if (this.smoothScroll) {
+          this._arrowScrollAnim.start();
+          return;
+        }
+      }
+
+      if (!this._scrollTimer) {
+        this._scrollTimer = Cc["@mozilla.org/timer;1"].createInstance(
+          Ci.nsITimer
+        );
+      } else {
+        this._scrollTimer.cancel();
+      }
+
+      let callback;
+      if (this._clickToScroll) {
+        callback = () => {
+          if (!document && this._scrollTimer) {
+            this._scrollTimer.cancel();
+          }
+          this.scrollByIndex(this._scrollIndex);
+        };
+      } else {
+        callback = () => this.scrollByPixels(this.scrollIncrement * index);
+      }
+
+      this._scrollTimer.initWithCallback(
+        callback,
+        this._scrollDelay,
+        Ci.nsITimer.TYPE_REPEATING_SLACK
+      );
+
+      callback();
+    }
+
+    _stopScroll() {
+      if (this._scrollTimer) {
+        this._scrollTimer.cancel();
+      }
+
+      if (this._clickToScroll) {
+        this._mousedown = false;
+        if (!this._scrollIndex || !this.smoothScroll) {
           return;
         }
 
-        this.setAttribute("notoverflowing", "true");
-        this._updateScrollButtonsDisabledState();
-      ]]></handler>
+        this.scrollByIndex(this._scrollIndex);
+        this._scrollIndex = 0;
+
+        this._arrowScrollAnim.stop();
+      }
+    }
+
+    _pauseScroll() {
+      if (this._mousedown) {
+        this._stopScroll();
+        this._mousedown = true;
+        document.addEventListener("mouseup", this);
+        document.addEventListener("blur", this, true);
+      }
+    }
+
+    _continueScroll(index) {
+      if (this._mousedown) {
+        this._startScroll(index);
+      }
+    }
+
+    _distanceScroll(aEvent) {
+      if (aEvent.detail < 2 || aEvent.detail > 3) {
+        return;
+      }
+
+      var scrollBack = aEvent.originalTarget == this._scrollButtonUp;
+      var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;
+      var targetElement;
+
+      if (aEvent.detail == 2) {
+        // scroll by the size of the scrollbox
+        let [start, end] = this._startEndProps;
+        let x;
+        if (scrollLeftOrUp) {
+          x = this.scrollClientRect[start] - this.scrollClientSize;
+        } else {
+          x = this.scrollClientRect[end] + this.scrollClientSize;
+        }
+        targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);
 
-      <handler event="overflow" phase="capturing"><![CDATA[
-        // Ignore overflow events:
-        // - from nested scrollable elements
-        if (event.target != this) {
-          return;
+        // the next partly-hidden element will become fully visible,
+        // so don't scroll too far
+        if (targetElement) {
+          targetElement = scrollBack
+            ? targetElement.nextElementSibling
+            : targetElement.previousElementSibling;
         }
+      }
+
+      if (!targetElement) {
+        // scroll to the first resp. last element
+        let elements = this._getScrollableElements();
+        targetElement = scrollBack
+          ? elements[0]
+          : elements[elements.length - 1];
+      }
+
+      this.ensureElementIsVisible(targetElement);
+    }
 
-        // Ignore events that doesn't match our orientation.
-        // Scrollport event orientation:
-        //   0: vertical
-        //   1: horizontal
-        //   2: both
-        if (this.orient == "vertical") {
-          if (event.detail == 1)
+    handleEvent(aEvent) {
+      if (
+        aEvent.type == "mouseup" ||
+        (aEvent.type == "blur" && aEvent.target == document)
+      ) {
+        this._mousedown = false;
+        document.removeEventListener("mouseup", this);
+        document.removeEventListener("blur", this, true);
+      }
+    }
+
+    scrollByPixels(aPixels, aInstant) {
+      let scrollOptions = { behavior: aInstant ? "instant" : "auto" };
+      scrollOptions[this._startEndProps[0]] = aPixels;
+      this.scrollbox.scrollBy(scrollOptions);
+    }
+
+    _updateScrollButtonsDisabledState() {
+      if (this.hasAttribute("notoverflowing")) {
+        this.setAttribute("scrolledtoend", "true");
+        this.setAttribute("scrolledtostart", "true");
+        return;
+      }
+
+      if (this._scrollButtonUpdatePending) {
+        return;
+      }
+      this._scrollButtonUpdatePending = true;
+
+      // Wait until after the next paint to get current layout data from
+      // getBoundsWithoutFlushing.
+      window.requestAnimationFrame(() => {
+        setTimeout(() => {
+          if (!this._startEndProps) {
+            // We've been destroyed in the meantime.
             return;
-        } else if (event.detail == 0) {
-          // horizontal scrollbox
-          return;
-        }
+          }
+
+          this._scrollButtonUpdatePending = false;
+
+          let scrolledToStart = false;
+          let scrolledToEnd = false;
 
-        this.removeAttribute("notoverflowing");
-        this._updateScrollButtonsDisabledState();
-      ]]></handler>
+          if (this.hasAttribute("notoverflowing")) {
+            scrolledToStart = true;
+            scrolledToEnd = true;
+          } else {
+            let [leftOrTop, rightOrBottom] = this._startEndProps;
+            let leftOrTopEdge = ele =>
+              Math.round(this._boundsWithoutFlushing(ele)[leftOrTop]);
+            let rightOrBottomEdge = ele =>
+              Math.round(this._boundsWithoutFlushing(ele)[rightOrBottom]);
+
+            let elements = this._getScrollableElements();
+            let [leftOrTopElement, rightOrBottomElement] = [
+              elements[0],
+              elements[elements.length - 1],
+            ];
+            if (this._isRTLScrollbox) {
+              [leftOrTopElement, rightOrBottomElement] = [
+                rightOrBottomElement,
+                leftOrTopElement,
+              ];
+            }
+
+            // XXX: For some reason the scrolled to start/end detection isn't working with Shadow DOM impl. May
+            // have something do with calls to getBoundsWithoutFlushing, or maybe some missing styles:
+            // console.trace(rightOrBottomElement, rightOrBottomEdge(rightOrBottomElement), rightOrBottomEdge(this.scrollbox), rightOrBottomEdge(rightOrBottomElement) <= rightOrBottomEdge(this.scrollbox));
 
-      <handler event="scroll"><![CDATA[
-        this._isScrolling = true;
-        this._updateScrollButtonsDisabledState();
-      ]]></handler>
+            if (
+              leftOrTopElement &&
+              leftOrTopEdge(leftOrTopElement) >= leftOrTopEdge(this.scrollbox)
+            ) {
+              scrolledToStart = !this._isRTLScrollbox;
+              scrolledToEnd = this._isRTLScrollbox;
+            } else if (
+              rightOrBottomElement &&
+              rightOrBottomEdge(rightOrBottomElement) <=
+                rightOrBottomEdge(this.scrollbox)
+            ) {
+              scrolledToStart = this._isRTLScrollbox;
+              scrolledToEnd = !this._isRTLScrollbox;
+            }
+          }
 
-      <handler event="scrollend"><![CDATA[
-        this._isScrolling = false;
-        this._destination = 0;
-        this._direction = 0;
-      ]]></handler>
-    </handlers>
-  </binding>
-</bindings>
+          if (scrolledToEnd) {
+            this.setAttribute("scrolledtoend", "true");
+          } else {
+            this.removeAttribute("scrolledtoend");
+          }
+
+          if (scrolledToStart) {
+            this.setAttribute("scrolledtostart", "true");
+          } else {
+            this.removeAttribute("scrolledtostart");
+          }
+        }, 0);
+      });
+    }
+
+    disconnectedCallback() {
+      // Release timer to avoid reference cycles.
+      if (this._scrollTimer) {
+        this._scrollTimer.cancel();
+        this._scrollTimer = null;
+      }
+    }
+  }
+
+  customElements.define("arrowscrollbox", MozArrowScrollbox);
+}
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -554,20 +554,16 @@ scrollbox {
   /* This makes it scrollable! */
   overflow: hidden;
 }
 
 scrollbox[smoothscroll=true] {
   scroll-behavior: smooth;
 }
 
-arrowscrollbox {
-  -moz-binding: url("chrome://global/content/bindings/scrollbox.xml#arrowscrollbox");
-}
-
 /********** stringbundle **********/
 
 stringbundle,
 stringbundleset {
   display: none;
 }
 
 /********** dialog **********/
