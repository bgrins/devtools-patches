# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bb75ac297bc82405cc6d613469f3163e6242c012
Bug 1223116 P3 Extend the test to check console messages for more service worker conditions. r=bgrins

diff --git a/devtools/shared/webconsole/test/helper_serviceworker.js b/devtools/shared/webconsole/test/helper_serviceworker.js
--- a/devtools/shared/webconsole/test/helper_serviceworker.js
+++ b/devtools/shared/webconsole/test/helper_serviceworker.js
@@ -1,2 +1,14 @@
+console.log('script evaluation');
 
-console.log("Hello from serviceworker");
+addEventListener('install', function(evt) {
+  console.log('install event');
+});
+
+addEventListener('activate', function(evt) {
+  console.log('activate event');
+});
+
+addEventListener('fetch', function(evt) {
+  console.log('fetch event: ' + evt.request.url);
+  evt.respondWith(new Response('Hello world'));
+});
diff --git a/devtools/shared/webconsole/test/test_console_serviceworker.html b/devtools/shared/webconsole/test/test_console_serviceworker.html
--- a/devtools/shared/webconsole/test/test_console_serviceworker.html
+++ b/devtools/shared/webconsole/test/test_console_serviceworker.html
@@ -9,87 +9,168 @@
      - http://creativecommons.org/publicdomain/zero/1.0/ -->
 </head>
 <body>
 <p>Test for the Console API and Service Workers</p>
 
 <script class="testbody" type="text/javascript;version=1.8">
 SimpleTest.waitForExplicitFinish();
 
-let SERVICE_WORKER_URL = "https://example.com/chrome/devtools/shared/webconsole/test/helper_serviceworker.js";
-let FRAME_URL = "https://example.com/chrome/devtools/shared/webconsole/test/sandboxed_iframe.html";
+let BASE_URL = "https://example.com/chrome/devtools/shared/webconsole/test/";
+let SERVICE_WORKER_URL = BASE_URL + "helper_serviceworker.js";
+let SCOPE = BASE_URL + "foo/";
+let NONSCOPE_FRAME_URL = BASE_URL + "sandboxed_iframe.html";
+let SCOPE_FRAME_URL = SCOPE + "fake.html";
+let SCOPE_FRAME_URL2 = SCOPE + "whatsit.html";
 
-let swClosed = new Promise(() => {});
 let expectedConsoleCalls = [
     {
       level: "log",
       filename: /helper_serviceworker/,
-      arguments: ["Hello from serviceworker"],
-    }
+      arguments: ['script evaluation'],
+    },
+    {
+      level: "log",
+      filename: /helper_serviceworker/,
+      arguments: ['install event'],
+    },
+    {
+      level: "log",
+      filename: /helper_serviceworker/,
+      arguments: ['activate event'],
+    },
+    {
+      level: "log",
+      filename: /helper_serviceworker/,
+      arguments: ['fetch event: ' + SCOPE_FRAME_URL],
+    },
+    {
+      level: "log",
+      filename: /helper_serviceworker/,
+      arguments: ['fetch event: ' + SCOPE_FRAME_URL2],
+    },
 ];
 let consoleCalls = [];
 
 let startTest = Task.async(function*() {
   removeEventListener("load", startTest);
 
   yield new Promise(resolve => {
     SpecialPowers.pushPrefEnv({"set": [
       ["devtools.webconsole.filter.serviceworkers", true]
     ]}, resolve);
   });
 
   attachConsoleToTab(["ConsoleAPI"], onAttach);
 });
 addEventListener("load", startTest);
 
+function with_frame(url) {
+  return new Promise(resolve => {
+    let iframe = document.createElement("iframe");
+    iframe.onload = function() {
+      resolve(iframe);
+    };
+    iframe.src = url;
+    document.body.appendChild(iframe);
+  });
+}
+
+function navigate_frame(iframe, url) {
+  return new Promise(resolve => {
+    iframe.onload = function() {
+      resolve(iframe);
+    };
+    iframe.src = url;
+  });
+}
+
+function with_active_service_worker(win, url, scope) {
+  return win.navigator.serviceWorker.register(url, { scope: scope }).then(swr => {
+    if (swr.active) {
+      return swr;
+    }
+
+    // Unfortunately we can't just use navigator.serviceWorker.ready promise
+    // here.  If the service worker is for a scope that does not cover the window
+    // then the ready promise will never resolve.  Instead monitor the service
+    // workers state change events to determine when its activated.
+    return new Promise(resolve => {
+      let sw = swr.waiting || swr.installing;
+      sw.addEventListener('statechange', function stateHandler(evt) {
+        if (sw.state === 'activated') {
+          sw.removeEventListener('statechange', stateHandler);
+          resolve(swr);
+        }
+      });
+    });
+  });
+}
+
+function unregister_service_worker(win) {
+  return win.navigator.serviceWorker.ready.then(swr => {
+    return swr.unregister();
+  });
+}
+
 function onAttach(state, response) {
   onConsoleAPICall = onConsoleAPICall.bind(null, state);
   state.dbgClient.addListener("consoleAPICall", onConsoleAPICall);
 
+  let currentFrame = null;
+
+  // First, we need a frame from which to register our script.  This
+  // will not trigger any console calls.
   info("Loading a ServiceWorker that will use console API");
-  swClosed = new Promise(resolve => {
-    let iframe = document.createElement("iframe");
-    iframe.onload = function() {
-      let win = iframe.contentWindow;
-      info("Registering the service worker");
-      win.navigator.serviceWorker.register(SERVICE_WORKER_URL).then(swr => {
+  with_frame(NONSCOPE_FRAME_URL).then(f => {
 
-        info("Service worker registered.  Unregistering");
-        swr.unregister().then(() => {
-          resolve();
-        });
-      }, error => {
-        info("Error registering service worker: " + error);
-      });
-    };
-    iframe.src = FRAME_URL;
+    // Now register the service worker and wait for it to become
+    // activate.  This should trigger 3 console calls; 1 for script
+    // evaluation, 1 for the install event, and 1 for the activate
+    // event.  These console calls are received because we called
+    // register(), not because we are in scope for the worker.
+    info("Registering the service worker");
+    currentFrame = f;
+    return with_active_service_worker(f.contentWindow, SERVICE_WORKER_URL, SCOPE);
+  }).then(swr => {
 
-    document.body.appendChild(iframe);
+    // Now that the service worker is activate, lets navigate our frame.
+    // This will trigger 1 more console call for the fetch event.
+    info("Service worker registered. Navigating frame.");
+    return navigate_frame(currentFrame, SCOPE_FRAME_URL);
+  }).then(f => {
+
+    // We now have a controlled frame.  Lets perform a non-navigation fetch.
+    // This should produce another console call for the fetch event.
+    info("Frame navigated.  Calling fetch().");
+    return currentFrame.contentWindow.fetch(SCOPE_FRAME_URL2);
+  }).then(response => {
+    info("Completed fetch().  Unregistering service worker.");
+    return unregister_service_worker(currentFrame.contentWindow);
+  }).then(() => {
+    info('Service worker unregistered.  Checking console calls.');
+    state.dbgClient.removeListener("consoleAPICall", onConsoleAPICall);
+    is(consoleCalls.length, expectedConsoleCalls.length,
+       'received correct number of console calls');
+    expectedConsoleCalls.forEach(function(aMessage, aIndex) {
+      info("checking received console call #" + aIndex);
+      checkConsoleAPICall(consoleCalls[aIndex], expectedConsoleCalls[aIndex]);
+    });
+  }).catch(error => {
+    ok(false, 'unexpected error: ' + error);
+  }).then(() => {
+    currentFrame.remove();
+    currentFrame = null;
+    consoleCalls = [];
+    closeDebugger(state, function() {
+      SimpleTest.finish();
+    });
   });
 }
 
 function onConsoleAPICall(state, type, packet) {
   info("received message level: " + packet.message.level);
   is(packet.from, state.actor, "console API call actor");
-
   consoleCalls.push(packet.message);
-  if (consoleCalls.length != expectedConsoleCalls.length) {
-    return;
-  }
-
-  state.dbgClient.removeListener("consoleAPICall", onConsoleAPICall);
-
-  expectedConsoleCalls.forEach(function(aMessage, aIndex) {
-    info("checking received console call #" + aIndex);
-    checkConsoleAPICall(consoleCalls[aIndex], expectedConsoleCalls[aIndex]);
-  });
-
-  consoleCalls = [];
-
-  closeDebugger(state, function() {
-    swClosed.then(() => {
-      SimpleTest.finish();
-    });
-  });
 }
 </script>
 </body>
 </html>
