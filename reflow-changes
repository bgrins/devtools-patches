# HG changeset patch
# Parent c0fed563d58146f765ef575d24b320ee3ecc255b
# User Brian Grinstead <bgrinstead@mozilla.com>
test


diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -240,24 +240,26 @@ LayoutView.prototype = {
       let toolbox = this.inspector.toolbox;
       if (toolbox.target.form.reflowActor) {
         this.reflowFront = ReflowFront(toolbox.target.client, toolbox.target.form);
       } else {
         return;
       }
     }
 
+    console.log("TRACKING REFLOWS", this.reflowFront);
     this.reflowFront.on("reflows", this.update);
     this.reflowFront.start();
   },
 
   /**
    * Stop listening to reflows in the current tab.
    */
   untrackReflows: function() {
+    console.log("UNTRACKING REFLOWS", this.reflowFront);
     if (!this.reflowFront) {
       return;
     }
 
     this.reflowFront.off("reflows", this.update);
     this.reflowFront.stop();
   },
 
@@ -325,17 +327,17 @@ LayoutView.prototype = {
     this.inspector.selection.off("new-node-front", this.onNewSelection);
     this.inspector.sidebar.off("select", this.onSidebarSelect);
 
     this.sizeHeadingLabel = null;
     this.sizeLabel = null;
     this.inspector = null;
     this.doc = null;
 
-    if (reflowFront) {
+    if (this.reflowFront) {
       this.untrackReflows();
       this.reflowFront.destroy();
       this.reflowFront = null;
     }
   },
 
   onSidebarSelect: function(e, sidebar) {
     if (sidebar !== "layoutview") {
@@ -366,16 +368,19 @@ LayoutView.prototype = {
     return this.update();
   },
 
   /**
    * Hide the layout boxes. No node are selected.
    */
   dim: function() {
     this.untrackReflows();
+    this.untrackReflows();
+    this.untrackReflows();
+    console.log("MULTI UNTRACK");
     this.doc.body.classList.add("dim");
     this.dimmed = true;
   },
 
   /**
    * Show the layout boxes. A node is selected.
    */
   undim: function() {
diff --git a/toolkit/devtools/server/actors/layout.js b/toolkit/devtools/server/actors/layout.js
--- a/toolkit/devtools/server/actors/layout.js
+++ b/toolkit/devtools/server/actors/layout.js
@@ -30,40 +30,41 @@
 
 const {Ci, Cu} = require("chrome");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 const protocol = require("devtools/server/protocol");
 const {method, Arg, RetVal, types} = protocol;
 const events = require("sdk/event/core");
 const Heritage = require("sdk/core/heritage");
 const {EventEmitter} = Cu.import("resource://gre/modules/devtools/event-emitter.js");
+let {console} = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 
 XPCOMUtils.defineLazyModuleGetter(this, "setNamedTimeout",
   "resource:///modules/devtools/ViewHelpers.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "clearNamedTimeout",
   "resource:///modules/devtools/ViewHelpers.jsm");
 
 // The lower the value, the more event packets will be sent to the clients,
 // potentially impacting performance. The higher the value, the more time we'll
 // wait until sending batched reflow events, which is better for performance but
 // has an effect on how soon changes are shown in the toolbox
-const EVENT_BATCHING_DELAY = 300;
+const EVENT_BATCHING_DELAY = 2000;
 
 exports.register = function(handle) {
   handle.addTabActor(ReflowActor, "reflowActor");
 };
 
 exports.unregister = function(handle) {
   handle.removeTabActor(ReflowActor);
 };
 
 /**
  * The reflow actor tracks reflows and emits events about them.
  */
-let ReflowActor = exports.ReflowActor = protocol.ActorClass({
+let ReflowActor = protocol.ActorClass({
   typeName: "reflow",
 
   events: {
     /**
      * The reflows event is emitted when reflows have been detected. The event
      * is sent with an array of reflows that occured. Eeach item has the
      * following properties:
      * - start {Number}
@@ -157,29 +158,33 @@ exports.ReflowFront = protocol.FrontClas
 /**
  * Base class for all sorts of observers we need to create for a given window.
  * @param {TabActor} tabActor
  * @param {Function} callback Executed everytime the observer observes something
  */
 function Observable(tabActor, callback) {
   this.tabActor = tabActor;
   this.win = tabActor.window;
+
+  console.trace();
+  console.log("Observable created", this.win, this.win.location.toString(), tabActor);
   this.callback = callback;
 }
 
 Observable.prototype = {
   /**
    * Is the observer currently observing
    */
   observing: false,
 
   /**
    * Start observing whatever it is this observer is supposed to observe
    */
   start: function() {
+    console.log("Start requested - anything gonig to happen?", !this.observing);
     if (!this.observing) {
       this._start();
       this.observing = true;
     }
   },
 
   _start: function() {
     /* To be implemented by sub-classes */
@@ -499,30 +504,33 @@ ReflowObserver.prototype = Heritage.exte
  * @extends Observable
  * @param {TabActor} tabActor
  * @param {Function} callback Executed everytime a stylesheet event occurs
  */
 function StyleSheetChangesObserver(tabActor, callback) {
   Observable.call(this, tabActor, callback);
   this.handler = tabActor.isRootActor ?
     tabActor.window : tabActor.chromeEventHandler;
+  console.log("CREATING", this.handler);
   this._onStyleSheetChanged = this._onStyleSheetChanged.bind(this);
 }
 
 StyleSheetChangesObserver.prototype = Heritage.extend(Observable.prototype, {
   _start: function() {
     this.win.document.styleSheetChangeEventsEnabled = true;
+    console.log("StyleSheetChangesObserver start", this.win.location, this.win.document.styleSheetChangeEventsEnabled);
     this.handler.addEventListener("StyleSheetAdded",
       this._onStyleSheetChanged, true);
     this.handler.addEventListener("StyleSheetRemoved",
       this._onStyleSheetChanged, true);
   },
 
   _stop: function() {
     this.win.document.styleSheetChangeEventsEnabled = false;
+    console.log("STOPPING", this.win, this.win.document.styleSheetChangeEventsEnabled);
     this.handler.removeEventListener("StyleSheetAdded",
       this._onStyleSheetChanged, true);
     this.handler.removeEventListener("StyleSheetRemoved",
       this._onStyleSheetChanged, true);
   },
 
   _onStyleSheetChanged: function(event) {
     this.notifyCallback(event);
