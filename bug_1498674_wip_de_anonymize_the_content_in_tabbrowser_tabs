# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1548972402 28800
#      Thu Jan 31 14:06:42 2019 -0800
# Node ID 88e4a895735ab506acbb75cf44fd207f1125fc75
# Parent  319a369ccde4ff1c4842c62fe90e9adf4eb5c028
Bug 1498674 - WIP - De-anonymize the <content> in tabbrowser-tabs

Move the markup out into the only consumer (browser.xul), to avoid using
XBL content.

Differential Revision: https://phabricator.services.mozilla.com/D18282

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -129,37 +129,42 @@ panelview[mainview] > .panel-header {
   overflow: visible;
   transition: height var(--panelui-subview-transition-duration);
 }
 
 #tabbrowser-tabs {
   -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-tabs");
 }
 
+#tabbrowser-tabs > .tabs-left,
+#tabbrowser-tabs > .tabs-right {
+  -moz-box-flex: 0;
+}
+
 @supports -moz-bool-pref("layout.css.emulate-moz-box-with-flex") {
   #tabbrowser-tabs {
     /* Without this, the tabs container width extends beyond the window width */
     width: 0;
   }
   .tab-stack {
     /* Without this, pinned tabs get a bit too tall when the tabstrip overflows. */
     vertical-align: top;
   }
 }
 
 
-#tabbrowser-tabs:not([overflow="true"]):not([hashiddentabs]) ~ #alltabs-button,
-#tabbrowser-tabs[hasadjacentnewtabbutton]:not([overflow="true"]) ~ #new-tab-button,
-#tabbrowser-tabs[overflow="true"] > .tabbrowser-arrowscrollbox > .tabs-newtab-button,
-#tabbrowser-tabs:not([hasadjacentnewtabbutton]) > .tabbrowser-arrowscrollbox > .tabs-newtab-button,
-#TabsToolbar[customizing="true"] #tabbrowser-tabs > .tabbrowser-arrowscrollbox > .tabs-newtab-button {
+#tabbrowser-tabs-wrapper:not([overflow="true"]):not([hashiddentabs]) ~ #alltabs-button,
+#tabbrowser-tabs-wrapper[hasadjacentnewtabbutton]:not([overflow="true"]) ~ #new-tab-button,
+#tabbrowser-tabs-wrapper[overflow="true"] #tabs-newtab-button,
+#tabbrowser-tabs-wrapper:not([hasadjacentnewtabbutton]) #tabs-newtab-button,
+#TabsToolbar[customizing="true"] #tabs-newtab-button {
   visibility: collapse;
 }
 
-#tabbrowser-tabs:not([overflow="true"])[using-closing-tabs-spacer] ~ #alltabs-button {
+#tabbrowser-tabs-wrapper:not([overflow="true"])[using-closing-tabs-spacer] ~ #alltabs-button {
   visibility: hidden; /* temporary space to keep a tab's close button under the cursor */
 }
 
 .tabbrowser-tab {
   -moz-binding: url("chrome://browser/content/tabbrowser.xml#tabbrowser-tab");
 }
 
 .tabbrowser-tab:not([pinned]) {
diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -718,23 +718,40 @@
                aria-label="&tabsToolbar.label;"
                context="toolbar-context-menu"
                flex="1">
 
         <hbox class="titlebar-spacer" type="pre-tabs"/>
 
         <hbox flex="1" align="end" class="toolbar-items">
           <hbox id="TabsToolbar-customization-target" flex="1">
-            <tabs id="tabbrowser-tabs"
+            <hbox id="tabbrowser-tabs-wrapper"
                   flex="1"
-                  setfocus="false"
                   tooltip="tabbrowser-tab-tooltip"
                   stopwatchid="FX_TAB_CLICK_MS">
-              <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
-            </tabs>
+              <hbox class="tab-drop-indicator-box">
+                <image class="tab-drop-indicator" collapsed="true"/>
+              </hbox>
+              <arrowscrollbox orient="horizontal" flex="1"
+                              style="min-width: 1px;"
+                              clicktoscroll="true"
+                              class="tabbrowser-arrowscrollbox">
+                <tabs id="tabbrowser-tabs"
+                      flex="1"
+                      setfocus="false">
+                  <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
+                </tabs>
+                <toolbarbutton id="tabs-newtab-button"
+                               class="tabs-newtab-button toolbarbutton-1"
+                               command="cmd_newNavigatorTab"
+                               onclick="checkForMiddleClick(this, event);"
+                               tooltip="dynamic-shortcut-tooltip"/>
+                <spacer class="closing-tabs-spacer" style="width: 0;"/>
+              </arrowscrollbox>
+            </hbox>
 
             <toolbarbutton id="new-tab-button"
                            class="toolbarbutton-1 chromeclass-toolbar-additional"
                            label="&tabCmd.label;"
                            command="cmd_newNavigatorTab"
                            onclick="checkForMiddleClick(this, event);"
                            tooltip="dynamic-shortcut-tooltip"
                            ondrop="newTabButtonObserver.onDrop(event)"
diff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml
--- a/browser/base/content/tabbrowser.xml
+++ b/browser/base/content/tabbrowser.xml
@@ -5,61 +5,29 @@
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <bindings id="tabBrowserBindings"
           xmlns="http://www.mozilla.org/xbl"
           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
           xmlns:xbl="http://www.mozilla.org/xbl">
   <binding id="tabbrowser-tabs"
            extends="chrome://global/content/bindings/tabbox.xml#tabs">
-    <content>
-      <xul:hbox class="tab-drop-indicator-box">
-        <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
-      </xul:hbox>
-      <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
-                          style="min-width: 1px;"
-                          clicktoscroll="true"
-                          class="tabbrowser-arrowscrollbox">
-<!--
- This is a hack to circumvent bug 472020, otherwise the tabs show up on the
- right of the newtab button.
--->
-        <children includes="tab"/>
-<!--
-  This is to ensure anything extensions put here will go before the newtab
-  button, necessary due to the previous hack.
--->
-        <children/>
-        <xul:toolbarbutton class="tabs-newtab-button toolbarbutton-1"
-                           anonid="tabs-newtab-button"
-                           command="cmd_newNavigatorTab"
-                           onclick="checkForMiddleClick(this, event);"
-                           />
-        <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
-                    style="width: 0;"/>
-      </xul:arrowscrollbox>
-    </content>
-
     <implementation implements="nsIObserver">
       <constructor>
         <![CDATA[
           this._tabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
           this._hiddenSoundPlayingTabs = new Set();
 
           let strId = PrivateBrowsingUtils.isWindowPrivate(window) ?
               "emptyPrivateTabTitle" : "emptyTabTitle";
           this.emptyTabTitle = gTabBrowserBundle.GetStringFromName("tabs." + strId);
 
           var tab = this.firstElementChild;
           tab.label = this.emptyTabTitle;
 
-          let newTabButton = document.getAnonymousElementByAttribute(
-            this, "anonid", "tabs-newtab-button");
-          newTabButton.setAttribute("tooltiptext", GetDynamicShortcutTooltipText("tabs-newtab-button"));
-
           window.addEventListener("resize", this);
 
           Services.prefs.addObserver("privacy.userContext", this);
           this.observe(null, "nsPref:changed", "privacy.userContext.enabled");
 
           XPCOMUtils.defineLazyPreferenceGetter(this, "_tabMinWidthPref",
             "browser.tabs.tabMinWidth", null,
             (pref, prevValue, newValue) => this._tabMinWidth = newValue,
@@ -102,27 +70,48 @@
       <field name="tabbox" readonly="true">
         document.getElementById("tabbrowser-tabbox");
       </field>
 
       <field name="contextMenu" readonly="true">
         document.getElementById("tabContextMenu");
       </field>
 
+      <field name="wrapper">
+        document.getElementById("tabbrowser-tabs-wrapper");
+      </field>
+
+      <field name="newTabButton">
+        document.getElementById("tabs-newtab-button");
+      </field>
+
       <field name="arrowScrollbox">
-        document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
+        this.wrapper.querySelector(".tabbrowser-arrowscrollbox");
       </field>
 
       <field name="_firstTab">null</field>
       <field name="_lastTab">null</field>
       <field name="_beforeSelectedTab">null</field>
       <field name="_beforeHoveredTab">null</field>
       <field name="_afterHoveredTab">null</field>
       <field name="_hoveredTab">null</field>
 
+      <property name="isOverflowing">
+        <getter>
+          return this.wrapper.getAttribute("overflow") == "true";
+        </getter>
+        <setter>
+          if (val) {
+            this.wrapper.setAttribute("overflow", "true");
+          } else {
+            this.wrapper.removeAttribute("overflow");
+          }
+        </setter>
+      </property>
+
       <property name="_tabMinWidth">
         <setter>
           this.style.setProperty("--tab-min-width", val + "px");
           return val;
         </setter>
       </property>
 
       <property name="_multiselectEnabled">
@@ -206,17 +195,17 @@
 
               // If longPressBehavior pref is set to 0 (or any invalid value)
               // long press menu is disabled.
               if (containersEnabled && (longPressBehavior <= 0 || longPressBehavior > 2)) {
                 containersEnabled = false;
               }
 
               const newTab = document.getElementById("new-tab-button");
-              const newTab2 = document.getAnonymousElementByAttribute(this, "anonid", "tabs-newtab-button");
+              const newTab2 = this.newTabButton;
 
               for (let parent of [newTab, newTab2]) {
                 if (!parent)
                   continue;
 
                 gClickAndHoldListenersOnElement.remove(parent);
                 parent.removeAttribute("type");
                 if (parent.firstElementChild) {
@@ -285,17 +274,17 @@
           if (this._beforeSelectedTab) {
             this._beforeSelectedTab.removeAttribute("beforeselected-visible");
           }
 
           if (selectedTab.closing || selectedIndex <= 0) {
             this._beforeSelectedTab = null;
           } else {
             let beforeSelectedTab = visibleTabs[selectedIndex - 1];
-            let separatedByScrollButton = this.getAttribute("overflow") == "true" &&
+            let separatedByScrollButton = this.isOverflowing &&
               beforeSelectedTab.pinned && !selectedTab.pinned;
             if (!separatedByScrollButton) {
               this._beforeSelectedTab = beforeSelectedTab;
               this._beforeSelectedTab.setAttribute("beforeselected-visible",
                                                    "true");
             }
           }
 
@@ -328,27 +317,27 @@
             }
           }
         ]]></body>
       </method>
 
       <field name="_blockDblClick">false</field>
 
       <field name="_tabDropIndicator">
-        document.getAnonymousElementByAttribute(this, "anonid", "tab-drop-indicator");
+        this.wrapper.querySelector(".tab-drop-indicator");
       </field>
 
       <field name="_dragOverDelay">350</field>
       <field name="_dragTime">0</field>
 
       <field name="_closeButtonsUpdatePending">false</field>
       <method name="_updateCloseButtons">
         <body><![CDATA[
           // If we're overflowing, tabs are at their minimum widths.
-          if (this.getAttribute("overflow") == "true") {
+          if (this.isOverflowing) {
             this.setAttribute("closebuttons", "activetab");
             return;
           }
 
           if (this._closeButtonsUpdatePending) {
             return;
           }
           this._closeButtonsUpdatePending = true;
@@ -356,17 +345,17 @@
           // Wait until after the next paint to get current layout data from
           // getBoundsWithoutFlushing.
           window.requestAnimationFrame(() => {
             window.requestAnimationFrame(() => {
               this._closeButtonsUpdatePending = false;
 
               // The scrollbox may have started overflowing since we checked
               // overflow earlier, so check again.
-              if (this.getAttribute("overflow") == "true") {
+              if (this.isOverflowing) {
                 this.setAttribute("closebuttons", "activetab");
                 return;
               }
 
               // Check if tab widths are below the threshold where we want to
               // remove close buttons from background tabs so that people don't
               // accidentally close tabs by selecting them.
               let rect = ele => {
@@ -381,36 +370,36 @@
             });
           });
         ]]></body>
       </method>
 
       <method name="_updateHiddenTabsStatus">
         <body><![CDATA[
           if (gBrowser.visibleTabs.length < gBrowser.tabs.length) {
-            this.setAttribute("hashiddentabs", "true");
+            this.wrapper.setAttribute("hashiddentabs", "true");
           } else {
-            this.removeAttribute("hashiddentabs");
+            this.wrapper.removeAttribute("hashiddentabs");
           }
         ]]></body>
       </method>
 
       <method name="_handleTabSelect">
         <parameter name="aInstant"/>
         <body><![CDATA[
           let selectedTab = this.selectedItem;
-          if (this.getAttribute("overflow") == "true")
+          if (this.isOverflowing)
             this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);
 
           selectedTab._notselectedsinceload = false;
         ]]></body>
       </method>
 
       <field name="_closingTabsSpacer">
-        document.getAnonymousElementByAttribute(this, "anonid", "closing-tabs-spacer");
+        this.wrapper.querySelector(".closing-tabs-spacer");
       </field>
 
       <field name="_tabDefaultMaxWidth">NaN</field>
       <field name="_lastTabClosedByMouse">false</field>
       <field name="_hasTabTempMaxWidth">false</field>
       <field name="_scrollButtonWidth">0</field>
 
       <!-- Try to keep the active tab's close button under the mouse cursor -->
@@ -427,17 +416,17 @@
 
           if (!this._tabDefaultMaxWidth) {
             this._tabDefaultMaxWidth =
               parseFloat(window.getComputedStyle(aTab).maxWidth);
           }
           this._lastTabClosedByMouse = true;
           this._scrollButtonWidth = window.windowUtils.getBoundsWithoutFlushing(this.arrowScrollbox._scrollButtonDown).width;
 
-          if (this.getAttribute("overflow") == "true") {
+          if (this.isOverflowing) {
             // Don't need to do anything if we're in overflow mode and aren't scrolled
             // all the way to the right, or if we're closing the last tab.
             if (isEndTab || !this.arrowScrollbox._scrollButtonDown.disabled) {
               return;
             }
             // If the tab has an owner that will become the active tab, the owner will
             // be to the left of it, so we actually want the left tab to slide over.
             // This can't be done as easily in non-overflow mode, so we don't bother.
@@ -528,17 +517,17 @@
         ]]></body>
       </method>
 
       <field name="_lastNumPinned">0</field>
       <field name="_pinnedTabsLayoutCache">null</field>
       <method name="_positionPinnedTabs">
         <body><![CDATA[
           let numPinned = gBrowser._numPinnedTabs;
-          let doPosition = this.getAttribute("overflow") == "true" &&
+          let doPosition = this.isOverflowing &&
                            this._getVisibleTabs().length > numPinned &&
                            numPinned > 0;
 
           if (doPosition) {
             this.setAttribute("positionpinnedtabs", "true");
 
             let layoutData = this._pinnedTabsLayoutCache;
             let uiDensity = document.documentElement.getAttribute("uidensity");
@@ -919,17 +908,17 @@
 
       <field name="_animateElement">
         this.arrowScrollbox._scrollButtonDown;
       </field>
 
       <method name="_notifyBackgroundTab">
         <parameter name="aTab"/>
         <body><![CDATA[
-          if (aTab.pinned || aTab.hidden || this.getAttribute("overflow") != "true")
+          if (aTab.pinned || aTab.hidden || !this.isOverflowing)
             return;
 
           this._lastTabToScrollIntoView = aTab;
           if (!this._backgroundTabScrollPromise) {
             this._backgroundTabScrollPromise = window.promiseDocumentFlushed(() => {
               let lastTabRect = this._lastTabToScrollIntoView.getBoundingClientRect();
               let selectedTab = this.selectedItem;
               if (selectedTab.pinned) {
@@ -1126,35 +1115,35 @@
       </method>
 
       <method name="_updateNewTabVisibility">
         <body><![CDATA[
           // Helper functions to help deal with customize mode wrapping some items
           let wrap = n => n.parentNode.localName == "toolbarpaletteitem" ? n.parentNode : n;
           let unwrap = n => n && n.localName == "toolbarpaletteitem" ? n.firstElementChild : n;
 
-          // Starting from the tabs element, find the next sibling that:
+          // Starting from the tabs wrapper, find the next sibling that:
           // - isn't hidden; and
           // - isn't the all-tabs button.
           // If it's the new tab button, consider the new tab button adjacent to the tabs.
           // If the new tab button is marked as adjacent and the tabstrip doesn't
           // overflow, we'll display the 'new tab' button inline in the tabstrip.
           // In all other cases, the separate new tab button is displayed in its
           // customized location.
-          let sib = this;
+          let sib = this.wrapper;
           do {
             sib = unwrap(wrap(sib).nextElementSibling);
           } while (sib && (sib.hidden ||
                            sib.id == "alltabs-button"));
 
           const kAttr = "hasadjacentnewtabbutton";
           if (sib && sib.id == "new-tab-button") {
-            this.setAttribute(kAttr, "true");
+            this.wrapper.setAttribute(kAttr, "true");
           } else {
-            this.removeAttribute(kAttr);
+            this.wrapper.removeAttribute(kAttr);
           }
         ]]></body>
       </method>
 
       <method name="onWidgetAfterDOMChange">
         <parameter name="aNode"/>
         <parameter name="aNextNode"/>
         <parameter name="aContainer"/>
@@ -1187,21 +1176,21 @@
 
       <method name="_hiddenSoundPlayingStatusChanged">
         <parameter name="tab"/>
         <parameter name="opts"/>
         <body><![CDATA[
           let closed = opts && opts.closed;
           if (!closed && tab.soundPlaying && tab.hidden) {
             this._hiddenSoundPlayingTabs.add(tab);
-            this.setAttribute("hiddensoundplaying", "true");
+            this.wrapper.setAttribute("hiddensoundplaying", "true");
           } else {
             this._hiddenSoundPlayingTabs.delete(tab);
             if (this._hiddenSoundPlayingTabs.size == 0) {
-              this.removeAttribute("hiddensoundplaying");
+              this.wrapper.removeAttribute("hiddensoundplaying");
             }
           }
         ]]></body>
       </method>
     </implementation>
 
     <handlers>
       <handler event="TabSelect"><![CDATA[
@@ -1568,17 +1557,17 @@
         event.stopPropagation();
 
         var arrowScrollbox = this.arrowScrollbox;
 
         // autoscroll the tab strip if we drag over the scroll
         // buttons, even if we aren't dragging a tab, but then
         // return to avoid drawing the drop indicator
         var pixelsToScroll = 0;
-        if (this.getAttribute("overflow") == "true") {
+        if (this.isOverflowing) {
           var targetAnonid = event.originalTarget.getAttribute("anonid");
           switch (targetAnonid) {
             case "scrollbutton-up":
               pixelsToScroll = arrowScrollbox.scrollIncrement * -1;
               break;
             case "scrollbutton-down":
               pixelsToScroll = arrowScrollbox.scrollIncrement;
               break;
@@ -2139,17 +2128,17 @@
           if (this.selected)
             tabContainer._handleTabSelect();
 
           if (tabIndex == 0) {
             tabContainer._beforeHoveredTab = null;
           } else {
             let candidate = visibleTabs[tabIndex - 1];
             let separatedByScrollButton =
-              tabContainer.getAttribute("overflow") == "true" &&
+              tabContainer.isOverflowing &&
               candidate.pinned && !this.pinned;
             if (!candidate.selected && !separatedByScrollButton) {
               tabContainer._beforeHoveredTab = candidate;
               candidate.setAttribute("beforehovered", "true");
             }
           }
 
           if (tabIndex == visibleTabs.length - 1) {
diff --git a/browser/base/content/test/performance/browser_tabclose.js b/browser/base/content/test/performance/browser_tabclose.js
--- a/browser/base/content/test/performance/browser_tabclose.js
+++ b/browser/base/content/test/performance/browser_tabclose.js
@@ -21,20 +21,17 @@ const EXPECTED_REFLOWS = [
  */
 add_task(async function() {
   await ensureNoPreloadedBrowser();
 
   let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser);
   await BrowserTestUtils.waitForCondition(() => tab._fullyOpen);
 
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
-  let newTabButtonRect =
-    document.getAnonymousElementByAttribute(gBrowser.tabContainer,
-                                            "anonid", "tabs-newtab-button")
-            .getBoundingClientRect();
+  let newTabButtonRect = gBrowser.tabContainer.newTabButton.getBoundingClientRect();
   let inRange = (val, min, max) => min <= val && val <= max;
 
   // Add a reflow observer and open a new tab.
   await withPerfObserver(async function() {
     let switchDone = BrowserTestUtils.waitForEvent(window, "TabSwitchDone");
     gBrowser.removeTab(tab, { animate: true });
     await BrowserTestUtils.waitForEvent(tab, "TabAnimationEnd");
     await switchDone;
diff --git a/browser/base/content/test/performance/head.js b/browser/base/content/test/performance/head.js
--- a/browser/base/content/test/performance/head.js
+++ b/browser/base/content/test/performance/head.js
@@ -273,19 +273,17 @@ async function ensureFocusedUrlbar() {
  * tabstrip without causing it to overflow.
  *
  * @return int
  *         The maximum additional tabs that can be fit into the
  *         tabstrip without causing it to overflow.
  */
 function computeMaxTabCount() {
   let currentTabCount = gBrowser.tabs.length;
-  let newTabButton =
-    document.getAnonymousElementByAttribute(gBrowser.tabContainer,
-                                            "anonid", "tabs-newtab-button");
+  let newTabButton = gBrowser.tabContainer.newTabButton;
   let newTabRect = newTabButton.getBoundingClientRect();
   let tabStripRect = gBrowser.tabContainer.arrowScrollbox.getBoundingClientRect();
   let availableTabStripWidth = tabStripRect.width - newTabRect.width;
 
   let tabMinWidth =
     parseInt(getComputedStyle(gBrowser.selectedTab, null).minWidth, 10);
 
   let maxTabCount = Math.floor(availableTabStripWidth / tabMinWidth) - currentTabCount;
diff --git a/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js b/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js
--- a/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js
+++ b/browser/base/content/test/tabs/browser_multiselect_tabs_open_related.js
@@ -17,17 +17,17 @@ add_task(async function test() {
 
   ok(tab1.multiselected, "Tab1 is multi-selected");
   ok(tab2.multiselected, "Tab2 is multi-selected");
   ok(!tab3.multiselected, "Tab3 is not multi-selected");
 
   let metaKeyEvent = AppConstants.platform == "macosx" ? {metaKey: true} : {ctrlKey: true};
 
   let tabs = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(tabs, "anonid", "tabs-newtab-button");
+  let newTabButton = tabs.newTabButton;
   let promiseTabOpened = BrowserTestUtils.waitForEvent(gBrowser.tabContainer, "TabOpen");
   EventUtils.synthesizeMouseAtCenter(newTabButton, metaKeyEvent);
   let openEvent = await promiseTabOpened;
   let newTab = openEvent.target;
 
   is(newTab.previousElementSibling, tab2,
     "New tab should be opened after tab2 when tab1 and tab2 are multiselected");
   is(newTab.nextElementSibling, tab3,
diff --git a/browser/components/contextualidentity/test/browser/browser_newtabButton.js b/browser/components/contextualidentity/test/browser/browser_newtabButton.js
--- a/browser/components/contextualidentity/test/browser/browser_newtabButton.js
+++ b/browser/components/contextualidentity/test/browser/browser_newtabButton.js
@@ -5,17 +5,17 @@
 
 add_task(async function test_menu_with_timeout() {
   await SpecialPowers.pushPrefEnv({"set": [
       ["privacy.userContext.enabled", true],
       ["privacy.userContext.longPressBehavior", 2],
   ]});
 
   let newTab = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(newTab, "anonid", "tabs-newtab-button");
+  let newTabButton = newTab.newTabButton;
   ok(newTabButton, "New tab button exists");
   ok(!newTabButton.hidden, "New tab button is visible");
   await BrowserTestUtils.waitForCondition(() => !!document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup"), "Wait for popup to exist");
   let popup = document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
 
   for (let i = 1; i <= 4; i++) {
     let popupShownPromise = BrowserTestUtils.waitForEvent(popup, "popupshown");
     EventUtils.synthesizeMouseAtCenter(newTabButton, {type: "mousedown"});
@@ -37,17 +37,17 @@ add_task(async function test_menu_with_t
 
 add_task(async function test_menu_without_timeout() {
   await SpecialPowers.pushPrefEnv({"set": [
       ["privacy.userContext.enabled", true],
       ["privacy.userContext.longPressBehavior", 1],
   ]});
 
   let newTab = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(newTab, "anonid", "tabs-newtab-button");
+  let newTabButton = newTab.newTabButton;
   ok(newTabButton, "New tab button exists");
   ok(!newTabButton.hidden, "New tab button is visible");
   await BrowserTestUtils.waitForCondition(() => !!document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup"), "Wait for popup to exist");
   let popup = document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
 
   let popupShownPromise = BrowserTestUtils.waitForEvent(popup, "popupshown");
   let popupHiddenPromise = BrowserTestUtils.waitForEvent(popup, "popuphidden");
   EventUtils.synthesizeMouseAtCenter(newTabButton, {type: "mousedown"});
@@ -84,28 +84,28 @@ add_task(async function test_menu_withou
 
 add_task(async function test_no_menu() {
   await SpecialPowers.pushPrefEnv({"set": [
       ["privacy.userContext.enabled", true],
       ["privacy.userContext.longPressBehavior", 0],
   ]});
 
   let newTab = document.getElementById("tabbrowser-tabs");
-  let newTabButton = document.getAnonymousElementByAttribute(newTab, "anonid", "tabs-newtab-button");
+  let newTabButton = newTab.newTabButton;
   ok(newTabButton, "New tab button exists");
   ok(!newTabButton.hidden, "New tab button is visible");
   let popup = document.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
   ok(!popup, "new tab should not have a popup");
 });
 
 add_task(async function test_private_mode() {
   let privateWindow = await BrowserTestUtils.openNewBrowserWindow({private: true});
   let privateDocument = privateWindow.document;
   let {tabContainer} = privateWindow.gBrowser;
-  let newTab = privateDocument.getAnonymousElementByAttribute(tabContainer, "anonid", "tabs-newtab-button");
+  let newTab = tabContainer.newTabButton;
   let newTab2 = privateDocument.getElementById("new-tab-button");
   // Check to ensure we are talking about the right button
   ok(!!newTab.clientWidth, "new tab button should not be hidden");
   ok(!newTab2.clientWidth, "overflow new tab button should be hidden");
   let popup = privateDocument.getAnonymousElementByAttribute(newTab, "anonid", "newtab-popup");
   ok(!popup, "new tab should not have a popup");
   await BrowserTestUtils.closeWindow(privateWindow);
 });
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -237,17 +237,17 @@ var CustomizableUIInternal = {
         ],
         defaultCollapsed: true,
       }, true);
     }
 
     this.registerArea(CustomizableUI.AREA_TABSTRIP, {
       type: CustomizableUI.TYPE_TOOLBAR,
       defaultPlacements: [
-        "tabbrowser-tabs",
+        "tabbrowser-tabs-wrapper",
         "new-tab-button",
         "alltabs-button",
       ],
       defaultCollapsed: null,
     }, true);
     this.registerArea(CustomizableUI.AREA_BOOKMARKS, {
       type: CustomizableUI.TYPE_TOOLBAR,
       defaultPlacements: [
diff --git a/browser/components/customizableui/test/browser_newtab_button_customizemode.js b/browser/components/customizableui/test/browser_newtab_button_customizemode.js
--- a/browser/components/customizableui/test/browser_newtab_button_customizemode.js
+++ b/browser/components/customizableui/test/browser_newtab_button_customizemode.js
@@ -4,17 +4,17 @@
 "use strict";
 
 /**
  * Tests in this file check that user customizations to the tabstrip show
  * the correct type of new tab button while the tabstrip isn't overflowing.
  */
 
 const kGlobalNewTabButton = document.getElementById("new-tab-button");
-const kInnerNewTabButton = document.getAnonymousElementByAttribute(gBrowser.tabContainer, "anonid", "tabs-newtab-button");
+const kInnerNewTabButton = gBrowser.tabContainer.newTabButton;
 
 function assertNewTabButton(which) {
   if (which == "global") {
     isnot(kGlobalNewTabButton.getBoundingClientRect().width, 0,
       "main new tab button should be visible");
     is(kInnerNewTabButton.getBoundingClientRect().width, 0,
       "inner new tab button should be hidden");
   } else if (which == "inner") {
@@ -29,100 +29,100 @@ function assertNewTabButton(which) {
 
 /**
  * Add and remove items *after* the new tab button in customize mode.
  */
 add_task(async function addremove_after_newtab_customizemode() {
   await startCustomizing();
   await waitForElementShown(kGlobalNewTabButton);
   simulateItemDrag(document.getElementById("home-button"), kGlobalNewTabButton, "end");
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should have the adjacent newtab attribute");
   await endCustomizing();
   assertNewTabButton("inner");
 
   await startCustomizing();
   let dropTarget = document.getElementById("stop-reload-button");
   await waitForElementShown(dropTarget);
   simulateItemDrag(document.getElementById("home-button"), dropTarget, "end");
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should still have the adjacent newtab attribute");
   await endCustomizing();
   assertNewTabButton("inner");
   ok(CustomizableUI.inDefaultState, "Should be in default state");
 });
 
 /**
  * Add and remove items *before* the new tab button in customize mode.
  */
 add_task(async function addremove_before_newtab_customizemode() {
   await startCustomizing();
   await waitForElementShown(kGlobalNewTabButton);
   simulateItemDrag(document.getElementById("home-button"), kGlobalNewTabButton, "start");
-  ok(!gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(!gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should no longer have the adjacent newtab attribute");
   await endCustomizing();
   assertNewTabButton("global");
   await startCustomizing();
   let dropTarget = document.getElementById("stop-reload-button");
   await waitForElementShown(dropTarget);
   simulateItemDrag(document.getElementById("home-button"), dropTarget, "end");
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should have the adjacent newtab attribute again");
   await endCustomizing();
   assertNewTabButton("inner");
   ok(CustomizableUI.inDefaultState, "Should be in default state");
 });
 
 /**
  * Add and remove items *after* the new tab button outside of customize mode.
  */
 add_task(async function addremove_after_newtab_api() {
   CustomizableUI.addWidgetToArea("home-button", "TabsToolbar");
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should have the adjacent newtab attribute");
   assertNewTabButton("inner");
 
   CustomizableUI.reset();
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should still have the adjacent newtab attribute");
   assertNewTabButton("inner");
   ok(CustomizableUI.inDefaultState, "Should be in default state");
 });
 
 /**
  * Add and remove items *before* the new tab button outside of customize mode.
  */
 add_task(async function addremove_before_newtab_api() {
   let index = CustomizableUI.getWidgetIdsInArea("TabsToolbar").indexOf("new-tab-button");
   CustomizableUI.addWidgetToArea("home-button", "TabsToolbar", index);
-  ok(!gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(!gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should no longer have the adjacent newtab attribute");
   assertNewTabButton("global");
 
   CustomizableUI.removeWidgetFromArea("home-button");
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should have the adjacent newtab attribute again");
   assertNewTabButton("inner");
 
   CustomizableUI.reset();
   ok(CustomizableUI.inDefaultState, "Should be in default state");
 });
 
 /**
   * Reset to defaults in customize mode to see if that doesn't break things.
   */
 add_task(async function reset_before_newtab_customizemode() {
   await startCustomizing();
   await waitForElementShown(kGlobalNewTabButton);
   simulateItemDrag(document.getElementById("home-button"), kGlobalNewTabButton, "start");
-  ok(!gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(!gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should no longer have the adjacent newtab attribute");
   await endCustomizing();
   assertNewTabButton("global");
   await startCustomizing();
   await gCustomizeMode.reset();
-  ok(gBrowser.tabContainer.hasAttribute("hasadjacentnewtabbutton"),
+  ok(gBrowser.tabContainer.wrapper.hasAttribute("hasadjacentnewtabbutton"),
     "tabs should have the adjacent newtab attribute again");
   await endCustomizing();
   assertNewTabButton("inner");
   ok(CustomizableUI.inDefaultState, "Should be in default state");
 });
diff --git a/browser/themes/shared/tabs.inc.css b/browser/themes/shared/tabs.inc.css
--- a/browser/themes/shared/tabs.inc.css
+++ b/browser/themes/shared/tabs.inc.css
@@ -43,17 +43,17 @@
   #tabbrowser-tabpanels {
     /* Value for --in-content-page-background for dark mode in in-content/common.inc.css */
     background-color: #2A2A2E;
   }
 }
 }
 
 #tabbrowser-tabs,
-#tabbrowser-tabs > .tabbrowser-arrowscrollbox,
+#tabbrowser-tabs-wrapper > .tabbrowser-arrowscrollbox,
 #tabbrowser-tabs[positionpinnedtabs] > .tabbrowser-tab[pinned] {
   min-height: var(--tab-min-height);
 }
 
 .tab-stack {
   min-height: inherit;
 }
 
@@ -692,28 +692,28 @@
 
 .tabbrowser-arrowscrollbox > .scrollbutton-up:-moz-locale-dir(rtl),
 .tabbrowser-arrowscrollbox > .scrollbutton-down:-moz-locale-dir(ltr) {
   transform: scaleX(-1);
 }
 
 /* New tab button */
 
-.tabs-newtab-button,
+#tabs-newtab-button,
 #TabsToolbar #new-tab-button {
   list-style-image: url(chrome://browser/skin/add.svg);
 }
 
 /* All tabs button and menupopup */
 
 #alltabs-button {
   list-style-image: url(chrome://global/skin/icons/arrow-dropdown-16.svg);
 }
 
-#tabbrowser-tabs[hiddensoundplaying] ~ #alltabs-button > .toolbarbutton-badge-stack > .toolbarbutton-badge {
+#tabbrowser-tabs-wrapper[hiddensoundplaying] ~ #alltabs-button > .toolbarbutton-badge-stack > .toolbarbutton-badge {
   background: transparent url(chrome://browser/skin/tabbrowser/badge-audio-playing.svg);
   box-shadow: none;
   /* Match the color of the button, rather than label default. */
   color: inherit;
   display: block;
   -moz-context-properties: fill, fill-opacity;
   fill: currentColor;
   fill-opacity: var(--toolbarbutton-icon-fill-opacity);
diff --git a/browser/themes/windows/browser.css b/browser/themes/windows/browser.css
--- a/browser/themes/windows/browser.css
+++ b/browser/themes/windows/browser.css
@@ -206,17 +206,17 @@
  * the tabs. Unfortunately, this requires a bunch of positioning in order to get
  * text and icons to not appear fuzzy.
  */
 @media (-moz-windows-classic) {
   /**
    * We need to bump up the z-index of the tabbrowser-tabs so that they appear
    * over top of the fog we're applying for classic themes, as well as the nav-bar.
    */
-  #main-window[tabsintitlebar]:not([sizemode=fullscreen]) #tabbrowser-tabs {
+  #main-window[tabsintitlebar]:not([sizemode=fullscreen]) #tabbrowser-tabs-wrapper {
     position: relative;
     z-index: 2;
   }
 
   #main-window[tabsintitlebar] #TabsToolbar:not(:-moz-lwtheme) {
     position: relative;
   }
 
diff --git a/browser/tools/mozscreenshots/mozscreenshots/extension/configurations/Tabs.jsm b/browser/tools/mozscreenshots/mozscreenshots/extension/configurations/Tabs.jsm
--- a/browser/tools/mozscreenshots/mozscreenshots/extension/configurations/Tabs.jsm
+++ b/browser/tools/mozscreenshots/mozscreenshots/extension/configurations/Tabs.jsm
@@ -54,18 +54,17 @@ var Tabs = {
         browserWindow.gBrowser.pinTab(tab);
         tab = browserWindow.gBrowser.addTab("about:home", {
           triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
         });
         browserWindow.gBrowser.pinTab(tab);
         browserWindow.gBrowser.selectTabAtIndex(5);
         hoverTab(browserWindow.gBrowser.tabs[2]);
         // also hover the new tab button
-        let newTabButton = browserWindow.document.getAnonymousElementByAttribute(browserWindow.
-                           gBrowser.tabContainer, "anonid", "tabs-newtab-button");
+        let newTabButton = gBrowser.tabContainer.newTabButton;
         hoverTab(newTabButton);
         browserWindow.gBrowser.tabs[browserWindow.gBrowser.tabs.length - 1].
                       setAttribute("beforehovered", true);
 
         await new Promise((resolve, reject) => {
           setTimeout(resolve, 3000);
         });
         await allTabTitlesDisplayed(browserWindow);
