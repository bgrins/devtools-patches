# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  feefdfa526a80bc51010582ca8eae5263735a657
Bug 1143224 - Use getBoundsWithoutFlushing and scroll less often in the SideMenuWidget to speed up the netmonitor UI;r=vporof

diff --git a/browser/devtools/netmonitor/test/browser_net_autoscroll.js b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
--- a/browser/devtools/netmonitor/test/browser_net_autoscroll.js
+++ b/browser/devtools/netmonitor/test/browser_net_autoscroll.js
@@ -6,92 +6,81 @@
 // Whitelisting this test.
 // As part of bug 1077403, the leaking uncaught rejection should be fixed.
 //
 thisTestLeaksUncaughtRejectionsAndShouldBeFixed("TypeError: aValue.content is undefined");
 
 /**
  * Bug 863102 - Automatically scroll down upon new network requests.
  */
-
-function test() {
+add_task(function*() {
   requestLongerTimeout(2);
   let monitor, debuggee, requestsContainer, scrollTop;
 
-  initNetMonitor(INFINITE_GET_URL).then(([aTab, aDebuggee, aMonitor]) => {
-    monitor = aMonitor;
-    debuggee = aDebuggee;
-    let win = monitor.panelWin;
-    let topNode = win.document.getElementById("requests-menu-contents");
-    requestsContainer = topNode.getElementsByTagName("scrollbox")[0];
-    ok(!!requestsContainer, "Container element exists as expected.");
-  })
+  let [aTab, aDebuggee, aMonitor] = yield initNetMonitor(INFINITE_GET_URL);
+  monitor = aMonitor;
+  debuggee = aDebuggee;
+  let win = monitor.panelWin;
+  let topNode = win.document.getElementById("requests-menu-contents");
+  requestsContainer = topNode.getElementsByTagName("scrollbox")[0];
+  ok(!!requestsContainer, "Container element exists as expected.");
 
   // (1) Check that the scroll position is maintained at the bottom
   // when the requests overflow the vertical size of the container.
-  .then(() => {
-    return waitForRequestsToOverflowContainer(monitor, requestsContainer);
-  })
-  .then(() => {
-    ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
-  })
+  yield waitForRequestsToOverflowContainer(monitor, requestsContainer);
+  yield waitForScroll(monitor);
+  ok(scrolledToBottom(requestsContainer), "Scrolled to bottom on overflow.");
 
   // (2) Now set the scroll position somewhere in the middle and check
   // that additional requests do not change the scroll position.
-  .then(() => {
-    let children = requestsContainer.childNodes;
-    let middleNode = children.item(children.length / 2);
-    middleNode.scrollIntoView();
-    ok(!scrolledToBottom(requestsContainer), "Not scrolled to bottom.");
-    scrollTop = requestsContainer.scrollTop; // save for comparison later
-    return waitForNetworkEvents(monitor, 8);
-  })
-  .then(() => {
-    is(requestsContainer.scrollTop, scrollTop, "Did not scroll.");
-  })
+  let children = requestsContainer.childNodes;
+  let middleNode = children.item(children.length / 2);
+  middleNode.scrollIntoView();
+  ok(!scrolledToBottom(requestsContainer), "Not scrolled to bottom.");
+  scrollTop = requestsContainer.scrollTop; // save for comparison later
+  yield waitForNetworkEvents(monitor, 8);
+  yield waitSomeTime();
+  is(requestsContainer.scrollTop, scrollTop, "Did not scroll.");
 
   // (3) Now set the scroll position back at the bottom and check that
   // additional requests *do* cause the container to scroll down.
-  .then(() => {
-    requestsContainer.scrollTop = requestsContainer.scrollHeight;
-    ok(scrolledToBottom(requestsContainer), "Set scroll position to bottom.");
-    return waitForNetworkEvents(monitor, 8);
-  })
-  .then(() => {
-    ok(scrolledToBottom(requestsContainer), "Still scrolled to bottom.");
-  })
+  requestsContainer.scrollTop = requestsContainer.scrollHeight;
+  ok(scrolledToBottom(requestsContainer), "Set scroll position to bottom.");
+  yield waitForNetworkEvents(monitor, 8);
+  yield waitForScroll(monitor);
+  ok(scrolledToBottom(requestsContainer), "Still scrolled to bottom.");
 
   // (4) Now select an item in the list and check that additional requests
   // do not change the scroll position.
-  .then(() => {
-    monitor.panelWin.NetMonitorView.RequestsMenu.selectedIndex = 0;
-    return waitForNetworkEvents(monitor, 8);
-  })
-  .then(() => {
-    is(requestsContainer.scrollTop, 0, "Did not scroll.");
-  })
+  monitor.panelWin.NetMonitorView.RequestsMenu.selectedIndex = 0;
+  yield waitForNetworkEvents(monitor, 8);
+  yield waitSomeTime();
+  is(requestsContainer.scrollTop, 0, "Did not scroll.");
 
-  // Done; clean up.
-  .then(() => {
-    return teardown(monitor).then(finish);
-  })
+  // Done: clean up.
+  yield teardown(monitor);
 
-  // Handle exceptions in the chain of promises.
-  .then(null, (err) => {
-    ok(false, err);
-    finish();
-  });
+  finish();
 
-  function waitForRequestsToOverflowContainer (aMonitor, aContainer) {
+  function waitForRequestsToOverflowContainer(aMonitor, aContainer) {
     return waitForNetworkEvents(aMonitor, 1).then(() => {
       if (aContainer.scrollHeight > aContainer.clientHeight) {
-        // Wait for some more just for good measure.
-        return waitForNetworkEvents(aMonitor, 8);
+        return promise.resolve();
       } else {
         return waitForRequestsToOverflowContainer(aMonitor, aContainer);
       }
     });
   }
 
   function scrolledToBottom(aElement) {
     return aElement.scrollTop + aElement.clientHeight >= aElement.scrollHeight;
   }
-}
+
+  function waitSomeTime() {
+    let waitSomeTime = promise.defer();
+    setTimeout(waitSomeTime.resolve, 50); // Wait to make sure no scrolls happen
+    return waitSomeTime.promise;
+  }
+
+  function waitForScroll(aMonitor) {
+    return aMonitor._view.RequestsMenu.widget.once("scroll-to-bottom");
+  }
+});
diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -5,19 +5,22 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/event-emitter.js");
+const {DeferredTask} = Cu.import("resource://gre/modules/DeferredTask.jsm", {});
 
 this.EXPORTED_SYMBOLS = ["SideMenuWidget"];
 
+const SCROLL_FREQUENCY = 16;
+
 /**
  * A simple side menu, with the ability of grouping menu items.
  *
  * Note: this widget should be used in tandem with the WidgetMethods in
  * ViewHelpers.jsm.
  *
  * @param nsIDOMNode aNode
  *        The element associated with the widget.
@@ -108,31 +111,85 @@ SideMenuWidget.prototype = {
     // needlessly expensive operations that may cause reflows):
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
-      // 4. The list should already be scrolled at the bottom.
-      (this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight);
+      // 4. We aren't waiting for a scroll to happen.
+      (!this._scrollToBottomTask || !this._scrollToBottomTask.isArmed) &&
+      // 5. The list should already be scrolled at the bottom.
+      this.isScrolledToBottom();
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
     if (maintainScrollAtBottom) {
-      this._list.scrollTop = this._list.scrollHeight;
+      this.scrollToBottom();
     }
 
     return element;
   },
 
   /**
+   * Checks to see if the list is scrolled all the way to the bottom.
+   * Uses getBoundsWithoutFlushing to limit the performance impact
+   * of this function.
+   *
+   * @return bool
+   */
+  isScrolledToBottom: function() {
+    if (this._list.lastElementChild) {
+      let utils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                             .getInterface(Ci.nsIDOMWindowUtils);
+      let childRect = utils.getBoundsWithoutFlushing(this._list.lastElementChild);
+      let listRect = utils.getBoundsWithoutFlushing(this._list);
+
+      // Cheap way to check if it's scrolled all the way to the bottom.
+      return (childRect.height + childRect.top) <= listRect.bottom;
+    }
+
+    return false;
+  },
+
+  /**
+   * Scroll the list to the bottom after a timeout.
+   * If the user scrolls in the meantime, cancel this operation.
+   */
+  scrollToBottom: function() {
+    // Lazily attach this functionality to the object, so it won't get
+    // created unless if this scrollToBottom behavior is needed.
+    if (!this._scrollToBottomTask) {
+      // The scroll event fires asynchronously, so we need to keep a bit to
+      // distinguish between user-initiated events and scrollTop assignment.
+      let ignoreNextScroll = false;
+
+      this._scrollToBottomTask = new DeferredTask(() => {
+        ignoreNextScroll = true;
+        this._list.scrollTop = this._list.scrollHeight;
+        this.emit("scroll-to-bottom");
+      }, SCROLL_FREQUENCY);
+
+      // On a user scroll, cancel any pending calls to the scroll function.
+      this._list.addEventListener("scroll", () => {
+        if (!ignoreNextScroll && this._scrollToBottomTask.isArmed &&
+            !this.isScrolledToBottom()) {
+          this._scrollToBottomTask.disarm();
+        }
+        ignoreNextScroll = false;
+      }, true);
+    }
+
+    this._scrollToBottomTask.arm();
+  },
+
+  /**
    * Returns the child node in this container situated at the specified index.
    *
    * @param number aIndex
    *        The position in the container intended for this item.
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   getItemAtIndex: function(aIndex) {
