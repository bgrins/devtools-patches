# HG changeset patch
# Parent 8ca3b35eb9551dce88632438d275e398c6b46693
# User Joe Walker <jwalker@mozilla.com>
Bug 900114 - GCLI rollup for bugs 781856, 884015, 789884, 892901, 773188

diff --git a/browser/devtools/commandline/test/browser_cmd_cookie.js b/browser/devtools/commandline/test/browser_cmd_cookie.js
--- a/browser/devtools/commandline/test/browser_cmd_cookie.js
+++ b/browser/devtools/commandline/test/browser_cmd_cookie.js
@@ -8,17 +8,17 @@ const TEST_URI = "http://example.com/bro
 
 function test() {
   helpers.addTabWithToolbar(TEST_URI, function(options) {
     return helpers.audit(options, [
       {
         setup: 'cookie',
         check: {
           input:  'cookie',
-          hints:        '',
+          hints:        ' list',
           markup: 'IIIIII',
           status: 'ERROR'
         },
       },
       {
         setup: 'cookie lis',
         check: {
           input:  'cookie lis',
diff --git a/browser/devtools/commandline/test/browser_cmd_pagemod_export.js b/browser/devtools/commandline/test/browser_cmd_pagemod_export.js
--- a/browser/devtools/commandline/test/browser_cmd_pagemod_export.js
+++ b/browser/devtools/commandline/test/browser_cmd_pagemod_export.js
@@ -180,17 +180,17 @@ function test() {
   };
 
   tests.testPageModRemoveElement = function(options) {
     return helpers.audit(options, [
       {
         setup: 'pagemod remove',
         check: {
           input:  'pagemod remove',
-          hints:                '',
+          hints:                ' attribute',
           markup: 'IIIIIIIVIIIIII',
           status: 'ERROR'
         },
       },
       {
         setup: 'pagemod remove element',
         check: {
           input:  'pagemod remove element',
diff --git a/browser/devtools/commandline/test/browser_cmd_pref.js b/browser/devtools/commandline/test/browser_cmd_pref.js
--- a/browser/devtools/commandline/test/browser_cmd_pref.js
+++ b/browser/devtools/commandline/test/browser_cmd_pref.js
@@ -41,17 +41,17 @@ let tests = {
   },
 
   testPrefStatus: function(options) {
     return helpers.audit(options, [
       {
         setup: 'pref',
         check: {
           input:  'pref',
-          hints:      '',
+          hints:      ' reset',
           markup: 'IIII',
           status: 'ERROR'
         },
       },
       {
         setup: 'pref s',
         check: {
           input:  'pref s',
diff --git a/browser/devtools/commandline/test/browser_gcli_canon.js b/browser/devtools/commandline/test/browser_gcli_canon.js
--- a/browser/devtools/commandline/test/browser_gcli_canon.js
+++ b/browser/devtools/commandline/test/browser_gcli_canon.js
@@ -35,18 +35,18 @@ function test() {
 
 'use strict';
 
 // var helpers = require('gclitest/helpers');
 var canon = require('gcli/canon');
 // var assert = require('test/assert');
 var Canon = canon.Canon;
 
-var startCount = undefined;
-var events = undefined;
+var startCount;
+var events;
 
 var canonChange = function(ev) {
   events++;
 };
 
 exports.setup = function(options) {
   startCount = canon.getCommands().length;
   events = 0;
diff --git a/browser/devtools/commandline/test/browser_gcli_cli.js b/browser/devtools/commandline/test/browser_gcli_cli.js
--- a/browser/devtools/commandline/test/browser_gcli_cli.js
+++ b/browser/devtools/commandline/test/browser_gcli_cli.js
@@ -1066,17 +1066,17 @@ exports.testElement = function(options) 
 };
 
 exports.testNestedCommand = function(options) {
   return helpers.audit(options, [
     {
       setup:    'tsn',
       check: {
         input:  'tsn',
-        hints:     '',
+        hints:     ' deep down nested cmd',
         markup: 'III',
         cursor: 3,
         current: '__command',
         status: 'ERROR',
         predictionsInclude: [
           'tsn deep', 'tsn deep down', 'tsn deep down nested',
           'tsn deep down nested cmd', 'tsn dif'
         ],
@@ -1085,17 +1085,17 @@ exports.testNestedCommand = function(opt
           command: { name: 'tsn' }
         }
       }
     },
     {
       setup:    'tsn ',
       check: {
         input:  'tsn ',
-        hints:      '',
+        hints:      ' deep down nested cmd',
         markup: 'IIIV',
         cursor: 4,
         current: '__command',
         status: 'ERROR',
         unassigned: [ ]
       }
     },
     {
@@ -1280,22 +1280,22 @@ exports.testNestedCommand = function(opt
 
 // From Bug 664203
 exports.testDeeplyNested = function(options) {
   return helpers.audit(options, [
     {
       setup:    'tsn deep down nested',
       check: {
         input:  'tsn deep down nested',
-        hints:                      '',
+        hints:                      ' cmd',
         markup: 'IIIVIIIIVIIIIVIIIIII',
         cursor: 20,
         current: '__command',
         status: 'ERROR',
-        predictions: [ 'tsn deep down nested', 'tsn deep down nested cmd' ],
+        predictions: [ 'tsn deep down nested cmd' ],
         unassigned: [ ],
         outputState: 'false:default',
         tooltipState: 'false:default',
         args: {
           command: { name: 'tsn deep down nested' },
         }
       }
     },
diff --git a/browser/devtools/commandline/test/browser_gcli_context.js b/browser/devtools/commandline/test/browser_gcli_context.js
--- a/browser/devtools/commandline/test/browser_gcli_context.js
+++ b/browser/devtools/commandline/test/browser_gcli_context.js
@@ -71,41 +71,41 @@ exports.testBaseline = function(options)
         message: 'Too many arguments',
         unassigned: [ ' test' ],
       }
     },
     {
       setup:    'tsn',
       check: {
         input:  'tsn',
-        hints:     '',
+        hints:     ' deep down nested cmd',
         markup: 'III',
         cursor: 3,
         current: '__command',
         status: 'ERROR',
-        predictionsContains: [ 'tsn', 'tsn deep', 'tsn ext', 'tsn exte' ],
+        predictionsContains: [ 'tsn deep down nested cmd', 'tsn ext', 'tsn exte' ],
         args: {
           command: { name: 'tsn' },
         }
       }
     }
   ]);
 };
 
 exports.testContext = function(options) {
   return helpers.audit(options, [
     // Use the 'tsn' context
     {
       setup:    'context tsn',
       check: {
         input:  'context tsn',
-        hints:             '',
+        hints:             ' deep down nested cmd',
         markup: 'VVVVVVVVVVV',
         message: '',
-        predictionsContains: [ 'tsn', 'tsn deep', 'tsn ext', 'tsn exte' ],
+        predictionsContains: [ 'tsn deep down nested cmd', 'tsn ext', 'tsn exte' ],
         args: {
           command: { name: 'context' },
           prefix: {
             value: mockCommands.commands.tsn,
             status: 'VALID',
             message: ''
           },
         }
@@ -154,20 +154,20 @@ exports.testContext = function(options) 
         output: 'Exec: tsnExt text=test',
         completed: true,
       }
     },
     {
       setup:    'tsn',
       check: {
         input:  'tsn',
-        hints:     '',
+        hints:     ' deep down nested cmd',
         markup: 'III',
         message: '',
-        predictionsContains: [ 'tsn', 'tsn deep', 'tsn ext', 'tsn exte' ],
+        predictionsContains: [ 'tsn deep down nested cmd', 'tsn ext', 'tsn exte' ],
         args: {
           command: { name: 'tsn' },
         }
       }
     },
     // Does it actually work?
     {
       setup:    'tsb true',
@@ -192,17 +192,17 @@ exports.testContext = function(options) 
     },
     {
       setup:    'context "tsn ext"',
       check: {
         input:  'context "tsn ext"',
         hints:                   '',
         markup: 'VVVVVVVVVVVVVVVVV',
         message: '',
-        predictions: [ ],
+        predictions: [ 'tsn ext', 'tsn exte', 'tsn exten', 'tsn extend' ],
         unassigned: [ ],
         args: {
           command: { name: 'context' },
           prefix: {
             value: mockCommands.commands.tsnExt,
             status: 'VALID',
             message: ''
           }
diff --git a/browser/devtools/commandline/test/browser_gcli_date.js b/browser/devtools/commandline/test/browser_gcli_date.js
--- a/browser/devtools/commandline/test/browser_gcli_date.js
+++ b/browser/devtools/commandline/test/browser_gcli_date.js
@@ -47,17 +47,16 @@ var Status = require('gcli/types').Statu
 exports.setup = function(options) {
   mockCommands.setup();
 };
 
 exports.shutdown = function(options) {
   mockCommands.shutdown();
 };
 
-
 exports.testParse = function(options) {
   var date = types.createType('date');
   return date.parse(new Argument('now')).then(function(conversion) {
     // Date comparison - these 2 dates may not be the same, but how close is
     // close enough? If this test takes more than 30secs to run the it will
     // probably time out, so we'll assume that these 2 values must be within
     // 1 min of each other
     var gap = new Date().getTime() - conversion.value.getTime();
@@ -87,18 +86,16 @@ exports.testIncrement = function(options
     var gap = new Date().getTime() - minusOne.getTime();
     assert.ok(gap < 60000, 'now is less than a minute away');
   });
 };
 
 exports.testInput = function(options) {
   return helpers.audit(options, [
     {
-      // See bug 892901
-      skipRemainingIf: options.isFirefox,
       setup:    'tsdate 2001-01-01 1980-01-03',
       check: {
         input:  'tsdate 2001-01-01 1980-01-03',
         hints:                              '',
         markup: 'VVVVVVVVVVVVVVVVVVVVVVVVVVVV',
         status: 'VALID',
         message: '',
         args: {
@@ -114,45 +111,173 @@ exports.testInput = function(options) {
               assert.is(d1.getMilliseconds(), 0, 'd1 millis');
             },
             arg: ' 2001-01-01',
             status: 'VALID',
             message: ''
           },
           d2: {
             value: function(d2) {
-              assert.is(d2.getFullYear(), 1980, 'd1 year');
-              assert.is(d2.getMonth(), 0, 'd1 month');
-              assert.is(d2.getDate(), 3, 'd1 date');
-              assert.is(d2.getHours(), 0, 'd1 hours');
-              assert.is(d2.getMinutes(), 0, 'd1 minutes');
-              assert.is(d2.getSeconds(), 0, 'd1 seconds');
-              assert.is(d2.getMilliseconds(), 0, 'd1 millis');
+              assert.is(d2.getFullYear(), 1980, 'd2 year');
+              assert.is(d2.getMonth(), 0, 'd2 month');
+              assert.is(d2.getDate(), 3, 'd2 date');
+              assert.is(d2.getHours(), 0, 'd2 hours');
+              assert.is(d2.getMinutes(), 0, 'd2 minutes');
+              assert.is(d2.getSeconds(), 0, 'd2 seconds');
+              assert.is(d2.getMilliseconds(), 0, 'd2 millis');
             },
             arg: ' 1980-01-03',
             status: 'VALID',
             message: ''
           },
         }
       },
       exec: {
         output: [ /^Exec: tsdate/, /2001/, /1980/ ],
         completed: true,
         type: 'string',
         error: false
       }
+    },
+    {
+      setup:    'tsdate 2001/01/01 1980/01/03',
+      check: {
+        input:  'tsdate 2001/01/01 1980/01/03',
+        hints:                              '',
+        markup: 'VVVVVVVVVVVVVVVVVVVVVVVVVVVV',
+        status: 'VALID',
+        message: '',
+        args: {
+          command: { name: 'tsdate' },
+          d1: {
+            value: function(d1) {
+              assert.is(d1.getFullYear(), 2001, 'd1 year');
+              assert.is(d1.getMonth(), 0, 'd1 month');
+              assert.is(d1.getDate(), 1, 'd1 date');
+              assert.is(d1.getHours(), 0, 'd1 hours');
+              assert.is(d1.getMinutes(), 0, 'd1 minutes');
+              assert.is(d1.getSeconds(), 0, 'd1 seconds');
+              assert.is(d1.getMilliseconds(), 0, 'd1 millis');
+            },
+            arg: ' 2001/01/01',
+            status: 'VALID',
+            message: ''
+          },
+          d2: {
+            value: function(d2) {
+              assert.is(d2.getFullYear(), 1980, 'd2 year');
+              assert.is(d2.getMonth(), 0, 'd2 month');
+              assert.is(d2.getDate(), 3, 'd2 date');
+              assert.is(d2.getHours(), 0, 'd2 hours');
+              assert.is(d2.getMinutes(), 0, 'd2 minutes');
+              assert.is(d2.getSeconds(), 0, 'd2 seconds');
+              assert.is(d2.getMilliseconds(), 0, 'd2 millis');
+            },
+            arg: ' 1980/01/03',
+            status: 'VALID',
+            message: ''
+          },
+        }
+      },
+      exec: {
+        output: [ /^Exec: tsdate/, /2001/, /1980/ ],
+        completed: true,
+        type: 'string',
+        error: false
+      }
+    },
+    {
+      setup:    'tsdate now today',
+      check: {
+        input:  'tsdate now today',
+        hints:                  '',
+        markup: 'VVVVVVVVVVVVVVVV',
+        status: 'VALID',
+        message: '',
+        args: {
+          command: { name: 'tsdate' },
+          d1: {
+            value: function(d1) {
+              // How long should we allow between d1 and now? Mochitest will
+              // time out after 30 secs, so that seems like a decent upper
+              // limit, although 30 ms should probably do it. I don't think
+              // reducing the limit from 30 secs will find any extra bugs
+              assert.ok(d1.getTime() - new Date().getTime() < 30 * 1000,
+                        'd1 time');
+            },
+            arg: ' now',
+            status: 'VALID',
+            message: ''
+          },
+          d2: {
+            value: function(d2) {
+              // See comment for d1 above
+              assert.ok(d2.getTime() - new Date().getTime() < 30 * 1000,
+                        'd2 time');
+            },
+            arg: ' today',
+            status: 'VALID',
+            message: ''
+          },
+        }
+      },
+      exec: {
+        output: [ /^Exec: tsdate/, new Date().getFullYear() ],
+        completed: true,
+        type: 'string',
+        error: false
+      }
+    },
+    {
+      setup:    'tsdate yesterday tomorrow',
+      check: {
+        input:  'tsdate yesterday tomorrow',
+        hints:                           '',
+        markup: 'VVVVVVVVVVVVVVVVVVVVVVVVV',
+        status: 'VALID',
+        message: '',
+        args: {
+          command: { name: 'tsdate' },
+          d1: {
+            value: function(d1) {
+              var compare = new Date().getTime() - (24 * 60 * 60 * 1000);
+              // See comment for d1 in the test for 'tsdate now today'
+              assert.ok(d1.getTime() - compare < 30 * 1000,
+                        'd1 time');
+            },
+            arg: ' yesterday',
+            status: 'VALID',
+            message: ''
+          },
+          d2: {
+            value: function(d2) {
+              var compare = new Date().getTime() + (24 * 60 * 60 * 1000);
+              // See comment for d1 in the test for 'tsdate now today'
+              assert.ok(d2.getTime() - compare < 30 * 1000,
+                        'd2 time');
+            },
+            arg: ' tomorrow',
+            status: 'VALID',
+            message: ''
+          },
+        }
+      },
+      exec: {
+        output: [ /^Exec: tsdate/, new Date().getFullYear() ],
+        completed: true,
+        type: 'string',
+        error: false
+      }
     }
   ]);
 };
 
 exports.testIncrDecr = function(options) {
   return helpers.audit(options, [
     {
-      // See bug 892901
-      skipRemainingIf: options.isFirefox,
       setup:    'tsdate 2001-01-01<UP>',
       check: {
         input:  'tsdate 2001-01-02',
         hints:                    ' <d2>',
         markup: 'VVVVVVVVVVVVVVVVV',
         status: 'ERROR',
         message: '',
         args: {
diff --git a/browser/devtools/commandline/test/browser_gcli_fileparser.js b/browser/devtools/commandline/test/browser_gcli_fileparser.js
--- a/browser/devtools/commandline/test/browser_gcli_fileparser.js
+++ b/browser/devtools/commandline/test/browser_gcli_fileparser.js
@@ -37,21 +37,22 @@ function test() {
 
 // var assert = require('test/assert');
 var fileparser = require('util/fileparser');
 
 var local = false;
 
 exports.testGetPredictor = function(options) {
   if (!options.isNode || !local) {
+    assert.log('Skipping tests due to install differences.');
     return;
   }
 
-  var options = { filetype: 'file', existing: 'yes' };
-  var predictor = fileparser.getPredictor('/usr/locl/bin/nmp', options);
+  var opts = { filetype: 'file', existing: 'yes' };
+  var predictor = fileparser.getPredictor('/usr/locl/bin/nmp', opts);
   return predictor().then(function(replies) {
     assert.is(replies[0].name,
               '/usr/local/bin/npm',
               'predict npm');
   });
 };
 
 // });
diff --git a/browser/devtools/commandline/test/browser_gcli_focus.js b/browser/devtools/commandline/test/browser_gcli_focus.js
--- a/browser/devtools/commandline/test/browser_gcli_focus.js
+++ b/browser/devtools/commandline/test/browser_gcli_focus.js
@@ -58,33 +58,33 @@ exports.testBasic = function(options) {
       },
       check: { },
       exec: { }
     },
     {
       setup:    'tsn deep',
       check: {
         input:  'tsn deep',
-        hints:          '',
+        hints:          ' down nested cmd',
         markup: 'IIIVIIII',
         cursor: 8,
         status: 'ERROR',
         outputState: 'false:default',
         tooltipState: 'false:default'
       }
     },
     {
-      setup:    'tsn deep<TAB><RETURN>',
+      setup:    'tsn deep<TAB>',
       check: {
-        input:  'tsn deep ',
-        hints:           '',
-        markup: 'IIIIIIIIV',
-        cursor: 9,
-        status: 'ERROR',
+        input:  'tsn deep down nested cmd ',
+        hints:                           '',
+        markup: 'VVVVVVVVVVVVVVVVVVVVVVVVV',
+        cursor: 25,
+        status: 'VALID',
         outputState: 'false:default',
-        tooltipState: 'true:isError'
+        tooltipState: 'false:default'
       }
     }
   ]);
 };
 
 
 // });
diff --git a/browser/devtools/commandline/test/browser_gcli_incomplete.js b/browser/devtools/commandline/test/browser_gcli_incomplete.js
--- a/browser/devtools/commandline/test/browser_gcli_incomplete.js
+++ b/browser/devtools/commandline/test/browser_gcli_incomplete.js
@@ -81,17 +81,17 @@ exports.testBasic = function(options) {
         args: {
           solo: { type: 'BlankArgument' },
           txt1: { type: 'BlankArgument' },
           bool: { type: 'BlankArgument' },
           txt2: { type: 'BlankArgument' },
           num: { type: 'BlankArgument' }
         }
       }
-    },
+    }
   ]);
 };
 
 exports.testCompleted = function(options) {
   return helpers.audit(options, [
     {
       setup: 'tsela<TAB>',
       check: {
@@ -231,17 +231,17 @@ exports.testCase = function(options) {
         args: {
           solo: { value: undefined, text: 'AA', status: 'INCOMPLETE' },
           txt1: { value: undefined, status: 'VALID' },
           bool: { value: false, status: 'VALID' },
           txt2: { value: undefined, status: 'VALID' },
           num: { value: undefined, status: 'VALID' }
         }
       }
-    },
+    }
   ]);
 };
 
 exports.testIncomplete = function(options) {
   return helpers.audit(options, [
     {
       setup:    'tsm a a -',
       check: {
@@ -271,17 +271,70 @@ exports.testIncomplete = function(option
                   'unassigned -');
         assert.is(requisition._unassigned.length,
                   1,
                   'single unassigned - tsg -');
         assert.is(requisition._unassigned[0].param.type.isIncompleteName,
                   true,
                   'unassigned.isIncompleteName: tsg -');
       }
-    },
+    }
+  ]);
+};
+
+exports.testRepeated = function(options) {
+  return helpers.audit(options, [
+    {
+      setup:    'tscook key value --path jjj --path kkk',
+      check: {
+        input:  'tscook key value --path jjj --path kkk',
+        hints:                                        ' [options]',
+        markup: 'VVVVVVVVVVVVVVVVVVVVVVVVVVVVEEEEEEVEEE',
+        cursor: 38,
+        current: '__unassigned',
+        status: 'ERROR',
+        options: [ ],
+        message: '',
+        predictions: [ ],
+        unassigned: [ ' --path', ' kkk' ],
+        args: {
+          command: { name: 'tscook' },
+          key: {
+            value: 'key',
+            arg: ' key',
+            status: 'VALID',
+            message: ''
+          },
+          value: {
+            value: 'value',
+            arg: ' value',
+            status: 'VALID',
+            message: ''
+          },
+          path: {
+            value: 'jjj',
+            arg: ' --path jjj',
+            status: 'VALID',
+            message: ''
+          },
+          domain: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          secure: {
+            value: false,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+        }
+      }
+    }
   ]);
 };
 
 exports.testHidden = function(options) {
   return helpers.audit(options, [
     {
       setup:    'tshidde',
       check: {
@@ -396,13 +449,13 @@ exports.testHidden = function(options) {
         status: 'VALID',
         hints:  '',
         args: {
           visible: { value: 'xxx', status: 'VALID' },
           invisiblestring: { value: undefined, status: 'VALID' },
           invisibleboolean: { value: false, status: 'VALID' }
         }
       }
-    },
+    }
   ]);
 };
 
 // });
diff --git a/browser/devtools/commandline/test/browser_gcli_inputter.js b/browser/devtools/commandline/test/browser_gcli_inputter.js
--- a/browser/devtools/commandline/test/browser_gcli_inputter.js
+++ b/browser/devtools/commandline/test/browser_gcli_inputter.js
@@ -34,18 +34,18 @@ function test() {
 // <INJECTED SOURCE:END>
 
 'use strict';
 
 var KeyEvent = require('util/util').KeyEvent;
 // var assert = require('test/assert');
 // var mockCommands = require('gclitest/mockCommands');
 
-var latestEvent = undefined;
-var latestData = undefined;
+var latestEvent;
+var latestData;
 
 var outputted = function(ev) {
   latestEvent = ev;
 
   ev.output.promise.then(function() {
     latestData = ev.output.data;
     ev.output.onClose();
   });
diff --git a/browser/devtools/commandline/test/browser_gcli_js.js b/browser/devtools/commandline/test/browser_gcli_js.js
--- a/browser/devtools/commandline/test/browser_gcli_js.js
+++ b/browser/devtools/commandline/test/browser_gcli_js.js
@@ -35,17 +35,17 @@ function test() {
 
 'use strict';
 
 // var assert = require('test/assert');
 // var helpers = require('gclitest/helpers');
 var javascript = require('gcli/types/javascript');
 var canon = require('gcli/canon');
 
-var tempWindow = undefined;
+var tempWindow;
 
 exports.setup = function(options) {
   tempWindow = javascript.getGlobalObject();
   Object.defineProperty(options.window, 'donteval', {
     get: function() {
       assert.ok(false, 'donteval should not be used');
       return { cant: '', touch: '', 'this': '' };
     },
diff --git a/browser/devtools/commandline/test/browser_gcli_keyboard3.js b/browser/devtools/commandline/test/browser_gcli_keyboard3.js
--- a/browser/devtools/commandline/test/browser_gcli_keyboard3.js
+++ b/browser/devtools/commandline/test/browser_gcli_keyboard3.js
@@ -35,17 +35,17 @@ function test() {
 
 'use strict';
 
 var javascript = require('gcli/types/javascript');
 // var helpers = require('gclitest/helpers');
 // var mockCommands = require('gclitest/mockCommands');
 var canon = require('gcli/canon');
 
-var tempWindow = undefined;
+var tempWindow;
 
 exports.setup = function(options) {
   mockCommands.setup();
 
   tempWindow = javascript.getGlobalObject();
   javascript.setGlobalObject(options.window);
 };
 
diff --git a/browser/devtools/commandline/test/browser_gcli_resource.js b/browser/devtools/commandline/test/browser_gcli_resource.js
--- a/browser/devtools/commandline/test/browser_gcli_resource.js
+++ b/browser/devtools/commandline/test/browser_gcli_resource.js
@@ -38,17 +38,17 @@ function test() {
 // var assert = require('test/assert');
 var util = require('util/util');
 
 var resource = require('gcli/types/resource');
 var types = require('gcli/types');
 var Status = require('gcli/types').Status;
 
 
-var tempDocument = undefined;
+var tempDocument;
 
 exports.setup = function(options) {
   tempDocument = resource.getDocument();
   resource.setDocument(options.window.document);
 };
 
 exports.shutdown = function(options) {
   resource.setDocument(tempDocument);
diff --git a/browser/devtools/commandline/test/browser_gcli_scratchpad.js b/browser/devtools/commandline/test/browser_gcli_scratchpad.js
--- a/browser/devtools/commandline/test/browser_gcli_scratchpad.js
+++ b/browser/devtools/commandline/test/browser_gcli_scratchpad.js
@@ -32,17 +32,17 @@ function test() {
 }
 
 // <INJECTED SOURCE:END>
 
 'use strict';
 
 // var assert = require('test/assert');
 
-var origScratchpad = undefined;
+var origScratchpad;
 
 exports.setup = function(options) {
   origScratchpad = options.display.inputter.scratchpad;
   options.display.inputter.scratchpad = stubScratchpad;
 };
 
 exports.shutdown = function(options) {
   options.display.inputter.scratchpad = origScratchpad;
diff --git a/browser/devtools/commandline/test/browser_gcli_short.js b/browser/devtools/commandline/test/browser_gcli_short.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/commandline/test/browser_gcli_short.js
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2012, Mozilla Foundation and contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// define(function(require, exports, module) {
+
+// <INJECTED SOURCE:START>
+
+// THIS FILE IS GENERATED FROM SOURCE IN THE GCLI PROJECT
+// DO NOT EDIT IT DIRECTLY
+
+var exports = {};
+
+const TEST_URI = "data:text/html;charset=utf-8,<p id='gcli-input'>gcli-testShort.js</p>";
+
+function test() {
+  helpers.addTabWithToolbar(TEST_URI, function(options) {
+    return helpers.runTests(options, exports);
+  }).then(finish);
+}
+
+// <INJECTED SOURCE:END>
+
+'use strict';
+
+// var assert = require('test/assert');
+// var helpers = require('gclitest/helpers');
+// var mockCommands = require('gclitest/mockCommands');
+
+exports.setup = function(options) {
+  mockCommands.setup();
+};
+
+exports.shutdown = function(options) {
+  mockCommands.shutdown();
+};
+
+exports.testBasic = function(options) {
+  return helpers.audit(options, [
+    {
+      setup:    'tshidden -v',
+      check: {
+        input:  'tshidden -v',
+        hints:             ' <string>',
+        markup: 'VVVVVVVVVII',
+        cursor: 11,
+        current: 'visible',
+        status: 'ERROR',
+        options: [ ],
+        message: '',
+        predictions: [ ],
+        unassigned: [ ],
+        args: {
+          command: { name: 'tshidden' },
+          visible: {
+            value: undefined,
+            arg: ' -v',
+            status: 'INCOMPLETE',
+            message: ''
+          },
+          invisiblestring: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisibleboolean: {
+            value: false,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          }
+        }
+      }
+    },
+    {
+      setup:    'tshidden -v v',
+      check: {
+        input:  'tshidden -v v',
+        hints:               '',
+        markup: 'VVVVVVVVVVVVV',
+        cursor: 13,
+        current: 'visible',
+        status: 'VALID',
+        options: [ ],
+        message: '',
+        predictions: [ ],
+        unassigned: [ ],
+        args: {
+          command: { name: 'tshidden' },
+          visible: {
+            value: 'v',
+            arg: ' -v v',
+            status: 'VALID',
+            message: ''
+          },
+          invisiblestring: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisibleboolean: {
+            value: false,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          }
+        }
+      }
+    },
+    {
+      setup:    'tshidden -i i',
+      check: {
+        input:  'tshidden -i i',
+        hints:               ' [options]',
+        markup: 'VVVVVVVVVVVVV',
+        cursor: 13,
+        current: 'invisiblestring',
+        status: 'VALID',
+        options: [ ],
+        message: '',
+        predictions: [ ],
+        unassigned: [ ],
+        args: {
+          command: { name: 'tshidden' },
+          visible: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisiblestring: {
+            value: 'i',
+            arg: ' -i i',
+            status: 'VALID',
+            message: ''
+          },
+          invisibleboolean: {
+            value: false,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          }
+        }
+      }
+    },
+    {
+      setup:    'tshidden -b',
+      check: {
+        input:  'tshidden -b',
+        hints:             ' [options]',
+        markup: 'VVVVVVVVVVV',
+        cursor: 11,
+        current: 'invisibleboolean',
+        status: 'VALID',
+        options: [ ],
+        message: '',
+        predictions: [ ],
+        unassigned: [ ],
+        args: {
+          command: { name: 'tshidden' },
+          visible: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisiblestring: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisibleboolean: {
+            value: true,
+            arg: ' -b',
+            status: 'VALID',
+            message: ''
+          }
+        }
+      }
+    },
+    {
+      setup:    'tshidden -j',
+      check: {
+        input:  'tshidden -j',
+        hints:             ' [options]',
+        markup: 'VVVVVVVVVEE',
+        cursor: 11,
+        current: '__unassigned',
+        status: 'ERROR',
+        options: [ ],
+        message: 'Can\'t use \'-j\'.',
+        predictions: [ ],
+        unassigned: [ ' -j' ],
+        args: {
+          command: { name: 'tshidden' },
+          visible: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisiblestring: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisibleboolean: {
+            value: false,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          }
+        }
+      }
+    },
+    {
+      setup:    'tshidden -v jj -b --',
+      check: {
+        input:  'tshidden -v jj -b --',
+        hints:                      '',
+        markup: 'VVVVVVVVVVVVVVVVVVEE',
+        cursor: 20,
+        current: '__unassigned',
+        status: 'ERROR',
+        options: [ ],
+        message: 'Can\'t use \'--\'.',
+        predictions: [ ],
+        unassigned: [ ' --' ],
+        args: {
+          command: { name: 'tshidden' },
+          visible: {
+            value: 'jj',
+            arg: ' -v jj',
+            status: 'VALID',
+            message: ''
+          },
+          invisiblestring: {
+            value: undefined,
+            arg: '',
+            status: 'VALID',
+            message: ''
+          },
+          invisibleboolean: {
+            value: true,
+            arg: ' -b',
+            status: 'VALID',
+            message: ''
+          }
+        }
+      }
+    }
+  ]);
+};
+
+
+// });
diff --git a/browser/devtools/commandline/test/browser_gcli_util.js b/browser/devtools/commandline/test/browser_gcli_util.js
--- a/browser/devtools/commandline/test/browser_gcli_util.js
+++ b/browser/devtools/commandline/test/browser_gcli_util.js
@@ -34,16 +34,21 @@ function test() {
 // <INJECTED SOURCE:END>
 
 'use strict';
 
 var util = require('util/util');
 // var assert = require('test/assert');
 
 exports.testFindCssSelector = function(options) {
+  if (options.isPhantomjs) {
+    assert.log('Skipping tests due to issues with querySelectorAll.');
+    return;
+  }
+
   var nodes = options.window.document.querySelectorAll('*');
   for (var i = 0; i < nodes.length; i++) {
     var selector = util.findCssSelector(nodes[i]);
     var matches = options.window.document.querySelectorAll(selector);
 
     assert.is(matches.length, 1, 'multiple matches for ' + selector);
     assert.is(matches[0], nodes[i], 'non-matching selector: ' + selector);
   }
diff --git a/browser/devtools/commandline/test/helpers.js b/browser/devtools/commandline/test/helpers.js
--- a/browser/devtools/commandline/test/helpers.js
+++ b/browser/devtools/commandline/test/helpers.js
@@ -304,30 +304,30 @@ helpers._actual = {
                         templateData.emptyParameters,
                         templateData.arrowTabText);
   },
 
   markup: function(options) {
     var cursor = options.display.inputter.element.selectionStart;
     var statusMarkup = options.display.requisition.getInputStatusMarkup(cursor);
     return statusMarkup.map(function(s) {
-      return Array(s.string.length + 1).join(s.status.toString()[0]);
+      return new Array(s.string.length + 1).join(s.status.toString()[0]);
     }).join('');
   },
 
   cursor: function(options) {
     return options.display.inputter.element.selectionStart;
   },
 
   current: function(options) {
     return options.display.requisition.getAssignmentAt(helpers._actual.cursor(options)).param.name;
   },
 
   status: function(options) {
-    return options.display.requisition.getStatus().toString();
+    return options.display.requisition.status.toString();
   },
 
   predictions: function(options) {
     var cursor = options.display.inputter.element.selectionStart;
     var assignment = options.display.requisition.getAssignmentAt(cursor);
     return assignment.getPredictions().then(function(predictions) {
       return predictions.map(function(prediction) {
         return prediction.name;
@@ -377,17 +377,17 @@ function outputArray(array) {
 }
 
 helpers._createDebugCheck = function(options) {
   checkOptions(options);
   var requisition = options.display.requisition;
   var command = requisition.commandAssignment.value;
   var cursor = helpers._actual.cursor(options);
   var input = helpers._actual.input(options);
-  var padding = Array(input.length + 1).join(' ');
+  var padding = new Array(input.length + 1).join(' ');
 
   var hintsPromise = helpers._actual.hints(options);
   var predictionsPromise = helpers._actual.predictions(options);
 
   return promise.all(hintsPromise, predictionsPromise).then(function(values) {
     var hints = values[0];
     var predictions = values[1];
     var output = '';
@@ -435,17 +435,17 @@ helpers._createDebugCheck = function(opt
           output += 'value: ' + assignment.value + ', ';
         }
         else {
           output += '/*value:' + assignment.value + ',*/ ';
         }
 
         output += 'arg: \'' + assignment.arg + '\', ';
         output += 'status: \'' + assignment.getStatus().toString() + '\', ';
-        output += 'message: \'' + assignment.getMessage() + '\'';
+        output += 'message: \'' + assignment.message + '\'';
         output += ' },\n';
       });
 
       output += '      }\n';
     }
 
     output += '    },\n';
     output += '    exec: {\n';
@@ -514,44 +514,44 @@ var ACTIONS = {
     return helpers.pressKey(options, 38 /*KeyEvent.DOM_VK_UP*/);
   },
   '<DOWN>': function(options) {
     return helpers.pressKey(options, 40 /*KeyEvent.DOM_VK_DOWN*/);
   }
 };
 
 /**
- * Used in helpers.setInput to cut an input string like "blah<TAB>foo<UP>" into
- * an array like [ "blah", "<TAB>", "foo", "<UP>" ].
+ * Used in helpers.setInput to cut an input string like 'blah<TAB>foo<UP>' into
+ * an array like [ 'blah', '<TAB>', 'foo', '<UP>' ].
  * When using this RegExp, you also need to filter out the blank strings.
  */
 var CHUNKER = /([^<]*)(<[A-Z]+>)/;
 
 /**
  * Alter the input to <code>typed</code> optionally leaving the cursor at
  * <code>cursor</code>.
  * @return A promise of the number of key-presses to respond
  */
 helpers.setInput = function(options, typed, cursor) {
   checkOptions(options);
-  var inputPromise = undefined;
+  var inputPromise;
   var inputter = options.display.inputter;
   // We try to measure average keypress time, but setInput can simulate
   // several, so we try to keep track of how many
   var chunkLen = 1;
 
   // The easy case is a simple string without things like <TAB>
   if (typed.indexOf('<') === -1) {
     inputPromise = inputter.setInput(typed);
   }
   else {
     // Cut the input up into input strings separated by '<KEY>' tokens. The
     // CHUNKS RegExp leaves blanks so we filter them out.
     var chunks = typed.split(CHUNKER).filter(function(s) {
-      return s != '';
+      return s !== '';
     });
     chunkLen = chunks.length + 1;
 
     // We're working on this in chunks so first clear the input
     inputPromise = inputter.setInput('').then(function() {
       return util.promiseEach(chunks, function(chunk) {
         if (chunk.charAt(0) === '<') {
           var action = ACTIONS[chunk];
@@ -756,21 +756,21 @@ helpers._check = function(options, name,
       if ('status' in check) {
         assert.is(assignment.getStatus().toString(),
                   check.status,
                   'arg.' + paramName + '.status' + suffix);
       }
 
       if ('message' in check) {
         if (typeof check.message.test === 'function') {
-          assert.ok(check.message.test(assignment.getMessage()),
+          assert.ok(check.message.test(assignment.message),
                     'arg.' + paramName + '.message' + suffix);
         }
         else {
-          assert.is(assignment.getMessage(),
+          assert.is(assignment.message,
                     check.message,
                     'arg.' + paramName + '.message' + suffix);
         }
       }
     });
   }
 
   return promise.all(outstanding).then(function() {
@@ -782,120 +782,119 @@ helpers._check = function(options, name,
 /**
  * Helper for helpers.audit() to ensure that all the 'exec' properties work.
  * See helpers.audit for more information.
  * @param name The name to use in error messages
  * @param expected See helpers.audit for a list of available exec checks
  * @return A promise which resolves to undefined when the checks are complete
  */
 helpers._exec = function(options, name, expected) {
+  var requisition = options.display.requisition;
   if (expected == null) {
     return promise.resolve({});
   }
 
   var origLogErrors = cli.logErrors;
   if (expected.error) {
     cli.logErrors = false;
   }
 
-  var output;
+  var completed = true;
+
   try {
-    output = options.display.requisition.exec({ hidden: true });
+    return requisition.exec({ hidden: true }).then(function(output) {
+      if ('completed' in expected) {
+        assert.is(completed,
+                  expected.completed,
+                  'output.completed for: ' + name);
+      }
+
+      if ('type' in expected) {
+        assert.is(output.type,
+                  expected.type,
+                  'output.type for: ' + name);
+      }
+
+      if ('error' in expected) {
+        assert.is(output.error,
+                  expected.error,
+                  'output.error for: ' + name);
+      }
+
+      if (!options.window) {
+        assert.ok(false, 'Missing options.window in \'' + name + '\'. ' +
+                         'Are you assming that helpers.audit is synchronous? ' +
+                         'It returns a promise');
+        return { output: output };
+      }
+
+      if (!options.window.document.createElement) {
+        assert.log('skipping output tests (missing doc.createElement) for ' + name);
+        return { output: output };
+      }
+
+      if (!('output' in expected)) {
+        return { output: output };
+      }
+
+      var context = requisition.conversionContext;
+      return output.convert('dom', context).then(function(node) {
+        var actualOutput = node.textContent.trim();
+
+        var doTest = function(match, against) {
+          // Only log the real textContent if the test fails
+          if (against.match(match) != null) {
+            assert.ok(true, 'html output for \'' + name + '\' ' +
+                            'should match /' + match.source || match + '/');
+          } else {
+            assert.ok(false, 'html output for \'' + name + '\' ' +
+                             'should match /' + match.source || match + '/. ' +
+                             'Actual textContent: "' + against + '"');
+          }
+        };
+
+        if (typeof expected.output === 'string') {
+          assert.is(actualOutput,
+                    expected.output,
+                    'html output for ' + name);
+        }
+        else if (Array.isArray(expected.output)) {
+          expected.output.forEach(function(match) {
+            doTest(match, actualOutput);
+          });
+        }
+        else {
+          doTest(expected.output, actualOutput);
+        }
+
+        if (expected.error) {
+          cli.logErrors = origLogErrors;
+        }
+        return { output: output, text: actualOutput };
+      });
+    }.bind(this)).then(function(data) {
+      if (expected.error) {
+        cli.logErrors = origLogErrors;
+      }
+
+      return data;
+    });
   }
   catch (ex) {
     assert.ok(false, 'Failure executing \'' + name + '\': ' + ex);
     util.errorHandler(ex);
 
     if (expected.error) {
       cli.logErrors = origLogErrors;
     }
     return promise.resolve({});
   }
-
-  if ('completed' in expected) {
-    assert.is(output.completed,
-              expected.completed,
-              'output.completed false for: ' + name);
+  finally {
+    completed = false;
   }
-
-  if (!options.window) {
-    assert.ok(false, 'Missing options.window in \'' + name + '\'. ' +
-                     'Are you assming that helpers.audit is synchronous? ' +
-                     'It returns a promise');
-    return { output: output };
-  }
-
-  if (!options.window.document.createElement) {
-    assert.log('skipping output tests (missing doc.createElement) for ' + name);
-
-    if (expected.error) {
-      cli.logErrors = origLogErrors;
-    }
-    return promise.resolve({ output: output });
-  }
-
-  if (!('output' in expected)) {
-    if (expected.error) {
-      cli.logErrors = origLogErrors;
-    }
-    return promise.resolve({ output: output });
-  }
-
-  var checkOutput = function() {
-    if ('type' in expected) {
-      assert.is(output.type,
-                expected.type,
-                'output.type for: ' + name);
-    }
-
-    if ('error' in expected) {
-      assert.is(output.error,
-                expected.error,
-                'output.error for: ' + name);
-    }
-
-    var conversionContext = options.display.requisition.conversionContext;
-    var convertPromise = converters.convert(output.data, output.type, 'dom',
-                                            conversionContext);
-    return convertPromise.then(function(node) {
-      var actualOutput = node.textContent.trim();
-
-      var doTest = function(match, against) {
-        if (match.test(against)) {
-          assert.ok(true, 'html output for ' + name + ' should match /' +
-                          match.source + '/');
-        } else {
-          assert.ok(false, 'html output for ' + name + ' should match /' +
-                           match.source +
-                           '/. Actual textContent: "' + against + '"');
-        }
-      };
-
-      if (typeof expected.output === 'string') {
-        assert.is(actualOutput,
-                  expected.output,
-                  'html output for ' + name);
-      }
-      else if (Array.isArray(expected.output)) {
-        expected.output.forEach(function(match) {
-          doTest(match, actualOutput);
-        });
-      }
-      else {
-        doTest(expected.output, actualOutput);
-      }
-
-      if (expected.error) {
-        cli.logErrors = origLogErrors;
-      }
-      return { output: output, text: actualOutput };
-    });
-  };
-
-  return output.promise.then(checkOutput, checkOutput);
 };
 
 /**
  * Helper to setup the test
  */
 helpers._setup = function(options, name, action) {
   if (typeof action === 'string') {
     return helpers.setInput(options, action);
@@ -919,18 +918,18 @@ helpers._post = function(name, action, d
 };
 
 /*
  * We do some basic response time stats so we can see if we're getting slow
  */
 var totalResponseTime = 0;
 var averageOver = 0;
 var maxResponseTime = 0;
-var maxResponseCulprit = undefined;
-var start = undefined;
+var maxResponseCulprit;
+var start;
 
 /**
  * Restart the stats collection process
  */
 helpers.resetResponseTimes = function() {
   start = new Date().getTime();
   totalResponseTime = 0;
   averageOver = 0;
@@ -995,30 +994,30 @@ Object.defineProperty(helpers, 'timingSu
  *     The name of the test will be used in log messages noting the skip
  *     See helpers.reason for pre-defined skip functions. The skip function must
  *     be synchronous, and will be passed the test options object.
  * - skipRemainingIf: A function to skip all the remaining audits in this set.
  *     See skipIf for details of how skip functions work.
  * - check: Check data. Available checks:
  *   - input: The text displayed in the input field
  *   - cursor: The position of the start of the cursor
- *   - status: One of "VALID", "ERROR", "INCOMPLETE"
+ *   - status: One of 'VALID', 'ERROR', 'INCOMPLETE'
  *   - hints: The hint text, i.e. a concatenation of the directTabText, the
  *       emptyParameters and the arrowTabText. The text as inserted into the UI
  *       will include NBSP and Unicode RARR characters, these should be
  *       represented using normal space and '->' for the arrow
- *   - markup: What state should the error markup be in. e.g. "VVVIIIEEE"
+ *   - markup: What state should the error markup be in. e.g. 'VVVIIIEEE'
  *   - args: Maps of checks to make against the arguments:
  *     - value: i.e. assignment.value (which ignores defaultValue)
  *     - type: Argument/BlankArgument/MergedArgument/etc i.e. what's assigned
  *             Care should be taken with this since it's something of an
  *             implementation detail
  *     - arg: The toString value of the argument
  *     - status: i.e. assignment.getStatus
- *     - message: i.e. assignment.getMessage
+ *     - message: i.e. assignment.message
  *     - name: For commands - checks assignment.value.name
  * - exec: Object to indicate we should execute the command and check the
  *     results. Available checks:
  *   - output: A string, RegExp or array of RegExps to compare with the output
  *       If typeof output is a string then the output should be exactly equal
  *       to the given string. If the type of output is a RegExp or array of
  *       RegExps then the output should match all RegExps
  *   - completed: A boolean which declares that we should check to see if the
diff --git a/browser/devtools/commandline/test/mockCommands.js b/browser/devtools/commandline/test/mockCommands.js
--- a/browser/devtools/commandline/test/mockCommands.js
+++ b/browser/devtools/commandline/test/mockCommands.js
@@ -22,23 +22,24 @@
 // DO NOT EDIT IT DIRECTLY
 
 const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 let { require: require, define: define } = Cu.import("resource://gre/modules/devtools/Require.jsm", {});
 Cu.import("resource://gre/modules/devtools/gcli.jsm", {});
 
 // <INJECTED SOURCE:END>
 
+
+'use strict';
+
 var mockCommands = {};
 
 // We use an alias for exports here because this module is used in Firefox
 // mochitests where we don't have define/require
 
-'use strict';
-
 var util = require('util/util');
 var canon = require('gcli/canon');
 var types = require('gcli/types');
 
 mockCommands.option1 = { };
 mockCommands.option2 = { };
 mockCommands.option3 = { };
 
@@ -142,37 +143,63 @@ var tsb = {
 
 var tss = {
   name: 'tss',
   exec: createExec('tss')
 };
 
 var tsu = {
   name: 'tsu',
-  params: [ { name: 'num', type: { name: 'number', max: 10, min: -5, step: 3 } } ],
+  params: [
+    {
+      name: 'num',
+      type: {
+        name: 'number',
+        max: 10,
+        min: -5,
+        step: 3
+      }
+    }
+  ],
   exec: createExec('tsu')
 };
 
 var tsf = {
   name: 'tsf',
-  params: [ { name: 'num', type: { name: 'number', allowFloat: true, max: 11.5, min: -6.5, step: 1.5 } } ],
+  params: [
+    {
+      name: 'num',
+      type: {
+        name: 'number',
+        allowFloat: true,
+        max: 11.5,
+        min: -6.5,
+        step: 1.5
+      }
+    }
+  ],
   exec: createExec('tsf')
 };
 
 var tsn = {
   name: 'tsn'
 };
 
 var tsnDif = {
   name: 'tsn dif',
-  description: 'tsn dif',
   params: [ { name: 'text', type: 'string', description: 'tsn dif text' } ],
   exec: createExec('tsnDif')
 };
 
+var tsnHidden = {
+  name: 'tsn hidden',
+  hidden: true,
+  exec: createExec('tsnHidden')
+};
+
 var tsnExt = {
   name: 'tsn ext',
   params: [ { name: 'text', type: 'string' } ],
   exec: createExec('tsnExt')
 };
 
 var tsnExte = {
   name: 'tsn exte',
@@ -214,28 +241,31 @@ var tshidden = {
   hidden: true,
   params: [
     {
       group: 'Options',
       params: [
         {
           name: 'visible',
           type: 'string',
+          short: 'v',
           defaultValue: null,
           description: 'visible'
         },
         {
           name: 'invisiblestring',
           type: 'string',
+          short: 'i',
           description: 'invisiblestring',
           defaultValue: null,
           hidden: true
         },
         {
           name: 'invisibleboolean',
+          short: 'b',
           type: 'boolean',
           description: 'invisibleboolean',
           hidden: true
         }
       ]
     }
   ],
   exec: createExec('tshidden')
@@ -349,60 +379,66 @@ var tslong = {
   description: 'long param tests to catch problems with the jsb command',
   params: [
     {
       name: 'msg',
       type: 'string',
       description: 'msg Desc'
     },
     {
-      group: "Options Desc",
+      group: 'Options Desc',
       params: [
         {
           name: 'num',
+          short: 'n',
           type: 'number',
           description: 'num Desc',
           defaultValue: 2
         },
         {
           name: 'sel',
+          short: 's',
           type: {
             name: 'selection',
             lookup: [
-              { name: "space", value: " " },
-              { name: "tab", value: "\t" }
+              { name: 'space', value: ' ' },
+              { name: 'tab', value: '\t' }
             ]
           },
           description: 'sel Desc',
           defaultValue: ' '
         },
         {
           name: 'bool',
+          short: 'b',
           type: 'boolean',
           description: 'bool Desc'
         },
         {
           name: 'num2',
+          short: 'm',
           type: 'number',
           description: 'num2 Desc',
           defaultValue: -1
         },
         {
           name: 'bool2',
+          short: 'c',
           type: 'boolean',
           description: 'bool2 Desc'
         },
         {
           name: 'sel2',
+          short: 't',
           type: {
             name: 'selection',
             data: [ 'collapse', 'basic', 'with space', 'with two spaces' ]
           },
           description: 'sel2 Desc',
-          defaultValue: "collapse"
+          defaultValue: 'collapse'
         }
       ]
     }
   ],
   exec: createExec('tslong')
 };
 
 var tsdate = {
@@ -438,34 +474,35 @@ var tsfail = {
           'reject', 'rejecttyped',
           'throwerror', 'throwstring', 'throwinpromise',
           'noerror'
         ]
       }
     }
   ],
   exec: function(args, context) {
+    var deferred;
     if (args.method === 'reject') {
-      var deferred = context.defer();
+      deferred = context.defer();
       setTimeout(function() {
         deferred.reject('rejected promise');
       }, 10);
       return deferred.promise;
     }
 
     if (args.method === 'rejecttyped') {
-      var deferred = context.defer();
+      deferred = context.defer();
       setTimeout(function() {
         deferred.reject(context.typedData('number', 54));
       }, 10);
       return deferred.promise;
     }
 
     if (args.method === 'throwinpromise') {
-      var deferred = context.defer();
+      deferred = context.defer();
       setTimeout(function() {
         deferred.resolve('should be lost');
       }, 10);
       return deferred.promise.then(function() {
         var t = null;
         return t.foo;
       });
     }
@@ -622,16 +659,17 @@ mockCommands.setup = function(opts) {
   mockCommands.commands.tse = canon.addCommand(tse);
   mockCommands.commands.tsj = canon.addCommand(tsj);
   mockCommands.commands.tsb = canon.addCommand(tsb);
   mockCommands.commands.tss = canon.addCommand(tss);
   mockCommands.commands.tsu = canon.addCommand(tsu);
   mockCommands.commands.tsf = canon.addCommand(tsf);
   mockCommands.commands.tsn = canon.addCommand(tsn);
   mockCommands.commands.tsnDif = canon.addCommand(tsnDif);
+  mockCommands.commands.tsnHidden = canon.addCommand(tsnHidden);
   mockCommands.commands.tsnExt = canon.addCommand(tsnExt);
   mockCommands.commands.tsnExte = canon.addCommand(tsnExte);
   mockCommands.commands.tsnExten = canon.addCommand(tsnExten);
   mockCommands.commands.tsnExtend = canon.addCommand(tsnExtend);
   mockCommands.commands.tsnDeep = canon.addCommand(tsnDeep);
   mockCommands.commands.tsnDeepDown = canon.addCommand(tsnDeepDown);
   mockCommands.commands.tsnDeepDownNested = canon.addCommand(tsnDeepDownNested);
   mockCommands.commands.tsnDeepDownNestedCmd = canon.addCommand(tsnDeepDownNestedCmd);
@@ -660,16 +698,17 @@ mockCommands.shutdown = function(opts) {
   canon.removeCommand(tse);
   canon.removeCommand(tsj);
   canon.removeCommand(tsb);
   canon.removeCommand(tss);
   canon.removeCommand(tsu);
   canon.removeCommand(tsf);
   canon.removeCommand(tsn);
   canon.removeCommand(tsnDif);
+  canon.removeCommand(tsnHidden);
   canon.removeCommand(tsnExt);
   canon.removeCommand(tsnExte);
   canon.removeCommand(tsnExten);
   canon.removeCommand(tsnExtend);
   canon.removeCommand(tsnDeep);
   canon.removeCommand(tsnDeepDown);
   canon.removeCommand(tsnDeepDownNested);
   canon.removeCommand(tsnDeepDownNestedCmd);
diff --git a/browser/devtools/debugger/test/browser_dbg_cmd_break.js b/browser/devtools/debugger/test/browser_dbg_cmd_break.js
--- a/browser/devtools/debugger/test/browser_dbg_cmd_break.js
+++ b/browser/devtools/debugger/test/browser_dbg_cmd_break.js
@@ -11,26 +11,26 @@ function test() {
     // To help us run later commands, and clear up after ourselves
     let client, line0;
 
     return helpers.audit(options, [
       {
         setup: 'break',
         check: {
           input:  'break',
-          hints:       '',
+          hints:       ' add line',
           markup: 'IIIII',
           status: 'ERROR',
         },
       },
       {
         setup: 'break add',
         check: {
           input:  'break add',
-          hints:           '',
+          hints:           ' line',
           markup: 'IIIIIVIII',
           status: 'ERROR'
         },
       },
       {
         setup: 'break add line',
         check: {
           input:  'break add line',
diff --git a/browser/locales/en-US/chrome/browser/devtools/gcli.properties b/browser/locales/en-US/chrome/browser/devtools/gcli.properties
--- a/browser/locales/en-US/chrome/browser/devtools/gcli.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/gcli.properties
@@ -44,16 +44,20 @@ cliEvalJavascript=Enter JavaScript direc
 # LOCALIZATION NOTE: This message is displayed when the command line has more
 # arguments than the current command can understand.
 cliUnusedArg=Too many arguments
 
 # LOCALIZATION NOTE: The title of the dialog which displays the options that
 # are available to the current command.
 cliOptions=Available Options
 
+# LOCALIZATION NOTE: The error message when the user types a command that
+# isn't registered
+cliUnknownCommand=Invalid Command
+
 # LOCALIZATION NOTE: Error message given when a file argument points to a file
 # that does not exist, but should (e.g. for use with File->Open) %1$S is a
 # filename
 fileErrNotExists='%1$S' doesn't exist
 
 # LOCALIZATION NOTE: Error message given when a file argument points to a file
 # that exists, but should not (e.g. for use with File->Save As) %1$S is a
 # filename
@@ -142,21 +146,20 @@ nodeParseNone=No matches
 # LOCALIZATION NOTE (helpDesc, helpManual, helpSearchDesc, helpSearchManual3):
 # These strings describe the "help" command, used to display a description of
 # a command (e.g. "help pref"), and its parameter 'search'.
 helpDesc=Get help on the available commands
 helpManual=Provide help either on a specific command (if a search string is provided and an exact match is found) or on the available commands (if a search string is not provided, or if no exact match is found).
 helpSearchDesc=Search string
 helpSearchManual3=search string to use in narrowing down the displayed commands. Regular expressions not supported.
 
-# LOCALIZATION NOTE (helpManSynopsis, helpManDescription, helpManParameters):
-# These strings are displayed in the help page for a command in the console.
+# LOCALIZATION NOTE (helpManSynopsis, helpManDescription): These strings are
+# displayed in the help page for a command in the console.
 helpManSynopsis=Synopsis
 helpManDescription=Description
-helpManParameters=Parameters
 
 # LOCALIZATION NOTE: This message is displayed in the help page if the command
 # has no parameters.
 helpManNone=None
 
 # LOCALIZATION NOTE: This message is displayed in response to the 'help'
 # command when used without a filter, just above the list of known commands.
 helpListAll=Available Commands:
diff --git a/toolkit/devtools/gcli/gcli.jsm b/toolkit/devtools/gcli/gcli.jsm
--- a/toolkit/devtools/gcli/gcli.jsm
+++ b/toolkit/devtools/gcli/gcli.jsm
@@ -121,17 +121,17 @@ var prefBranch = prefSvc.getBranch(null)
                         .QueryInterface(Components.interfaces.nsIPrefBranch2);
 
 exports.hiddenByChromePref = function() {
   return !prefBranch.prefHasUserValue('devtools.chrome.enabled');
 };
 
 
 try {
-  var Services = Components.utils.import("resource://gre/modules/Services.jsm", {}).Services;
+  var Services = Components.utils.import('resource://gre/modules/Services.jsm', {}).Services;
   var stringBundle = Services.strings.createBundle(
           'chrome://browser/locale/devtools/gclicommands.properties');
 
   /**
    * Lookup a string in the GCLI string bundle
    */
   exports.lookup = function(name) {
     try {
@@ -184,27 +184,28 @@ catch (ex) {
  */
 
 define('gcli/settings', ['require', 'exports', 'module' , 'util/util', 'gcli/types'], function(require, exports, module) {
 
 'use strict';
 
 var imports = {};
 
-Components.utils.import('resource://gre/modules/XPCOMUtils.jsm', imports);
-
-imports.XPCOMUtils.defineLazyGetter(imports, 'prefBranch', function() {
+var XPCOMUtils = Components.utils.import('resource://gre/modules/XPCOMUtils.jsm', {}).XPCOMUtils;
+var Services = Components.utils.import('resource://gre/modules/Services.jsm', {}).Services;
+
+XPCOMUtils.defineLazyGetter(imports, 'prefBranch', function() {
   var prefService = Components.classes['@mozilla.org/preferences-service;1']
           .getService(Components.interfaces.nsIPrefService);
   return prefService.getBranch(null)
           .QueryInterface(Components.interfaces.nsIPrefBranch2);
 });
 
-imports.XPCOMUtils.defineLazyGetter(imports, 'supportsString', function() {
-  return Components.classes["@mozilla.org/supports-string;1"]
+XPCOMUtils.defineLazyGetter(imports, 'supportsString', function() {
+  return Components.classes['@mozilla.org/supports-string;1']
           .createInstance(Components.interfaces.nsISupportsString);
 });
 
 
 var util = require('util/util');
 var types = require('gcli/types');
 
 /**
@@ -443,17 +444,17 @@ exports.getSetting = function(name) {
     return found;
   }
 
   if (hasReadSystem) {
     return undefined;
   }
   else {
     readSystem();
-    var found = settingsMap.get(name);
+    found = settingsMap.get(name);
     if (!found) {
       found = settingsMap.get(DEVTOOLS_PREFIX + name);
     }
     return found;
   }
 };
 
 /**
@@ -542,26 +543,26 @@ function nameFunction(handler) {
  *   hat.putOn.add(function(ev) {
  *     console.log('The hat ', ev.hat, ' has is worn by ', ev.person);
  *   }, scope);
  *
  * @param name Optional name to help with debugging
  */
 exports.createEvent = function(name) {
   var handlers = [];
-  var holdFire = false;
+  var fireHoldCount = 0;
   var heldEvents = [];
-  var eventCombiner = undefined;
+  var eventCombiner;
 
   /**
    * This is how the event is triggered.
    * @param ev The event object to be passed to the event listeners
    */
   var event = function(ev) {
-    if (holdFire) {
+    if (fireHoldCount > 0) {
       heldEvents.push(ev);
       if (eventDebug) {
         console.log('Held fire: ' + name, ev);
       }
       return;
     }
 
     if (eventDebug) {
@@ -632,36 +633,36 @@ exports.createEvent = function(name) {
    * Temporarily prevent this event from firing.
    * @see resumeFire(ev)
    */
   event.holdFire = function() {
     if (eventDebug) {
       console.group('Holding fire: ' + name);
     }
 
-    holdFire = true;
+    fireHoldCount++;
   };
 
   /**
    * Resume firing events.
    * If there are heldEvents, then we fire one event to cover them all. If an
    * event combining function has been provided then we use that to combine the
    * events. Otherwise the last held event is used.
    * @see holdFire()
    */
   event.resumeFire = function() {
     if (eventDebug) {
       console.groupEnd('Resume fire: ' + name);
     }
 
-    if (holdFire !== true) {
-      throw new Error('Event not held: ' + name);
-    }
-
-    holdFire = false;
+    if (fireHoldCount === 0) {
+      throw new Error('fireHoldCount === 0 during resumeFire on ' + name);
+    }
+
+    fireHoldCount--;
     if (heldEvents.length === 0) {
       return;
     }
 
     if (heldEvents.length === 1) {
       event(heldEvents[0]);
     }
     else {
@@ -710,18 +711,18 @@ var promise = require('util/promise');
  * Utility to convert a resolved promise to a concrete value.
  * Warning: This is something of an experiment. The alternative of mixing
  * concrete/promise return values could be better.
  */
 exports.synchronize = function(p) {
   if (p == null || typeof p.then !== 'function') {
     return p;
   }
-  var failure = undefined;
-  var reply = undefined;
+  var failure;
+  var reply;
   var onDone = function(value) {
     failure = false;
     reply = value;
   };
   var onError = function (value) {
     failure = true;
     reply = value;
   };
@@ -913,26 +914,26 @@ exports.importCss = function(cssText, do
 
 /**
  * Simple hash function which happens to match Java's |String.hashCode()|
  * Done like this because I we don't need crypto-security, but do need speed,
  * and I don't want to spend a long time working on it.
  * @see http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
  */
 function hash(str) {
-  var hash = 0;
-  if (str.length == 0) {
-    return hash;
+  var h = 0;
+  if (str.length === 0) {
+    return h;
   }
   for (var i = 0; i < str.length; i++) {
     var character = str.charCodeAt(i);
-    hash = ((hash << 5) - hash) + character;
-    hash = hash & hash; // Convert to 32bit integer
-  }
-  return hash;
+    h = ((h << 5) - h) + character;
+    h = h & h; // Convert to 32bit integer
+  }
+  return h;
 }
 
 /**
  * Shortcut for clearElement/createTextNode/appendChild to make up for the lack
  * of standards around textContent/innerText
  */
 exports.setTextContent = function(elem, text) {
   exports.clearElement(elem);
@@ -1027,16 +1028,26 @@ function positionInNodeList(element, nod
     if (element === nodeList[i]) {
       return i;
     }
   }
   return -1;
 }
 
 /**
+ * We'd really like to be able to do 'new NodeList()'
+ */
+exports.createEmptyNodeList = function(doc) {
+  if (doc.createDocumentFragment) {
+    return doc.createDocumentFragment().childNodes;
+  }
+  return doc.querySelectorAll('x>:root');
+};
+
+/**
  * Find a unique CSS selector for a given element
  * @returns a string such that ele.ownerDocument.querySelector(reply) === ele
  * and ele.ownerDocument.querySelectorAll(reply).length === 1
  */
 exports.findCssSelector = function(ele) {
   var document = ele.ownerDocument;
   if (ele.id && document.getElementById(ele.id) === ele) {
     return '#' + ele.id;
@@ -1281,17 +1292,17 @@ else {
  * limitations under the License.
  */
 
 define('util/promise', ['require', 'exports', 'module' ], function(require, exports, module) {
 
 'use strict';
 
 var imported = {};
-Components.utils.import("resource://gre/modules/commonjs/sdk/core/promise.js",
+Components.utils.import('resource://gre/modules/commonjs/sdk/core/promise.js',
                         imported);
 
 exports.defer = imported.Promise.defer;
 exports.resolve = imported.Promise.resolve;
 exports.reject = imported.Promise.reject;
 exports.promised = imported.Promise.promised;
 exports.all = imported.Promise.all;
 
@@ -1489,17 +1500,17 @@ Conversion.prototype.equals = function(t
 };
 
 /**
  * Check that the value in this conversion is strict equal to the value in the
  * provided conversion.
  * @param that The conversion to compare values with
  */
 Conversion.prototype.valueEquals = function(that) {
-  return this.value === that.value;
+  return that != null && this.value === that.value;
 };
 
 /**
  * Check that the argument in this conversion is equal to the value in the
  * provided conversion as defined by the argument (i.e. arg.equals).
  * @param that The conversion to compare arguments with
  */
 Conversion.prototype.argEquals = function(that) {
@@ -1619,16 +1630,20 @@ ArrayConversion.prototype.getStatus = fu
   return this._status;
 };
 
 ArrayConversion.prototype.isDataProvided = function() {
   return this.conversions.length > 0;
 };
 
 ArrayConversion.prototype.valueEquals = function(that) {
+  if (that == null) {
+    return false;
+  }
+
   if (!(that instanceof ArrayConversion)) {
     throw new Error('Can\'t compare values with non ArrayConversion');
   }
 
   if (this.value === that.value) {
     return true;
   }
 
@@ -1974,17 +1989,17 @@ Argument.prototype.beget = function(opti
   var prefix = this.prefix;
   var suffix = this.suffix;
 
   if (options.text != null) {
     text = options.text;
 
     // We need to add quotes when the replacement string has spaces or is empty
     if (!options.dontQuote) {
-      var needsQuote = text.indexOf(' ') >= 0 || text.length == 0;
+      var needsQuote = text.indexOf(' ') >= 0 || text.length === 0;
       var hasQuote = /['"]$/.test(prefix);
       if (needsQuote && !hasQuote) {
         prefix = prefix + '\'';
         suffix = '\'' + suffix;
       }
     }
   }
 
@@ -2467,17 +2482,17 @@ ArrayArgument.prototype.getArgs = functi
 ArrayArgument.prototype.equals = function(that) {
   if (this === that) {
     return true;
   }
   if (that == null) {
     return false;
   }
 
-  if (!(that.type === 'ArrayArgument')) {
+  if (that.type !== 'ArrayArgument') {
     return false;
   }
 
   if (this.args.length !== that.args.length) {
     return false;
   }
 
   for (var i = 0; i < this.args.length; i++) {
@@ -2703,32 +2718,43 @@ function Command(commandSpec) {
   this.description = lookup(this.description, 'canonDescNone');
   this.manual = 'manual' in this ? this.manual : undefined;
   this.manual = lookup(this.manual);
 
   // At this point this.params has nested param groups. We want to flatten it
   // out and replace the param object literals with Parameter objects
   var paramSpecs = this.params;
   this.params = [];
+  this.paramGroups = {};
+  this._shortParams = {};
+
+  var addParam = function(param) {
+    var groupName = param.groupName || Parameter.DEFAULT_GROUP_NAME;
+    this.params.push(param);
+    if (!this.paramGroups.hasOwnProperty(groupName)) {
+      this.paramGroups[groupName] = [];
+    }
+    this.paramGroups[groupName].push(param);
+  }.bind(this);
 
   // Track if the user is trying to mix default params and param groups.
   // All the non-grouped parameters must come before all the param groups
   // because non-grouped parameters can be assigned positionally, so their
   // index is important. We don't want 'holes' in the order caused by
   // parameter groups.
   var usingGroups = false;
 
   // In theory this could easily be made recursive, so param groups could
   // contain nested param groups. Current thinking is that the added
   // complexity for the UI probably isn't worth it, so this implementation
   // prevents nesting.
   paramSpecs.forEach(function(spec) {
     if (!spec.group) {
       var param = new Parameter(spec, this, null);
-      this.params.push(param);
+      addParam(param);
 
       if (!param.isPositionalAllowed) {
         this.hasNamedParameters = true;
       }
 
       if (usingGroups && param.groupName == null) {
         throw new Error('Parameters can\'t come after param groups.' +
                         ' Ignoring ' + this.name + '/' + spec.name);
@@ -2736,26 +2762,35 @@ function Command(commandSpec) {
 
       if (param.groupName != null) {
         usingGroups = true;
       }
     }
     else {
       spec.params.forEach(function(ispec) {
         var param = new Parameter(ispec, this, spec.group);
-        this.params.push(param);
+        addParam(param);
 
         if (!param.isPositionalAllowed) {
           this.hasNamedParameters = true;
         }
       }, this);
 
       usingGroups = true;
     }
   }, this);
+
+  this.params.forEach(function(param) {
+    if (param.short != null) {
+      if (this._shortParams[param.short] != null) {
+        throw new Error('Multiple params using short name ' + param.short);
+      }
+      this._shortParams[param.short] = param;
+    }
+  }, this);
 }
 
 /**
  * JSON serializer that avoids non-serializable data
  */
 Object.defineProperty(Command.prototype, 'json', {
   get: function() {
     return {
@@ -2765,39 +2800,51 @@ Object.defineProperty(Command.prototype,
       params: this.params.map(function(param) { return param.json; }),
       returnType: this.returnType,
       isParent: (this.exec == null)
     };
   },
   enumerable: true
 });
 
+/**
+ * Easy way to lookup parameters by short name
+ */
+Command.prototype.getParameterByShortName = function(short) {
+  return this._shortParams[short];
+};
+
 exports.Command = Command;
 
 
 /**
  * A wrapper for a paramSpec so we can sort out shortened versions names for
  * option switches
  */
 function Parameter(paramSpec, command, groupName) {
   this.command = command || { name: 'unnamed' };
   this.paramSpec = paramSpec;
   this.name = this.paramSpec.name;
   this.type = this.paramSpec.type;
+  this.short = this.paramSpec.short;
+
+  if (this.short != null && !/[0-9A-Za-z]/.test(this.short)) {
+    throw new Error('\'short\' value must be a single alphanumeric digit.');
+  }
 
   this.groupName = groupName;
   if (this.groupName != null) {
     if (this.paramSpec.option != null) {
       throw new Error('Can\'t have a "option" property in a nested parameter');
     }
   }
   else {
     if (this.paramSpec.option != null) {
       this.groupName = this.paramSpec.option === true ?
-              l10n.lookup('canonDefaultGroupName') :
+              Parameter.DEFAULT_GROUP_NAME :
               '' + this.paramSpec.option;
     }
   }
 
   if (!this.name) {
     throw new Error('In ' + this.command.name +
                     ': all params must have a name');
   }
@@ -2841,23 +2888,28 @@ function Parameter(paramSpec, command, g
     catch (ex) {
       throw new Error('In ' + this.command.name + '/' + this.name + ': ' + ex);
     }
   }
 
   // All parameters that can only be set via a named parameter must have a
   // non-undefined default value
   if (!this.isPositionalAllowed && this.paramSpec.defaultValue === undefined &&
-      this.type.getBlank == null && !(this.type.name === 'boolean')) {
+      this.type.getBlank == null && this.type.name !== 'boolean') {
     throw new Error('In ' + this.command.name + '/' + this.name +
                     ': Missing defaultValue for optional parameter.');
   }
 }
 
 /**
+ * The default group name, when none is given explicitly
+ */
+Parameter.DEFAULT_GROUP_NAME = l10n.lookup('canonDefaultGroupName');
+
+/**
  * type.getBlank can be expensive, so we delay execution where we can
  */
 Object.defineProperty(Parameter.prototype, 'defaultValue', {
   get: function() {
     if (!('_defaultValue' in this)) {
       this._defaultValue = (this.paramSpec.defaultValue !== undefined) ?
           this.paramSpec.defaultValue :
           this.type.getBlank().value;
@@ -2869,20 +2921,17 @@ Object.defineProperty(Parameter.prototyp
 });
 
 /**
  * Does the given name uniquely identify this param (among the other params
  * in this command)
  * @param name The name to check
  */
 Parameter.prototype.isKnownAs = function(name) {
-  if (name === '--' + this.name) {
-    return true;
-  }
-  return false;
+  return (name === '--' + this.name) || (name === '-' + this.short);
 };
 
 /**
  * Resolve the manual for this parameter, by looking in the paramSpec
  * and doing a l10n lookup
  */
 Object.defineProperty(Parameter.prototype, 'manual', {
   get: function() {
@@ -2945,16 +2994,19 @@ Object.defineProperty(Parameter.prototyp
       description: this.description
     };
     if (this.defaultValue !== undefined && json.type !== 'boolean') {
       json.defaultValue = this.defaultValue;
     }
     if (this.option !== undefined) {
       json.option = this.option;
     }
+    if (this.short !== undefined) {
+      json.short = this.short;
+    }
     return json;
   },
   enumerable: true
 });
 
 exports.Parameter = Parameter;
 
 
@@ -3195,18 +3247,18 @@ exports.CommandOutputManager = CommandOu
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 define('util/l10n', ['require', 'exports', 'module' ], function(require, exports, module) {
 
 'use strict';
 
-Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
-Components.utils.import('resource://gre/modules/Services.jsm');
+var XPCOMUtils = Components.utils.import('resource://gre/modules/XPCOMUtils.jsm', {}).XPCOMUtils;
+var Services = Components.utils.import('resource://gre/modules/Services.jsm', {}).Services;
 
 var imports = {};
 XPCOMUtils.defineLazyGetter(imports, 'stringBundle', function () {
   return Services.strings.createBundle('chrome://browser/locale/devtools/gcli.properties');
 });
 
 /*
  * Not supported when embedded - we're doing things the Mozilla way not the
@@ -3404,23 +3456,23 @@ function getConverter(from, to) {
 
   var converter = fromMatch[to];
   if (converter == null) {
     // Someone is going to love writing a graph search algorithm to work out
     // the smallest number of conversions, or perhaps the least 'lossy'
     // conversion but for now the only 2 step conversion is foo->view->dom,
     // which we are going to special case.
     if (to === 'dom') {
-      converter = fromMatch['view'];
+      converter = fromMatch.view;
       if (converter != null) {
         return getChainConverter(converter, viewDomConverter);
       }
     }
     if (to === 'string') {
-      converter = fromMatch['view'];
+      converter = fromMatch.view;
       if (converter != null) {
         return getChainConverter(converter, viewStringConverter);
       }
     }
     return getFallbackConverter(from, to);
   }
   return converter;
 }
@@ -3475,23 +3527,24 @@ exports.items = [ viewDomConverter, view
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-define('gcli/ui/fields', ['require', 'exports', 'module' , 'util/promise', 'util/util'], function(require, exports, module) {
+define('gcli/ui/fields', ['require', 'exports', 'module' , 'util/promise', 'util/util', 'gcli/argument'], function(require, exports, module) {
 
 'use strict';
 
 var promise = require('util/promise');
 var util = require('util/util');
 var KeyEvent = require('util/util').KeyEvent;
+var Argument = require('gcli/argument').Argument;
 
 /**
  * A Field is a way to get input for a single parameter.
  * This class is designed to be inherited from. It's important that all
  * subclasses have a similar constructor signature because they are created
  * via getField(...)
  * @param type The type to use in conversions
  * @param options A set of properties to help fields configure themselves:
@@ -3632,23 +3685,22 @@ exports.addField = function(fieldCtor) {
 
 /**
  * Remove a Field definition
  * @param field A previously registered field, specified either with a field
  * name or from the field name
  */
 exports.removeField = function(field) {
   if (typeof field !== 'string') {
-    fields = fields.filter(function(test) {
+    fieldCtors = fieldCtors.filter(function(test) {
       return test !== field;
     });
-    delete fields[field];
   }
   else if (field instanceof Field) {
-    removeField(field.name);
+    exports.removeField(field.name);
   }
   else {
     console.error('removeField erroring on ', field);
     throw new Error('removeField requires an instance of Field');
   }
 };
 
 /**
@@ -3884,18 +3936,18 @@ function resolve(thing, context, neverFo
  */
 function dataToLookup(data) {
   if (!Array.isArray(data)) {
     throw new Error('SelectionType has no lookup or data');
   }
 
   return data.map(function(option) {
     return { name: option, value: option };
-  }, this);
-};
+  });
+}
 
 /**
  * Return a list of possible completions for the given arg.
  * @param arg The initial input to match
  * @return A trimmed array of string:value pairs
  */
 SelectionType.prototype._findPredictions = function(arg, context) {
   return promise.resolve(this.getLookup(context)).then(function(lookup) {
@@ -3905,17 +3957,17 @@ SelectionType.prototype._findPredictions
     var match = arg.text.toLowerCase();
 
     // If the arg has a suffix then we're kind of 'done'. Only an exact match
     // will do.
     if (arg.suffix.length > 0) {
       for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
         option = lookup[i];
         if (option.name === arg.text) {
-          this._addToPredictions(predictions, option, arg);
+          predictions.push(option);
         }
       }
 
       return predictions;
     }
 
     // Cache lower case versions of all the option names
     for (i = 0; i < lookup.length; i++) {
@@ -3925,37 +3977,37 @@ SelectionType.prototype._findPredictions
       }
     }
 
     // Exact hidden matches. If 'hidden: true' then we only allow exact matches
     // All the tests after here check that !option.value.hidden
     for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
       option = lookup[i];
       if (option.name === arg.text) {
-        this._addToPredictions(predictions, option, arg);
+        predictions.push(option);
       }
     }
 
     // Start with prefix matching
     for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
       option = lookup[i];
       if (option._gcliLowerName.indexOf(match) === 0 && !option.value.hidden) {
         if (predictions.indexOf(option) === -1) {
-          this._addToPredictions(predictions, option, arg);
+          predictions.push(option);
         }
       }
     }
 
     // Try infix matching if we get less half max matched
     if (predictions.length < (maxPredictions / 2)) {
       for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
         option = lookup[i];
         if (option._gcliLowerName.indexOf(match) !== -1 && !option.value.hidden) {
           if (predictions.indexOf(option) === -1) {
-            this._addToPredictions(predictions, option, arg);
+            predictions.push(option);
           }
         }
       }
     }
 
     // Try fuzzy matching if we don't get a prefix match
     if (predictions.length === 0) {
       var names = [];
@@ -3973,26 +4025,16 @@ SelectionType.prototype._findPredictions
         }, this);
       }
     }
 
     return predictions;
   }.bind(this));
 };
 
-/**
- * Add an option to our list of predicted options.
- * We abstract out this portion of _findPredictions() because CommandType needs
- * to make an extra check before actually adding which SelectionType does not
- * need to make.
- */
-SelectionType.prototype._addToPredictions = function(predictions, option, arg) {
-  predictions.push(option);
-};
-
 SelectionType.prototype.parse = function(arg, context) {
   return this._findPredictions(arg, context).then(function(predictions) {
     if (predictions.length === 0) {
       var msg = l10n.lookupFormat('typesSelectionNomatch', [ arg.text ]);
       return new Conversion(undefined, arg, Status.ERROR, msg,
                             promise.resolve(predictions));
     }
 
@@ -4552,22 +4594,23 @@ exports.items = [
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-define('gcli/types/command', ['require', 'exports', 'module' , 'util/promise', 'util/l10n', 'gcli/canon', 'gcli/types/selection', 'gcli/types'], function(require, exports, module) {
+define('gcli/types/command', ['require', 'exports', 'module' , 'util/promise', 'util/l10n', 'util/spell', 'gcli/canon', 'gcli/types/selection', 'gcli/types'], function(require, exports, module) {
 
 'use strict';
 
 var promise = require('util/promise');
 var l10n = require('util/l10n');
+var spell = require('util/spell');
 var canon = require('gcli/canon');
 var SelectionType = require('gcli/types/selection').SelectionType;
 var Status = require('gcli/types').Status;
 var Conversion = require('gcli/types').Conversion;
 
 exports.items = [
   {
     // Select from the available parameters to a command
@@ -4580,17 +4623,17 @@ exports.items = [
     isIncompleteName: undefined,
 
     lookup: function() {
       var displayedParams = [];
       var command = this.requisition.commandAssignment.value;
       if (command != null) {
         command.params.forEach(function(param) {
           var arg = this.requisition.getAssignment(param.name).arg;
-          if (!param.isPositionalAllowed && arg.type === "BlankArgument") {
+          if (!param.isPositionalAllowed && arg.type === 'BlankArgument') {
             displayedParams.push({ name: '--' + param.name, value: param });
           }
         }, this);
       }
       return displayedParams;
     },
 
     parse: function(arg, context) {
@@ -4609,70 +4652,186 @@ exports.items = [
     // SelectionType to make it handle Commands correctly was to high, so we
     // simplified.
     // If you are making changes to this code, you should check there too.
     item: 'type',
     name: 'command',
     parent: 'selection',
     stringifyProperty: 'name',
     neverForceAsync: true,
+    allowNonExec: true,
 
     lookup: function() {
       var commands = canon.getCommands();
       commands.sort(function(c1, c2) {
         return c1.name.localeCompare(c2.name);
       });
       return commands.map(function(command) {
         return { name: command.name, value: command };
       }, this);
     },
 
-    // Add an option to our list of predicted options
-    _addToPredictions: function(predictions, option, arg) {
-      // The command type needs to exclude sub-commands when the CLI
-      // is blank, but include them when we're filtering. This hack
-      // excludes matches when the filter text is '' and when the
-      // name includes a space.
-      if (arg.text.length !== 0 || option.name.indexOf(' ') === -1) {
-        predictions.push(option);
-      }
-    },
-
     parse: function(arg, context) {
-      // Especially at startup, predictions live over the time that things change
-      // so we provide a completion function rather than completion values
+      // Helper function - Commands like 'context' work best with parent
+      // commands which are not executable. However obviously to execute a
+      // command, it needs an exec function.
+      var execWhereNeeded = function(command) {
+        return this.allowNonExec || typeof command.exec === 'function';
+      }.bind(this);
+
+      var command = canon.getCommand(arg.text);
+
+      // Predictions live over the time that things change so we provide a
+      // completion function rather than completion values
       var predictFunc = function() {
-        return this._findPredictions(arg);
+        return this._findPredictions(arg).then(function(predictions) {
+          // If it's an exact match of an executable command (rather than just
+          // the only possibility) then we don't want alternatives
+          if (command && command.name === arg.text &&
+              execWhereNeeded(command) && predictions.length === 1) {
+            return [];
+          }
+
+          return predictions;
+        }.bind(this));
       }.bind(this);
 
+      if (command) {
+        var status = execWhereNeeded(command) ? Status.VALID : Status.INCOMPLETE;
+        var conversion = new Conversion(command, arg, status, '', predictFunc);
+        return promise.resolve(conversion);
+      }
+
       return this._findPredictions(arg).then(function(predictions) {
         if (predictions.length === 0) {
           var msg = l10n.lookupFormat('typesSelectionNomatch', [ arg.text ]);
           return new Conversion(undefined, arg, Status.ERROR, msg, predictFunc);
         }
 
-        var command = predictions[0].value;
+        command = predictions[0].value;
 
         if (predictions.length === 1) {
           // Is it an exact match of an executable command,
           // or just the only possibility?
-          if (command.name === arg.text && typeof command.exec === 'function') {
+          if (command.name === arg.text && execWhereNeeded(command)) {
             return new Conversion(command, arg, Status.VALID, '');
           }
 
           return new Conversion(undefined, arg, Status.INCOMPLETE, '', predictFunc);
         }
 
         // It's valid if the text matches, even if there are several options
         if (predictions[0].name === arg.text) {
           return new Conversion(command, arg, Status.VALID, '', predictFunc);
         }
 
         return new Conversion(undefined, arg, Status.INCOMPLETE, '', predictFunc);
       }.bind(this));
+    },
+
+    _findPredictions: function(arg, context) {
+      return promise.resolve(this.getLookup(context)).then(function(lookup) {
+        var predictions = [];
+        var i, option;
+        var maxPredictions = Conversion.maxPredictions;
+        var match = arg.text.toLowerCase();
+
+        // Add an option to our list of predicted options
+        var addToPredictions = function(option) {
+          if (arg.text.length === 0) {
+            // If someone hasn't typed anything, we only show top level commands in
+            // the menu. i.e. sub-commands (those with a space in their name) are
+            // excluded. We do this to keep the list at an overview level.
+            if (option.name.indexOf(' ') === -1) {
+              predictions.push(option);
+            }
+          }
+          else {
+            // If someone has typed something, then we exclude parent commands
+            // (those without an exec). We do this because the user is drilling
+            // down and doesn't need the summary level.
+            if (option.value.exec != null) {
+              predictions.push(option);
+            }
+          }
+        };
+
+        // If the arg has a suffix then we're kind of 'done'. Only an exact
+        // match will do.
+        if (arg.suffix.match(/ +/)) {
+          for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
+            option = lookup[i];
+            if (option.name === arg.text ||
+                option.name.indexOf(arg.text + ' ') === 0) {
+              addToPredictions(option);
+            }
+          }
+
+          return predictions;
+        }
+
+        // Cache lower case versions of all the option names
+        for (i = 0; i < lookup.length; i++) {
+          option = lookup[i];
+          if (option._gcliLowerName == null) {
+            option._gcliLowerName = option.name.toLowerCase();
+          }
+        }
+
+        // Exact hidden matches. If 'hidden: true' then we only allow exact matches
+        // All the tests after here check that !option.value.hidden
+        for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
+          option = lookup[i];
+          if (option.name === arg.text) {
+            addToPredictions(option);
+          }
+        }
+
+        // Start with prefix matching
+        for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
+          option = lookup[i];
+          if (option._gcliLowerName.indexOf(match) === 0 && !option.value.hidden) {
+            if (predictions.indexOf(option) === -1) {
+              addToPredictions(option);
+            }
+          }
+        }
+
+        // Try infix matching if we get less half max matched
+        if (predictions.length < (maxPredictions / 2)) {
+          for (i = 0; i < lookup.length && predictions.length < maxPredictions; i++) {
+            option = lookup[i];
+            if (option._gcliLowerName.indexOf(match) !== -1 && !option.value.hidden) {
+              if (predictions.indexOf(option) === -1) {
+                addToPredictions(option);
+              }
+            }
+          }
+        }
+
+        // Try fuzzy matching if we don't get a prefix match
+        if (predictions.length === 0) {
+          var names = [];
+          lookup.forEach(function(opt) {
+            if (!opt.value.hidden) {
+              names.push(opt.name);
+            }
+          });
+          var corrected = spell.correct(match, names);
+          if (corrected) {
+            lookup.forEach(function(opt) {
+              if (opt.name === corrected) {
+                predictions.push(opt);
+              }
+            }, this);
+          }
+        }
+
+        return predictions;
+      }.bind(this));
     }
   }
 ];
 
 });
 /*
  * Copyright 2012, Mozilla Foundation and contributors
  *
@@ -4813,34 +4972,58 @@ DateType.prototype.parse = function(arg,
   var value;
 
   if (arg.text.replace(/\s/g, '').length === 0) {
     return promise.resolve(new Conversion(undefined, arg, Status.INCOMPLETE, ''));
   }
 
   // Lots of room for improvement here: 1h ago, in two days, etc.
   // Should "1h ago" dynamically update the step?
-  if (arg.text === 'now') {
+  if (arg.text.toLowerCase() === 'now' || arg.text.toLowerCase() === 'today') {
     value = new Date();
   }
-  else if (arg.text === 'yesterday') {
-    value = new Date().setDate(new Date().getDate() - 1);
-  }
-  else if (arg.text === 'tomorrow') {
-    value = new Date().setDate(new Date().getDate() + 1);
+  else if (arg.text.toLowerCase() === 'yesterday') {
+    value = new Date();
+    value.setDate(value.getDate() - 1);
+  }
+  else if (arg.text.toLowerCase() === 'tomorrow') {
+    value = new Date();
+    value.setDate(value.getDate() + 1);
   }
   else {
-    var millis = Date.parse(arg.text);
-
-    if (isNaN(millis)) {
+    // So now actual date parsing.
+    // Javascript dates are a mess. Like the default date libraries in most
+    // common languages, but with added browser weirdness.
+    // There is an argument for saying that the user will expect dates to be
+    // formatted as JavaScript dates, except that JS dates are of themselves
+    // very unexpected.
+    // See http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html
+
+    // The timezone used by Date.parse depends on whether or not the string
+    // can be interpreted as ISO-8601, so "2000-01-01" is not the same as
+    // "2000/01/01" (unless your TZ aligns with UTC) because the first is
+    // ISO-8601 and therefore assumed to be UTC, where the latter is assumed to
+    // be in the local timezone.
+
+    // First, if the user explicitly includes a 'Z' timezone marker, then we
+    // assume they know what they are doing with timezones. ISO-8601 uses 'Z'
+    // as a marker for 'Zulu time', zero hours offset i.e. UTC
+    if (arg.text.indexOf('Z') !== -1) {
+      value = new Date(arg.text);
+    }
+    else {
+      // Now we don't want the browser to assume ISO-8601 and therefore use UTC
+      // so we replace the '-' with '/'
+      value = new Date(arg.text.replace(/-/g, '/'));
+    }
+
+    if (isNaN(value.getTime())) {
       var msg = l10n.lookupFormat('typesDateNan', [ arg.text ]);
       return promise.resolve(new Conversion(undefined, arg, Status.ERROR, msg));
     }
-
-    value = new Date(millis);
   }
 
   return promise.resolve(new Conversion(value, arg));
 };
 
 DateType.prototype.decrement = function(value, context) {
   if (!isDate(value)) {
     return new Date();
@@ -4892,17 +5075,17 @@ function toDate(str) {
 
 /**
  * Is |thing| a valid date?
  * @see http://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript
  */
 function isDate(thing) {
   return Object.prototype.toString.call(thing) === '[object Date]'
           && !isNaN(thing.getTime());
-};
+}
 
 
 });
 /*
  * Copyright 2012, Mozilla Foundation and contributors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -5326,34 +5509,34 @@ var history = {
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 define('util/filesystem', ['require', 'exports', 'module' , 'util/promise'], function(require, exports, module) {
 
 'use strict';
 
-var OS = Components.utils.import("resource://gre/modules/osfile.jsm", {}).OS;
+var OS = Components.utils.import('resource://gre/modules/osfile.jsm', {}).OS;
 var promise = require('util/promise');
 
 /**
  * A set of functions that don't really belong in 'fs' (because they're not
  * really universal in scope) but also kind of do (because they're not specific
  * to GCLI
  */
 
 exports.join = OS.Path.join;
 exports.sep = OS.Path.sep;
 exports.dirname = OS.Path.dirname;
 
-var dirService = Components.classes["@mozilla.org/file/directory_service;1"]
+var dirService = Components.classes['@mozilla.org/file/directory_service;1']
                            .getService(Components.interfaces.nsIProperties);
-exports.home = dirService.get("Home", Components.interfaces.nsIFile).path;
-
-if ("winGetDrive" in OS.Path) {
+exports.home = dirService.get('Home', Components.interfaces.nsIFile).path;
+
+if ('winGetDrive' in OS.Path) {
   exports.sep = '\\';
 }
 else {
   exports.sep = '/';
 }
 
 /**
  * Split a path into its components.
@@ -5465,17 +5648,17 @@ var types = require('gcli/types');
 var Conversion = types.Conversion;
 var Type = types.Type;
 var Status = types.Status;
 
 /**
  * The object against which we complete, which is usually 'window' if it exists
  * but could be something else in non-web-content environments.
  */
-var globalObject = undefined;
+var globalObject;
 if (typeof window !== 'undefined') {
   globalObject = window;
 }
 
 /**
  * Setter for the object against which JavaScript completions happen
  */
 exports.setGlobalObject = function(obj) {
@@ -5555,17 +5738,17 @@ JavascriptType.prototype.parse = functio
   // string which means that no completion is possible.
   if (beginning.state !== ParseState.NORMAL) {
     return promise.resolve(new Conversion(typed, arg, Status.INCOMPLETE, ''));
   }
 
   var completionPart = typed.substring(beginning.startPos);
   var properties = completionPart.split('.');
   var matchProp;
-  var prop = undefined;
+  var prop;
 
   if (properties.length > 1) {
     matchProp = properties.pop().trimLeft();
     for (var i = 0; i < properties.length; i++) {
       prop = properties[i].trim();
 
       // We can't complete on null.foo, so bail out
       if (scope == null) {
@@ -5601,18 +5784,18 @@ JavascriptType.prototype.parse = functio
   // If the reason we just stopped adjusting the scope was a non-simple string,
   // then we're not sure if the input is valid or invalid, so accept it
   if (prop && !prop.match(/^[0-9A-Za-z]*$/)) {
     return promise.resolve(new Conversion(typed, arg));
   }
 
   // However if the prop was a simple string, it is an error
   if (scope == null) {
-    var message = l10n.lookupFormat('jstypeParseMissing', [ prop ]);
-    return promise.resolve(new Conversion(typed, arg, Status.ERROR, message));
+    var msg = l10n.lookupFormat('jstypeParseMissing', [ prop ]);
+    return promise.resolve(new Conversion(typed, arg, Status.ERROR, msg));
   }
 
   // If the thing we're looking for isn't a simple string, then we're not going
   // to find it, but we're not sure if it's valid or invalid, so accept it
   if (!matchProp.match(/^[0-9A-Za-z]*$/)) {
     return promise.resolve(new Conversion(typed, arg));
   }
 
@@ -5947,17 +6130,17 @@ JavascriptType.prototype._isIteratorOrGe
  */
 JavascriptType.prototype._isSafeProperty = function(scope, prop) {
   if (typeof scope !== 'object') {
     return false;
   }
 
   // Walk up the prototype chain of 'scope' looking for a property descriptor
   // for 'prop'
-  var propDesc = undefined;
+  var propDesc;
   while (scope) {
     try {
       propDesc = Object.getOwnPropertyDescriptor(scope, prop);
       if (propDesc) {
         break;
       }
     }
     catch (ex) {
@@ -6001,33 +6184,34 @@ exports.items = [ JavascriptType ];
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-define('gcli/types/node', ['require', 'exports', 'module' , 'util/promise', 'util/host', 'util/l10n', 'gcli/types', 'gcli/argument'], function(require, exports, module) {
+define('gcli/types/node', ['require', 'exports', 'module' , 'util/promise', 'util/host', 'util/l10n', 'util/util', 'gcli/types', 'gcli/argument'], function(require, exports, module) {
 
 'use strict';
 
 var promise = require('util/promise');
-var host = require('util/host');
+var Highlighter = require('util/host').Highlighter;
 var l10n = require('util/l10n');
+var util = require('util/util');
 var Status = require('gcli/types').Status;
 var Conversion = require('gcli/types').Conversion;
 var BlankArgument = require('gcli/argument').BlankArgument;
 
 
 /**
  * The object against which we complete, which is usually 'window' if it exists
  * but could be something else in non-web-content environments.
  */
-var doc = undefined;
+var doc;
 if (typeof document !== 'undefined') {
   doc = document;
 }
 
 /**
  * For testing only.
  * The fake empty NodeList used when there are no matches, we replace this with
  * something that looks better as soon as we have a document, so not only
@@ -6036,17 +6220,17 @@ if (typeof document !== 'undefined') {
 exports._empty = [];
 
 /**
  * Setter for the document that contains the nodes we're matching
  */
 exports.setDocument = function(document) {
   doc = document;
   if (doc != null) {
-    exports._empty = doc.querySelectorAll('x>:root');
+    exports._empty = util.createEmptyNodeList(doc);
   }
 };
 
 /**
  * Undo the effects of setDocument()
  */
 exports.unsetDocument = function() {
   doc = undefined;
@@ -6057,65 +6241,97 @@ exports.unsetDocument = function() {
  * Getter for the document that contains the nodes we're matching
  * Most for changing things back to how they were for unit testing
  */
 exports.getDocument = function() {
   return doc;
 };
 
 /**
+ * Helper functions to be attached to the prototypes of NodeType and
+ * NodeListType to allow inputter to tell us which nodes should be highlighted
+ */
+function onEnter(assignment) {
+  assignment.highlighter = new Highlighter(doc);
+  assignment.highlighter.nodelist = assignment.conversion.matches;
+}
+
+/** @see #onEnter() */
+function onLeave(assignment) {
+  assignment.highlighter.destroy();
+  delete assignment.highlighter;
+}
+/** @see #onEnter() */
+function onChange(assignment) {
+  if (assignment.conversion.matches == null) {
+    return;
+  }
+  if (!assignment.highlighter) {
+    return;
+  }
+
+  assignment.highlighter.nodelist = assignment.conversion.matches;
+}
+
+/**
  * The exported 'node' and 'nodelist' types
  */
 exports.items = [
   {
     // The 'node' type is a CSS expression that refers to a single node
     item: 'type',
     name: 'node',
 
     stringify: function(value, context) {
       if (value == null) {
         return '';
       }
       return value.__gcliQuery || 'Error';
     },
 
     parse: function(arg, context) {
+      var reply;
+
       if (arg.text === '') {
-        return promise.resolve(new Conversion(undefined, arg,
-                                              Status.INCOMPLETE));
-      }
-
-      var nodes;
-      try {
-        nodes = doc.querySelectorAll(arg.text);
-      }
-      catch (ex) {
-        return promise.resolve(new Conversion(undefined, arg, Status.ERROR,
-                                              l10n.lookup('nodeParseSyntax')));
-      }
-
-      if (nodes.length === 0) {
-        return promise.resolve(new Conversion(undefined, arg, Status.INCOMPLETE,
-                                              l10n.lookup('nodeParseNone')));
-      }
-
-      if (nodes.length === 1) {
-        var node = nodes.item(0);
-        node.__gcliQuery = arg.text;
-
-        host.flashNodes(node, true);
-
-        return promise.resolve(new Conversion(node, arg, Status.VALID, ''));
-      }
-
-      host.flashNodes(nodes, false);
-
-      var msg = l10n.lookupFormat('nodeParseMultiple', [ nodes.length ]);
-      return promise.resolve(new Conversion(undefined, arg, Status.ERROR, msg));
-    }
+        reply = new Conversion(undefined, arg, Status.INCOMPLETE);
+        reply.matches = util.createEmptyNodeList(doc);
+      }
+      else {
+        var nodes;
+        try {
+          nodes = doc.querySelectorAll(arg.text);
+          if (nodes.length === 0) {
+            reply = new Conversion(undefined, arg, Status.INCOMPLETE,
+                                   l10n.lookup('nodeParseNone'));
+          }
+          else if (nodes.length === 1) {
+            var node = nodes.item(0);
+            node.__gcliQuery = arg.text;
+
+            reply = new Conversion(node, arg, Status.VALID, '');
+          }
+          else {
+            var msg = l10n.lookupFormat('nodeParseMultiple', [ nodes.length ]);
+            reply = new Conversion(undefined, arg, Status.ERROR, msg);
+          }
+
+          reply.matches = nodes;
+        }
+        catch (ex) {
+          reply = new Conversion(undefined, arg, Status.ERROR,
+                                 l10n.lookup('nodeParseSyntax'));
+        }
+      }
+
+      return promise.resolve(reply);
+    },
+
+    onEnter: onEnter,
+    onLeave: onLeave,
+    onChange: onChange
   },
   {
     // The 'nodelist' type is a CSS expression that refers to a node list
     item: 'type',
     name: 'nodelist',
 
     // The 'allowEmpty' option ensures that we do not complain if the entered
     // CSS selector is valid, but does not match any nodes. There is some
@@ -6140,37 +6356,48 @@ exports.items = [
     stringify: function(value, context) {
       if (value == null) {
         return '';
       }
       return value.__gcliQuery || 'Error';
     },
 
     parse: function(arg, context) {
-      if (arg.text === '') {
-        return promise.resolve(new Conversion(undefined, arg, Status.INCOMPLETE));
-      }
-
-      var nodes;
+      var reply;
       try {
-        nodes = doc.querySelectorAll(arg.text);
+        if (arg.text === '') {
+          reply = new Conversion(undefined, arg, Status.INCOMPLETE);
+          reply.matches = util.createEmptyNodeList(doc);
+        }
+        else {
+          var nodes = doc.querySelectorAll(arg.text);
+
+          if (nodes.length === 0 && !this.allowEmpty) {
+            reply = new Conversion(undefined, arg, Status.INCOMPLETE,
+                                   l10n.lookup('nodeParseNone'));
+          }
+          else {
+            reply = new Conversion(nodes, arg, Status.VALID, '');
+          }
+
+          reply.matches = nodes;
+        }
       }
       catch (ex) {
-        return promise.resolve(new Conversion(undefined, arg, Status.ERROR,
-                                        l10n.lookup('nodeParseSyntax')));
-      }
-
-      if (nodes.length === 0 && !this.allowEmpty) {
-        return promise.resolve(new Conversion(undefined, arg, Status.INCOMPLETE,
-                                        l10n.lookup('nodeParseNone')));
-      }
-
-      host.flashNodes(nodes, false);
-      return promise.resolve(new Conversion(nodes, arg, Status.VALID, ''));
-    }
+        reply = new Conversion(undefined, arg, Status.ERROR,
+                               l10n.lookup('nodeParseSyntax'));
+        reply.matches = util.createEmptyNodeList(doc);
+      }
+
+      return promise.resolve(reply);
+    },
+
+    onEnter: onEnter,
+    onLeave: onLeave,
+    onChange: onChange
   }
 ];
 
 });
 /*
  * Copyright 2012, Mozilla Foundation and contributors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -6181,43 +6408,61 @@ exports.items = [
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-define('util/host', ['require', 'exports', 'module' ], function(require, exports, module) {
+define('util/host', ['require', 'exports', 'module' , 'util/util'], function(require, exports, module) {
 
 'use strict';
 
+var util = require('util/util');
+
 /**
  * The chromeWindow as as required by Highlighter, so it knows where to
  * create temporary highlight nodes.
  */
 exports.chromeWindow = undefined;
 
-/**
- * See docs in lib/util/host.js:flashNodes
- */
-exports.flashNodes = function(nodes, match) {
-  // Commented out until Bug 653545 is completed
-  /*
-  if (exports.chromeWindow == null) {
-    console.log('flashNodes has no chromeWindow. Skipping flash');
-    return;
-  }
-
-  var imports = {};
-  Components.utils.import("resource:///modules/highlighter.jsm", imports);
-
-  imports.Highlighter.flashNodes(nodes, exports.chromeWindow, match);
-  */
-};
+function Highlighter(document) {
+  this._document = document;
+  this._nodes = util.createEmptyNodeList(this._document);
+}
+
+Object.defineProperty(Highlighter.prototype, 'nodelist', {
+  set: function(nodes) {
+    Array.prototype.forEach.call(this._nodes, this._unhighlightNode, this);
+    this._nodes = (nodes == null) ?
+        util.createEmptyNodeList(this._document) :
+        nodes;
+    Array.prototype.forEach.call(this._nodes, this._highlightNode, this);
+  },
+  get: function() {
+    return this._nodes;
+  },
+  enumerable: true
+});
+
+Highlighter.prototype.destroy = function() {
+  this.nodelist = null;
+};
+
+Highlighter.prototype._highlightNode = function(node) {
+  // Enable when the highlighter rewrite is done
+};
+
+Highlighter.prototype._unhighlightNode = function(node) {
+  // Enable when the highlighter rewrite is done
+};
+
+exports.Highlighter = Highlighter;
+
 
 /**
  * See docs in lib/util/host.js:exec
  */
 exports.exec = function(execSpec) {
   throw new Error('Not supported');
 };
 
@@ -6296,48 +6541,49 @@ exports.items = [
         if (typeof this.max === 'number') {
           return this.max;
         }
       }
       return undefined;
     },
 
     parse: function(arg, context) {
+      var msg;
       if (arg.text.replace(/^\s*-?/, '').length === 0) {
         return promise.resolve(new Conversion(undefined, arg, Status.INCOMPLETE, ''));
       }
 
       if (!this.allowFloat && (arg.text.indexOf('.') !== -1)) {
-        var message = l10n.lookupFormat('typesNumberNotInt2', [ arg.text ]);
-        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, message));
+        msg = l10n.lookupFormat('typesNumberNotInt2', [ arg.text ]);
+        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, msg));
       }
 
       var value;
       if (this.allowFloat) {
         value = parseFloat(arg.text);
       }
       else {
         value = parseInt(arg.text, 10);
       }
 
       if (isNaN(value)) {
-        var message = l10n.lookupFormat('typesNumberNan', [ arg.text ]);
-        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, message));
+        msg = l10n.lookupFormat('typesNumberNan', [ arg.text ]);
+        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, msg));
       }
 
       var max = this.getMax(context);
       if (max != null && value > max) {
-        var message = l10n.lookupFormat('typesNumberMax', [ value, max ]);
-        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, message));
+        msg = l10n.lookupFormat('typesNumberMax', [ value, max ]);
+        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, msg));
       }
 
       var min = this.getMin(context);
       if (min != null && value < min) {
-        var message = l10n.lookupFormat('typesNumberMin', [ value, min ]);
-        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, message));
+        msg = l10n.lookupFormat('typesNumberMin', [ value, min ]);
+        return promise.resolve(new Conversion(undefined, arg, Status.ERROR, msg));
       }
 
       return promise.resolve(new Conversion(value, arg));
     },
 
     decrement: function(value, context) {
       if (typeof value !== 'number' || isNaN(value)) {
         return this.getMax(context) || 1;
@@ -6414,17 +6660,17 @@ var SelectionType = require('gcli/types/
 exports.clearResourceCache = function() {
   ResourceCache.clear();
 };
 
 /**
  * The object against which we complete, which is usually 'window' if it exists
  * but could be something else in non-web-content environments.
  */
-var doc = undefined;
+var doc;
 if (typeof document !== 'undefined') {
   doc = document;
 }
 
 /**
  * Setter for the document that contains the nodes we're matching
  */
 exports.setDocument = function(document) {
@@ -6902,20 +7148,28 @@ exports.items = [
     }
   },
   {
     item: 'converter',
     from: 'error',
     to: 'dom',
     exec: function(ex, conversionContext) {
       var node = util.createElement(conversionContext.document, 'p');
-      node.className = "gcli-error";
+      node.className = 'gcli-error';
       node.textContent = ex;
       return node;
     }
+  },
+  {
+    item: 'converter',
+    from: 'error',
+    to: 'string',
+    exec: function(ex, conversionContext) {
+      return '' + ex;
+    }
   }
 ];
 
 });
 /*
  * Copyright 2012, Mozilla Foundation and contributors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -7181,25 +7435,26 @@ define('util/domtemplate', ['require', '
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-define('gcli/cli', ['require', 'exports', 'module' , 'util/promise', 'util/util', 'util/l10n', 'gcli/ui/view', 'gcli/canon', 'gcli/types', 'gcli/argument'], function(require, exports, module) {
+define('gcli/cli', ['require', 'exports', 'module' , 'util/promise', 'util/util', 'util/l10n', 'gcli/ui/view', 'gcli/converters', 'gcli/canon', 'gcli/types', 'gcli/argument'], function(require, exports, module) {
 
 'use strict';
 
 var promise = require('util/promise');
 var util = require('util/util');
 var l10n = require('util/l10n');
 
 var view = require('gcli/ui/view');
+var converters = require('gcli/converters');
 var canon = require('gcli/canon');
 var CommandOutputManager = require('gcli/canon').CommandOutputManager;
 
 var Status = require('gcli/types').Status;
 var Conversion = require('gcli/types').Conversion;
 
 var Argument = require('gcli/argument').Argument;
 var ArrayArgument = require('gcli/argument').ArrayArgument;
@@ -7223,78 +7478,72 @@ function getEvalCommand() {
  * The data for the parameter is available as in the preferred type and as
  * an Argument for the CLI.
  * <p>We also record validity information where applicable.
  * <p>For values, null and undefined have distinct definitions. null means
  * that a value has been provided, undefined means that it has not.
  * Thus, null is a valid default value, and common because it identifies an
  * parameter that is optional. undefined means there is no value from
  * the command line.
- *
- * <h2>Events<h2>
- * Assignment publishes the following event:<ul>
- * <li>onAssignmentChange: Either the value or the text has changed. It is
- * likely that any UI component displaying this argument will need to be
- * updated.
- * The event object looks like:
- * <tt>{ assignment: ..., conversion: ..., oldConversion: ... }</tt>
  * @constructor
  */
 function Assignment(param, paramIndex) {
   // The parameter that we are assigning to
   this.param = param;
 
   this.conversion = undefined;
 
   // The index of this parameter in the parent Requisition. paramIndex === -1
   // is the command assignment although this should not be relied upon, it is
   // better to test param instanceof CommandAssignment
   this.paramIndex = paramIndex;
-
-  this.onAssignmentChange = util.createEvent('Assignment.onAssignmentChange');
 }
 
 /**
  * Easy accessor for conversion.arg.
  * This is a read-only property because writes to arg should be done through
  * the 'conversion' property.
  */
 Object.defineProperty(Assignment.prototype, 'arg', {
   get: function() {
-    return this.conversion.arg;
+    return this.conversion == null ? undefined : this.conversion.arg;
   },
   enumerable: true
 });
 
 /**
  * Easy accessor for conversion.value.
  * This is a read-only property because writes to value should be done through
  * the 'conversion' property.
  */
 Object.defineProperty(Assignment.prototype, 'value', {
   get: function() {
-    return this.conversion.value;
+    return this.conversion == null ? undefined : this.conversion.value;
   },
   enumerable: true
 });
 
 /**
  * Easy (and safe) accessor for conversion.message
  */
-Assignment.prototype.getMessage = function() {
-  return this.conversion.message ? this.conversion.message : '';
-};
+Object.defineProperty(Assignment.prototype, 'message', {
+  get: function() {
+    return this.conversion == null || !this.conversion.message ?
+        '' : this.conversion.message;
+  },
+  enumerable: true
+});
 
 /**
  * Easy (and safe) accessor for conversion.getPredictions()
  * @return An array of objects with name and value elements. For example:
  * [ { name:'bestmatch', value:foo1 }, { name:'next', value:foo2 }, ... ]
  */
 Assignment.prototype.getPredictions = function() {
-  return this.conversion.getPredictions();
+  return this.conversion == null ? [] : this.conversion.getPredictions();
 };
 
 /**
  * Accessor for a prediction by index.
  * This is useful above <tt>getPredictions()[index]</tt> because it normalizes
  * index to be within the bounds of the predictions, which means that the UI
  * can maintain an index of which prediction to choose without caring how many
  * predictions there are.
@@ -7374,17 +7623,17 @@ Object.defineProperty(Assignment.prototy
     this.getPredictions().then(function(predictions) {
       predictionCount = predictions.length;
     }, console.log);
     return {
       param: this.param.name + '/' + this.param.type.name,
       defaultValue: this.param.defaultValue,
       arg: this.conversion.arg._summaryJson,
       value: this.value,
-      message: this.getMessage(),
+      message: this.message,
       status: this.getStatus().toString(),
       predictionCount: predictionCount
     };
   },
   enumerable: true
 });
 
 exports.Assignment = Assignment;
@@ -7440,33 +7689,35 @@ var evalCmd = {
 };
 
 exports.items = [ evalCmd ];
 
 /**
  * This is a special assignment to reflect the command itself.
  */
 function CommandAssignment() {
-  var commandParamMetadata = { name: '__command', type: 'command' };
+  var commandParamMetadata = {
+    name: '__command',
+    type: { name: 'command', allowNonExec: false }
+  };
   // This is a hack so that rather than reply with a generic description of the
   // command assignment, we reply with the description of the assigned command,
   // (using a generic term if there is no assigned command)
   var self = this;
   Object.defineProperty(commandParamMetadata, 'description', {
     get: function() {
       var value = self.value;
       return value && value.description ?
           value.description :
           'The command to execute';
     },
     enumerable: true
   });
   this.param = new canon.Parameter(commandParamMetadata);
   this.paramIndex = -1;
-  this.onAssignmentChange = util.createEvent('CommandAssignment.onAssignmentChange');
 }
 
 CommandAssignment.prototype = Object.create(Assignment.prototype);
 
 CommandAssignment.prototype.getStatus = function(arg) {
   return Status.combine(
     Assignment.prototype.getStatus.call(this, arg),
     this.conversion.value && this.conversion.value.exec ?
@@ -7486,17 +7737,16 @@ function UnassignedAssignment(requisitio
     description: l10n.lookup('cliOptions'),
     type: {
       name: 'param',
       requisition: requisition,
       isIncompleteName: (arg.text.charAt(0) === '-')
     }
   });
   this.paramIndex = -1;
-  this.onAssignmentChange = util.createEvent('UnassignedAssignment.onAssignmentChange');
 
   // synchronize is ok because we can be sure that param type is synchronous
   var parsed = this.param.type.parse(arg, requisition.executionContext);
   this.conversion = util.synchronize(parsed);
   this.conversion.assignment = this;
 }
 
 UnassignedAssignment.prototype = Object.create(Assignment.prototype);
@@ -7516,19 +7766,16 @@ exports.logErrors = true;
  * There is little point in a requisition for parameter-less commands because
  * there is no information to collect. A Requisition is a collection of
  * assignments of values to parameters, each handled by an instance of
  * Assignment.
  *
  * <h2>Events<h2>
  * <p>Requisition publishes the following events:
  * <ul>
- * <li>onAssignmentChange: This is a forward of the onAssignmentChange event on
- * Assignment. It is fired when any assignment (except the commandAssignment)
- * changes.
  * <li>onTextChange: The text to be mirrored in a command line has changed.
  * </ul>
  *
  * @param environment An optional opaque object passed to commands in the
  * Execution Context.
  * @param doc A DOM Document passed to commands using the Execution Context in
  * order to allow creation of DOM nodes. If missing Requisition will use the
  * global 'document'.
@@ -7549,16 +7796,18 @@ function Requisition(environment, doc, c
   }
 
   this.commandOutputManager = commandOutputManager || new CommandOutputManager();
   this.shell = {
     cwd: '/', // Where we store the current working directory
     env: {}   // Where we store the current environment
   };
 
+  this.onTextChange = util.createEvent('Requisition.onTextChange');
+
   // The command that we are about to execute.
   // @see setCommandConversion()
   this.commandAssignment = new CommandAssignment();
   var assignPromise = this.setAssignment(this.commandAssignment, null,
                                    { internal: true });
   util.synchronize(assignPromise);
 
   // The object that stores of Assignment objects that we are filling out.
@@ -7573,55 +7822,43 @@ function Requisition(environment, doc, c
   this.assignmentCount = 0;
 
   // Used to store cli arguments in the order entered on the cli
   this._args = [];
 
   // Used to store cli arguments that were not assigned to parameters
   this._unassigned = [];
 
-  // Temporarily set this to true to prevent _assignmentChanged resetting
-  // argument positions
-  this._structuralChangeInProgress = false;
-
   // Changes can be asynchronous, when one update starts before another
   // finishes we abandon the former change
   this._nextUpdateId = 0;
 
   // We can set a prefix to typed commands to make it easier to focus on
   // Allowing us to type "add -a; commit" in place of "git add -a; git commit"
   this.prefix = '';
-
-  this.commandAssignment.onAssignmentChange.add(this._commandAssignmentChanged, this);
-  this.commandAssignment.onAssignmentChange.add(this._assignmentChanged, this);
-
-  this.onAssignmentChange = util.createEvent('Requisition.onAssignmentChange');
-  this.onTextChange = util.createEvent('Requisition.onTextChange');
 }
 
 /**
  * Avoid memory leaks
  */
 Requisition.prototype.destroy = function() {
-  this.commandAssignment.onAssignmentChange.remove(this._commandAssignmentChanged, this);
-  this.commandAssignment.onAssignmentChange.remove(this._assignmentChanged, this);
-
   delete this.document;
   delete this.environment;
 };
 
 /**
  * If we're about to make an asynchronous change when other async changes could
  * overtake this one, then we want to be able to bail out if overtaken. The
  * value passed back from beginChange should be passed to endChangeCheckOrder
  * on completion of calculation, before the results are applied in order to
  * check that the calculation has not been overtaken
  */
 Requisition.prototype._beginChange = function() {
-  this._structuralChangeInProgress = true;
+  this.onTextChange.holdFire();
+
   var updateId = this._nextUpdateId;
   this._nextUpdateId++;
   return updateId;
 };
 
 /**
  * Check to see if another change has started since updateId started.
  * This allows us to bail out of an update.
@@ -7632,23 +7869,24 @@ Requisition.prototype._beginChange = fun
 Requisition.prototype._isChangeCurrent = function(updateId) {
   return updateId + 1 === this._nextUpdateId;
 };
 
 /**
  * See notes on beginChange
  */
 Requisition.prototype._endChangeCheckOrder = function(updateId) {
+  this.onTextChange.resumeFire();
+
   if (updateId + 1 !== this._nextUpdateId) {
     // An update that started after we did has already finished, so our
     // changes are out of date. Abandon further work.
     return false;
   }
 
-  this._structuralChangeInProgress = false;
   return true;
 };
 
 var legacy = false;
 
 /**
  * Functions and data related to the execution of a command
  */
@@ -7751,69 +7989,16 @@ Object.defineProperty(Requisition.protot
     }
 
     return this._conversionContext;
   },
   enumerable: true
 });
 
 /**
- * When any assignment changes, we might need to update the _args array to
- * match and inform people of changes to the typed input text.
- */
-Requisition.prototype._assignmentChanged = function(ev) {
-  // Don't report an event if the value is unchanged
-  if (ev.oldConversion != null &&
-      ev.conversion.valueEquals(ev.oldConversion)) {
-    return;
-  }
-
-  if (this._structuralChangeInProgress) {
-    return;
-  }
-
-  this.onAssignmentChange(ev);
-
-  // Both for argument position and the onTextChange event, we only care
-  // about changes to the argument.
-  if (ev.conversion.argEquals(ev.oldConversion)) {
-    return;
-  }
-
-  this.onTextChange();
-};
-
-/**
- * When the command changes, we need to keep a bunch of stuff in sync
- */
-Requisition.prototype._commandAssignmentChanged = function(ev) {
-  // Assignments fire AssignmentChange events on any change, including minor
-  // things like whitespace change in arg prefix, so we ignore anything but
-  // an actual value change
-  if (ev.conversion.valueEquals(ev.oldConversion)) {
-    return;
-  }
-
-  this._assignments = {};
-
-  var command = this.commandAssignment.value;
-  if (command) {
-    for (var i = 0; i < command.params.length; i++) {
-      var param = command.params[i];
-      var assignment = new Assignment(param, i);
-      var assignPromise = this.setAssignment(assignment, null, { internal: true });
-      util.synchronize(assignPromise);
-      assignment.onAssignmentChange.add(this._assignmentChanged, this);
-      this._assignments[param.name] = assignment;
-    }
-  }
-  this.assignmentCount = Object.keys(this._assignments).length;
-};
-
-/**
  * Assignments have an order, so we need to store them in an array.
  * But we also need named access ...
  * @return The found assignment, or undefined, if no match was found
  */
 Requisition.prototype.getAssignment = function(nameOrNumber) {
   var name = (typeof nameOrNumber === 'string') ?
     nameOrNumber :
     Object.keys(this._assignments)[nameOrNumber];
@@ -7862,60 +8047,67 @@ Requisition.prototype.cloneAssignments =
 
 /**
  * The overall status is the most severe status.
  * There is no such thing as an INCOMPLETE overall status because the
  * definition of INCOMPLETE takes into account the cursor position to say 'this
  * isn't quite ERROR because the user can fix it by typing', however overall,
  * this is still an error status.
  */
-Requisition.prototype.getStatus = function() {
-  var status = Status.VALID;
-  if (this._unassigned.length !== 0) {
-    var isAllIncomplete = true;
-    this._unassigned.forEach(function(assignment) {
-      if (!assignment.param.type.isIncompleteName) {
-        isAllIncomplete = false;
-      }
-    });
-    status = isAllIncomplete ? Status.INCOMPLETE : Status.ERROR;
-  }
-
-  this.getAssignments(true).forEach(function(assignment) {
-    var assignStatus = assignment.getStatus();
-    if (assignStatus > status) {
-      status = assignStatus;
-    }
-  }, this);
-  if (status === Status.INCOMPLETE) {
-    status = Status.ERROR;
-  }
-  return status;
-};
-
-/**
- * If ``requisition.getStatus() != VALID`` message then return a string which
+Object.defineProperty(Requisition.prototype, 'status', {
+  get : function() {
+    var status = Status.VALID;
+    if (this._unassigned.length !== 0) {
+      var isAllIncomplete = true;
+      this._unassigned.forEach(function(assignment) {
+        if (!assignment.param.type.isIncompleteName) {
+          isAllIncomplete = false;
+        }
+      });
+      status = isAllIncomplete ? Status.INCOMPLETE : Status.ERROR;
+    }
+
+    this.getAssignments(true).forEach(function(assignment) {
+      var assignStatus = assignment.getStatus();
+      if (assignStatus > status) {
+        status = assignStatus;
+      }
+    }, this);
+    if (status === Status.INCOMPLETE) {
+      status = Status.ERROR;
+    }
+    return status;
+  },
+  enumerable : true
+});
+
+/**
+ * If ``requisition.status != VALID`` message then return a string which
  * best describes what is wrong. Generally error messages are delivered by
  * looking at the error associated with the argument at the cursor, but there
  * are times when you just want to say 'tell me the worst'.
- * If ``requisition.getStatus() != VALID`` then return ``null``.
+ * If ``requisition.status != VALID`` then return ``null``.
  */
 Requisition.prototype.getStatusMessage = function() {
-  var message = null;
-  this.getAssignments(true).forEach(function(assignment) {
-    if (assignment.getStatus() !== Status.VALID) {
-      message = assignment.getMessage();
-    }
-  }, this);
-
-  if (message == null && this._unassigned.length !== 0) {
-    message = l10n.lookup('cliUnusedArg');
-  }
-
-  return message;
+  if (this.commandAssignment.getStatus() !== Status.VALID) {
+    return l10n.lookup('cliUnknownCommand');
+  }
+
+  var assignments = this.getAssignments();
+  for (var i = 0; i < assignments.length; i++) {
+    if (assignments[i].getStatus() !== Status.VALID) {
+      return assignments[i].message;
+    }
+  }
+
+  if (this._unassigned.length !== 0) {
+    return l10n.lookup('cliUnusedArg');
+  }
+
+  return null;
 };
 
 /**
  * Extract the names and values of all the assignments, and return as
  * an object.
  */
 Requisition.prototype.getArgsObject = function() {
   var args = {};
@@ -7940,16 +8132,58 @@ Requisition.prototype.getAssignments = f
   }
   Object.keys(this._assignments).forEach(function(name) {
     assignments.push(this.getAssignment(name));
   }, this);
   return assignments;
 };
 
 /**
+ * When any assignment changes, we might need to update the _args array to
+ * match and inform people of changes to the typed input text.
+ */
+Requisition.prototype._setAssignmentInternal = function(assignment, conversion) {
+  var oldConversion = assignment.conversion;
+
+  assignment.conversion = conversion;
+  assignment.conversion.assignment = assignment;
+
+  // Do nothing if the conversion is unchanged
+  if (assignment.conversion.equals(oldConversion)) {
+    if (assignment === this.commandAssignment) {
+      this.setBlankArguments();
+    }
+    return;
+  }
+
+  // When the command changes, we need to keep a bunch of stuff in sync
+  if (assignment === this.commandAssignment) {
+    this._assignments = {};
+
+    var command = this.commandAssignment.value;
+    if (command) {
+      for (var i = 0; i < command.params.length; i++) {
+        var param = command.params[i];
+        var newAssignment = new Assignment(param, i);
+        var assignPromise = this.setAssignment(newAssignment, null, { internal: true });
+        util.synchronize(assignPromise);
+
+        this._assignments[param.name] = newAssignment;
+      }
+    }
+    this.assignmentCount = Object.keys(this._assignments).length;
+  }
+
+  // For the onTextChange event, we only care about changes to the argument
+  if (!assignment.conversion.argEquals(oldConversion)) {
+    this.onTextChange();
+  }
+};
+
+/**
  * Internal function to alter the given assignment using the given arg.
  * @param assignment The assignment to alter
  * @param arg The new value for the assignment. An instance of Argument, or an
  * instance of Conversion, or null to set the blank value.
  * @param options There are a number of ways to customize how the assignment
  * is made, including:
  * - internal: (default:false) External updates are required to do more work,
  *   including adjusting the args in this requisition to stay in sync.
@@ -8003,28 +8237,17 @@ Requisition.prototype.setAssignment = fu
       }
     }
   }
 
   var updateId = options.internal ? null : this._beginChange();
 
   var setAssignmentInternal = function(conversion) {
     if (options.internal || this._endChangeCheckOrder(updateId)) {
-      var oldConversion = assignment.conversion;
-
-      assignment.conversion = conversion;
-      assignment.conversion.assignment = assignment;
-
-      if (!assignment.conversion.equals(oldConversion)) {
-        assignment.onAssignmentChange({
-          assignment: assignment,
-          conversion: assignment.conversion,
-          oldConversion: oldConversion
-        });
-      }
+      this._setAssignmentInternal(assignment, conversion);
     }
 
     return promise.resolve(undefined);
   }.bind(this);
 
   if (arg == null) {
     var blank = assignment.param.type.getBlank(this.executionContext);
     return setAssignmentInternal(blank);
@@ -8090,19 +8313,18 @@ Requisition.prototype.complete = functio
               assignment.getStatus() === Status.VALID) {
         outstanding.push(this._addSpace(assignment));
       }
 
       // Also add a space if we are in the name part of an assignment, however
       // this time we don't want the 'push the space to the next assignment'
       // logic, so we don't use addSpace
       if (assignment.isInName()) {
-        var newArg = assignment.conversion.arg.beget({ prefixPostSpace: true });
-        var p = this.setAssignment(assignment, newArg);
-        outstanding.push(p);
+        var newArg = assignment.arg.beget({ prefixPostSpace: true });
+        outstanding.push(this.setAssignment(assignment, newArg));
       }
     }
     else {
       // Mutate this argument to hold the completion
       var arg = assignment.arg.beget({
         text: prediction.name,
         dontQuote: (assignment === this.commandAssignment)
       });
@@ -8143,50 +8365,50 @@ Requisition.prototype._assertArgsAssigne
 };
 
 /**
  * Pressing TAB sometimes requires that we add a space to denote that we're on
  * to the 'next thing'.
  * @param assignment The assignment to which to append the space
  */
 Requisition.prototype._addSpace = function(assignment) {
-  var arg = assignment.conversion.arg.beget({ suffixSpace: true });
-  if (arg !== assignment.conversion.arg) {
+  var arg = assignment.arg.beget({ suffixSpace: true });
+  if (arg !== assignment.arg) {
     return this.setAssignment(assignment, arg);
   }
   else {
     return promise.resolve(undefined);
   }
 };
 
 /**
  * Replace the current value with the lower value if such a concept exists.
  */
 Requisition.prototype.decrement = function(assignment) {
-  var replacement = assignment.param.type.decrement(assignment.conversion.value,
+  var replacement = assignment.param.type.decrement(assignment.value,
                                                     this.executionContext);
   if (replacement != null) {
     var str = assignment.param.type.stringify(replacement,
                                               this.executionContext);
-    var arg = assignment.conversion.arg.beget({ text: str });
+    var arg = assignment.arg.beget({ text: str });
     var assignPromise = this.setAssignment(assignment, arg);
     util.synchronize(assignPromise);
   }
 };
 
 /**
  * Replace the current value with the higher value if such a concept exists.
  */
 Requisition.prototype.increment = function(assignment) {
-  var replacement = assignment.param.type.increment(assignment.conversion.value,
+  var replacement = assignment.param.type.increment(assignment.value,
                                                     this.executionContext);
   if (replacement != null) {
     var str = assignment.param.type.stringify(replacement,
                                               this.executionContext);
-    var arg = assignment.conversion.arg.beget({ text: str });
+    var arg = assignment.arg.beget({ text: str });
     var assignPromise = this.setAssignment(assignment, arg);
     util.synchronize(assignPromise);
   }
 };
 
 /**
  * Extract a canonical version of the input
  */
@@ -8344,17 +8566,17 @@ Requisition.prototype.getInputStatusMark
         }
       }
     }
 
     markup.push({ status: status, string: argTrace.character });
   }
 
   // De-dupe: merge entries where 2 adjacent have same status
-  var i = 0;
+  i = 0;
   while (i < markup.length - 1) {
     if (markup[i].status === markup[i + 1].status) {
       markup[i].string += markup[i + 1].string;
       markup.splice(i + 1, 1);
     }
     else {
       i++;
     }
@@ -8433,56 +8655,43 @@ Requisition.prototype.getAssignmentAt = 
  * Entry point for keyboard accelerators or anything else that wants to execute
  * a command.
  * @param options Object describing how the execution should be handled.
  * (optional). Contains some of the following properties:
  * - hidden (boolean, default=false) Should the output be hidden from the
  *   commandOutputManager for this requisition
  * - command/args A fast shortcut to executing a known command with a known
  *   set of parsed arguments.
- * - typed (string, deprecated) Don't use this. Also don't set the options
- *   object itself to be a string.
  */
 Requisition.prototype.exec = function(options) {
   var command = null;
   var args = null;
   var hidden = false;
-  if (options && options.hidden) {
-    hidden = true;
-  }
 
   if (options) {
-    if (typeof input === 'string') {
-      // Deprecated - does not handle async properly
-      this.update(options);
-    }
-    else if (typeof options.typed === 'string') {
-      // Deprecated - does not handle async properly
-      this.update(options.typed);
-    }
-    else if (options.command != null) {
+    if (options.hidden) {
+      hidden = true;
+    }
+
+    if (options.command != null) {
       // Fast track by looking up the command directly since passed args
       // means there is no command line to parse.
       command = canon.getCommand(options.command);
       if (!command) {
         console.error('Command not found: ' + options.command);
       }
       args = options.args;
     }
   }
 
   if (!command) {
     command = this.commandAssignment.value;
     args = this.getArgsObject();
   }
 
-  if (!command) {
-    throw new Error('Unknown command');
-  }
-
   // Display JavaScript input without the initial { or closing }
   var typed = this.toString();
   if (evalCmd.isCommandRegexp.test(typed)) {
     typed = typed.replace(evalCmd.isCommandRegexp, '');
     // Bug 717763: What if the JavaScript naturally ends with a }?
     typed = typed.replace(/\s*}\s*$/, '');
   }
 
@@ -8493,41 +8702,52 @@ Requisition.prototype.exec = function(op
     canonical: this.toCanonicalString(),
     hidden: hidden
   });
 
   this.commandOutputManager.onOutput({ output: output });
 
   var onDone = function(data) {
     output.complete(data, false);
+    return output;
   };
 
   var onError = function(ex) {
     if (exports.logErrors) {
       util.errorHandler(ex);
     }
 
     var data = ex.isTypedData ? ex : {
       isTypedData: true,
       data: ex,
       type: 'error'
     };
     output.complete(data, true);
+    return output;
   };
 
-  try {
-    var reply = command.exec(args, this.executionContext);
-    promise.resolve(reply).then(onDone, onError);
-  }
-  catch (ex) {
-    onError(ex);
-  }
-
-  this.clear();
-  return output;
+  if (this.status !== Status.VALID) {
+    var ex = new Error(this.getStatusMessage());
+    return promise.resolve(onError(ex)).then(function(output) {
+      this.clear();
+      return output;
+    });
+  }
+  else {
+    try {
+      var reply = command.exec(args, this.executionContext);
+      return promise.resolve(reply).then(onDone, onError);
+    }
+    catch (ex) {
+      return promise.resolve(onError(ex));
+    }
+    finally {
+      this.clear();
+    }
+  }
 };
 
 /**
  * A shortcut for calling update, resolving the promise and then exec.
  * @param input The string to execute
  * @param options Passed to exec
  * @return A promise of an output object
  */
@@ -8536,28 +8756,28 @@ Requisition.prototype.updateExec = funct
     return this.exec(options);
   }.bind(this));
 };
 
 /**
  * Similar to update('') except that it's guaranteed to execute synchronously
  */
 Requisition.prototype.clear = function() {
-  this._structuralChangeInProgress = true;
+  this.onTextChange.holdFire();
 
   var arg = new Argument('', '', '');
   this._args = [ arg ];
 
   var commandType = this.commandAssignment.param.type;
   var parsePromise = commandType.parse(arg, this.executionContext);
   this.setAssignment(this.commandAssignment,
                      util.synchronize(parsePromise),
                      { internal: true });
 
-  this._structuralChangeInProgress = false;
+  this.onTextChange.resumeFire();
   this.onTextChange();
 };
 
 /**
  * Helper to find the 'data-command' attribute, used by |update()|
  */
 function getDataCommandAttribute(element) {
   var command = element.getAttribute('data-command');
@@ -8705,18 +8925,18 @@ exports.tokenize = function(typed) {
       .replace(/\\}/g, '\uF005');
 
   function unescape2(escaped) {
     return escaped
         .replace(/\uF000/g, '\\\\')
         .replace(/\uF001/g, '\\ ')
         .replace(/\uF002/g, '\\\'')
         .replace(/\uF003/g, '\\\"')
-        .replace(/\uF004/g, '\\\{')
-        .replace(/\uF005/g, '\\\}');
+        .replace(/\uF004/g, '\\{')
+        .replace(/\uF005/g, '\\}');
   }
 
   var i = 0;          // The index of the current character
   var start = 0;      // Where did this section start?
   var prefix = '';    // Stuff that comes before the current argument
   var args = [];      // The array that we're creating
   var blockDepth = 0; // For JS with nested {}
 
@@ -8859,17 +9079,17 @@ function isSimple(typed) {
 Requisition.prototype._split = function(args) {
   // We're processing args, so we don't want the assignments that we make to
   // try to adjust other args assuming this is an external update
   var noArgUp = { internal: true };
 
   // Handle the special case of the user typing { javascript(); }
   // We use the hidden 'eval' command directly rather than shift()ing one of
   // the parameters, and parse()ing it.
-  var conversion = undefined;
+  var conversion;
   if (args[0].type === 'ScriptArgument') {
     // Special case: if the user enters { console.log('foo'); } then we need to
     // use the hidden 'eval' command
     conversion = new Conversion(getEvalCommand(), new ScriptArgument());
     return this.setAssignment(this.commandAssignment, conversion, noArgUp);
   }
 
   var argsUsed = 1;
@@ -9010,27 +9230,32 @@ Requisition.prototype._assign = function
           var arrayArg = arrayArgs[assignment.param.name];
           if (!arrayArg) {
             arrayArg = new ArrayArgument();
             arrayArgs[assignment.param.name] = arrayArg;
           }
           arrayArg.addArgument(arg);
         }
         else {
-          outstanding.push(this.setAssignment(assignment, arg, noArgUp));
+          if (assignment.arg.type === 'BlankArgument') {
+            outstanding.push(this.setAssignment(assignment, arg, noArgUp));
+          }
+          else {
+            this._addUnassignedArgs(arg.getArgs());
+          }
         }
       }
       else {
         // Skip this parameter and handle as a positional parameter
         i++;
       }
     }
   }, this);
 
-  // What's left are positional parameters assign in order
+  // What's left are positional parameters: assign in order
   unassignedParams.forEach(function(name) {
     var assignment = this.getAssignment(name);
 
     // If not set positionally, and we can't set it non-positionally,
     // we have to default it to prevent previous values surviving
     if (!assignment.param.isPositionalAllowed) {
       outstanding.push(this.setAssignment(assignment, null, noArgUp));
       return;
@@ -9129,22 +9354,24 @@ Output.prototype.complete = function(dat
       this.type = (this.data == null) ? 'undefined' : typeof this.data;
     }
   }
 
   if (this.type === 'object') {
     throw new Error('No type from output of ' + this.typed);
   }
 
-  if (error) {
-    this._deferred.reject();
-  }
-  else {
-    this._deferred.resolve();
-  }
+  this._deferred.resolve();
+};
+
+/**
+ * Call converters.convert using the data in this Output object
+ */
+Output.prototype.convert = function(type, conversionContext) {
+  return converters.convert(this.data, this.type, type, conversionContext);
 };
 
 exports.Output = Output;
 
 
 });
 define("text!gcli/ui/intro.html", [], "\n" +
   "<div>\n" +
@@ -9589,21 +9816,22 @@ exports.FocusManager = FocusManager;
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-define('gcli/ui/fields/basic', ['require', 'exports', 'module' , 'util/util', 'util/l10n', 'gcli/argument', 'gcli/types', 'gcli/ui/fields'], function(require, exports, module) {
+define('gcli/ui/fields/basic', ['require', 'exports', 'module' , 'util/util', 'util/promise', 'util/l10n', 'gcli/argument', 'gcli/types', 'gcli/ui/fields'], function(require, exports, module) {
 
 'use strict';
 
 var util = require('util/util');
+var promise = require('util/promise');
 var l10n = require('util/l10n');
 
 var Argument = require('gcli/argument').Argument;
 var TrueNamedArgument = require('gcli/argument').TrueNamedArgument;
 var FalseNamedArgument = require('gcli/argument').FalseNamedArgument;
 var ArrayArgument = require('gcli/argument').ArrayArgument;
 var ArrayConversion = require('gcli/types').ArrayConversion;
 
@@ -9760,17 +9988,17 @@ BooleanField.prototype.getConversion = f
 
 /**
  * A field that works with delegate types by delaying resolution until that
  * last possible time
  */
 function DelegateField(type, options) {
   Field.call(this, type, options);
   this.options = options;
-  this.requisition.onAssignmentChange.add(this.update, this);
+  this.requisition.onTextChange.add(this.update, this);
 
   this.element = util.createElement(this.document, 'div');
   this.update();
 
   this.onFieldChange = util.createEvent('DelegateField.onFieldChange');
 }
 
 DelegateField.prototype = Object.create(Field.prototype);
@@ -9795,17 +10023,17 @@ DelegateField.prototype.update = functio
 };
 
 DelegateField.claim = function(type, context) {
   return type.isDelegate ? Field.MATCH : Field.NO_MATCH;
 };
 
 DelegateField.prototype.destroy = function() {
   Field.prototype.destroy.call(this);
-  this.requisition.onAssignmentChange.remove(this.update, this);
+  this.requisition.onTextChange.remove(this.update, this);
   delete this.element;
   delete this.document;
   delete this.onInputChange;
 };
 
 DelegateField.prototype.setConversion = function(conversion) {
   this.field.setConversion(conversion);
 };
@@ -9873,35 +10101,40 @@ ArrayField.prototype.setConversion = fun
   conversion.conversions.forEach(function(subConversion) {
     this._onAdd(null, subConversion);
   }, this);
 };
 
 ArrayField.prototype.getConversion = function() {
   var conversions = [];
   var arrayArg = new ArrayArgument();
+
+  var addConversion = function(conversion) {
+    conversions.push(conversion);
+    arrayArg.addArgument(conversion.arg);
+  }.bind(this);
+
   for (var i = 0; i < this.members.length; i++) {
-    Promise.resolve(this.members[i].field.getConversion()).then(function(conversion) {
-      conversions.push(conversion);
-      arrayArg.addArgument(conversion.arg);
-    }.bind(this), util.errorHandler);
-  }
+    var reply = this.members[i].field.getConversion();
+    promise.resolve(reply).then(addConversion, util.errorHandler);
+  }
+
   return new ArrayConversion(conversions, arrayArg);
 };
 
 ArrayField.prototype._onAdd = function(ev, subConversion) {
   // <div class=gcliArrayMbr save="${element}">
   var element = util.createElement(this.document, 'div');
   element.classList.add('gcli-array-member');
   this.container.appendChild(element);
 
   // ${field.element}
   var field = fields.getField(this.type.subtype, this.options);
   field.onFieldChange.add(function() {
-    Promise.resolve(this.getConversion()).then(function(conversion) {
+    promise.resolve(this.getConversion()).then(function(conversion) {
       this.onFieldChange({ conversion: conversion });
       this.setMessage(conversion.message);
     }.bind(this), util.errorHandler);
   }, this);
 
   if (subConversion) {
     field.setConversion(subConversion);
   }
@@ -10375,17 +10608,17 @@ function SelectionField(type, options) {
   this.items = [];
 
   this.element = util.createElement(this.document, 'select');
   this.element.classList.add('gcli-field');
   this._addOption({
     name: l10n.lookupFormat('fieldSelectionSelect', [ options.name ])
   });
 
-  Promise.resolve(this.type.getLookup()).then(function(lookup) {
+  promise.resolve(this.type.getLookup()).then(function(lookup) {
     lookup.forEach(this._addOption, this);
   }.bind(this), util.errorHandler);
 
   this.onInputChange = this.onInputChange.bind(this);
   this.element.addEventListener('change', this.onInputChange, false);
 
   this.onFieldChange = util.createEvent('SelectionField.onFieldChange');
 }
@@ -10593,23 +10826,25 @@ var connect = {
   params: [
     {
       name: 'prefix',
       type: 'string',
       description: l10n.lookup('connectPrefixDesc')
     },
     {
       name: 'host',
+      short: 'h',
       type: 'string',
       description: l10n.lookup('connectHostDesc'),
       defaultValue: 'localhost',
       option: true
     },
     {
       name: 'port',
+      short: 'p',
       type: { name: 'number', max: 65536, min: 0 },
       description: l10n.lookup('connectPortDesc'),
       defaultValue: connector.defaultPort,
       option: true
     }
   ],
   returnType: 'string',
 
@@ -10639,17 +10874,17 @@ var connect = {
    */
   createRemoter: function(prefix, connection) {
     return function(cmdArgs, context) {
       var typed = context.typed;
 
       // If we've been called using a 'context' then there will be no prefix
       // otherwise we need to remove it
       if (typed.indexOf(prefix) === 0) {
-        typed = typed.substring(prefix.length).replace(/^ */, "");
+        typed = typed.substring(prefix.length).replace(/^ */, '');
       }
 
       return connection.execute(typed, cmdArgs).then(function(reply) {
         var typedData = context.typedData(reply.type, reply.data);
         if (!reply.error) {
           return typedData;
         }
         else {
@@ -10828,17 +11063,17 @@ exports.disconnectSupportsForce = false;
  */
 Connection.prototype.disconnect = function(force) {
   var deferred = promise.defer();
 
   this.client.close(function() {
     deferred.resolve();
   });
 
-  return request.promise;
+  return deferred.promise;
 };
 
 /**
  * A Request is a command typed at the client which lives until the command
  * has finished executing on the server
  */
 function Request(actor, typed, args) {
   this.json = {
@@ -10988,25 +11223,26 @@ var helpCommand = {
           }
           else {
             var defaultValue = param.type.stringify(param.defaultValue);
             input = l10n.lookupFormat('helpManDefault', [ defaultValue ]);
           }
           return '(' + param.type.name + ', ' + input + ')';
         },
         getSynopsis: function(param) {
+          var short = param.short ? '|-' + param.short : '';
           if (param.isPositionalAllowed) {
             return param.defaultValue !== undefined ?
-                '[' + param.name + ']' :
-                '<' + param.name + '>';
+                '[' + param.name + short + ']' :
+                '<' + param.name + short + '>';
           }
           else {
             return param.type.name === 'boolean' ?
-                '[--' + param.name + ']' :
-                '[--' + param.name + '=...]';
+                '[--' + param.name + short + ']' :
+                '[--' + param.name + short + ' ...]';
           }
         },
         command: commandData.command,
         subcommands: commandData.subcommands
       },
       css: helpCss,
       cssId: 'gcli-help'
     });
@@ -11063,17 +11299,17 @@ var help = {
       type: 'string',
       description: l10n.lookup('helpSearchDesc'),
       manual: l10n.lookup('helpSearchManual3'),
       defaultValue: null
     }
   ],
 
   exec: function(args, context) {
-    var command = canon.getCommand(args.search || undefined);
+    var command = canon.getCommand(args.search);
     if (command) {
       return context.typedData('commandData', {
         command: command,
         subcommands: getSubCommands(command)
       });
     }
 
     return context.typedData('commandsData', {
@@ -11114,17 +11350,18 @@ function getMatchingCommands(prefix) {
  */
 function getSubCommands(command) {
   if (command.exec != null) {
     return [];
   }
 
   var subcommands = canon.getCommands().filter(function(subcommand) {
     return subcommand.name.indexOf(command.name) === 0 &&
-            subcommand.name !== command.name;
+           subcommand.name !== command.name &&
+           !subcommand.hidden;
   });
 
   subcommands.sort(function(c1, c2) {
     return c1.name.localeCompare(c2.name);
   });
 
   return subcommands;
 }
@@ -11144,26 +11381,27 @@ define("text!gcli/commands/help_man.html
   "    </span>\n" +
   "  </h4>\n" +
   "\n" +
   "  <h4 class=\"gcli-help-header\">${l10n.helpManDescription}:</h4>\n" +
   "\n" +
   "  <p class=\"gcli-help-description\">${describe(command)}</p>\n" +
   "\n" +
   "  <div if=\"${command.exec}\">\n" +
-  "    <h4 class=\"gcli-help-header\">${l10n.helpManParameters}:</h4>\n" +
-  "\n" +
-  "    <ul class=\"gcli-help-parameter\">\n" +
-  "      <li if=\"${command.params.length === 0}\">${l10n.helpManNone}</li>\n" +
-  "      <li foreach=\"param in ${command.params}\">\n" +
-  "        ${param.name} <em>${getTypeDescription(param)}</em>\n" +
-  "        <br/>\n" +
-  "        ${describe(param)}\n" +
-  "      </li>\n" +
-  "    </ul>\n" +
+  "    <div foreach=\"groupName in ${command.paramGroups}\">\n" +
+  "      <h4 class=\"gcli-help-header\">${groupName}:</h4>\n" +
+  "      <ul class=\"gcli-help-parameter\">\n" +
+  "        <li if=\"${command.params.length === 0}\">${l10n.helpManNone}</li>\n" +
+  "        <li foreach=\"param in ${command.paramGroups[groupName]}\">\n" +
+  "          <code>${getSynopsis(param)}</code> <em>${getTypeDescription(param)}</em>\n" +
+  "          <br/>\n" +
+  "          ${describe(param)}\n" +
+  "        </li>\n" +
+  "      </ul>\n" +
+  "    </div>\n" +
   "  </div>\n" +
   "\n" +
   "  <div if=\"${!command.exec}\">\n" +
   "    <h4 class=\"gcli-help-header\">${l10n.subCommands}:</h4>\n" +
   "\n" +
   "    <ul class=\"gcli-help-${subcommands}\">\n" +
   "      <li if=\"${subcommands.length === 0}\">${l10n.subcommandsNone}</li>\n" +
   "      <li foreach=\"subcommand in ${subcommands}\">\n" +
@@ -11637,17 +11875,16 @@ var promise = require('util/promise');
 var util = require('util/util');
 var KeyEvent = require('util/util').KeyEvent;
 
 var Status = require('gcli/types').Status;
 var History = require('gcli/history').History;
 
 var inputterCss = require('text!gcli/ui/inputter.css');
 
-
 var RESOLVED = promise.resolve(true);
 
 /**
  * A wrapper to take care of the functions concerning an input element
  * @param options Object containing user customization properties, including:
  * - scratchpad (default=none)
  * - promptWidth (default=22px)
  * @param components Object that links to other UI components. GCLI provided:
@@ -11694,29 +11931,30 @@ function Inputter(options, components) {
   // Cursor position affects hint severity
   this.onMouseUp = this.onMouseUp.bind(this);
   this.element.addEventListener('mouseup', this.onMouseUp, false);
 
   if (this.focusManager) {
     this.focusManager.addMonitoredElement(this.element, 'input');
   }
 
-  // Start looking like an asynchronous completion isn't happening
+  // Initially an asynchronous completion isn't in-progress
   this._completed = RESOLVED;
 
   this.requisition.onTextChange.add(this.textChanged, this);
 
   this.assignment = this.requisition.getAssignmentAt(0);
   this.onAssignmentChange = util.createEvent('Inputter.onAssignmentChange');
   this.onInputChange = util.createEvent('Inputter.onInputChange');
 
   this.onResize = util.createEvent('Inputter.onResize');
   this.onWindowResize = this.onWindowResize.bind(this);
   this.document.defaultView.addEventListener('resize', this.onWindowResize, false);
 
+  this._previousValue = undefined;
   this.requisition.update(this.element.value || '');
 }
 
 /**
  * Avoid memory leaks
  */
 Inputter.prototype.destroy = function() {
   this.document.defaultView.removeEventListener('resize', this.onWindowResize, false);
@@ -11925,29 +12163,41 @@ Inputter.prototype._processCaretChange =
  * selection start is only recognised when the event loop has finished
  */
 Inputter.prototype._checkAssignment = function(start) {
   if (start == null) {
     start = this.element.selectionStart;
   }
   var newAssignment = this.requisition.getAssignmentAt(start);
   if (this.assignment !== newAssignment) {
+    if (this.assignment.param.type.onLeave) {
+      this.assignment.param.type.onLeave(this.assignment);
+    }
+
     this.assignment = newAssignment;
     this.onAssignmentChange({ assignment: this.assignment });
+
+    if (this.assignment.param.type.onEnter) {
+      this.assignment.param.type.onEnter(this.assignment);
+    }
+  }
+  else {
+    if (this.assignment && this.assignment.param.type.onChange) {
+      this.assignment.param.type.onChange(this.assignment);
+    }
   }
 
   // This is slightly nasty - the focusManager generally relies on people
   // telling it what it needs to know (which makes sense because the event
   // system to do it with events would be unnecessarily complex). However
   // requisition doesn't know about the focusManager either. So either one
   // needs to know about the other, or a third-party needs to break the
   // deadlock. These 2 lines are all we're quibbling about, so for now we hack
   if (this.focusManager) {
-    var message = this.assignment.conversion.message;
-    this.focusManager.setError(message != null && message !== '');
+    this.focusManager.setError(this.assignment.message);
   }
 };
 
 /**
  * Set the input field to a value, for external use.
  * This function updates the data model. It sets the caret to the end of the
  * input. It does not make any similarity checks so calling this function with
  * it's current value resets the cursor position.
@@ -12040,139 +12290,176 @@ Inputter.prototype.handleKeyUp = functio
   }
 
   if (this.focusManager && ev.keyCode === KeyEvent.DOM_VK_ESCAPE) {
     this.focusManager.removeHelp();
     return RESOLVED;
   }
 
   if (ev.keyCode === KeyEvent.DOM_VK_UP) {
-    if (this.tooltip && this.tooltip.isMenuShowing) {
-      this.changeChoice(-1);
-    }
-    else if (this.element.value === '' || this._scrollingThroughHistory) {
-      this._scrollingThroughHistory = true;
-      return this.requisition.update(this.history.backward());
-    }
-    else {
-      // If the user is on a valid value, then we increment the value, but if
-      // they've typed something that's not right we page through predictions
-      if (this.assignment.getStatus() === Status.VALID) {
-        this.requisition.increment(this.assignment);
-        // See notes on focusManager.onInputChange in onKeyDown
-        if (this.focusManager) {
-          this.focusManager.onInputChange();
-        }
-      }
-      else {
-        this.changeChoice(-1);
-      }
-    }
-    return RESOLVED;
+    return this._handleUpArrow();
   }
 
   if (ev.keyCode === KeyEvent.DOM_VK_DOWN) {
-    if (this.tooltip && this.tooltip.isMenuShowing) {
-      this.changeChoice(+1);
-    }
-    else if (this.element.value === '' || this._scrollingThroughHistory) {
-      this._scrollingThroughHistory = true;
-      return this.requisition.update(this.history.forward());
-    }
-    else {
-      // See notes above for the UP key
-      if (this.assignment.getStatus() === Status.VALID) {
-        this.requisition.decrement(this.assignment,
-                                   this.requisition.executionContext);
-        // See notes on focusManager.onInputChange in onKeyDown
-        if (this.focusManager) {
-          this.focusManager.onInputChange();
-        }
-      }
-      else {
-        this.changeChoice(+1);
-      }
-    }
-    return RESOLVED;
-  }
-
-  // RETURN checks status and might exec
+    return this._handleDownArrow();
+  }
+
   if (ev.keyCode === KeyEvent.DOM_VK_RETURN) {
-    var worst = this.requisition.getStatus();
-    // Deny RETURN unless the command might work
-    if (worst === Status.VALID) {
-      this._scrollingThroughHistory = false;
-      this.history.add(this.element.value);
-      this.requisition.exec();
-    }
-    else {
-      // If we can't execute the command, but there is a menu choice to use
-      // then use it.
-      if (!this.tooltip.selectChoice()) {
-        this.focusManager.setError(true);
-      }
-    }
-
-    this._choice = null;
-    return RESOLVED;
+    return this._handleReturn();
   }
 
   if (ev.keyCode === KeyEvent.DOM_VK_TAB && !ev.shiftKey) {
-    // Being able to complete 'nothing' is OK if there is some context, but
-    // when there is nothing on the command line it just looks bizarre.
-    var hasContents = (this.element.value.length > 0);
-
-    // If the TAB keypress took the cursor from another field to this one,
-    // then they get the keydown/keypress, and we get the keyup. In this
-    // case we don't want to do any completion.
-    // If the time of the keydown/keypress of TAB was close (i.e. within
-    // 1 second) to the time of the keyup then we assume that we got them
-    // both, and do the completion.
-    if (hasContents && this.lastTabDownAt + 1000 > ev.timeStamp) {
-      // It's possible for TAB to not change the input, in which case the
-      // textChanged event will not fire, and the caret move will not be
-      // processed. So we check that this is done first
-      this._caretChange = Caret.TO_ARG_END;
-      var inputState = this.getInputState();
-      this._processCaretChange(inputState);
-
-      if (this._choice == null) {
-        this._choice = 0;
-      }
-
-      // The changes made by complete may happen asynchronously, so after the
-      // the call to complete() we should avoid making changes before the end
-      // of the event loop
-      this._completed = this.requisition.complete(inputState.cursor,
-                                                  this._choice);
-    }
-    this.lastTabDownAt = 0;
-    this._scrollingThroughHistory = false;
-
-    return this._completed.then(function(updated) {
-      // Abort UI changes if this UI update has been overtaken
-      if (updated) {
-        this._choice = null;
-        this.onChoiceChange({ choice: this._choice });
-      }
-    }.bind(this));
+    return this._handleTab(ev);
   }
 
   // Give the scratchpad (if enabled) a chance to activate
   if (this.scratchpad && this.scratchpad.shouldActivate(ev)) {
     if (this.scratchpad.activate(this.element.value)) {
       return this.requisition.update('');
     }
     return RESOLVED;
   }
 
+  if (this._previousValue === this.element.value) {
+    return RESOLVED;
+  }
+
   this._scrollingThroughHistory = false;
   this._caretChange = Caret.NO_CHANGE;
 
   this._completed = this.requisition.update(this.element.value);
+  this._previousValue = this.element.value;
+
+  return this._completed.then(function(updated) {
+    // Abort UI changes if this UI update has been overtaken
+    if (updated) {
+      this._choice = null;
+      this.onChoiceChange({ choice: this._choice });
+    }
+  }.bind(this));
+};
+
+/**
+ * See also _handleDownArrow for some symmetry
+ */
+Inputter.prototype._handleUpArrow = function() {
+  if (this.tooltip && this.tooltip.isMenuShowing) {
+    this.changeChoice(-1);
+    return RESOLVED;
+  }
+
+  if (this.element.value === '' || this._scrollingThroughHistory) {
+    this._scrollingThroughHistory = true;
+    return this.requisition.update(this.history.backward());
+  }
+
+  // If the user is on a valid value, then we increment the value, but if
+  // they've typed something that's not right we page through predictions
+  if (this.assignment.getStatus() === Status.VALID) {
+    this.requisition.increment(this.assignment);
+    // See notes on focusManager.onInputChange in onKeyDown
+    if (this.focusManager) {
+      this.focusManager.onInputChange();
+    }
+  }
+  else {
+    this.changeChoice(-1);
+  }
+
+  return RESOLVED;
+};
+
+/**
+ * See also _handleUpArrow for some symmetry
+ */
+Inputter.prototype._handleDownArrow = function() {
+  if (this.tooltip && this.tooltip.isMenuShowing) {
+    this.changeChoice(+1);
+    return RESOLVED;
+  }
+
+  if (this.element.value === '' || this._scrollingThroughHistory) {
+    this._scrollingThroughHistory = true;
+    return this.requisition.update(this.history.forward());
+  }
+
+  // See notes above for the UP key
+  if (this.assignment.getStatus() === Status.VALID) {
+    this.requisition.decrement(this.assignment,
+                               this.requisition.executionContext);
+    // See notes on focusManager.onInputChange in onKeyDown
+    if (this.focusManager) {
+      this.focusManager.onInputChange();
+    }
+  }
+  else {
+    this.changeChoice(+1);
+  }
+
+  return RESOLVED;
+};
+
+/**
+ * RETURN checks status and might exec
+ */
+Inputter.prototype._handleReturn = function() {
+  // Deny RETURN unless the command might work
+  if (this.requisition.status === Status.VALID) {
+    this._scrollingThroughHistory = false;
+    this.history.add(this.element.value);
+    this.requisition.exec();
+  }
+  else {
+    // If we can't execute the command, but there is a menu choice to use
+    // then use it.
+    if (!this.tooltip.selectChoice()) {
+      this.focusManager.setError(true);
+    }
+  }
+
+  this._choice = null;
+  return RESOLVED;
+};
+
+/**
+ * Warning: We get TAB events for more than just the user pressing TAB in our
+ * input element.
+ */
+Inputter.prototype._handleTab = function(ev) {
+  // Being able to complete 'nothing' is OK if there is some context, but
+  // when there is nothing on the command line it just looks bizarre.
+  var hasContents = (this.element.value.length > 0);
+
+  // If the TAB keypress took the cursor from another field to this one,
+  // then they get the keydown/keypress, and we get the keyup. In this
+  // case we don't want to do any completion.
+  // If the time of the keydown/keypress of TAB was close (i.e. within
+  // 1 second) to the time of the keyup then we assume that we got them
+  // both, and do the completion.
+  if (hasContents && this.lastTabDownAt + 1000 > ev.timeStamp) {
+    // It's possible for TAB to not change the input, in which case the
+    // textChanged event will not fire, and the caret move will not be
+    // processed. So we check that this is done first
+    this._caretChange = Caret.TO_ARG_END;
+    var inputState = this.getInputState();
+    this._processCaretChange(inputState);
+
+    if (this._choice == null) {
+      this._choice = 0;
+    }
+
+    // The changes made by complete may happen asynchronously, so after the
+    // the call to complete() we should avoid making changes before the end
+    // of the event loop
+    this._completed = this.requisition.complete(inputState.cursor,
+                                                this._choice);
+    this._previousValue = this.element.value;
+  }
+  this.lastTabDownAt = 0;
+  this._scrollingThroughHistory = false;
 
   return this._completed.then(function(updated) {
     // Abort UI changes if this UI update has been overtaken
     if (updated) {
       this._choice = null;
       this.onChoiceChange({ choice: this._choice });
     }
   }.bind(this));
@@ -12434,17 +12721,17 @@ Completer.prototype._getCompleterTemplat
   // Some of the data created by this function can be calculated synchronously
   // but other parts depend on predictions which are asynchronous.
   var promisedDirectTabText = promise.defer();
   var promisedArrowTabText = promise.defer();
   var promisedEmptyParameters = promise.defer();
 
   var input = this.inputter.getInputState();
   var current = this.requisition.getAssignmentAt(input.cursor.start);
-  var predictionPromise = undefined;
+  var predictionPromise;
 
   if (input.typed.trim().length !== 0) {
     predictionPromise = current.getPredictionAt(this.choice);
   }
 
   // If anything goes wrong, we pass the error on to all the child promises
   var onError = function(ex) {
     promisedDirectTabText.reject(ex);
@@ -12546,17 +12833,17 @@ Completer.prototype._getCompleterTemplat
     var addOptionsMarker = false;
 
     // We add an '[options]' marker when there are named parameters that are
     // not filled in and not hidden, and we don't have any directTabText
     if (command && command.hasNamedParameters) {
       command.params.forEach(function(param) {
         var arg = this.requisition.getAssignment(param.name).arg;
         if (!param.isPositionalAllowed && !param.hidden
-                && arg.type === "BlankArgument") {
+                && arg.type === 'BlankArgument') {
           addOptionsMarker = true;
         }
       }, this);
     }
 
     if (addOptionsMarker) {
       // Add an nbsp if we don't have one at the end of the input or if
       // this isn't the first param we've mentioned
@@ -12701,42 +12988,50 @@ function Tooltip(options, components) {
     this.style = util.importCss(tooltipCss, this.document, 'gcli-tooltip');
   }
 
   this.template = util.toDom(this.document, tooltipHtml);
   this.templateOptions = { blankNullUndefined: true, stack: 'tooltip.html' };
 
   this.inputter.onChoiceChange.add(this.choiceChanged, this);
   this.inputter.onAssignmentChange.add(this.assignmentChanged, this);
+  this.requisition.onTextChange.add(this.textChanged, this);
 
   // We keep a track of which assignment the cursor is in
   this.assignment = undefined;
   this.assignmentChanged({ assignment: this.inputter.assignment });
+
+  // We also keep track of the last known arg text for the current assignment
+  this.lastText = undefined;
 }
 
 /**
  * Avoid memory leaks
  */
 Tooltip.prototype.destroy = function() {
   this.inputter.onAssignmentChange.remove(this.assignmentChanged, this);
   this.inputter.onChoiceChange.remove(this.choiceChanged, this);
+  this.requisition.onTextChange.remove(this.textChanged, this);
 
   if (this.panelElement) {
     this.focusManager.onVisibilityChange.remove(this.visibilityChanged, this);
   }
   this.focusManager.removeMonitoredElement(this.element, 'tooltip');
 
   if (this.style) {
     this.style.parentNode.removeChild(this.style);
     delete this.style;
   }
 
   this.field.onFieldChange.remove(this.fieldChanged, this);
   this.field.destroy();
 
+  delete this.lastText;
+  delete this.assignment;
+
   delete this.errorEle;
   delete this.descriptionEle;
   delete this.highlightEle;
 
   delete this.document;
   delete this.element;
   delete this.panelElement;
   delete this.template;
@@ -12760,20 +13055,18 @@ Object.defineProperty(Tooltip.prototype,
 Tooltip.prototype.assignmentChanged = function(ev) {
   // This can be kicked off either by requisition doing an assign or by
   // inputter noticing a cursor movement out of a command, so we should check
   // that this really is a new assignment
   if (this.assignment === ev.assignment) {
     return;
   }
 
-  if (this.assignment) {
-    this.assignment.onAssignmentChange.remove(this.assignmentContentsChanged, this);
-  }
   this.assignment = ev.assignment;
+  this.lastText = this.assignment.arg.text;
 
   if (this.field) {
     this.field.onFieldChange.remove(this.fieldChanged, this);
     this.field.destroy();
   }
 
   this.field = fields.getField(this.assignment.param.type, {
     document: this.document,
@@ -12782,18 +13075,16 @@ Tooltip.prototype.assignmentChanged = fu
     required: this.assignment.param.isDataRequired,
     named: !this.assignment.param.isPositionalAllowed,
     tooltip: true
   });
 
   this.focusManager.setImportantFieldFlag(this.field.isImportant);
 
   this.field.onFieldChange.add(this.fieldChanged, this);
-  this.assignment.onAssignmentChange.add(this.assignmentContentsChanged, this);
-
   this.field.setConversion(this.assignment.conversion);
 
   // Filled in by the template process
   this.errorEle = undefined;
   this.descriptionEle = undefined;
   this.highlightEle = undefined;
 
   var contents = this.template.cloneNode(true);
@@ -12845,27 +13136,29 @@ Tooltip.prototype.fieldChanged = functio
   // get it's calculations wrong. We need to wait until the current set of
   // changes has had a chance to propagate
   this.document.defaultView.setTimeout(function() {
     this.inputter.focus();
   }.bind(this), 10);
 };
 
 /**
- * Called by the onAssignmentChange event on the current Assignment
- */
-Tooltip.prototype.assignmentContentsChanged = function(ev) {
-  // Assignments fire AssignmentChange events on any change, including minor
+ * Called by the onTextChanged event on the Requisition
+ */
+Tooltip.prototype.textChanged = function() {
+  // Requisition fires onTextChanged events on any change, including minor
   // things like whitespace change in arg prefix, so we ignore anything but
   // an actual value change.
-  if (ev.conversion.arg.text === ev.oldConversion.arg.text) {
+  if (this.assignment.arg.text === this.lastText) {
     return;
   }
 
-  this.field.setConversion(ev.conversion);
+  this.lastText = this.assignment.arg.text;
+
+  this.field.setConversion(this.assignment.conversion);
   util.setTextContent(this.descriptionEle, this.description);
 
   this._updatePosition();
 };
 
 /**
  * Called to move the tooltip to the correct horizontal position
  */
