exporting patch:
# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1399901734 18000
#      Mon May 12 08:35:34 2014 -0500
# Node ID c4f1bbb132c019424341a790042b5a7b820d04e1
# Parent  f64790d37d51f149f27a1e51df16dfb2a789f418
Bug 892935 - [markup view] if the content of a node is only text, we should expand the ellipsis;r=pbrosset

diff --git a/browser/devtools/markupview/markup-view.css b/browser/devtools/markupview/markup-view.css
--- a/browser/devtools/markupview/markup-view.css
+++ b/browser/devtools/markupview/markup-view.css
@@ -21,16 +21,20 @@ body.dragging .tag-line {
 
 #root-wrapper:after {
    content: "";
    display: block;
    clear: both;
    position:relative;
 }
 
+.editor.text {
+  display: inline-block;
+}
+
 .html-editor {
   display: none;
   position: absolute;
   z-index: 2;
 
   /* Use the same margin/padding trick used by .child tags to ensure that
    * the editor covers up any content to the left (including expander arrows
    * and hover effects). */
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -870,17 +870,17 @@ MarkupView.prototype = {
    * Expand the container's children.
    */
   _expandContainer: function(aContainer) {
     return this._updateChildren(aContainer, {expand: true}).then(() => {
       if (this._destroyer) {
         console.warn("Could not expand the node, the markup-view was destroyed");
         return;
       }
-      aContainer.expanded = true;
+      aContainer.setExpanded(true);
     });
   },
 
   /**
    * Expand the node's children.
    */
   expandNode: function(aNode) {
     let container = this.getContainer(aNode);
@@ -915,17 +915,17 @@ MarkupView.prototype = {
     return this._expandAll(this.getContainer(aNode));
   },
 
   /**
    * Collapse the node's children.
    */
   collapseNode: function(aNode) {
     let container = this.getContainer(aNode);
-    container.expanded = false;
+    container.setExpanded(false);
   },
 
   /**
    * Returns either the innerHTML or the outerHTML for a remote node.
    * @param aNode The NodeFront to get the outerHTML / innerHTML for.
    * @param isOuter A boolean that, if true, makes the function return the
    *                outerHTML, otherwise the innerHTML.
    * @returns A promise that will be resolved with the outerHTML / innerHTML.
@@ -1277,16 +1277,42 @@ MarkupView.prototype = {
     if (!aContainer.hasChildren) {
       while (aContainer.children.firstChild) {
         aContainer.children.removeChild(aContainer.children.firstChild);
       }
       aContainer.childrenDirty = false;
       return promise.resolve(aContainer);
     }
 
+    if (aContainer.singleTextChild
+        && aContainer.singleTextChild != aContainer.node.singleTextChild) {
+
+      // This container was doing double duty as a container for a single
+      // text child, back that out.
+      this._containers.delete(aContainer.singleTextChild);
+      aContainer.clearSingleTextChild();
+
+      aContainer.setExpanded(true);
+    }
+
+    if (aContainer.node.singleTextChild) {
+      aContainer.setExpanded(false);
+      // this container will do double duty as the container for the single
+      // text child.
+      while (aContainer.children.firstChild) {
+        aContainer.children.removeChild(aContainer.children.firstChild);
+      }
+
+      aContainer.setSingleTextChild(aContainer.node.singleTextChild);
+
+      this._containers.set(aContainer.node.singleTextChild, aContainer);
+      aContainer.childrenDirty = false;
+      return promise.resolve(aContainer);
+    }
+
     // If we're not expanded (or asked to update anyway), we're done for
     // now.  Note that this will leave the childrenDirty flag set, so when
     // expanded we'll refresh the child list.
     if (!(aContainer.expanded || expand)) {
       return promise.resolve(aContainer);
     }
 
     // We're going to issue a children request, make sure it includes the
@@ -1356,16 +1382,21 @@ MarkupView.prototype = {
     }
     return promise.all([updatePromise for (updatePromise of this._queuedChildUpdates.values())]);
   },
 
   /**
    * Return a list of the children to display for this container.
    */
   _getVisibleChildren: function(aContainer, aCentered) {
+    // If the backend has told us that there's only one child, just use that child.
+    if (aContainer.node.singleTextChild) {
+      return promise.resolve({ hasFirst: true, hasLast: true, nodes: [aContainer.node.singleTextChild]});
+    }
+
     let maxChildren = aContainer.maxChildren || this.maxChildren;
     if (maxChildren == -1) {
       maxChildren = undefined;
     }
 
     return this.walker.children(aContainer.node, {
       maxNodes: maxChildren,
       center: aCentered
@@ -1710,21 +1741,32 @@ MarkupContainer.prototype = {
   _hasChildren: false,
 
   get hasChildren() {
     return this._hasChildren;
   },
 
   set hasChildren(aValue) {
     this._hasChildren = aValue;
+    this.updateExpander();
+  },
+
+  /**
+   * True if the current node can be expanded.
+   */
+  get canExpand() {
+    return this._hasChildren && !this.node.singleTextChild;
+  },
+
+  updateExpander: function() {
     if (!this.expander) {
       return;
     }
 
-    if (aValue) {
+    if (this.canExpand) {
       this.expander.style.visibility = "visible";
     } else {
       this.expander.style.visibility = "hidden";
     }
   },
 
   /**
    * If the node has children, return the list of containers for all these
@@ -1740,21 +1782,25 @@ MarkupContainer.prototype = {
 
   /**
    * True if the node has been visually expanded in the tree.
    */
   get expanded() {
     return !this.elt.classList.contains("collapsed");
   },
 
-  set expanded(aValue) {
+  setExpanded: function(aValue) {
     if (!this.expander) {
       return;
     }
 
+    if (!this.canExpand) {
+      aValue = false;
+    }
+
     if (aValue && this.elt.classList.contains("collapsed")) {
       // Expanding a node means cloning its "inline" closing tag into a new
       // tag-line that the user can interact with and showing the children.
       let closingTag = this.elt.querySelector(".close");
       if (closingTag) {
         if (!this.closeTagLine) {
           let line = this.markup.doc.createElement("div");
           line.classList.add("tag-line");
@@ -1949,16 +1995,17 @@ MarkupContainer.prototype = {
   get selected() {
     return this._selected;
   },
 
   set selected(aValue) {
     this.tagState.classList.remove("flash-out");
     this._selected = aValue;
     this.editor.selected = aValue;
+
     if (this._selected) {
       this.tagLine.setAttribute("selected", "");
       this.tagState.classList.add("theme-selected");
     } else {
       this.tagLine.removeAttribute("selected");
       this.tagState.classList.remove("theme-selected");
     }
   },
@@ -2177,16 +2224,26 @@ MarkupElementContainer.prototype = Herit
   copyImageDataUri: function() {
     // We need to send again a request to gettooltipData even if one was sent for
     // the tooltip, because we want the full-size image
     this.node.getImageData().then(data => {
       data.data.string().then(str => {
         clipboardHelper.copyString(str, this.markup.doc);
       });
     });
+  },
+
+  setSingleTextChild: function(singleTextChild) {
+    this.singleTextChild = singleTextChild;
+    this.editor.updateTextEditor();
+  },
+
+  clearSingleTextChild: function() {
+    this.singleTextChild = undefined;
+    this.editor.updateTextEditor();
   }
 });
 
 /**
  * Dummy container node used for the root document element.
  */
 function RootContainer(aMarkupView, aNode) {
   this.doc = aMarkupView.doc;
@@ -2204,17 +2261,19 @@ RootContainer.prototype = {
   destroy: function() {},
 
   /**
    * If the node has children, return the list of containers for all these
    * children.
    */
   getChildContainers: function() {
     return [...this.children.children].map(node => node.container);
-  }
+  },
+
+  setExpanded: function(aValue) {}
 };
 
 /**
  * Creates an editor for non-editable nodes.
  */
 function GenericEditor(aContainer, aNode) {
   this.container = aContainer;
   this.markup = this.container.markup;
@@ -2396,16 +2455,23 @@ function ElementEditor(aContainer, aNode
   this.eventNode.style.display = this.node.hasEventListeners ? "inline-block" : "none";
 
   this.update();
   this.initialized = true;
 }
 
 ElementEditor.prototype = {
 
+  set selected(aValue) {
+    console.log("SETTING SEELECTED", aValue, this.textEditor);
+    if (this.textEditor) {
+      this.textEditor.selected = aValue;
+    }
+  },
+
   flashAttribute: function(attrName) {
     if (this.animationTimers[attrName]) {
       clearTimeout(this.animationTimers[attrName]);
     }
 
     flashElementOn(this.getAttributeElement(attrName));
 
     this.animationTimers[attrName] = setTimeout(() => {
@@ -2448,16 +2514,45 @@ ElementEditor.prototype = {
         // Temporarily flash the attribute to highlight the change.
         // But not if this is the first time the editor instance has
         // been created.
         if (this.initialized) {
           this.flashAttribute(attr.name);
         }
       }
     }
+
+    this.updateTextEditor();
+  },
+
+  /**
+   * Update the inline text editor in case of a single text child node.
+   * This ends up with two editors (one in the parent container and one in the
+   * node's container), but that lets us keep the "container per node"
+   * assumptions everywhere.
+   */
+  updateTextEditor: function() {
+    let node = this.node.singleTextChild;
+
+    if (this.textEditor && this.textEditor.node != node) {
+      this.elt.removeChild(this.textEditor.elt);
+      this.textEditor = null;
+    }
+
+    if (node && !this.textEditor) {
+      // Create a text editor added to this editor.
+      // This editor won't receive an update automatically, so we rely on
+      // child text editors to let us know that we need updating.
+      this.textEditor = new TextEditor(this.container, node, "text");
+      this.elt.insertBefore(this.textEditor.elt, this.elt.firstChild.nextSibling.nextSibling);
+    }
+console.log("Setting text editor", this.textEditor, node);
+    if (this.textEditor) {
+      this.textEditor.update();
+    }
   },
 
   _startModifyingAttributes: function() {
     return this.node.startModifyingAttributes();
   },
 
   /**
    * Get the element used for one of the attributes of this element
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -223,24 +223,31 @@ var NodeActor = exports.NodeActor = prot
   // Returns the JSON representation of this object over the wire.
   form: function(detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
 
+    let singleTextChild = undefined;
+
+    if (this.rawNode.childNodes.length == 1 && this.rawNode.childNodes[0].nodeType === Ci.nsIDOMNode.TEXT_NODE) {
+      singleTextChild = this.walker._ref(this.rawNode.childNodes[0]);
+    }
+
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
       numChildren: this.numChildren,
+      singleTextChild: singleTextChild ? singleTextChild.form() : undefined,
 
       // doctype attributes
       name: this.rawNode.name,
       publicId: this.rawNode.publicId,
       systemId: this.rawNode.systemId,
 
       attrs: this.writeAttrs(),
       isBeforePseudoElement: this.isBeforePseudoElement,
@@ -748,16 +755,22 @@ let NodeFront = protocol.FrontClass(Node
 
     if (form.parent) {
       // Get the owner actor for this actor (the walker), and find the
       // parent node of this actor from it, creating a standin node if
       // necessary.
       let parentNodeFront = ctx.marshallPool().ensureParentFront(form.parent);
       this.reparent(parentNodeFront);
     }
+
+    if (form.singleTextChild) {
+      this.singleTextChild = types.getType("domnode").read(form.singleTextChild, ctx);
+    } else {
+      this.singleTextChild = undefined;
+    }
   },
 
   /**
    * Returns the parent NodeFront for this NodeFront.
    */
   parentNode: function() {
     return this._parent;
   },
@@ -2565,16 +2578,18 @@ var WalkerActor = protocol.ActorClass({
    * `childList` type is returned when the set of children for a node
    * has changed.  Includes extra data, which can be used by the client to
    * maintain its ownership subtree.
    *
    *   added: array of <domnode actor ID> - The list of actors *previously
    *     seen by the client* that were added to the target node.
    *   removed: array of <domnode actor ID> The list of actors *previously
    *     seen by the client* that were removed from the target node.
+   *   singleTextChild: If the node now has a single text child, it will
+   *     be sent here.
    *
    * Actors that are included in a MutationRecord's `removed` but
    * not in an `added` have been removed from the client's ownership
    * tree (either by being moved under a node the client has seen yet
    * or by being removed from the tree entirely), and is considered
    * 'orphaned'.
    *
    * Keep in mind that if a node that the client hasn't seen is moved
@@ -2703,16 +2718,21 @@ var WalkerActor = protocol.ActorClass({
           // it and let the client know so that its ownership tree is up
           // to date.
           this._orphaned.delete(addedActor);
           addedActors.push(addedActor.actorID);
         }
 
         mutation.removed = removedActors;
         mutation.added = addedActors;
+
+        if (change.target.childNodes.length == 1 && change.target.childNodes[0].nodeType === Ci.nsIDOMNode.TEXT_NODE) {
+          mutation.singleTextChild = this._ref(change.target.childNodes[0]).form();
+        }
+
       }
       this.queueMutation(mutation);
     }
   },
 
   onFrameLoad: function({ window, isTopLevel }) {
     if (!this.rootDoc && isTopLevel) {
       this.rootDoc = window.document;
@@ -3195,16 +3215,23 @@ var WalkerFront = exports.WalkerFront = 
             }
             addedFront.reparent(targetFront)
 
             // The actor is reconnected to the ownership tree, unorphan
             // it.
             this._orphaned.delete(addedFront);
             addedFronts.push(addedFront);
           }
+
+          if (change.singleTextChild) {
+            targetFront.singleTextChild = types.getType("domnode").read(change.singleTextChild, this);
+          } else {
+            targetFront.singleTextChild = undefined;
+          }
+
           // Before passing to users, replace the added and removed actor
           // ids with front in the mutation record.
           emittedMutation.added = addedFronts;
           emittedMutation.removed = removedFronts;
 
           // If this is coming from a DOM mutation, the actor's numChildren
           // was passed in. Otherwise, it is simulated from a frame load or
           // unload, so don't change the front's form.
