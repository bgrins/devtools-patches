# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  da66c4a05fda49d457d9411a7092fed87cf9e53a

diff --git a/devtools/client/webconsole/new-console-output/components/console-output.js b/devtools/client/webconsole/new-console-output/components/console-output.js
--- a/devtools/client/webconsole/new-console-output/components/console-output.js
+++ b/devtools/client/webconsole/new-console-output/components/console-output.js
@@ -15,16 +15,49 @@ const {
   getAllMessagesUiById,
   getAllMessagesTableDataById,
   getAllNetworkMessagesUpdateById,
   getVisibleMessages,
   getAllRepeatById,
 } = require("devtools/client/webconsole/new-console-output/selectors/messages");
 const MessageContainer = createFactory(require("devtools/client/webconsole/new-console-output/components/message-container").MessageContainer);
 
+function calculateMessageNodes(component, props) {
+  let {
+    dispatch,
+    visibleMessages,
+    messagesUi,
+    messagesTableData,
+    messagesRepeat,
+    networkMessagesUpdate,
+    serviceContainer,
+    timestampsVisible,
+  } = (props || component.props);
+
+  let messageNodes = visibleMessages.map((message) => {
+    return (
+      MessageContainer({
+        dispatch,
+        message,
+        key: message.id,
+        serviceContainer,
+        open: messagesUi.includes(message.id),
+        tableData: messagesTableData.get(message.id),
+        indent: message.indent,
+        timestampsVisible,
+        repeat: messagesRepeat[message.id],
+        networkMessageUpdate: networkMessagesUpdate[message.id],
+      })
+    );
+  });
+  component.setState({
+    messages: messageNodes,
+  });
+}
+
 const ConsoleOutput = createClass({
 
   displayName: "ConsoleOutput",
 
   propTypes: {
     messagesUi: PropTypes.object.isRequired,
     serviceContainer: PropTypes.shape({
       attachRefToHud: PropTypes.func.isRequired,
@@ -34,23 +67,31 @@ const ConsoleOutput = createClass({
     dispatch: PropTypes.func.isRequired,
     timestampsVisible: PropTypes.bool,
     messagesTableData: PropTypes.object.isRequired,
     messagesRepeat: PropTypes.object.isRequired,
     networkMessagesUpdate: PropTypes.object.isRequired,
     visibleMessages: PropTypes.array.isRequired,
   },
 
+  getInitialState() {
+    return {
+      messages: []
+    }
+  },
+
   componentDidMount() {
     // Do the scrolling in the nextTick since this could hit console startup performances.
     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1355869
     setTimeout(() => {
       scrollToBottom(this.outputNode);
     }, 0);
     this.props.serviceContainer.attachRefToHud("outputScroller", this.outputNode);
+
+    calculateMessageNodes(this);
   },
 
   componentWillUpdate(nextProps, nextState) {
     const outputNode = this.outputNode;
     if (!outputNode || !outputNode.lastChild) {
       return;
     }
 
@@ -62,64 +103,68 @@ const ConsoleOutput = createClass({
   },
 
   componentDidUpdate() {
     if (this.shouldScrollBottom) {
       scrollToBottom(this.outputNode);
     }
   },
 
+  componentWillReceiveProps(nextProps) {
+    console.log("componentWillReceiveProps", nextProps);
+    calculateMessageNodes(this, nextProps);
+  },
+
   onContextMenu(e) {
     this.props.serviceContainer.openContextMenu(e);
     e.stopPropagation();
     e.preventDefault();
   },
 
   render() {
-    let {
-      dispatch,
-      visibleMessages,
-      messagesUi,
-      messagesTableData,
-      messagesRepeat,
-      networkMessagesUpdate,
-      serviceContainer,
-      timestampsVisible,
-    } = this.props;
-
-    let messageNodes = visibleMessages.map((message) => {
-      return (
-        MessageContainer({
-          dispatch,
-          message,
-          key: message.id,
-          serviceContainer,
-          open: messagesUi.includes(message.id),
-          tableData: messagesTableData.get(message.id),
-          indent: message.indent,
-          timestampsVisible,
-          repeat: messagesRepeat[message.id],
-          networkMessageUpdate: networkMessagesUpdate[message.id],
-        })
-      );
-    });
-
     return (
       dom.div({
         className: "webconsole-output",
         onContextMenu: this.onContextMenu,
         ref: node => {
           this.outputNode = node;
         },
-      }, messageNodes
+      }, this.state.messages
       )
     );
   }
 });
 
+
+const itemsToRender = [];
+let raf = null;
+let FRAME_BUDGET = 10;
+function scheduleRender() {
+    if (raf) {
+      return;
+    }
+    raf = requestAnimationFrame(() => {
+      const start = Date.now();
+      while (Date.now() - start < FRAME_BUDGET && itemsToRender.length !== 0) {
+        const item = itemsToRender.shift();
+        if (item.div && item.div.parentNode) {
+          let MessageComponent = getMessageComponent(item.props.message);
+          ReactDOM.render(MessageComponent(item.props), item.div);
+        } else {
+          console.log("Forget it", item.key1);
+        }
+      }
+      raf = null;
+      if (itemsToRender.length > 0) {
+        console.log("Carrying over",itemsToRender.length )
+        scheduleRender();
+      }
+    });
+}
+
 function scrollToBottom(node) {
   node.scrollTop = node.scrollHeight;
 }
 
 function isScrolledToBottom(outputNode, scrollNode) {
   let lastNodeHeight = outputNode.lastChild ?
                        outputNode.lastChild.clientHeight : 0;
   return scrollNode.scrollTop + scrollNode.clientHeight >=
