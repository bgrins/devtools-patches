# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  71353523aa4182253cc9a74be24d777d5ad8029f
more console debugging

diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -1002,17 +1002,17 @@ Toolbox.prototype = {
 
         // Make sure to decorate panel object with event API also in case
         // where the tool definition 'build' method returns only a promise
         // and the actual panel instance is available as soon as the
         // promise is resolved.
         if (typeof panel.emit == "undefined") {
           EventEmitter.decorate(panel);
         }
-
+console.log("emitting " + id + "-ready");
         gDevTools.emit(id + "-ready", this, panel);
         this.emit(id + "-ready", panel);
 
         deferred.resolve(panel);
       }, console.error);
     };
 
     iframe.setAttribute("src", definition.url);
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -445,20 +445,45 @@ WebConsoleFrame.prototype = {
 
   /**
    * Initialize the WebConsoleFrame instance.
    * @return object
    *         A promise object that resolves once the frame is ready to use.
    */
   init: function()
   {
+    let notifyObservers = () => {
+      let id = WebConsoleUtils.supportsString(this.hudId);
+      Services.obs.notifyObservers(id, "web-console-created", null);
+      console.log("Sent notification");
+    };
+
+let deferred = promise.defer();
+console.log("DEFEEDDDREE???", deferred, deferred.promise);
     return promise.all([
       this._initUI(),
+      deferred.promise,
       this._initConnection()
-    ]);
+    ]).then(notifyObservers, reason => {
+      // In case either initialization failed, we still want to notify
+      notifyObservers();
+      // return promise.reject(reason);
+    });
+
+    // let uiInited = this._initUI().catch();
+    // let connectionInited = this._initConnection();
+
+    // return uiInited.then(() => {
+    //   return connectionInited.then()
+    // })
+    // this.initUI.catch(null)
+
+    // return new promise((resolve, reject) => {
+    //   this.uiInited.then()
+    // });
   },
 
   /**
    * Connect to the server using the remote debugging protocol.
    *
    * @private
    * @return object
    *         A promise object that is resolved/reject based on the connection
@@ -469,25 +494,23 @@ WebConsoleFrame.prototype = {
     if (this._initDefer) {
       return this._initDefer.promise;
     }
 
     this._initDefer = promise.defer();
     this.proxy = new WebConsoleConnectionProxy(this, this.owner.target);
 
     this.proxy.connect().then(() => { // on success
+      // this._initDefer.reject({foo: "brian"});
       this._initDefer.resolve(this);
     }, (aReason) => { // on failure
       let node = this.createMessageNode(CATEGORY_JS, SEVERITY_ERROR,
                                         aReason.error + ": " + aReason.message);
       this.outputMessage(CATEGORY_JS, node, [aReason]);
       this._initDefer.reject(aReason);
-    }).then(() => {
-      let id = WebConsoleUtils.supportsString(this.hudId);
-      Services.obs.notifyObservers(id, "web-console-created", null);
     });
 
     return this._initDefer.promise;
   },
 
   /**
    * Find the Web Console UI elements and setup event listeners as needed.
    * @private
