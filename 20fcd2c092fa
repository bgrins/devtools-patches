
# HG changeset patch
# User Nick Alexander <nalexander@mozilla.com>
# Date 1501126449 25200
# Node ID 20fcd2c092fa4bf7c92192c37aa526701d977a08
# Parent  f44052f48d62dc1c7f869a6cc564d761bb2b15af
Bug 1384241 - Part 1: Add |mach watch|: pywatchman based incremental |mach build faster| shell. r=gps

There's a natural follow-on that I haven't time to explore right now:
I want the faster make backend to also write a "unified chrome
manifest" that maps outputs
(browser/chrome/browser/content/browser/ext-utils.js) to chrome:// or
resource:// URLs (chrome://content/browser/ext-utils.js or similar).

MozReview-Commit-ID: LDQmm8KD57I

diff --git a/python/mozbuild/mozbuild/backend/fastermake.py b/python/mozbuild/mozbuild/backend/fastermake.py
--- a/python/mozbuild/mozbuild/backend/fastermake.py
+++ b/python/mozbuild/mozbuild/backend/fastermake.py
@@ -148,18 +148,29 @@
 
         # Add dependencies we infered:
         for target, deps in self._dependencies.iteritems():
             mk.create_rule([target]).add_dependencies(
                 '$(TOPOBJDIR)/%s' % d for d in deps)
 
         mk.add_statement('include $(TOPSRCDIR)/config/faster/rules.mk')
 
+        unified_manifest = InstallManifest()
         for base, install_manifest in self._install_manifests.iteritems():
+            if base.startswith('dist/bin'):
+                unified_manifest.add_entries_from(install_manifest,
+                                                  base=mozpath.relpath(base, 'dist/bin'))
+
             with self._write_file(
                     mozpath.join(self.environment.topobjdir, 'faster',
                                  'install_%s' % base.replace('/', '_'))) as fh:
                 install_manifest.write(fileobj=fh)
 
+        # Write a single unified manifest for consumption by |mach watch|.
+        with self._write_file(
+                mozpath.join(self.environment.topobjdir, 'faster',
+                             'unified_install_dist_bin')) as fh:
+            unified_manifest.write(fileobj=fh)
+
         with self._write_file(
                 mozpath.join(self.environment.topobjdir, 'faster',
                              'Makefile')) as fh:
             mk.dump(fh, removal_guard=False)
diff --git a/python/mozbuild/mozbuild/faster_daemon.py b/python/mozbuild/mozbuild/faster_daemon.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/faster_daemon.py
@@ -0,0 +1,258 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+'''
+Use pywatchman to watch source directories and perform partial |mach
+build faster| builds.
+'''
+
+from __future__ import absolute_import, print_function, unicode_literals
+
+import datetime
+import os
+import sys
+import time
+
+import mozbuild.util
+import mozpack.path as mozpath
+from mozpack.manifests import (
+    InstallManifest,
+)
+from mozpack.copier import (
+    FileCopier,
+    FileRegistrySubtree,
+)
+from mozpack.files import (
+    FileFinder,
+)
+
+# Watchman integration cribbed entirely from
+# https://github.com/facebook/watchman/blob/19aebfebb0b5b0b5174b3914a879370ffc5dac37/python/bin/watchman-wait
+import pywatchman
+
+
+def print_line(prefix, m, now=None):
+    now = now or datetime.datetime.utcnow()
+    print(b'[%s %sZ] %s' % (prefix, now.isoformat(), m))
+
+
+def print_copy_result(elapsed, destdir, result, verbose=True):
+    COMPLETE = 'Elapsed: {elapsed:.2f}s; From {dest}: Kept {existing} existing; ' \
+        'Added/updated {updated}; ' \
+        'Removed {rm_files} files and {rm_dirs} directories.'
+
+    print_line('watch', COMPLETE.format(
+        elapsed=elapsed,
+        dest=destdir,
+        existing=result.existing_files_count,
+        updated=result.updated_files_count,
+        rm_files=result.removed_files_count,
+        rm_dirs=result.removed_directories_count))
+
+
+class FasterBuildException(Exception):
+    def __init__(self, cause):
+        Exception.__init__(self)
+        self.cause = cause
+
+
+class FasterBuildChange(object):
+    def __init__(self):
+        self.unrecognized = set()
+        self.input_to_outputs = {}
+        self.output_to_inputs = {}
+
+
+class Daemon(object):
+    def __init__(self, config_environment):
+        self.config_environment = config_environment
+        self._client = None
+
+    @property
+    def defines(self):
+        defines = dict(self.config_environment.acdefines)
+        # These additions work around warts in the build system: see
+        # http://searchfox.org/mozilla-central/rev/ad093e98f42338effe2e2513e26c3a311dd96422/config/faster/rules.mk#92-93
+        # and
+        # http://searchfox.org/mozilla-central/rev/ad093e98f42338effe2e2513e26c3a311dd96422/python/mozbuild/mozbuild/backend/tup.py#244-253.
+        defines.update({
+            'AB_CD': 'en-US',
+            'BUILD_FASTER': '1',
+        })
+        defines.update({
+            'BOOKMARKS_INCLUDE_DIR': mozpath.join(self.config_environment.topsrcdir,
+                                                  'browser', 'locales', 'en-US', 'profile'),
+        })
+        return defines
+
+    @mozbuild.util.memoized_property
+    def file_copier(self):
+        file_copier = FileCopier()
+
+        unified_manifest = InstallManifest(
+            mozpath.join(self.config_environment.topobjdir,
+                         'faster', 'unified_install_dist_bin'))
+
+        unified_manifest.populate_registry(file_copier, defines_override=self.defines)
+
+        return file_copier
+
+    def subscribe_to_topsrcdir(self, dir_to_watch):
+        query = {
+            'empty_on_fresh_instance': True,
+            'expression': [
+                'allof',
+                ['type', 'f'],
+                ['not',
+                 ['anyof',
+                  ['dirname', '.hg'],
+                  ['name', '.hg', 'wholename'],
+                  ['dirname', '.git'],
+                  ['name', '.git', 'wholename'],
+                 ],
+                ],
+            ],
+            'fields': ['name'],
+        }
+        watch = self.client.query('watch-project', dir_to_watch)
+        if 'warning' in watch:
+            print('WARNING: ', watch['warning'], file=sys.stderr)
+
+        root = watch['watch']
+        if 'relative_path' in watch:
+            query['relative_root'] = watch['relative_path']
+
+        # Get the initial clock value so that we only get updates.
+        query['since'] = self.client.query('clock', root)['clock']
+
+        return self.client.query('subscribe', root, 'topsrcdir', query)
+
+    def changed_files(self):
+        # In theory we can parse just the result variable here, but
+        # the client object will accumulate all subscription results
+        # over time, so we ask it to remove and return those values.
+        files = set()
+
+        data = self.client.getSubscription('topsrcdir')
+        if data:
+            for dat in data:
+                files |= set([mozpath.normpath(mozpath.join(self.config_environment.topsrcdir, f))
+                              for f in dat.get('files', [])])
+
+        return files
+
+    def incremental_copy(self, copier, force=False, verbose=True):
+        # Just like the 'repackage' target in browser/app/Makefile.in.
+        if 'cocoa' == self.config_environment.substs['MOZ_WIDGET_TOOLKIT']:
+            bundledir = mozpath.join(self.config_environment.topobjdir, 'dist',
+                                     self.config_environment.substs['MOZ_MACBUNDLE_NAME'],
+                                     'Contents', 'Resources')
+            start = time.time()
+            result = copier.copy(bundledir,
+                                 skip_if_older=not force,
+                                 remove_unaccounted=False,
+                                 remove_all_directory_symlinks=False,
+                                 remove_empty_directories=False)
+            print_copy_result(time.time() - start, bundledir, result, verbose=verbose)
+
+        destdir = mozpath.join(self.config_environment.topobjdir, 'dist', 'bin')
+        start = time.time()
+        result = copier.copy(destdir,
+                             skip_if_older=not force,
+                             remove_unaccounted=False,
+                             remove_all_directory_symlinks=False,
+                             remove_empty_directories=False)
+        print_copy_result(time.time() - start, destdir, result, verbose=verbose)
+
+
+    def input_changes(self):
+        '''
+        Return an iterator of `FasterBuildChange` instances as inputs
+        to the faster build system change.
+        '''
+
+        self.client = pywatchman.client()
+
+        try:
+            # TODO: restrict these capabilities to the minimal set.
+            self.client.capabilityCheck(required=['term-dirname', 'cmd-watch-project', 'wildmatch'])
+
+            self.subscribe_to_topsrcdir(self.config_environment.topsrcdir)
+
+            input_to_outputs = self.file_copier.input_to_outputs_tree()
+            for input, outputs in input_to_outputs.items():
+                if not outputs:
+                    raise Exception("Refusing to watch input ({}) with no outputs".format(input))
+
+            while True:
+                try:
+                    _watch_result = self.client.receive()
+
+                    changed = self.changed_files()
+                    if not changed:
+                        continue
+
+                    result = FasterBuildChange()
+
+                    for change in changed:
+                        if change in input_to_outputs:
+                            result.input_to_outputs[change] = set(input_to_outputs[change])
+                        else:
+                            result.unrecognized.add(change)
+
+                    for input, outputs in result.input_to_outputs.items():
+                        for output in outputs:
+                            if output not in result.output_to_inputs:
+                                result.output_to_inputs[output] = set()
+                            result.output_to_inputs[output].add(input)
+
+                    yield result
+
+                except pywatchman.SocketTimeout:
+                    # Let's check to see if we're still functional.
+                    _version = self.client.query('version')
+
+        except pywatchman.CommandError as e:
+            # Abstract away pywatchman errors.
+            raise FasterBuildException(e)
+
+        except pywatchman.SocketTimeout as ex:
+            # Abstract away pywatchman errors.
+            raise FasterBuildException(e)
+
+        finally:
+            self.client.close()
+
+    def output_changes(self, verbose=True):
+        '''
+        Return an iterator of `FasterBuildChange` instances as outputs
+        from the faster build system are updated.
+        '''
+        # TODO: provide the debug diagnostics we want: this print is
+        # not immediately before the watch.
+        if verbose:
+            print_line('watch', 'Watching {}'.format(self.config_environment.topsrcdir))
+
+        for change in self.input_changes():
+            now = datetime.datetime.utcnow()
+
+            for unrecognized in sorted(change.unrecognized):
+                print_line('watch', '! {}'.format(unrecognized), now=now)
+
+            all_outputs = set()
+            for input in sorted(change.input_to_outputs):
+                outputs = change.input_to_outputs[input]
+
+                print_line('watch', '< {}'.format(input), now=now)
+                for output in sorted(outputs):
+                    print_line('watch', '> {}'.format(output), now=now)
+                all_outputs |= outputs
+
+            if all_outputs:
+                partial_copier = FileCopier()
+                for output in all_outputs:
+                    partial_copier.add(output, self.file_copier[output])
+
+                self.incremental_copy(partial_copier, force=True, verbose=verbose)
+                yield change
diff --git a/python/mozbuild/mozbuild/mach_commands.py b/python/mozbuild/mozbuild/mach_commands.py
--- a/python/mozbuild/mozbuild/mach_commands.py
+++ b/python/mozbuild/mozbuild/mach_commands.py
@@ -302,16 +302,36 @@
 class StoreDebugParamsAndWarnAction(argparse.Action):
     def __call__(self, parser, namespace, values, option_string=None):
         sys.stderr.write('The --debugparams argument is deprecated. Please ' +
                          'use --debugger-args instead.\n\n')
         setattr(namespace, self.dest, values)
 
 
 @CommandProvider
+class Watch(MachCommandBase):
+    """Interface to watch and re-build the tree."""
+
+    @Command('watch', category='build', description='Watch and re-build the tree.')
+    def watch(self):
+        """Watch and re-build the source tree."""
+        self._activate_virtualenv()
+        try:
+            self.virtualenv_manager.install_pip_package('pywatchman==1.3.0')
+        except:
+            print('Could not install pywatchman from pip.  See '
+                  'https://developer.mozilla.org/en-US/docs/TODO_DOCUMENTATION_URL')
+            return 1
+
+        from mozbuild.faster_daemon import Daemon
+        daemon = Daemon(self.config_environment)
+        return daemon.watch()
+
+
+@CommandProvider
 class Build(MachCommandBase):
     """Interface to build the tree."""
 
     @Command('build', category='build', description='Build the tree.')
     @CommandArgument('--jobs', '-j', default='0', metavar='jobs', type=int,
         help='Number of concurrent jobs to run. Default is the number of CPUs.')
     @CommandArgument('-C', '--directory', default=None,
         help='Change to a subdirectory of the build directory first.')
diff --git a/python/mozbuild/mozpack/manifests.py b/python/mozbuild/mozpack/manifests.py
--- a/python/mozbuild/mozpack/manifests.py
+++ b/python/mozbuild/mozpack/manifests.py
@@ -326,16 +326,29 @@
         ))
 
     def _add_entry(self, dest, entry):
         if dest in self._dests:
             raise ValueError('Item already in manifest: %s' % dest)
 
         self._dests[dest] = entry
 
+    def add_entries_from(self, other, base=''):
+        """
+        Copy data from another mozpack.copier.InstallManifest
+        instance, adding an optional base prefix to the destination.
+
+        This allows to merge two manifests into a single manifest, or
+        two take the tagged union of two manifests.
+        """
+        for dest, entry in other._dests.iteritems():
+            if base:
+                dest = mozpath.join(base, dest)
+            self._add_entry(dest, entry)
+
     def populate_registry(self, registry, defines_override={},
                           link_policy='symlink'):
         """Populate a mozpack.copier.FileRegistry instance with data from us.
 
         The caller supplied a FileRegistry instance (or at least something that
         conforms to its interface) and that instance is populated with data
         from this manifest.
 

