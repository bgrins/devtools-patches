# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  d11f4539ac14c6a1e9a11dab5322f61f21b3958a

diff --git a/toolkit/content/widgets/text.js b/toolkit/content/widgets/text.js
--- a/toolkit/content/widgets/text.js
+++ b/toolkit/content/widgets/text.js
@@ -28,185 +28,356 @@ if (gUnderlineAccesskey) {
     val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
       nsIPrefLocalizedString).data;
     gAlwaysAppendAccessKey = val == "true";
   } catch (e) {
     gInsertSeparator = gAlwaysAppendAccessKey = true;
   }
 }
 
+// class MozTextLabel extends MozXULTextElement {
+//   constructor() {
+//     super();
+//     this._lastFormattedAccessKey = null;
+//     this.addEventListener("click", this._onClick);
+//   }
+
+//   static get observedAttributes() {
+//     return ["accesskey", "text"];
+//   }
+
+//   attributeChangedCallback(name, oldValue, newValue) {
+//     if (!this.isConnectedAndReady || oldValue == newValue) {
+//       return;
+//     }
+//     if (name == "text") {
+//       this._lastFormattedAccessKey = null;
+//     }
+//     this.formatAccessKey();
+//   }
+
+//   _onClick(event) {
+//     let controlElement = this.labeledControlElement;
+//     if (!controlElement || this.disabled) {
+//       return;
+//     }
+//     controlElement.focus();
+//     const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+//     if (controlElement.namespaceURI != XUL_NS) {
+//       return;
+//     }
+//     if (controlElement.localName == "checkbox") {
+//       controlElement.checked = !controlElement.checked;
+//     } else if (controlElement.localName == "radio") {
+//       controlElement.control.selectedItem = controlElement;
+//     }
+//   }
+
+//   connectedCallback() {
+//     if (this.delayConnectedCallback()) {
+//       return;
+//     }
+
+//     this.formatAccessKey();
+//   }
+
+//   set accessKey(val) {
+//     this.setAttribute("accesskey", val);
+//     var control = this.labeledControlElement;
+//     if (control) {
+//       control.setAttribute("accesskey", val);
+//     }
+//   }
+
+//   get accessKey() {
+//     let accessKey = this.getAttribute("accesskey");
+//     return accessKey ? accessKey[0] : null;
+//   }
+
+//   get labeledControlElement() {
+//     let control = this.control;
+//     return control ? document.getElementById(control) : null;
+//   }
+
+//   set control(val) {
+//     this.setAttribute("control", val);
+//   }
+
+//   get control() {
+//     return this.getAttribute("control");
+//   }
+
+//   // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
+//   // label uses [value]). So this is just for when we have textContent.
+//   formatAccessKey() {
+//     // Skip doing any DOM manipulation whenever possible:
+//     let accessKey = this.accessKey;
+//     if (!gUnderlineAccesskey ||
+//         !this.isConnectedAndReady ||
+//         this._lastFormattedAccessKey == accessKey ||
+//         !this.textContent) {
+//       return;
+//     }
+
+//     this._lastFormattedAccessKey = accessKey;
+//     if (this.accessKeySpan) { // Clear old accesskey
+//       mergeElement(this.accessKeySpan);
+//       this.accessKeySpan = null;
+//     }
+
+//     if (this.hiddenColon) {
+//       mergeElement(this.hiddenColon);
+//       this.hiddenColon = null;
+//     }
+
+//     if (this.accessKeyParens) {
+//       this.accessKeyParens.remove();
+//       this.accessKeyParens = null;
+//     }
+
+//     // If we used to have an accessKey but not anymore, we're done here
+//     if (!accessKey) {
+//       return;
+//     }
+
+//     let labelText = this.textContent;
+//     let accessKeyIndex = -1;
+//     if (!gAlwaysAppendAccessKey) {
+//       accessKeyIndex = labelText.indexOf(accessKey);
+//       if (accessKeyIndex < 0) { // Try again in upper case
+//         accessKeyIndex =
+//           labelText.toUpperCase().indexOf(accessKey.toUpperCase());
+//       }
+//     } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
+//       accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
+//     }
+
+//     const HTML_NS = "http://www.w3.org/1999/xhtml";
+//     this.accessKeySpan = document.createElementNS(HTML_NS, "span");
+//     this.accessKeySpan.className = "accesskey";
+
+//     // Note that if you change the following code, see the comment of
+//     // nsTextBoxFrame::UpdateAccessTitle.
+
+//     // If accesskey is in the string, underline it:
+//     if (accessKeyIndex >= 0) {
+//       wrapChar(this, this.accessKeySpan, accessKeyIndex);
+//       return;
+//     }
+
+//     // If accesskey is not in string, append in parentheses
+//     // If end is colon, we should insert before colon.
+//     // i.e., "label:" -> "label(X):"
+//     let colonHidden = false;
+//     if (/:$/.test(labelText)) {
+//       labelText = labelText.slice(0, -1);
+//       this.hiddenColon = document.createElementNS(HTML_NS, "span");
+//       this.hiddenColon.className = "hiddenColon";
+//       this.hiddenColon.style.display = "none";
+//       // Hide the last colon by using span element.
+//       // I.e., label<span style="display:none;">:</span>
+//       wrapChar(this, this.hiddenColon, labelText.length);
+//       colonHidden = true;
+//     }
+//     // If end is space(U+20),
+//     // we should not add space before parentheses.
+//     let endIsSpace = false;
+//     if (/ $/.test(labelText)) {
+//       endIsSpace = true;
+//     }
+
+//     this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+//     this.appendChild(this.accessKeyParens);
+//     if (gInsertSeparator && !endIsSpace)
+//       this.accessKeyParens.textContent = " (";
+//     else
+//       this.accessKeyParens.textContent = "(";
+//     this.accessKeySpan.textContent = accessKey.toUpperCase();
+//     this.accessKeyParens.appendChild(this.accessKeySpan);
+//     if (!colonHidden) {
+//       this.accessKeyParens.appendChild(document.createTextNode(")"));
+//     } else {
+//       this.accessKeyParens.appendChild(document.createTextNode("):"));
+//     }
+//   }
+// }
+
+// customElements.define("label", MozTextLabel);
+
+
 class MozTextLabel extends MozXULTextElement {
   constructor() {
     super();
-    this._lastFormattedAccessKey = null;
-    this.addEventListener("click", this._onClick);
-  }
-
-  static get observedAttributes() {
-    return ["accesskey", "text"];
-  }
 
-  attributeChangedCallback(name, oldValue, newValue) {
-    if (!this.isConnectedAndReady || oldValue == newValue) {
-      return;
-    }
-    if (name == "text") {
-      this._lastFormattedAccessKey = null;
-    }
-    this.formatAccessKey();
-  }
+    this.addEventListener("click", (event) => {
+      if (this.disabled) {
+        return;
+      }
+      var controlElement = this.labeledControlElement;
+      if (!controlElement) {
+        return;
+      }
+      controlElement.focus();
+      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
-  _onClick(event) {
-    let controlElement = this.labeledControlElement;
-    if (!controlElement || this.disabled) {
-      return;
-    }
-    controlElement.focus();
-    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
-    if (controlElement.namespaceURI != XUL_NS) {
-      return;
-    }
-    if (controlElement.localName == "checkbox") {
-      controlElement.checked = !controlElement.checked;
-    } else if (controlElement.localName == "radio") {
-      controlElement.control.selectedItem = controlElement;
-    }
+      if (controlElement.namespaceURI != XUL_NS) {
+        return;
+      }
+      if (controlElement.localName == "checkbox") {
+        controlElement.checked = !controlElement.checked;
+      } else if (controlElement.localName == "radio") {
+        controlElement.control.selectedItem = controlElement;
+      }
+    });
   }
 
   connectedCallback() {
     if (this.delayConnectedCallback()) {
       return;
     }
 
-    this.formatAccessKey();
+    this.formatAccessKey(true);
   }
 
   set accessKey(val) {
-    this.setAttribute("accesskey", val);
+    // If this label already has an accesskey attribute store it here as well
+    if (this.hasAttribute("accesskey")) {
+      this.setAttribute("accesskey", val);
+    }
     var control = this.labeledControlElement;
     if (control) {
       control.setAttribute("accesskey", val);
     }
+    this.formatAccessKey(false);
+    return val;
   }
 
   get accessKey() {
-    let accessKey = this.getAttribute("accesskey");
+    var accessKey = this.getAttribute("accesskey");
     return accessKey ? accessKey[0] : null;
   }
 
   get labeledControlElement() {
-    let control = this.control;
+    var control = this.control;
     return control ? document.getElementById(control) : null;
   }
 
   set control(val) {
+    var control = this.labeledControlElement;
+    if (control) {
+      control.labelElement = null; // No longer pointed to be this label
+    }
     this.setAttribute("control", val);
+    this.formatAccessKey(false);
+    return val;
   }
 
   get control() {
     return this.getAttribute("control");
   }
 
-  // This is used to match the rendering of accesskeys from nsTextBoxFrame.cpp (i.e. when the
-  // label uses [value]). So this is just for when we have textContent.
-  formatAccessKey() {
-    // Skip doing any DOM manipulation whenever possible:
-    let accessKey = this.accessKey;
-    if (!gUnderlineAccesskey ||
-        !this.isConnectedAndReady ||
-        this._lastFormattedAccessKey == accessKey ||
-        !this.textContent) {
-      return;
+  formatAccessKey(firstTime) {
+    var control = this.labeledControlElement;
+    if (!control) {
+      var bindingParent = document.getBindingParent(this);
+      if ("accessKey" in bindingParent) {
+        control = bindingParent; // For controls that make the <label> an anon child
+      }
     }
-
-    this._lastFormattedAccessKey = accessKey;
-    if (this.accessKeySpan) { // Clear old accesskey
-      mergeElement(this.accessKeySpan);
-      this.accessKeySpan = null;
+    if (control) {
+      control.labelElement = this;
+      var controlAccessKey = control.getAttribute("accesskey");
+      if (controlAccessKey) {
+        this.setAttribute("accesskey", controlAccessKey);
+      }
     }
 
-    if (this.hiddenColon) {
-      mergeElement(this.hiddenColon);
-      this.hiddenColon = null;
+    var accessKey = this.accessKey;
+    // No need to remove existing formatting the first time.
+    if (firstTime && !accessKey)
+      return;
+
+    if (!this.mUnderlineAccesskey)
+      return;
+
+    var afterLabel = document.getAnonymousElementByAttribute(this, "anonid", "accessKeyParens");
+    afterLabel.textContent = "";
+
+    var oldAccessKey = this.getElementsByAttribute("class", "accesskey").item(0);
+    if (oldAccessKey) { // Clear old accesskey
+      mergeElement(oldAccessKey);
     }
 
-    if (this.accessKeyParens) {
-      this.accessKeyParens.remove();
-      this.accessKeyParens = null;
+    var oldHiddenSpan =
+      this.getElementsByAttribute("class", "hiddenColon").item(0);
+    if (oldHiddenSpan) {
+      mergeElement(oldHiddenSpan);
     }
 
-    // If we used to have an accessKey but not anymore, we're done here
-    if (!accessKey) {
+    var labelText = this.textContent;
+    if (!accessKey || !labelText || !control) {
       return;
     }
-
-    let labelText = this.textContent;
-    let accessKeyIndex = -1;
-    if (!gAlwaysAppendAccessKey) {
+    var accessKeyIndex = -1;
+    if (!this.mAlwaysAppendAccessKey) {
       accessKeyIndex = labelText.indexOf(accessKey);
       if (accessKeyIndex < 0) { // Try again in upper case
         accessKeyIndex =
           labelText.toUpperCase().indexOf(accessKey.toUpperCase());
       }
     } else if (labelText.endsWith(`(${accessKey.toUpperCase()})`)) {
       accessKeyIndex = labelText.length - (1 + accessKey.length); // = index of accessKey.
     }
 
     const HTML_NS = "http://www.w3.org/1999/xhtml";
-    this.accessKeySpan = document.createElementNS(HTML_NS, "span");
-    this.accessKeySpan.className = "accesskey";
+    var span = document.createElementNS(HTML_NS, "span");
+    span.className = "accesskey";
 
     // Note that if you change the following code, see the comment of
     // nsTextBoxFrame::UpdateAccessTitle.
 
-    // If accesskey is in the string, underline it:
-    if (accessKeyIndex >= 0) {
-      wrapChar(this, this.accessKeySpan, accessKeyIndex);
+    // If accesskey is not in string, append in parentheses
+    if (accessKeyIndex < 0) {
+      // If end is colon, we should insert before colon.
+      // i.e., "label:" -> "label(X):"
+      var colonHidden = false;
+      if (/:$/.test(labelText)) {
+        labelText = labelText.slice(0, -1);
+        var hiddenSpan = document.createElementNS(HTML_NS, "span");
+        hiddenSpan.className = "hiddenColon";
+        hiddenSpan.style.display = "none";
+        // Hide the last colon by using span element.
+        // I.e., label<span style="display:none;">:</span>
+        wrapChar(hiddenSpan, labelText.length);
+        colonHidden = true;
+      }
+      // If end is space(U+20),
+      // we should not add space before parentheses.
+      var endIsSpace = false;
+      if (/ $/.test(labelText)) {
+        endIsSpace = true;
+      }
+      if (this.mInsertSeparator && !endIsSpace)
+        afterLabel.textContent = " (";
+      else
+        afterLabel.textContent = "(";
+      span.textContent = accessKey.toUpperCase();
+      afterLabel.appendChild(span);
+      if (!colonHidden)
+        afterLabel.appendChild(document.createTextNode(")"));
+      else
+        afterLabel.appendChild(document.createTextNode("):"));
       return;
     }
-
-    // If accesskey is not in string, append in parentheses
-    // If end is colon, we should insert before colon.
-    // i.e., "label:" -> "label(X):"
-    let colonHidden = false;
-    if (/:$/.test(labelText)) {
-      labelText = labelText.slice(0, -1);
-      this.hiddenColon = document.createElementNS(HTML_NS, "span");
-      this.hiddenColon.className = "hiddenColon";
-      this.hiddenColon.style.display = "none";
-      // Hide the last colon by using span element.
-      // I.e., label<span style="display:none;">:</span>
-      wrapChar(this, this.hiddenColon, labelText.length);
-      colonHidden = true;
-    }
-    // If end is space(U+20),
-    // we should not add space before parentheses.
-    let endIsSpace = false;
-    if (/ $/.test(labelText)) {
-      endIsSpace = true;
-    }
-
-    this.accessKeyParens = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
-    this.appendChild(this.accessKeyParens);
-    if (gInsertSeparator && !endIsSpace)
-      this.accessKeyParens.textContent = " (";
-    else
-      this.accessKeyParens.textContent = "(";
-    this.accessKeySpan.textContent = accessKey.toUpperCase();
-    this.accessKeyParens.appendChild(this.accessKeySpan);
-    if (!colonHidden) {
-      this.accessKeyParens.appendChild(document.createTextNode(")"));
-    } else {
-      this.accessKeyParens.appendChild(document.createTextNode("):"));
-    }
+    wrapChar(span, accessKeyIndex);
   }
 }
 
-customElements.define("label", MozTextLabel);
+customElements.define("label-control", MozTextLabel);
 
 function mergeElement(element) {
   // If the element has been removed already, return:
   if (!element.isConnected) {
     return;
   }
   if (element.previousSibling instanceof Text) {
     element.previousSibling.appendData(element.textContent);
