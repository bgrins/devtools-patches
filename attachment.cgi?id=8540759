# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent e22433270ec30950336368a52425d138e9f4275c

diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -507,19 +507,26 @@ LayoutView.prototype = {
   }
 };
 
 let elts;
 let tooltip;
 
 let onmouseover = function(e) {
   let region = e.target.getAttribute("data-box");
+  if (!region) {
+    return;
+  }
 
   tooltip.textContent = e.target.getAttribute("tooltip");
-  this.layoutview.showBoxModel({region});
+  this.layoutview.showBoxModel({
+    region: region,
+    onlyRegionArea: true,
+    showOnly: region
+  });
 
   return false;
 }.bind(window);
 
 let onmouseout = function(e) {
   tooltip.textContent = "";
   this.layoutview.hideBoxModel();
 
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -25,16 +25,20 @@
 }
 
 /* Box model highlighter */
 
 :-moz-native-anonymous .box-model-regions {
   opacity: 0.6;
 }
 
+:-moz-native-anonymous .box-model-regions [faded] {
+  opacity: 0.2;
+}
+
 :-moz-native-anonymous .box-model-content {
   fill: #87ceeb;
 }
 
 :-moz-native-anonymous .box-model-padding {
   fill: #6a5acd;
 }
 
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -14,16 +14,18 @@ const {CssLogic} = require("devtools/sty
 const EventEmitter = require("devtools/toolkit/event-emitter");
 const {setIgnoreLayoutChanges} = require("devtools/server/actors/layout");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 // FIXME: add ":visited" and ":link" after bug 713106 is fixed
 const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
+// Note that the order of items in this array is important because it is used
+// for drawing the BoxModelHighlighter's path elements correctly.
 const BOX_MODEL_REGIONS = ["margin", "border", "padding", "content"];
 const BOX_MODEL_SIDES = ["top", "right", "bottom", "left"];
 const SVG_NS = "http://www.w3.org/2000/svg";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const HIGHLIGHTER_STYLESHEET_URI = "resource://gre/modules/devtools/server/actors/highlighter.css";
 const HIGHLIGHTER_PICKED_TIMER = 1000;
 // How high is the nodeinfobar
 const NODE_INFOBAR_HEIGHT = 40; //px
@@ -167,17 +169,18 @@ let HighlighterActor = exports.Highlight
       this._highlighter.hide();
     }
   }, {
     request: {
       node: Arg(0, "domnode"),
       region: Option(1),
       hideInfoBar: Option(1),
       hideGuides: Option(1),
-      showOnly: Option(1)
+      showOnly: Option(1),
+      onlyRegionArea: Option(1)
     }
   }),
 
   /**
    * Hide the box model highlighting if it was shown before
    */
   hideBoxModel: method(function() {
     this._highlighter.hide();
@@ -725,26 +728,29 @@ AutoRefreshHighlighter.prototype = {
  *   Defaults to "content"
  * - hideGuides {Boolean}
  *   Defaults to false
  * - hideInfoBar {Boolean}
  *   Defaults to false
  * - showOnly {String}
  *   "content", "padding", "border" or "margin"
  *    If set, only this region will be highlighted
+ * - onlyRegionArea {Boolean}
+ *   By default, the rectangle defined by the region is filled by the highlighter.
+ *   Set to true to only fill the region area itself (not the nested regions).
  *
  * Structure:
  * <div class="highlighter-container">
  *   <div class="box-model-root">
  *     <svg class="box-model-elements" hidden="true">
  *       <g class="box-model-regions">
- *         <polygon class="box-model-margin" points="..." />
- *         <polygon class="box-model-border" points="..." />
- *         <polygon class="box-model-padding" points="..." />
- *         <polygon class="box-model-content" points="..." />
+ *         <path class="box-model-margin" d="..." />
+ *         <path class="box-model-border" d="..." />
+ *         <path class="box-model-padding" d="..." />
+ *         <path class="box-model-content" d="..." />
  *       </g>
  *       <line class="box-model-guide-top" x1="..." y1="..." x2="..." y2="..." />
  *       <line class="box-model-guide-right" x1="..." y1="..." x2="..." y2="..." />
  *       <line class="box-model-guide-bottom" x1="..." y1="..." x2="..." y2="..." />
  *       <line class="box-model-guide-left" x1="..." y1="..." x2="..." y2="..." />
  *     </svg>
  *     <div class="box-model-nodeinfobar-container">
  *       <div class="box-model-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top" />
@@ -830,17 +836,17 @@ BoxModelHighlighter.prototype = Heritage
       attributes: {
         "class": "regions"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     for (let region of BOX_MODEL_REGIONS) {
       createSVGNode(this.win, {
-        nodeType: "polygon",
+        nodeType: "path",
         parent: regions,
         attributes: {
           "class": region,
           "id": region
         },
         prefix: this.ID_CLASS_PREFIX
       });
     }
@@ -1052,35 +1058,57 @@ BoxModelHighlighter.prototype = Heritage
    *
    * @return {boolean}
    *         True if the current node has a box model to be highlighted
    */
   _updateBoxModel: function() {
     this.options.region = this.options.region || "content";
 
     if (this._nodeNeedsHighlighting()) {
-      for (let boxType of BOX_MODEL_REGIONS) {
+      for (let i = 0; i < BOX_MODEL_REGIONS.length; i ++) {
+        let boxType = BOX_MODEL_REGIONS[i];
+        let nextBoxType = BOX_MODEL_REGIONS[i + 1];
+
         let {p1, p2, p3, p4} = this.currentQuads[boxType];
 
         if (this.regionFill[boxType]) {
           this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
             "style", "fill:" + this.regionFill[boxType]);
         } else {
           this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
             "style", "");
         }
 
+        let path;
+        if (!nextBoxType) {
+          // If this is the content box (inner-most box), draw a simple rectangle.
+          path = "M" + p1.x + " " + p1.y +
+                 " L" + p2.x + " " + p2.y +
+                 " L" + p3.x + " " + p3.y +
+                 " L" + p4.x + " " + p4.y;
+        } else {
+          // Otherwise, just draw the region itself, not a filled rectangle.
+          let {p1: np1, p2: np2, p3: np3, p4: np4} = this.currentQuads[nextBoxType];
+          path = "M" + p1.x + " " + p1.y +
+                 " L" + p2.x + " " + p2.y +
+                 " L" + p3.x + " " + p3.y +
+                 " L" + p4.x + " " + p4.y +
+                 " L" + p1.x + " " + p1.y +
+                 " L" + np1.x + " " + np1.y +
+                 " L" + np4.x + " " + np4.y +
+                 " L" + np3.x + " " + np3.y +
+                 " L" + np2.x + " " + np2.y +
+                 " L" + np1.x + " " + np1.y;
+        }
+        this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType, "d", path);
+
         if (!this.options.showOnly || this.options.showOnly === boxType) {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "points", p1.x + "," + p1.y + " " +
-                      p2.x + "," + p2.y + " " +
-                      p3.x + "," + p3.y + " " +
-                      p4.x + "," + p4.y);
+          this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + boxType, "faded");
         } else {
-          this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + boxType, "points");
+          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType, "faded", "true");
         }
 
         if (boxType === this.options.region && !this.options.hideGuides) {
           this._showGuides(p1, p2, p3, p4);
         } else if (this.options.hideGuides) {
           this._hideGuides();
         }
       }
