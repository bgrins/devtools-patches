# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  bab079b99cec263f3fdb7c8d21e8769a8f0321b8

diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -561,17 +561,35 @@ LayoutHelpers.isXBLAnonymous = function(
 LayoutHelpers.isShadowAnonymous = function(node) {
   let parent = LayoutHelpers.getBindingParent(node);
   if (!parent) {
     return false;
   }
 
   // If there is a shadowRoot and this is part of it then this
   // is not native anonymous
-  return parent.shadowRoot && parent.shadowRoot.contains(node);
+  // XXX: This should loop over olderShadowRoots possibly
+  let root = parent.shadowRoot;
+  let isChild = false;
+
+  while (root) {
+    if (root.contains(node)) {
+      isChild = true;
+      break;
+    }
+    root = root.olderShadowRoot;
+  }
+
+  return isChild;
+};
+
+LayoutHelpers.isShadowRoot = function(node) {
+  let defaultView = (node.ownerDocument && node.ownerDocument.defaultView) || node.defaultView
+  return node.host &&
+         node instanceof defaultView.ShadowRoot;
 };
 
 /**
  * Get the current zoom factor applied to the container window of a given node.
  * Container windows are used as a weakmap key to store the corresponding
  * nsIDOMWindowUtils instance to avoid querying it every time.
  *
  * @param {DOMNode|DOMWindow} The node for which the zoom factor should be
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -3803,142 +3803,226 @@ function DocumentWalker(node, rootWin, w
   this.walker.showSubDocuments = true;
   this.walker.showDocumentsAsNodes = true;
   this.walker.init(rootWin.document, whatToShow);
   this.filter = filter;
 
   // Make sure that the walker knows about the initial node (which could
   // be skipped due to a filter).  Note that simply calling parentNode()
   // causes currentNode to be updated.
-  this.walker.currentNode = node;
+
+  // XXX: this shouldnt be called if walker.currentNode setter pukes
+  this.currentNode = node;
   while (node &&
          this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
     node = this.walker.parentNode();
   }
 }
 
 DocumentWalker.prototype = {
   get node() {
     return this.walker.node;
   },
   get whatToShow() {
     return this.walker.whatToShow;
   },
   get currentNode() {
-    return this.walker.currentNode;
+    return this._currentNode;
   },
   set currentNode(aVal) {
-    this.walker.currentNode = aVal;
+    // if (LayoutHelpers.isShadowAnonymous(aVal)) {
+    //   console.log("shadow anon", aVal);
+    // }
+    try {
+      this.walker.currentNode = aVal;
+    } catch(e) {
+      console.log("Puke", e);
+    }
+    this._currentNode = aVal;
   },
 
   parentNode: function() {
-    let node = this.walker.currentNode;
+    let node = this.currentNode;
 
     // ShadowHost is the parent of every ShadowRoot
-    if (node.host &&
-        node instanceof node.ownerDocument.defaultView.ShadowRoot) {
-      this.walker.currentNode = node.host;
+    if (LayoutHelpers.isShadowRoot(node)) {
+      this.currentNode = node.host;
       return node.host;
     }
 
-    return this.walker.parentNode();
+    let parentNode = this.walker.parentNode();
+    this.currentNode = parentNode;
+    return parentNode;
   },
 
+  createNormalWalker: function(node) {
+    //XXX: try to create a deeptreewalker without showAnonymous as gabor suggestd
+    // this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"].createInstance(Ci.inIDeepTreeWalker);
+    // this.walker.showSubDocuments = true;
+    // this.walker.showDocumentsAsNodes = true;
+    // this.walker.init(rootWin.document, whatToShow);
+    return node.ownerDocument.createTreeWalker(
+        node, this.whatToShow);
+  },
+
   firstChild: function() {
-    let node = this.walker.currentNode;
+    let node = this.currentNode;
     if (!node)
       return null;
 
+    // Use a normal walker if this is a shadow root
+    if (LayoutHelpers.isShadowRoot(node)) {
+      let walker = this.createNormalWalker(node);
+      let firstChild = walker.firstChild();
+      while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        firstChild = walker.nextSibling();
+      }
+      this.currentNode = firstChild;
+      return firstChild;
+    }
+
     if (node.shadowRoot) {
-      this.walker.currentNode = node.shadowRoot;
+      this.currentNode = node.shadowRoot;
       return node.shadowRoot;
     }
 
     let firstChild = this.walker.firstChild();
     while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       firstChild = this.walker.nextSibling();
     }
 
+    this.currentNode = firstChild;
     return firstChild;
   },
 
   lastChild: function() {
-    let node = this.walker.currentNode;
+    let node = this.currentNode;
     if (!node)
       return null;
 
+    // Use a normal walker if this is a shadow root
+    if (LayoutHelpers.isShadowRoot(node)) {
+      let walker = this.createNormalWalker(node);
+      let lastChild = walker.lastChild();
+      while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        lastChild = walker.previousSibling();
+      }
+
+      this.currentNode = lastChild;
+      return lastChild;
+    }
+
     let lastChild = this.walker.lastChild();
     while (lastChild && this.filter(lastChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       lastChild = this.walker.previousSibling();
     }
 
     if (lastChild) {
+      this.currentNode = lastChild;
       return lastChild;
     }
 
     let root = node.shadowRoot || null;
     while (root) {
       root = root.olderShadowRoot;
-      this.walker.currentNode = root;
+      this.currentNode = root;
     }
 
     return root;
   },
 
   previousSibling: function() {
-    let node = this.walker.currentNode;
-
-    if (node.host && node instanceof node.ownerDocument.defaultView.ShadowRoot) {
+    let node = this.currentNode;
+
+    if (LayoutHelpers.isShadowRoot(node)) {
       let host = node.host;
       let root = host.shadowRoot;
       if (root == node) {
         return null;
       }
 
       while (root && root.olderShadowRoot != node) {
         root = root.olderShadowRoot;
-        this.walker.currentNode = root;
+        this.currentNode = root;
       }
 
       return root;
     }
 
+    if (LayoutHelpers.isShadowAnonymous(node)) {
+
+      // Update the state of this.currentNode.
+      // XX: if this traverses to a non shadow element then we need to fall back to normal
+      // traversal.
+      // node = this.parentNode();
+
+      let walker = this.createNormalWalker(node);
+      let previousSibling = walker.previousSibling();
+      while (previousSibling && this.filter(previousSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        previousSibling = walker.previousSibling();
+      }
+      this.currentNode = previousSibling;
+      return previousSibling;
+    }
+
     let previousSibling = this.walker.previousSibling();
     while (previousSibling && this.filter(previousSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       previousSibling = this.walker.previousSibling();
     }
+    this.currentNode = previousSibling;
     return previousSibling;
   },
 
   nextSibling: function() {
-    let node = this.walker.currentNode;
-
-    if (node instanceof node.ownerDocument.defaultView.ShadowRoot &&
+    let node = this.currentNode;
+
+    if (LayoutHelpers.isShadowRoot(node) &&
         node.olderShadowRoot) {
-      this.walker.currentNode = node.olderShadowRoot;
+      this.currentNode = node.olderShadowRoot;
       return node.olderShadowRoot;
-    } else if (node instanceof node.ownerDocument.defaultView.ShadowRoot) {
-      this.walker.currentNode = node.host;
+    } else if (LayoutHelpers.isShadowRoot(node)) {
+      this.currentNode = node.host;
 
       let firstChild = this.walker.firstChild();
       while (firstChild && this.filter(firstChild) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
         firstChild = this.walker.nextSibling();
       }
 
+      this.currentNode = firstChild;
       return firstChild;
     }
 
+    if (LayoutHelpers.isShadowAnonymous(node)) {
+
+      // Update the state of this.currentNode.
+      // XX: if this traverses to a non shadow element then we need to fall back to normal
+      // traversal.
+      // node = this.parentNode();
+
+      let walker = this.createNormalWalker(node);
+      let nextSibling = walker.nextSibling();
+      console.log("got next sibling", nextSibling, node);
+      while (nextSibling && this.filter(nextSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
+        nextSibling = walker.nextSibling();
+      }
+      this.currentNode = nextSibling;
+      return nextSibling;
+    }
+
     let nextSibling = this.walker.nextSibling();
     while (nextSibling && this.filter(nextSibling) === Ci.nsIDOMNodeFilter.FILTER_SKIP) {
       nextSibling = this.walker.nextSibling();
     }
+    this.currentNode = nextSibling;
     return nextSibling;
   }
 };
 
+exports.DocumentWalker = DocumentWalker;
+
 function isXULElement(el) {
   return el &&
          el.namespaceURI === XUL_NS;
 }
 
 /**
  * This DeepTreeWalker filter skips whitespace text nodes and anonymous
  * content with the exception of ::before and ::after and anonymous content
