# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1578455095 28800
#      Tue Jan 07 19:44:55 2020 -0800
# Node ID 0422c8f8b4d070d87d67cc5dff4c9c5928e03e2f
# Parent  9f55d547e196a6945636405c2b33afc87dd501ee
Bug 1596485 - Rename mXBLInvolved to mShadowDOMInvolved and XBLInvolved to ShadowDOMInvolved

Differential Revision: https://phabricator.services.mozilla.com/D59071

diff --git a/dom/base/ChildIterator.cpp b/dom/base/ChildIterator.cpp
--- a/dom/base/ChildIterator.cpp
+++ b/dom/base/ChildIterator.cpp
@@ -84,21 +84,21 @@ void FlattenedChildIterator::Init(bool a
     return;
   }
 
   // TODO(emilio): I think it probably makes sense to only allow constructing
   // FlattenedChildIterators with Element.
   if (mParent->IsElement()) {
     if (ShadowRoot* shadow = mParent->AsElement()->GetShadowRoot()) {
       mParent = shadow;
-      mXBLInvolved = true;
+      mShadowDOMInvolved = true;
       return;
     }
     if (mParentAsSlot) {
-      mXBLInvolved = true;
+      mShadowDOMInvolved = true;
       return;
     }
   }
 }
 
 bool ExplicitChildIterator::Seek(const nsIContent* aChildToFind) {
   if (aChildToFind->GetParent() == mParent &&
       !aChildToFind->IsRootOfAnonymousSubtree()) {
diff --git a/dom/base/ChildIterator.h b/dom/base/ChildIterator.h
--- a/dom/base/ChildIterator.h
+++ b/dom/base/ChildIterator.h
@@ -132,25 +132,24 @@ class FlattenedChildIterator : public Ex
       : ExplicitChildIterator(aParent, aStartAtBeginning),
         mOriginalContent(aParent) {
     Init(false);
   }
 
   FlattenedChildIterator(FlattenedChildIterator&& aOther)
       : ExplicitChildIterator(std::move(aOther)),
         mOriginalContent(aOther.mOriginalContent),
-        mXBLInvolved(aOther.mXBLInvolved) {}
+        mShadowDOMInvolved(aOther.mShadowDOMInvolved) {}
 
   FlattenedChildIterator(const FlattenedChildIterator& aOther)
       : ExplicitChildIterator(aOther),
         mOriginalContent(aOther.mOriginalContent),
-        mXBLInvolved(aOther.mXBLInvolved) {}
+        mShadowDOMInvolved(aOther.mShadowDOMInvolved) {}
 
-  // TODO(emilio): Rename to use shadow dom terminology.
-  bool XBLInvolved() { return mXBLInvolved; }
+  bool ShadowDOMInvolved() { return mShadowDOMInvolved; }
 
   const nsIContent* Parent() const { return mOriginalContent; }
 
  private:
   void Init(bool aIgnoreXBL);
 
  protected:
   /**
@@ -165,17 +164,17 @@ class FlattenedChildIterator : public Ex
     Init(ignoreXBL);
   }
 
   const nsIContent* mOriginalContent;
 
  private:
   // For certain optimizations, nsCSSFrameConstructor needs to know if the child
   // list of the element that we're iterating matches its .childNodes.
-  bool mXBLInvolved = false;
+  bool mShadowDOMInvolved = false;
 };
 
 /**
  * AllChildrenIterator traverses the children of an element including before /
  * after content and optionally XBL children.  The iterator can be initialized
  * to start at the end by providing false for aStartAtBeginning in order to
  * start iterating in reverse from the last child.
  *
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -3806,21 +3806,21 @@ void nsCSSFrameConstructor::ConstructFra
       !(bits & FCDATA_SKIP_FRAMESET)) {
     aItem.mContent->SetPrimaryFrame(primaryFrame);
     ActiveLayerTracker::TransferActivityToFrame(aItem.mContent, primaryFrame);
   }
 }
 
 static void SetFlagsOnSubtree(nsIContent* aNode, uintptr_t aFlagsToSet) {
 #ifdef DEBUG
-  // Make sure that the node passed to us doesn't have any XBL children
+  // Make sure that the node passed to us doesn't have any Shadow DOM children
   {
     FlattenedChildIterator iter(aNode);
-    NS_ASSERTION(!iter.XBLInvolved() || !iter.GetNextChild(),
-                 "The node should not have any XBL children");
+    NS_ASSERTION(!iter.ShadowDOMInvolved() || !iter.GetNextChild(),
+                 "The node should not have any Shadow DOM children");
   }
 #endif
 
   // Set the flag on the node itself
   aNode->SetFlags(aFlagsToSet);
 
   // Set the flag on all of its children recursively
   for (nsIContent* child = aNode->GetFirstChild(); child;
@@ -5371,17 +5371,17 @@ void nsCSSFrameConstructor::AddFrameCons
 
     FlattenedChildIterator iter(aContent);
     InsertionPoint insertion(aParentFrame, aContent);
     for (nsIContent* child = iter.GetNextChild(); child;
          child = iter.GetNextChild()) {
       AddFrameConstructionItems(aState, child, aSuppressWhiteSpaceOptimizations,
                                 insertion, aItems, aFlags);
     }
-    aItems.SetParentHasNoXBLChildren(!iter.XBLInvolved());
+    aItems.SetParentHasNoXBLChildren(!iter.ShadowDOMInvolved());
 
     CreateGeneratedContentItem(aState, aParentFrame, *aContent->AsElement(),
                                *aComputedStyle, PseudoStyleType::after, aItems);
     return;
   }
 
   nsIContent* parent = aParentFrame ? aParentFrame->GetContent() : nullptr;
   if (ShouldSuppressFrameInSelect(parent, *aContent)) {
@@ -6210,17 +6210,17 @@ nsIFrame* nsCSSFrameConstructor::GetInse
 
   *aIsAppend = false;
 
   // Find the frame that precedes the insertion point. Walk backwards
   // from the parent frame to get the parent content, because if an
   // XBL insertion point is involved, we'll need to use _that_ to find
   // the preceding frame.
   FlattenedChildIterator iter(aInsertion->mContainer);
-  if (iter.XBLInvolved() || !aChild->IsRootOfAnonymousSubtree()) {
+  if (iter.ShadowDOMInvolved() || !aChild->IsRootOfAnonymousSubtree()) {
     // The check for IsRootOfAnonymousSubtree() is because editor is
     // severely broken and calls us directly for native anonymous
     // nodes that it creates.
     if (aStartSkipChild) {
       iter.Seek(aStartSkipChild);
     } else {
       iter.Seek(aChild);
     }
@@ -6740,17 +6740,17 @@ void nsCSSFrameConstructor::ContentAppen
   // Create some new frames
   nsFrameConstructorState state(
       mPresShell, GetAbsoluteContainingBlock(parentFrame, FIXED_POS),
       GetAbsoluteContainingBlock(parentFrame, ABS_POS), containingBlock);
 
   LayoutFrameType frameType = parentFrame->Type();
 
   FlattenedChildIterator iter(insertion.mContainer);
-  const bool haveNoXBLChildren = !iter.XBLInvolved() || !iter.GetNextChild();
+  const bool haveNoXBLChildren = !iter.ShadowDOMInvolved() || !iter.GetNextChild();
 
   AutoFrameConstructionItemList items(this);
   if (aFirstNewContent->GetPreviousSibling() &&
       GetParentType(frameType) == eTypeBlock && haveNoXBLChildren) {
     // If there's a text node in the normal content list just before the new
     // items, and it has no frame, make a frame construction item for it. If it
     // doesn't need a frame, ConstructFramesFromItemList below won't give it
     // one.  No need to do all this if our parent type is not block, though,
@@ -7162,17 +7162,17 @@ void nsCSSFrameConstructor::ContentRange
 
       frameType = insertion.mParentFrame->Type();
     }
   }
 
   AutoFrameConstructionItemList items(this);
   ParentType parentType = GetParentType(frameType);
   FlattenedChildIterator iter(insertion.mContainer);
-  bool haveNoXBLChildren = !iter.XBLInvolved() || !iter.GetNextChild();
+  bool haveNoXBLChildren = !iter.ShadowDOMInvolved() || !iter.GetNextChild();
   if (aStartChild->GetPreviousSibling() && parentType == eTypeBlock &&
       haveNoXBLChildren) {
     // If there's a text node in the normal content list just before the
     // new nodes, and it has no frame, make a frame construction item for
     // it, because it might need a frame now.  No need to do this if our
     // parent type is not block, though, since WipeContainingBlock
     // already handles that situation.
     AddTextItemIfNeeded(state, insertion, aStartChild->GetPreviousSibling(),
@@ -9632,23 +9632,23 @@ void nsCSSFrameConstructor::ProcessChild
 
     FlattenedChildIterator iter(aContent);
     const InsertionPoint insertion(aFrame, aContent);
     for (nsIContent* child = iter.GetNextChild(); child;
          child = iter.GetNextChild()) {
       MOZ_ASSERT(insertion.mContainer == GetInsertionPoint(child).mContainer,
                  "GetInsertionPoint should agree with us");
       if (addChildItems) {
-        AddFrameConstructionItems(aState, child, iter.XBLInvolved(), insertion,
+        AddFrameConstructionItems(aState, child, iter.ShadowDOMInvolved(), insertion,
                                   itemsToConstruct);
       } else {
         ClearLazyBits(child, child->GetNextSibling());
       }
     }
-    itemsToConstruct.SetParentHasNoXBLChildren(!iter.XBLInvolved());
+    itemsToConstruct.SetParentHasNoXBLChildren(!iter.ShadowDOMInvolved());
 
     if (aCanHaveGeneratedContent) {
       // Probe for generated content after
       CreateGeneratedContentItem(aState, aFrame, *aContent->AsElement(),
                                  *computedStyle, PseudoStyleType::after,
                                  itemsToConstruct);
     }
   } else {
@@ -11114,17 +11114,17 @@ void nsCSSFrameConstructor::BuildInlineC
   if (aItemAllowsTextPathChild &&
       aParentItem.mContent->IsSVGElement(nsGkAtoms::a)) {
     flags |= ITEM_ALLOWS_TEXT_PATH_CHILD;
   }
 
   FlattenedChildIterator iter(parentContent);
   for (nsIContent* content = iter.GetNextChild(); content;
        content = iter.GetNextChild()) {
-    AddFrameConstructionItems(aState, content, iter.XBLInvolved(),
+    AddFrameConstructionItems(aState, content, iter.ShadowDOMInvolved(),
                               InsertionPoint(), aParentItem.mChildItems, flags);
   }
 
   if (!aItemIsWithinSVGText) {
     // Probe for generated content after
     CreateGeneratedContentItem(aState, nullptr, *parentContent->AsElement(),
                                *parentComputedStyle, PseudoStyleType::after,
                                aParentItem.mChildItems);
