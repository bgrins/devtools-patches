# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  dead9fcddd4a25fd36d54ab7eb782d7d9b8bb7a1
perl -p -i -e 's/\.childNodes/.children/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js} --exclude=browser//components/newtab/** --exclude=**/vendor/** "react" browser/ toolkit/`
perl -p -i -e 's/\.firstChild/.firstElementChild/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js} --exclude=browser//components/newtab/** --exclude=**/vendor/** "react" browser/ toolkit/`
perl -p -i -e 's/\.lastChild/.lastElementChild/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js} --exclude=browser//components/newtab/** --exclude=**/vendor/** "react" browser/ toolkit/`
perl -p -i -e 's/\.nextSibling/.nextElementSibling/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js} --exclude=browser//components/newtab/** --exclude=**/vendor/** "react" browser/ toolkit/`
perl -p -i -e 's/\.previousSibling/.previousElementSibling/g' `grep -ril --include=*.{js,jsm,xul} --exclude={JSDOMParser.js,Readability.js} --exclude=browser//components/newtab/** --exclude=**/vendor/** "react" browser/ toolkit/`

diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -194,17 +194,17 @@ window._gBrowser = {
 
   get tabContainer() {
     delete this.tabContainer;
     return this.tabContainer = document.getElementById("tabbrowser-tabs");
   },
 
   get tabs() {
     delete this.tabs;
-    return this.tabs = this.tabContainer.childNodes;
+    return this.tabs = this.tabContainer.children;
   },
 
   get tabbox() {
     delete this.tabbox;
     return this.tabbox = document.getElementById("tabbrowser-tabbox");
   },
 
   get tabpanels() {
@@ -302,17 +302,17 @@ window._gBrowser = {
     for (let attribute in this._defaultBrowserAttributes) {
       this._defaultBrowserAttributes[attribute] = browser.getAttribute(attribute);
     }
 
     let tab = this.tabs[0];
     this._selectedTab = tab;
 
     let uniqueId = this._generateUniquePanelID();
-    this.tabpanels.childNodes[0].id = uniqueId;
+    this.tabpanels.children[0].id = uniqueId;
     tab.linkedPanel = uniqueId;
     tab.permanentKey = browser.permanentKey;
     tab._tPos = 0;
     tab._fullyOpen = true;
     tab.linkedBrowser = browser;
     this._tabForBrowser.set(browser, tab);
 
     // Hook the browser up with a progress listener.
@@ -528,17 +528,17 @@ window._gBrowser = {
     aTab.dispatchEvent(event);
 
     return findBar;
   },
 
   _appendStatusPanel() {
     let browser = this.selectedBrowser;
     let browserContainer = this.getBrowserContainer(browser);
-    browserContainer.insertBefore(StatusPanel.panel, browser.parentNode.nextSibling);
+    browserContainer.insertBefore(StatusPanel.panel, browser.parentNode.nextElementSibling);
   },
 
   _updateTabBarForPinnedTabs() {
     this.tabContainer._unlockTabSizing();
     this.tabContainer._positionPinnedTabs();
     this.tabContainer._updateCloseButtons();
   },
 
@@ -2995,24 +2995,24 @@ window._gBrowser = {
       remainingTabs = Array.filter(this.tabs, function(tab) {
         return !tab.closing;
       }, this);
     }
 
     // Try to find a remaining tab that comes after the given tab
     let tab = aTab;
     do {
-      tab = tab.nextSibling;
+      tab = tab.nextElementSibling;
     } while (tab && !remainingTabs.includes(tab));
 
     if (!tab) {
       tab = aTab;
 
       do {
-        tab = tab.previousSibling;
+        tab = tab.previousElementSibling;
       } while (tab && !remainingTabs.includes(tab));
     }
 
     return tab;
   },
 
   _blurTab(aTab) {
     this.selectedTab = this._findTabToBlurTo(aTab);
@@ -3535,19 +3535,19 @@ window._gBrowser = {
     this.tabContainer._setPositionalAttributes();
 
     var evt = document.createEvent("UIEvents");
     evt.initUIEvent("TabMove", true, false, window, oldPosition);
     aTab.dispatchEvent(evt);
   },
 
   moveTabForward() {
-    let nextTab = this.selectedTab.nextSibling;
+    let nextTab = this.selectedTab.nextElementSibling;
     while (nextTab && nextTab.hidden)
-      nextTab = nextTab.nextSibling;
+      nextTab = nextTab.nextElementSibling;
 
     if (nextTab)
       this.moveTabTo(this.selectedTab, nextTab._tPos);
     else if (this.arrowKeysShouldWrap)
       this.moveTabToStart();
   },
 
   /**
@@ -3602,19 +3602,19 @@ window._gBrowser = {
       // for our new tab after we've done swapBrowsersAndCloseOther.
       this.updateCurrentBrowser(true);
     }
 
     return newTab;
   },
 
   moveTabBackward() {
-    let previousTab = this.selectedTab.previousSibling;
+    let previousTab = this.selectedTab.previousElementSibling;
     while (previousTab && previousTab.hidden)
-      previousTab = previousTab.previousSibling;
+      previousTab = previousTab.previousElementSibling;
 
     if (previousTab)
       this.moveTabTo(this.selectedTab, previousTab._tPos);
     else if (this.arrowKeysShouldWrap)
       this.moveTabToEnd();
   },
 
   moveTabToStart() {
diff --git a/browser/components/downloads/content/allDownloadsView.js b/browser/components/downloads/content/allDownloadsView.js
--- a/browser/components/downloads/content/allDownloadsView.js
+++ b/browser/components/downloads/content/allDownloadsView.js
@@ -249,23 +249,23 @@ DownloadsPlacesView.prototype = {
     this._active = val;
     if (this._active)
       this._ensureVisibleElementsAreActive();
     return this._active;
   },
 
   _ensureVisibleElementsAreActive() {
     if (!this.active || this._ensureVisibleTimer ||
-        !this._richlistbox.firstChild) {
+        !this._richlistbox.firstElementChild) {
       return;
     }
 
     this._ensureVisibleTimer = setTimeout(() => {
       delete this._ensureVisibleTimer;
-      if (!this._richlistbox.firstChild) {
+      if (!this._richlistbox.firstElementChild) {
         return;
       }
 
       let rlbRect = this._richlistbox.getBoundingClientRect();
       let winUtils = window.windowUtils;
       let nodes = winUtils.nodesFromRect(rlbRect.left, rlbRect.top,
                                          0, rlbRect.width, rlbRect.height, 0,
                                          true, false);
@@ -283,23 +283,23 @@ DownloadsPlacesView.prototype = {
             lastVisibleNode = node;
           }
         }
       }
 
       // Also activate the first invisible nodes in both boundaries (that is,
       // above and below the visible area) to ensure proper keyboard navigation
       // in both directions.
-      let nodeBelowVisibleArea = lastVisibleNode && lastVisibleNode.nextSibling;
+      let nodeBelowVisibleArea = lastVisibleNode && lastVisibleNode.nextElementSibling;
       if (nodeBelowVisibleArea && nodeBelowVisibleArea._shell) {
         nodeBelowVisibleArea._shell.ensureActive();
       }
 
       let nodeAboveVisibleArea = firstVisibleNode &&
-                                 firstVisibleNode.previousSibling;
+                                 firstVisibleNode.previousElementSibling;
       if (nodeAboveVisibleArea && nodeAboveVisibleArea._shell) {
         nodeAboveVisibleArea._shell.ensureActive();
       }
     }, 10);
   },
 
   _place: "",
   get place() {
@@ -332,17 +332,17 @@ DownloadsPlacesView.prototype = {
     return this._richlistbox.controller;
   },
 
   get searchTerm() {
     return this._searchTerm;
   },
   set searchTerm(aValue) {
     if (this._searchTerm != aValue) {
-      for (let element of this._richlistbox.childNodes) {
+      for (let element of this._richlistbox.children) {
         element.hidden = !element._shell.matchesSearchTerm(aValue);
       }
       this._ensureVisibleElementsAreActive();
     }
     return this._searchTerm = aValue;
   },
 
   /**
@@ -358,17 +358,17 @@ DownloadsPlacesView.prototype = {
    * We work around this by attempting to select the first element twice,
    * once after the places data is loaded and once when the session downloads
    * data is done loading.  However, if the selection has changed in-between,
    * we assume the user has already started using the view and give up.
    */
   _ensureInitialSelection() {
     // Either they're both null, or the selection has not changed in between.
     if (this._richlistbox.selectedItem == this._initiallySelectedElement) {
-      let firstDownloadElement = this._richlistbox.firstChild;
+      let firstDownloadElement = this._richlistbox.firstElementChild;
       if (firstDownloadElement != this._initiallySelectedElement) {
         // We may be called before _ensureVisibleElementsAreActive,
         // or before the download binding is attached. Therefore, ensure the
         // first item is activated, and pass the item to the richlistbox
         // setters only at a point we know for sure the binding is attached.
         firstDownloadElement._shell.ensureActive();
         Services.tm.dispatchToMainThread(() => {
           this._richlistbox.selectedItem = firstDownloadElement;
@@ -418,17 +418,17 @@ DownloadsPlacesView.prototype = {
     let xblFields = new Map();
     for (let key of Object.getOwnPropertyNames(this._richlistbox)) {
       let value = this._richlistbox[key];
       xblFields.set(key, value);
     }
 
     let oldActiveElement = document.activeElement;
     let parentNode = this._richlistbox.parentNode;
-    let nextSibling = this._richlistbox.nextSibling;
+    let nextSibling = this._richlistbox.nextElementSibling;
     parentNode.removeChild(this._richlistbox);
     this._richlistbox.prepend(this.batchFragment);
     parentNode.insertBefore(this._richlistbox, nextSibling);
     if (oldActiveElement && oldActiveElement != document.activeElement) {
       oldActiveElement.focus();
     }
 
     for (let [key, value] of xblFields) {
@@ -464,22 +464,22 @@ DownloadsPlacesView.prototype = {
     this._viewItemsForDownloads.get(download).onChanged();
   },
 
   onDownloadRemoved(download) {
     let element = this._viewItemsForDownloads.get(download).element;
 
     // If the element was selected exclusively, select its next
     // sibling first, if not, try for previous sibling, if any.
-    if ((element.nextSibling || element.previousSibling) &&
+    if ((element.nextElementSibling || element.previousElementSibling) &&
         this._richlistbox.selectedItems &&
         this._richlistbox.selectedItems.length == 1 &&
         this._richlistbox.selectedItems[0] == element) {
-      this._richlistbox.selectItem(element.nextSibling ||
-                                   element.previousSibling);
+      this._richlistbox.selectItem(element.nextElementSibling ||
+                                   element.previousElementSibling);
     }
 
     this._richlistbox.removeItemFromSelection(element);
     element.remove();
 
     // Don't update commands and visible elements during a batch change.
     if (!this.batchFragment) {
       this._ensureVisibleElementsAreActive();
diff --git a/browser/components/preferences/in-content/main.js b/browser/components/preferences/in-content/main.js
--- a/browser/components/preferences/in-content/main.js
+++ b/browser/components/preferences/in-content/main.js
@@ -1496,18 +1496,18 @@ var gMainPane = {
   },
 
   _rebuildView() {
     let lastSelectedType = this.selectedHandlerListItem &&
                            this.selectedHandlerListItem.handlerInfoWrapper.type;
     this.selectedHandlerListItem = null;
 
     // Clear the list of entries.
-    while (this._list.childNodes.length > 1)
-      this._list.removeChild(this._list.lastChild);
+    while (this._list.children.length > 1)
+      this._list.removeChild(this._list.lastElementChild);
 
     var visibleTypes = this._visibleTypes;
 
     // If the user is filtering the list, then only show matching types.
     if (this._filter.value)
       visibleTypes = visibleTypes.filter(this._matchesFilter, this);
 
     for (let visibleType of visibleTypes) {
@@ -1574,17 +1574,17 @@ var gMainPane = {
   rebuildActionsMenu() {
     var typeItem = this._list.selectedItem;
     var handlerInfo = this.selectedHandlerListItem.handlerInfoWrapper;
     var menu = typeItem.querySelector(".actionsMenu");
     var menuPopup = menu.menupopup;
 
     // Clear out existing items.
     while (menuPopup.hasChildNodes())
-      menuPopup.removeChild(menuPopup.lastChild);
+      menuPopup.removeChild(menuPopup.lastElementChild);
 
     let internalMenuItem;
     // Add the "Preview in Firefox" option for optional internal handlers.
     if (handlerInfo instanceof InternalHandlerInfoWrapper) {
       internalMenuItem = document.createElement("menuitem");
       internalMenuItem.setAttribute("action", Ci.nsIHandlerInfo.handleInternally);
       let label = gMainPane._prefsBundle.getFormattedString("previewInApp",
         [this._brandShortName]);
@@ -1963,17 +1963,17 @@ var gMainPane = {
       // If they picked an app, we want to add the app to the menu and select it.
       // If they canceled, we want to go back to their previous selection.
       this.rebuildActionsMenu();
 
       // If the user picked a new app from the menu, select it.
       if (aHandlerApp) {
         let typeItem = this._list.selectedItem;
         let actionsMenu = typeItem.querySelector(".actionsMenu");
-        let menuItems = actionsMenu.menupopup.childNodes;
+        let menuItems = actionsMenu.menupopup.children;
         for (let i = 0; i < menuItems.length; i++) {
           let menuItem = menuItems[i];
           if (menuItem.handlerApp && menuItem.handlerApp.equals(aHandlerApp)) {
             actionsMenu.selectedIndex = i;
             this.onSelectAction(menuItem);
             break;
           }
         }
@@ -2450,17 +2450,17 @@ class HandlerListItem {
       } else {
         node.removeAttribute(name);
       }
     }
   }
 
   connectAndAppendToList(list) {
     list.appendChild(document.importNode(gHandlerListItemFragment, true));
-    this.node = list.lastChild;
+    this.node = list.lastElementChild;
     gNodeToObjectMap.set(this.node, this);
 
     this.node.querySelector(".actionsMenu").addEventListener("command",
       event => gMainPane.onSelectAction(event.originalTarget));
 
     let typeDescription = this.handlerInfoWrapper.typeDescription;
     this.setOrRemoveAttributes([
       [null, "type", this.handlerInfoWrapper.type],
diff --git a/browser/extensions/pocket/bootstrap.js b/browser/extensions/pocket/bootstrap.js
--- a/browser/extensions/pocket/bootstrap.js
+++ b/browser/extensions/pocket/bootstrap.js
@@ -281,35 +281,35 @@ var PocketContextMenu = {
     if (!menu) {
       menu = createElementWithAttrs(document, "menuitem", {
         "id": "context-pocket",
         "label": gPocketBundle.GetStringFromName("saveToPocketCmd.label"),
         "accesskey": gPocketBundle.GetStringFromName("saveToPocketCmd.accesskey"),
         "oncommand": "Pocket.savePage(gContextMenu.browser, gContextMenu.browser.currentURI.spec, gContextMenu.browser.contentTitle);"
       });
       let sibling = document.getElementById("context-savepage");
-      if (sibling.nextSibling) {
-        sibling.parentNode.insertBefore(menu, sibling.nextSibling);
+      if (sibling.nextElementSibling) {
+        sibling.parentNode.insertBefore(menu, sibling.nextElementSibling);
       } else {
         sibling.parentNode.appendChild(menu);
       }
     }
     menu.hidden = !(canPocket && showSaveCurrentPageToPocket);
 
     menu = document.getElementById("context-savelinktopocket");
     if (!menu) {
       menu = createElementWithAttrs(document, "menuitem", {
         "id": "context-savelinktopocket",
         "label": gPocketBundle.GetStringFromName("saveLinkToPocketCmd.label"),
         "accesskey": gPocketBundle.GetStringFromName("saveLinkToPocketCmd.accesskey"),
         "oncommand": "Pocket.savePage(gContextMenu.browser, gContextMenu.linkURL);"
       });
       let sibling = document.getElementById("context-savelink");
-      if (sibling.nextSibling) {
-        sibling.parentNode.insertBefore(menu, sibling.nextSibling);
+      if (sibling.nextElementSibling) {
+        sibling.parentNode.insertBefore(menu, sibling.nextElementSibling);
       } else {
         sibling.parentNode.appendChild(menu);
       }
     }
     menu.hidden = !showSaveLinkToPocket;
   }
 };
 
diff --git a/browser/modules/AsyncTabSwitcher.jsm b/browser/modules/AsyncTabSwitcher.jsm
--- a/browser/modules/AsyncTabSwitcher.jsm
+++ b/browser/modules/AsyncTabSwitcher.jsm
@@ -409,17 +409,17 @@ class AsyncTabSwitcher {
     if (this.visibleTab !== showTab) {
       this.tabbrowser._adjustFocusBeforeTabSwitch(this.visibleTab, showTab);
       this.visibleTab = showTab;
 
       this.maybeVisibleTabs.add(showTab);
 
       let tabpanels = this.tabbrowser.tabpanels;
       let showPanel = this.tabbrowser.tabContainer.getRelatedElement(showTab);
-      let index = Array.indexOf(tabpanels.childNodes, showPanel);
+      let index = Array.indexOf(tabpanels.children, showPanel);
       if (index != -1) {
         this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
         tabpanels.setAttribute("selectedIndex", index);
         if (showTab === this.requestedTab) {
           if (this._requestingTab) {
             /*
              * If _requestingTab is set, that means that we're switching the
              * visibility of the tab synchronously, and we need to wait for
diff --git a/browser/modules/test/browser/browser_PageActions.js b/browser/modules/test/browser/browser_PageActions.js
--- a/browser/modules/test/browser/browser_PageActions.js
+++ b/browser/modules/test/browser/browser_PageActions.js
@@ -172,31 +172,31 @@ add_task(async function simple() {
   Assert.deepEqual(PageActions.actionForID(action.id), action,
                    "actionForID should be action");
 
   Assert.ok(PageActions._persistedActions.ids.includes(action.id),
             "PageActions should record action in its list of seen actions");
 
   // The action's panel button should have been created.
   let panelButtonNode =
-    BrowserPageActions.mainViewBodyNode.childNodes[indexInPanel];
+    BrowserPageActions.mainViewBodyNode.children[indexInPanel];
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
   Assert.equal(panelButtonNode.id, panelButtonID, "panelButtonID");
   Assert.equal(panelButtonNode.getAttribute("label"), action.getTitle(),
                "label");
   for (let name in action.nodeAttributes) {
     Assert.ok(panelButtonNode.hasAttribute(name), "Has attribute: " + name);
     Assert.equal(panelButtonNode.getAttribute(name),
                  action.nodeAttributes[name],
                  "Equal attribute: " + name);
   }
 
   // The separator between the built-ins and non-built-ins should exist.
   let sepNode =
-    BrowserPageActions.mainViewBodyNode.childNodes[sepIndex];
+    BrowserPageActions.mainViewBodyNode.children[sepIndex];
   Assert.notEqual(sepNode, null, "sepNode");
   Assert.equal(
     sepNode.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     ),
     "sepNode.id"
   );
@@ -224,19 +224,19 @@ add_task(async function simple() {
     Assert.ok(urlbarButtonNode.hasAttribute(name), name,
               "Has attribute: " + name);
     Assert.equal(urlbarButtonNode.getAttribute(name),
                  action.nodeAttributes[name],
                  "Equal attribute: " + name);
   }
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Disable the action.  The button in the urlbar should be removed, and the
   // button in the panel should be disabled.
   action.setDisabled(true);
   urlbarButtonNode = document.getElementById(urlbarButtonID);
@@ -299,17 +299,17 @@ add_task(async function simple() {
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     )
   );
   if (initialSepIndex < 0) {
     // The separator between the built-in actions and non-built-in actions
     // should be gone now, too.
     Assert.equal(separatorNode, null, "No separator");
     Assert.ok(!BrowserPageActions.mainViewBodyNode
-              .lastChild.localName.includes("separator"),
+              .lastElementChild.localName.includes("separator"),
               "Last child should not be separator");
   } else {
     // The separator should still be present.
     Assert.notEqual(separatorNode, null, "Separator should still exist");
   }
 
   Assert.deepEqual(PageActions.actionsInPanel(window), initialActionsInPanel,
                    "Actions in panel should go back to initial");
@@ -410,19 +410,19 @@ add_task(async function withSubview() {
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The action's urlbar button should have been created.
   let urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Click the action's button in the panel.  The subview should be shown.
   Assert.equal(onSubviewShowingCount, 0,
                "onSubviewShowingCount should remain 0");
   let subviewShownPromise = promisePageActionViewShown();
@@ -523,19 +523,19 @@ add_task(async function withIframe() {
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The action's urlbar button should have been created.
   let urlbarButtonNode = document.getElementById(urlbarButtonID);
   Assert.notEqual(urlbarButtonNode, null, "urlbarButtonNode");
 
   // The button should have been inserted before the bookmark star.
-  Assert.notEqual(urlbarButtonNode.nextSibling, null, "Should be a next node");
+  Assert.notEqual(urlbarButtonNode.nextElementSibling, null, "Should be a next node");
   Assert.equal(
-    urlbarButtonNode.nextSibling.id,
+    urlbarButtonNode.nextElementSibling.id,
     PageActions.actionForID(PageActions.ACTION_ID_BOOKMARK).urlbarIDOverride,
     "Next node should be the bookmark star"
   );
 
   // Open the panel, click the action's button.
   await promiseOpenPageActionPanel();
   Assert.equal(onIframeShowingCount, 0, "onIframeShowingCount should remain 0");
   EventUtils.synthesizeMouseAtCenter(panelButtonNode, {});
@@ -644,24 +644,24 @@ add_task(async function insertBeforeActi
   Assert.equal(newBookmarkSeparatorIndex, initialBookmarkSeparatorIndex + 1,
                "newBookmarkSeparatorIndex");
 
   // The action's panel button should have been created.
   let panelButtonNode = document.getElementById(panelButtonID);
   Assert.notEqual(panelButtonNode, null, "panelButtonNode");
 
   // The button's next sibling should be the bookmark separator.
-  Assert.notEqual(panelButtonNode.nextSibling, null,
-                  "panelButtonNode.nextSibling");
+  Assert.notEqual(panelButtonNode.nextElementSibling, null,
+                  "panelButtonNode.nextElementSibling");
   Assert.equal(
-    panelButtonNode.nextSibling.id,
+    panelButtonNode.nextElementSibling.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BOOKMARK_SEPARATOR
     ),
-    "panelButtonNode.nextSibling.id"
+    "panelButtonNode.nextElementSibling.id"
   );
 
   // The separator between the built-in and non-built-in actions should not have
   // been created.
   Assert.equal(
     document.getElementById(
       BrowserPageActions.panelButtonNodeIDForActionID(
         PageActions.ACTION_ID_BUILT_IN_SEPARATOR
@@ -719,33 +719,33 @@ add_task(async function multipleNonBuilt
   await promisePageActionPanelHidden();
 
   // Check the button nodes in the panel.
   let expectedIndex = 1;
   let buttonNode = document.getElementById(
     BrowserPageActions.panelButtonNodeIDForActionID(idPrefix + expectedIndex)
   );
   Assert.notEqual(buttonNode, null, "buttonNode");
-  Assert.notEqual(buttonNode.previousSibling, null,
-                  "buttonNode.previousSibling");
+  Assert.notEqual(buttonNode.previousElementSibling, null,
+                  "buttonNode.previousElementSibling");
   Assert.equal(
-    buttonNode.previousSibling.id,
+    buttonNode.previousElementSibling.id,
     BrowserPageActions.panelButtonNodeIDForActionID(
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR
     ),
-    "buttonNode.previousSibling.id"
+    "buttonNode.previousElementSibling.id"
   );
   for (let i = 0; i < actions.length; i++) {
     Assert.notEqual(buttonNode, null, "buttonNode at index: " + i);
     Assert.equal(
       buttonNode.id,
       BrowserPageActions.panelButtonNodeIDForActionID(idPrefix + expectedIndex),
       "buttonNode.id at index: " + i
     );
-    buttonNode = buttonNode.nextSibling;
+    buttonNode = buttonNode.nextElementSibling;
     expectedIndex++;
   }
   Assert.equal(buttonNode, null, "Nothing should come after the last button");
 
   for (let action of actions) {
     action.remove();
   }
 
@@ -778,17 +778,17 @@ add_task(async function nonBuiltFirst() 
   Assert.deepEqual(PageActions.actions.map(a => a.id), [],
                    "PageActions.actions should be empty");
   Assert.deepEqual(PageActions._builtInActions.map(a => a.id), [],
                    "PageActions._builtInActions should be empty");
   Assert.deepEqual(PageActions._nonBuiltInActions.map(a => a.id), [],
                    "PageActions._nonBuiltInActions should be empty");
 
   // Check the panel.
-  Assert.equal(BrowserPageActions.mainViewBodyNode.childNodes.length, 0,
+  Assert.equal(BrowserPageActions.mainViewBodyNode.children.length, 0,
                "All nodes should be gone");
 
   // Add a non-built-in action.
   let action = PageActions.addAction(new PageActions.Action({
     id: "test-nonBuiltFirst",
     title: "Test nonBuiltFirst",
   }));
 
@@ -800,17 +800,17 @@ add_task(async function nonBuiltFirst() 
   Assert.deepEqual(PageActions._nonBuiltInActions.map(a => a.id), [action.id],
                    "Action should be in PageActions._nonBuiltInActions");
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     [BrowserPageActions.panelButtonNodeIDForActionID(action.id)],
     "Action should be in panel"
   );
 
   // Now add back all the actions.
   for (let a of initialActions) {
     PageActions.addAction(a);
   }
@@ -842,17 +842,17 @@ add_task(async function nonBuiltFirst() 
     PageActions.actionsInPanel(window).map(a => a.id),
     initialActionsInPanel.map(a => a.id).concat(
       [PageActions.ACTION_ID_BUILT_IN_SEPARATOR],
       [action.id]
     ),
     "All actions should be in PageActions.actionsInPanel()"
   );
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat(
       [PageActions.ACTION_ID_BUILT_IN_SEPARATOR],
       [action.id]
     ).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Panel should contain all actions"
   );
 
   // Remove the test action.
@@ -880,17 +880,17 @@ add_task(async function nonBuiltFirst() 
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
     PageActions.actionsInPanel(window).map(a => a.id),
     initialActionsInPanel.map(a => a.id),
     "Action should no longer be in PageActions.actionsInPanel()"
   );
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => BrowserPageActions.panelButtonNodeIDForActionID(a.id)),
     "Action should no longer be in panel"
   );
 });
 
 
 // Makes sure that urlbar nodes appear in the correct order in a new window.
 add_task(async function urlbarOrderNewWindow() {
@@ -950,19 +950,19 @@ add_task(async function urlbarOrderNewWi
   // not appear in the new window (or any window at this point).
   ids = ids.filter(id => PageActions.actionForID(id));
 
   // Open the new window.
   let win = await BrowserTestUtils.openNewBrowserWindow();
 
   // Collect its urlbar nodes.
   let actualUrlbarNodeIDs = [];
-  for (let node = win.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = win.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
 
   // Now check that they're in the right order.
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     ids.map(id => win.BrowserPageActions.urlbarButtonNodeIDForActionID(id)),
     "Expected actions in new window's urlbar"
@@ -1030,19 +1030,19 @@ add_task(async function migrate1() {
   let win = await BrowserTestUtils.openNewBrowserWindow();
   await BrowserTestUtils.openNewForegroundTab({
     gBrowser: win.gBrowser,
     url: "http://example.com/",
   });
 
   // Collect its urlbar nodes.
   let actualUrlbarNodeIDs = [];
-  for (let node = win.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = win.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
 
   // Now check that they're in the right order.
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     orderedIDs.map(id => win.BrowserPageActions.urlbarButtonNodeIDForActionID(id)),
     "Expected actions in new window's urlbar"
@@ -1133,32 +1133,32 @@ add_task(async function perWindowState()
   Assert.deepEqual(
     PageActions.actionsInUrlbar(newWindow).map(a => a.id),
     actionsInUrlbar.map(a => a.id).filter(id => id != action.id),
     "PageActions.actionsInUrlbar: new window should have all actions in urlbar except the test action"
   );
 
   // Check the urlbar nodes for the old window.
   let actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     actionsInUrlbar.map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "Old window should have all nodes in urlbar"
   );
 
   // Check the urlbar nodes for the new window.
   actualUrlbarNodeIDs = [];
-  for (let node = newWindow.BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = newWindow.BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     actionsInUrlbar.filter(a => a.id != action.id).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "New window should have all nodes in urlbar except for the test action's"
   );
 
@@ -1200,19 +1200,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     [testAction].concat(initialActionsInUrlbar).map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order: testAction followed by all initial actions"
   );
 
   // Check the nodes in the urlbar.
   let actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     [testAction].concat(initialActionsInUrlbar).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order: testAction followed by all initial actions"
   );
 
@@ -1223,19 +1223,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     initialActionsInUrlbar.map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order after removing test action: all initial actions"
   );
 
   // Check the nodes in the urlbar.
   actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     initialActionsInUrlbar.map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order after removing test action: all initial actions"
   );
 
@@ -1252,19 +1252,19 @@ add_task(async function removeRetainStat
   Assert.deepEqual(
     PageActions.actionsInUrlbar(window).map(a => a.id),
     [testAction].concat(initialActionsInUrlbar).map(a => a.id),
     "PageActions.actionsInUrlbar should be in expected order after re-adding test action: testAction followed by all initial actions"
   );
 
   // Check the nodes in the urlbar.
   actualUrlbarNodeIDs = [];
-  for (let node = BrowserPageActions.mainButtonNode.nextSibling;
+  for (let node = BrowserPageActions.mainButtonNode.nextElementSibling;
        node;
-       node = node.nextSibling) {
+       node = node.nextElementSibling) {
     actualUrlbarNodeIDs.push(node.id);
   }
   Assert.deepEqual(
     actualUrlbarNodeIDs,
     [testAction].concat(initialActionsInUrlbar).map(a => BrowserPageActions.urlbarButtonNodeIDForActionID(a.id)),
     "urlbar nodes should be in expected order after re-adding test action: testAction followed by all initial actions"
   );
 
@@ -1502,17 +1502,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   Assert.equal(onPlacedInPanelCount, 1,
@@ -1529,17 +1529,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should revert to initial"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel
       .map(a => BrowserPageActions.panelButtonNodeIDForActionID(a.id)),
     "Actions in panel should be correct"
   );
 
   // Enable the action.  It should be added back to the panel.
   action.setDisabled(false, window);
 
@@ -1552,17 +1552,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   Assert.equal(onPlacedInPanelCount, 2,
@@ -1587,17 +1587,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
@@ -1619,17 +1619,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
 
   // Enable the action again.  It should be added back to the panel.
@@ -1646,17 +1646,17 @@ add_task(async function transient() {
     "PageActions.actionsInPanel() should be updated"
   );
 
   // Check the panel.
   await promiseOpenPageActionPanel();
   EventUtils.synthesizeMouseAtCenter(BrowserPageActions.mainButtonNode, {});
   await promisePageActionPanelHidden();
   Assert.deepEqual(
-    Array.map(BrowserPageActions.mainViewBodyNode.childNodes, n => n.id),
+    Array.map(BrowserPageActions.mainViewBodyNode.children, n => n.id),
     initialActionsInPanel.map(a => a.id).concat([
       PageActions.ACTION_ID_BUILT_IN_SEPARATOR,
       otherAction.id,
       PageActions.ACTION_ID_TRANSIENT_SEPARATOR,
       action.id,
     ]).map(id => BrowserPageActions.panelButtonNodeIDForActionID(id)),
     "Actions in panel should be correct"
   );
@@ -1744,25 +1744,25 @@ function promisePageActionViewShown() {
     return panelViewNode;
   });
 }
 
 function promisePageActionViewChildrenVisible(panelViewNode) {
   info("promisePageActionViewChildrenVisible waiting for a child node to be visible");
   let dwu = window.windowUtils;
   return BrowserTestUtils.waitForCondition(() => {
-    let bodyNode = panelViewNode.firstChild;
-    for (let childNode of bodyNode.childNodes) {
+    let bodyNode = panelViewNode.firstElementChild;
+    for (let childNode of bodyNode.children) {
       let bounds = dwu.getBoundsWithoutFlushing(childNode);
       if (bounds.width > 0 && bounds.height > 0) {
         return true;
       }
     }
     return false;
   });
 }
 
 function collectContextMenuItems() {
   let contextMenu = document.getElementById("pageActionContextMenu");
-  return Array.filter(contextMenu.childNodes, node => {
+  return Array.filter(contextMenu.children, node => {
     return window.getComputedStyle(node).visibility == "visible";
   });
 }
diff --git a/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js b/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
--- a/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
+++ b/toolkit/content/tests/browser/browser_autoplay_policy_request_permission.js
@@ -154,17 +154,17 @@ async function testAutoplayUnknownPermis
     ok(promptShowing(), "Should now be showing permission prompt");
 
     // Click the appropriate doorhanger button.
     if (args.button == "allow") {
       info("Clicking allow button");
       PopupNotifications.panel.firstElementChild.button.click();
     } else if (args.button == "block") {
       info("Clicking block button");
-      PopupNotifications.panel.firstChild.secondaryButton.click();
+      PopupNotifications.panel.firstElementChild.secondaryButton.click();
     } else {
       ok(false, "Invalid button field");
     }
     // Check that the video started playing.
     await checkVideoDidPlay(browser, args);
 
     // Reset permission.
     SitePermissions.remove(browser.currentURI, "autoplay-media");
diff --git a/toolkit/mozapps/update/nsUpdateService.js b/toolkit/mozapps/update/nsUpdateService.js
--- a/toolkit/mozapps/update/nsUpdateService.js
+++ b/toolkit/mozapps/update/nsUpdateService.js
@@ -1219,18 +1219,18 @@ function Update(update) {
 
   // Null <update>, assume this is a message container and do no
   // further initialization
   if (!update) {
     return;
   }
 
   let patch;
-  for (let i = 0; i < update.childNodes.length; ++i) {
-    let patchElement = update.childNodes.item(i);
+  for (let i = 0; i < update.children.length; ++i) {
+    let patchElement = update.children.item(i);
     if (patchElement.nodeType != patchElement.ELEMENT_NODE ||
         patchElement.localName != "patch") {
       continue;
     }
 
     try {
       patch = new UpdatePatch(patchElement);
     } catch (e) {
@@ -2578,19 +2578,19 @@ UpdateManager.prototype = {
     var fileStream = Cc["@mozilla.org/network/file-input-stream;1"].
                      createInstance(Ci.nsIFileInputStream);
     fileStream.init(file, FileUtils.MODE_RDONLY, FileUtils.PERMS_FILE, 0);
     try {
       var parser = new DOMParser();
       var doc = parser.parseFromStream(fileStream, "UTF-8",
                                        fileStream.available(), "text/xml");
 
-      var updateCount = doc.documentElement.childNodes.length;
+      var updateCount = doc.documentElement.children.length;
       for (var i = 0; i < updateCount; ++i) {
-        var updateElement = doc.documentElement.childNodes.item(i);
+        var updateElement = doc.documentElement.children.item(i);
         if (updateElement.nodeType != updateElement.ELEMENT_NODE ||
             updateElement.localName != "update")
           continue;
 
         let update;
         try {
           update = new Update(updateElement);
         } catch (e) {
@@ -3017,18 +3017,18 @@ Checker.prototype = {
 
     if (updatesElement.nodeName != "updates") {
       LOG("Checker:_updates get - unexpected node name!");
       throw new Error("Unexpected node name, expected: updates, got: " +
                       updatesElement.nodeName);
     }
 
     var updates = [];
-    for (var i = 0; i < updatesElement.childNodes.length; ++i) {
-      var updateElement = updatesElement.childNodes.item(i);
+    for (var i = 0; i < updatesElement.children.length; ++i) {
+      var updateElement = updatesElement.children.item(i);
       if (updateElement.nodeType != updateElement.ELEMENT_NODE ||
           updateElement.localName != "update")
         continue;
 
       let update;
       try {
         update = new Update(updateElement);
       } catch (e) {
