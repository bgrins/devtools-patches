# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  3f12efd6b89593936e784746cce19a464847fc48

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -15,31 +15,65 @@
 // from MainProcessSingleton, to handle pages that can open both before and after
 // MainProcessSingleton starts. See Bug 1501845.
 if (window.MozXULElement) {
   return;
 }
 
 const {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
 const {AppConstants} = ChromeUtils.import("resource://gre/modules/AppConstants.jsm");
-const instrumentClasses = false; // Flip this to get logging for perf data at startup
+const instrumentClasses = true; // Flip this to get logging for perf data at startup
 const instrumentedClassesToLogAtStartup = new Set();
+const baseClasses = new Set();
 
 let define = window.customElements.define;
 window.customElements.define = function(name, c, opts) {
-  instrumentClass(c);
+  instrumentCustomElementClass(c);
   return define.call(this, name, c, opts);
 };
 
-function instrumentClass(c) {
+function instrumentCustomElementClass(c) {
   if (!instrumentClasses) {
     return;
   }
+
+  // Climb up prototype chain to see if we inherit from a MozElement.
+  // Keep track of all
+  let inheritsFromBase = false;
+  let classesToInstrument = [];
+  let proto = Object.getPrototypeOf(c);
+  while (proto) {
+    classesToInstrument.push(proto);
+    if (baseClasses.has(proto)) {
+      inheritsFromBase = true;
+      break;
+    }
+    proto = Object.getPrototypeOf(proto);
+  }
+
+  if (!inheritsFromBase && !baseClasses.has(c)) {
+    console.trace("Found one that doesn't inherit from base", c);
+    return;
+  }
+  classesToInstrument.reverse().forEach(c => {
+    if (!instrumentedClassesToLogAtStartup.has(c)) {
+      console.log("Recusively instrumenting", c.name);
+      instrumentIndividualClass(c);
+    }
+  });
+
+  instrumentIndividualClass(c);
+}
+
+function instrumentIndividualClass(c) {
+  if (instrumentedClassesToLogAtStartup.has(c)) {
+    return;
+  }
+  instrumentedClassesToLogAtStartup.add(c);
   let data = {};
-  instrumentedClassesToLogAtStartup.add(c);
 
   function overrideFunction(p, fn) {
     return function() {
       if (!data[p]) {
         data[p] = {time: 0, calls: 0};
       }
       data[p].calls++;
       let n = performance.now();
@@ -99,18 +133,16 @@ function instrumentClass(c) {
         clonedData[d].timePerCall = clonedData[d].time / clonedData[d].calls;
       }
 
       // Add a spaced-out final row with summed up totals
       clonedData["\ntotals"]  = { time: `\n${totalTime}`, calls: `\n${totalCalls}`, timePerCall: `\n${totalTime / totalCalls}` };
       return clonedData;
     },
   });
-
-  return c;
 }
 
 // The listener of DOMContentLoaded must be set on window, rather than
 // document, because the window can go away before the event is fired.
 // In that case, we don't want to initialize anything, otherwise we
 // may be leaking things because they will never be destroyed after.
 let gIsDOMContentLoaded = false;
 const gElementsPendingConnection = new Set();
@@ -148,18 +180,16 @@ window.addEventListener("DOMContentLoade
   }
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 const MozElements = {};
 
-MozElements.instrumentClass = instrumentClass;
-
 const MozElementMixin = Base => {
 let c = class extends Base {
   /*
    * A declarative way to wire up attribute inheritance and automatically generate
    * the `observedAttributes` getter.  For example, if you returned:
    *    {
    *      ".foo": "bar,baz=bat"
    *    }
@@ -479,17 +509,17 @@ let c = class extends Base {
       if (cls.prototype.customInterfaces.some(iface => iface.equals(ifaceToCheck))) {
         return getInterfaceProxy(this);
       }
       return null;
     };
   }
 };
 Object.defineProperty(c, "name", {value: `Moz${Base.name}`});
-instrumentClass(c);
+baseClasses.add(c);
 return c;
 };
 
 const MozXULElement = MozElementMixin(XULElement);
 
 /**
  * Given an object, add a proxy that reflects interface implementations
  * onto the object itself.
