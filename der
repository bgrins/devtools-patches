# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  7974d2f4d3d5cc28ad0409c1dbb3dbed8ad453e1
Bug 1608278 - Export DER as DERDecoder to avoid duplicate DER global in DER.jsm

We need to stop relying on the global `this` in order to support ES Modules.
In this case we have `this.DER` (which is exported) and `class DER` in the
same module.

Because of this, changing `this.DER` to `const DER` would lead to an error.
So this change renames the class to avoid the conflict.

diff --git a/security/manager/ssl/DER.jsm b/security/manager/ssl/DER.jsm
--- a/security/manager/ssl/DER.jsm
+++ b/security/manager/ssl/DER.jsm
@@ -5,18 +5,18 @@
 "use strict";
 
 // A minimal ASN.1 DER decoder. Supports input lengths up to 65539 (one byte for
 // the outer tag, one byte for the 0x82 length-length indicator, two bytes
 // indicating a contents length of 65535, and then the 65535 bytes of contents).
 // Intended to be used like so:
 //
 // let bytes = <an array of bytes describing a SEQUENCE OF INTEGER>;
-// let der = new DER.DER(bytes);
-// let contents = new DER.DER(der.readTagAndGetContents(DER.SEQUENCE));
+// let der = new DER.DERDecoder(bytes);
+// let contents = new DER.DERDecoder(der.readTagAndGetContents(DER.SEQUENCE));
 // while (!contents.atEnd()) {
 //   let integerBytes = contents.readTagAndGetContents(DER.INTEGER);
 //   <... do something with integerBytes ...>
 // }
 // der.assertAtEnd();
 //
 // For CHOICE, use readTLVChoice and pass an array of acceptable tags.
 // The convenience function readBIT_STRING is provided to handle the unused bits
@@ -78,17 +78,17 @@ class BitString {
    * @return {Number[]} an array of bytes representing the contents
    */
   get contents() {
     return this._contents;
   }
 }
 
 /** Class representing DER-encoded data. Provides methods for decoding it. */
-class DER {
+class DERDecoder {
   /**
    * @param {Number[]} bytes an array of bytes representing the encoded data
    */
   constructor(bytes) {
     // Reject non-array inputs.
     if (!Array.isArray(bytes)) {
       throw new Error(ERROR_INVALID_INPUT);
     }
@@ -294,27 +294,27 @@ class DER {
       throw new Error(
         `unexpected tag: found ${tag} instead of one of ${tagList}`
       );
     }
     return this._readExpectedTLV(tag);
   }
 }
 
-this.DER = {
+var DER = {
   UNIVERSAL,
   CONSTRUCTED,
   CONTEXT_SPECIFIC,
   INTEGER,
   BIT_STRING,
   NULL,
   OBJECT_IDENTIFIER,
   PrintableString,
   TeletexString,
   IA5String,
   UTCTime,
   GeneralizedTime,
   UTF8String,
   SEQUENCE,
   SET,
-  DER,
+  DERDecoder,
 };
-this.EXPORTED_SYMBOLS = ["DER"];
+var EXPORTED_SYMBOLS = ["DER"];
diff --git a/security/manager/ssl/X509.jsm b/security/manager/ssl/X509.jsm
--- a/security/manager/ssl/X509.jsm
+++ b/security/manager/ssl/X509.jsm
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-var { DER } = ChromeUtils.import("resource://gre/modules/psm/DER.jsm", null);
+var { DER } = ChromeUtils.import("resource://gre/modules/psm/DER.jsm");
 
 const ERROR_UNSUPPORTED_ASN1 = "unsupported asn.1";
 const ERROR_TIME_NOT_VALID = "Time not valid";
 const ERROR_LIBRARY_FAILURE = "library failure";
 
 const X509v3 = 2;
 
 /**
@@ -113,44 +113,44 @@ class DecodedDER {
 
   /**
    * Public interface to be called to parse all data. Calls parseOverride inside
    * a try/catch block. If an exception is thrown, stashes the error, which can
    * be obtained via the error getter (above).
    * @param {Number[]} bytes encoded DER to be decoded
    */
   parse(bytes) {
-    this._der = new DER.DER(bytes);
+    this._der = new DER.DERDecoder(bytes);
     try {
       this.parseOverride();
     } catch (e) {
       this._error = e;
     }
   }
 }
 
 /**
  * Helper function for reading the next SEQUENCE out of a DER and creating a new
  * DER out of the resulting bytes.
  * @param {DER} der the underlying DER object
  * @return {DER} the contents of the SEQUENCE
  */
 function readSEQUENCEAndMakeDER(der) {
-  return new DER.DER(der.readTagAndGetContents(DER.SEQUENCE));
+  return new DER.DERDecoder(der.readTagAndGetContents(DER.SEQUENCE));
 }
 
 /**
  * Helper function for reading the next item identified by tag out of a DER and
  * creating a new DER out of the resulting bytes.
  * @param {DER} der the underlying DER object
  * @param {Number} tag the expected next tag in the DER
  * @return {DER} the contents of the tag
  */
 function readTagAndMakeDER(der, tag) {
-  return new DER.DER(der.readTagAndGetContents(tag));
+  return new DER.DERDecoder(der.readTagAndGetContents(tag));
 }
 
 // Certificate  ::=  SEQUENCE  {
 //      tbsCertificate       TBSCertificate,
 //      signatureAlgorithm   AlgorithmIdentifier,
 //      signatureValue       BIT STRING  }
 class Certificate extends DecodedDER {
   constructor() {
diff --git a/security/manager/ssl/tests/unit/test_der.js b/security/manager/ssl/tests/unit/test_der.js
--- a/security/manager/ssl/tests/unit/test_der.js
+++ b/security/manager/ssl/tests/unit/test_der.js
@@ -6,236 +6,236 @@
 // Tests DER.jsm functionality.
 
 // Until DER.jsm is actually used in production code, this is where we have to
 // import it from.
 var { DER } = ChromeUtils.import("resource://gre/modules/psm/DER.jsm", null);
 
 function run_simple_tests() {
   throws(
-    () => new DER.DER("this is not an array"),
+    () => new DER.DERDecoder("this is not an array"),
     /invalid input/,
     "should throw given non-array input"
   );
   throws(
-    () => new DER.DER([0, "invalid input", 1]),
+    () => new DER.DERDecoder([0, "invalid input", 1]),
     /invalid input/,
     "should throw given non-byte data (string case)"
   );
   throws(
-    () => new DER.DER([31, 1, {}]),
+    () => new DER.DERDecoder([31, 1, {}]),
     /invalid input/,
     "should throw given non-byte data (object case)"
   );
   throws(
-    () => new DER.DER([0.1, 3, 1]),
+    () => new DER.DERDecoder([0.1, 3, 1]),
     /invalid input/,
     "should throw given non-byte data (non-integer case)"
   );
   throws(
-    () => new DER.DER([1, 3, -1]),
+    () => new DER.DERDecoder([1, 3, -1]),
     /invalid input/,
     "should throw given non-byte data (negative integer case)"
   );
   throws(
-    () => new DER.DER([1, 300, 79]),
+    () => new DER.DERDecoder([1, 300, 79]),
     /invalid input/,
     "should throw given non-byte data (large integer case)"
   );
 
-  let testReadByte = new DER.DER([0x0a, 0x0b]);
+  let testReadByte = new DER.DERDecoder([0x0a, 0x0b]);
   equal(testReadByte.readByte(), 0x0a, "should read 0x0a");
   equal(testReadByte.readByte(), 0x0b, "should read 0x0b");
   throws(
     () => testReadByte.readByte(),
     /data truncated/,
     "reading more data than is available should fail"
   );
 
-  let testReadBytes = new DER.DER([0x0c, 0x0d, 0x0e]);
+  let testReadBytes = new DER.DERDecoder([0x0c, 0x0d, 0x0e]);
   deepEqual(
     testReadBytes.readBytes(3),
     [0x0c, 0x0d, 0x0e],
     "should read correct sequence of bytes"
   );
 
-  let testReadNegativeBytes = new DER.DER([0xff, 0xaf]);
+  let testReadNegativeBytes = new DER.DERDecoder([0xff, 0xaf]);
   throws(
     () => testReadNegativeBytes.readBytes(-4),
     /invalid length/,
     "reading a negative number of bytes should fail"
   );
 
-  let testReadZeroBytes = new DER.DER([]);
+  let testReadZeroBytes = new DER.DERDecoder([]);
   equal(
     testReadZeroBytes.readBytes(0).length,
     0,
     "reading zero bytes should result in a zero-length array"
   );
 
-  let testReadTooManyBytes = new DER.DER([0xab, 0xcd, 0xef]);
+  let testReadTooManyBytes = new DER.DERDecoder([0xab, 0xcd, 0xef]);
   throws(
     () => testReadTooManyBytes.readBytes(4),
     /data truncated/,
     "reading too many bytes should fail"
   );
 
-  let testSEQUENCE = new DER.DER([0x30, 0x01, 0x01]);
+  let testSEQUENCE = new DER.DERDecoder([0x30, 0x01, 0x01]);
   let content = testSEQUENCE.readTagAndGetContents(DER.SEQUENCE);
   equal(content.length, 1, "content should have length 1");
   equal(content[0], 1, "value of content should be [1]");
   ok(testSEQUENCE.atEnd(), "testSEQUENCE should be at the end of its input");
   testSEQUENCE.assertAtEnd();
 
   // The length purports to be 4 bytes, but there are only 2 available.
-  let truncatedSEQUENCE = new DER.DER([0x30, 0x04, 0x00, 0x00]);
+  let truncatedSEQUENCE = new DER.DERDecoder([0x30, 0x04, 0x00, 0x00]);
   throws(
     () => truncatedSEQUENCE.readTagAndGetContents(DER.SEQUENCE),
     /data truncated/,
     "should get 'data truncated' error"
   );
 
   // With 2 bytes of content, there is 1 remaining after reading the content.
-  let extraDataSEQUENCE = new DER.DER([0x30, 0x02, 0xab, 0xcd, 0xef]);
+  let extraDataSEQUENCE = new DER.DERDecoder([0x30, 0x02, 0xab, 0xcd, 0xef]);
   content = extraDataSEQUENCE.readTagAndGetContents(DER.SEQUENCE);
   equal(content.length, 2, "content should have length 2");
   deepEqual(content, [0xab, 0xcd], "value of content should be [0xab, 0xcd]");
   ok(
     !extraDataSEQUENCE.atEnd(),
     "extraDataSEQUENCE should not be at the end of its input"
   );
   throws(
     () => extraDataSEQUENCE.assertAtEnd(),
     /extra data/,
     "should get 'extra data' error"
   );
 
   // The length of 0x81 0x01 is invalid because it could be encoded as just
   // 0x01, which is shorter.
-  let invalidLengthSEQUENCE1 = new DER.DER([0x30, 0x81, 0x01, 0x00]);
+  let invalidLengthSEQUENCE1 = new DER.DERDecoder([0x30, 0x81, 0x01, 0x00]);
   throws(
     () => invalidLengthSEQUENCE1.readTagAndGetContents(DER.SEQUENCE),
     /invalid length/,
     "should get 'invalid length' error"
   );
 
   // Similarly, 0x82 0x00 0x01 could be encoded as just 0x01, which is shorter.
-  let invalidLengthSEQUENCE2 = new DER.DER([0x30, 0x82, 0x00, 0x01, 0x00]);
+  let invalidLengthSEQUENCE2 = new DER.DERDecoder([0x30, 0x82, 0x00, 0x01, 0x00]);
   throws(
     () => invalidLengthSEQUENCE2.readTagAndGetContents(DER.SEQUENCE),
     /invalid length/,
     "should get 'invalid length' error"
   );
 
   // Lengths requiring 4 bytes to encode are not supported.
-  let unsupportedLengthSEQUENCE = new DER.DER([0x30, 0x83, 0x01, 0x01, 0x01]);
+  let unsupportedLengthSEQUENCE = new DER.DERDecoder([0x30, 0x83, 0x01, 0x01, 0x01]);
   throws(
     () => unsupportedLengthSEQUENCE.readTagAndGetContents(DER.SEQUENCE),
     /unsupported length/,
     "should get 'unsupported length' error"
   );
 
   // Indefinite lengths are not supported (and aren't DER anyway).
-  let unsupportedASN1SEQUENCE = new DER.DER([0x30, 0x80, 0x01, 0x00, 0x00]);
+  let unsupportedASN1SEQUENCE = new DER.DERDecoder([0x30, 0x80, 0x01, 0x00, 0x00]);
   throws(
     () => unsupportedASN1SEQUENCE.readTagAndGetContents(DER.SEQUENCE),
     /unsupported asn.1/,
     "should get 'unsupported asn.1' error"
   );
 
-  let unexpectedTag = new DER.DER([0x31, 0x01, 0x00]);
+  let unexpectedTag = new DER.DERDecoder([0x31, 0x01, 0x00]);
   throws(
     () => unexpectedTag.readTagAndGetContents(DER.SEQUENCE),
     /unexpected tag/,
     "should get 'unexpected tag' error"
   );
 
-  let readTLVTestcase = new DER.DER([0x02, 0x03, 0x45, 0x67, 0x89]);
+  let readTLVTestcase = new DER.DERDecoder([0x02, 0x03, 0x45, 0x67, 0x89]);
   let bytes = readTLVTestcase.readTLV();
   deepEqual(
     bytes,
     [0x02, 0x03, 0x45, 0x67, 0x89],
     "bytes read with readTLV should be equal to expected value"
   );
 
-  let peekTagTestcase = new DER.DER([0x30, 0x01, 0x00]);
+  let peekTagTestcase = new DER.DERDecoder([0x30, 0x01, 0x00]);
   ok(
     peekTagTestcase.peekTag(DER.SEQUENCE),
     "peekTag should return true for peeking with a SEQUENCE at a SEQUENCE"
   );
   ok(
     !peekTagTestcase.peekTag(DER.SET),
     "peekTag should return false for peeking with a SET at a SEQUENCE"
   );
   peekTagTestcase.readTLV();
   ok(
     !peekTagTestcase.peekTag(DER.SEQUENCE),
     "peekTag should return false for peeking at a DER with no more data"
   );
 
-  let tlvChoiceTestcase = new DER.DER([0x31, 0x02, 0xaa, 0xbb]);
+  let tlvChoiceTestcase = new DER.DERDecoder([0x31, 0x02, 0xaa, 0xbb]);
   let tlvChoiceContents = tlvChoiceTestcase.readTLVChoice([DER.NULL, DER.SET]);
   deepEqual(
     tlvChoiceContents,
     [0x31, 0x02, 0xaa, 0xbb],
     "readTLVChoice should return expected bytes"
   );
 
-  let tlvChoiceNoMatchTestcase = new DER.DER([0x30, 0x01, 0xff]);
+  let tlvChoiceNoMatchTestcase = new DER.DERDecoder([0x30, 0x01, 0xff]);
   throws(
     () => tlvChoiceNoMatchTestcase.readTLVChoice([DER.NULL, DER.SET]),
     /unexpected tag/,
     "readTLVChoice should throw if no matching tag is found"
   );
 }
 
 function run_bit_string_tests() {
-  let bitstringDER = new DER.DER([0x03, 0x04, 0x03, 0x01, 0x02, 0xf8]);
+  let bitstringDER = new DER.DERDecoder([0x03, 0x04, 0x03, 0x01, 0x02, 0xf8]);
   let bitstring = bitstringDER.readBIT_STRING();
   equal(bitstring.unusedBits, 3, "BIT STRING should have 3 unused bits");
   deepEqual(
     bitstring.contents,
     [0x01, 0x02, 0xf8],
     "BIT STRING should have expected contents"
   );
 
-  let bitstringTooManyUnusedBits = new DER.DER([0x03, 0x02, 0x08, 0x00]);
+  let bitstringTooManyUnusedBits = new DER.DERDecoder([0x03, 0x02, 0x08, 0x00]);
   throws(
     () => bitstringTooManyUnusedBits.readBIT_STRING(),
     /invalid BIT STRING encoding/,
     "BIT STRING with too many unused bits should throw"
   );
 
   // A BIT STRING must have the unused bits byte, and so its length must be at
   // least one.
-  let bitstringMissingUnusedBits = new DER.DER([0x03, 0x00]);
+  let bitstringMissingUnusedBits = new DER.DERDecoder([0x03, 0x00]);
   throws(
     () => bitstringMissingUnusedBits.readBIT_STRING(),
     /invalid BIT STRING encoding/,
     "BIT STRING with missing unused bits (and no contents) should throw"
   );
 
   // The minimal BIT STRING is 03 01 00 (zero bits of padding and zero bytes of
   // content).
-  let minimalBitstringDER = new DER.DER([0x03, 0x01, 0x00]);
+  let minimalBitstringDER = new DER.DERDecoder([0x03, 0x01, 0x00]);
   let minimalBitstring = minimalBitstringDER.readBIT_STRING();
   equal(
     minimalBitstring.unusedBits,
     0,
     "minimal BIT STRING should have 0 unused bits"
   );
   equal(
     minimalBitstring.contents.length,
     0,
     "minimal BIT STRING should have empty contents"
   );
 
   // However, a BIT STRING with zero bytes of content can't have any padding,
   // because that makes no sense.
-  let noContentsPaddedBitstringDER = new DER.DER([0x03, 0x01, 0x03]);
+  let noContentsPaddedBitstringDER = new DER.DERDecoder([0x03, 0x01, 0x03]);
   throws(
     () => noContentsPaddedBitstringDER.readBIT_STRING(),
     /invalid BIT STRING encoding/,
     "BIT STRING with no contents with non-zero padding should throw"
   );
 }
 
 function run_compound_tests() {
@@ -264,47 +264,47 @@ function run_compound_tests() {
     0x06, //   SEQUENCE
     0x02,
     0x02,
     0x00,
     0xff, //     INTEGER
     0x05,
     0x00,
   ]; //     NULL
-  let der = new DER.DER(derBytes);
-  let contents = new DER.DER(der.readTagAndGetContents(DER.SEQUENCE));
+  let der = new DER.DERDecoder(derBytes);
+  let contents = new DER.DERDecoder(der.readTagAndGetContents(DER.SEQUENCE));
   let firstINTEGER = contents.readTagAndGetContents(DER.INTEGER);
   deepEqual(
     firstINTEGER,
     [0x77, 0xff],
     "first INTEGER should have expected value"
   );
   let oid = contents.readTagAndGetContents(DER.OBJECT_IDENTIFIER);
   deepEqual(
     oid,
     [0x2b, 0x01, 0x01],
     "OBJECT IDENTIFIER should have expected value"
   );
 
-  let firstNested = new DER.DER(contents.readTagAndGetContents(DER.SEQUENCE));
+  let firstNested = new DER.DERDecoder(contents.readTagAndGetContents(DER.SEQUENCE));
   let firstNestedNULL = firstNested.readTagAndGetContents(DER.NULL);
   equal(
     firstNestedNULL.length,
     0,
     "first nested NULL should have expected value (empty array)"
   );
   let firstNestedINTEGER = firstNested.readTagAndGetContents(DER.INTEGER);
   deepEqual(
     firstNestedINTEGER,
     [0x45, 0x46, 0x47],
     "first nested INTEGER should have expected value"
   );
   firstNested.assertAtEnd();
 
-  let secondNested = new DER.DER(contents.readTagAndGetContents(DER.SEQUENCE));
+  let secondNested = new DER.DERDecoder(contents.readTagAndGetContents(DER.SEQUENCE));
   let secondNestedINTEGER = secondNested.readTagAndGetContents(DER.INTEGER);
   deepEqual(
     secondNestedINTEGER,
     [0x00, 0xff],
     "second nested INTEGER should have expected value"
   );
   let secondNestedNULL = secondNested.readTagAndGetContents(DER.NULL);
   equal(
@@ -324,21 +324,21 @@ function run_compound_tests() {
     0x02, //   SEQUENCE
     0x02,
     0x01, //     INTEGER (missing data)
     0x05,
     0x00, //   NULL
     0x00,
     0x00,
   ]; // (extra data)
-  let invalidDER = new DER.DER(invalidDERBytes);
-  let invalidContents = new DER.DER(
+  let invalidDER = new DER.DERDecoder(invalidDERBytes);
+  let invalidContents = new DER.DERDecoder(
     invalidDER.readTagAndGetContents(DER.SEQUENCE)
   );
-  let invalidContentsContents = new DER.DER(
+  let invalidContentsContents = new DER.DERDecoder(
     invalidContents.readTagAndGetContents(DER.SEQUENCE)
   );
   throws(
     () => invalidContentsContents.readTagAndGetContents(DER.INTEGER),
     /data truncated/,
     "should throw due to missing data"
   );
   let nestedNULL = invalidContents.readTagAndGetContents(DER.NULL);
