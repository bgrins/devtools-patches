
# HG changeset patch
# User Zibi Braniecki <zbraniecki@mozilla.com>
# Date 1527142592 25200
# Node ID 688d90cf9d01248265f55e8d5ffd03e58673283d
# Parent  d36cd8bdbc5c0df1d1d7a167f5fedb95c3a3648e
Bug 1435915 - Migrate Preferences::General JS to Fluent

MozReview-Commit-ID: graoobedZH

diff --git a/browser/components/preferences/in-content/main.js b/browser/components/preferences/in-content/main.js
--- a/browser/components/preferences/in-content/main.js
+++ b/browser/components/preferences/in-content/main.js
@@ -103,16 +103,44 @@
 
 if (AppConstants.MOZ_DEV_EDITION) {
   ChromeUtils.defineModuleGetter(this, "fxAccounts",
     "resource://gre/modules/FxAccounts.jsm");
   ChromeUtils.defineModuleGetter(this, "FxAccounts",
     "resource://gre/modules/FxAccounts.jsm");
 }
 
+/**
+ * This API facilitates dual-model of some localization APIs which
+ * may operate on raw strings of l10n id/args pairs.
+ *
+ * The l10n can be:
+ *
+ * {raw: string} - raw strings to be used as text value of the element
+ * {id: string} - l10n-id
+ * {id: string, args: object} - l10n-id + l10n-args
+ *
+ * This API on top of that does a quirky thing to pass those three
+ * possible values into XBL.
+ */
+function localizeElement(node, l10n) {
+  if (l10n.hasOwnProperty("raw")) {
+    node.removeAttribute("data-l10n-id");
+    node.textContent = l10n.raw;
+  } else {
+    document.l10n.setAttributes(node, l10n.id, l10n.args);
+  }
+}
+
+function localizeMenuItem(item, l10n) {
+  const label = document.createElement("label");
+  localizeElement(label, l10n);
+  item.appendChild(label);
+}
+
 Preferences.addAll([
   // Startup
   { id: "browser.startup.page", type: "int" },
   { id: "browser.privatebrowsing.autostart", type: "bool" },
 
   // Downloads
   { id: "browser.download.useDownloadDir", type: "bool" },
   { id: "browser.download.folderList", type: "int" },
@@ -262,26 +290,16 @@
 
   // browser.startup.page values
   STARTUP_PREF_BLANK: 0,
   STARTUP_PREF_HOMEPAGE: 1,
   STARTUP_PREF_RESTORE_SESSION: 3,
 
   // Convenience & Performance Shortcuts
 
-  get _brandShortName() {
-    delete this._brandShortName;
-    return this._brandShortName = document.getElementById("bundleBrand").getString("brandShortName");
-  },
-
-  get _prefsBundle() {
-    delete this._prefsBundle;
-    return this._prefsBundle = document.getElementById("bundlePreferences");
-  },
-
   get _list() {
     delete this._list;
     return this._list = document.getElementById("handlersView");
   },
 
   get _filter() {
     delete this._filter;
     return this._filter = document.getElementById("filter");
@@ -581,18 +599,17 @@
       // Load the data and build the list of handlers for applications pane.
       // By doing this after pageshow, we ensure it doesn't delay painting
       // of the preferences page.
       window.addEventListener("pageshow", async () => {
         try {
           this._initListEventHandlers();
           this._loadData();
           await this._rebuildVisibleTypes();
-          this._sortVisibleTypes();
-          this._rebuildView();
+          await this._rebuildView();
           resolve();
         } catch (ex) {
           reject(ex);
         }
       }, { once: true });
     });
   },
 
@@ -1325,22 +1342,22 @@
       // Rebuild the list when there are changes to preferences that influence
       // whether or not to show certain entries in the list.
       if (!this._storingAction) {
         // These two prefs alter the list of visible types, so we have to rebuild
         // that list when they change.
         if (aData == PREF_SHOW_PLUGINS_IN_LIST ||
           aData == PREF_HIDE_PLUGINS_WITHOUT_EXTENSIONS) {
           await this._rebuildVisibleTypes();
-          this._sortVisibleTypes();
+          await this._rebuildView();
+        } else {
+          // All the prefs we observe can affect what we display, so we rebuild
+          // the view when any of them changes.
+          await this._rebuildView();
         }
-
-        // All the prefs we observe can affect what we display, so we rebuild
-        // the view when any of them changes.
-        this._rebuildView();
       }
       if (AppConstants.MOZ_UPDATER) {
         this.updateReadPrefs();
       }
     }
   },
 
 
@@ -1526,47 +1543,54 @@
         // There is at least another type with this description. Make sure we
         // add the type to the description on both HandlerInfoWrapper objects.
         handlerInfo.disambiguateDescription = true;
         otherHandlerInfo.disambiguateDescription = true;
       }
     }
   },
 
-  _rebuildView() {
-    let lastSelectedType = this.selectedHandlerListItem &&
-                           this.selectedHandlerListItem.handlerInfoWrapper.type;
-    this.selectedHandlerListItem = null;
-
-    // Clear the list of entries.
-    while (this._list.childNodes.length > 1)
-      this._list.removeChild(this._list.lastChild);
-
-    var visibleTypes = this._visibleTypes;
+  async _rebuildView() {
+    const frag = document.createDocumentFragment();
+
+    for (let visibleType of this._visibleTypes) {
+      let item = new HandlerListItem(visibleType);
+      item.connectAndAppendToList(frag);
+    }
+
+    await document.l10n.translateFragment(frag);
+
+    this._sortView(frag);
 
     // If the user is filtering the list, then only show matching types.
-    if (this._filter.value)
-      visibleTypes = visibleTypes.filter(this._matchesFilter, this);
-
-    for (let visibleType of visibleTypes) {
-      let item = new HandlerListItem(visibleType);
-      item.connectAndAppendToList(this._list);
-
-      if (visibleType.type === lastSelectedType) {
-        this._list.selectedItem = item.node;
+    if (this._filter.value) {
+      this._filterView(frag);
+    }
+
+    // Clear the list of entries.
+    while (this._list.childNodes.length > 1) {
+      this._list.removeChild(this._list.lastChild);
+    }
+
+    this._list.appendChild(frag);
+
+    this._selectLastSelectedType(this._list);
+  },
+
+  _selectLastSelectedType(list) {
+    let lastSelectedType = this.selectedHandlerListItem &&
+                           this.selectedHandlerListItem.handlerInfoWrapper.type;
+    for (elem of list.childNodes) {
+      if (elem.type === lastSelectedType) {
+        list.selectedItem = elem;
+        break;
       }
     }
   },
 
-  _matchesFilter(aType) {
-    var filterValue = this._filter.value.toLowerCase();
-    return aType.typeDescription.toLowerCase().includes(filterValue) ||
-           aType.actionDescription.toLowerCase().includes(filterValue);
-  },
-
   /**
    * Whether or not the given handler app is valid.
    *
    * @param aHandlerApp {nsIHandlerApp} the handler app in question
    *
    * @returns {boolean} whether or not it's valid
    */
   isValidHandlerApp(aHandlerApp) {
@@ -1620,79 +1644,77 @@
     while (menuPopup.hasChildNodes())
       menuPopup.removeChild(menuPopup.lastChild);
 
     let internalMenuItem;
     // Add the "Preview in Firefox" option for optional internal handlers.
     if (handlerInfo instanceof InternalHandlerInfoWrapper) {
       internalMenuItem = document.createElement("menuitem");
       internalMenuItem.setAttribute("action", Ci.nsIHandlerInfo.handleInternally);
-      let label = gMainPane._prefsBundle.getFormattedString("previewInApp",
-        [this._brandShortName]);
-      internalMenuItem.setAttribute("label", label);
-      internalMenuItem.setAttribute("tooltiptext", label);
+      localizeMenuItem(internalMenuItem, {
+        id: "applications-action-preview-in-app",
+      });
       internalMenuItem.setAttribute(APP_ICON_ATTR_NAME, "ask");
       menuPopup.appendChild(internalMenuItem);
     }
 
     {
       var askMenuItem = document.createElement("menuitem");
       askMenuItem.setAttribute("action", Ci.nsIHandlerInfo.alwaysAsk);
-      let label;
-      if (isFeedType(handlerInfo.type))
-        label = gMainPane._prefsBundle.getFormattedString("previewInApp",
-          [this._brandShortName]);
-      else
-        label = gMainPane._prefsBundle.getString("alwaysAsk");
-      askMenuItem.setAttribute("label", label);
-      askMenuItem.setAttribute("tooltiptext", label);
+      if (isFeedType(handlerInfo.type)) {
+        localizeMenuItem(askMenuItem, {
+          id: "applications-action-preview-in-app",
+        });
+      } else {
+        localizeMenuItem(askMenuItem, {
+          id: "applications-action-always-ask",
+        });
+      }
       askMenuItem.setAttribute(APP_ICON_ATTR_NAME, "ask");
       menuPopup.appendChild(askMenuItem);
     }
 
     // Create a menu item for saving to disk.
     // Note: this option isn't available to protocol types, since we don't know
     // what it means to save a URL having a certain scheme to disk, nor is it
     // available to feeds, since the feed code doesn't implement the capability.
     if ((handlerInfo.wrappedHandlerInfo instanceof Ci.nsIMIMEInfo) &&
       !isFeedType(handlerInfo.type)) {
       var saveMenuItem = document.createElement("menuitem");
       saveMenuItem.setAttribute("action", Ci.nsIHandlerInfo.saveToDisk);
-      let label = gMainPane._prefsBundle.getString("saveFile");
-      saveMenuItem.setAttribute("label", label);
-      saveMenuItem.setAttribute("tooltiptext", label);
+      localizeMenuItem(saveMenuItem, {
+        id: "applications-action-save-file",
+      });
       saveMenuItem.setAttribute(APP_ICON_ATTR_NAME, "save");
       menuPopup.appendChild(saveMenuItem);
     }
 
     // If this is the feed type, add a Live Bookmarks item.
     if (isFeedType(handlerInfo.type)) {
       internalMenuItem = document.createElement("menuitem");
       internalMenuItem.setAttribute("action", Ci.nsIHandlerInfo.handleInternally);
-      let label = gMainPane._prefsBundle.getFormattedString("addLiveBookmarksInApp",
-        [this._brandShortName]);
-      internalMenuItem.setAttribute("label", label);
-      internalMenuItem.setAttribute("tooltiptext", label);
+      localizeMenuItem(internalMenuItem, {
+        id: "applications-action-add-live-bookmarks",
+      });
       internalMenuItem.setAttribute(APP_ICON_ATTR_NAME, "feed");
       menuPopup.appendChild(internalMenuItem);
     }
 
     // Add a separator to distinguish these items from the helper app items
     // that follow them.
     let menuseparator = document.createElement("menuseparator");
     menuPopup.appendChild(menuseparator);
 
     // Create a menu item for the OS default application, if any.
     if (handlerInfo.hasDefaultHandler) {
       var defaultMenuItem = document.createElement("menuitem");
       defaultMenuItem.setAttribute("action", Ci.nsIHandlerInfo.useSystemDefault);
-      let label = gMainPane._prefsBundle.getFormattedString("useDefault",
-        [handlerInfo.defaultDescription]);
-      defaultMenuItem.setAttribute("label", label);
-      defaultMenuItem.setAttribute("tooltiptext", handlerInfo.defaultDescription);
+      localizeMenuItem(defaultMenuItem, {
+        id: "applications-action-use-default",
+      });
       defaultMenuItem.setAttribute("image", handlerInfo.iconURLForSystemDefault);
 
       menuPopup.appendChild(defaultMenuItem);
     }
 
     // Create menu items for possible handlers.
     let preferredApp = handlerInfo.preferredApplicationHandler;
     let possibleApps = handlerInfo.possibleApplicationHandlers.enumerate();
@@ -1704,19 +1726,20 @@
 
       let menuItem = document.createElement("menuitem");
       menuItem.setAttribute("action", Ci.nsIHandlerInfo.useHelperApp);
       let label;
       if (possibleApp instanceof Ci.nsILocalHandlerApp)
         label = getFileDisplayName(possibleApp.executable);
       else
         label = possibleApp.name;
-      label = gMainPane._prefsBundle.getFormattedString("useApp", [label]);
-      menuItem.setAttribute("label", label);
-      menuItem.setAttribute("tooltiptext", label);
+      localizeMenuItem(menuItem, {
+        id: "applications-action-use-app",
+        args: {name: label}
+      });
       menuItem.setAttribute("image", this._getIconURLForHandlerApp(possibleApp));
 
       // Attach the handler app object to the menu item so we can use it
       // to make changes to the datastore when the user selects the item.
       menuItem.handlerApp = possibleApp;
 
       menuPopup.appendChild(menuItem);
       possibleAppMenuItems.push(menuItem);
@@ -1742,40 +1765,40 @@
           if (handler.equals(app)) {
             appAlreadyInHandlers = true;
             break;
           }
         }
         if (!appAlreadyInHandlers) {
           let menuItem = document.createElement("menuitem");
           menuItem.setAttribute("action", Ci.nsIHandlerInfo.useHelperApp);
-          let label = gMainPane._prefsBundle.getFormattedString("useApp", [handler.name]);
-          menuItem.setAttribute("label", label);
-          menuItem.setAttribute("tooltiptext", label);
+          localizeMenuItem(menuItem, {
+            id: "applications-action-use-app",
+            args: { name: handler.name }
+          });
           menuItem.setAttribute("image", this._getIconURLForHandlerApp(handler));
 
           // Attach the handler app object to the menu item so we can use it
           // to make changes to the datastore when the user selects the item.
           menuItem.handlerApp = handler;
 
           menuPopup.appendChild(menuItem);
           possibleAppMenuItems.push(menuItem);
         }
       }
     }
 
     // Create a menu item for the plugin.
     if (handlerInfo.pluginName) {
       var pluginMenuItem = document.createElement("menuitem");
       pluginMenuItem.setAttribute("action", kActionUsePlugin);
-      let label = gMainPane._prefsBundle.getFormattedString("usePluginIn",
-        [handlerInfo.pluginName,
-        this._brandShortName]);
-      pluginMenuItem.setAttribute("label", label);
-      pluginMenuItem.setAttribute("tooltiptext", label);
+      localizeMenuItem(pluginMenuItem, {
+        id: "applications-action-use-plugin-in",
+        args: { name: handleInfo.pluginName }
+      });
       pluginMenuItem.setAttribute(APP_ICON_ATTR_NAME, "plugin");
       menuPopup.appendChild(pluginMenuItem);
     }
 
     // Create a menu item for selecting a local application.
     let canOpenWithOtherApp = true;
     if (AppConstants.platform == "win") {
       // On Windows, selecting an application to open another application
@@ -1785,32 +1808,35 @@
       canOpenWithOtherApp = handlerInfo.type != executableType;
     }
     if (canOpenWithOtherApp) {
       let menuItem = document.createElement("menuitem");
       menuItem.className = "choose-app-item";
       menuItem.addEventListener("command", function(e) {
         gMainPane.chooseApp(e);
       });
-      let label = gMainPane._prefsBundle.getString("useOtherApp");
-      menuItem.setAttribute("label", label);
-      menuItem.setAttribute("tooltiptext", label);
+      localizeMenuItem(menuItem, {
+        id: "applications-action-use-other-app",
+      });
+
       menuPopup.appendChild(menuItem);
     }
 
     // Create a menu item for managing applications.
     if (possibleAppMenuItems.length) {
       let menuItem = document.createElement("menuseparator");
       menuPopup.appendChild(menuItem);
       menuItem = document.createElement("menuitem");
       menuItem.className = "manage-app-item";
       menuItem.addEventListener("command", function(e) {
         gMainPane.manageApp(e);
       });
-      menuItem.setAttribute("label", gMainPane._prefsBundle.getString("manageApp"));
+      localizeMenuItem(menuItem, {
+        id: "applications-action-manage-app",
+      });
       menuPopup.appendChild(menuItem);
     }
 
     // Select the item corresponding to the preferred action.  If the always
     // ask flag is set, it overrides the preferred action.  Otherwise we pick
     // the item identified by the preferred action (when the preferred action
     // is to use a helper app, we have to pick the specific helper app item).
     if (handlerInfo.alwaysAskBeforeHandling)
@@ -1859,55 +1885,70 @@
     this._sortColumn = column;
 
     // Set (or switch) the sort direction indicator.
     if (column.getAttribute("sortDirection") == "ascending")
       column.setAttribute("sortDirection", "descending");
     else
       column.setAttribute("sortDirection", "ascending");
 
-    this._sortVisibleTypes();
-    this._rebuildView();
+    this._sortView(this._list);
   },
 
   /**
    * Sort the list of visible types by the current sort column/direction.
    */
-  _sortVisibleTypes() {
+  _sortView(list) {
     if (!this._sortColumn)
       return;
 
-    function sortByType(a, b) {
-      return a.typeDescription.toLowerCase().
-        localeCompare(b.typeDescription.toLowerCase());
-    }
-
-    function sortByAction(a, b) {
-      return a.actionDescription.toLowerCase().
-        localeCompare(b.actionDescription.toLowerCase());
+    let comp = new Services.intl.Collator(undefined, {
+      usage: "sort"
+    });
+
+    let items = Array.from(list.children);
+
+    let sortColumn = this._sortColumn.getAttribute("value") === "type" ?
+      ".typeDescription" :
+      ".actionDescription";
+
+    items.sort((a, b) => {
+      return comp.compare(
+        a.querySelector(sortColumn).textContent,
+        b.querySelector(sortColumn).textContent);
+    });
+
+    if (this._sortColumn.getAttribute("sortDirection") == "descending") {
+      items.reverse();
     }
 
-    switch (this._sortColumn.getAttribute("value")) {
-      case "type":
-        this._visibleTypes.sort(sortByType);
-        break;
-      case "action":
-        this._visibleTypes.sort(sortByAction);
-        break;
+    // Re-append items in the correct order:
+    items.forEach(item => list.appendChild(item));
+  },
+
+  _filterView(list) {
+    const filterValue = this._filter.value.toLowerCase();
+    for (let elem of list.children) {
+      const typeDescription = elem.querySelector(".typeDescription").textContent.toLowerCase();
+      const actionDescription = elem.querySelector(".actionDescription").textContent.toLowerCase();
+      if (!typeDescription.includes(filterValue) &&
+          !actionDescription.includes(filterValue)) {
+        elem.hidden = true;
+      } else {
+        elem.hidden = false;
+      }
     }
-
-    if (this._sortColumn.getAttribute("sortDirection") == "descending")
-      this._visibleTypes.reverse();
   },
 
+
   /**
    * Filter the list when the user enters a filter term into the filter field.
    */
   filter() {
-    this._rebuildView();
+    this._filterView(this._list);
   },
 
   focusFilterBox() {
     this._filter.focus();
     this._filter.select();
   },
 
 
@@ -1986,17 +2027,17 @@
       this.selectedHandlerListItem.refreshAction();
     };
 
     gSubDialog.open("chrome://browser/content/preferences/applicationManager.xul",
       "resizable=no", handlerInfo, onComplete);
 
   },
 
-  chooseApp(aEvent) {
+  async chooseApp(aEvent) {
     // Don't let the normal "on select action" handler get this event,
     // as we handle it specially ourselves.
     aEvent.stopPropagation();
 
     var handlerApp;
     let chooseAppCallback = aHandlerApp => {
       // Rebuild the actions menu whether the user picked an app or canceled.
       // If they picked an app, we want to add the app to the menu and select it.
@@ -2026,17 +2067,26 @@
       if (isFeedType(handlerInfo.type)) {
         // MIME info will be null, create a temp object.
         params.mimeInfo = gMIMEService.getFromTypeAndExtension(handlerInfo.type,
           handlerInfo.primaryExtension);
       } else {
         params.mimeInfo = handlerInfo.wrappedHandlerInfo;
       }
 
-      params.title = gMainPane._prefsBundle.getString("fpTitleChooseApp");
+      params.title = await document.l10n.formatValue("applications-choose-app-title");
+      if (handlerInfo.description.raw) {
+        params.description = handlerInfo.description.raw;
+      } else {
+        params.description = await document.l10n.formatValue(
+          handlerInfo.description.id,
+          handlerInfo.description.args
+        );
+      }
+
       params.description = handlerInfo.description;
       params.filename = null;
       params.handlerApp = null;
 
       let onAppSelected = () => {
         if (this.isValidHandlerApp(params.handlerApp)) {
           handlerApp = params.handlerApp;
 
@@ -2045,17 +2095,17 @@
         }
 
         chooseAppCallback(handlerApp);
       };
 
       gSubDialog.open("chrome://global/content/appPicker.xul",
         null, params, onAppSelected);
     } else {
-      let winTitle = gMainPane._prefsBundle.getString("fpTitleChooseApp");
+      let winTitle = await document.l10n.formatValue("applications-choose-app-title");
       let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
       let fpCallback = aResult => {
         if (aResult == Ci.nsIFilePicker.returnOK && fp.file &&
           this._isValidHandlerExecutable(fp.file)) {
           handlerApp = Cc["@mozilla.org/uriloader/local-handler-app;1"].
             createInstance(Ci.nsILocalHandlerApp);
           handlerApp.name = getFileDisplayName(fp.file);
           handlerApp.executable = fp.file;
@@ -2247,17 +2297,17 @@
    * Displays a file picker in which the user can choose the location where
    * downloads are automatically saved, updating preferences and UI in
    * response to the choice, if one is made.
    */
   chooseFolder() {
     return this.chooseFolderTask().catch(Cu.reportError);
   },
   async chooseFolderTask() {
-    let title = gMainPane._prefsBundle.getString("chooseDownloadFolderTitle");
+    let title = await document.l10n.formatValue("download-choose-folder");
     let folderListPref = Preferences.get("browser.download.folderList");
     let currentDirPref = await this._indexToFolder(folderListPref.value);
     let defDownloads = await this._indexToFolder(1);
     let fp = Cc["@mozilla.org/filepicker;1"].
       createInstance(Ci.nsIFilePicker);
 
     fp.init(window, title, Ci.nsIFilePicker.modeGetFolder);
     fp.appendFilters(Ci.nsIFilePicker.filterAll);
@@ -2319,21 +2369,21 @@
     // Display a 'pretty' label or the path in the UI.
     if (folderIndex == 2) {
       // Force the left-to-right direction when displaying a custom path.
       downloadFolder.value = currentDirPref.value ?
         `\u2066${currentDirPref.value.path}\u2069` : "";
       iconUrlSpec = fph.getURLSpecFromFile(currentDirPref.value);
     } else if (folderIndex == 1) {
       // 'Downloads'
-      downloadFolder.value = gMainPane._prefsBundle.getString("downloadsFolderName");
+      document.l10n.setAttributes(downloadFolder, "download-folder-name-downloads");
       iconUrlSpec = fph.getURLSpecFromFile(await this._indexToFolder(1));
     } else {
       // 'Desktop'
-      downloadFolder.value = gMainPane._prefsBundle.getString("desktopFolderName");
+      document.l10n.setAttributes(downloadFolder, "download-folder-name-desktop");
       iconUrlSpec = fph.getURLSpecFromFile(await this._getDownloadsFolder("Desktop"));
     }
     downloadFolder.style.backgroundImage = "url(moz-icon://" + iconUrlSpec + "?size=16)";
   },
 
   /**
    * Returns the Downloads folder.  If aFolder is "Desktop", then the Downloads
    * folder returned is the desktop folder; otherwise, it is a folder whose name
@@ -2501,33 +2551,33 @@
     gNodeToObjectMap.set(this.node, this);
 
     this.node.querySelector(".actionsMenu").addEventListener("command",
       event => gMainPane.onSelectAction(event.originalTarget));
 
     let typeDescription = this.handlerInfoWrapper.typeDescription;
     this.setOrRemoveAttributes([
       [null, "type", this.handlerInfoWrapper.type],
-      [".typeContainer", "tooltiptext", typeDescription],
-      [".typeDescription", "value", typeDescription],
+      // [".typeContainer", "tooltiptext", typeDescription],
       [".typeIcon", "src", this.handlerInfoWrapper.smallIcon],
     ]);
+    localizeElement(this.node.querySelector(".typeDescription"), typeDescription);
     this.refreshAction();
     this.showActionsMenu = false;
   }
 
   refreshAction() {
     let { actionIconClass, actionDescription } = this.handlerInfoWrapper;
     this.setOrRemoveAttributes([
       [null, APP_ICON_ATTR_NAME, actionIconClass],
-      [".actionContainer", "tooltiptext", actionDescription],
-      [".actionDescription", "value", actionDescription],
+      // [".actionContainer", "tooltiptext", actionDescription],
       [".actionIcon", "src", actionIconClass ? null :
                              this.handlerInfoWrapper.actionIcon],
     ]);
+    localizeElement(this.node.querySelector(".actionDescription"), actionDescription);
   }
 
   set showActionsMenu(value) {
     this.setOrRemoveAttributes([
       [".actionContainer", "hidden", value],
       [".actionsMenuContainer", "hidden", !value],
     ]);
   }
@@ -2570,104 +2620,130 @@
     // and user-configured records, stop using this boolean flag and simply
     // check for the presence of a user-configured record to determine whether
     // or not this type is only handled by a plugin.  Filed as bug 395142.
     this.handledOnlyByPlugin = false;
   }
 
   get description() {
     if (this.wrappedHandlerInfo.description)
-      return this.wrappedHandlerInfo.description;
+      return {raw: this.wrappedHandlerInfo.description};
 
     if (this.primaryExtension) {
-      var extension = this.primaryExtension.toUpperCase();
-      return gMainPane._prefsBundle.getFormattedString("fileEnding",
-        [extension]);
+      return {
+        id: "applications-file-ending",
+        args: {
+          extension: this.primaryExtension.toUpperCase()
+        }
+      };
     }
 
-    return this.type;
+    return {raw: this.type};
   }
 
   /**
    * Describe, in a human-readable fashion, the type represented by the given
    * handler info object.  Normally this is just the description, but if more
    * than one object presents the same description, "disambiguateDescription"
    * is set and we annotate the duplicate descriptions with the type itself
    * to help users distinguish between those types.
    */
   get typeDescription() {
     if (this.disambiguateDescription) {
-      return gMainPane._prefsBundle.getFormattedString(
-        "typeDescriptionWithType", [this.description, this.type]);
+      const desc = this.description;
+      // Once Fluent supports dynamic references, this should be switched
+      // to use them, in order to avoid duplication.
+      if (desc.hasOwnProperty("id")) {
+        return {
+          id: `${desc.id}-with-type`,
+          args: {
+            type: this.type,
+          }
+        };
+      }
+      return {
+        id: "applications-type-description-with-type",
+        args: {
+          description: this.description.raw,
+          type: this.type,
+        }
+      };
     }
 
     return this.description;
   }
 
   /**
    * Describe, in a human-readable fashion, the preferred action to take on
    * the type represented by the given handler info object.
    */
   get actionDescription() {
     // alwaysAskBeforeHandling overrides the preferred action, so if that flag
     // is set, then describe that behavior instead.  For most types, this is
     // the "alwaysAsk" string, but for the feed type we show something special.
     if (this.alwaysAskBeforeHandling) {
       if (isFeedType(this.type))
-        return gMainPane._prefsBundle.getFormattedString("previewInApp",
-          [gMainPane._brandShortName]);
-      return gMainPane._prefsBundle.getString("alwaysAsk");
+        return {id: "applications-action-preview-in-app"};
+      return {id: "applications-action-always-ask"};
     }
 
     switch (this.preferredAction) {
       case Ci.nsIHandlerInfo.saveToDisk:
-        return gMainPane._prefsBundle.getString("saveFile");
+        return {id: "applications-action-save-file"};
 
       case Ci.nsIHandlerInfo.useHelperApp:
         var preferredApp = this.preferredApplicationHandler;
         var name;
         if (preferredApp instanceof Ci.nsILocalHandlerApp)
           name = getFileDisplayName(preferredApp.executable);
         else
           name = preferredApp.name;
-        return gMainPane._prefsBundle.getFormattedString("useApp", [name]);
+        return {
+          id: "applications-action-use-app",
+          args: { name }
+        };
 
       case Ci.nsIHandlerInfo.handleInternally:
         // For the feed type, handleInternally means live bookmarks.
         if (isFeedType(this.type)) {
-          return gMainPane._prefsBundle.getFormattedString("addLiveBookmarksInApp",
-            [gMainPane._brandShortName]);
+          return {id: "applications-action-add-live-bookmarks"};
         }
 
         if (this instanceof InternalHandlerInfoWrapper) {
-          return gMainPane._prefsBundle.getFormattedString("previewInApp",
-            [gMainPane._brandShortName]);
+          return {id: "applications-action-preview-in-app"};
         }
 
         // For other types, handleInternally looks like either useHelperApp
         // or useSystemDefault depending on whether or not there's a preferred
         // handler app.
         if (gMainPane.isValidHandlerApp(this.preferredApplicationHandler))
-          return this.preferredApplicationHandler.name;
-
-        return this.defaultDescription;
+          return {raw: this.preferredApplicationHandler.name};
+
+        return {raw: this.defaultDescription};
 
       // XXX Why don't we say the app will handle the type internally?
       // Is it because the app can't actually do that?  But if that's true,
       // then why would a preferredAction ever get set to this value
       // in the first place?
 
       case Ci.nsIHandlerInfo.useSystemDefault:
-        return gMainPane._prefsBundle.getFormattedString("useDefault",
-          [this.defaultDescription]);
+        return {
+          id: "applications-action-use-default",
+          args: {
+            name: this.defaultDescription
+          }
+        };
 
       case kActionUsePlugin:
-        return gMainPane._prefsBundle.getFormattedString("usePluginIn",
-          [this.pluginName,
-          gMainPane._brandShortName]);
+        return {
+          id: "applications-action-use-plugin-in",
+          args: {
+            name: this.pluginName
+          }
+        };
       default:
         throw new Error(`Unexpected preferredAction: ${this.preferredAction}`);
     }
   }
 
   get actionIconClass() {
     if (this.alwaysAskBeforeHandling) {
       return "ask";
@@ -2945,17 +3021,17 @@
  */
 class FeedHandlerInfo extends HandlerInfoWrapper {
   constructor(aMIMEType, properties) {
     super(aMIMEType, null);
     Object.assign(this, properties);
   }
 
   get description() {
-    return gMainPane._prefsBundle.getString(this._appPrefLabel);
+    return {id: this._appPrefLabel};
   }
 
   get preferredApplicationHandler() {
     switch (Preferences.get(this._prefSelectedReader).value) {
       case "client":
         var file = Preferences.get(this._prefSelectedApp).value;
         if (file)
           return getLocalHandlerApp(file);
@@ -3200,35 +3276,35 @@
 }
 
 var feedHandlerInfo = new FeedHandlerInfo(TYPE_MAYBE_FEED, {
   _prefSelectedApp: PREF_FEED_SELECTED_APP,
   _prefSelectedWeb: PREF_FEED_SELECTED_WEB,
   _prefSelectedAction: PREF_FEED_SELECTED_ACTION,
   _prefSelectedReader: PREF_FEED_SELECTED_READER,
   _smallIcon: "chrome://browser/skin/feeds/feedIcon16.png",
-  _appPrefLabel: "webFeed"
+  _appPrefLabel: "applications-type-web-feed",
 });
 
 var videoFeedHandlerInfo = new FeedHandlerInfo(TYPE_MAYBE_VIDEO_FEED, {
   _prefSelectedApp: PREF_VIDEO_FEED_SELECTED_APP,
   _prefSelectedWeb: PREF_VIDEO_FEED_SELECTED_WEB,
   _prefSelectedAction: PREF_VIDEO_FEED_SELECTED_ACTION,
   _prefSelectedReader: PREF_VIDEO_FEED_SELECTED_READER,
   _smallIcon: "chrome://browser/skin/feeds/videoFeedIcon16.png",
-  _appPrefLabel: "videoPodcastFeed"
+  _appPrefLabel: "applications-type-video-podcast-feed",
 });
 
 var audioFeedHandlerInfo = new FeedHandlerInfo(TYPE_MAYBE_AUDIO_FEED, {
   _prefSelectedApp: PREF_AUDIO_FEED_SELECTED_APP,
   _prefSelectedWeb: PREF_AUDIO_FEED_SELECTED_WEB,
   _prefSelectedAction: PREF_AUDIO_FEED_SELECTED_ACTION,
   _prefSelectedReader: PREF_AUDIO_FEED_SELECTED_READER,
   _smallIcon: "chrome://browser/skin/feeds/audioFeedIcon16.png",
-  _appPrefLabel: "audioPodcastFeed"
+  _appPrefLabel: "applications-type-audio-podcast-feed",
 });
 
 /**
  * InternalHandlerInfoWrapper provides a basic mechanism to create an internal
  * mime type handler that can be enabled/disabled in the applications preference
  * menu.
  */
 class InternalHandlerInfoWrapper extends HandlerInfoWrapper {
@@ -3243,30 +3319,30 @@
     Services.obs.notifyObservers(null, this._handlerChanged);
   }
 
   get enabled() {
     throw Cr.NS_ERROR_NOT_IMPLEMENTED;
   }
 
   get description() {
-    return gMainPane._prefsBundle.getString(this._appPrefLabel);
+    return {id: this._appPrefLabel};
   }
 }
 
 class PDFHandlerInfoWrapper extends InternalHandlerInfoWrapper {
   constructor() {
     super(TYPE_PDF);
   }
 
   get _handlerChanged() {
     return TOPIC_PDFJS_HANDLER_CHANGED;
   }
 
   get _appPrefLabel() {
-    return "portableDocumentFormat";
+    return "applications-type-pdf";
   }
 
   get enabled() {
     return !Services.prefs.getBoolPref(PREF_PDFJS_DISABLED) &&
            Services.policies.isAllowed("PDF.js");
   }
 }
diff --git a/browser/components/preferences/in-content/main.xul b/browser/components/preferences/in-content/main.xul
--- a/browser/components/preferences/in-content/main.xul
+++ b/browser/components/preferences/in-content/main.xul
@@ -9,18 +9,16 @@
 
 #ifdef MOZ_UPDATER
   <script type="application/javascript" src="chrome://browser/content/aboutDialog-appUpdater.js"/>
 #endif
 
 <script type="application/javascript"
         src="chrome://mozapps/content/preferences/fontbuilder.js"/>
 
-<stringbundle id="bundlePreferences" src="chrome://browser/locale/preferences.properties"/>
-
 <hbox id="generalCategory"
       class="subcategory"
       hidden="true"
       data-category="paneGeneral">
       <label class="header-name" flex="1" data-l10n-id="pane-general-title"/>
 </hbox>
 
 <!-- Startup -->
@@ -399,21 +397,16 @@
                     class="tail-with-learn-more" data-l10n-id="play-drm-content" />
           <label id="playDRMContentLink" class="learnMore text-link" data-l10n-id="play-drm-content-learn-more"/>
         </hbox>
       </row>
     </rows>
   </grid>
 </groupbox>
 
-#ifdef HAVE_SHELL_SERVICE
-  <stringbundle id="bundleShell" src="chrome://browser/locale/shellservice.properties"/>
-  <stringbundle id="bundleBrand" src="chrome://branding/locale/brand.properties"/>
-#endif
-
 <hbox id="updatesCategory"
       class="subcategory"
       hidden="true"
       data-category="paneGeneral">
   <label class="header-name" flex="1" data-l10n-id="update-application-title"/>
 </hbox>
 
 <!-- Update -->
diff --git a/browser/components/preferences/in-content/preferences.xul b/browser/components/preferences/in-content/preferences.xul
--- a/browser/components/preferences/in-content/preferences.xul
+++ b/browser/components/preferences/in-content/preferences.xul
@@ -66,18 +66,16 @@
           src="chrome://browser/content/preferences/in-content/preferences.js"/>
   <script type="application/javascript"
           src="chrome://browser/content/preferences/in-content/extensionControlled.js"/>
   <script src="chrome://browser/content/preferences/in-content/findInPage.js"/>
   <script src="chrome://browser/content/preferences/in-content/subdialogs.js"/>
 
   <stringbundle id="bundleBrand"
                 src="chrome://branding/locale/brand.properties"/>
-  <stringbundle id="bundlePreferences"
-                src="chrome://browser/locale/preferences/preferences.properties"/>
   <stringbundle id="pkiBundle"
                 src="chrome://pippki/locale/pippki.properties"/>
   <stringbundle id="browserBundle"
                 src="chrome://browser/locale/browser.properties"/>
 
   <stack flex="1">
   <hbox flex="1">
 
diff --git a/browser/components/preferences/in-content/privacy.js b/browser/components/preferences/in-content/privacy.js
--- a/browser/components/preferences/in-content/privacy.js
+++ b/browser/components/preferences/in-content/privacy.js
@@ -1046,47 +1046,48 @@
     checkbox.disabled = noMP && !Services.policies.isAllowed("createMasterPassword");
   },
 
   /**
    * Enables/disables the master password button depending on the state of the
    * "use master password" checkbox, and prompts for master password removal if
    * one is set.
    */
-  updateMasterPasswordButton() {
+  async updateMasterPasswordButton() {
     var checkbox = document.getElementById("useMasterPassword");
     var button = document.getElementById("changeMasterPassword");
     button.disabled = !checkbox.checked;
 
     // unchecking the checkbox should try to immediately remove the master
     // password, because it's impossible to non-destructively remove the master
     // password used to encrypt all the passwords without providing it (by
     // design), and it would be extremely odd to pop up that dialog when the
     // user closes the prefwindow and saves his settings
     if (!checkbox.checked)
-      this._removeMasterPassword();
+      await this._removeMasterPassword();
     else
       this.changeMasterPassword();
 
     this._initMasterPasswordUI();
   },
 
   /**
    * Displays the "remove master password" dialog to allow the user to remove
    * the current master password.  When the dialog is dismissed, master password
    * UI is automatically updated.
    */
-  _removeMasterPassword() {
+  async _removeMasterPassword() {
     var secmodDB = Cc["@mozilla.org/security/pkcs11moduledb;1"].
       getService(Ci.nsIPKCS11ModuleDB);
     if (secmodDB.isFIPSEnabled) {
-      var bundle = document.getElementById("bundlePreferences");
-      Services.prompt.alert(window,
-        bundle.getString("pw_change_failed_title"),
-        bundle.getString("pw_change2empty_in_fips_mode"));
+      let [title, text] = await document.l10n.formatValues([
+        {id: "passwords-master-change-failed-title"},
+        {id: "passwords-master-change-empty"},
+      ]);
+      Services.prompt.alert(window, title, text);
       this._initMasterPasswordUI();
     } else {
       gSubDialog.open("chrome://mozapps/content/preferences/removemp.xul",
         null, null, this._initMasterPasswordUI.bind(this));
     }
   },
 
   /**
diff --git a/browser/components/preferences/in-content/privacy.xul b/browser/components/preferences/in-content/privacy.xul
--- a/browser/components/preferences/in-content/privacy.xul
+++ b/browser/components/preferences/in-content/privacy.xul
@@ -1,17 +1,16 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <!-- Privacy panel -->
 
 <script type="application/javascript"
         src="chrome://browser/content/preferences/in-content/privacy.js"/>
-<stringbundle id="bundlePreferences" src="chrome://browser/locale/preferences/preferences.properties"/>
 <stringbundle id="signonBundle" src="chrome://passwordmgr/locale/passwordmgr.properties"/>
 
 <hbox id="browserPrivacyCategory"
       class="subcategory"
       hidden="true"
       data-category="panePrivacy">
   <label class="header-name" flex="1" data-l10n-id="privacy-header"/>
 </hbox>
diff --git a/browser/locales/en-US/browser/preferences/preferences.ftl b/browser/locales/en-US/browser/preferences/preferences.ftl
--- a/browser/locales/en-US/browser/preferences/preferences.ftl
+++ b/browser/locales/en-US/browser/preferences/preferences.ftl
@@ -288,31 +288,64 @@
             [macos] e
            *[other] o
         }
 
 download-always-ask-where =
     .label = Always ask you where to save files
     .accesskey = A
 
+download-choose-folder = Choose Download Folder:
+
+download-folder-name-desktop =
+    .label = Desktop
+download-folder-name-downloads =
+    .label = Downloads
+
 applications-header = Applications
 
 applications-description = Choose how { -brand-short-name } handles the files you download from the web or the applications you use while browsing.
 
 applications-filter =
     .placeholder = Search file types or applications
 
 applications-type-column =
     .label = Content Type
     .accesskey = T
 
 applications-action-column =
     .label = Action
     .accesskey = A
 
+applications-file-ending = { $extension } file
+
+applications-type-web-feed = Web Feed
+applications-type-video-podcast-feed = Video Podcast
+applications-type-audio-podcast-feed = Podcast
+applications-type-pdf = Portable Document Format (PDF)
+
+applications-type-web-feed-with-type = Web Feed ({ $type })
+applications-type-video-podcast-feed-with-type = Video Podcast ({ $type })
+applications-type-audio-podcast-feed-with-type = Podcast ({ $type })
+applications-type-pdf-with-type = Portable Document Format (PDF) ({ $type })
+
+applications-type-description-with-type = { $description } ({ $type })
+
+applications-action-preview-in-app = Preview in { -brand-short-name }
+applications-action-always-ask = Always ask
+applications-action-save-file = Save File
+applications-action-use-app = Use { $name }
+applications-action-add-live-bookmarks = Add Live Bookmarks in { -brand-short-name }
+applications-action-use-default = Use { $name } (default)
+applications-action-use-plugin-in = Use { $name } (in { -brand-short-name })
+applications-action-use-other-app = Use other…
+applications-action-manage-app = Application Details…
+
+applications-choose-app-title = Select Helper Application
+
 drm-content-header = Digital Rights Management (DRM) Content
 
 play-drm-content =
     .label = Play DRM-controlled content
     .accesskey = P
 
 play-drm-content-learn-more = Learn more
 
@@ -661,16 +694,19 @@
     .accesskey = L
 forms-master-pw-use =
     .label = Use a master password
     .accesskey = U
 forms-master-pw-change =
     .label = Change Master Password
     .accesskey = M
 
+passwords-master-change-empty = You are currently in FIPS mode. FIPS requires a non-empty Master Password.
+passwords-master-change-failed-title = Password Change Failed
+
 ## Privacy Section - History
 
 history-header = History
 
 # This label is followed, on the same line, by a dropdown list of options
 # (Remember history, etc.).
 # In English it visually creates a full sentence, e.g.
 # "Firefox will" + "Remember history".
diff --git a/browser/locales/en-US/chrome/browser/preferences/preferences.properties b/browser/locales/en-US/chrome/browser/preferences/preferences.properties
--- a/browser/locales/en-US/chrome/browser/preferences/preferences.properties
+++ b/browser/locales/en-US/chrome/browser/preferences/preferences.properties
@@ -1,62 +1,12 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-#### Security
-
-# LOCALIZATION NOTE: phishBefore uses %S to represent the name of the provider
-#                    whose privacy policy must be accepted (for enabling
-#                    check-every-page-as-I-load-it phishing protection).
-phishBeforeText=Selecting this option will send the address of web pages you are viewing to %S. To continue, please review and accept the following terms of service.
-
-#### Master Password
-
-pw_change2empty_in_fips_mode=You are currently in FIPS mode. FIPS requires a non-empty Master Password.
-pw_change_failed_title=Password Change Failed
-
-#### Downloads
-
-desktopFolderName=Desktop
-downloadsFolderName=Downloads
-chooseDownloadFolderTitle=Choose Download Folder:
-
-#### Applications
-
-fileEnding=%S file
-saveFile=Save File
-
-# LOCALIZATION NOTE (useApp, useDefault): %S = Application name
-useApp=Use %S
-useDefault=Use %S (default)
-
-useOtherApp=Use other…
-fpTitleChooseApp=Select Helper Application
-manageApp=Application Details…
-webFeed=Web Feed
-videoPodcastFeed=Video Podcast
-audioPodcastFeed=Podcast
-alwaysAsk=Always ask
-portableDocumentFormat=Portable Document Format (PDF)
-
-# LOCALIZATION NOTE (usePluginIn):
-# %1$S = plugin name (for example "QuickTime Plugin-in 7.2")
-# %2$S = brandShortName from brand.properties (for example "Minefield")
-usePluginIn=Use %S (in %S)
-
-# LOCALIZATION NOTE (previewInApp, addLiveBookmarksInApp): %S = brandShortName
-previewInApp=Preview in %S
-addLiveBookmarksInApp=Add Live Bookmarks in %S
-
-# LOCALIZATION NOTE (typeDescriptionWithType):
-# %1$S = type description (for example "Portable Document Format")
-# %2$S = type (for example "application/pdf")
-typeDescriptionWithType=%S (%S)
-
 #### Permission labels
 
 can=Allow
 canAccessFirstParty=Allow first party only
 canSession=Allow for Session
 cannot=Block
 prompt=Always Ask
 

