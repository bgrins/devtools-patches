# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1539716304 25200
#      Tue Oct 16 11:58:24 2018 -0700
# Node ID cc567ee7e9f9b04b2526c3df763b8a2a1491ca56
# Parent  31724aea10cae55f30b825ade226c4d25e11a899
Bug 1499476 - Add the ability to mixin the base MozXULElement;r=paolo

Differential Revision: https://phabricator.services.mozilla.com/D8898

diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -29,163 +29,167 @@ window.addEventListener("DOMContentLoade
     } catch (ex) { console.error(ex); }
   }
   gElementsPendingConnection.clear();
 }, { once: true, capture: true });
 
 const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
-class MozXULElement extends XULElement {
-  /**
-   * Sometimes an element may not want to run connectedCallback logic during
-   * parse. This could be because we don't want to initialize the element before
-   * the element's contents have been fully parsed, or for performance reasons.
-   * If you'd like to opt-in to this, then add this to the beginning of your
-   * `connectedCallback` and `disconnectedCallback`:
-   *
-   *    if (this.delayConnectedCallback()) { return }
-   *
-   * And this at the beginning of your `attributeChangedCallback`
-   *
-   *    if (!this.isConnectedAndReady) { return; }
-   */
-  delayConnectedCallback() {
-    if (gIsDOMContentLoaded) {
-      return false;
+function MozElementMixin(base) {
+  return class MozElement extends base {
+    /**
+     * Sometimes an element may not want to run connectedCallback logic during
+     * parse. This could be because we don't want to initialize the element before
+     * the element's contents have been fully parsed, or for performance reasons.
+     * If you'd like to opt-in to this, then add this to the beginning of your
+     * `connectedCallback` and `disconnectedCallback`:
+     *
+     *    if (this.delayConnectedCallback()) { return }
+     *
+     * And this at the beginning of your `attributeChangedCallback`
+     *
+     *    if (!this.isConnectedAndReady) { return; }
+     */
+    delayConnectedCallback() {
+      if (gIsDOMContentLoaded) {
+        return false;
+      }
+      gElementsPendingConnection.add(this);
+      return true;
     }
-    gElementsPendingConnection.add(this);
-    return true;
-  }
-
-  get isConnectedAndReady() {
-    return gIsDOMContentLoaded && this.isConnected;
-  }
 
-  /**
-   * Allows eager deterministic construction of XUL elements with XBL attached, by
-   * parsing an element tree and returning a DOM fragment to be inserted in the
-   * document before any of the inner elements is referenced by JavaScript.
-   *
-   * This process is required instead of calling the createElement method directly
-   * because bindings get attached when:
-   *
-   * 1. the node gets a layout frame constructed, or
-   * 2. the node gets its JavaScript reflector created, if it's in the document,
-   *
-   * whichever happens first. The createElement method would return a JavaScript
-   * reflector, but the element wouldn't be in the document, so the node wouldn't
-   * get XBL attached. After that point, even if the node is inserted into a
-   * document, it won't get XBL attached until either the frame is constructed or
-   * the reflector is garbage collected and the element is touched again.
-   *
-   * @param {string} str
-   *        String with the XML representation of XUL elements.
-   * @param {string[]} [entities]
-   *        An array of DTD URLs containing entity definitions.
-   *
-   * @return {DocumentFragment} `DocumentFragment` instance containing
-   *         the corresponding element tree, including element nodes
-   *         but excluding any text node.
-   */
-  static parseXULToFragment(str, entities = []) {
-    let doc = gXULDOMParser.parseFromString(`
-      ${entities.length ? `<!DOCTYPE bindings [
-        ${entities.reduce((preamble, url, index) => {
-          return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}">
-            %_dtd-${index};
-            `;
-        }, "")}
-      ]>` : ""}
-      <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-        ${str}
-      </box>
-    `, "application/xml");
-    // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
-    // does not do this. Most XUL code assumes that the whitespace has been
-    // stripped out, so we simply remove all text nodes after using the parser.
-    let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
-    let currentNode = nodeIterator.nextNode();
-    while (currentNode) {
-      currentNode.remove();
-      currentNode = nodeIterator.nextNode();
-    }
-    // We use a range here so that we don't access the inner DOM elements from
-    // JavaScript before they are imported and inserted into a document.
-    let range = doc.createRange();
-    range.selectNodeContents(doc.querySelector("box"));
-    return range.extractContents();
-  }
-
-  /**
-   * Insert a localization link to an FTL file. This is used so that
-   * a Custom Element can wait to inject the link until it's connected,
-   * and so that consuming documents don't require the correct <link>
-   * present in the markup.
-   *
-   * @param path
-   *        The path to the FTL file
-   */
-  static insertFTLIfNeeded(path) {
-    let container = document.head || document.querySelector("linkset");
-    if (!container) {
-      if (document.contentType == "application/vnd.mozilla.xul+xml") {
-        container = document.createXULElement("linkset");
-        document.documentElement.appendChild(container);
-      } else if (document.documentURI == AppConstants.BROWSER_CHROME_URL) {
-        // Special case for browser.xhtml. Here `document.head` is null, so
-        // just insert the link at the end of the window.
-        container = document.documentElement;
-      } else {
-        throw new Error("Attempt to inject localization link before document.head is available");
-      }
+    get isConnectedAndReady() {
+      return gIsDOMContentLoaded && this.isConnected;
     }
 
-    for (let link of container.querySelectorAll("link")) {
-      if (link.getAttribute("href") == path) {
-        return;
+    /**
+     * Allows eager deterministic construction of XUL elements with XBL attached, by
+     * parsing an element tree and returning a DOM fragment to be inserted in the
+     * document before any of the inner elements is referenced by JavaScript.
+     *
+     * This process is required instead of calling the createElement method directly
+     * because bindings get attached when:
+     *
+     * 1. the node gets a layout frame constructed, or
+     * 2. the node gets its JavaScript reflector created, if it's in the document,
+     *
+     * whichever happens first. The createElement method would return a JavaScript
+     * reflector, but the element wouldn't be in the document, so the node wouldn't
+     * get XBL attached. After that point, even if the node is inserted into a
+     * document, it won't get XBL attached until either the frame is constructed or
+     * the reflector is garbage collected and the element is touched again.
+     *
+     * @param {string} str
+     *        String with the XML representation of XUL elements.
+     * @param {string[]} [entities]
+     *        An array of DTD URLs containing entity definitions.
+     *
+     * @return {DocumentFragment} `DocumentFragment` instance containing
+     *         the corresponding element tree, including element nodes
+     *         but excluding any text node.
+     */
+    static parseXULToFragment(str, entities = []) {
+      let doc = gXULDOMParser.parseFromString(`
+        ${entities.length ? `<!DOCTYPE bindings [
+          ${entities.reduce((preamble, url, index) => {
+            return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}">
+              %_dtd-${index};
+              `;
+          }, "")}
+        ]>` : ""}
+        <box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+          ${str}
+        </box>
+      `, "application/xml");
+      // The XUL/XBL parser is set to ignore all-whitespace nodes, whereas (X)HTML
+      // does not do this. Most XUL code assumes that the whitespace has been
+      // stripped out, so we simply remove all text nodes after using the parser.
+      let nodeIterator = doc.createNodeIterator(doc, NodeFilter.SHOW_TEXT);
+      let currentNode = nodeIterator.nextNode();
+      while (currentNode) {
+        currentNode.remove();
+        currentNode = nodeIterator.nextNode();
       }
+      // We use a range here so that we don't access the inner DOM elements from
+      // JavaScript before they are imported and inserted into a document.
+      let range = doc.createRange();
+      range.selectNodeContents(doc.querySelector("box"));
+      return range.extractContents();
     }
 
-    let link = document.createElement("link");
-    link.setAttribute("rel", "localization");
-    link.setAttribute("href", path);
-
-    container.appendChild(link);
-  }
+    /**
+     * Insert a localization link to an FTL file. This is used so that
+     * a Custom Element can wait to inject the link until it's connected,
+     * and so that consuming documents don't require the correct <link>
+     * present in the markup.
+     *
+     * @param path
+     *        The path to the FTL file
+     */
+    static insertFTLIfNeeded(path) {
+      let container = document.head || document.querySelector("linkset");
+      if (!container) {
+        if (document.contentType == "application/vnd.mozilla.xul+xml") {
+          container = document.createXULElement("linkset");
+          document.documentElement.appendChild(container);
+        } else if (document.documentURI == AppConstants.BROWSER_CHROME_URL) {
+          // Special case for browser.xhtml. Here `document.head` is null, so
+          // just insert the link at the end of the window.
+          container = document.documentElement;
+        } else {
+          throw new Error("Attempt to inject localization link before document.head is available");
+        }
+      }
 
-  /**
-   * Indicate that a class defining a XUL element implements one or more
-   * XPCOM interfaces by adding a getCustomInterface implementation to it.
-   *
-   * The supplied class should implement the properties and methods of
-   * all of the interfaces that are specified.
-   *
-   * @param cls
-   *        The class that implements the interface.
-   * @param names
-   *        Array of interface names.
-   */
-  static implementCustomInterface(cls, ifaces) {
-    const numbers = new Set(ifaces.map(i => i.number));
-    if (cls.prototype.customInterfaceNumbers) {
-      // Base class already implemented some interfaces. Inherit:
-      cls.prototype.customInterfaceNumbers.forEach(number => numbers.add(number));
+      for (let link of container.querySelectorAll("link")) {
+        if (link.getAttribute("href") == path) {
+          return;
+        }
+      }
+
+      let link = document.createElement("link");
+      link.setAttribute("rel", "localization");
+      link.setAttribute("href", path);
+
+      container.appendChild(link);
     }
 
-    cls.prototype.customInterfaceNumbers = numbers;
-    cls.prototype.getCustomInterfaceCallback = function getCustomInterfaceCallback(iface) {
-      if (numbers.has(iface.number)) {
-        return getInterfaceProxy(this);
+    /**
+     * Indicate that a class defining a XUL element implements one or more
+     * XPCOM interfaces by adding a getCustomInterface implementation to it.
+     *
+     * The supplied class should implement the properties and methods of
+     * all of the interfaces that are specified.
+     *
+     * @param cls
+     *        The class that implements the interface.
+     * @param names
+     *        Array of interface names.
+     */
+    static implementCustomInterface(cls, ifaces) {
+      const numbers = new Set(ifaces.map(i => i.number));
+      if (cls.prototype.customInterfaceNumbers) {
+        // Base class already implemented some interfaces. Inherit:
+        cls.prototype.customInterfaceNumbers.forEach(number => numbers.add(number));
       }
-      return null;
-    };
-  }
+
+      cls.prototype.customInterfaceNumbers = numbers;
+      cls.prototype.getCustomInterfaceCallback = function getCustomInterfaceCallback(iface) {
+        if (numbers.has(iface.number)) {
+          return getInterfaceProxy(this);
+        }
+        return null;
+      };
+    }
+  };
 }
 
+const MozXULElement = MozElementMixin(XULElement);
+
 /**
  * Given an object, add a proxy that reflects interface implementations
  * onto the object itself.
  */
 function getInterfaceProxy(obj) {
   if (!obj._customInterfaceProxy) {
     obj._customInterfaceProxy = new Proxy(obj, {
       get(target, prop, receiver) {
@@ -230,16 +234,17 @@ class MozBaseControl extends MozXULEleme
       this.removeAttribute("tabindex");
     }
   }
 }
 
 MozXULElement.implementCustomInterface(MozBaseControl, [Ci.nsIDOMXULControlElement]);
 
 // Attach the base class to the window so other scripts can use it:
+window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozBaseControl = MozBaseControl;
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -20,30 +20,37 @@
 
   <!-- test code goes here -->
   <script type="application/javascript"><![CDATA[
 
   SimpleTest.waitForExplicitFinish();
 
   async function runTests() {
     ok(MozXULElement, "MozXULElement defined on the window");
+    testMixin();
     testParseXULToFragment();
     await testCustomInterface();
 
     let htmlWin = await new Promise(resolve => {
       let htmlIframe = document.createElement("iframe");
       htmlIframe.src = "file_empty.xhtml";
       htmlIframe.onload = () => resolve(htmlIframe.contentWindow);
       document.documentElement.appendChild(htmlIframe);
     });
 
     ok(htmlWin.MozXULElement, "MozXULElement defined on a chrome HTML window");
     SimpleTest.finish();
   }
 
+  function testMixin() {
+    ok(MozElementMixin, "Mixin exists");
+    let mixedHTMLElement = MozElementMixin(HTMLElement);
+    ok(mixedHTMLElement.insertFTLIfNeeded, "Mixed in class contains helper functions");
+  }
+
   function testParseXULToFragment() {
     ok(MozXULElement.parseXULToFragment, "parseXULToFragment helper exists");
 
     let frag = MozXULElement.parseXULToFragment(`<deck id='foo' />`);
     ok(frag instanceof DocumentFragment);
 
     document.documentElement.appendChild(frag);
 
