# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a3fb4eb11fcf840b9e0d65a06be6cf64584add08
Bug 1291049 - Attempt to bundle the inspector with webpack

MozReview-Commit-ID: LMtEQCtwCgN

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -70,16 +70,18 @@
 ^python/psutil/.*\.so
 ^python/psutil/.*\.pyd
 ^python/psutil/build/
 
 # Git repositories
 .git/
 
 # Ignore chrome.manifest files from the devtools loader
+^devtools/client/node_modules
+^devtools/client/inspector/inspector.bundle.js
 ^devtools/client/chrome.manifest$
 ^devtools/shared/chrome.manifest$
 
 # git checkout of libstagefright
 ^media/libstagefright/android$
 
 # Tag files generated by GNU Global
 GTAGS
diff --git a/devtools/client/.babelrc b/devtools/client/.babelrc
new file mode 100644
--- /dev/null
+++ b/devtools/client/.babelrc
@@ -0,0 +1,1 @@
+ { "presets": [ "es2015" ] }
\ No newline at end of file
diff --git a/devtools/client/inspector/inspector-panel.js b/devtools/client/inspector/inspector-panel.js
--- a/devtools/client/inspector/inspector-panel.js
+++ b/devtools/client/inspector/inspector-panel.js
@@ -40,16 +40,18 @@ loader.lazyGetter(this, "strings", () =>
 });
 loader.lazyGetter(this, "toolboxStrings", () => {
   return Services.strings.createBundle("chrome://devtools/locale/toolbox.properties");
 });
 loader.lazyGetter(this, "clipboardHelper", () => {
   return Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
 });
 
+
+
 /**
  * Represents an open instance of the Inspector for a tab.
  * The inspector controls the breadcrumbs, the markup view, and the sidebar
  * (computed view, rule view, font view and layout view).
  *
  * Events:
  * - ready
  *      Fired when the inspector panel is opened for the first time and ready to
@@ -590,23 +592,23 @@ InspectorPanel.prototype = {
 
   _selectionCssSelector: null,
 
   /**
    * Set the currently selected node unique css selector.
    * Will store the current target url along with it to allow pre-selection at
    * reload
    */
-  set selectionCssSelector(cssSelector = null) {
+  set selectionCssSelector(cssSelector) {
     if (this._panelDestroyer) {
       return;
     }
 
     this._selectionCssSelector = {
-      selector: cssSelector,
+      selector: cssSelector || null,
       url: this._target.url
     };
   },
 
   /**
    * Get the current selection unique css selector if any, that is, if a node
    * is actually selected and that node has been selected while on the same url
    */
diff --git a/devtools/client/inspector/inspector.xhtml b/devtools/client/inspector/inspector.xhtml
new file mode 100644
--- /dev/null
+++ b/devtools/client/inspector/inspector.xhtml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+  <meta charset="UTF-8" />
+</head>
+<body>
+  <p>
+    Temp inspector
+  </p>
+  <script src="inspector.bundle.js"></script>
+</body>
+</html>
\ No newline at end of file
diff --git a/devtools/client/package.json b/devtools/client/package.json
new file mode 100644
--- /dev/null
+++ b/devtools/client/package.json
@@ -0,0 +1,21 @@
+{
+  "name": "inspector",
+  "version": "1.0.0",
+  "description": "",
+  "main": "",
+  "directories": {
+    "test": "test"
+  },
+  "scripts": {
+    "build": "webpack"
+  },
+  "author": "",
+  "license": "",
+  "devDependencies": {
+    "babel-core": "^6.11.4",
+    "babel-loader": "^6.2.4",
+    "babel-preset-es2015": "^6.9.0",
+    "raw-loader": "^0.5.1",
+    "webpack": "^1.13.1"
+  }
+}
diff --git a/devtools/client/sourceeditor/autocomplete.js b/devtools/client/sourceeditor/autocomplete.js
--- a/devtools/client/sourceeditor/autocomplete.js
+++ b/devtools/client/sourceeditor/autocomplete.js
@@ -27,19 +27,19 @@ function initializeAutoCompletion(ctx, o
   let win = ed.container.contentWindow.wrappedJSObject;
   let { CodeMirror, document } = win;
 
   let completer = null;
   let autocompleteKey = "Ctrl-" +
                         Editor.keyFor("autocompletion", { noaccel: true });
   if (ed.config.mode == Editor.modes.js) {
     let defs = [
-      "./tern/browser",
-      "./tern/ecma5",
-    ].map(require);
+      require("./tern/browser"),
+      require("./tern/ecma5"),
+    ];
 
     CM_TERN_SCRIPTS.forEach(ed.loadScript, ed);
     win.tern = require("./tern/tern");
     cm.tern = new CodeMirror.TernServer({
       defs: defs,
       typeTip: function (data) {
         let tip = document.createElement("span");
         tip.className = "CodeMirror-Tern-information";
diff --git a/devtools/client/webpack.config.js b/devtools/client/webpack.config.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webpack.config.js
@@ -0,0 +1,127 @@
+
+"use strict";
+
+/*
+ Instructions for building:
+
+  cd devtools/client
+  npm run build
+  npm install
+  webpack
+  open inspector/simple.html in a browser
+
+*/
+
+const path = require("path");
+const webpack = require("webpack");
+
+module.exports = {
+  bail: true,
+  context: __dirname + "/inspector",
+  entry: './inspector-panel.js',
+  output: {
+    filename: './inspector/inspector.bundle.js',
+  },
+  module: {
+    loaders: [
+      {
+        test: /\.js$/,
+        exclude: /node_modules/,
+        loader: "babel-loader",
+        // query: { compact: false },
+      }
+    ]
+  },
+  resolveLoader: {
+    packageMains: ["webpackLoader", "webLoader"],
+    root: [
+      path.resolve('./node_modules'),
+    ]
+  },
+  resolve: {
+    packageMains: ["webpack"],
+    alias: {
+      devtools: path.join(__dirname, "../"),
+      Services: path.join(__dirname, "./shared/shim/Services.js"),
+
+      // I don't understand why it's trying to load any of this, yet
+      gcli: path.join(__dirname, "../shared/gcli/source/lib/gcli"),
+      "acorn/util/walk": path.join(__dirname, "../shared/acorn/walk"),
+      acorn: path.join(__dirname, "../shared/acorn"),
+
+      // Somehow need to fix:
+      // Module not found: Error: Cannot resolve 'file' or 'directory' ../lib/codemirror in /Users/bgrinstead/Code/fx-team/devtools/client/sourceeditor/codemirror/mode
+      // Due to some wonky paths in codemirror dependencies like modes
+      // But this doesn't work
+      // "../lib/codemirror": path.join(__dirname, "./sourceeditor/codemirror"),
+
+
+      // "source-map": "resource://devtools/shared/sourcemap/source-map.js",
+      // Hardcode en-US for now
+      // l10n: path.join(__dirname, "locales", "en-US"),
+      // sdk: path.join(__dirname, "sdk"),
+      // acorn: path.join(__dirname, "../shared/acorn"),
+    },
+  },
+
+  plugins: [
+    new webpack.DefinePlugin({
+      "isWorker": JSON.stringify(false),
+      "reportError": "console.error",
+      "loader": "{ lazyRequireGetter: () => {} }",
+      "dump": "console.log",
+    }),
+    new webpack.ContextReplacementPlugin(/.*$/, /NEVER_MATCH^/),
+  ],
+
+  externals: [
+    /codemirror/,
+    /resource\:\/\//,
+    /sdk\//,
+    /tests\//,
+    /test\//,
+    /testharness\//,
+    {
+      "promise": "var Promise",
+      "FileReader": "var FileReader",
+      "indexedDB": "var indexedDB",
+
+      // Just trying to get build to work.  These should be removed eventually:
+      "chrome": "{}",
+      "loader": "{}",
+      "toolkit/loader": "{}",
+
+      "xpcInspector": "{}",
+      "Debugger": "{}",
+      "source-map": "{}",
+      "fake_module": "{}",
+
+      // I don't understand why it's trying to load any of this, yet
+      "devtools/client/inspector/inspector-panel": "{}",
+      "devtools/server/actors/utils/audionodes.json": "{}",
+
+      // "resource://gre/modules/XPCOMUtils.jsm": "{}",
+      // "resource://gre/modules/AddonManager.jsm": "{}",
+      // "resource://gre/modules/FileUtils.jsm": "{}",
+      // "resource://gre/modules/PermissionsTable.jsm": "{}",
+      // "resource://devtools/client/styleeditor/StyleEditorUI.jsm": "{}",
+      // "resource://devtools/client/styleeditor/StyleEditorUtil.jsm": "{}",
+      // "sdk": "{}",
+      // "sdk/core/heritage": "{}",
+      // "sdk/event/core": "{}",
+      // "sdk/clipboard": "{}",
+      // "sdk/event/target": "{}",
+      // "sdk/util/object": "{}",
+      // "sdk/frame/utils": "{}",
+      // "sdk/system/unload": "{}",
+      // "sdk/lang/functional": "{}",
+      // "sdk/window/utils": "{}",
+      // "sdk/indexed-db": "{}",
+      // "sdk/loader/sandbox": "{}",
+      // "sdk/console/plain-text": "{}",
+      // "sdk/stylesheet/style": "{}",
+      // "sdk/content/mod": "{}",
+    },
+
+  ],
+};
diff --git a/devtools/shared/event-emitter.js b/devtools/shared/event-emitter.js
--- a/devtools/shared/event-emitter.js
+++ b/devtools/shared/event-emitter.js
@@ -1,259 +1,132 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-"use strict";
+/**
+ * EventEmitter.
+ */
 
-(function (factory) {
-  // This file can be loaded in several different ways.  It can be
-  // require()d, either from the main thread or from a worker thread;
-  // or it can be imported via Cu.import.  These different forms
-  // explain some of the hairiness of this code.
-  //
-  // It's important for the devtools-as-html project that a require()
-  // on the main thread not use any chrome privileged APIs.  Instead,
-  // the body of the main function can only require() (not Cu.import)
-  // modules that are available in the devtools content mode.  This,
-  // plus the lack of |console| in workers, results in some gyrations
-  // in the definition of |console|.
-  if (this.module && module.id.indexOf("event-emitter") >= 0) {
-    let console;
-    if (isWorker) {
-      console = {
-        error: () => {}
-      };
-    } else {
-      console = this.console;
+var EventEmitter = function EventEmitter() {};
+module.exports = EventEmitter;
+
+const { Cu } = require("chrome");
+const promise = require("promise");
+
+/**
+ * Decorate an object with event emitter functionality.
+ *
+ * @param Object aObjectToDecorate
+ *        Bind all public methods of EventEmitter to
+ *        the aObjectToDecorate object.
+ */
+EventEmitter.decorate = function EventEmitter_decorate (aObjectToDecorate) {
+  let emitter = new EventEmitter();
+  aObjectToDecorate.on = emitter.on.bind(emitter);
+  aObjectToDecorate.off = emitter.off.bind(emitter);
+  aObjectToDecorate.once = emitter.once.bind(emitter);
+  aObjectToDecorate.emit = emitter.emit.bind(emitter);
+};
+
+EventEmitter.prototype = {
+  /**
+   * Connect a listener.
+   *
+   * @param string aEvent
+   *        The event name to which we're connecting.
+   * @param function aListener
+   *        Called when the event is fired.
+   */
+  on: function EventEmitter_on(aEvent, aListener) {
+    if (!this._eventEmitterListeners)
+      this._eventEmitterListeners = new Map();
+    if (!this._eventEmitterListeners.has(aEvent)) {
+      this._eventEmitterListeners.set(aEvent, []);
     }
-    // require
-    factory.call(this, require, exports, module, console);
-  } else {
-    // Cu.import.  This snippet implements a sort of miniature loader,
-    // which is responsible for appropriately translating require()
-    // requests from the client function.  This code can use
-    // Cu.import, because it is never run in the devtools-in-content
-    // mode.
-    this.isWorker = false;
-    const Cu = Components.utils;
-    let console = Cu.import("resource://gre/modules/Console.jsm", {}).console;
-    // Bug 1259045: This module is loaded early in firefox startup as a JSM,
-    // but it doesn't depends on any real module. We can save a few cycles
-    // and bytes by not loading Loader.jsm.
-    let require = function (module) {
-      switch (module) {
-        case "devtools/shared/defer":
-          return Cu.import("resource://gre/modules/Promise.jsm", {}).Promise.defer;
-        case "Services":
-          return Cu.import("resource://gre/modules/Services.jsm", {}).Services;
-        case "chrome":
-          return {
-            Cu,
-            components: Components
-          };
-      }
-      return null;
-    };
-    factory.call(this, require, this, { exports: this }, console);
-    this.EXPORTED_SYMBOLS = ["EventEmitter"];
-  }
-}).call(this, function (require, exports, module, console) {
-  // ⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠
-  // After this point the code may not use Cu.import, and should only
-  // require() modules that are "clean-for-content".
-  let EventEmitter = this.EventEmitter = function () {};
-  module.exports = EventEmitter;
-
-  // See comment in JSM module boilerplate when adding a new dependency.
-  const { components } = require("chrome");
-  const Services = require("Services");
-  const defer = require("devtools/shared/defer");
-  let loggingEnabled = true;
-
-  if (!isWorker) {
-    loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
-    Services.prefs.addObserver("devtools.dump.emit", {
-      observe: () => {
-        loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
-      }
-    }, false);
-  }
+    this._eventEmitterListeners.get(aEvent).push(aListener);
+  },
 
   /**
-   * Decorate an object with event emitter functionality.
+   * Listen for the next time an event is fired.
    *
-   * @param Object objectToDecorate
-   *        Bind all public methods of EventEmitter to
-   *        the objectToDecorate object.
+   * @param string aEvent
+   *        The event name to which we're connecting.
+   * @param function aListener
+   *        (Optional) Called when the event is fired. Will be called at most
+   *        one time.
+   * @return promise
+   *        A promise which is resolved when the event next happens. The
+   *        resolution value of the promise is the first event argument. If
+   *        you need access to second or subsequent event arguments (it's rare
+   *        that this is needed) then use aListener
    */
-  EventEmitter.decorate = function (objectToDecorate) {
-    let emitter = new EventEmitter();
-    objectToDecorate.on = emitter.on.bind(emitter);
-    objectToDecorate.off = emitter.off.bind(emitter);
-    objectToDecorate.once = emitter.once.bind(emitter);
-    objectToDecorate.emit = emitter.emit.bind(emitter);
-  };
-
-  EventEmitter.prototype = {
-    /**
-     * Connect a listener.
-     *
-     * @param string event
-     *        The event name to which we're connecting.
-     * @param function listener
-     *        Called when the event is fired.
-     */
-    on(event, listener) {
-      if (!this._eventEmitterListeners) {
-        this._eventEmitterListeners = new Map();
-      }
-      if (!this._eventEmitterListeners.has(event)) {
-        this._eventEmitterListeners.set(event, []);
-      }
-      this._eventEmitterListeners.get(event).push(listener);
-    },
+  once: function EventEmitter_once(aEvent, aListener) {
+    let deferred = promise.defer();
 
-    /**
-     * Listen for the next time an event is fired.
-     *
-     * @param string event
-     *        The event name to which we're connecting.
-     * @param function listener
-     *        (Optional) Called when the event is fired. Will be called at most
-     *        one time.
-     * @return promise
-     *        A promise which is resolved when the event next happens. The
-     *        resolution value of the promise is the first event argument. If
-     *        you need access to second or subsequent event arguments (it's rare
-     *        that this is needed) then use listener
-     */
-    once(event, listener) {
-      let deferred = defer();
-
-      let handler = (_, first, ...rest) => {
-        this.off(event, handler);
-        if (listener) {
-          listener.apply(null, [event, first, ...rest]);
-        }
-        deferred.resolve(first);
-      };
-
-      handler._originalListener = listener;
-      this.on(event, handler);
+    let handler = (aEvent, aFirstArg, ...aRest) => {
+      this.off(aEvent, handler);
+      if (aListener) {
+        aListener.apply(null, [aEvent, aFirstArg, ...aRest]);
+      }
+      deferred.resolve(aFirstArg);
+    };
 
-      return deferred.promise;
-    },
+    handler._originalListener = aListener;
+    this.on(aEvent, handler);
 
-    /**
-     * Remove a previously-registered event listener.  Works for events
-     * registered with either on or once.
-     *
-     * @param string event
-     *        The event name whose listener we're disconnecting.
-     * @param function listener
-     *        The listener to remove.
-     */
-    off(event, listener) {
+    return deferred.promise;
+  },
+
+  /**
+   * Remove a previously-registered event listener.  Works for events
+   * registered with either on or once.
+   *
+   * @param string aEvent
+   *        The event name whose listener we're disconnecting.
+   * @param function aListener
+   *        The listener to remove.
+   */
+  off: function EventEmitter_off(aEvent, aListener) {
+    if (!this._eventEmitterListeners)
+      return;
+    let listeners = this._eventEmitterListeners.get(aEvent);
+    if (listeners) {
+      this._eventEmitterListeners.set(aEvent, listeners.filter(l => {
+        return l !== aListener && l._originalListener !== aListener;
+      }));
+    }
+  },
+
+  /**
+   * Emit an event.  All arguments to this method will
+   * be sent to listener functions.
+   */
+  emit: function EventEmitter_emit(aEvent) {
+    if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(aEvent)) {
+      return;
+    }
+
+    let originalListeners = this._eventEmitterListeners.get(aEvent);
+    for (let listener of this._eventEmitterListeners.get(aEvent)) {
+      // If the object was destroyed during event emission, stop
+      // emitting.
       if (!this._eventEmitterListeners) {
-        return;
-      }
-      let listeners = this._eventEmitterListeners.get(event);
-      if (listeners) {
-        this._eventEmitterListeners.set(event, listeners.filter(l => {
-          return l !== listener && l._originalListener !== listener;
-        }));
-      }
-    },
-
-    /**
-     * Emit an event.  All arguments to this method will
-     * be sent to listener functions.
-     */
-    emit(event) {
-      this.logEvent(event, arguments);
-
-      if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(event)) {
-        return;
+        break;
       }
 
-      let originalListeners = this._eventEmitterListeners.get(event);
-      for (let listener of this._eventEmitterListeners.get(event)) {
-        // If the object was destroyed during event emission, stop
-        // emitting.
-        if (!this._eventEmitterListeners) {
-          break;
+      // If listeners were removed during emission, make sure the
+      // event handler we're going to fire wasn't removed.
+      if (originalListeners === this._eventEmitterListeners.get(aEvent) ||
+          this._eventEmitterListeners.get(aEvent).some(l => l === listener)) {
+        try {
+          listener.apply(null, arguments);
         }
-
-        // If listeners were removed during emission, make sure the
-        // event handler we're going to fire wasn't removed.
-        if (originalListeners === this._eventEmitterListeners.get(event) ||
-          this._eventEmitterListeners.get(event).some(l => l === listener)) {
-          try {
-            listener.apply(null, arguments);
-          } catch (ex) {
-            // Prevent a bad listener from interfering with the others.
-            let msg = ex + ": " + ex.stack;
-            console.error(msg);
-            dump(msg + "\n");
-          }
+        catch (ex) {
+          // Prevent a bad listener from interfering with the others.
+          let msg = ex + ": " + ex.stack;
+          //console.error(msg);
+          console.log(msg);
         }
       }
-    },
-
-    logEvent(event, args) {
-      if (!loggingEnabled) {
-        return;
-      }
-
-      let caller, func, path;
-      if (!isWorker) {
-        caller = components.stack.caller.caller;
-        func = caller.name;
-        let file = caller.filename;
-        if (file.includes(" -> ")) {
-          file = caller.filename.split(/ -> /)[1];
-        }
-        path = file + ":" + caller.lineNumber;
-      }
-
-      let argOut = "(";
-      if (args.length === 1) {
-        argOut += event;
-      }
-
-      let out = "EMITTING: ";
-
-      // We need this try / catch to prevent any dead object errors.
-      try {
-        for (let i = 1; i < args.length; i++) {
-          if (i === 1) {
-            argOut = "(" + event + ", ";
-          } else {
-            argOut += ", ";
-          }
-
-          let arg = args[i];
-          argOut += arg;
-
-          if (arg && arg.nodeName) {
-            argOut += " (" + arg.nodeName;
-            if (arg.id) {
-              argOut += "#" + arg.id;
-            }
-            if (arg.className) {
-              argOut += "." + arg.className;
-            }
-            argOut += ")";
-          }
-        }
-      } catch (e) {
-        // Object is dead so the toolbox is most likely shutting down,
-        // do nothing.
-      }
-
-      argOut += ")";
-      out += "emit" + argOut + " from " + func + "() -> " + path + "\n";
-
-      dump(out);
-    },
-  };
-});
+    }
+  },
+};
