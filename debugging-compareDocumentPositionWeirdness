# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0c25083d107b07dde9f895a88d7b8402eee7e811
weird

diff --git a/devtools/client/framework/selection.js b/devtools/client/framework/selection.js
--- a/devtools/client/framework/selection.js
+++ b/devtools/client/framework/selection.js
@@ -156,16 +156,17 @@ Selection.prototype = {
     if (this.isNode()) {
       return this.node.ownerDocument;
     }
     return null;
   },
 
   setNodeFront: function(value, reason="unknown") {
     this.reason = reason;
+    console.log("SETTING NODE FRONT", value)
 
     // If a singleTextChild text node is being set, then set it's parent instead.
     let parentNode = value && value.parentNode();
     if (value && parentNode && parentNode.singleTextChild === value) {
       value = parentNode;
     }
 
     // We used to return here if the node had not changed but we now need to
diff --git a/devtools/client/inspector/test/browser_inspector_search-05.js b/devtools/client/inspector/test/browser_inspector_search-05.js
--- a/devtools/client/inspector/test/browser_inspector_search-05.js
+++ b/devtools/client/inspector/test/browser_inspector_search-05.js
@@ -6,63 +6,91 @@
 // Testing that when search results contain suggestions for nodes in other
 // frames, selecting these suggestions actually selects the right nodes.
 
 const IFRAME_SRC = "doc_inspector_search.html";
 const TEST_URL = "data:text/html;charset=utf-8," +
                  "<iframe id=\"iframe-1\" src=\"" +
                  TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>" +
                  "<iframe id=\"iframe-2\" src=\"" +
-                 TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>";
+                 TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>" +
+                 "<iframe id='iframe-3' src='data:text/html," +
+                   "<button id=\"b1\">Nested button</button>" +
+                   "<iframe id=\"frame-4\" src=" + TEST_URL_ROOT + IFRAME_SRC + "></iframe>'>" +
+                 "</iframe>";
 
 add_task(function* () {
-  let {inspector} = yield openInspectorForURL(TEST_URL);
+  let tab = gBrowser.selectedTab = gBrowser.addTab(TEST_URL);
+  // let tab = yield addTab(TEST_URL);
+  let browser = gBrowser.selectedBrowser;
+
+  let numLoaded = 3;
+  yield new Promise(resolve => {
+    info("Waiting for DOMContentLoaded event");
+    browser.addEventListener("DOMContentLoaded", function load(e) {
+      numLoaded--;
+      console.log(numLoaded, e, e.target);
+      if (numLoaded === 0) {
+        browser.removeEventListener("DOMContentLoaded", load, false, true);
+        resolve();
+      }
+    }, false, true);
+  });
+
+  let {inspector} = yield openInspector(null);
   let {walker} = inspector;
 
   let searchBox = inspector.searchBox;
   let popup = inspector.searchSuggestions.searchPopup;
 
   info("Focus the search box");
   yield focusSearchBoxUsingShortcut(inspector.panelWin);
 
   info("Enter # to search for all ids");
-  let processingDone = once(inspector.searchSuggestions, "processing-done");
-  EventUtils.synthesizeKey("#", {}, inspector.panelWin);
-  yield processingDone;
+  for (let key of ["#", "b", "1"]) {
+    let processingDone = once(inspector.searchSuggestions, "processing-done");
+    EventUtils.synthesizeKey(key, {}, inspector.panelWin);
+    // yield processingDone;
+  }
 
-  info("Wait for search query to complete");
-  yield inspector.searchSuggestions._lastQuery;
+  // info("Wait for search query to complete");
+  // yield inspector.searchSuggestions._lastQuery;
 
-  info("Press tab to fill the search input with the first suggestion");
-  processingDone = once(inspector.searchSuggestions, "processing-done");
-  EventUtils.synthesizeKey("VK_TAB", {}, inspector.panelWin);
-  yield processingDone;
+  // info("Press tab to fill the search input with the first suggestion");
+  // processingDone = once(inspector.searchSuggestions, "processing-done");
+  // EventUtils.synthesizeKey("VK_TAB", {}, inspector.panelWin);
+  // yield processingDone;
 
   info("Press enter and expect a new selection");
   let onSelect = inspector.once("inspector-updated");
   EventUtils.synthesizeKey("VK_RETURN", {}, inspector.panelWin);
   yield onSelect;
 
   let node = inspector.selection.nodeFront;
   ok(node.id, "b1", "The selected node is #b1");
   ok(node.tagName.toLowerCase(), "button",
     "The selected node is <button>");
 
   let selectedNodeDoc = yield walker.document(node);
   let iframe1 = yield walker.querySelector(walker.rootNode, "#iframe-1");
   let iframe1Doc = (yield walker.children(iframe1)).nodes[0];
   is(selectedNodeDoc, iframe1Doc, "The selected node is in iframe 1");
 
+  if (selectedNodeDoc != iframe1Doc) {
+
+  }
   info("Press enter to cycle through multiple nodes matching this suggestion");
   onSelect = inspector.once("inspector-updated");
   EventUtils.synthesizeKey("VK_RETURN", {}, inspector.panelWin);
   yield onSelect;
 
   node = inspector.selection.nodeFront;
   ok(node.id, "b1", "The selected node is #b1 again");
   ok(node.tagName.toLowerCase(), "button",
     "The selected node is <button> again");
 
   selectedNodeDoc = yield walker.document(node);
   let iframe2 = yield walker.querySelector(walker.rootNode, "#iframe-2");
   let iframe2Doc = (yield walker.children(iframe2)).nodes[0];
   is(selectedNodeDoc, iframe2Doc, "The selected node is in iframe 2");
+
+  yield new Promise(() => {});
 });
diff --git a/devtools/server/actors/utils/walker-search.js b/devtools/server/actors/utils/walker-search.js
--- a/devtools/server/actors/utils/walker-search.js
+++ b/devtools/server/actors/utils/walker-search.js
@@ -243,18 +243,29 @@ WalkerSearch.prototype = {
 
         // For now, just do one result per node since the frontend
         // doesn't have a way to highlight each result individually
         // yet.
         break;
       }
     }
 
+    let documents = this.walker.tabActor.windows.map(win=>win.document);
+
     // Sort the resulting nodes by order of appearance in the DOM
     resultList.sort((a,b) => {
+      // Disconnected nodes won't get good results from compareDocumentPosition
+      // so check the order of their document instead.
+      if (a.node.ownerDocument != b.node.ownerDocument) {
+        let indA = documents.indexOf(a.node.ownerDocument);
+        let indB = documents.indexOf(b.node.ownerDocument);
+        return indA - indB;
+      }
+      // If the same document, then sort on DOCUMENT_POSITION_FOLLOWING (4)
+      // which means B is after A.
       return a.node.compareDocumentPosition(b.node) & 4 ? -1 : 1;
     });
 
     return resultList;
   }
 };
 
 WalkerSearch.SEARCH_METHOD_CONTAINS = (query, candidate) => {
