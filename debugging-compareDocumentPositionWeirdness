# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  0c25083d107b07dde9f895a88d7b8402eee7e811
weird

diff --git a/devtools/client/framework/selection.js b/devtools/client/framework/selection.js
--- a/devtools/client/framework/selection.js
+++ b/devtools/client/framework/selection.js
@@ -156,16 +156,17 @@ Selection.prototype = {
     if (this.isNode()) {
       return this.node.ownerDocument;
     }
     return null;
   },
 
   setNodeFront: function(value, reason="unknown") {
     this.reason = reason;
+    console.log("SETTING NODE FRONT", value)
 
     // If a singleTextChild text node is being set, then set it's parent instead.
     let parentNode = value && value.parentNode();
     if (value && parentNode && parentNode.singleTextChild === value) {
       value = parentNode;
     }
 
     // We used to return here if the node had not changed but we now need to
diff --git a/devtools/client/inspector/test/browser_inspector_search-05.js b/devtools/client/inspector/test/browser_inspector_search-05.js
--- a/devtools/client/inspector/test/browser_inspector_search-05.js
+++ b/devtools/client/inspector/test/browser_inspector_search-05.js
@@ -9,53 +9,76 @@
 const IFRAME_SRC = "doc_inspector_search.html";
 const TEST_URL = "data:text/html;charset=utf-8," +
                  "<iframe id=\"iframe-1\" src=\"" +
                  TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>" +
                  "<iframe id=\"iframe-2\" src=\"" +
                  TEST_URL_ROOT + IFRAME_SRC + "\"></iframe>";
 
 add_task(function* () {
-  let {inspector} = yield openInspectorForURL(TEST_URL);
+  let tab = gBrowser.selectedTab = gBrowser.addTab(TEST_URL);
+  // let tab = yield addTab(TEST_URL);
+  let browser = gBrowser.selectedBrowser;
+
+  let numLoaded = 3;
+  yield new Promise(resolve => {
+    info("Waiting for DOMContentLoaded event");
+    browser.addEventListener("DOMContentLoaded", function load(e) {
+      numLoaded--;
+      console.log(numLoaded, e, e.target);
+      if (numLoaded === 0) {
+        browser.removeEventListener("DOMContentLoaded", load, false, true);
+        resolve();
+      }
+    }, false, true);
+  });
+
+  let {inspector} = yield openInspector(null);
   let {walker} = inspector;
 
   let searchBox = inspector.searchBox;
   let popup = inspector.searchSuggestions.searchPopup;
 
   info("Focus the search box");
   yield focusSearchBoxUsingShortcut(inspector.panelWin);
 
   info("Enter # to search for all ids");
-  let processingDone = once(inspector.searchSuggestions, "processing-done");
-  EventUtils.synthesizeKey("#", {}, inspector.panelWin);
-  yield processingDone;
+  for (let key of ["#", "b", "1"]) {
+    let processingDone = once(inspector.searchSuggestions, "processing-done");
+    EventUtils.synthesizeKey(key, {}, inspector.panelWin);
+    // yield processingDone;
+  }
 
-  info("Wait for search query to complete");
-  yield inspector.searchSuggestions._lastQuery;
+  // info("Wait for search query to complete");
+  // yield inspector.searchSuggestions._lastQuery;
 
-  info("Press tab to fill the search input with the first suggestion");
-  processingDone = once(inspector.searchSuggestions, "processing-done");
-  EventUtils.synthesizeKey("VK_TAB", {}, inspector.panelWin);
-  yield processingDone;
+  // info("Press tab to fill the search input with the first suggestion");
+  // processingDone = once(inspector.searchSuggestions, "processing-done");
+  // EventUtils.synthesizeKey("VK_TAB", {}, inspector.panelWin);
+  // yield processingDone;
 
   info("Press enter and expect a new selection");
   let onSelect = inspector.once("inspector-updated");
   EventUtils.synthesizeKey("VK_RETURN", {}, inspector.panelWin);
   yield onSelect;
 
   let node = inspector.selection.nodeFront;
   ok(node.id, "b1", "The selected node is #b1");
   ok(node.tagName.toLowerCase(), "button",
     "The selected node is <button>");
 
   let selectedNodeDoc = yield walker.document(node);
   let iframe1 = yield walker.querySelector(walker.rootNode, "#iframe-1");
   let iframe1Doc = (yield walker.children(iframe1)).nodes[0];
   is(selectedNodeDoc, iframe1Doc, "The selected node is in iframe 1");
 
+  if (selectedNodeDoc != iframe1Doc) {
+  yield new Promise(() => {})
+
+  }
   info("Press enter to cycle through multiple nodes matching this suggestion");
   onSelect = inspector.once("inspector-updated");
   EventUtils.synthesizeKey("VK_RETURN", {}, inspector.panelWin);
   yield onSelect;
 
   node = inspector.selection.nodeFront;
   ok(node.id, "b1", "The selected node is #b1 again");
   ok(node.tagName.toLowerCase(), "button",
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -2074,16 +2074,20 @@ var WalkerActor = protocol.ActorClass({
    *            - {NodeList} list
    *            - {Array<Object>} metadata. Extra information with indices that
    *                              match up with node list.
    */
   search: method(function(query) {
     let results = this.walkerSearch.search(query);
     let nodeList = new NodeListActor(this, results.map(r => r.node));
 
+    console.log("results returned from search", results.map(r => {
+      let frame = r.node.ownerDocument.defaultView.frameElement;
+      return (frame && frame.id)  + " - " + r.node.nodeName;
+    }));
     return {
       list: nodeList,
       metadata: []
     }
   }, {
     request: {
       query: Arg(0),
     },
@@ -3394,31 +3398,35 @@ var WalkerFront = exports.WalkerFront = 
         nodeList = yield this.querySelectorAll(this.rootNode, query);
       }
     } else {
       searchType = "search";
       let result = yield this._search(query, options);
       nodeList = result.list;
     }
 
+
+    console.log("Got result", options, nodeList, searchData.index);
+
     // If this is a new search, start at the beginning.
     if (searchData.query !== query ||
         searchData.selectorOnly !== selectorOnly) {
       searchData.selectorOnly = selectorOnly;
       searchData.query = query;
       searchData.index = -1;
     }
 
     if (!nodeList.length) {
       return null;
     }
 
     // Move search result cursor and cycle if necessary.
     searchData.index = options.reverse ? searchData.index - 1 :
                                          searchData.index + 1;
+    console.log("searchData.index been set", searchData.index);
     if (searchData.index >= nodeList.length) {
       searchData.index = 0;
     }
     if (searchData.index < 0) {
       searchData.index = nodeList.length - 1;
     }
 
     // Send back the single node, along with any relevant search data
diff --git a/devtools/server/actors/utils/walker-search.js b/devtools/server/actors/utils/walker-search.js
--- a/devtools/server/actors/utils/walker-search.js
+++ b/devtools/server/actors/utils/walker-search.js
@@ -8,16 +8,18 @@
  * The walker-search module provides a simple API to index and search strings
  * and elements inside a given document.
  * It indexes tag names, attribute names and values, and text contents.
  * It provides a simple search function that returns a list of nodes that
  * matched.
  */
 
 const {Ci, Cu} = require("chrome");
+const DOCUMENT_POSITION_DISCONNECTED = 1;
+const DOCUMENT_POSITION_FOLLOWING = 4;
 
 /**
  * The WalkerIndex class indexes the document (and all subdocs) from
  * a given walker.
  *
  * It is only indexed the first time the data is accessed and will be
  * re-indexed if a mutation happens between requests.
  *
@@ -35,16 +37,17 @@ WalkerIndex.prototype = {
   /**
    * Destroy this instance, releasing all data and references
    */
   destroy: function() {
     this.walker.off("any-mutation", this.clearIndex);
   },
 
   clearIndex: function() {
+    console.log("Clearing index", this.currentlyIndexing);
     if (!this.currentlyIndexing) {
       this._data = null;
     }
   },
 
   get doc() {
     return this.walker.rootDoc;
   },
@@ -70,24 +73,30 @@ WalkerIndex.prototype = {
 
   _addToIndex: function(type, node, value) {
     // Add an entry for this value if there isn't one
     let entry = this._data.get(value);
     if (!entry) {
       this._data.set(value, []);
     }
 
+    if (node.id == "b1") {
+      let frame = node.ownerDocument.defaultView.frameElement;
+      console.log("ADDING b1", node, type, frame && frame.id)
+    }
+
     // Add the type/node to the list
     this._data.get(value).push({
       type: type,
       node: node
     });
   },
 
   index: function() {
+    console.log("DOING index", this.currentlyIndexing);
     // Handle case where iterating nextNode() with the deepTreeWalker triggers
     // a mutation (Bug 1222558)
     this.currentlyIndexing = true;
 
     let documentWalker = this.walker.getDocumentWalker(this.doc);
     while (documentWalker.nextNode()) {
       let node = documentWalker.currentNode;
 
@@ -224,40 +233,64 @@ WalkerSearch.prototype = {
     }
 
     // Store results in a map indexed by nodes to avoid duplicate results
     let results = new Map();
 
     // Search through the indexed data
     this._searchIndex(query, options, results);
 
+    console.log("Searched index", results.size);
     // Search with querySelectorAll
     this._searchSelectors(query, options, results);
+    console.log("Searched selectors", results.size);
 
     // Concatenate all results into an Array to return
     let resultList = [];
     for (let [node, matches] of results) {
       for (let {type} of matches) {
+      let frame = node.ownerDocument.defaultView.frameElement;
+      console.log("Pusing ", node, type, frame && frame.id)
         resultList.push({
           node: node,
           type: type,
         });
 
         // For now, just do one result per node since the frontend
         // doesn't have a way to highlight each result individually
         // yet.
         break;
       }
     }
 
     // Sort the resulting nodes by order of appearance in the DOM
     resultList.sort((a,b) => {
-      return a.node.compareDocumentPosition(b.node) & 4 ? -1 : 1;
+      let nodeA = a.node;
+      let nodeB = b.node;
+      let position = nodeA.compareDocumentPosition(nodeB);
+      // while (nodeA && nodeB && position & DOCUMENT_POSITION_DISCONNECTED) {
+        
+      // }
+      if (position & DOCUMENT_POSITION_DISCONNECTED) {
+        return 1;
+      }
+      return position & DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
     });
 
+    console.log("ITERATING RESULT LIST!");
+    for (let i of resultList) {
+      let frame = i.node.ownerDocument.defaultView.frameElement;
+      console.log("Found ", i.node, frame && frame.id)
+
+    }
+
+    if (resultList.length == 2) {
+      console.log(resultList[0].node.compareDocumentPosition(resultList[1].node));
+    }
+
     return resultList;
   }
 };
 
 WalkerSearch.SEARCH_METHOD_CONTAINS = (query, candidate) => {
   return query && candidate.toLowerCase().indexOf(query.toLowerCase()) !== -1;
 };
 
