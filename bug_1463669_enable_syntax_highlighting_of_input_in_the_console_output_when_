# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1534889222 25200
#      Tue Aug 21 15:07:02 2018 -0700
# Node ID 6ba10b7fa09f3fdf59a212041549888a48f1b855
# Parent  f8d52bf9ffdedf8d9197690ee848c3d88f360b53
Bug 1463669 - Enable syntax highlighting of input in the console output when possible;r=nchevobbe

When you enter JS into the console, we can now syntax highlight it in
the output when CodeMirror is enabled.

Differential Revision: https://phabricator.services.mozilla.com/D3842

diff --git a/devtools/client/webconsole/components/message-types/ConsoleCommand.js b/devtools/client/webconsole/components/message-types/ConsoleCommand.js
--- a/devtools/client/webconsole/components/message-types/ConsoleCommand.js
+++ b/devtools/client/webconsole/components/message-types/ConsoleCommand.js
@@ -2,17 +2,17 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // React & Redux
-const { createFactory } = require("devtools/client/shared/vendor/react");
+const { createElement, createFactory } = require("devtools/client/shared/vendor/react");
 const PropTypes = require("devtools/client/shared/vendor/react-prop-types");
 const Message = createFactory(require("devtools/client/webconsole/components/Message"));
 
 ConsoleCommand.displayName = "ConsoleCommand";
 
 ConsoleCommand.propTypes = {
   message: PropTypes.object.isRequired,
   timestampsVisible: PropTypes.bool.isRequired,
@@ -29,19 +29,22 @@ function ConsoleCommand(props) {
     serviceContainer,
   } = props;
 
   const {
     indent,
     source,
     type,
     level,
-    messageText: messageBody,
+    messageText,
   } = message;
 
+  // This uses a Custom Element to syntax highlight when possible. If it's not
+  // (no CodeMirror editor), then it will just render text.
+  const messageBody = createElement("syntax-highlighted", null, messageText);
   return Message({
     source,
     type,
     level,
     topLevelClasses: [],
     messageBody,
     serviceContainer,
     indent,
diff --git a/devtools/client/webconsole/test/mochitest/browser.ini b/devtools/client/webconsole/test/mochitest/browser.ini
--- a/devtools/client/webconsole/test/mochitest/browser.ini
+++ b/devtools/client/webconsole/test/mochitest/browser.ini
@@ -229,16 +229,17 @@ skip-if = os != 'mac' # The tested ctrl+
 [browser_jsterm_popup_close_on_tab_switch.js]
 [browser_jsterm_screenshot_command_clipboard.js]
 subsuite = clipboard
 [browser_jsterm_screenshot_command_user.js]
 subsuite = clipboard
 [browser_jsterm_screenshot_command_file.js]
 [browser_jsterm_selfxss.js]
 subsuite = clipboard
+[browser_jsterm_syntax_highlight_output.js]
 [browser_webconsole_allow_mixedcontent_securityerrors.js]
 tags = mcb
 [browser_webconsole_batching.js]
 [browser_webconsole_block_mixedcontent_securityerrors.js]
 tags = mcb
 [browser_webconsole_cached_messages.js]
 [browser_webconsole_cd_iframe.js]
 [browser_webconsole_certificate_messages.js]
diff --git a/devtools/client/webconsole/test/mochitest/browser_console_consolejsm_output.js b/devtools/client/webconsole/test/mochitest/browser_console_consolejsm_output.js
--- a/devtools/client/webconsole/test/mochitest/browser_console_consolejsm_output.js
+++ b/devtools/client/webconsole/test/mochitest/browser_console_consolejsm_output.js
@@ -28,28 +28,28 @@ add_task(async function testCategoryLogs
   console.time("foobarTimer");
   const foobar = { bug851231prop: "bug851231value" };
 
   console.log("bug851231-log");
   console.info("bug851231-info");
   console.warn("bug851231-warn");
   console.error("bug851231-error", foobar);
   console.debug("bug851231-debug");
-  console.dir(document);
+  console.dir({ "bug851231-dir": 1 });
   testTrace();
   console.timeEnd("foobarTimer");
 
   info("wait for the Console.jsm messages");
 
   await checkMessageExists(hud, "bug851231-log");
   await checkMessageExists(hud, "bug851231-info");
   await checkMessageExists(hud, "bug851231-warn");
   await checkMessageExists(hud, "bug851231-error");
   await checkMessageExists(hud, "bug851231-debug");
-  await checkMessageExists(hud, "XULDocument");
+  await checkMessageExists(hud, "bug851231-dir");
   await checkMessageExists(hud, "console.trace()");
   await checkMessageExists(hud, "foobarTimer");
 
   hud.ui.clearOutput(true);
   await HUDService.toggleBrowserConsole();
 });
 
 add_task(async function testFilter() {
diff --git a/devtools/client/webconsole/test/mochitest/browser_console_context_menu_entries.js b/devtools/client/webconsole/test/mochitest/browser_console_context_menu_entries.js
--- a/devtools/client/webconsole/test/mochitest/browser_console_context_menu_entries.js
+++ b/devtools/client/webconsole/test/mochitest/browser_console_context_menu_entries.js
@@ -4,16 +4,18 @@
 "use strict";
 
 // Check that we display the expected context menu entries.
 
 const TEST_URI = "http://example.com/browser/devtools/client/webconsole/" +
                  "test/mochitest/test-console.html";
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
   // Enable net messages in the console for this test.
   await pushPref("devtools.browserconsole.filter.net", true);
   // This is required for testing the text input in the browser console:
   await pushPref("devtools.chrome.enabled", true);
 
   await addTab(TEST_URI);
   const hud = await HUDService.toggleBrowserConsole();
 
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_history.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_history.js
--- a/devtools/client/webconsole/test/mochitest/browser_jsterm_history.js
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_history.js
@@ -11,22 +11,19 @@ const TEST_URI = "data:text/html;charset
 const COMMANDS = ["document", "window", "window.location"];
 
 const {
   HISTORY_BACK,
   HISTORY_FORWARD,
 } = require("devtools/client/webconsole/constants");
 
 add_task(async function() {
-  // Run test with legacy JsTerm
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
   await pushPref("devtools.webconsole.jsterm.codeMirror", false);
   await testHistory();
-  // And then run it with the CodeMirror-powered one.
-  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
-  await testHistory();
 });
 
 async function testHistory() {
   const { jsterm, ui } = await openNewTabAndConsole(TEST_URI);
   ui.clearOutput();
 
   for (const command of COMMANDS) {
     info(`Executing command ${command}`);
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_history_nav.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_history_nav.js
--- a/devtools/client/webconsole/test/mochitest/browser_jsterm_history_nav.js
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_history_nav.js
@@ -7,22 +7,19 @@
 
 // See Bug 660806. Check that history navigation with the UP/DOWN arrows does not trigger
 // autocompletion.
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 660806 - history " +
                  "navigation must not show the autocomplete popup";
 
 add_task(async function() {
-  // Run test with legacy JsTerm
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
   await pushPref("devtools.webconsole.jsterm.codeMirror", false);
   await testHistory();
-  // And then run it with the CodeMirror-powered one.
-  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
-  await testHistory();
 });
 
 async function testHistory() {
   const { jsterm } = await openNewTabAndConsole(TEST_URI);
   const popup = jsterm.autocompletePopup;
 
   // The autocomplete popup should never be displayed during the test.
   const onShown = function() {
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_syntax_highlight_output.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_syntax_highlight_output.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_syntax_highlight_output.js
@@ -0,0 +1,41 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const TEST_URI =
+  "data:text/html;charset=utf-8,Test syntax highlighted output";
+
+add_task(async function() {
+  await pushPref("dom.webcomponents.customelements.enabled", true);
+
+  await pushPref("devtools.webconsole.jsterm.codeMirror", true);
+  await performTests();
+
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+  await performTests();
+});
+
+async function performTests() {
+  const hud = await openNewTabAndConsole(TEST_URI);
+  const jsterm = hud.jsterm;
+
+  // Syntax highlighting is implemented with a Custom Element:
+  ok(hud.iframeWindow.customElements.get("syntax-highlighted"), "Custom Element exists");
+
+  // Check that we syntax highlight output to look like the inputed text.
+  // See Bug 1463669.
+  const onMessage = waitForMessage(hud, `var a = 'str';`);
+  jsterm.execute("var a = 'str';");
+  const message = await onMessage;
+  const highlighted = message.node.querySelectorAll("syntax-highlighted");
+  let expectedMarkup;
+  if (Services.prefs.getBoolPref("devtools.webconsole.jsterm.codeMirror")) {
+    /* eslint-disable-next-line max-len */
+    expectedMarkup = `<syntax-highlighted class="cm-s-mozilla"><span class="cm-keyword">var</span> <span class="cm-def">a</span> <span class="cm-operator">=</span> <span class="cm-string">'str'</span>;</syntax-highlighted>`;
+  } else {
+    expectedMarkup = `<syntax-highlighted>var a = 'str';</syntax-highlighted>`;
+  }
+  is(highlighted.length, 1, "1 syntax highlighted tag");
+  is(highlighted[0].outerHTML, expectedMarkup, "got expected html");
+}
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_close_sidebar.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_close_sidebar.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_close_sidebar.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_close_sidebar.js
@@ -5,20 +5,20 @@
 
 // Test that the sidebar is hidden for all methods of closing it.
 
 "use strict";
 
 const TEST_URI = "data:text/html;charset=utf8,";
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
   // Should be removed when sidebar work is complete
-  await SpecialPowers.pushPrefEnv({"set": [
-    ["devtools.webconsole.sidebarToggle", true]
-  ]});
+  await pushPref("devtools.webconsole.sidebarToggle", true);
 
   const hud = await openNewTabAndConsole(TEST_URI);
   await showSidebar(hud);
 
   info("Click the clear console button");
   const clearButton = hud.ui.document.querySelector(".devtools-button");
   clearButton.click();
   await waitFor(() => findMessages(hud, "").length == 0);
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_document_focus.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_document_focus.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_document_focus.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_document_focus.js
@@ -2,16 +2,19 @@
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Check that focus is restored to content page after closing the console. See Bug 588342.
 const TEST_URI = "data:text/html;charset=utf-8,Test content focus after closing console";
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+
   const hud = await openNewTabAndConsole(TEST_URI);
 
   const inputNode = hud.jsterm.inputNode;
   info("Focus after console is opened");
   ok(hasFocus(inputNode), "input node is focused after console is opened");
 
   info("Closing console");
   await closeConsole();
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_input_field_focus_on_panel_select.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_input_field_focus_on_panel_select.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_input_field_focus_on_panel_select.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_input_field_focus_on_panel_select.js
@@ -6,16 +6,19 @@
 // Test that the JS input field is focused when the user switches back to the
 // web console from other tools, see bug 891581.
 
 "use strict";
 
 const TEST_URI = "data:text/html;charset=utf8,<p>Test console input focus";
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+
   const hud = await openNewTabAndConsole(TEST_URI);
 
   const inputNode = hud.jsterm.inputNode;
   const filterInput = hud.ui.outputNode.querySelector(".text-filter");
 
   info("Focus after console is opened");
   ok(hasFocus(inputNode), "input node is focused after console is opened");
 
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_input_focus.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_input_focus.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_input_focus.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_input_focus.js
@@ -9,16 +9,19 @@
 
 const TEST_URI =
   `data:text/html;charset=utf-8,Test input focused
   <script>
     console.log("console message 1");
   </script>`;
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+
   const hud = await openNewTabAndConsole(TEST_URI);
 
   const inputNode = hud.jsterm.inputNode;
   info("Focus after console is opened");
   ok(hasFocus(inputNode), "input node is focused after console is opened");
 
   hud.ui.clearOutput();
   ok(hasFocus(inputNode), "input node is focused after output is cleared");
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_keyboard_accessibility.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_keyboard_accessibility.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_keyboard_accessibility.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_keyboard_accessibility.js
@@ -12,16 +12,19 @@ const TEST_URI =
   <script>
     for (let i = 1; i <= 100; i++) {
       console.log("console message " + i);
     }
   </script>
   `;
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+
   const hud = await openNewTabAndConsole(TEST_URI);
   info("Web Console opened");
   const outputScroller = hud.ui.outputScroller;
   await waitFor(() => findMessages(hud, "").length == 100);
   let currentPosition = outputScroller.scrollTop;
   const bottom = currentPosition;
   hud.jsterm.inputNode.focus();
   // Page up.
diff --git a/devtools/client/webconsole/test/mochitest/browser_webconsole_split_focus.js b/devtools/client/webconsole/test/mochitest/browser_webconsole_split_focus.js
--- a/devtools/client/webconsole/test/mochitest/browser_webconsole_split_focus.js
+++ b/devtools/client/webconsole/test/mochitest/browser_webconsole_split_focus.js
@@ -3,16 +3,19 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>Web Console test for splitting</p>";
 
 add_task(async function() {
+  // Only run in legacy JsTerm - fixme in Bug 1485510.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+
   info("Test that the split console input is focused and restores the focus properly.");
 
   const toolbox = await openNewTabAndToolbox(TEST_URI, "inspector");
   ok(!toolbox.splitConsole, "Split console is hidden by default");
 
   info("Focusing the search box before opening the split console");
   const inspector = toolbox.getPanel("inspector");
   inspector.searchBox.focus();
diff --git a/devtools/client/webconsole/webconsole-frame.js b/devtools/client/webconsole/webconsole-frame.js
--- a/devtools/client/webconsole/webconsole-frame.js
+++ b/devtools/client/webconsole/webconsole-frame.js
@@ -240,24 +240,49 @@ WebConsoleFrame.prototype = {
     const Wrapper = this.owner.WebConsoleOutputWrapper || this.window.WebConsoleOutput;
     this.consoleOutput =
       new Wrapper(this.outputNode, this, toolbox, this.owner, this.document);
     // Toggle the timestamp on preference change
     Services.prefs.addObserver(PREF_MESSAGE_TIMESTAMP, this._onToolboxPrefChanged);
     this._onToolboxPrefChanged();
 
     this._initShortcuts();
+    this._initOutputSyntaxHighlighting();
 
     if (toolbox) {
       toolbox.on("webconsole-selected", this._onPanelSelected);
       toolbox.on("split-console", this._onChangeSplitConsoleState);
       toolbox.on("select", this._onChangeSplitConsoleState);
     }
   },
 
+  _initOutputSyntaxHighlighting: function() {
+    // Given a DOM node, we syntax highlight identically to how the input field
+    // looks. See https://codemirror.net/demo/runmode.html;
+    const syntaxHighlightNode = node => {
+      const editor = this.jsterm && this.jsterm.editor;
+      if (node && editor) {
+        node.classList.add("cm-s-mozilla");
+        editor.CodeMirror.runMode(node.textContent, "application/javascript", node);
+      }
+    };
+
+    // Use a Custom Element to handle syntax highlighting to avoid
+    // dealing with refs or innerHTML from React.
+    const win = this.window;
+    win.customElements.define("syntax-highlighted", class extends win.HTMLElement {
+      connectedCallback() {
+        if (!this.connected) {
+          this.connected = true;
+          syntaxHighlightNode(this);
+        }
+      }
+    });
+  },
+
   _initShortcuts: function() {
     const shortcuts = new KeyShortcuts({
       window: this.window
     });
 
     shortcuts.on(l10n.getStr("webconsole.find.key"),
                  event => {
                    this.filterBox.focus();
