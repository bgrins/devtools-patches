# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  d2da6be23dbe025d5e99957b3a8031556711301b
Bug 1123851 - 4 - Add event-handling support for canvasframe native anonymous content

diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -409,20 +409,13 @@ div:-moz-native-anonymous.moz-selectionc
 div:-moz-native-anonymous.moz-selectioncaret-right.hidden > div {
   width: 0px;
   height: 0px;
   margin: 0px;
   visibility: hidden;
 }
 
 /* Custom content container in the CanvasFrame, fixed positioned on top of
-   everything else, not reacting to pointer events. */
+   everything else. */
 div:-moz-native-anonymous.moz-custom-content-container {
-  pointer-events: none;
-
   position: fixed;
-  top: 0;
-  left: 0;
-  width: 100%;
-  height: 100%;
-
   z-index: 2147483648;
 }
diff --git a/toolkit/devtools/gcli/commands/highlight.js b/toolkit/devtools/gcli/commands/highlight.js
--- a/toolkit/devtools/gcli/commands/highlight.js
+++ b/toolkit/devtools/gcli/commands/highlight.js
@@ -32,19 +32,21 @@ function destroyHighlighters() {
   }
   exports.highlighters.length = 0;
 }
 
 /**
  * Get an object that looks like a TabActor for instantiating highlighters
  */
 function getTabActorContext(env) {
+  let browser = env.chromeWindow.gBrowser.getBrowserForDocument(env.document);
   return {
-    browser: env.chromeWindow.gBrowser.getBrowserForDocument(env.document),
-    window: env.window
+    browser: browser,
+    window: env.window,
+    chromeEventHandler: browser.docShell.chromeEventHandler
   };
 }
 
 exports.items = [
   {
     name: "highlight",
     description: gcli.lookup("highlightDesc"),
     manual: gcli.lookup("highlightManual"),
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -9,20 +9,23 @@
   This stylesheet is loaded as a ua stylesheet via the addon sdk, so having this
   pseudo-class is important.
   Having bug 1086532 fixed would make it possible to load this stylesheet in a
   <style scoped> node instead, directly in the native anonymous container
   element.
 */
 
 :-moz-native-anonymous .highlighter-container {
+  position: absolute;
+  /* The container for all highlighters doesn't react to pointer-events by
+     default. This is because most highlighters cover the whole viewport and
+     don't need to be accessed.
+     If you are adding a new highlighter that needs interactivity, you need to
+     define 'pointer-events:auto;' on it. */
   pointer-events: none;
-  position: absolute;
-  width: 100%;
-  height: 100%;
 }
 
 :-moz-native-anonymous .highlighter-container [hidden] {
   display: none;
 }
 
 /* Box model highlighter */
 
@@ -176,16 +179,22 @@
 :-moz-native-anonymous .highlighted-rect {
   position: absolute;
   background: #80d4ff;
   opacity: 0.8;
 }
 
 /* Element geometry highlighter */
 
+:-moz-native-anonymous .geometry-editor-root {
+  /* The geometry editor can be interacted with, so it needs to react to
+     pointer events */
+  pointer-events: auto;
+}
+
 :-moz-native-anonymous .geometry-editor-offset-parent {
   stroke: #08c;
   shape-rendering: crispEdges;
   stroke-dasharray: 5 3;
   fill: transparent;
 }
 
 :-moz-native-anonymous .geometry-editor-current-node {
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -120,16 +120,17 @@ let HighlighterActor = exports.Highlight
     this._inspector = inspector;
     this._walker = this._inspector.walker;
     this._tabActor = this._inspector.tabActor;
 
     this._highlighterReady = this._highlighterReady.bind(this);
     this._highlighterHidden = this._highlighterHidden.bind(this);
     this._onNavigate = this._onNavigate.bind(this);
 
+    this._layoutHelpers = new LayoutHelpers(this._tabActor.window);
     this._createHighlighter();
 
     // Listen to navigation events to switch from the BoxModelHighlighter to the
     // SimpleOutlineHighlighter, and back, if the top level window changes.
     events.on(this._tabActor, "navigate", this._onNavigate);
   },
 
   get conn() this._inspector && this._inspector.conn,
@@ -174,16 +175,17 @@ let HighlighterActor = exports.Highlight
     protocol.Actor.prototype.destroy.call(this);
 
     this._destroyHighlighter();
     events.off(this._tabActor, "navigate", this._onNavigate);
     this._autohide = null;
     this._inspector = null;
     this._walker = null;
     this._tabActor = null;
+    this._layoutHelpers = null;
   },
 
   /**
    * Display the box model highlighting on a given NodeActor.
    * There is only one instance of the box model highlighter, so calling this
    * method several times won't display several highlighters, it will just move
    * the highlighter instance to these nodes.
    *
@@ -264,22 +266,23 @@ let HighlighterActor = exports.Highlight
 
     this._tabActor.window.focus();
     this._startPickerListeners();
 
     return null;
   }),
 
   _findAndAttachElement: function(event) {
-    let doc = event.target.ownerDocument;
-
     let x = event.clientX;
     let y = event.clientY;
 
-    let node = doc.elementFromPoint(x, y);
+    // Search for the node using elementFromPoint starting from the root window
+    // and going into nested iframes if needed.
+    let node = this._layoutHelpers.getElementFromPoint(
+      this._tabActor.window.document, x, y);
     return this._walker.attachElement(node);
   },
 
   _startPickerListeners: function() {
     let target = getPageListenerTarget(this._tabActor);
     target.addEventListener("mousemove", this._onHovered, true);
     target.addEventListener("click", this._onPick, true);
     target.addEventListener("mousedown", this._preventContentEvent, true);
@@ -439,30 +442,34 @@ function CanvasFrameAnonymousContentHelp
   this.anonymousContentDocument = this.tabActor.window.document;
   // XXX the next line is a wallpaper for bug 1123362.
   this.anonymousContentGlobal = Cu.getGlobalForObject(this.anonymousContentDocument);
 
   this._insert();
 
   this._onNavigate = this._onNavigate.bind(this);
   events.on(this.tabActor, "navigate", this._onNavigate);
+
+  this.listeners = new Map();
 }
 
 CanvasFrameAnonymousContentHelper.prototype = {
   destroy: function() {
     // If the current window isn't the one the content was inserted into, this
     // will fail, but that's fine.
     try {
       let doc = this.anonymousContentDocument;
       doc.removeAnonymousContent(this._content);
     } catch (e) {console.error(e)}
     events.off(this.tabActor, "navigate", this._onNavigate);
     this.tabActor = this.nodeBuilder = this._content = null;
     this.anonymousContentDocument = null;
     this.anonymousContentGlobal = null;
+
+    this._removeAllListeners();
   },
 
   _insert: function() {
     // Re-insert the content node after page navigation only if the new page
     // isn't XUL.
     if (isXUL(this.tabActor)) {
       return;
     }
@@ -489,16 +496,17 @@ CanvasFrameAnonymousContentHelper.protot
     installHelperSheet(this.tabActor.window,
       "@import url('" + HIGHLIGHTER_STYLESHEET_URI + "');");
     let node = this.nodeBuilder();
     this._content = doc.insertAnonymousContent(node);
   },
 
   _onNavigate: function({isTopLevel}) {
     if (isTopLevel) {
+      this._removeAllListeners();
       this._insert();
     }
   },
 
   getTextContentForElement: function(id) {
     if (!this.content) {
       return null;
     }
@@ -525,24 +533,116 @@ CanvasFrameAnonymousContentHelper.protot
   },
 
   removeAttributeForElement: function(id, name) {
     if (this.content) {
       this.content.removeAttributeForElement(id, name);
     }
   },
 
+  /**
+   * Add an event listener to one of the elements inserted in the canvasFrame
+   * native anonymous container.
+   * Like other methods in this helper, this requires the ID of the element to
+   * be passed in.
+   *
+   * A single event listener is added per event types only, at the browser level
+   * and if the event originalTarget is found to have the provided ID, the
+   * callback is executed.
+   *
+   * IMPORTANT: the chrome-only canvasFrame insertion API takes great care of
+   * not leaking references to inserted elements to chrome JS code. That's
+   * because otherwise, chrome JS code could freely modify native anon elements
+   * inside the canvasFrame and probably change things that are assumed not to
+   * change by the C++ code managing this frame.
+   * See https://wiki.mozilla.org/DevTools/Highlighter#The_AnonymousContent_API
+   * Unfortunately, the inserted nodes are still available via
+   * event.originalTarget, and that's what the event handler here uses to check
+   * that the event actually occured on the right element, but that also means
+   * consumers of this code would be able to access the inserted elements.
+   * Therefore, the originalTarget property will be nullified before the event
+   * is passed to your handler.
+   *
+   * @param {String} id
+   * @param {String} type
+   * @param {Function} handler
+   */
+  addEventListenerForElement: function(id, type, handler) {
+    // If noone is listening for this type of event yet, add one listener.
+    if (!this.listeners.has(type)) {
+      let target = getPageListenerTarget(this.tabActor);
+      target.addEventListener(type, this, true);
+      // Each type entry in the map is a map of ids:handlers.
+      this.listeners.set(type, new Map);
+    }
+
+    let listeners = this.listeners.get(type);
+    listeners.set(id, handler);
+  },
+
+  /**
+   * Remove an event listener from one of the elements inserted in the
+   * canvasFrame native anonymous container.
+   * @param {String} id
+   * @param {String} type
+   * @param {Function} handler
+   */
+  removeEventListenerForElement: function(id, type, handler) {
+    let listeners = this.listeners.get(type);
+    if (!listeners) {
+      return;
+    }
+    listeners.delete(id);
+
+    // If noone is listening for event type anymore, remove the listener.
+    if (!this.listeners.has(type)) {
+      let target = getPageListenerTarget(this.tabActor);
+      target.removeEventListener(type, this, true);
+    }
+  },
+
+  handleEvent: function(event) {
+    let listeners = this.listeners.get(event.type);
+    if (!listeners) {
+      return;
+    }
+
+    for (let [id, handler] of listeners) {
+      if (event.originalTarget.id === id) {
+        // Hiding the originalTarget property to avoid exposing references to
+        // native anonymous elements. See addEventListenerForElement's comment.
+        Object.defineProperty(event, "originalTarget", {
+          get: () => null,
+          configurable: false
+        });
+        handler(event, id);
+      }
+    }
+  },
+
+  _removeAllListeners: function() {
+    if (this.tabActor) {
+      let target = getPageListenerTarget(this.tabActor);
+      for (let [type] of this.listeners) {
+        target.removeEventListener(type, this, true);
+      }
+    }
+    this.listeners.clear();
+  },
+
   getElement: function(id) {
     let self = this;
     return {
       getTextContent: () => self.getTextContentForElement(id),
       setTextContent: text => self.setTextContentForElement(id, text),
       setAttribute: (name, value) => self.setAttributeForElement(id, name, value),
       getAttribute: name => self.getAttributeForElement(id, name),
-      removeAttribute: name => self.removeAttributeForElement(id, name)
+      removeAttribute: name => self.removeAttributeForElement(id, name),
+      addEventListener: (type, handler) => self.addEventListenerForElement(id, type, handler),
+      removeEventListener: (type, handler) => self.removeEventListenerForElement(id, type, handler)
     };
   },
 
   get content() {
     if (!this._content || Cu.isDeadWrapper(this._content)) {
       return null;
     }
     return this._content;
@@ -869,19 +969,19 @@ BoxModelHighlighter.prototype = Heritage
 
     // Building the SVG element with its polygons and lines
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: rootWrapper,
       attributes: {
         "id": "elements",
-        "width": "100%",
-        "height": "100%",
-        "style": "width:100%;height:100%;",
+        "class": "elements",
+        "width": this.win.innerWidth,
+        "height": this.win.innerHeight,
         "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     let regions = createSVGNode(this.win, {
       nodeType: "g",
       parent: svg,
@@ -1421,18 +1521,18 @@ CssTransformHighlighter.prototype = Heri
     });
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: rootWrapper,
       attributes: {
         "id": "elements",
         "hidden": "true",
-        "width": "100%",
-        "height": "100%"
+        "width": this.win.innerWidth,
+        "height": this.win.innerHeight,
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     // Add a marker tag to the svg root for the arrow tip
     this.markerId = "arrow-marker-" + MARKER_COUNTER;
     MARKER_COUNTER ++;
     let marker = createSVGNode(this.win, {
@@ -1868,19 +1968,18 @@ GeometryEditorHighlighter.prototype = He
       prefix: this.ID_CLASS_PREFIX
     });
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: root,
       attributes: {
         "id": "elements",
-        "width": "100%",
-        "height": "100%",
-        "style": "width:100%;height:100%;"
+        "width": this.win.innerWidth,
+        "height": this.win.innerHeight,
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     // Offset parent node highlighter.
     createSVGNode(this.win, {
       nodeType: "polygon",
       parent: svg,
