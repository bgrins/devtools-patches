
# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1443108214 25200
# Node ID 7b145ea2fbdefc0c32d0bc7375ed030326530bfd
# Parent  787cfa4012cebf5d0a5b0ee32191604b56938063
Bug 1034110 - Listen to nativeAnonymousChildList changes from devtools;r=pbrosset

diff --git a/devtools/client/markupview/markup-view.js b/devtools/client/markupview/markup-view.js
--- a/devtools/client/markupview/markup-view.js
+++ b/devtools/client/markupview/markup-view.js
@@ -825,17 +825,17 @@ MarkupView.prototype = {
       }
       if (type === "attributes" || type === "characterData") {
         container.update();
 
         // Auto refresh style properties on selected node when they change.
         if (type === "attributes" && container.selected) {
           requiresLayoutChange = true;
         }
-      } else if (type === "childList") {
+      } else if (type === "childList" || type === "nativeAnonymousChildList") {
         container.childrenDirty = true;
         // Update the children to take care of changes in the markup view DOM.
         this._updateChildren(container, {flash: true});
       } else if (type === "pseudoClassLock") {
         container.update();
       }
     }
 
diff --git a/devtools/client/markupview/test/browser_markupview_mutation_01.js b/devtools/client/markupview/test/browser_markupview_mutation_01.js
--- a/devtools/client/markupview/test/browser_markupview_mutation_01.js
+++ b/devtools/client/markupview/test/browser_markupview_mutation_01.js
@@ -5,16 +5,18 @@
 "use strict";
 
 // Tests that various mutations to the dom update the markup view correctly.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_mutation.html";
 
 // Mutation tests. Each entry in the array has the following properties:
 // - desc: for logging only
+// - numMutations: how many mutations are expected to come happen due to the
+//   test case.  Defaults to 1 if not set.
 // - test: a function supposed to mutate the DOM
 // - check: a function supposed to test that the mutation was handled
 const TEST_DATA = [
   {
     desc: "Adding an attribute",
     test: () => {
       let node1 = getNode("#node1");
       node1.setAttribute("newattr", "newattrval");
@@ -61,16 +63,41 @@ const TEST_DATA = [
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrchanged\"";
       }), "newattr attribute found");
     }
   },
   {
+    desc: "Adding ::after element",
+    numMutations: 2,
+    test: () => {
+      let node1 = getNode("#node1");
+      node1.classList.add("pseudo");
+    },
+    check: function*(inspector) {
+      let {children} = yield getContainerForSelector("#node1", inspector);
+      is(children.childNodes.length, 2,
+        "Node1 now has 2 children (text child and ::after");
+    }
+  },
+  {
+    desc: "Removing ::after element",
+    numMutations: 2,
+    test: () => {
+      let node1 = getNode("#node1");
+      node1.classList.remove("pseudo");
+    },
+    check: function*(inspector) {
+      let container = yield getContainerForSelector("#node1", inspector);
+      ok(container.singleTextChild, "Has single text child.");
+    }
+  },
+  {
     desc: "Updating the text-content",
     test: () => {
       let node1 = getNode("#node1");
       node1.textContent = "newtext";
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
@@ -236,23 +263,38 @@ const TEST_DATA = [
 ];
 
 add_task(function*() {
   let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Expanding all markup-view nodes");
   yield inspector.markup.expandAll();
 
-  for (let {desc, test, check} of TEST_DATA) {
+  for (let {desc, test, check, numMutations} of TEST_DATA) {
     info("Starting test: " + desc);
 
+    numMutations = numMutations || 1;
+
     info("Executing the test markup mutation");
-    let onMutation = inspector.once("markupmutation");
-    test();
-    yield onMutation;
+    yield new Promise((resolve) => {
+      // If a test expects more than one mutation it may come through in a
+      // single event or possibly in multiples.
+      let seenMutations = 0;
+      inspector.on("markupmutation", function onmutation(e, mutations) {
+        seenMutations += mutations.length;
+        info("Receieved " + seenMutations +
+             " mutations, expecting at least " + numMutations);
+        if (seenMutations >= numMutations) {
+          inspector.off("markupmutation", onmutation);
+          resolve();
+        }
+      });
+
+      test();
+    })
 
     info("Expanding all markup-view nodes to make sure new nodes are imported");
     yield inspector.markup.expandAll();
 
     info("Checking the markup-view content");
     yield check(inspector);
   }
 });
diff --git a/devtools/client/markupview/test/doc_markup_mutation.html b/devtools/client/markupview/test/doc_markup_mutation.html
--- a/devtools/client/markupview/test/doc_markup_mutation.html
+++ b/devtools/client/markupview/test/doc_markup_mutation.html
@@ -1,11 +1,16 @@
 <!DOCTYPE html>
 
 <html class="html">
+  <style type="text/css">
+    #node1.pseudo::after {
+      content: "after";
+    }
+  </style>
 
   <body class="body">
     <div class="node0">
       <div id="node1" class="node1">line1</div>
       <div id="node2" class="node2">line2</div>
       <p class="node3">line3</p>
       <!-- A comment -->
       <p id="node4" class="node4">line4
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -321,16 +321,17 @@ var NodeActor = exports.NodeActor = prot
    */
   watchDocument: function(callback) {
     let node = this.rawNode;
     // Create the observer on the node's actor.  The node will make sure
     // the observer is cleaned up when the actor is released.
     let observer = new node.defaultView.MutationObserver(callback);
     observer.mergeAttributeRecords = true;
     observer.observe(node, {
+      nativeAnonymousChildList: true,
       attributes: true,
       characterData: true,
       childList: true,
       subtree: true
     });
     this.mutationObserver = observer;
   },
 
@@ -2805,35 +2806,36 @@ var WalkerActor = protocol.ActorClass({
    */
   onMutations: function(mutations) {
     for (let change of mutations) {
       let targetActor = this._refMap.get(change.target);
       if (!targetActor) {
         continue;
       }
       let targetNode = change.target;
+      let type = change.type;
       let mutation = {
-        type: change.type,
+        type: type,
         target: targetActor.actorID,
       };
 
-      if (mutation.type === "attributes") {
+      if (type === "attributes") {
         mutation.attributeName = change.attributeName;
         mutation.attributeNamespace = change.attributeNamespace || undefined;
         mutation.newValue = targetNode.hasAttribute(mutation.attributeName) ?
                             targetNode.getAttribute(mutation.attributeName)
                             : null;
-      } else if (mutation.type === "characterData") {
+      } else if (type === "characterData") {
         if (targetNode.nodeValue.length > gValueSummaryLength) {
           mutation.newValue = targetNode.nodeValue.substring(0, gValueSummaryLength);
           mutation.incompleteValue = true;
         } else {
           mutation.newValue = targetNode.nodeValue;
         }
-      } else if (mutation.type === "childList") {
+      } else if (type === "childList" || type === "nativeAnonymousChildList") {
         // Get the list of removed and added actors that the client has seen
         // so that it can keep its ownership tree up to date.
         let removedActors = [];
         let addedActors = [];
         for (let removed of change.removedNodes) {
           let removedActor = this._refMap.get(removed);
           if (!removedActor) {
             // If the client never encountered this actor we don't need to
@@ -3325,17 +3327,17 @@ var WalkerFront = exports.WalkerFront = 
 
         if (!targetFront) {
           console.trace("Got a mutation for an unexpected actor: " + targetID + ", please file a bug on bugzilla.mozilla.org!");
           continue;
         }
 
         let emittedMutation = object.merge(change, { target: targetFront });
 
-        if (change.type === "childList") {
+        if (change.type === "childList" || change.type === "nativeAnonymousChildList") {
           // Update the ownership tree according to the mutation record.
           let addedFronts = [];
           let removedFronts = [];
           for (let removed of change.removed) {
             let removedFront = this.get(removed);
             if (!removedFront) {
               console.error("Got a removal of an actor we didn't know about: " + removed);
               continue;
