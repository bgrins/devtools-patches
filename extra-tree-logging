# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  8200c205641f122130073b5b3482a8aac2257d74

diff --git a/toolkit/content/tests/widgets/tree_shared.js b/toolkit/content/tests/widgets/tree_shared.js
--- a/toolkit/content/tests/widgets/tree_shared.js
+++ b/toolkit/content/tests/widgets/tree_shared.js
@@ -48,81 +48,83 @@ function testtag_tree(treeid, treerowinf
 
   // note: the functions below should be in this order due to changes made in later tests
 
   testtag_tree_columns(tree, columnInfo, testid);
   testtag_tree_TreeSelection(tree, testid, multiple);
   testtag_tree_TreeSelection_UI(tree, testid, multiple);
   testtag_tree_TreeView(tree, testid, rowInfo);
 
-  is(tree.editable, false, "tree should not be editable");
-  // currently, the editable flag means that tree editing cannot be invoked
-  // by the user. However, editing can still be started with a script.
-  is(tree.editingRow, -1, testid + " initial editingRow");
-  is(tree.editingColumn, null, testid + " initial editingColumn");
+
+
+  // is(tree.editable, false, "tree should not be editable");
+  // // currently, the editable flag means that tree editing cannot be invoked
+  // // by the user. However, editing can still be started with a script.
+  // is(tree.editingRow, -1, testid + " initial editingRow");
+  // is(tree.editingColumn, null, testid + " initial editingColumn");
 
-  testtag_tree_UI_editing(tree, testid, rowInfo);
+  // testtag_tree_UI_editing(tree, testid, rowInfo);
 
-  is(tree.editable, false, "tree should not be editable after testtag_tree_UI_editing");
-  // currently, the editable flag means that tree editing cannot be invoked
-  // by the user. However, editing can still be started with a script.
-  is(tree.editingRow, -1, testid + " initial editingRow (continued)");
-  is(tree.editingColumn, null, testid + " initial editingColumn (continued)");
+  // is(tree.editable, false, "tree should not be editable after testtag_tree_UI_editing");
+  // // currently, the editable flag means that tree editing cannot be invoked
+  // // by the user. However, editing can still be started with a script.
+  // is(tree.editingRow, -1, testid + " initial editingRow (continued)");
+  // is(tree.editingColumn, null, testid + " initial editingColumn (continued)");
 
-  var ecolumn = tree.columns[0];
-  ok(!tree.startEditing(1, ecolumn), "non-editable trees shouldn't start editing");
-  is(tree.editingRow, -1, testid + " failed startEditing shouldn't set editingRow");
-  is(tree.editingColumn, null, testid + " failed startEditing shouldn't set editingColumn");
+  // var ecolumn = tree.columns[0];
+  // ok(!tree.startEditing(1, ecolumn), "non-editable trees shouldn't start editing");
+  // is(tree.editingRow, -1, testid + " failed startEditing shouldn't set editingRow");
+  // is(tree.editingColumn, null, testid + " failed startEditing shouldn't set editingColumn");
 
-  tree.editable = true;
+  // tree.editable = true;
 
-  ok(tree.startEditing(1, ecolumn), "startEditing should have returned true");
-  is(tree.editingRow, 1, testid + " startEditing editingRow");
-  is(tree.editingColumn, ecolumn, testid + " startEditing editingColumn");
-  is(tree.getAttribute("editing"), "true", testid + " startEditing editing attribute");
+  // ok(tree.startEditing(1, ecolumn), "startEditing should have returned true");
+  // is(tree.editingRow, 1, testid + " startEditing editingRow");
+  // is(tree.editingColumn, ecolumn, testid + " startEditing editingColumn");
+  // is(tree.getAttribute("editing"), "true", testid + " startEditing editing attribute");
 
-  tree.stopEditing(true);
-  is(tree.editingRow, -1, testid + " stopEditing editingRow");
-  is(tree.editingColumn, null, testid + " stopEditing editingColumn");
-  is(tree.hasAttribute("editing"), false, testid + " stopEditing editing attribute");
+  // tree.stopEditing(true);
+  // is(tree.editingRow, -1, testid + " stopEditing editingRow");
+  // is(tree.editingColumn, null, testid + " stopEditing editingColumn");
+  // is(tree.hasAttribute("editing"), false, testid + " stopEditing editing attribute");
 
-  tree.startEditing(-1, ecolumn);
-  is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing -1 editingRow");
-  tree.startEditing(15, ecolumn);
-  is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing 15 editingRow");
-  tree.startEditing(1, null);
-  is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing null column editingRow");
-  tree.startEditing(2, tree.columns[1]);
-  is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing non editable cell editingRow");
+  // tree.startEditing(-1, ecolumn);
+  // is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing -1 editingRow");
+  // tree.startEditing(15, ecolumn);
+  // is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing 15 editingRow");
+  // tree.startEditing(1, null);
+  // is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing null column editingRow");
+  // tree.startEditing(2, tree.columns[1]);
+  // is(tree.editingRow == -1 && tree.editingColumn == null, true, testid + " startEditing non editable cell editingRow");
 
-  tree.startEditing(1, ecolumn);
-  var inputField = tree.inputField;
-  is(inputField.localName, "textbox", testid + "inputField");
-  inputField.value = "Changed Value";
-  tree.stopEditing(true);
-  is(tree.view.getCellText(1, ecolumn), "Changed Value", testid + "edit cell accept");
+  // tree.startEditing(1, ecolumn);
+  // var inputField = tree.inputField;
+  // is(inputField.localName, "textbox", testid + "inputField");
+  // inputField.value = "Changed Value";
+  // tree.stopEditing(true);
+  // is(tree.view.getCellText(1, ecolumn), "Changed Value", testid + "edit cell accept");
 
-  // this cell can be edited, but stopEditing(false) means don't accept the change.
-  tree.startEditing(1, ecolumn);
-  inputField.value = "Second Value";
-  tree.stopEditing(false);
-  is(tree.view.getCellText(1, ecolumn), "Changed Value", testid + "edit cell no accept");
+  // // this cell can be edited, but stopEditing(false) means don't accept the change.
+  // tree.startEditing(1, ecolumn);
+  // inputField.value = "Second Value";
+  // tree.stopEditing(false);
+  // is(tree.view.getCellText(1, ecolumn), "Changed Value", testid + "edit cell no accept");
 
-  tree.editable = false;
+  // tree.editable = false;
 
-  // do the sorting tests last as it will cause the rows to rearrange
-  // skip them for the custom tree view
-  if (testid != "tree view")
-    testtag_tree_TreeView_rows_sort(tree, testid, rowInfo);
+  // // do the sorting tests last as it will cause the rows to rearrange
+  // // skip them for the custom tree view
+  // if (testid != "tree view")
+  //   testtag_tree_TreeView_rows_sort(tree, testid, rowInfo);
 
-  testtag_tree_wheel(tree);
+  // testtag_tree_wheel(tree);
 
-  document.removeEventListener("keypress", preventDefault);
+  // document.removeEventListener("keypress", preventDefault);
 
-  SimpleTest.finish();
+  // SimpleTest.finish();
 }
 
 function testtag_tree_columns(tree, expectedColumns, testid) {
   testid += " ";
 
   var columns = tree.columns;
 
   is(columns instanceof TreeColumns, true, testid + "columns is a TreeColumns");
diff --git a/toolkit/content/widgets/tree.js b/toolkit/content/widgets/tree.js
--- a/toolkit/content/widgets/tree.js
+++ b/toolkit/content/widgets/tree.js
@@ -632,19 +632,25 @@
 
       this.addEventListener("focus", (event) => {
         this.focused = true;
         if (this.currentIndex == -1 && this.view.rowCount > 0) {
           this.currentIndex = this.getFirstVisibleRow();
         }
       });
 
-      this.addEventListener("blur", (event) => { this.focused = false; });
+      this.addEventListener("blur", (event) => {
+        this.focused = false;
+      });
 
-      this.addEventListener("blur", (event) => { if (event.originalTarget == this.inputField.inputField) this.stopEditing(true); }, true);
+      this.addEventListener("blur", (event) => {
+        if (event.originalTarget == this.inputField.inputField) {
+          this.stopEditing(true);
+        }
+      }, true);
 
       this.addEventListener("keydown", (event) => {
         if (event.keyCode != KeyEvent.DOM_VK_RETURN) {
           return;
         }
 
         if (this._handleEnter(event)) {
           event.stopPropagation();
@@ -1272,16 +1278,18 @@
       input.hidden = true;
       input.value = "";
       this.removeAttribute("editing");
     }
 
     _moveByOffset(offset, edge, event) {
       event.preventDefault();
 
+      console.trace("_moveByOffset", this.currentIndex, offset, edge, event, this.view.selection.single);
+
       if (this.view.rowCount == 0)
         return;
 
       if (event.getModifierState("Accel") && this.view.selection.single) {
         this.scrollByLines(offset);
         return;
       }
 
