# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  01df1f0e9a0338577fc35de417f8103cdd9421e7
Bug 943306 - Debugging persist console intermittents

diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -445,18 +445,37 @@ WebConsoleFrame.prototype = {
 
   /**
    * Initialize the WebConsoleFrame instance.
    * @return object
    *         A promise object that resolves once the frame is ready to use.
    */
   init: function()
   {
-    this._initUI();
-    return this._initConnection();
+    // Don't reject if the history fails to load for some reason.
+    // This would be fine, the panel will just start with empty history.
+    let uiInited = this._initUI().catch(() => {});
+    let connectionInited = this._initConnection();
+
+    // This notification is only used in tests.
+    let notifyObservers = () => {
+      let id = WebConsoleUtils.supportsString(this.hudId);
+      Services.obs.notifyObservers(id, "web-console-created", null);
+    };
+
+    let allReady = uiInited.then(() => {
+      return connectionInited;
+    });
+    allReady.then(notifyObservers, notifyObservers);
+    return allReady;
+
+    // return uiInited.then(connectionInited.then(notifyObservers, reason => {
+    //   notifyObservers();
+    //   return promise.reject(reason);
+    // }));
   },
 
   /**
    * Connect to the server using the remote debugging protocol.
    *
    * @private
    * @return object
    *         A promise object that is resolved/reject based on the connection
@@ -473,27 +492,26 @@ WebConsoleFrame.prototype = {
 
     this.proxy.connect().then(() => { // on success
       this._initDefer.resolve(this);
     }, (aReason) => { // on failure
       let node = this.createMessageNode(CATEGORY_JS, SEVERITY_ERROR,
                                         aReason.error + ": " + aReason.message);
       this.outputMessage(CATEGORY_JS, node, [aReason]);
       this._initDefer.reject(aReason);
-    }).then(() => {
-      let id = WebConsoleUtils.supportsString(this.hudId);
-      Services.obs.notifyObservers(id, "web-console-created", null);
     });
 
     return this._initDefer.promise;
   },
 
   /**
    * Find the Web Console UI elements and setup event listeners as needed.
    * @private
+   * @return object
+   *         A promise object that resolved once the UI is ready.
    */
   _initUI: function WCF__initUI()
   {
     this.document = this.window.document;
     this.rootElement = this.document.documentElement;
 
     this._initDefaultFilterPrefs();
 
@@ -606,16 +624,17 @@ WebConsoleFrame.prototype = {
     gDevTools.on("pref-changed", this._onToolboxPrefChanged);
     this._onToolboxPrefChanged("pref-changed", {
       pref: PREF_MESSAGE_TIMESTAMP,
       newValue: Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP),
     });
 
     // focus input node
     this.jsterm.inputNode.focus();
+    return this.jsterm.historyLoaded;
   },
 
   /**
    * Sets the focus to JavaScript input field when the web console tab is
    * selected or when there is a split console present.
    * @private
    */
   _onPanelSelected: function WCF__onPanelSelected(evt, id)
@@ -3079,31 +3098,31 @@ JSTerm.prototype = {
   /**
    * Load the console history from previous sessions.
    * @private
    */
   _loadHistory: function() {
     this.history = [];
     this.historyIndex = this.historyPlaceHolder = 0;
 
-    asyncStorage.getItem("webConsoleHistory").then(value => {
+    this.historyLoaded = asyncStorage.getItem("webConsoleHistory").then(value => {
       if (Array.isArray(value)) {
         // Since it was gotten asynchronously, there could be items already in
         // the history.  It's not likely but stick them onto the end anyway.
         this.history = value.concat(this.history);
 
         // Holds the number of entries in history. This value is incremented in
         // this.execute().
         this.historyIndex = this.history.length;
 
         // Holds the index of the history entry that the user is currently viewing.
         // This is reset to this.history.length when this.execute() is invoked.
         this.historyPlaceHolder = this.history.length;
       }
-    }, console.error);
+    });
   },
 
   /**
    * Stores the console history for future sessions.
    */
   storeHistory: function() {
     asyncStorage.setItem("webConsoleHistory", this.history);
   },
