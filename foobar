# HG changeset patch
# Parent 757a333e20f4bbf789fda3351f91fca280b64e56
# User Brian Grinstead <bgrinstead@mozilla.com>
asdf

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -412,16 +412,17 @@ ElementStyle.prototype = {
  *            the rule applies directly to the current element.
  *          isSystem: Is this a user agent style?
  * @constructor
  */
 function Rule(aElementStyle, aOptions) {
   this.elementStyle = aElementStyle;
   this.domRule = aOptions.rule || null;
   this.style = aOptions.rule;
+  console.log("CREATING A RULE", this.style, this.style.cssText);
   this.matchedSelectors = aOptions.matchedSelectors || [];
   this.pseudoElement = aOptions.pseudoElement || "";
 
   this.isSystem = aOptions.isSystem;
   this.inherited = aOptions.inherited || null;
   this.keyframes = aOptions.keyframes || null;
   this._modificationDepth = 0;
 
@@ -608,23 +609,24 @@ Rule.prototype = {
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
-    let promise = aModifications.apply().then(() => {
+    let promise = this._applyingModifications = aModifications.apply().then(() => {
       let cssProps = {};
       for (let cssProp of parseDeclarations(this.style.cssText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
+        console.log("Looking at ", textProp.name, textProp.value, textProp.enabled);
         if (!textProp.enabled) {
           continue;
         }
         let cssProp = cssProps[textProp.name];
 
         if (!cssProp) {
           cssProp = {
             name: textProp.name,
@@ -632,26 +634,28 @@ Rule.prototype = {
             priority: ""
           };
         }
 
         textProp.priority = cssProp.priority;
       }
 
       this.elementStyle.markOverriddenAll();
-
       if (promise === this._applyingModifications) {
         this._applyingModifications = null;
       }
 
       this.elementStyle._changed();
+      console.log("REFRESHING PANEL");
+      // this.editor.ruleView.refreshPanel();
+      // return this.elementStyle.populate();
     }).then(null, promiseWarn);
 
-    this._applyingModifications = promise;
-    return promise;
+    // this._applyingModifications = promise;
+    // return promise;
   },
 
   /**
    * Renames a property.
    *
    * @param {TextProperty} aProperty
    *        The property to rename.
    * @param {string} aName
@@ -740,16 +744,17 @@ Rule.prototype = {
 
   /**
    * Get the list of TextProperties from the style.  Needs
    * to parse the style's cssText.
    */
   _getTextProperties: function() {
     let textProps = [];
     let store = this.elementStyle.store;
+    console.log("_getTextProperties", this.style, this.style.cssText);
     let props = parseDeclarations(this.style.cssText);
     for (let prop of props) {
       let name = prop.name;
       if (this.inherited && !domUtils.isInheritedProperty(name)) {
         continue;
       }
       let value = store.userProperties.getProperty(this.style, name, prop.value);
       let textProp = new TextProperty(this, name, value, prop.priority);
@@ -785,17 +790,17 @@ Rule.prototype = {
 
   /**
    * Reread the current state of the rules and rebuild text
    * properties as needed.
    */
   refresh: function(aOptions) {
     this.matchedSelectors = aOptions.matchedSelectors || [];
     let newTextProps = this._getTextProperties();
-
+console.log("RULE REFRESH!!", aOptions);
     // Update current properties for each property present on the style.
     // This will mark any touched properties with _visited so we
     // can detect properties that weren't touched (because they were
     // removed from the style).
     // Also keep track of properties that didn't exist in the current set
     // of properties.
     let brandNewProps = [];
     for (let newProp of newTextProps) {
@@ -1576,21 +1581,24 @@ CssRuleView.prototype = {
     }
 
     // Repopulate the element style.
     this._populate(true);
   },
 
   _populate: function(clearRules = false) {
     let elementStyle = this._elementStyle;
+    console.trace();
     return this._elementStyle.populate().then(() => {
       if (this._elementStyle != elementStyle) {
         return;
       }
 
+      console.log("POPULATE!!!", elementStyle);
+
       if (clearRules) {
         this._clearRules();
       }
       this._createEditors();
 
       // Notify anyone that cares that we refreshed.
       var evt = this.doc.createEvent("Events");
       evt.initEvent("CssRuleViewRefreshed", true, false);
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
@@ -16,44 +16,44 @@ add_task(function*() {
 
   yield selectNode("#testid", inspector);
 
   let elementStyle = view._elementStyle;
   let elementRule = elementStyle.rules[0];
 
   info("Checking rules insertion order and checking the applied style");
   let firstProp = elementRule.createProperty("background-color", "green", "");
-  let secondProp = elementRule.createProperty("background-color", "blue", "");
+  let secondProp = elementRule.createProperty("color", "blue", "");
   is(elementRule.textProps[0], firstProp, "Rules should be in addition order.");
   is(elementRule.textProps[1], secondProp, "Rules should be in addition order.");
   yield elementRule._applyingModifications;
-  is(element.style.getPropertyValue("background-color"), "blue", "Second property should have been used.");
+  is(element.style.getPropertyValue("color"), "blue", "Second property should have been used.");
 
   info("Removing the second property and checking the applied style again");
   secondProp.remove();
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "green", "After deleting second property, first should be used.");
 
   info("Creating a new second property and checking that the insertion order is still the same");
-  secondProp = elementRule.createProperty("background-color", "blue", "");
+  secondProp = elementRule.createProperty("color", "blue", "");
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "blue", "New property should be used.");
   is(elementRule.textProps[0], firstProp, "Rules shouldn't have switched places.");
   is(elementRule.textProps[1], secondProp, "Rules shouldn't have switched places.");
 
   info("Disabling the second property and checking the applied style");
   secondProp.setEnabled(false);
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "green", "After disabling second property, first value should be used");
 
   info("Disabling the first property too and checking the applied style");
   firstProp.setEnabled(false);
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "", "After disabling both properties, value should be empty.");
-
+  yield promise.defer().promise;
   info("Re-enabling the second propertyt and checking the applied style");
   secondProp.setEnabled(true);
   yield elementRule._applyingModifications;
   is(element.style.getPropertyValue("background-color"), "blue", "Value should be set correctly after re-enabling");
 
   info("Re-enabling the first property and checking the insertion order is still respected");
   firstProp.setEnabled(true);
   yield elementRule._applyingModifications;
