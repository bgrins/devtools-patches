# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  55a86d1a75e20acce229f2d5a0a8315c811cec86

diff --git a/browser/components/search/content/searchbar.js b/browser/components/search/content/searchbar.js
--- a/browser/components/search/content/searchbar.js
+++ b/browser/components/search/content/searchbar.js
@@ -9,20 +9,20 @@
 // This is loaded into chrome windows with the subscript loader. Wrap in
 // a block to prevent accidentally leaking globals onto `window`.
 {
 /**
  * Defines the search bar element.
  */
 class MozSearchbar extends MozXULElement {
   static get inheritedAttributes() {
-    return new Map([
-      [".searchbar-textbox", "disabled,disableautocomplete,searchengine,src,newlines"],
-      [".searchbar-search-button", "addengines"],
-    ]);
+    return {
+      ".searchbar-textbox": "disabled,disableautocomplete,searchengine,src,newlines",
+      ".searchbar-search-button": "addengines",
+    };
   }
 
   constructor() {
     super();
     this.destroy = this.destroy.bind(this);
     this._setupEventListeners();
     let searchbar = this;
     this.observer = {
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -45,70 +45,70 @@ const gXULDOMParser = new DOMParser();
 gXULDOMParser.forceEnableXULXBL();
 
 const MozElements = {};
 
 const MozElementMixin = Base => class MozElement extends Base {
   /*
    * A declarative way to wire up attribute inheritance and automatically generate
    * the `observedAttributes` getter.  For example, if you returned:
-   *    new Map([
-   *      [".foo", "bar,baz=bat"]
-   *    ])
+   *    {
+   *      ".foo": "bar,baz=bat"
+   *    }
    *
    * Then the base class will automatically return ["bar", "bat"] from `observedAttributes`,
    * and set up an `attributeChangedCallback` to pass those attributes down onto an element
    * matching the ".foo" selector.
    *
    * See the `inheritAttribute` function for more details on the attribute string format.
    *
-   * @return {Map<string selector, string attributes>}
+   * @return {Object<string selector, string attributes>}
    */
   static get inheritedAttributes() {
     return null;
   }
 
   /*
    * Generate this array based on `inheritedAttributes`, if any. A class is free to override
    * this if it needs to do something more complex or wants to opt out of this behavior.
    */
   static get observedAttributes() {
     let {inheritedAttributes} = this;
     if (!inheritedAttributes) {
       return [];
     }
 
     let allAttributes = new Set();
-    for (let attrStr of inheritedAttributes.values()) {
-      for (let attrName of attrStr.split(",")) {
+    for (let sel in inheritedAttributes) {
+      for (let attrName of inheritedAttributes[sel].split(",")) {
         let split = attrName.split("=");
         if (split.length == 2) {
           attrName = split[1];
         }
         allAttributes.add(attrName);
       }
     }
     return [...allAttributes];
   }
 
   /*
    * Provide default lifecycle callback for attribute changes that will inherit attributes
-   * based on the static `inheritedAttributes` Map. This can be overridden by callers.
+   * based on the static `inheritedAttributes` Object. This can be overridden by callers.
    */
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this.isConnectedAndReady || oldValue === newValue || !this.inheritedAttributesCache) {
       return;
     }
 
     this.inheritAttributes();
   }
 
   /*
   * After setting content, calling this will cache the elements from selectors in the
-  * static `inheritedAttributes` Map. It'll also do an initial call to `this.inheritAttributes()`,
+  * static `inheritedAttributes` Object. It'll also do an initial call to `this.inheritAttributes()`,
   * so in the simple case, this is the only function you need to call.
   *
   * This should be called any time the children that are inheriting attributes changes. For instance,
   * it's common in a connectedCallback to do something like:
   *
   *   this.textContent = "";
   *   this.append(MozXULElement.parseXULToFragment(`<label />`))
   *   this.initializeAttributeInheritance();
@@ -116,27 +116,27 @@ const MozElementMixin = Base => class Mo
   */
   initializeAttributeInheritance() {
     let {inheritedAttributes} = this.constructor;
     if (!inheritedAttributes) {
       return;
     }
     this._inheritedAttributesValuesCache = null;
     this.inheritedAttributesCache = new Map();
-    for (let [selector, attr] of inheritedAttributes) {
+    for (let selector in inheritedAttributes) {
       let el = this.querySelector(selector);
       // Skip unmatched selectors in case an element omits some elements in certain cases:
       if (!el) {
         continue;
       }
       if (this.inheritedAttributesCache.has(el)) {
         console.error(`Error: duplicate element encountered with ${selector}`);
       }
 
-      this.inheritedAttributesCache.set(el, attr);
+      this.inheritedAttributesCache.set(el, inheritedAttributes[selector]);
     }
     this.inheritAttributes();
   }
 
   /*
    * Loop through the static `inheritedAttributes` Map and inherit attributes to child elements.
    *
    * This usually won't need to be called directly - `this.initializeAttributeInheritance()` and
diff --git a/toolkit/content/tests/chrome/test_custom_element_base.xul b/toolkit/content/tests/chrome/test_custom_element_base.xul
--- a/toolkit/content/tests/chrome/test_custom_element_base.xul
+++ b/toolkit/content/tests/chrome/test_custom_element_base.xul
@@ -87,20 +87,20 @@
     is(deck.id, "foo", "attribute set");
     is(deck.selectedIndex, "0", "Custom Element is property attached");
     deck.remove();
   }
 
   function testInheritAttributes() {
     class InheritsElementDeclarative extends MozXULElement {
       static get inheritedAttributes() {
-        return new Map([
-          ["label", "text=label,foo,boo,bardo=bar"],
-          ["unmatched", "foo"], // Make sure we don't throw on unmatched selectors
-        ]);
+        return {
+          "label": "text=label,foo,boo,bardo=bar",
+          "unmatched": "foo", // Make sure we don't throw on unmatched selectors
+        };
       }
 
       attributeChangedCallback(name, oldValue, newValue) {
         if (!this.label) {
           return;
         }
 
         super.attributeChangedCallback(name, oldValue, newValue);
diff --git a/toolkit/content/widgets/autocomplete-richlistitem.js b/toolkit/content/widgets/autocomplete-richlistitem.js
--- a/toolkit/content/widgets/autocomplete-richlistitem.js
+++ b/toolkit/content/widgets/autocomplete-richlistitem.js
@@ -65,29 +65,29 @@ MozElements.MozAutocompleteRichlistitem 
 
     this._boundaryCutoff = null;
     this._inOverflow = false;
 
     this._adjustAcItem();
   }
 
   static get inheritedAttributes() {
-    return new Map([
-      [".ac-type-icon", "selected,current,type"],
-      [".ac-site-icon", "src=image,selected,type"],
-      [".ac-title", "selected"],
-      [".ac-title-text", "selected"],
-      [".ac-tags", "selected"],
-      [".ac-tags-text", "selected"],
-      [".ac-separator", "selected,actiontype,type"],
-      [".ac-url", "selected,actiontype"],
-      [".ac-url-text", "selected"],
-      [".ac-action", "selected,actiontype"],
-      [".ac-action-text", "selected"],
-    ]);
+    return {
+      ".ac-type-icon": "selected,current,type",
+      ".ac-site-icon": "src=image,selected,type",
+      ".ac-title": "selected",
+      ".ac-title-text": "selected",
+      ".ac-tags": "selected",
+      ".ac-tags-text": "selected",
+      ".ac-separator": "selected,actiontype,type",
+      ".ac-url": "selected,actiontype",
+      ".ac-url-text": "selected",
+      ".ac-action": "selected,actiontype",
+      ".ac-action-text": "selected",
+    };
   }
 
   get _markup() {
     return `
       <image class="ac-type-icon"></image>
       <image class="ac-site-icon"></image>
       <hbox class="ac-title" align="center">
         <description class="ac-text-overflow-container">
@@ -910,27 +910,27 @@ class MozAutocompleteRichlistitemInsecur
 
     // Unlike other autocomplete items, the height of the insecure warning
     // increases by wrapping. So "forceHandleUnderflow" is for container to
     // recalculate an item's height and width.
     this.classList.add("forceHandleUnderflow");
   }
 
   static get inheritedAttributes() {
-    return new Map([
-      [".ac-type-icon", "selected,current,type"],
-      [".ac-site-icon", "src=image,selected,type"],
-      [".ac-title-text", "selected"],
-      [".ac-tags-text", "selected"],
-      [".ac-separator", "selected,actiontype,type"],
-      [".ac-url", "selected,actiontype"],
-      [".ac-url-text", "selected"],
-      [".ac-action", "selected,actiontype"],
-      [".ac-action-text", "selected"],
-    ]);
+    return {
+      ".ac-type-icon": "selected,current,type",
+      ".ac-site-icon": "src=image,selected,type",
+      ".ac-title-text": "selected",
+      ".ac-tags-text": "selected",
+      ".ac-separator": "selected,actiontype,type",
+      ".ac-url": "selected,actiontype",
+      ".ac-url-text": "selected",
+      ".ac-action": "selected,actiontype",
+      ".ac-action-text": "selected",
+    }
   }
 
   get _markup() {
     return `
       <image class="ac-type-icon"></image>
       <image class="ac-site-icon"></image>
       <vbox class="ac-title" align="left">
         <description class="ac-text-overflow-container">
diff --git a/toolkit/content/widgets/menu.js b/toolkit/content/widgets/menu.js
--- a/toolkit/content/widgets/menu.js
+++ b/toolkit/content/widgets/menu.js
@@ -107,22 +107,22 @@ class MozMenuBase extends MozMenuItemBas
 }
 
 MozXULElement.implementCustomInterface(MozMenuBase, [Ci.nsIDOMXULContainerElement]);
 
 // The <menucaption> element is used for rendering <html:optgroup> inside of <html:select>,
 // See SelectParentHelper.jsm.
 class MozMenuCaption extends MozMenuBase {
   static get inheritedAttributes() {
-    return new Map([
-      [".menu-iconic-left", "selected,disabled,checked"],
-      [".menu-iconic-icon", "src=image,validate,src"],
-      [".menu-iconic-text", "value=label,crop,highlightable"],
-      [".menu-iconic-highlightable-text", "text=label,crop,highlightable"],
-    ]);
+    return {
+      ".menu-iconic-left": "selected,disabled,checked",
+      ".menu-iconic-icon": "src=image,validate,src",
+      ".menu-iconic-text": "value=label,crop,highlightable",
+      ".menu-iconic-highlightable-text": "text=label,crop,highlightable",
+    };
   }
 
   _updateAttributes() {
     if (!this._inheritedAttributeMap) {
       return;
     }
 
     for (let [ el, attrs ] of this._inheritedAttributeMap.entries()) {
diff --git a/toolkit/content/widgets/menulist.js b/toolkit/content/widgets/menulist.js
--- a/toolkit/content/widgets/menulist.js
+++ b/toolkit/content/widgets/menulist.js
@@ -52,22 +52,22 @@ class MozMenuList extends MenuBaseContro
           this.activeChild.doCommand();
           event.preventDefault();
         }
       }
     }, { mozSystemGroup: true });
   }
 
   static get inheritedAttributes() {
-    return new Map([
-      [".menulist-icon", "src=image"],
-      [".menulist-label", "value=label,crop,accesskey,highlightable"],
-      [".menulist-highlightable-label", "text=label,crop,accesskey,highlightable"],
-      [".menulist-dropmarker", "disabled,open"],
-    ]);
+    return {
+      ".menulist-icon": "src=image",
+      ".menulist-label": "value=label,crop,accesskey,highlightable",
+      ".menulist-highlightable-label": "text=label,crop,accesskey,highlightable",
+      ".menulist-dropmarker": "disabled,open",
+    };
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this._labelBox) {
       return;
     }
 
     super.attributeChangedCallback(name, oldValue, newValue);
diff --git a/toolkit/content/widgets/popupnotification.js b/toolkit/content/widgets/popupnotification.js
--- a/toolkit/content/widgets/popupnotification.js
+++ b/toolkit/content/widgets/popupnotification.js
@@ -4,35 +4,35 @@
 
 "use strict";
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 class MozPopupNotification extends MozXULElement {
   static get inheritedAttributes() {
-    return new Map([
-      [".popup-notification-icon", "popupid,src=icon,class=iconclass"],
-      [".popup-notification-origin", "value=origin,tooltiptext=origin"],
-      [".popup-notification-description", "popupid"],
-      [".popup-notification-description > span:first-of-type", "text=label,popupid"],
-      [".popup-notification-description > b:first-of-type", "text=name,popupid"],
-      [".popup-notification-description > span:nth-of-type(2)", "text=endlabel,popupid"],
-      [".popup-notification-description > b:last-of-type", "text=secondname,popupid"],
-      [".popup-notification-description > span:last-of-type", "secondendlabel,popupid"],
-      [".popup-notification-closebutton", "oncommand=closebuttoncommand,hidden=closebuttonhidden"],
-      [".popup-notification-learnmore-link", "onclick=learnmoreclick,href=learnmoreurl"],
-      [".popup-notification-warning", "hidden=warninghidden,text=warninglabel"],
-      [".popup-notification-button-container > .popup-notification-secondary-button",
-          "oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden"],
-      [".popup-notification-button-container > toolbarseparator", "hidden=dropmarkerhidden"],
-      [".popup-notification-dropmarker", "onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden"],
-      [".popup-notification-dropmarker > menupopup", "oncommand=menucommand"],
-      [".popup-notification-primary-button", "oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,default=buttonhighlight,disabled=mainactiondisabled"],
-    ]);
+    return {
+      ".popup-notification-icon": "popupid,src=icon,class=iconclass",
+      ".popup-notification-origin": "value=origin,tooltiptext=origin",
+      ".popup-notification-description": "popupid",
+      ".popup-notification-description > span:first-of-type": "text=label,popupid",
+      ".popup-notification-description > b:first-of-type": "text=name,popupid",
+      ".popup-notification-description > span:nth-of-type(2)": "text=endlabel,popupid",
+      ".popup-notification-description > b:last-of-type": "text=secondname,popupid",
+      ".popup-notification-description > span:last-of-type": "secondendlabel,popupid",
+      ".popup-notification-closebutton": "oncommand=closebuttoncommand,hidden=closebuttonhidden",
+      ".popup-notification-learnmore-link": "onclick=learnmoreclick,href=learnmoreurl",
+      ".popup-notification-warning": "hidden=warninghidden,text=warninglabel",
+      ".popup-notification-button-container > .popup-notification-secondary-button":
+          "oncommand=secondarybuttoncommand,label=secondarybuttonlabel,accesskey=secondarybuttonaccesskey,hidden=secondarybuttonhidden",
+      ".popup-notification-button-container > toolbarseparator": "hidden=dropmarkerhidden",
+      ".popup-notification-dropmarker": "onpopupshown=dropmarkerpopupshown,hidden=dropmarkerhidden",
+      ".popup-notification-dropmarker > menupopup": "oncommand=menucommand",
+      ".popup-notification-primary-button": "oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey,default=buttonhighlight,disabled=mainactiondisabled",
+    };
   }
 
   attributeChangedCallback(name, oldValue, newValue) {
     if (!this._hasSlotted) {
       return;
     }
 
     super.attributeChangedCallback(name, oldValue, newValue);
diff --git a/toolkit/content/widgets/tree.js b/toolkit/content/widgets/tree.js
--- a/toolkit/content/widgets/tree.js
+++ b/toolkit/content/widgets/tree.js
@@ -240,20 +240,20 @@
       aPopup.querySelectorAll(":not([colindex])").forEach((e) => { e.hidden = hidden; });
     }
   }
 
   customElements.define("treecolpicker", MozTreecolPicker);
 
   class MozTreecol extends MozElements.BaseControl {
     static get inheritedAttributes() {
-      return new Map([
-        [".treecol-sortdirection", "sortdirection,hidden=hideheader"],
-        [".treecol-text", "value=label,crop"],
-      ]);
+      return {
+        ".treecol-sortdirection": "sortdirection,hidden=hideheader",
+        ".treecol-text": "value=label,crop",
+      };
     }
 
     get content() {
       return MozXULElement.parseXULToFragment(`
         <label class="treecol-text" flex="1" crop="right"></label>
         <image class="treecol-sortdirection"></image>
     `);
     }
@@ -462,19 +462,19 @@
       aEvent.preventDefault();
     }
   }
 
   customElements.define("treecol", MozTreecol);
 
   class MozTreecols extends MozElements.BaseControl {
     static get inheritedAttributes() {
-      return new Map([
-        ["treecolpicker", "tooltiptext=pickertooltiptext"],
-      ]);
+      return {
+        "treecolpicker": "tooltiptext=pickertooltiptext",
+      };
     }
 
     connectedCallback() {
       if (this.delayConnectedCallback()) {
         return;
       }
 
       if (!this.querySelector("treecolpicker")) {
