# vim: se ft=diff :
# HG changeset patch
# User Tom Tromey <tromey@mozilla.com>
# Date 2015-09-11 12:52
Bug 984880 - fix up rule actor to notice update events

diff --git a/toolkit/devtools/server/actors/styles.js b/toolkit/devtools/server/actors/styles.js
index 4c5ce35..e843f4b 100644
--- a/toolkit/devtools/server/actors/styles.js
+++ b/toolkit/devtools/server/actors/styles.js
@@ -9,18 +9,19 @@ const {Cc, Ci, Cu} = require("chrome");
 const promise = require("promise");
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method, RetVal, types} = protocol;
 const events = require("sdk/event/core");
 const {Class} = require("sdk/core/heritage");
 const {LongStringActor} = require("devtools/server/actors/string");
 const {PSEUDO_ELEMENT_SET} = require("devtools/styleinspector/css-logic");
 
-// This will add the "stylesheet" actor type for protocol.js to recognize
-require("devtools/server/actors/stylesheets");
+// This will also add the "stylesheet" actor type for protocol.js to recognize
+const {UPDATE_PRESERVING_RULES, UPDATE_GENERAL} =
+      require("devtools/server/actors/stylesheets");
 
 loader.lazyGetter(this, "CssLogic", () => {
   return require("devtools/styleinspector/css-logic").CssLogic;
 });
 loader.lazyGetter(this, "DOMUtils", () => {
   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
 });
 
@@ -1000,25 +1001,31 @@ let PageStyleFront = protocol.FrontClass(PageStyleActor, {
  * with a special rule type (100).
  */
 let StyleRuleActor = protocol.ActorClass({
   typeName: "domstylerule",
   initialize: function(pageStyle, item) {
     protocol.Actor.prototype.initialize.call(this, null);
     this.pageStyle = pageStyle;
     this.rawStyle = item.style;
+    this._parentSheet = null;
 
     if (item instanceof (Ci.nsIDOMCSSRule)) {
       this.type = item.type;
       this.rawRule = item;
       if ((this.rawRule instanceof Ci.nsIDOMCSSStyleRule ||
            this.rawRule instanceof Ci.nsIDOMMozCSSKeyframeRule) &&
           this.rawRule.parentStyleSheet) {
         this.line = DOMUtils.getRelativeRuleLine(this.rawRule);
         this.column = DOMUtils.getRuleColumn(this.rawRule);
+        this._parentSheet = this.rawRule.parentStyleSheet;
+        this._getRuleIndex();
+        let sheetActor = this.pageStyle._sheetRef(this._parentSheet);
+        this._styleApplied = this._styleApplied.bind(this);
+        sheetActor.on("style-applied", this._styleApplied);
       }
     } else {
       // Fake a rule
       this.type = ELEMENT_STYLE;
       this.rawNode = item;
       this.rawRule = {
         style: item.style,
         toString: function() {
@@ -1083,18 +1090,18 @@ let StyleRuleActor = protocol.ActorClass({
       // below.
       if (this.rawRule.parentRule.type === Ci.nsIDOMCSSRule.MEDIA_RULE) {
         form.media = [];
         for (let i = 0, n = this.rawRule.parentRule.media.length; i < n; i++) {
           form.media.push(this.rawRule.parentRule.media.item(i));
         }
       }
     }
-    if (this.rawRule.parentStyleSheet) {
-      form.parentStyleSheet = this.pageStyle._sheetRef(this.rawRule.parentStyleSheet).actorID;
+    if (this._parentSheet) {
+      form.parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet).actorID;
     }
 
     form.authoredText = this.authoredText;
     switch (this.type) {
       case Ci.nsIDOMCSSRule.STYLE_RULE:
         form.selectors = CssLogic.getSelectors(this.rawRule);
         form.cssText = this.rawStyle.cssText || "";
         break;
@@ -1121,31 +1128,66 @@ let StyleRuleActor = protocol.ActorClass({
         form.keyText = this.rawRule.keyText || "";
         break;
     }
 
     return form;
   },
 
   /**
+   * Compute the index of this actor's raw rule in its parent style
+   * sheet.
+   */
+  _getRuleIndex: function() {
+    let rule = this.rawRule;
+    let cssRules = this._parentSheet.cssRules;
+    this._ruleIndex = -1;
+    for (let i = 0; i < cssRules.length; i++) {
+      if (rule === cssRules.item(i)) {
+        this._ruleIndex = i;
+        break;
+      }
+    }
+  },
+
+  /**
+   * This is attached to the parent style sheet actor's
+   * "style-applied" event.
+   */
+  _styleApplied: function(kind) {
+    if (kind === UPDATE_GENERAL) {
+      // A general change means that the rule actors are invalidated,
+      // so stop listening to events now.
+      let sheetActor = this.pageStyle._sheetRef(this._parentSheet);
+      sheetActor.off("style-applied", this._styleApplied);
+    } else if (this._ruleIndex >= 0) {
+      // The sheet was updated by this actor, in a way that preserves
+      // the rules.  Now, recompute our new rule from the style sheet,
+      // so that we aren't left with a reference to a dangling rule.
+      this.rawRule = this._parentSheet.cssRules[this._ruleIndex];
+      // FIXME emit an event here for the front end if the values change
+      this.line = DOMUtils.getRelativeRuleLine(this.rawRule);
+      this.column = DOMUtils.getRuleColumn(this.rawRule);
+    }
+  },
+
+  /**
    * Return the authored form of a rule's text.  This will include
    * invalid and otherwise ignored properties.
    */
   getAuthoredCssText: function*() {
-    if (this.type !== Ci.nsIDOMCSSRule.STYLE_RULE ||
-        !this.rawRule.parentStyleSheet) {
+    if (this.type !== Ci.nsIDOMCSSRule.STYLE_RULE || !this._parentSheet) {
       return "";
     }
 
     if (typeof this.authoredText === "string") {
       return this.authoredText;
     }
 
-    let parentStyleSheet =
-        this.pageStyle._sheetRef(this.rawRule.parentStyleSheet);
+    let parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet);
     let {str: cssText} = yield parentStyleSheet.getText();
     let {text} = getRuleText(cssText, this.line, this.column);
 
     // Cache the result on the rule actor to avoid parsing again next time
     this.authoredText = text;
     return this.authoredText;
   },
 
@@ -1153,27 +1195,26 @@ let StyleRuleActor = protocol.ActorClass({
    * Set the contents of the rule.  This rewrites the rule in the
    * stylesheet and causes it to be re-evaluated.
    *
    * @param {String} newText the new text of the rule
    * @returns the rule with updated properties
    */
   setRuleText: method(Task.async(function*(newText) {
     if (this.type === Ci.nsIDOMCSSRule.STYLE_RULE &&
-        this.rawRule.parentStyleSheet) {
-      let parentStyleSheet =
-          this.pageStyle._sheetRef(this.rawRule.parentStyleSheet);
+        this._parentSheet) {
+      let parentStyleSheet = this.pageStyle._sheetRef(this._parentSheet);
       let {str: cssText} = yield parentStyleSheet.getText();
 
       let {offset, text} = getRuleText(cssText, this.line, this.column);
       cssText = cssText.substring(0, offset) + newText +
         cssText.substring(offset + text.length);
 
       this.authoredText = newText;
-      yield parentStyleSheet.update(cssText, false);
+      yield parentStyleSheet.update(cssText, false, UPDATE_PRESERVING_RULES);
 
       return this;
     }
   }), {
     request: { modification: Arg(0, "string") },
     response: { rule: RetVal("domstylerule") }
   }),
 
@@ -1197,17 +1238,17 @@ let StyleRuleActor = protocol.ActorClass({
     // Use a fresh element for each call to this function to prevent side
     // effects that pop up based on property values that were already set on the
     // element.
 
     let document;
     if (this.rawNode) {
       document = this.rawNode.ownerDocument;
     } else {
-      let parentStyleSheet = this.rawRule.parentStyleSheet;
+      let parentStyleSheet = this._parentSheet;
       while (parentStyleSheet.ownerRule &&
           parentStyleSheet.ownerRule instanceof Ci.nsIDOMCSSImportRule) {
         parentStyleSheet = parentStyleSheet.ownerRule.parentStyleSheet;
       }
 
       document = this.getDocument(parentStyleSheet);
     }
 
@@ -1238,17 +1279,17 @@ let StyleRuleActor = protocol.ActorClass({
    * @param string value
    *        The new selector value
    *
    * @returns CSSRule
    *        The new CSS rule added
    */
   _addNewSelector: function(value) {
     let rule = this.rawRule;
-    let parentStyleSheet = rule.parentStyleSheet;
+    let parentStyleSheet = this._parentSheet;
     let cssRules = parentStyleSheet.cssRules;
     let cssText = rule.cssText;
     let selectorText = rule.selectorText;
 
     for (let i = 0; i < cssRules.length; i++) {
       if (rule === cssRules.item(i)) {
         try {
           // Inserts the new style rule into the current style sheet and
@@ -1282,17 +1323,17 @@ let StyleRuleActor = protocol.ActorClass({
    *        Returns a boolean if the selector in the stylesheet was modified,
    *        and false otherwise
    */
   modifySelector: method(function(value) {
     if (this.type === ELEMENT_STYLE) {
       return false;
     }
 
-    let document = this.getDocument(this.rawRule.parentStyleSheet);
+    let document = this.getDocument(this._parentSheet);
     // Extract the selector, and pseudo elements and classes
     let [selector, pseudoProp] = value.split(/(:{1,2}.+$)/);
     let selectorElement;
 
     try {
       selectorElement = document.querySelector(selector);
     } catch (e) {
       return false;
diff --git a/toolkit/devtools/server/actors/stylesheets.js b/toolkit/devtools/server/actors/stylesheets.js
index 5cb92e2..896f8d2 100644
--- a/toolkit/devtools/server/actors/stylesheets.js
+++ b/toolkit/devtools/server/actors/stylesheets.js
@@ -35,16 +35,25 @@ transition-timing-function: ease-out !important;\
 transition-property: all !important;\
 }";
 
 let LOAD_ERROR = "error-load";
 
 types.addActorType("stylesheet");
 types.addActorType("originalsource");
 
+// The possible kinds of style-applied events.
+// UPDATE_PRESERVING_RULES means that the update is guaranteed to
+// preserve the number and order of rules on the style sheet.
+// UPDATE_GENERAL covers any other kind of change to the style sheet.
+let UPDATE_PRESERVING_RULES = 0;
+exports.UPDATE_PRESERVING_RULES = UPDATE_PRESERVING_RULES;
+let UPDATE_GENERAL = 1;
+exports.UPDATE_GENERAL = UPDATE_GENERAL;
+
 /**
  * Creates a StyleSheetsActor. StyleSheetsActor provides remote access to the
  * stylesheets of a document.
  */
 let StyleSheetsActor = exports.StyleSheetsActor = protocol.ActorClass({
   typeName: "stylesheets",
 
   /**
@@ -380,17 +389,18 @@ let StyleSheetActor = protocol.ActorClass({
 
   events: {
     "property-change" : {
       type: "propertyChange",
       property: Arg(0, "string"),
       value: Arg(1, "json")
     },
     "style-applied" : {
-      type: "styleApplied"
+      type: "styleApplied",
+      kind: Arg(0, "number")
     },
     "media-rules-changed" : {
       type: "mediaRulesChanged",
       rules: Arg(0, "array:mediarule")
     }
   },
 
   /* List of original sources that generated this stylesheet */
@@ -867,73 +877,74 @@ let StyleSheetActor = protocol.ActorClass({
   },
 
   /**
    * Update the style sheet in place with new text.
    *
    * @param  {object} request
    *         'text' - new text
    *         'transition' - whether to do CSS transition for change.
+   *         'kind' - either UPDATE_PRESERVING_RULES or UPDATE_GENERAL
    */
-  update: method(function(text, transition) {
+  update: method(function(text, transition, kind = UPDATE_GENERAL) {
     DOMUtils.parseStyleSheet(this.rawSheet, text);
 
     this.text = text;
 
     this._notifyPropertyChanged("ruleCount");
 
     if (transition) {
-      this._insertTransistionRule();
+      this._insertTransistionRule(kind);
     }
     else {
-      events.emit(this, "style-applied");
+      events.emit(this, "style-applied", kind);
     }
 
     this._getMediaRules().then((rules) => {
       events.emit(this, "media-rules-changed", rules);
     });
   }, {
     request: {
       text: Arg(0, "string"),
       transition: Arg(1, "boolean")
     }
   }),
 
   /**
    * Insert a catch-all transition rule into the document. Set a timeout
    * to remove the rule after a certain time.
    */
-  _insertTransistionRule: function() {
+  _insertTransistionRule: function(kind) {
     this.document.documentElement.classList.add(TRANSITION_CLASS);
 
     // We always add the rule since we've just reset all the rules
     this.rawSheet.insertRule(TRANSITION_RULE, this.rawSheet.cssRules.length);
 
     // Set up clean up and commit after transition duration (+buffer)
     // @see _onTransitionEnd
     this.window.clearTimeout(this._transitionTimeout);
-    this._transitionTimeout = this.window.setTimeout(this._onTransitionEnd.bind(this),
+    this._transitionTimeout = this.window.setTimeout(this._onTransitionEnd.bind(this, kind),
                               TRANSITION_DURATION_MS + TRANSITION_BUFFER_MS);
   },
 
   /**
    * This cleans up class and rule added for transition effect and then
    * notifies that the style has been applied.
    */
-  _onTransitionEnd: function()
+  _onTransitionEnd: function(kind)
   {
     this.document.documentElement.classList.remove(TRANSITION_CLASS);
 
     let index = this.rawSheet.cssRules.length - 1;
     let rule = this.rawSheet.cssRules[index];
     if (rule.selectorText == TRANSITION_RULE_SELECTOR) {
       this.rawSheet.deleteRule(index);
     }
 
-    events.emit(this, "style-applied");
+    events.emit(this, "style-applied", kind);
   }
 })
 
 /**
  * StyleSheetFront is the client-side counterpart to a StyleSheetActor.
  */
 var StyleSheetFront = protocol.FrontClass(StyleSheetActor, {
   initialize: function(conn, form) {
