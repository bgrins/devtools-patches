# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  28a4562cb5173c543cce6b58480ac80fcce3763a

diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -589,16 +589,22 @@ Element::WrapObject(JSContext *aCx, JS::
 
   nsIDocument* doc = GetComposedDoc();
   if (!doc) {
     // There's no baseclass that cares about this call so we just
     // return here.
     return obj;
   }
 
+  if (!XRE_IsParentProcess()) {
+    // Disable in-content XBL wrapping
+    printf("Returning\n");
+    return obj;
+  }
+
   // We must ensure that the XBL Binding is installed before we hand
   // back this object.
 
   if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR) && GetXBLBinding()) {
     // There's already a binding for this element so nothing left to
     // be done here.
 
     // In theory we could call ExecuteAttachedHandler here when it's safe to
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -236,16 +236,262 @@ class MozBaseControl extends MozXULEleme
 
 MozXULElement.implementCustomInterface(MozBaseControl, [Ci.nsIDOMXULControlElement]);
 
 // Attach the base class to the window so other scripts can use it:
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozBaseControl = MozBaseControl;
 
+
+
+class MozTextLabel extends MozElementMixin(XULTextElement) {
+  // static get observedAttributes() {
+  //   return ["accesskey", "highlightable"];
+  // }
+
+  // attributeChangedCallback(name, oldValue, newValue) {
+  //   if (!this.isConnectedAndReady || oldValue == newValue) {
+  //     return;
+  //   }
+  //   this.formatAccessKey();
+  // }
+
+  get isHiddenHighlightable() {
+    return !this.hasAttribute("highlightable") && (
+      this.classList.contains("button-highlightable-text") ||
+      this.classList.contains("menulist-highlightable-label") ||
+      this.classList.contains("menu-iconic-highlightable-text")
+    );
+  }
+
+  _onClick(event) {
+    if (this.isTextLink) {
+      if (event.button == 0 || event.button == 1) {
+        this.open(event);
+      }
+      return;
+    }
+
+    var controlElement = this.labeledControlElement;
+    if (!controlElement || this.disabled) {
+      return;
+    }
+    controlElement.focus();
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+    if (controlElement.namespaceURI != XUL_NS) {
+      return;
+    }
+    if (controlElement.localName == "checkbox") {
+      controlElement.checked = !controlElement.checked;
+    } else if (controlElement.localName == "radio") {
+      controlElement.control.selectedItem = controlElement;
+    }
+  }
+
+  _onKeyPress(event) {
+    if (this.isTextLink && event.keyCode == 13) {
+      this.click();
+    }
+  }
+
+  // handleEvent(event) {
+  //   if (event.type == "click") {
+  //     this._onClick(event);
+  //   } else if (event.type == "keypress") {
+  //     this._onKeyPress(event);
+  //   }
+  // }
+
+  connectedCallback() {
+    // if (this.delayConnectedCallback()) {
+    //   return;
+    // }
+
+    // if (!this.connectedOnce) {
+    //   this.connectedOnce = true;
+    //   this._lastFormattedAccessKey = null;
+    //   this.addEventListener("click", this, true);
+    //   this.addEventListener("keypress", this);
+    // }
+
+    // setGlobalAccessKeyFormattingState();
+    // this.formatAccessKey();
+  }
+
+  get isTextLink() {
+    return this.classList.contains("text-link") || this.hasAttribute("onClick");
+  }
+
+  // set accessKey(val) {
+  //   this.setAttribute("accesskey", val);
+  // }
+
+  // get accessKey() {
+  //   var accessKey = this.getAttribute("accesskey");
+  //   return accessKey ? accessKey[0] : null;
+  // }
+
+  // get labeledControlElement() {
+  //   var control = this.control;
+  //   return control ? document.getElementById(control) : null;
+  // }
+
+  // set control(val) {
+  //   this.setAttribute("control", val);
+  // }
+
+  // get control() {
+  //   return this.getAttribute("control");
+  // }
+
+  // set href(val) {
+  //   this.setAttribute("href", val);
+  // }
+
+  // get href() {
+  //   return this.getAttribute("href");
+  // }
+
+  openLink(aEvent) {
+    if (!this.isTextLink) {
+      return;
+    }
+
+    var href = this.href;
+    if (!href || this.disabled || aEvent.defaultPrevented)
+      return;
+
+    var uri = null;
+    try {
+      const nsISSM = Ci.nsIScriptSecurityManager;
+      const secMan =
+        Cc["@mozilla.org/scriptsecuritymanager;1"]
+        .getService(nsISSM);
+
+      uri = Services.io.newURI(href);
+
+      let principal;
+      if (this.getAttribute("useoriginprincipal") == "true") {
+        principal = this.nodePrincipal;
+      } else {
+        principal = secMan.createNullPrincipal({});
+      }
+      try {
+        secMan.checkLoadURIWithPrincipal(principal, uri,
+          nsISSM.DISALLOW_INHERIT_PRINCIPAL);
+      } catch (ex) {
+        var msg = "Error: Cannot open a " + uri.scheme + ": link using \
+                         the text-link binding.";
+        Cu.reportError(msg);
+        return;
+      }
+
+      const cID = "@mozilla.org/uriloader/external-protocol-service;1";
+      const nsIEPS = Ci.nsIExternalProtocolService;
+      var protocolSvc = Cc[cID].getService(nsIEPS);
+
+      // if the scheme is not an exposed protocol, then opening this link
+      // should be deferred to the system's external protocol handler
+      if (!protocolSvc.isExposedProtocol(uri.scheme)) {
+        protocolSvc.loadURI(uri);
+        aEvent.preventDefault();
+        return;
+      }
+
+    } catch (ex) {
+      Cu.reportError(ex);
+    }
+
+    aEvent.preventDefault();
+    href = uri ? uri.spec : href;
+
+    // Try handing off the link to the host application, e.g. for
+    // opening it in a tabbed browser.
+    var linkHandled = Cc["@mozilla.org/supports-PRBool;1"]
+      .createInstance(Ci.nsISupportsPRBool);
+    linkHandled.data = false;
+    let { shiftKey, ctrlKey, metaKey, altKey, button } = aEvent;
+    let data = { shiftKey, ctrlKey, metaKey, altKey, button, href };
+    Services.obs
+      .notifyObservers(linkHandled, "handle-xul-text-link", JSON.stringify(data));
+    if (linkHandled.data)
+      return;
+
+    // otherwise, fall back to opening the anchor directly
+    var win = window;
+    if (window.isChromeWindow) {
+      while (win.opener && !win.opener.closed)
+        win = win.opener;
+    }
+    win.open(href);
+  }
+}
+
+customElements.define("label", MozTextLabel);
+
+function mergeElement(element) {
+  if (element.previousSibling instanceof Text) {
+    element.previousSibling.appendData(element.textContent);
+  } else {
+    element.parentNode.insertBefore(element.firstChild, element);
+  }
+  element.remove();
+}
+
+function wrapChar(parent, element, index) {
+  var treeWalker = document.createNodeIterator(parent,
+    NodeFilter.SHOW_TEXT,
+    null);
+  var node = treeWalker.nextNode();
+  while (index >= node.length) {
+    index -= node.length;
+    node = treeWalker.nextNode();
+  }
+  if (index) {
+    node = node.splitText(index);
+  }
+  node.parentNode.insertBefore(element, node);
+  if (node.length > 1) {
+    node.splitText(1);
+  }
+  element.appendChild(node);
+}
+
+let gInsertSeparator;
+let gUnderlineAccesskey;
+let gAlwaysAppendAccessKey = false;
+function setGlobalAccessKeyFormattingState() {
+  if (gUnderlineAccesskey === undefined) {
+    gUnderlineAccesskey = Services.prefs.getIntPref("ui.key.menuAccessKey") != 0;
+  }
+  if (!gUnderlineAccesskey || gInsertSeparator !== undefined) {
+    return;
+  }
+  try {
+    const nsIPrefLocalizedString = Ci.nsIPrefLocalizedString;
+    const prefNameInsertSeparator =
+      "intl.menuitems.insertseparatorbeforeaccesskeys";
+    const prefNameAlwaysAppendAccessKey =
+      "intl.menuitems.alwaysappendaccesskeys";
+
+    var val = Services.prefs.getComplexValue(prefNameInsertSeparator,
+      nsIPrefLocalizedString).data;
+    gInsertSeparator = val == "true";
+
+    val = Services.prefs.getComplexValue(prefNameAlwaysAppendAccessKey,
+      nsIPrefLocalizedString).data;
+    gAlwaysAppendAccessKey = val == "true";
+  } catch (e) {
+    gInsertSeparator = gAlwaysAppendAccessKey = true;
+  }
+}
+
+
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/progressmeter.js",
     "chrome://global/content/elements/radio.js",
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -95,22 +95,22 @@ page {
 
 vbox {
   -moz-box-orient: vertical;
 }
 
 /********** label **********/
 
 label.text-link, label[onclick] {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#text-link");
+  /* -moz-binding: url("chrome://global/content/bindings/text.xml#text-link"); */
   -moz-user-focus: normal;
 }
 
 label[control], label.radio-label, label.checkbox-label, label.toolbarbutton-multiline-text {
-  -moz-binding: url("chrome://global/content/bindings/text.xml#label-control");
+  /* -moz-binding: url("chrome://global/content/bindings/text.xml#label-control"); */
 }
 
 label html|span.accesskey {
   text-decoration: underline;
 }
 
 /********** button **********/
 
