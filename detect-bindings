# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  87c745019518b1d6cd782534f2553721e5735657
Add a test to detect which xbl bindings are being used in the ui

diff --git a/browser/moz.build b/browser/moz.build
--- a/browser/moz.build
+++ b/browser/moz.build
@@ -23,16 +23,17 @@ DIRS += [
     'app',
 ]
 
 if CONFIG['MAKENSISU']:
     DIRS += ['installer/windows']
 
 TEST_DIRS += [
     'tools/mozscreenshots',
+    'tools/xblcount',
 ]
 
 DIST_SUBDIR = 'browser'
 export('DIST_SUBDIR')
 
 if CONFIG['MOZ_ARTIFACT_BUILDS']:
     # Ensure a pre-built interfaces.xpt installed to the objdir by the artifact
     # code is included by the top-level chrome.manifest.
diff --git a/browser/tools/xblcount/XblCounter.jsm b/browser/tools/xblcount/XblCounter.jsm
new file mode 100644
--- /dev/null
+++ b/browser/tools/xblcount/XblCounter.jsm
@@ -0,0 +1,217 @@
+
+this.EXPORTED_SYMBOLS = ["XblCounter"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+const {console} = Cu.import("resource://gre/modules/Console.jsm", {});
+
+// The `Node` global is not available here
+const ELEMENT_NODE = 1;
+const DOCUMENT_NODE = 9;
+
+function XblCounter() {
+  this.bindingsMap = new Map();
+  this.duplicateNodeSet = new Map();
+}
+
+XblCounter.prototype = {
+
+  numElementsTraversed: 0,
+  numDuplicateXblElements: 0,
+  get numXblElements() {
+    return [...this.bindingsMap.values()].reduce((a, v)=> {
+      return a+v;
+    });
+  },
+  get bindingsList() {
+    return [...this.bindingsMap.entries()].sort((a, b) => {
+      return b[1] - a[1];
+    });
+  },
+
+  nodeFilter(node) {
+    return node.nodeType == ELEMENT_NODE ? Ci.nsIDOMNodeFilter.FILTER_ACCEPT : Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  },
+
+
+  countNodes(element) {
+    var win = element.ownerGlobal;
+    var dw = new DocumentWalker(element,
+                                win,
+                                Ci.nsIDOMNodeFilter.SHOW_ELEMENT,
+                                this.nodeFilter);
+    var node = element.nodeType === DOCUMENT_NODE ? dw.nextNode() : dw.currentNode;
+    do {
+      this.numElementsTraversed++;
+      var style = node.ownerGlobal.getComputedStyle(node, null);
+      var binding = style && style.getPropertyValue("-moz-binding");
+      if (binding && binding != "none") {
+        var cssPath = getCssPath(node);
+        if (!this.duplicateNodeSet.has(cssPath)) {
+          this.bindingsMap.set(binding, (this.bindingsMap.get(binding) || 0) + 1);
+          this.duplicateNodeSet.set(cssPath, node);
+        } else {
+          this.numDuplicateXblElements++;
+        }
+      }
+    } while (node = dw.nextNode())
+  }
+}
+
+/**
+ * Traverse getBindingParent until arriving upon the bound element
+ * responsible for the generation of the specified node.
+ * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/DOM_Interfaces#getBindingParent.
+ *
+ * @param {DOMNode} node
+ * @return {DOMNode}
+ *         If node is not anonymous, this will return node. Otherwise,
+ *         it will return the bound element
+ *
+ */
+function getRootBindingParent(node) {
+  let parent;
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return node;
+  }
+  while ((parent = doc.getBindingParent(node))) {
+    node = parent;
+  }
+  return node;
+}
+
+/**
+ * Find the position of [element] in [nodeList].
+ * @returns an index of the match, or -1 if there is no match
+ */
+function positionInNodeList(element, nodeList) {
+  for (let i = 0; i < nodeList.length; i++) {
+    if (element === nodeList[i]) {
+      return i;
+    }
+  }
+  return -1;
+}
+
+/**
+ * Get the full CSS path for a given element.
+ * @returns a string that can be used as a CSS selector for the element
+ */
+function getCssPath(ele) {
+  var parent = getRootBindingParent(ele);
+  const document = ele.ownerDocument;
+  if (!document || !document.contains(parent)) {
+    throw new Error("getCssPath received element not inside document");
+  }
+
+  const getElementSelector = element => {
+    if (!element.localName) {
+      return "";
+    }
+
+    let label = element.nodeName == element.nodeName.toUpperCase()
+                ? element.localName.toLowerCase()
+                : element.localName;
+
+    if (element.id) {
+      label += "#" + element.id;
+    } else {
+      let index = positionInNodeList(element, element.parentNode.children)
+      if (index == -1) {
+       // XBL anon.  This seems to miss on scrollbars (hence the || []) but that's fine for now
+       index = positionInNodeList(element, element.ownerDocument.getAnonymousNodes(element.parentNode) || []);
+      }
+      label += ":nth-child(" + (index + 1) + ")";
+    }
+
+    return label;
+  };
+
+  let paths = [];
+
+  while (ele) {
+    if (!ele || ele.nodeType !== ELEMENT_NODE) {
+      break;
+    }
+
+    paths.splice(0, 0, getElementSelector(ele));
+    ele = ele.parentNode;
+    if (!ele) {
+      ele = document.getBindingParent(ele);
+    }
+  }
+
+  return paths.length ? paths.join(" ") : "";
+}
+
+/**
+ * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
+ * See inDeepTreeWalker for more information about the methods.
+ *
+ * @param {DOMNode} node
+ * @param {Window} rootWin
+ * @param {Number} whatToShow
+ *        See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
+ * @param {Function} filter
+ *        A custom filter function Taking in a DOMNode and returning an Int. See
+ *        WalkerActor.nodeFilter for an example.
+ */
+function DocumentWalker(node, rootWin,
+    whatToShow = Ci.nsIDOMNodeFilter.SHOW_ALL,
+    filter = nodeFilter) {
+  if (Cu.isDeadWrapper(rootWin) || !rootWin.location) {
+    throw new Error("Got an invalid root window in DocumentWalker");
+  }
+
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"]
+    .createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.showDocumentsAsNodes = true;
+  this.walker.init(rootWin.document, whatToShow);
+  this.filter = filter;
+
+  // Make sure that the walker knows about the initial node (which could
+  // be skipped due to a filter).
+  this.walker.currentNode = this.getStartingNode(node);
+}
+
+DocumentWalker.prototype = {
+  get whatToShow() {
+    return this.walker.whatToShow;
+  },
+  get currentNode() {
+    return this.walker.currentNode;
+  },
+  set currentNode(val) {
+    this.walker.currentNode = val;
+  },
+  nextNode: function () {
+    let node = this.walker.currentNode;
+    if (!node) {
+      return null;
+    }
+
+    let nextNode = this.walker.nextNode();
+    while (nextNode && this.isSkippedNode(nextNode)) {
+      nextNode = this.walker.nextNode();
+    }
+
+    return nextNode;
+  },
+  getStartingNode: function (node, skipTo) {
+    // Keep a reference on the starting node in case we can't find a node compatible with
+    // the filter.
+    let startingNode = node;
+
+    while (node && this.isSkippedNode(node)) {
+      node = node.parentNode;
+    }
+
+    return node || startingNode;
+  },
+
+  isSkippedNode: function (node) {
+    return this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  },
+};
diff --git a/browser/tools/xblcount/moz.build b/browser/tools/xblcount/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/tools/xblcount/moz.build
@@ -0,0 +1,11 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
+
+EXTRA_JS_MODULES += [
+  'XblCounter.jsm',
+]
diff --git a/browser/tools/xblcount/test/browser.ini b/browser/tools/xblcount/test/browser.ini
new file mode 100644
--- /dev/null
+++ b/browser/tools/xblcount/test/browser.ini
@@ -0,0 +1,3 @@
+[DEFAULT]
+
+[browser_count_xbl.js]
diff --git a/browser/tools/xblcount/test/browser_count_xbl.js b/browser/tools/xblcount/test/browser_count_xbl.js
new file mode 100644
--- /dev/null
+++ b/browser/tools/xblcount/test/browser_count_xbl.js
@@ -0,0 +1,28 @@
+
+const {XblCounter} = Components.utils.import("resource:///modules/XblCounter.jsm", {});
+
+add_task(async function test_unique() {
+  const counter = new XblCounter();
+  counter.countNodes(document);
+  const numXblElements = counter.numXblElements;
+  counter.countNodes(document.querySelector("#sidebar-box"));
+  is(counter.numXblElements, numXblElements,
+    "Re-running the counter on a child doesn't increase the number of elements detected");
+  ok(counter.numDuplicateXblElements > 0,
+    "Some duplicate elements have been detected");
+});
+
+add_task(async function test_print_count() {
+  const counter = new XblCounter();
+  counter.countNodes(document);
+  ok(counter.numElementsTraversed > 0, "some nodes have been traversed");
+  const bindings = counter.bindingsList;
+
+  info(`${counter.numElementsTraversed} elements traversed`);
+  info(`${counter.numXblElements} elements with xbl bindings`);
+  info(`${counter.numDuplicateXblElements} duplicate elements with xbl bindings detected`);
+  info(`${bindings.length} unique bindings`);
+  info("Sorted list of bindings:\n" + bindings.map(b => {
+    return b[1] + "\t" + b[0];
+  }).join("\n"));
+});
