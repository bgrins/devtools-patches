# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b138d2f271fdb598bf8a66c2dcb7fe391ca2a96f

diff --git a/testing/mochitest/browser-test.js b/testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js
+++ b/testing/mochitest/browser-test.js
@@ -20,16 +20,366 @@ if (Services.appinfo.OS == 'Android') {
     window.addEventListener("MozAfterPaint", function() {
       setTimeout(testInit, 0);
     }, {once: true});
   }, {once: true});
 } else {
   setTimeout(testInit, 0);
 }
 
+/**
+ * Traverse getBindingParent until arriving upon the bound element
+ * responsible for the generation of the specified node.
+ * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/DOM_Interfaces#getBindingParent.
+ *
+ * @param {DOMNode} node
+ * @return {DOMNode}
+ *         If node is not anonymous, this will return node. Otherwise,
+ *         it will return the bound element
+ *
+ */
+function getRootBindingParent(node) {
+  let parent;
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return node;
+  }
+  while ((parent = doc.getBindingParent(node))) {
+    node = parent;
+  }
+  return node;
+}
+
+/**
+ * Find the position of [element] in [nodeList].
+ * @returns an index of the match, or -1 if there is no match
+ */
+function positionInNodeList(element, nodeList) {
+  for (let i = 0; i < nodeList.length; i++) {
+    if (element === nodeList[i]) {
+      return i;
+    }
+  }
+  return -1;
+}
+
+/**
+ * Get the full CSS path for a given element.
+ * @returns a string that can be used as a CSS selector for the element
+ */
+function getCssPath(ele) {
+  var parent = getRootBindingParent(ele);
+  const document = ele.ownerDocument;
+  if (!document || !document.contains(parent)) {
+    throw new Error("getCssPath received element not inside document");
+  }
+
+  const getElementSelector = element => {
+    if (!element.localName) {
+      return "";
+    }
+
+    let label = element.nodeName == element.nodeName.toUpperCase()
+                ? element.localName.toLowerCase()
+                : element.localName;
+
+    if (element.id) {
+      label += "#" + element.id;
+    } else {
+      let index = positionInNodeList(element, element.parentNode.children)
+      if (index == -1) {
+       // XBL anon.  This seems to miss on scrollbars (hence the || []) but that's fine for now
+       index = positionInNodeList(element, element.ownerDocument.getAnonymousNodes(element.parentNode) || []);
+      }
+      label += ":nth-child(" + (index + 1) + ")";
+    }
+
+    return label;
+  };
+
+  let paths = [];
+
+  while (ele) {
+    if (!ele || ele.nodeType !== Node.ELEMENT_NODE) {
+      break;
+    }
+
+    paths.splice(0, 0, getElementSelector(ele));
+    ele = ele.parentNode;
+    if (!ele) {
+      ele = document.getBindingParent(ele);
+    }
+  }
+
+  return paths.length ? paths.join(" ") : "";
+}
+
+var nodeFilterConstants = {
+  FILTER_ACCEPT: 1,
+  FILTER_REJECT: 2,
+  FILTER_SKIP: 3,
+
+  SHOW_ALL: 0xFFFFFFFF,
+  SHOW_ELEMENT: 0x00000001,
+  SHOW_ATTRIBUTE: 0x00000002,
+  SHOW_TEXT: 0x00000004,
+  SHOW_CDATA_SECTION: 0x00000008,
+  SHOW_ENTITY_REFERENCE: 0x00000010,
+  SHOW_ENTITY: 0x00000020,
+  SHOW_PROCESSING_INSTRUCTION: 0x00000040,
+  SHOW_COMMENT: 0x00000080,
+  SHOW_DOCUMENT: 0x00000100,
+  SHOW_DOCUMENT_TYPE: 0x00000200,
+  SHOW_DOCUMENT_FRAGMENT: 0x00000400,
+  SHOW_NOTATION: 0x00000800
+};
+
+// SKIP_TO_* arguments are used with the DocumentWalker, driving the strategy to use if
+// the starting node is incompatible with the filter function of the walker.
+var SKIP_TO_PARENT = "SKIP_TO_PARENT";
+var SKIP_TO_SIBLING = "SKIP_TO_SIBLING";
+
+/**
+ * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
+ * See inDeepTreeWalker for more information about the methods.
+ *
+ * @param {DOMNode} node
+ * @param {Window} rootWin
+ * @param {Number} whatToShow
+ *        See nodeFilterConstants / inIDeepTreeWalker for options.
+ * @param {Function} filter
+ *        A custom filter function Taking in a DOMNode and returning an Int. See
+ *        WalkerActor.nodeFilter for an example.
+ * @param {String} skipTo
+ *        Either SKIP_TO_PARENT or SKIP_TO_SIBLING. If the provided node is not compatible
+ *        with the filter function for this walker, try to find a compatible one either
+ *        in the parents or in the siblings of the node.
+ */
+function DocumentWalker(node, rootWin,
+    whatToShow = nodeFilterConstants.SHOW_ALL,
+    filter = nodeFilter,
+    skipTo = SKIP_TO_PARENT) {
+  if (Cu.isDeadWrapper(rootWin) || !rootWin.location) {
+    throw new Error("Got an invalid root window in DocumentWalker");
+  }
+
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"]
+    .createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.showDocumentsAsNodes = true;
+  this.walker.init(rootWin.document, whatToShow);
+  this.filter = filter;
+
+  // Make sure that the walker knows about the initial node (which could
+  // be skipped due to a filter).
+  this.walker.currentNode = this.getStartingNode(node, skipTo);
+}
+
+DocumentWalker.prototype = {
+  get whatToShow() {
+    return this.walker.whatToShow;
+  },
+  get currentNode() {
+    return this.walker.currentNode;
+  },
+  set currentNode(val) {
+    this.walker.currentNode = val;
+  },
+
+  parentNode: function () {
+    return this.walker.parentNode();
+  },
+
+  nextNode: function () {
+    let node = this.walker.currentNode;
+    if (!node) {
+      return null;
+    }
+
+    let nextNode = this.walker.nextNode();
+    while (nextNode && this.isSkippedNode(nextNode)) {
+      nextNode = this.walker.nextNode();
+    }
+
+    return nextNode;
+  },
+
+  firstChild: function () {
+    let node = this.walker.currentNode;
+    if (!node) {
+      return null;
+    }
+
+    let firstChild = this.walker.firstChild();
+    while (firstChild && this.isSkippedNode(firstChild)) {
+      firstChild = this.walker.nextSibling();
+    }
+
+    return firstChild;
+  },
+
+  lastChild: function () {
+    let node = this.walker.currentNode;
+    if (!node) {
+      return null;
+    }
+
+    let lastChild = this.walker.lastChild();
+    while (lastChild && this.isSkippedNode(lastChild)) {
+      lastChild = this.walker.previousSibling();
+    }
+
+    return lastChild;
+  },
+
+  previousSibling: function () {
+    let node = this.walker.previousSibling();
+    while (node && this.isSkippedNode(node)) {
+      node = this.walker.previousSibling();
+    }
+    return node;
+  },
+
+  nextSibling: function () {
+    let node = this.walker.nextSibling();
+    while (node && this.isSkippedNode(node)) {
+      node = this.walker.nextSibling();
+    }
+    return node;
+  },
+
+  getStartingNode: function (node, skipTo) {
+    // Keep a reference on the starting node in case we can't find a node compatible with
+    // the filter.
+    let startingNode = node;
+
+    if (skipTo === SKIP_TO_PARENT) {
+      while (node && this.isSkippedNode(node)) {
+        node = node.parentNode;
+      }
+    } else if (skipTo === SKIP_TO_SIBLING) {
+      node = this.getClosestAcceptedSibling(node);
+    }
+
+    return node || startingNode;
+  },
+
+  /**
+   * Loop on all of the provided node siblings until finding one that is compliant with
+   * the filter function.
+   */
+  getClosestAcceptedSibling: function (node) {
+    if (this.filter(node) === nodeFilterConstants.FILTER_ACCEPT) {
+      // node is already valid, return immediately.
+      return node;
+    }
+
+    // Loop on starting node siblings.
+    let previous = node;
+    let next = node;
+    while (previous || next) {
+      previous = previous && previous.previousSibling;
+      next = next && next.nextSibling;
+
+      if (previous && this.filter(previous) === nodeFilterConstants.FILTER_ACCEPT) {
+        // A valid node was found in the previous siblings of the node.
+        return previous;
+      }
+
+      if (next && this.filter(next) === nodeFilterConstants.FILTER_ACCEPT) {
+        // A valid node was found in the next siblings of the node.
+        return next;
+      }
+    }
+
+    return null;
+  },
+
+  isSkippedNode: function (node) {
+    return this.filter(node) === nodeFilterConstants.FILTER_SKIP;
+  },
+};
+
+function nodeFilter(node) {
+  return node.nodeType == 1 ? nodeFilterConstants.FILTER_ACCEPT : nodeFilterConstants.FILTER_SKIP;
+}
+
+var bindingsMap = new Map();
+var duplicateNodeSet = new Map();
+
+function addObserver(win) {
+  let observer = new MutationObserver(mutations => {
+    console.log("Observed changes", mutations);
+    countNodes(win);
+  });
+  observer.observe(document.documentElement, {
+    childList: true,
+    subtree: true,
+  });
+
+}
+function countNodes(win) {
+  var dw = new DocumentWalker(document,
+                              win,
+                              nodeFilterConstants.SHOW_ELEMENT,
+                              nodeFilter);
+  var node;
+  var count = 0;
+  while (node = dw.nextNode()) {
+    count++;
+    var style = node.ownerDocument.defaultView.getComputedStyle(node, null);
+    var binding = style && style.getPropertyValue("-moz-binding");
+    if (!binding || binding == "none") {
+      continue;
+    }
+
+    var cssPath = getCssPath(node);
+    if (duplicateNodeSet.has(cssPath)) {
+      // console.log(getCssPath(node), node, binding, duplicateNodeSet.get(cssPath), node == duplicateNodeSet.get(getCssPath));
+    }
+    if (!duplicateNodeSet.has(cssPath)) {
+      bindingsMap.set(binding, (bindingsMap.get(binding) || 0) + 1);
+      duplicateNodeSet.set(cssPath, node);
+    }
+  }
+
+  // var totalBindings = [...bindingsMap.values()].reduce((a, v)=> {
+  //   return a+v;
+  // });
+  // var sortedBindings = [...bindingsMap.entries()].sort((a, b) => {
+  //   return b[1] - a[1];
+  // });
+
+  // console.log("Counting for window: " + window.location.toString());
+  // console.log(count + " element nodes traversed");
+  // console.log(sortedBindings.length + " unique bindings detected");
+  // console.log(totalBindings + " total bindings detected");
+
+  // console.log(sortedBindings.map(b => {
+  //   return b[1] + "\t" + b[0];
+  // }).join("\n"));
+}
+
+// addObserver(window);
+// countNodes(window);
+
+
+function MyWindowObserver() {
+  this.observe=function(aSubject, aTopic, aData) {
+    if (aTopic == "domwindowopened") {
+      addObserver(aSubject);
+      countNodes(aSubject);
+    }
+  }
+}
+var ww = Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
+              .getService(Components.interfaces.nsIWindowWatcher);
+ww.registerNotification(new MyWindowObserver())
+
 var TabDestroyObserver = {
   outstanding: new Set(),
   promiseResolver: null,
 
   init: function() {
     Services.obs.addObserver(this, "message-manager-close");
     Services.obs.addObserver(this, "message-manager-disconnect");
   },
@@ -659,16 +1009,33 @@ Tester.prototype = {
           "ShutdownLeaks: Wait for cleanup to be finished before checking for leaks");
         Services.obs.notifyObservers({wrappedJSObject: barrier},
           "shutdown-leaks-before-check");
 
         barrier.client.addBlocker("ShutdownLeaks: Wait for tabs to finish closing",
                                   TabDestroyObserver.wait());
 
         barrier.wait().then(() => {
+
+
+  var totalBindings = [...bindingsMap.values()].reduce((a, v)=> {
+    return a+v;
+  });
+  var sortedBindings = [...bindingsMap.entries()].sort((a, b) => {
+    return b[1] - a[1];
+  });
+
+  console.log("Counting for window: " + window.location.toString());
+  console.log(sortedBindings.length + " unique bindings detected");
+  console.log(totalBindings + " total bindings detected");
+
+  console.log(sortedBindings.map(b => {
+    return b[1] + "\t" + b[0];
+  }).join("\n"));
+
           // Simulate memory pressure so that we're forced to free more resources
           // and thus get rid of more false leaks like already terminated workers.
           Services.obs.notifyObservers(null, "memory-pressure", "heap-minimize");
 
           Services.ppmm.broadcastAsyncMessage("browser-test:collect-request");
 
           shutdownCleanup(() => {
             setTimeout(() => {
