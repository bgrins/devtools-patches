# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  87c745019518b1d6cd782534f2553721e5735657
Add a test to detect which xbl bindings are being used in the ui

diff --git a/browser/moz.build b/browser/moz.build
--- a/browser/moz.build
+++ b/browser/moz.build
@@ -23,16 +23,17 @@ DIRS += [
     'app',
 ]
 
 if CONFIG['MAKENSISU']:
     DIRS += ['installer/windows']
 
 TEST_DIRS += [
     'tools/mozscreenshots',
+    'tools/xulcount',
 ]
 
 DIST_SUBDIR = 'browser'
 export('DIST_SUBDIR')
 
 if CONFIG['MOZ_ARTIFACT_BUILDS']:
     # Ensure a pre-built interfaces.xpt installed to the objdir by the artifact
     # code is included by the top-level chrome.manifest.
diff --git a/browser/tools/xulcount/XulCounter.jsm b/browser/tools/xulcount/XulCounter.jsm
new file mode 100644
--- /dev/null
+++ b/browser/tools/xulcount/XulCounter.jsm
@@ -0,0 +1,257 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+this.EXPORTED_SYMBOLS = ["XulCounter"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+const {console} = Cu.import("resource://gre/modules/Console.jsm", {});
+
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+const SVG_NS = "http://www.w3.org/2000/svg";
+
+// The `Node` global is not available here
+const ELEMENT_NODE = 1;
+const DOCUMENT_NODE = 9;
+
+function XulCounter() {
+  this.xblBindingsMap = new Map();
+  this.xulTagMap = new Map();
+  this.htmlTagMap = new Map();
+  this.unknownTagMap = new Map();
+}
+
+XulCounter.prototype = {
+
+  numElementsTraversed: 0,
+
+  get numXblElements() {
+    return [...this.xblBindingsMap.values()].reduce((a, v) => {
+      return a + v;
+    }, 0);
+  },
+  get numXulElements() {
+    return [...this.xulTagMap.values()].reduce((a, v) => {
+      return a + v;
+    }, 0);
+  },
+  get numHtmlElements() {
+    return [...this.htmlTagMap.values()].reduce((a, v) => {
+      return a + v;
+    }, 0);
+  },
+  get numUnknownElements() {
+    return [...this.unknownTagMap.values()].reduce((a, v) => {
+      return a + v;
+    }, 0);
+  },
+
+  get xblList() {
+    return [...this.xblBindingsMap.entries()].sort((a, b) => {
+      return b[1] - a[1];
+    }).map(e => [e[1], e[0]]);
+  },
+  get xulList() {
+    return [...this.xulTagMap.entries()].sort((a, b) => {
+      return b[1] - a[1];
+    }).map(e => [e[1], e[0]]);
+  },
+  get htmlList() {
+    return [...this.htmlTagMap.entries()].sort((a, b) => {
+      return b[1] - a[1];
+    }).map(e => [e[1], e[0]]);
+  },
+
+  nodeFilter(node) {
+    return node.nodeType == ELEMENT_NODE ? Ci.nsIDOMNodeFilter.FILTER_ACCEPT : Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  },
+
+  countNodes(element) {
+    var win = element.ownerGlobal;
+    var dw = new DocumentWalker(element,
+                                win,
+                                Ci.nsIDOMNodeFilter.SHOW_ELEMENT,
+                                this.nodeFilter);
+    var node = element.nodeType === DOCUMENT_NODE ? dw.nextNode() : dw.currentNode;
+    while (node) {
+      this.numElementsTraversed++;
+      var style = node.ownerGlobal.getComputedStyle(node);
+      var binding = style && style.getPropertyValue("-moz-binding");
+      var isXBL = binding && binding != "none";
+      var isXUL = node.namespaceURI === XUL_NS;
+      var isHTML = node.namespaceURI === HTML_NS || node.namespaceURI === SVG_NS;
+
+      if (isXBL) {
+        this.xblBindingsMap.set(binding, (this.xblBindingsMap.get(binding) || 0) + 1);
+      }
+
+      if (isXUL) {
+        this.xulTagMap.set(node.nodeName, (this.xulTagMap.get(node.nodeName) || 0) + 1);
+      } else if (isHTML) {
+        // Explicitly don't count HTML elements inside a xbl binding like
+        //   <html:span anonid="accessKeyParens">
+        if (!isXBLAnonymous(node)) {
+          this.htmlTagMap.set(node.nodeName, (this.htmlTagMap.get(node.nodeName) || 0) + 1);
+        }
+      } else if (!isNativeAnonymous(node)) {
+        console.warn("Unknown node detected", node);
+        this.unknownTagMap.set(node.nodeName, (this.unknownTagMap.get(node.nodeName) || 0) + 1);
+      }
+
+      node = dw.nextNode();
+    }
+  }
+}
+
+function getBindingParent(node) {
+  let doc = node.ownerDocument;
+  if (!doc) {
+    return null;
+  }
+
+  // If there is no binding parent then it is not anonymous.
+  let parent = doc.getBindingParent(node);
+  if (!parent) {
+    return null;
+  }
+
+  return parent;
+}
+
+/**
+ * Determine whether a node has a bindingParent.
+ *
+ * @param {DOMNode} node
+ * @return {Boolean}
+ *
+ */
+const hasBindingParent = (node) => !!getBindingParent(node);
+
+/**
+ * Determine whether a node is native anonymous content (as opposed
+ * to XBL anonymous or shadow DOM).
+ * Native anonymous content includes elements like internals to form
+ * controls and ::before/::after.
+ *
+ * @param {DOMNode} node
+ * @return {Boolean}
+ *
+ */
+const isNativeAnonymous = (node) =>
+  hasBindingParent(node) && !(isXBLAnonymous(node) || isShadowAnonymous(node));
+
+/**
+ * Determine whether a node is XBL anonymous content (as opposed
+ * to native anonymous or shadow DOM).
+ * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/Anonymous_Content.
+ *
+ * @param {DOMNode} node
+ * @return {Boolean}
+ *
+ */
+function isXBLAnonymous(node) {
+  let parent = getBindingParent(node);
+  if (!parent) {
+    return false;
+  }
+
+  // Shadow nodes also show up in getAnonymousNodes, so return false.
+  if (parent.shadowRoot && parent.shadowRoot.contains(node)) {
+    return false;
+  }
+
+  let anonNodes = [...node.ownerDocument.getAnonymousNodes(parent) || []];
+  return anonNodes.indexOf(node) > -1;
+}
+
+/**
+ * Determine whether a node is a child of a shadow root.
+ * See https://w3c.github.io/webcomponents/spec/shadow/
+ *
+ * @param {DOMNode} node
+ * @return {Boolean}
+ */
+function isShadowAnonymous(node) {
+  let parent = getBindingParent(node);
+  if (!parent) {
+    return false;
+  }
+
+  // If there is a shadowRoot and this is part of it then this
+  // is not native anonymous
+  return parent.shadowRoot && parent.shadowRoot.contains(node);
+}
+
+/**
+ * Wrapper for inDeepTreeWalker.  Adds filtering to the traversal methods.
+ * See inDeepTreeWalker for more information about the methods.
+ *
+ * @param {DOMNode} node
+ * @param {Window} rootWin
+ * @param {Number} whatToShow
+ *        See Ci.nsIDOMNodeFilter / inIDeepTreeWalker for options.
+ * @param {Function} filter
+ *        A custom filter function Taking in a DOMNode and returning an Int. See
+ *        WalkerActor.nodeFilter for an example.
+ */
+function DocumentWalker(node, rootWin,
+    whatToShow = Ci.nsIDOMNodeFilter.SHOW_ALL,
+    filter) {
+  if (Cu.isDeadWrapper(rootWin) || !rootWin.location) {
+    throw new Error("Got an invalid root window in DocumentWalker");
+  }
+
+  this.walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"]
+    .createInstance(Ci.inIDeepTreeWalker);
+  this.walker.showAnonymousContent = true;
+  this.walker.showSubDocuments = true;
+  this.walker.showDocumentsAsNodes = true;
+  this.walker.init(rootWin.document, whatToShow);
+  this.filter = filter;
+
+  // Make sure that the walker knows about the initial node (which could
+  // be skipped due to a filter).
+  this.walker.currentNode = this.getStartingNode(node);
+}
+
+DocumentWalker.prototype = {
+  get whatToShow() {
+    return this.walker.whatToShow;
+  },
+  get currentNode() {
+    return this.walker.currentNode;
+  },
+  set currentNode(val) {
+    this.walker.currentNode = val;
+  },
+  nextNode() {
+    let node = this.walker.currentNode;
+    if (!node) {
+      return null;
+    }
+
+    let nextNode = this.walker.nextNode();
+    while (nextNode && this.isSkippedNode(nextNode)) {
+      nextNode = this.walker.nextNode();
+    }
+
+    return nextNode;
+  },
+  getStartingNode(node, skipTo) {
+    // Keep a reference on the starting node in case we can't find a node compatible with
+    // the filter.
+    let startingNode = node;
+
+    while (node && this.isSkippedNode(node)) {
+      node = node.parentNode;
+    }
+
+    return node || startingNode;
+  },
+  isSkippedNode(node) {
+    return this.filter(node) === Ci.nsIDOMNodeFilter.FILTER_SKIP;
+  },
+};
diff --git a/browser/tools/xulcount/moz.build b/browser/tools/xulcount/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/tools/xulcount/moz.build
@@ -0,0 +1,11 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
+
+EXTRA_JS_MODULES += [
+  'XulCounter.jsm',
+]
diff --git a/browser/tools/xulcount/test/.eslintrc.js b/browser/tools/xulcount/test/.eslintrc.js
new file mode 100644
--- /dev/null
+++ b/browser/tools/xulcount/test/.eslintrc.js
@@ -0,0 +1,7 @@
+"use strict";
+
+module.exports = {
+  "extends": [
+    "plugin:mozilla/browser-test"
+  ]
+};
diff --git a/browser/tools/xulcount/test/browser.ini b/browser/tools/xulcount/test/browser.ini
new file mode 100644
--- /dev/null
+++ b/browser/tools/xulcount/test/browser.ini
@@ -0,0 +1,3 @@
+[DEFAULT]
+
+[browser_count_elements.js]
diff --git a/browser/tools/xulcount/test/browser_count_elements.js b/browser/tools/xulcount/test/browser_count_elements.js
new file mode 100644
--- /dev/null
+++ b/browser/tools/xulcount/test/browser_count_elements.js
@@ -0,0 +1,31 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const {XulCounter} = Components.utils.import("resource:///modules/XulCounter.jsm", {});
+
+add_task(async function test_print_count() {
+  const counter = new XulCounter();
+  counter.countNodes(document);
+  ok(counter.numElementsTraversed > 0, "some nodes have been traversed");
+
+  info(`${counter.numElementsTraversed} elements traversed`);
+  info(`There are ${counter.numXulElements} xul elements`);
+  info(`There are ${counter.numXblElements} elements with xbl bindings`);
+  info(`There are ${counter.numHtmlElements} html elements`);
+  info(`There are ${counter.numUnknownElements} unknown elements`);
+
+  const xulList = counter.xulList;
+  info(`${xulList.length} unique xul elements`);
+  info("Sorted list of xul elements:\n" + xulList.map(b => b[0] + "\t" + b[1]).join("\n"));
+
+  const xblList = counter.xblList;
+  info(`${xblList.length} unique xbl bindings`);
+  info("Sorted list of xbl bindings:\n" + xblList.map(b => b[0] + "\t" + b[1]).join("\n"));
+
+  const htmlList = counter.htmlList;
+  info(`${htmlList.length} unique html elements`);
+  info("Sorted list of html elements:\n" + htmlList.map(b => b[0] + "\t" + b[1]).join("\n"));
+});
