# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  fbdcb7d48dd9b11877048e542b6abd854af97541
Bug 1120852 - 1 - Expose the animation delay on the animationplayer actor

diff --git a/toolkit/devtools/server/actors/animation.js b/toolkit/devtools/server/actors/animation.js
--- a/toolkit/devtools/server/actors/animation.js
+++ b/toolkit/devtools/server/actors/animation.js
@@ -106,16 +106,40 @@ let AnimationPlayerActor = ActorClass({
     if (durationText.indexOf(",") !== -1) {
       durationText = durationText.split(",")[this.playerIndex];
     }
 
     return parseFloat(durationText) * 1000;
   },
 
   /**
+   * Get the animation delay from this player, in milliseconds.
+   * Note that the Web Animations API doesn't yet offer a way to retrieve this
+   * directly from the AnimationPlayer object, so for now, a delay is only
+   * returned if found in the node's computed styles.
+   * @return {Number}
+   */
+  getDelay: function() {
+    let delayText;
+    if (this.styles.animationDelay !== "0s") {
+      delayText = this.styles.animationDelay;
+    } else if (this.styles.transitionDelay !== "0s") {
+      delayText = this.styles.transitionDelay;
+    } else {
+      return 0;
+    }
+
+    if (delayText.indexOf(",") !== -1) {
+      delayText = delayText.split(",")[this.playerIndex];
+    }
+
+    return parseFloat(delayText) * 1000;
+  },
+
+  /**
    * Get the animation iteration count for this player. That is, how many times
    * is the animation scheduled to run.
    * Note that the Web Animations API doesn't yet offer a way to retrieve this
    * directly from the AnimationPlayer object, so for now, check for
    * animationIterationCount in the node's computed styles, and return that.
    * This style property defaults to 1 anyway.
    * @return {Number}
    */
@@ -140,16 +164,17 @@ let AnimationPlayerActor = ActorClass({
        * Return the player's current startTime value.
        * Will be null whenever the animation is paused or waiting to start.
        */
       startTime: this.player.startTime,
       currentTime: this.player.currentTime,
       playState: this.player.playState,
       name: this.player.source.effect.name,
       duration: this.getDuration(),
+      delay: this.getDelay(),
       iterationCount: this.getIterationCount(),
       /**
        * Is the animation currently running on the compositor. This is important for
        * developers to know if their animation is hitting the fast path or not.
        * Currently this will only be true for Firefox OS though (where we have
        * compositor animations enabled).
        * Returns false whenever the animation is paused as it is taken off the
        * compositor then.
@@ -234,16 +259,17 @@ let AnimationPlayerFront = FrontClass(An
    */
   get initialState() {
     return {
       startTime: this._form.startTime,
       currentTime: this._form.currentTime,
       playState: this._form.playState,
       name: this._form.name,
       duration: this._form.duration,
+      delay: this._form.delay,
       iterationCount: this._form.iterationCount,
       isRunningOnCompositor: this._form.isRunningOnCompositor
     }
   },
 
   // About auto-refresh:
   //
   // The AnimationPlayerFront is capable of automatically refreshing its state
diff --git a/toolkit/devtools/server/tests/browser/animation.html b/toolkit/devtools/server/tests/browser/animation.html
--- a/toolkit/devtools/server/tests/browser/animation.html
+++ b/toolkit/devtools/server/tests/browser/animation.html
@@ -42,16 +42,41 @@
     width: 150px;
     height: 150px;
     border-radius: 50%;
     background: purple;
 
     animation: move 1s;
   }
 
+  .delayed-animation {
+    display: inline-block;
+
+    width: 150px;
+    height: 150px;
+    border-radius: 50%;
+    background: rebeccapurple;
+
+    animation: move 2s 5s infinite;
+  }
+
+  .delayed-transition {
+    display: inline-block;
+
+    width: 150px;
+    height: 150px;
+    border-radius: 50%;
+    background: black;
+
+    transition: width 5s 3s;
+  }
+  .delayed-transition.get-round {
+    width: 200px;
+  }
+
   @keyframes move {
     100% {
       transform: translateY(100px);
     }
   }
 
   @keyframes glow {
     100% {
@@ -59,15 +84,18 @@
     }
   }
 </style>
 <div class="not-animated"></div>
 <div class="simple-animation"></div>
 <div class="multiple-animations"></div>
 <div class="transition"></div>
 <div class="short-animation"></div>
+<div class="delayed-animation"></div>
+<div class="delayed-transition"></div>
 <script type="text/javascript">
   // Get the transition started when the page loads
   var players;
   addEventListener("load", function() {
     document.querySelector(".transition").classList.add("get-round");
+    document.querySelector(".delayed-transition").classList.add("get-round");
   });
 </script>
diff --git a/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js b/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js
--- a/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js
+++ b/toolkit/devtools/server/tests/browser/browser_animation_actors_03.js
@@ -31,16 +31,17 @@ function* playerHasAnInitialState(walker
   let [player] = yield front.getAnimationPlayersForNode(node);
 
   ok(player.initialState, "The player front has an initial state");
   ok("startTime" in player.initialState, "Player's state has startTime");
   ok("currentTime" in player.initialState, "Player's state has currentTime");
   ok("playState" in player.initialState, "Player's state has playState");
   ok("name" in player.initialState, "Player's state has name");
   ok("duration" in player.initialState, "Player's state has duration");
+  ok("delay" in player.initialState, "Player's state has delay");
   ok("iterationCount" in player.initialState, "Player's state has iterationCount");
   ok("isRunningOnCompositor" in player.initialState, "Player's state has isRunningOnCompositor");
 }
 
 function* playerStateIsCorrect(walker, front) {
   info("Checking the state of the simple animation");
 
   let state = yield getAnimationStateForNode(walker, front, ".simple-animation", 0);
@@ -62,16 +63,26 @@ function* playerStateIsCorrect(walker, f
   info("Checking the state of one of multiple animations on a node");
 
   // Checking the 2nd player
   state = yield getAnimationStateForNode(walker, front, ".multiple-animations", 1);
   is(state.name, "glow", "The 2nd animation's name is correct");
   is(state.duration, 1000, "The 2nd animation's duration is correct");
   is(state.iterationCount, 5, "The 2nd animation's iteration count is correct");
   is(state.playState, "running", "The 2nd animation's playState is correct");
+
+  info("Checking the state of an animation with delay");
+
+  state = yield getAnimationStateForNode(walker, front, ".delayed-animation", 0);
+  is(state.delay, 5000, "The animation delay is correct");
+
+  info("Checking the state of an transition with delay");
+
+  state = yield getAnimationStateForNode(walker, front, ".delayed-transition", 0);
+  is(state.delay, 3000, "The transition delay is correct");
 }
 
 function* getAnimationStateForNode(walker, front, nodeSelector, playerIndex) {
   let node = yield walker.querySelector(walker.rootNode, nodeSelector);
   let players = yield front.getAnimationPlayersForNode(node);
   let player = players[playerIndex];
   yield player.ready();
   let state = yield player.getCurrentState();
