# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  22c9264fb98c983a701c516b934f9b49e9502f75

diff --git a/browser/base/content/pageinfo/pageInfo.js b/browser/base/content/pageinfo/pageInfo.js
--- a/browser/base/content/pageinfo/pageInfo.js
+++ b/browser/base/content/pageinfo/pageInfo.js
@@ -23,16 +23,18 @@ function pageInfoTreeView(treeid, copyco
   this.sortdir = false;
 }
 
 pageInfoTreeView.prototype = {
   set rowCount(c) { throw "rowCount is a readonly property"; },
   get rowCount() { return this.rows; },
 
   setTree(tree) {
+    console.log("Called setTree", tree);
+    console.trace();
     this.tree = tree;
   },
 
   getCellText(row, column) {
     // row can be null, but js arrays are 0-indexed.
     // colidx cannot be null, but can be larger than the number
     // of columns in the array. In this case it's the fault of
     // whoever typoed while calling this function.
diff --git a/dom/xul/XULTreeElement.cpp b/dom/xul/XULTreeElement.cpp
--- a/dom/xul/XULTreeElement.cpp
+++ b/dom/xul/XULTreeElement.cpp
@@ -54,16 +54,17 @@ void XULTreeElement::DestroyContent() {
     mView->SetTree(nullptr);  // Break the circular ref between the view and us.
   }
   mView = nullptr;
 
   nsXULElement::DestroyContent();
 }
 
 static nsIContent* FindBodyElement(nsIContent* aParent) {
+  printf("FindBodyElement\n")
   mozilla::dom::FlattenedChildIterator iter(aParent);
   for (nsIContent* content = iter.GetNextChild(); content;
        content = iter.GetNextChild()) {
     mozilla::dom::NodeInfo* ni = content->NodeInfo();
     if (ni->Equals(nsGkAtoms::treechildren, kNameSpaceID_XUL)) {
       return content;
     } else if (ni->Equals(nsGkAtoms::tree, kNameSpaceID_XUL)) {
       // There are nesting tree elements. Only the innermost should
@@ -84,28 +85,28 @@ nsTreeBodyFrame* XULTreeElement::GetTree
   RefPtr<Document> doc = GetUncomposedDoc();
 
   // Make sure our frames are up to date, and layout as needed.  We
   // have to do this before checking for our cached mTreeBody, since
   // it might go away on style flush, and in any case if aFlushLayout
   // is true we need to make sure to flush no matter what.
   // XXXbz except that flushing style when we were not asked to flush
   // layout here breaks things.  See bug 585123.
-  if (aFlushLayout && doc) {
-    doc->FlushPendingNotifications(FlushType::Layout);
-  }
+  // if (aFlushLayout && doc) {
+  //   doc->FlushPendingNotifications(FlushType::Layout);
+  // }
 
-  if (mTreeBody) {
-    // Have one cached already.
-    return mTreeBody;
-  }
+  // if (mTreeBody) {
+  //   // Have one cached already.
+  //   return mTreeBody;
+  // }
 
-  if (!aFlushLayout && doc) {
-    doc->FlushPendingNotifications(FlushType::Frames);
-  }
+  // if (!aFlushLayout && doc) {
+  //   doc->FlushPendingNotifications(FlushType::Frames);
+  // }
 
   nsCOMPtr<nsIContent> tree = FindBodyElement(this);
   if (tree) {
     mTreeBody = do_QueryFrame(tree->GetPrimaryFrame());
   }
 
   return mTreeBody;
 }
diff --git a/toolkit/content/widgets/tree.js b/toolkit/content/widgets/tree.js
--- a/toolkit/content/widgets/tree.js
+++ b/toolkit/content/widgets/tree.js
@@ -513,17 +513,17 @@
       // specified.
       Array.forEach(this.getElementsByTagName("splitter"), function(splitter) {
         if (!splitter.hasAttribute("resizeafter"))
           splitter.setAttribute("resizeafter", "farthest");
       });
     }
   }
 
-  class MozTree extends MozElementMixin(XULTreeElement) {
+  class MozTree extends BaseControlMixin(MozElementMixin(XULTreeElement)) {
     constructor() {
       super();
 
       this.addEventListener("underflow", (event) => {
         // Scrollport event orientation
         // 0: vertical
         // 1: horizontal
         // 2: both (not used)
@@ -852,39 +852,73 @@
           if (l >= 0) {
             this.view.selection.timedSelect(l, this._selectDelay);
             this.ensureRowIsVisible(l);
           }
           event.preventDefault();
         }
       });
 
-    }
-
-    connectedCallback() {
-      if (this.delayConnectedCallback()) {
-        return;
-      }
-      this.textContent = "";
-      this.appendChild(MozXULElement.parseXULToFragment(`
+      let shadow = this.attachShadow({mode: 'open'});
+      shadow.appendChild(MozXULElement.parseXULToFragment(`
         <html:slot name="treecols"></html:slot>
         <stack class="tree-stack" flex="1">
           <hbox class="tree-rows" flex="1">
             <hbox flex="1" class="tree-bodybox">
               <html:slot></html:slot>
             </hbox>
             <scrollbar height="0" minwidth="0" minheight="0" orient="vertical" inherits="collapsed=hidevscroll" style="position:relative; z-index:2147483647;" oncontextmenu="event.stopPropagation(); event.preventDefault();" onclick="event.stopPropagation(); event.preventDefault();" ondblclick="event.stopPropagation();" oncommand="event.stopPropagation();"></scrollbar>
           </hbox>
           <textbox anonid="input" class="tree-input" left="0" top="0" hidden="true"></textbox>
         </stack>
         <hbox inherits="collapsed=hidehscroll">
           <scrollbar orient="horizontal" flex="1" increment="16" style="position:relative; z-index:2147483647;" oncontextmenu="event.stopPropagation(); event.preventDefault();" onclick="event.stopPropagation(); event.preventDefault();" ondblclick="event.stopPropagation();" oncommand="event.stopPropagation();"></scrollbar>
           <scrollcorner inherits="collapsed=hidevscroll" oncontextmenu="event.stopPropagation(); event.preventDefault();" onclick="event.stopPropagation(); event.preventDefault();" ondblclick="event.stopPropagation();" oncommand="event.stopPropagation();"></scrollcorner>
         </hbox>
       `));
+
+
+    }
+
+    connectedCallback() {
+      if (this.delayConnectedCallback()) {
+        return;
+      }
+      // this.textContent = "";
+
+      // if (!this._hasConnected) {
+      //   this._hasConnected = true;
+      //   let children = [...this.children];
+      //   this.appendChild(MozXULElement.parseXULToFragment(`
+      //     <html:slot name="treecols"></html:slot>
+      //     <stack class="tree-stack" flex="1">
+      //       <hbox class="tree-rows" flex="1">
+      //         <hbox flex="1" class="tree-bodybox">
+      //           <html:slot></html:slot>
+      //         </hbox>
+      //         <scrollbar height="0" minwidth="0" minheight="0" orient="vertical" inherits="collapsed=hidevscroll" style="position:relative; z-index:2147483647;" oncontextmenu="event.stopPropagation(); event.preventDefault();" onclick="event.stopPropagation(); event.preventDefault();" ondblclick="event.stopPropagation();" oncommand="event.stopPropagation();"></scrollbar>
+      //       </hbox>
+      //       <textbox anonid="input" class="tree-input" left="0" top="0" hidden="true"></textbox>
+      //     </stack>
+      //     <hbox inherits="collapsed=hidehscroll">
+      //       <scrollbar orient="horizontal" flex="1" increment="16" style="position:relative; z-index:2147483647;" oncontextmenu="event.stopPropagation(); event.preventDefault();" onclick="event.stopPropagation(); event.preventDefault();" ondblclick="event.stopPropagation();" oncommand="event.stopPropagation();"></scrollbar>
+      //       <scrollcorner inherits="collapsed=hidevscroll" oncontextmenu="event.stopPropagation(); event.preventDefault();" onclick="event.stopPropagation(); event.preventDefault();" ondblclick="event.stopPropagation();" oncommand="event.stopPropagation();"></scrollcorner>
+      //     </hbox>
+      //   `));
+
+
+      //   for (let c of children) {
+      //     if (c.localName == "treecols") {
+      //       this.querySelector(".tree-stack").before(c);
+      //     } else {
+      //       this.querySelector(".tree-bodybox").append(c);
+      //     }
+      //   }
+      // }
+
       // XXX: Implement `this.inheritAttribute()` for the [inherits] attribute in the markup above!
 
       this.pageUpOrDownMovesSelection = !/Mac/.test(navigator.platform);
 
       this._inputField = null;
 
       this._editingRow = -1;
 
