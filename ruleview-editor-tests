# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  1cbd19a7201576044b60f8ec0f496717bc2729ed
Bug 1150780 - Refactor ruleview tests and add 'empty value' inplace editor test;r=pbrosset

diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-property_01.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-property_01.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-property_01.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-property_01.js
@@ -1,84 +1,131 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Testing various inplace-editor behaviors in the rule-view
-// FIXME: To be split in several test files, and some of the inplace-editor
-// focus/blur/commit/revert stuff should be factored out in head.js
+// Testing adding new properties via the inplace-editors in the rule
+// view.
+// FIXME: some of the inplace-editor focus/blur/commit/revert stuff
+// should be factored out in head.js
 
-let TEST_URL = 'url("' + TEST_URL_ROOT + 'doc_test_image.png")';
-let PAGE_CONTENT = [
+let BACKGROUND_IMAGE_URL = 'url("' + TEST_URL_ROOT + 'doc_test_image.png")';
+let TEST_URI = [
   '<style type="text/css">',
   '  #testid {',
   '    background-color: blue;',
   '  }',
   '  .testclass {',
   '    background-color: green;',
   '  }',
   '</style>',
   '<div id="testid" class="testclass">Styled Node</div>'
 ].join("\n");
 
+let TEST_DATA = [
+  { name: "color", value: "red", isValid: true },
+  { name: "background-image", value: BACKGROUND_IMAGE_URL, isValid: true },
+  { name: "border", value: "solid 1px foo", isValid: false },
+];
+
 add_task(function*() {
-  let tab = yield addTab("data:text/html;charset=utf-8,test rule view user changes");
-
-  info("Creating the test document");
-  content.document.body.innerHTML = PAGE_CONTENT;
+  let tab = yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
 
   info("Opening the rule-view");
   let {toolbox, inspector, view} = yield openRuleView();
 
   info("Selecting the test element");
   yield selectNode("#testid", inspector);
 
-  yield testEditProperty(view, "border-color", "red", tab.linkedBrowser);
-  yield testEditProperty(view, "background-image", TEST_URL, tab.linkedBrowser);
+  let ruleEditor = getRuleViewRuleEditor(view, 1);
+  for (let {name, value, isValid} of TEST_DATA) {
+    yield testEditProperty(ruleEditor, name, value, isValid);
+  }
+
+
+  // Finally, check to make sure that emptying out an existing value doesn't
+  // create a second inplace editor (Bug 1150780)
+  let propEditor = ruleEditor.rule.textProps[0].editor;
+  let onModifications = ruleEditor.rule._applyingModifications;
+  console.log(ruleEditor.rule.textProps[1].editor.element.innerHTML);
+  yield editFieldAndWaitForBlur(propEditor.valueSpan, ["VK_DELETE", "VK_RETURN"]);
+  info ("Waiting for modifications to be applied");
+  yield onModifications;
+  yield editFieldAndWaitForBlur(ruleEditor.doc.activeElement, ["VK_RETURN"]);
+
+  console.log(ruleEditor.rule.textProps[1].editor.element.innerHTML);
+
+  is (ruleEditor.element.querySelectorAll(".styleinspector-propertyeditor").length,
+      1, "wat?");
+  is (ruleEditor.rule.textProps.length, 4, "Correct number of props");
+
+  // yield promise.defer().promise;
 });
 
-function* testEditProperty(view, name, value, browser) {
+function* editFieldAndWaitForBlur(element, chars) {
+  let editor = yield focusEditableField(element);
+  let input = editor.input;
+
+  is(inplaceEditor(element), editor, "The new property editor got focused");
+
+  let onBlur = once(input, "blur");
+  for (let ch of chars) {
+    EventUtils.sendChar(ch, element.ownerDocument.defaultView);
+  }
+
+  info ("Waiting for blur");
+  yield onBlur;
+}
+
+function* testEditProperty(ruleEditor, name, value, isValid, ind) {
   info("Test editing existing property name/value fields");
 
-  let idRuleEditor = getRuleViewRuleEditor(view, 1);
-  let propEditor = idRuleEditor.rule.textProps[0].editor;
+  info("Focusing an existing property name in the rule-view");
+  let doc = ruleEditor.doc;
+  let editor = yield focusEditableField(ruleEditor.closeBrace);
+  // let editor = yield focusEditableField(propEditor.nameSpan, 32, 1);
 
-  info("Focusing an existing property name in the rule-view");
-  let editor = yield focusEditableField(propEditor.nameSpan, 32, 1);
-
-  is(inplaceEditor(propEditor.nameSpan), editor, "The property name editor got focused");
+  is(inplaceEditor(ruleEditor.newPropSpan), editor, "The new property editor got focused");
+  // is(inplaceEditor(propEditor.nameSpan), editor, "The property name editor got focused");
   let input = editor.input;
 
   info("Entering a new property name, including : to commit and focus the value");
-  let onValueFocus = once(idRuleEditor.element, "focus", true);
-  let onModifications = idRuleEditor.rule._applyingModifications;
+  let onValueFocus = once(ruleEditor.element, "focus", true);
+  let onModifications = ruleEditor.rule._applyingModifications;
   for (let ch of name + ":") {
-    EventUtils.sendChar(ch, view.doc.defaultView);
+    EventUtils.sendChar(ch, doc.defaultView);
   }
   yield onValueFocus;
   yield onModifications;
 
   // Getting the value editor after focus
-  editor = inplaceEditor(view.doc.activeElement);
+  editor = inplaceEditor(doc.activeElement);
   input = editor.input;
+  let propEditor = ruleEditor.rule.textProps[ruleEditor.rule.textProps.length - 1].editor;
   is(inplaceEditor(propEditor.valueSpan), editor, "Focus moved to the value.");
 
   info("Entering a new value, including ; to commit and blur the value");
   let onBlur = once(input, "blur");
-  onModifications = idRuleEditor.rule._applyingModifications;
+  onModifications = ruleEditor.rule._applyingModifications;
   for (let ch of value + ";") {
-    EventUtils.sendChar(ch, view.doc.defaultView);
+    EventUtils.sendChar(ch, doc.defaultView);
   }
   yield onBlur;
   yield onModifications;
 
-  is(propEditor.isValid(), true, value + " is a valid entry");
+  is(propEditor.isValid(), isValid, value + " is " + isValid ? "valid" : "invalid");
 
   info("Checking that the style property was changed on the content page");
   let propValue = yield executeInContent("Test:GetRulePropertyValue", {
     styleSheetIndex: 0,
     ruleIndex: 0,
     name
   });
-  is(propValue, value, name + " should have been set.");
+
+  if (isValid) {
+    is(propValue, value, name + " should have been set.");
+  } else {
+    isnot(propValue, value, name + " shouldn't have been set.");
+  }
 }
+
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-property_02.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-property_02.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-property_02.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-property_02.js
@@ -1,38 +1,39 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test several types of rule-view property edition
 
+let TEST_URI = [
+  '<style type="text/css">',
+  '#testid {',
+  '  background-color: blue;',
+  '}',
+  '.testclass, .unmatched {',
+  '  background-color: green;',
+  '}',
+  '</style>',
+  '<div id="testid" class="testclass">Styled Node</div>',
+  '<div id="testid2">Styled Node</div>'
+].join("\n");
+
 add_task(function*() {
-  yield addTab("data:text/html;charset=utf-8,browser_ruleview_ui.js");
+  let tab = yield addTab("data:text/html;charset=utf-8," + encodeURIComponent(TEST_URI));
+
   let {toolbox, inspector, view} = yield openRuleView();
 
-  info("Creating the test document");
-  let style = "" +
-    "#testid {" +
-    "  background-color: blue;" +
-    "}" +
-    ".testclass, .unmatched {" +
-    "  background-color: green;" +
-    "}";
-  let styleNode = addStyle(content.document, style);
-  content.document.body.innerHTML = "<div id='testid' class='testclass'>Styled Node</div>" +
-                                    "<div id='testid2'>Styled Node</div>";
-
   yield selectNode("#testid", inspector);
   yield testEditProperty(inspector, view);
   yield testDisableProperty(inspector, view);
   yield testPropertyStillMarkedDirty(inspector, view);
-
-  gBrowser.removeCurrentTab();
+  yield testPropertyWithEmptyValueWorks(inspector, view);
 });
 
 function* testEditProperty(inspector, ruleView) {
   let idRuleEditor = getRuleViewRuleEditor(ruleView, 1);
   let propEditor = idRuleEditor.rule.textProps[0].editor;
 
   let editor = yield focusEditableField(propEditor.nameSpan);
   let input = editor.input;
@@ -135,8 +136,49 @@ function* testPropertyStillMarkedDirty(i
   yield selectNode("#testid", inspector);
 
   let props = ruleView.element.querySelectorAll(".ruleview-property");
   for (let i = 0; i < props.length; i++) {
     is(props[i].hasAttribute("dirty"), i <= 1,
       "props[" + i + "] marked dirty as appropriate");
   }
 }
+
+function focusAndTypeIntoInput(input, chars) {
+  // Try clicking on the editor's input again, shouldn't cause trouble (see bug 761665).
+  EventUtils.synthesizeMouse(input, 1, 1, {}, input.ownerDocument.defaultView);
+  input.select();
+  for (let ch of chars) {
+    EventUtils.sendChar(ch, input.ownerDocument.defaultView);
+  }
+}
+
+function* testPropertyWithEmptyValueWorks(inspector, ruleView) {
+  let idRuleEditor = getRuleViewRuleEditor(ruleView, 1);
+  let propEditor = idRuleEditor.rule.textProps[0].editor;
+
+  let editor = yield focusEditableField(propEditor.valueSpan);
+  let input = editor.input;
+  is(inplaceEditor(propEditor.valueSpan), editor, "Next focused editor should be the name editor.");
+
+  ok(input.selectionStart === 0 && input.selectionEnd === input.value.length, "Editor contents are selected.");
+
+  // Try clicking on the editor's input again, shouldn't cause trouble (see bug 761665).
+  // EventUtils.synthesizeMouse(input, 1, 1, {}, ruleView.doc.defaultView);
+  // input.select();
+
+  info("Entering property name \"border-color\" followed by a colon to focus the value");
+  let onFocus = once(idRuleEditor.element, "focus", true);
+
+  // Remove all text and then press enter to remove the property
+  typeCharsIntoInput(input, [
+    "VK_DELETE",
+    "VK_ENTER"
+  ]);
+
+  // EventUtils.sendChar("VK_DELETE", ruleView.doc.defaultView);
+  // EventUtils.sendChar("VK_ENTER", ruleView.doc.defaultView);
+  yield onFocus;
+  yield idRuleEditor.rule._applyingModifications;
+  console.log("FOOBAR");
+
+  yield promise.defer().promise;
+}
diff --git a/browser/devtools/styleinspector/test/head.js b/browser/devtools/styleinspector/test/head.js
--- a/browser/devtools/styleinspector/test/head.js
+++ b/browser/devtools/styleinspector/test/head.js
@@ -408,23 +408,24 @@ function* waitForComputedStyleProperty(s
 }
 
 /**
  * Given an inplace editable element, click to switch it to edit mode, wait for
  * focus
  * @return a promise that resolves to the inplace-editor element when ready
  */
 let focusEditableField = Task.async(function*(editable, xOffset=1, yOffset=1, options={}) {
-  let onFocus = once(editable.parentNode, "focus", true);
+  if (editable.ownerDocument.activeElement !== editable) {
+    let onFocus = once(editable.parentNode, "focus", true);
 
-  info("Clicking on editable field to turn to edit mode");
-  EventUtils.synthesizeMouse(editable, xOffset, yOffset, options,
-    editable.ownerDocument.defaultView);
-  let event = yield onFocus;
-
+    info("Clicking on editable field to turn to edit mode");
+    EventUtils.synthesizeMouse(editable, xOffset, yOffset, options,
+      editable.ownerDocument.defaultView);
+    let event = yield onFocus;
+  }
   info("Editable field gained focus, returning the input field now");
   return inplaceEditor(editable.ownerDocument.activeElement);
 });
 
 /**
  * Given a tooltip object instance (see Tooltip.js), checks if it is set to
  * toggle and hover and if so, checks if the given target is a valid hover target.
  * This won't actually show the tooltip (the less we interact with XUL panels
