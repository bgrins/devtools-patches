# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Parent  bef8483e062915c16be2079bebb44f7d5501a7c7
Bug 1123851 - 6 - Add drag/drop support to the Element Geometry Highlighter, to resize elements

diff --git a/browser/devtools/inspector/test/browser.ini b/browser/devtools/inspector/test/browser.ini
--- a/browser/devtools/inspector/test/browser.ini
+++ b/browser/devtools/inspector/test/browser.ini
@@ -45,16 +45,17 @@ skip-if = e10s # GCLI isn't e10s compati
 [browser_inspector_highlighter-csstransform_02.js]
 [browser_inspector_highlighter-geometry_01.js]
 [browser_inspector_highlighter-geometry_02.js]
 [browser_inspector_highlighter-geometry_03.js]
 [browser_inspector_highlighter-geometry_04.js]
 [browser_inspector_highlighter-geometry_05.js]
 [browser_inspector_highlighter-hover_01.js]
 [browser_inspector_highlighter-hover_02.js]
+[browser_inspector_highlighter-geometry_08.js]
 [browser_inspector_highlighter-hover_03.js]
 [browser_inspector_highlighter-iframes.js]
 [browser_inspector_highlighter-keybinding_01.js]
 [browser_inspector_highlighter-keybinding_02.js]
 [browser_inspector_highlighter-keybinding_03.js]
 [browser_inspector_highlighter-options.js]
 [browser_inspector_highlighter-rect_01.js]
 [browser_inspector_highlighter-rect_02.js]
diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_08.js b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_08.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_08.js
@@ -0,0 +1,101 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Test that elements with at least one of width or height can be resized in
+// content by dragging the resize handle of the GeometryEditorHighlighter.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+
+const TEST_DATA = [{
+  desc: "Change width of a fixed element",
+  selector: ".fixed",
+  sizeBefore: {
+   "width": "50px",
+   "height": "50px"
+  },
+  dragFrom: {x:50, y:450},
+  dragTo: {x:75, y:450},
+  sizeAfter: {
+   "width": "75px",
+   "height": "50px"
+  }
+}, {
+  desc: "Change both width and height of an element",
+  selector: "#node1",
+  sizeBefore: {
+   "width": "300px",
+   "height": "300px"
+  },
+  dragFrom: {x:304, y:304},
+  dragTo: {x:354, y:404},
+  sizeAfter: {
+   "width": "350px",
+   "height": "400px"
+  }
+}, {
+  desc: "Change the height only of an element, even when moving along both axis",
+  selector: ".relative",
+  sizeBefore: "10px",
+  dragFrom: {x:1150, y:100},
+  dragTo: {x:900, y:190},
+  sizeAfter: "100px"
+}];
+
+add_task(function*() {
+  let {inspector, toolbox} = yield openInspectorForURL(TEST_URL);
+  let front = inspector.inspector;
+
+  for (let data of TEST_DATA) {
+    info("Running test case: " + data.desc);
+
+    info("Highlighting the test node " + data.selector);
+    let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+    let node = yield getNodeFront(data.selector, inspector);
+    yield highlighter.show(node);
+
+    info("Checking the size label before dragging");
+    yield checkSize(highlighter, data.sizeBefore);
+
+    info("Resizing the node by dragging the handle");
+    yield dragDrop(highlighter, data.dragFrom, data.dragTo);
+
+    info("Checking the new arrow coordinates");
+    yield checkSize(highlighter, data.sizeAfter);
+
+    info("Hiding the highlighter");
+    yield highlighter.hide();
+    yield highlighter.finalize();
+  }
+});
+
+function* dragDrop(highlighter, from, to) {
+  info("Simulating drag and drop from " +
+    from.x + "/" + from.y + " to " + to.x + "/" + to.y);
+
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: from.x, y: from.y, options: {type: "mousedown"}});
+  let onUpdated = waitForHighlighterEvent("updated", highlighter);
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mousemove"}});
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mouseup"}});
+
+  yield onUpdated;
+}
+
+function* checkSize(highlighter, sizes) {
+  let size = yield getHighlighterNodeTextContent(highlighter, ID + "label-text-size");
+  size = size.split(" ");
+  if (size.length === 4) {
+    let [,width,,height] = size;
+    is(width, sizes.width, "The size label contains the width " + sizes.width);
+    is(height, sizes.height, "The size label contains the height " + sizes.height);
+  } else if (size.length === 2) {
+    let [,dim] = size;
+    is(dim, sizes, "The size label contains the dimension " + sizes);
+  }
+}
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -187,28 +187,36 @@
 /* Element geometry highlighter */
 
 :-moz-native-anonymous .geometry-editor-root {
   /* The geometry editor can be interacted with, so it needs to react to
      pointer events */
   pointer-events: auto;
 }
 
+:-moz-native-anonymous .geometry-editor-root[moving] {
+  cursor: move;
+}
+
 :-moz-native-anonymous .geometry-editor-offset-parent {
   stroke: #08c;
   shape-rendering: crispEdges;
   stroke-dasharray: 5 3;
   fill: transparent;
 }
 
 :-moz-native-anonymous .geometry-editor-current-node {
   stroke: #08c;
   shape-rendering: crispEdges;
   fill: #87ceeb;
-  opacity: 0.4;
+  opacity: 0.6;
+}
+
+:-moz-native-anonymous .geometry-editor-current-node.movable {
+  cursor: move;
 }
 
 :-moz-native-anonymous .geometry-editor-arrow {
   stroke: #08c;
   shape-rendering: crispEdges;
 }
 
 :-moz-native-anonymous .geometry-editor-label-bubble {
@@ -219,8 +227,16 @@
 :-moz-native-anonymous .geometry-editor-label-text {
   fill: hsl(216,33%,97%);
   font: message-box;
   font-size: 10px;
   text-anchor: middle;
   dominant-baseline: middle;
   -moz-user-select: none;
 }
+
+:-moz-native-anonymous .geometry-editor-handle {
+  stroke: #08c;
+  fill: white;
+  shape-rendering: crispEdges;
+  opacity: 0.6;
+  cursor: move;
+}
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -2022,19 +2022,19 @@ function GeometryEditorHighlighter(tabAc
   AutoRefreshHighlighter.call(this, tabActor);
 
   // The list of element geometry properties that can be set.
   this.definedProperties = new Map();
 
   this.markup = new CanvasFrameAnonymousContentHelper(tabActor,
     this._buildMarkup.bind(this));
 
-  this.onCurrentNodeMouseDown = this.onCurrentNodeMouseDown.bind(this);
-  this.onCurrentNodeMouseUp = this.onCurrentNodeMouseUp.bind(this);
-  this.onCurrentNodeMouseMove = this.onCurrentNodeMouseMove.bind(this);
+  this.onMouseDown = this.onMouseDown.bind(this);
+  this.onMouseUp = this.onMouseUp.bind(this);
+  this.onMouseMove = this.onMouseMove.bind(this);
 }
 
 GeometryEditorHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
   typeName: "GeometryEditorHighlighter",
 
   ID_CLASS_PREFIX: "geometry-editor-",
 
   _buildMarkup: function() {
@@ -2144,17 +2144,17 @@ GeometryEditorHighlighter.prototype = He
           "id": "label-text-" + name,
           "x": GeoProp.isHorizontal(name) ? "30" : "35",
           "y": "10"
         },
         prefix: this.ID_CLASS_PREFIX
       });
     }
 
-    // Build the width/height label and resize handle.
+    // Build the width/height label.
     let labelSizeG = createSVGNode(this.win, {
       nodeType: "g",
       parent: svg,
       attributes: {
         "id": "label-size",
         "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
@@ -2185,16 +2185,30 @@ GeometryEditorHighlighter.prototype = He
         "class": "label-text",
         "id": "label-text-size",
         "x": "50",
         "y": "10"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
+    // Build the resize handle.
+    createSVGNode(this.win, {
+      nodeType: "rect",
+      parent: svg,
+      attributes: {
+        "class": "handle",
+        "id": "resize-handle",
+        "width": "6",
+        "height": "6",
+        "transform": "translate(-3 -3)"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
     return container;
   },
 
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
     this.definedProperties.clear();
@@ -2291,18 +2305,25 @@ GeometryEditorHighlighter.prototype = He
     let hasUpdated = this._update();
     if (!hasUpdated) {
       this.hide();
     }
 
     // Make the current node movable if the defined properties allow it.
     if (this.hasAtLeastOneSide) {
       let box = this.getElement("current-node");
-      box.addEventListener("mousedown", this.onCurrentNodeMouseDown);
+      box.addEventListener("mousedown", this.onMouseDown);
+      box.setAttribute("movable", "");
     }
+
+    // Make the size handle movable, if the defined properties allow it.
+    if (this.hasAtLeastOneSize) {
+      let handle = this.getElement("resize-handle");
+      handle.addEventListener("mousedown", this.onMouseDown);
+     }
   },
 
   _update: function() {
     // At each update, the position or/and size may have changed, so get the
     // list of defined properties, and re-position the arrows and highlighters.
     this.definedProperties = this.getDefinedGeometryProperties();
 
     let isStatic = this.computedStyle.position === "static";
@@ -2401,19 +2422,25 @@ GeometryEditorHighlighter.prototype = He
     this.getElement("current-node").setAttribute("hidden", "true");
     this.getElement("offset-parent").setAttribute("hidden", "true");
     this.getElement("elements").setAttribute("hidden", "true");
     this.hideArrows();
     this.hideSize();
 
     if (this.hasAtLeastOneSide) {
       let box = this.getElement("current-node");
-      box.removeEventListener("mousedown", this.onCurrentNodeMouseDown);
+      box.removeEventListener("mousedown", this.onMouseDown);
+      box.removeAttribute("movable");
     }
 
+    if (this.hasAtLeastOneSize) {
+      let handle = this.getElement("resize-handle");
+      handle.removeEventListener("mousedown", this.onMouseDown);
+     }
+
     this.definedProperties.clear();
 
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   hideArrows: function() {
     for (let side of GeoProp.SIDES) {
       this.getElement("arrow-" + side).setAttribute("hidden", "true");
@@ -2437,24 +2464,30 @@ GeometryEditorHighlighter.prototype = He
     }
     if (height) {
       labels.push("↕ " + height.cssRule.style.getPropertyValue("height"));
     }
 
     if (labels.length) {
       let labelEl = this.getElement("label-size");
       let labelTextEl = this.getElement("label-text-size");
+      let handleEl = this.getElement("resize-handle");
 
       let {bounds} = this.currentQuads.margin;
 
+      // Update and position the label.
       labelEl.setAttribute("transform", "translate(" +
         (bounds.left + bounds.width/2) + " " +
         (bounds.top + bounds.height/2) + ")");
       labelEl.removeAttribute("hidden");
       labelTextEl.setTextContent(labels.join(" "));
+
+      // Position the resize handle.
+      handleEl.setAttribute("x", bounds.left + bounds.width);
+      handleEl.setAttribute("y", bounds.top + bounds.height);
     }
   },
 
   updateArrows: function() {
     this.hideArrows();
 
     // Position arrows always end at the node's margin box.
     let marginBox = this.currentQuads.margin.bounds;
@@ -2546,57 +2579,63 @@ GeometryEditorHighlighter.prototype = He
     let labelCross = crossPos;
     labelEl.setAttribute("transform", GeoProp.isHorizontal(side)
                          ? "translate(" + labelMain + " " + labelCross + ")"
                          : "translate(" + labelCross + " " + labelMain + ")");
     labelEl.removeAttribute("hidden");
     labelTextEl.setTextContent(labelValue);
   },
 
-  onCurrentNodeMouseDown: function(e) {
-    if (this.isMovingCurrentNode) {
+  onMouseDown: function(e, id) {
+    if (this.isMoving) {
       return;
     }
 
     let target = getPageListenerTarget(this.tabActor);
-    target.addEventListener("mouseup", this.onCurrentNodeMouseUp);
-    target.addEventListener("mousemove", this.onCurrentNodeMouseMove);
-
-    this.nodeStartPos = {x: e.clientX, y: e.clientY};
-    this.isMovingCurrentNode = true;
+    target.addEventListener("mouseup", this.onMouseUp);
+    target.addEventListener("mousemove", this.onMouseMove);
+
+    this.moveStartPos = {x: e.clientX, y: e.clientY};
+    this.movingElement = id;
+    this.isMoving = true;
+    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "root", "moving", "");
   },
 
-  onCurrentNodeMouseUp: function(e) {
-    if (!this.isMovingCurrentNode) {
+  onMouseUp: function(e) {
+    if (!this.isMoving) {
       return;
     }
 
     let target = getPageListenerTarget(this.tabActor);
-    target.removeEventListener("mouseup", this.onCurrentNodeMouseUp);
-    target.removeEventListener("mousemove", this.onCurrentNodeMouseMove);
-
-    this.isMovingCurrentNode = false;
+    target.removeEventListener("mouseup", this.onMouseUp);
+    target.removeEventListener("mousemove", this.onMouseMove);
+
+    this.movingElement = null;
+    this.isMoving = false;
+    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "root", "moving");
   },
 
-  onCurrentNodeMouseMove: function(e) {
-    if (!this.isMovingCurrentNode) {
+  onMouseMove: function(e) {
+    if (!this.isMoving) {
       return;
     }
 
     let delta = {
-      x: e.clientX - this.nodeStartPos.x,
-      y: e.clientY - this.nodeStartPos.y
+      x: e.clientX - this.moveStartPos.x,
+      y: e.clientY - this.moveStartPos.y
     };
 
-    // Decide how to move the node depending on which properties are set.
-    for (let side of GeoProp.SIDES) {
-      this.updateProperty(side, delta);
+    let props = this.movingElement.contains("resize-handle")
+                ? GeoProp.SIZES
+                : GeoProp.SIDES;
+    for (let prop of props) {
+      this.updateProperty(prop, delta);
     }
 
-    this.nodeStartPos = {x: e.clientX, y: e.clientY};
+    this.moveStartPos = {x: e.clientX, y: e.clientY};
   },
 
   updateProperty: function(name, delta={x:0, y:0}) {
     let prop = this.definedProperties.get(name);
     if (!prop) {
       return;
     }
 
