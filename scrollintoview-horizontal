# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  b026164d4ceaffd62f0dfe8422e8373bb2797c16
Bug 1127423 - Don't scroll horizontally when selecting an element in markup view;r=pbrosset

diff --git a/browser/devtools/shared/test/browser_layoutHelpers.js b/browser/devtools/shared/test/browser_layoutHelpers.js
--- a/browser/devtools/shared/test/browser_layoutHelpers.js
+++ b/browser/devtools/shared/test/browser_layoutHelpers.js
@@ -1,101 +1,115 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that scrollIntoViewIfNeeded works properly.
+let {LayoutHelpers} = Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm", {});
 
-let imported = {};
-Components.utils.import("resource://gre/modules/devtools/LayoutHelpers.jsm",
-    imported);
-registerCleanupFunction(function () {
-  imported = {};
-});
-
-let LayoutHelpers = imported.LayoutHelpers;
 
 const TEST_URI = TEST_URI_ROOT + "browser_layoutHelpers.html";
 
-function test() {
-  addTab(TEST_URI, function(browser, tab) {
-    info("Starting browser_layoutHelpers.js");
-    let doc = browser.contentDocument;
-    runTest(doc.defaultView, doc.getElementById('some'));
-    gBrowser.removeCurrentTab();
-    finish();
-  });
-}
+add_task(function*() {
+  let browser = yield promiseTab(TEST_URI);
+  let doc = browser.contentDocument;
+  yield runTest(doc.defaultView);
+  gBrowser.removeCurrentTab();
+});
 
-function runTest(win, some) {
+function runTest(win) {
   let lh = new LayoutHelpers(win);
+  let some = win.document.getElementById('some');
 
   some.style.top = win.innerHeight + 'px';
   some.style.left = win.innerWidth + 'px';
   // The tests start with a black 2x2 pixels square below bottom right.
   // Do not resize the window during the tests.
 
   win.scroll(win.innerWidth / 2, win.innerHeight + 2);  // Above the viewport.
   lh.scrollIntoViewIfNeeded(some);
   is(win.scrollY, Math.floor(win.innerHeight / 2) + 1,
      'Element completely hidden above should appear centered.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   win.scroll(win.innerWidth / 2, win.innerHeight + 1);  // On the top edge.
   lh.scrollIntoViewIfNeeded(some);
   is(win.scrollY, win.innerHeight,
      'Element partially visible above should appear above.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   win.scroll(win.innerWidth / 2, 0);  // Just below the viewport.
   lh.scrollIntoViewIfNeeded(some);
   is(win.scrollY, Math.floor(win.innerHeight / 2) + 1,
      'Element completely hidden below should appear centered.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   win.scroll(win.innerWidth / 2, 1);  // On the bottom edge.
   lh.scrollIntoViewIfNeeded(some);
   is(win.scrollY, 2,
      'Element partially visible below should appear below.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
 
   win.scroll(win.innerWidth / 2, win.innerHeight + 2);  // Above the viewport.
   lh.scrollIntoViewIfNeeded(some, false);
   is(win.scrollY, win.innerHeight,
      'Element completely hidden above should appear above ' +
      'if parameter is false.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   win.scroll(win.innerWidth / 2, win.innerHeight + 1);  // On the top edge.
   lh.scrollIntoViewIfNeeded(some, false);
   is(win.scrollY, win.innerHeight,
      'Element partially visible above should appear above ' +
      'if parameter is false.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   win.scroll(win.innerWidth / 2, 0);  // Below the viewport.
   lh.scrollIntoViewIfNeeded(some, false);
   is(win.scrollY, 2,
      'Element completely hidden below should appear below ' +
      'if parameter is false.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   win.scroll(win.innerWidth / 2, 1);  // On the bottom edge.
   lh.scrollIntoViewIfNeeded(some, false);
   is(win.scrollY, 2,
      'Element partially visible below should appear below ' +
      'if parameter is false.');
+  is(win.scrollX, win.innerWidth / 2,
+     'scrollX position has not changed.');
 
   // The case of iframes.
   win.scroll(0, 0);
 
+  let def = promise.defer();
   let frame = win.document.getElementById('frame');
   let fwin = frame.contentWindow;
 
   frame.style.top = win.innerHeight + 'px';
   frame.style.left = win.innerWidth + 'px';
+// console.log("foo", DOMHelpers);
+  // let domHelper = new DOMHelpers(fwin);
+  // domHelper.onceDOMReady(() => {
+    some = fwin.document.getElementById('some');
+    lh.scrollIntoViewIfNeeded(some);
+    is(win.scrollX, 0,
+       'Scrolling from an iframe should not change scrollX position.');
+    is(win.scrollY, Math.floor(win.innerHeight / 2) + 20,
+       'Scrolling from an iframe should center the iframe vertically.');
+    is(fwin.scrollX, 0,
+       'Scrolling from an iframe should not change scrollX position for frame window.');
+    is(fwin.scrollY, Math.floor(fwin.innerHeight / 2) + 1,
+       'Scrolling from an iframe should center the element vertically.');
+    def.resolve();
+  // });
+  // fwin.addEventListener('load', function frameLoad() {
+  // }, false);
 
-  fwin.addEventListener('load', function frameLoad() {
-    let some = fwin.document.getElementById('some');
-    lh.scrollIntoViewIfNeeded(some);
-    is(win.scrollX, Math.floor(win.innerWidth / 2) + 20,
-       'Scrolling from an iframe should center the iframe vertically.');
-    is(win.scrollY, Math.floor(win.innerHeight / 2) + 20,
-       'Scrolling from an iframe should center the iframe horizontally.');
-    is(fwin.scrollX, Math.floor(fwin.innerWidth / 2) + 1,
-       'Scrolling from an iframe should center the element vertically.');
-    is(fwin.scrollY, Math.floor(fwin.innerHeight / 2) + 1,
-       'Scrolling from an iframe should center the element horizontally.');
-  }, false);
+  return def.promise;
 }
diff --git a/browser/devtools/shared/test/head.js b/browser/devtools/shared/test/head.js
--- a/browser/devtools/shared/test/head.js
+++ b/browser/devtools/shared/test/head.js
@@ -3,16 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 let {TargetFactory, require} = devtools;
 let {console} = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 let {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {DOMHelpers} = Cu.import("resource:///modules/devtools/DOMHelpers.jsm", {});
 const {Hosts} = require("devtools/framework/toolbox-hosts");
+const { Promise: promise } = Cu.import("resource://gre/modules/Promise.jsm", {});
 
 gDevTools.testing = true;
 SimpleTest.registerCleanupFunction(() => {
   gDevTools.testing = false;
 });
 
 const TEST_URI_ROOT = "http://example.com/browser/browser/devtools/shared/test/";
 const OPTIONS_VIEW_URL = TEST_URI_ROOT + "doc_options-view.xul";
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -207,86 +207,63 @@ LayoutHelpers.prototype = {
           node = subnode;
         }
       }
     }
     return node;
   },
 
   /**
-   * Scroll the document so that the element "elem" appears in the viewport.
+   * Scroll the document so that the element "elem" appears vertically the viewport.
    *
    * @param {DOMNode} elem
    *        The element that needs to appear in the viewport.
    * @param {Boolean} centered
    *        true if you want it centered, false if you want it to appear on the
    *        top of the viewport. It is true by default, and that is usually what
    *        you want.
    */
   scrollIntoViewIfNeeded: function(elem, centered) {
     // We want to default to centering the element in the page,
     // so as to keep the context of the element.
-    centered = centered === undefined? true: !!centered;
+    centered = centered === undefined ? true: !!centered;
 
     let win = elem.ownerDocument.defaultView;
     let clientRect = elem.getBoundingClientRect();
 
-    // The following are always from the {top, bottom, left, right}
+    // The following are always from the {top, bottom}
     // of the viewport, to the {top, â€¦} of the box.
     // Think of them as geometrical vectors, it helps.
     // The origin is at the top left.
 
     let topToBottom = clientRect.bottom;
     let bottomToTop = clientRect.top - win.innerHeight;
-    let leftToRight = clientRect.right;
-    let rightToLeft = clientRect.left - win.innerWidth;
-    let xAllowed = true;  // We allow one translation on the x axis,
-    let yAllowed = true;  // and one on the y axis.
+    let yAllowed = true;  // We allow one translation on the y axis.
 
     // Whatever `centered` is, the behavior is the same if the box is
     // (even partially) visible.
 
     if ((topToBottom > 0 || !centered) && topToBottom <= elem.offsetHeight) {
       win.scrollBy(0, topToBottom - elem.offsetHeight);
       yAllowed = false;
     } else
     if ((bottomToTop < 0 || !centered) && bottomToTop >= -elem.offsetHeight) {
       win.scrollBy(0, bottomToTop + elem.offsetHeight);
       yAllowed = false;
     }
 
-    if ((leftToRight > 0 || !centered) && leftToRight <= elem.offsetWidth) {
-      if (xAllowed) {
-        win.scrollBy(leftToRight - elem.offsetWidth, 0);
-        xAllowed = false;
-      }
-    } else
-    if ((rightToLeft < 0 || !centered) && rightToLeft >= -elem.offsetWidth) {
-      if (xAllowed) {
-        win.scrollBy(rightToLeft + elem.offsetWidth, 0);
-        xAllowed = false;
-      }
-    }
-
     // If we want it centered, and the box is completely hidden,
     // then we center it explicitly.
 
     if (centered) {
-
       if (yAllowed && (topToBottom <= 0 || bottomToTop >= 0)) {
         win.scroll(win.scrollX,
                    win.scrollY + clientRect.top
                    - (win.innerHeight - elem.offsetHeight) / 2);
       }
-
-      if (xAllowed && (leftToRight <= 0 || rightToLeft <= 0)) {
-        win.scroll(win.scrollX + clientRect.left
-                   - (win.innerWidth - elem.offsetWidth) / 2,
-                   win.scrollY);
-      }
     }
 
     if (!this.isTopLevelWindow(win)) {
       // We are inside an iframe.
       let frameElement = this.getFrameElement(win);
       this.scrollIntoViewIfNeeded(frameElement, centered);
     }
   },
