# HG changeset patch
# Parent a55ae452715a5b2897a5c2837ad44d1c93add4e0
# User Brian Grinstead <bgrinstead@mozilla.com>
sadf

diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -11,16 +11,17 @@ const {Promise: promise} = Cu.import("re
 const {CssLogic} = require("devtools/styleinspector/css-logic");
 const {InplaceEditor, editableField, editableItem} = require("devtools/shared/inplace-editor");
 const {ELEMENT_STYLE, PSEUDO_ELEMENTS} = require("devtools/server/actors/styles");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {OutputParser} = require("devtools/output-parser");
 const {PrefObserver, PREF_ORIG_SOURCES} = require("devtools/styleeditor/utils");
 const {parseSingleValue, parseDeclarations} = require("devtools/styleinspector/css-parsing-utils");
 const overlays = require("devtools/styleinspector/style-inspector-overlays");
+let EventEmitter = require("devtools/toolkit/event-emitter");
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 const PREF_UA_STYLES = "devtools.inspector.showUserAgentStyles";
 const PREF_DEFAULT_COLOR_UNIT = "devtools.defaultColorUnit";
@@ -254,25 +255,25 @@ ElementStyle.prototype = {
     if (aOptions.system) {
       return false;
     }
 
     let rule = null;
 
     // If we're refreshing and the rule previously existed, reuse the
     // Rule object.
-    if (this._refreshRules) {
-      for (let r of this._refreshRules) {
-        if (r.matches(aOptions)) {
-          rule = r;
-          rule.refresh(aOptions);
-          break;
-        }
-      }
-    }
+    // if (this._refreshRules) {
+    //   for (let r of this._refreshRules) {
+    //     if (r.matches(aOptions)) {
+    //       rule = r;
+    //       rule.refresh(aOptions);
+    //       break;
+    //     }
+    //   }
+    // }
 
     // If this is a new rule, create its Rule object.
     if (!rule) {
       rule = new Rule(this, aOptions);
     }
 
     // Ignore inherited rules with no properties.
     if (aOptions.inherited && rule.textProps.length == 0) {
@@ -409,16 +410,17 @@ ElementStyle.prototype = {
  *        The information used to construct this rule.  Properties include:
  *          rule: A StyleRuleActor
  *          inherited: An element this rule was inherited from.  If omitted,
  *            the rule applies directly to the current element.
  *          isSystem: Is this a user agent style?
  * @constructor
  */
 function Rule(aElementStyle, aOptions) {
+  EventEmitter.decorate(this);
   this.elementStyle = aElementStyle;
   this.domRule = aOptions.rule || null;
   this.style = aOptions.rule;
   this.matchedSelectors = aOptions.matchedSelectors || [];
   this.pseudoElement = aOptions.pseudoElement || "";
 
   this.isSystem = aOptions.isSystem;
   this.inherited = aOptions.inherited || null;
@@ -608,17 +610,17 @@ Rule.prototype = {
     // Store disabled properties in the disabled store.
     let disabled = this.elementStyle.store.disabled;
     if (disabledProps.length > 0) {
       disabled.set(this.style, disabledProps);
     } else {
       disabled.delete(this.style);
     }
 
-    let promise = aModifications.apply().then(() => {
+    aModifications.apply().then(() => {
       let cssProps = {};
       for (let cssProp of parseDeclarations(this.style.cssText)) {
         cssProps[cssProp.name] = cssProp;
       }
 
       for (let textProp of this.textProps) {
         if (!textProp.enabled) {
           continue;
@@ -633,25 +635,19 @@ Rule.prototype = {
           };
         }
 
         textProp.priority = cssProp.priority;
       }
 
       this.elementStyle.markOverriddenAll();
 
-      if (promise === this._applyingModifications) {
-        this._applyingModifications = null;
-      }
-
       this.elementStyle._changed();
+      this.emit("modifications-applied");
     }).then(null, promiseWarn);
-
-    this._applyingModifications = promise;
-    return promise;
   },
 
   /**
    * Renames a property.
    *
    * @param {TextProperty} aProperty
    *        The property to rename.
    * @param {string} aName
@@ -1402,17 +1398,17 @@ CssRuleView.prototype = {
 
     if (!client.traits.addNewRule) {
       return;
     }
 
     this.pageStyle.addNewRule(element).then(options => {
       let newRule = new Rule(elementStyle, options);
       rules.push(newRule);
-      let editor = new RuleEditor(this, newRule);
+      this.editor = new RuleEditor(this, newRule);
 
       // Insert the new rule editor after the inline element rule
       if (rules.length <= 1) {
         this.element.appendChild(editor.element);
       } else {
         for (let rule of rules) {
           if (rule.domRule.type === ELEMENT_STYLE) {
             let referenceElement = rule.editor.element.nextSibling;
diff --git a/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js b/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
--- a/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
+++ b/browser/devtools/styleinspector/test/browser_ruleview_edit-property-order.js
@@ -19,50 +19,50 @@ add_task(function*() {
   let elementStyle = view._elementStyle;
   let elementRule = elementStyle.rules[0];
 
   info("Checking rules insertion order and checking the applied style");
   let firstProp = elementRule.createProperty("background-color", "green", "");
   let secondProp = elementRule.createProperty("background-color", "blue", "");
   is(elementRule.textProps[0], firstProp, "Rules should be in addition order.");
   is(elementRule.textProps[1], secondProp, "Rules should be in addition order.");
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "blue", "Second property should have been used.");
 
   info("Removing the second property and checking the applied style again");
   secondProp.remove();
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "green", "After deleting second property, first should be used.");
 
   info("Creating a new second property and checking that the insertion order is still the same");
   secondProp = elementRule.createProperty("background-color", "blue", "");
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "blue", "New property should be used.");
   is(elementRule.textProps[0], firstProp, "Rules shouldn't have switched places.");
   is(elementRule.textProps[1], secondProp, "Rules shouldn't have switched places.");
 
   info("Disabling the second property and checking the applied style");
   secondProp.setEnabled(false);
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "green", "After disabling second property, first value should be used");
 
   info("Disabling the first property too and checking the applied style");
   firstProp.setEnabled(false);
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "", "After disabling both properties, value should be empty.");
 
   info("Re-enabling the second propertyt and checking the applied style");
   secondProp.setEnabled(true);
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "blue", "Value should be set correctly after re-enabling");
 
   info("Re-enabling the first property and checking the insertion order is still respected");
   firstProp.setEnabled(true);
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "blue", "Re-enabling an earlier property shouldn't make it override a later property.");
   is(elementRule.textProps[0], firstProp, "Rules shouldn't have switched places.");
   is(elementRule.textProps[1], secondProp, "Rules shouldn't have switched places.");
 
   info("Modifying the first property and checking the applied style");
   firstProp.setValue("purple", "");
-  yield elementRule._applyingModifications;
+  yield elementRule.once("modifications-applied")
   is(element.style.getPropertyValue("background-color"), "blue", "Modifying an earlier property shouldn't override a later property.");
 });
