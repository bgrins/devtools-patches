# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  1b93a25d0fe22bd10bae50eb705a25616f84477c
Testing some perf for bug 1288493

diff --git a/devtools/server/actors/source.js b/devtools/server/actors/source.js
--- a/devtools/server/actors/source.js
+++ b/devtools/server/actors/source.js
@@ -18,25 +18,30 @@ const { joinURI } = require("devtools/sh
 const promise = require("promise");
 const { defer, resolve, reject, all } = promise;
 const { sourceSpec } = require("devtools/shared/specs/source");
 
 loader.lazyRequireGetter(this, "SourceMapConsumer", "source-map", true);
 loader.lazyRequireGetter(this, "SourceMapGenerator", "source-map", true);
 loader.lazyRequireGetter(this, "mapURIToAddonID", "devtools/server/actors/utils/map-uri-to-addon-id");
 
+let introTypes = new WeakMap();
+
 function isEvalSource(source) {
-  let introType = source.introductionType;
-  // These are all the sources that are essentially eval-ed (either
-  // by calling eval or passing a string to one of these functions).
+  // Cache the result since accessing introductionType is slow
+  if (!introTypes.has(source)) {
+    introTypes.set(source, source.introductionType);
+  }
+  let introType = introTypes.get(source);
+
   return (introType === "eval" ||
-          introType === "Function" ||
-          introType === "eventHandler" ||
-          introType === "setTimeout" ||
-          introType === "setInterval");
+           introType === "Function" ||
+           introType === "eventHandler" ||
+           introType === "setTimeout" ||
+           introType === "setInterval");
 }
 
 exports.isEvalSource = isEvalSource;
 
 function getSourceURL(source, window) {
   if (isEvalSource(source)) {
     // Eval sources have no urls, but they might have a `displayURL`
     // created with the sourceURL pragma. If the introduction script
@@ -147,16 +152,17 @@ let SourceActor = ActorClassWithSpec(sou
   initialize: function ({ source, thread, originalUrl, generatedSource,
                           isInlineSource, contentType }) {
     this._threadActor = thread;
     this._originalUrl = originalUrl;
     this._source = source;
     this._generatedSource = generatedSource;
     this._contentType = contentType;
     this._isInlineSource = isInlineSource;
+    this._isEvalSource = isEvalSource(this._source);
 
     this.onSource = this.onSource.bind(this);
     this._invertSourceMap = this._invertSourceMap.bind(this);
     this._encodeAndSetSourceMapURL = this._encodeAndSetSourceMapURL.bind(this);
     this._getSourceText = this._getSourceText.bind(this);
 
     this._mapSourceToAddon();
 
@@ -206,28 +212,33 @@ let SourceActor = ActorClassWithSpec(sou
     // This might not have a source or a generatedSource because we
     // treat HTML pages with inline scripts as a special SourceActor
     // that doesn't have either
     let introductionUrl = null;
     if (source && source.introductionScript) {
       introductionUrl = source.introductionScript.source.url;
     }
 
+    if (source && !introTypes.has(source)) {
+      introTypes.set(source, source.introductionType);
+    }
+    let introType = introTypes.get(source);
+
     return {
       actor: this.actorID,
       generatedUrl: this.generatedSource ? this.generatedSource.url : null,
       url: this.url ? this.url.split(" -> ").pop() : null,
       addonID: this._addonID,
       addonPath: this._addonPath,
       isBlackBoxed: this.threadActor.sources.isBlackBoxed(this.url),
       isPrettyPrinted: this.threadActor.sources.isPrettyPrinted(this.url),
       isSourceMapped: this.isSourceMapped,
       sourceMapURL: source ? source.sourceMapURL : null,
       introductionUrl: introductionUrl ? introductionUrl.split(" -> ").pop() : null,
-      introductionType: source ? source.introductionType : null
+      introductionType: source ? introType : null
     };
   },
 
   disconnect: function () {
     if (this.registeredPool && this.registeredPool.sourceActors) {
       delete this.registeredPool.sourceActors[this.actorID];
     }
   },
diff --git a/devtools/server/actors/utils/TabSources.js b/devtools/server/actors/utils/TabSources.js
--- a/devtools/server/actors/utils/TabSources.js
+++ b/devtools/server/actors/utils/TabSources.js
@@ -297,60 +297,57 @@ TabSources.prototype = {
     // have an API implemented to detect whether this is the case, we
     // need to be conservative and only treat valid js files as real
     // sources. Otherwise, use the `originalUrl` property to treat it
     // as an HTML source that manages multiple inline sources.
 
     // Assume the source is inline if the element that introduced it is not a
     // script element, or does not have a src attribute.
     let element = aSource.element ? aSource.element.unsafeDereference() : null;
-    if (element && (element.tagName !== "SCRIPT" || !element.hasAttribute("src"))) {
+    if (!url) {
+      // Assume the content is javascript if there's no URL
+      spec.contentType = "text/javascript";
+    } else if (element && (element.tagName !== "SCRIPT" || !element.hasAttribute("src"))) {
       spec.isInlineSource = true;
     } else if (aSource.introductionType === "wasm") {
       // Wasm sources are not JavaScript. Give them their own content-type.
       spec.contentType = "text/wasm";
     } else {
-      if (url) {
-        // There are a few special URLs that we know are JavaScript:
-        // inline `javascript:` and code coming from the console
-        if (url.indexOf("Scratchpad/") === 0 ||
-            url.indexOf("javascript:") === 0 ||
-            url === "debugger eval code") {
-          spec.contentType = "text/javascript";
-        } else {
-          try {
-            let pathname = new URL(url).pathname;
-            let filename = pathname.slice(pathname.lastIndexOf("/") + 1);
-            let index = filename.lastIndexOf(".");
-            let extension = index >= 0 ? filename.slice(index + 1) : "";
-            if (extension === "xml") {
-              // XUL inline scripts may not correctly have the
-              // `source.element` property, so do a blunt check here if
-              // it's an xml page.
-              spec.isInlineSource = true;
-            }
-            else if (extension === "js") {
-              spec.contentType = "text/javascript";
-            }
-          } catch (e) {
-            // This only needs to be here because URL is not yet exposed to
-            // workers. (BUG 1258892)
-            const filename = url;
-            const index = filename.lastIndexOf(".");
-            const extension = index >= 0 ? filename.slice(index + 1) : "";
-            if (extension === "js") {
-              spec.contentType = "text/javascript";
-            }
+      // There are a few special URLs that we know are JavaScript:
+      // inline `javascript:` and code coming from the console
+      if (url.indexOf("Scratchpad/") === 0 ||
+          url.indexOf("javascript:") === 0 ||
+          url === "debugger eval code") {
+        spec.contentType = "text/javascript";
+      } else {
+        try {
+          let pathname = new URL(url).pathname;
+          let filename = pathname.slice(pathname.lastIndexOf("/") + 1);
+          let index = filename.lastIndexOf(".");
+          let extension = index >= 0 ? filename.slice(index + 1) : "";
+          if (extension === "xml") {
+            // XUL inline scripts may not correctly have the
+            // `source.element` property, so do a blunt check here if
+            // it's an xml page.
+            spec.isInlineSource = true;
+          }
+          else if (extension === "js") {
+            spec.contentType = "text/javascript";
+          }
+        } catch (e) {
+          // This only needs to be here because URL is not yet exposed to
+          // workers. (BUG 1258892)
+          const filename = url;
+          const index = filename.lastIndexOf(".");
+          const extension = index >= 0 ? filename.slice(index + 1) : "";
+          if (extension === "js") {
+            spec.contentType = "text/javascript";
           }
         }
       }
-      else {
-        // Assume the content is javascript if there's no URL
-        spec.contentType = "text/javascript";
-      }
     }
 
     return this.source(spec);
   },
 
   /**
    * This is an internal function that returns a promise of an array
    * of source actors representing all the source mapped sources of
