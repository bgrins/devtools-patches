# HG changeset patch
# Parent  07de21c39b59dc49dd4eed5281aba4033e4f7bab
Bug 1455433 - Migrate <checkbox> to a Custom Element

diff --git a/browser/components/preferences/in-content/tests/browser_extension_controlled.js b/browser/components/preferences/in-content/tests/browser_extension_controlled.js
--- a/browser/components/preferences/in-content/tests/browser_extension_controlled.js
+++ b/browser/components/preferences/in-content/tests/browser_extension_controlled.js
@@ -751,18 +751,26 @@ add_task(async function testExtensionCon
           },
         }, "The user is notified that an extension is controlling proxy settings.");
       }
       function getProxyControls() {
         let controlGroup = doc.getElementById("networkProxyType");
         let manualControlContainer = controlGroup.querySelector("grid");
         return {
           manualControls: [
+<<<<<<< found
             ...manualControlContainer.querySelectorAll("label:not([control=networkProxyNone])"),
             ...manualControlContainer.querySelectorAll("textbox:not(#networkProxyNone)"),
+||||||| expected
+            ...manualControlContainer.querySelectorAll("label"),
+            ...manualControlContainer.querySelectorAll("textbox"),
+=======
+            ...manualControlContainer.querySelectorAll("label[data-l10n-id]"),
+            ...manualControlContainer.querySelectorAll("textbox"),
+>>>>>>> replacement
             ...manualControlContainer.querySelectorAll("checkbox"),
             ...doc.querySelectorAll("#networkProxySOCKSVersion > radio")],
           pacControls: [doc.getElementById("networkProxyAutoconfigURL")],
           otherControls: [
             doc.querySelector("label[control=networkProxyNone]"),
             doc.getElementById("networkProxyNone"),
             ...controlGroup.querySelectorAll(":scope > radio"),
             ...doc.querySelectorAll("#ConnectionsDialogPane > checkbox")],
diff --git a/toolkit/components/prompts/test/chromeScript.js b/toolkit/components/prompts/test/chromeScript.js
--- a/toolkit/components/prompts/test/chromeScript.js
+++ b/toolkit/components/prompts/test/chromeScript.js
@@ -160,17 +160,17 @@ function dismissSelect(ui, action) {
   } else if (action.buttonClick == "cancel") {
       dialog.cancelDialog();
   }
 }
 
 function dismissPrompt(ui, action) {
   if (action.setCheckbox) {
     // Annoyingly, the prompt code is driven by oncommand.
-    ui.checkbox.setChecked(true);
+    ui.checkbox.checked = true;
     ui.checkbox.doCommand();
   }
 
   if ("textField" in action) {
     ui.loginTextbox.setAttribute("value", action.textField);
   }
 
   if ("passField" in action) {
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -479,31 +479,78 @@ const BaseTextMixin = Base => class exte
   }
 
   get accessKey() {
     return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
   }
 };
 MozElements.BaseText = BaseTextMixin(MozXULElement);
 
+
+class MozBaseTextControl extends MozElements.BaseControl {
+  constructor() {
+    super();
+    this.labelElement = null;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+  set label(val) {
+    this.setAttribute("label", val);
+  }
+
+  get image() {
+    return this.getAttribute("image");
+  }
+  set image(val) {
+    this.setAttribute("image", val);
+  }
+
+  get command() {
+    return this.getAttribute("command");
+  }
+  set command(val) {
+    this.setAttribute("command", val);
+  }
+
+  get accessKey() {
+    return this.labelElement ?
+      this.labelElement.accessKey : this.getAttribute("accesskey");
+  }
+  set accessKey(val) {
+    // Always store on the control
+    this.setAttribute("accesskey", val);
+    // If there is a label, change the accesskey on the labelElement
+    // if it's also set there
+    if (this.labelElement) {
+      this.labelElement.accessKey = val;
+    }
+    return val;
+  }
+}
+
+
 // Attach the base class to the window so other scripts can use it:
 window.BaseControlMixin = BaseControlMixin;
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozElements = MozElements;
+window.MozBaseTextControl = MozBaseTextControl;
 
 customElements.setElementCreationCallback("browser", () => {
   Services.scriptloader.loadSubScript("chrome://global/content/elements/browser-custom-element.js", window);
 });
 
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
+    "chrome://global/content/elements/checkbox.js",
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/menu.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/popupnotification.js",
     "chrome://global/content/elements/radio.js",
     "chrome://global/content/elements/richlistbox.js",
     "chrome://global/content/elements/autocomplete-richlistitem.js",
     "chrome://global/content/elements/textbox.js",
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -59,17 +59,16 @@ toolkit.jar:
    content/global/treeUtils.js
 #ifndef MOZ_FENNEC
    content/global/viewZoomOverlay.js
 #endif
    content/global/widgets.css
    content/global/bindings/autocomplete.xml    (widgets/autocomplete.xml)
    content/global/bindings/button.xml          (widgets/button.xml)
    content/global/bindings/calendar.js         (widgets/calendar.js)
-   content/global/bindings/checkbox.xml        (widgets/checkbox.xml)
    content/global/bindings/datekeeper.js       (widgets/datekeeper.js)
    content/global/bindings/datepicker.js       (widgets/datepicker.js)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
 *  content/global/bindings/dialog.xml          (widgets/dialog.xml)
    content/global/bindings/general.xml         (widgets/general.xml)
    content/global/bindings/menu.xml            (widgets/menu.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
@@ -82,16 +81,17 @@ toolkit.jar:
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
    content/global/elements/autocomplete-richlistitem.js       (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
+   content/global/elements/checkbox.js         (widgets/checkbox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/menu.js             (widgets/menu.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
    content/global/elements/richlistbox.js      (widgets/richlistbox.js)
diff --git a/toolkit/content/widgets/checkbox.xml b/toolkit/content/widgets/checkbox.js
rename from toolkit/content/widgets/checkbox.xml
rename to toolkit/content/widgets/checkbox.js
--- a/toolkit/content/widgets/checkbox.xml
+++ b/toolkit/content/widgets/checkbox.js
@@ -1,62 +1,102 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
 
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+class MozCheckbox extends MozBaseTextControl {
+  constructor() {
+    super();
 
-<bindings id="checkboxBindings"
-   xmlns="http://www.mozilla.org/xbl"
-   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-   xmlns:xbl="http://www.mozilla.org/xbl">
+    // While it would seem we could do this by handling oncommand, we need can't
+    // because any external oncommand handlers might get called before ours, and
+    // then they would see the incorrect value of checked.
+    this.addEventListener("click", (event) => {
+      if (!this.disabled) {
+        this.checked = !this.checked;
+      }
+    });
+    this.addEventListener("keypress", (event) => {
+      if (event.key == " ") {
+        this.checked = !this.checked;
+        // Prevent page from scrolling on the space key.
+        event.preventDefault();
+      }
+    });
+  }
 
-  <binding id="checkbox"
-    extends="chrome://global/content/bindings/general.xml#basetext">
-    <content>
-      <xul:image class="checkbox-check" xbl:inherits="checked,disabled"/>
-      <xul:hbox class="checkbox-label-box" flex="1">
-        <xul:image class="checkbox-icon" xbl:inherits="src"/>
-        <xul:label class="checkbox-label" xbl:inherits="xbl:text=label,accesskey,crop" flex="1"/>
-      </xul:hbox>
-    </content>
+  static get observedAttributes() {
+    return [ "accesskey", "label", "src" ];
+  }
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (!this.isConnectedAndReady || oldValue == newValue) {
+      return;
+    }
+
+    for (let [ el, attr ] of this.attrMap) {
+      this.inheritAttribute(el, attr);
+    }
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
 
-    <implementation>
-      <method name="setChecked">
-        <parameter name="aValue"/>
-        <body>
-        <![CDATA[
-          var change = (aValue != (this.getAttribute("checked") == "true"));
-          if (aValue)
-            this.setAttribute("checked", "true");
-          else
-            this.removeAttribute("checked");
-          if (change) {
-            var event = document.createEvent("Events");
-            event.initEvent("CheckboxStateChange", true, true);
-            this.dispatchEvent(event);
-          }
-          return aValue;
-        ]]>
-        </body>
-      </method>
+    let content = `
+      <image class="checkbox-check"/>
+      <hbox class="checkbox-label-box" flex="1">
+        <image class="checkbox-icon"/>
+        <label class="checkbox-label" flex="1"/>
+      </hbox>
+    `;
+    let contentFragment = MozXULElement.parseXULToFragment(content);
+
+    // Set up |hostElement| before <label> is appended to the tree.
+    contentFragment.querySelector(".checkbox-label").hostElement = this;
+
+    this.textContent = "";
+    this.appendChild(contentFragment);
+
+    this.labelEl = this.querySelector(".checkbox-label");
+    this.iconEl = this.querySelector(".checkbox-icon");
+
+    this.attrMap = new Map([
+      [ this.labelEl, "accesskey" ],
+      [ this.labelEl, "text=label" ],
+      [ this.iconEl, "src" ]
+    ]);
 
-      <!-- public implementation -->
-      <property name="checked"    onset="return this.setChecked(val);"
-                                  onget="return this.getAttribute('checked') == 'true';"/>
-    </implementation>
+    for (let [ el, attr ] of this.attrMap) {
+      this.inheritAttribute(el, attr);
+    }
+  }
+
+  set checked(val) {
+    let change = (val != (this.getAttribute("checked") == "true"));
+    if (val) {
+      this.setAttribute("checked", "true");
+    } else {
+      this.removeAttribute("checked");
+    }
 
-    <handlers>
-      <!-- While it would seem we could do this by handling oncommand, we need can't
-           because any external oncommand handlers might get called before ours, and
-           then they would see the incorrect value of checked. -->
-      <handler event="click" button="0" action="if (!this.disabled) this.checked = !this.checked;"/>
-      <handler event="keypress" key=" ">
-        <![CDATA[
-          this.checked = !this.checked;
-          // Prevent page from scrolling on the space key.
-          event.preventDefault();
-        ]]>
-      </handler>
-    </handlers>
-  </binding>
+    if (change) {
+      let event = document.createEvent("Events");
+      event.initEvent("CheckboxStateChange", true, true);
+      this.dispatchEvent(event);
+    }
+    return val;
+  }
 
-</bindings>
+  get checked() {
+    return this.getAttribute("checked") == "true";
+  }
+}
+
+customElements.define("checkbox", MozCheckbox);
+
+}
diff --git a/toolkit/content/widgets/text.xml b/toolkit/content/widgets/text.xml
--- a/toolkit/content/widgets/text.xml
+++ b/toolkit/content/widgets/text.xml
@@ -19,21 +19,23 @@
           this.formatAccessKey(true);
         ]]>
       </constructor>
 
       <method name="formatAccessKey">
         <parameter name="firstTime"/>
         <body>
           <![CDATA[
-            var control = this.labeledControlElement;
+            let control = this.labeledControlElement;
             if (!control) {
-              var bindingParent = document.getBindingParent(this);
-              if ("accessKey" in bindingParent) {
-                control = bindingParent; // For controls that make the <label> an anon child
+              // Controls can have the <label> in XBL anon or explicit content.
+              let bindingParent =
+                document.getBindingParent(this) || this.hostElement;
+              if (bindingParent && ("accessKey" in bindingParent)) {
+                control = bindingParent;
               }
             }
             if (control) {
               control.labelElement = this;
               var controlAccessKey = control.getAttribute("accesskey");
               if (controlAccessKey) {
                 this.setAttribute("accesskey", controlAccessKey);
               }
@@ -212,16 +214,17 @@
             this.formatAccessKey(false);
             return val;
           ]]>
         </setter>
       </property>
 
       <property name="labeledControlElement" readonly="true"
                 onget="var control = this.control; return control ? document.getElementById(control) : null;" />
+      <field name="hostElement">null</field>
 
       <property name="control" onget="return this.getAttribute('control');">
         <setter>
           <![CDATA[
             var control = this.labeledControlElement;
             if (control) {
               control.labelElement = null; // No longer pointed to be this label
             }
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -176,22 +176,16 @@ iframe {
 popupnotification {
   -moz-box-orient: vertical;
 }
 
 .popup-notification-menubutton:not([label]) {
   display: none;
 }
 
-/********** checkbox **********/
-
-checkbox {
-  -moz-binding: url("chrome://global/content/bindings/checkbox.xml#checkbox");
-}
-
 /********** radio **********/
 
 radiogroup {
   -moz-box-orient: vertical;
 }
 
 radio {
   -moz-binding: url("chrome://global/content/bindings/radio.xml#radio");
diff --git a/toolkit/themes/linux/global/in-content/common.css b/toolkit/themes/linux/global/in-content/common.css
--- a/toolkit/themes/linux/global/in-content/common.css
+++ b/toolkit/themes/linux/global/in-content/common.css
@@ -28,17 +28,17 @@ xul|menulist {
 }
 
 xul|*.menulist-dropmarker {
   display: -moz-box;
   margin-top: 6px;
   margin-bottom: 6px;
 }
 
-xul|*.checkbox-check[checked],
+xul|checkbox[checked] > xul|*.checkbox-check,
 xul|*.radio-check[selected] {
   background-color: -moz-field;
   fill: -moz-fieldText;
 }
 
 xul|*.radio-label-box {
   -moz-appearance: none;
 }
diff --git a/toolkit/themes/osx/global/checkbox.css b/toolkit/themes/osx/global/checkbox.css
--- a/toolkit/themes/osx/global/checkbox.css
+++ b/toolkit/themes/osx/global/checkbox.css
@@ -30,10 +30,10 @@ checkbox[disabled="true"] {
   -moz-appearance: checkbox;
   margin: 1px 1px 0;
   /* vertical-align tells native theming where to snap to. However, this doesn't
    * always work reliably because of bug 503833. */
   vertical-align: top;
   width: 1.3em;
   height: 1.3em;
 }
-  
 
+
diff --git a/toolkit/themes/shared/in-content/common.inc.css b/toolkit/themes/shared/in-content/common.inc.css
--- a/toolkit/themes/shared/in-content/common.inc.css
+++ b/toolkit/themes/shared/in-content/common.inc.css
@@ -490,17 +490,17 @@ html|input[type="checkbox"] {
   background-repeat: no-repeat;
 }
 
 xul|checkbox:not([disabled="true"]):hover > xul|*.checkbox-check,
 html|input[type="checkbox"]:not(:disabled):hover {
   border-color: var(--in-content-border-focus);
 }
 
-xul|*.checkbox-check[checked] {
+xul|checkbox[checked] > xul|*.checkbox-check {
   list-style-image: url("chrome://global/skin/icons/check.svg");
   -moz-context-properties: fill;
   fill: #2292d0;
 }
 
 html|input[type="checkbox"]:checked {
   background-image: url("chrome://global/skin/icons/check.svg");
   -moz-context-properties: fill;
diff --git a/toolkit/themes/windows/global/in-content/common.css b/toolkit/themes/windows/global/in-content/common.css
--- a/toolkit/themes/windows/global/in-content/common.css
+++ b/toolkit/themes/windows/global/in-content/common.css
@@ -10,17 +10,17 @@ xul|*.menulist-dropmarker {
 }
 
 xul|checkbox,
 xul|radio {
   padding-inline-start: 0;
 }
 
 @media (-moz-windows-default-theme: 0) {
-  xul|*.checkbox-check[checked],
+  xul|checkbox[checked] > xul|*.checkbox-check,
   xul|*.radio-check[selected] {
     fill: -moz-fieldText;
     background-color: -moz-field;
   }
 }
 
 xul|menulist:-moz-focusring > xul|*.menulist-label-box {
   outline: none !important;
