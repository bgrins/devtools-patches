diff --git a/devtools/client/themes/webconsole.css b/devtools/client/themes/webconsole.css
--- a/devtools/client/themes/webconsole.css
+++ b/devtools/client/themes/webconsole.css
@@ -329,7 +329,7 @@
 
 .jsterm-input-node {
   box-sizing: border-box;
-  height: 100%;
+  min-height: 100%;
   color: var(--theme-content-color1);
   /* input icon */
   background-image: var(--theme-console-input-image);
diff --git a/devtools/client/webconsole/components/JSTerm.js b/devtools/client/webconsole/components/JSTerm.js
--- a/devtools/client/webconsole/components/JSTerm.js
+++ b/devtools/client/webconsole/components/JSTerm.js
@@ -143,7 +143,7 @@
       onSelect: this.onAutocompleteSelect.bind(this),
       onClick: this.acceptProposedCompletion.bind(this),
       listId: "webConsole_autocompletePopupListBox",
-      position: "top",
+      position: "bottom",
       autoSelect: true
     };
 
@@ -365,7 +365,7 @@
 
     // Update the character and chevron width needed for the popup offset calculations.
     this._inputCharWidth = this._getInputCharWidth();
-    this._chevronWidth = this.editor ? null : this._getChevronWidth();
+    this._paddingInlineStart = this.editor ? null : this._getInputPaddingInlineStart();
 
     this.hud.window.addEventListener("blur", this._blurEventHandler);
     this.lastInputValue && this.setInputValue(this.lastInputValue);
@@ -629,25 +629,27 @@
    * @returns void
    */
   resizeInput() {
-    if (this.props.codeMirrorEnabled) {
+    if (this.props.codeMirrorEnabled || !this.inputNode) {
       return;
     }
 
-    if (!this.inputNode) {
-      return;
-    }
-
-    const inputNode = this.inputNode;
+    const {inputNode, completeNode} = this;
 
     // Reset the height so that scrollHeight will reflect the natural height of
     // the contents of the input field.
     inputNode.style.height = "auto";
+    const minHeightBackup = inputNode.style.minHeight;
+    inputNode.style.minHeight = "unset";
+    completeNode.style.height = "auto";
 
     // Now resize the input field to fit its contents.
     const scrollHeight = inputNode.scrollHeight;
 
     if (scrollHeight > 0) {
-      inputNode.style.height = (scrollHeight + this.inputBorderSize) + "px";
+      const pxHeight = (scrollHeight + this.inputBorderSize) + "px";
+      inputNode.style.height = pxHeight;
+      inputNode.style.minHeight = minHeightBackup;
+      completeNode.style.height = pxHeight;
     }
   }
 
@@ -660,7 +662,7 @@
    *        The new value to set.
    * @returns void
    */
-  setInputValue(newValue = "") {
+  setInputValue(newValue = "", opts = {}) {
     if (this.props.codeMirrorEnabled) {
       if (this.editor) {
         // In order to get the autocomplete popup to work properly, we need to set the
@@ -689,7 +691,10 @@
     }
 
     this.lastInputValue = newValue;
-    this.resizeInput();
+    if (!opts.preventResizeInput) {
+      this.resizeInput();
+    }
+
     this.emit("set-input-value");
   }
 
@@ -1154,8 +1159,11 @@
         const offset = inputUntilCursor.length -
           (inputUntilCursor.lastIndexOf("\n") + 1) -
           lastPart.length;
-        xOffset = (offset * this._inputCharWidth) + this._chevronWidth;
-        popupAlignElement = this.inputNode;
+        xOffset = (offset * this._inputCharWidth) + this._paddingInlineStart;
+        // We use completeNode as the popup anchor as its height never exceeds the
+        // content size, whereas it can be the case for inputNode (when there's no message
+        // in the output, it takes the whole height).
+        popupAlignElement = this.completeNode;
       }
 
       if (popupAlignElement) {
@@ -1260,7 +1268,7 @@
     // We need to retrieve the cursor before setting the new value.
     const editorCursor = this.editor && this.editor.getCursor();
 
-    this.setInputValue(prefix + str + suffix);
+    this.setInputValue(prefix + str + suffix, {preventResizeInput: true});
 
     if (this.inputNode) {
       const newCursor = prefix.length + str.length;
@@ -1372,7 +1380,7 @@
     WebConsoleUtils.copyTextStyles(this.inputNode, tempLabel);
     tempLabel.textContent = "x";
     doc.documentElement.appendChild(tempLabel);
-    const width = tempLabel.offsetWidth;
+    const width = tempLabel.getBoundingClientRect().width;
     tempLabel.remove();
     return width;
   }
@@ -1383,17 +1391,16 @@
    *
    * @returns {Number|null}: Width of the icon, or null if the input does not exist.
    */
-  _getChevronWidth() {
+  _getInputPaddingInlineStart() {
     if (!this.inputNode) {
       return null;
     }
-
-   // Calculate the width of the chevron placed at the beginning of the input
-    // box. Remove 4 more pixels to accommodate the padding of the popup.
+   // Calculate the width of the chevron placed at the beginning of the input box.
     const doc = this.hud.document;
-    return doc.defaultView
+
+    return new Number(doc.defaultView
       .getComputedStyle(this.inputNode)
-      .paddingLeft.replace(/[^0-9.]/g, "") - 4;
+      .paddingInlineStart.replace(/[^0-9.]/g, ""));
   }
 
   onContextMenu(e) {
diff --git a/devtools/client/webconsole/test/mochitest/browser.ini b/devtools/client/webconsole/test/mochitest/browser.ini
--- a/devtools/client/webconsole/test/mochitest/browser.ini
+++ b/devtools/client/webconsole/test/mochitest/browser.ini
@@ -182,6 +182,7 @@
 [browser_console_webconsole_private_browsing.js]
 [browser_jsterm_accessibility.js]
 [browser_jsterm_add_edited_input_to_history.js]
+[browser_jsterm_autocomplete_accept_no_scroll.js]
 [browser_jsterm_autocomplete_array_no_index.js]
 [browser_jsterm_autocomplete_arrow_keys.js]
 [browser_jsterm_autocomplete_cached_results.js]
diff --git a/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_accept_no_scroll.js b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_accept_no_scroll.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webconsole/test/mochitest/browser_jsterm_autocomplete_accept_no_scroll.js
@@ -0,0 +1,52 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the accepting an autocompletion does not scroll the input.
+
+const TEST_URI = `data:text/html;charset=utf-8,
+  <script>
+    /* Create a prototype-less object so popup does not contain native
+     * Object prototype properties.
+     */
+    window.foobar = Object.create(null, Object.getOwnPropertyDescriptors({
+      item0: "value0",
+      item1: "value1",
+    }));
+  </script>`;
+
+add_task(async function() {
+  // Only run test with legacy JsTerm.
+  await pushPref("devtools.webconsole.jsterm.codeMirror", false);
+
+  const { jsterm, ui } = await openNewTabAndConsole(TEST_URI);
+  const { autocompletePopup: popup } = jsterm;
+
+  info("Insert multiple new lines so the input overflows");
+  const onPopUpOpen = popup.once("popup-opened");
+  const lines = "\n".repeat(200);
+  jsterm.setInputValue(lines);
+
+  info("Fire the autocompletion popup");
+  EventUtils.sendString("window.foobar.");
+
+  await onPopUpOpen;
+
+  const inputContainer = ui.window.document.querySelector(".jsterm-input-container");
+  ok(inputContainer.scrollTop > 0, "The input overflows");
+  const scrollTop = inputContainer.scrollTop;
+
+  info("Hit Enter to accept the autocompletion");
+  const onPopupClose = popup.once("popup-closed");
+  EventUtils.synthesizeKey("KEY_Enter");
+  await onPopupClose;
+
+  ok(!popup.isOpen, "popup is not open after KEY_Enter");
+  is(jsterm.getInputValue(), lines + "window.foobar.item0",
+    "completion was successful after KEY_Enter");
+  is(inputContainer.scrollTop, scrollTop,
+    "The scrolling position stayed the same when accepting the completion");
+});

