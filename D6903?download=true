# HG changeset patch
# Parent  48cc597db296ea5234a96321e2ce0c52094cc254

diff --git a/devtools/client/debugger/new/dist/parser-worker.js b/devtools/client/debugger/new/dist/parser-worker.js
--- a/devtools/client/debugger/new/dist/parser-worker.js
+++ b/devtools/client/debugger/new/dist/parser-worker.js
@@ -46772,17 +46772,17 @@ function wrapExpression(ast) {
   const newAst = t.arrowFunctionExpression([], t.blockStatement(body), true);
   return (0, _generator2.default)(newAst).code;
 }
 
 function mapTopLevelAwait(expression) {
   const ast = hasTopLevelAwait(expression);
   if (ast) {
     const func = wrapExpression(ast);
-    return (0, _generator2.default)(_template2.default.ast(`(${func})().then(console.log).catch(console.error);`)).code;
+    return (0, _generator2.default)(_template2.default.ast(`(${func})();`)).code;
   }
 
   return expression;
 }
 
 /***/ }),
 
 /***/ 3779:
diff --git a/devtools/client/webconsole/components/JSTerm.js b/devtools/client/webconsole/components/JSTerm.js
--- a/devtools/client/webconsole/components/JSTerm.js
+++ b/devtools/client/webconsole/components/JSTerm.js
@@ -425,38 +425,33 @@ class JSTerm extends Component {
   }
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
    * @param {Object} response
    *        The message received from the server.
-   * @param {Object} options
-   *        On options object that can contain the following properties:
-   *          - {Object} mapped: An object indicating if the input was modified by the
-   *                             parser worker.
    */
-  async _executeResultCallback(response, options = {}) {
+  async _executeResultCallback(response) {
     if (!this.hud) {
       return null;
     }
 
-    // If the expression was a top-level await that the parser-worker transformed, we
-    // don't want to show the result returned by the server as it's a Promise that was
-    // created on our end by wrapping the input in an instantly called async function
-    // (e.g. `await 42` -> `(async () => {return await 42})()`).
-    if (options && options.mapped && options.mapped.await) {
-      return null;
-    }
-
     if (response.error) {
       console.error("Evaluation error " + response.error + ": " + response.message);
       return null;
     }
+
+    // If the evaluation was a top-level await expression that was rejected, there will
+    // be an uncaught exception reported, so we don't want need to print anything here.
+    if (response.topLevelAwaitRejected === true) {
+      return null;
+    }
+
     let errorMessage = response.exceptionMessage;
 
     // Wrap thrown strings in Error objects, so `throw "foo"` outputs "Error: foo"
     if (typeof response.exception === "string") {
       errorMessage = new Error(errorMessage).toString();
     }
     const result = response.result;
     const helperResult = response.helperResult;
@@ -566,26 +561,25 @@ class JSTerm extends Component {
       console.warn("Error when calling getMappedExpression", e);
     }
 
     executeString = mappedExpressionRes ? mappedExpressionRes.expression : executeString;
 
     const options = {
       frame: this.SELECTED_FRAME,
       selectedNodeActor,
+      mapped: mappedExpressionRes ? mappedExpressionRes.mapped : null
     };
 
     // Even if requestEvaluation rejects (because of webConsoleClient.evaluateJSAsync),
     // we still need to pass the error response to executeResultCallback.
     const onEvaluated = this.requestEvaluation(executeString, options)
       .then(res => res, res => res);
     const response = await onEvaluated;
-    return this._executeResultCallback(response, {
-      mapped: mappedExpressionRes ? mappedExpressionRes.mapped : null
-    });
+    return this._executeResultCallback(response);
   }
 
   /**
    * Request a JavaScript string evaluation from the server.
    *
    * @param string str
    *        String to execute.
    * @param object [options]
@@ -598,40 +592,38 @@ class JSTerm extends Component {
    *        the jsdebugger is paused, you can pick the stackframe to be used for
    *        evaluation. Use |this.SELECTED_FRAME| to always pick th;
    *        user-selected stackframe.
    *        If you do not provide a |frame| the string will be evaluated in the
    *        global content window.
    *        - selectedNodeActor: tells the NodeActor ID of the current selection
    *        in the Inspector, if such a selection exists. This is used by
    *        helper functions that can evaluate on the current selection.
+   *        - mapped: basically getMappedExpression().mapped. An object that indicates
+   *        which modifications were done to the input entered by the user.
    * @return object
    *         A promise object that is resolved when the server response is
    *         received.
    */
   requestEvaluation(str, options = {}) {
     // Send telemetry event. If we are in the browser toolbox we send -1 as the
     // toolbox session id.
     this.props.serviceContainer.recordTelemetryEvent("execute_js", {
       "lines": str.split(/\n/).length
     });
 
     let frameActor = null;
     if ("frame" in options) {
       frameActor = this.getFrameActor(options.frame);
     }
 
-    const evalOptions = {
-      bindObjectActor: options.bindObjectActor,
+    return this.webConsoleClient.evaluateJSAsync(str, null, {
       frameActor,
-      selectedNodeActor: options.selectedNodeActor,
-      selectedObjectActor: options.selectedObjectActor,
-    };
-
-    return this.webConsoleClient.evaluateJSAsync(str, null, evalOptions);
+      ...options,
+    });
   }
 
   /**
    * Copy the object/variable by invoking the server
    * which invokes the `copy(variable)` command and makes it
    * available in the clipboard
    * @param evalString - string which has the evaluation string to be copied
    * @param options - object - Options for evaluation
diff --git a/devtools/client/webconsole/reducers/messages.js b/devtools/client/webconsole/reducers/messages.js
--- a/devtools/client/webconsole/reducers/messages.js
+++ b/devtools/client/webconsole/reducers/messages.js
@@ -539,17 +539,17 @@ function getAllActorsInMessage(message) 
   const {
     parameters,
     messageText,
   } = message;
 
   const actors = [];
   if (Array.isArray(parameters)) {
     message.parameters.forEach(parameter => {
-      if (parameter.actor) {
+      if (parameter && parameter.actor) {
         actors.push(parameter.actor);
       }
     });
   }
 
   if (messageText && messageText.actor) {
     actors.push(messageText.actor);
   }
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -947,47 +947,59 @@ WebConsoleActor.prototype =
       from: this.actorID,
       resultID: resultID
     });
 
     // Then, execute the script that may pause.
     const response = this.evaluateJS(request);
     response.resultID = resultID;
 
-    this._waitForHelperResultAndSend(response).catch(e =>
+    this._waitForResultAndSend(response).catch(e =>
       DevToolsUtils.reportException(
         "evaluateJSAsync",
         Error(`Encountered error while waiting for Helper Result: ${e}`)
       )
     );
   },
 
   /**
-   * In order to have asynchronous commands such as screenshot, we have to be
-   * able to handle promises in the helper result. This method handles waiting
-   * for the promise, and then dispatching the result
-   *
+   * In order to have asynchronous commands (e.g. screenshot, top-level await, â€¦) ,
+   * we have to be able to handle promises. This method handles waiting for the promise,
+   * and then dispatching the result.
    *
    * @private
    * @param object response
    *         The response packet to send to with the unique id in the
-   *         `resultID` field, and potentially a promise in the helperResult
-   *         field.
+   *         `resultID` field, and potentially a promise in the `helperResult` or in the
+   *         `awaitResult` field.
    *
    * @return object
    *         The response packet to send to with the unique id in the
    *         `resultID` field, with a sanitized helperResult field.
    */
-  _waitForHelperResultAndSend: async function(response) {
+  _waitForResultAndSend: async function(response) {
     // Wait for asynchronous command completion before sending back the response
     if (
-      response.helperResult &&
-      typeof response.helperResult.then == "function"
+      response.helperResult && typeof response.helperResult.then == "function"
     ) {
       response.helperResult = await response.helperResult;
+    } else if (response.awaitResult && typeof response.awaitResult.then === "function") {
+      try {
+        const result = await response.awaitResult;
+        const dbgResult = this.makeDebuggeeValue(result);
+        // createValueGrip expect a debuggee value, while here we have access to the
+        // raw object. We need to call makeDebuggeeValue on it to make it work.
+        response.result = this.createValueGrip(dbgResult);
+      } catch (e) {
+        // The promise was rejected. We let the engine handle this as it will report a
+        // `uncaught exception` error.
+        response.topLevelAwaitRejected = true;
+      }
+      // Remove the promise from the response object.
+      delete response.awaitResult;
     }
 
     // Finally, send an unsolicited evaluationResult packet with
     // the normal return value
     this.conn.sendActorEvent(this.actorID, "evaluationResult", response);
   },
 
   /**
@@ -1005,31 +1017,42 @@ WebConsoleActor.prototype =
 
     const evalOptions = {
       bindObjectActor: request.bindObjectActor,
       frameActor: request.frameActor,
       url: request.url,
       selectedNodeActor: request.selectedNodeActor,
       selectedObjectActor: request.selectedObjectActor,
     };
+    const {mapped} = request;
 
     const evalInfo = evalWithDebugger(input, evalOptions, this);
     const evalResult = evalInfo.result;
     const helperResult = evalInfo.helperResult;
 
     let result, errorDocURL, errorMessage, errorNotes = null, errorGrip = null,
-      frame = null;
+      frame = null, awaitResult;
     if (evalResult) {
       if ("return" in evalResult) {
         result = evalResult.return;
+        if (
+          mapped &&
+          mapped.await &&
+          result &&
+          result.class === "Promise" &&
+          typeof result.unsafeDereference === "function"
+        ) {
+          try {
+            awaitResult = result.unsafeDereference();
+          } catch (e) {}
+        }
       } else if ("yield" in evalResult) {
         result = evalResult.yield;
       } else if ("throw" in evalResult) {
         const error = evalResult.throw;
-
         errorGrip = this.createValueGrip(error);
 
         errorMessage = String(error);
         if (typeof error === "object" && error !== null) {
           try {
             errorMessage = DevToolsUtils.callPropertyOnObject(error, "toString");
           } catch (e) {
             // If the debuggee is not allowed to access the "toString" property
@@ -1095,28 +1118,40 @@ WebConsoleActor.prototype =
           // ignored
         }
       }
     }
 
     // If a value is encountered that the debugger server doesn't support yet,
     // the console should remain functional.
     let resultGrip;
-    try {
-      resultGrip = this.createValueGrip(result);
-    } catch (e) {
-      errorMessage = e;
+    if (!awaitResult) {
+      try {
+        resultGrip = this.createValueGrip(result);
+      } catch (e) {
+        errorMessage = e;
+      }
     }
 
-    this._lastConsoleInputEvaluation = result;
+    if (!awaitResult) {
+      this._lastConsoleInputEvaluation = result;
+    } else {
+      // If we evaluated a top-level await expression, we want to assign its result to the
+      // _lastConsoleInputEvaluation only when the promise resolves, and only if it
+      // resolves.
+      awaitResult.then(res => {
+        this._lastConsoleInputEvaluation = this.makeDebuggeeValue(res);
+      });
+    }
 
     return {
       from: this.actorID,
       input: input,
       result: resultGrip,
+      awaitResult,
       timestamp: timestamp,
       exception: errorGrip,
       exceptionMessage: this._createStringGrip(errorMessage),
       exceptionDocURL: errorDocURL,
       frame,
       helperResult: helperResult,
       notes: errorNotes,
     };
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -313,16 +313,17 @@ WebConsoleClient.prototype = {
       to: this._actor,
       type: "evaluateJSAsync",
       text: string,
       bindObjectActor: options.bindObjectActor,
       frameActor: options.frameActor,
       url: options.url,
       selectedNodeActor: options.selectedNodeActor,
       selectedObjectActor: options.selectedObjectActor,
+      mapped: options.mapped,
     };
 
     return new Promise((resolve, reject) => {
       this._client.request(packet, response => {
         // Null check this in case the client has been detached while waiting
         // for a response.
         if (this.pendingEvaluationResults) {
           this.pendingEvaluationResults.set(response.resultID, resp => {
