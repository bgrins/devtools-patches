# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  e28e2921e6f4b5e51eefab0642962210a2d81391

diff --git a/browser/components/preferences/in-content/privacy.js b/browser/components/preferences/in-content/privacy.js
--- a/browser/components/preferences/in-content/privacy.js
+++ b/browser/components/preferences/in-content/privacy.js
@@ -546,16 +546,19 @@ var gPrivacyPane = {
     // attribute on our checkbox element before the XBL binding has had a chance to have
     // been re-applied to it.
     setTimeout(() => {
       browserPrivacyCategory.parentNode.insertBefore(siteDataGroup,
                                                      browserPrivacyCategory.nextSibling);
       browserPrivacyCategory.parentNode.insertBefore(trackingGroup,
                                                      browserPrivacyCategory.nextSibling);
 
+      // XXX: this causes double connectedCallback with CS
+
+
       // We do this after having moved the elements in the DOM above, in order to avoid
       // a race condition with this timeout handler reapplying the XBL bindings to the
       // elements in this subtree and the observe() method attempting to set the disabled
       // attribute on the site data controls.
       this.initSiteDataControls();
     }, 0);
   },
 
diff --git a/toolkit/content/widgets/radio.js b/toolkit/content/widgets/radio.js
--- a/toolkit/content/widgets/radio.js
+++ b/toolkit/content/widgets/radio.js
@@ -6,16 +6,17 @@
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
 class MozRadiogroup extends MozBaseControl {
   constructor() {
     super();
+    this._radioChildren = null;
 
     this.addEventListener("mousedown", (event) => {
       if (this.disabled)
         event.preventDefault();
     });
 
     /**
      * keyboard navigation  Here's how keyboard navigation works in radio groups on Windows:
@@ -107,35 +108,53 @@ class MozRadiogroup extends MozBaseContr
         return;
       }
       this.removeAttribute("focused");
       this.focusedItem = null;
     });
   }
 
   connectedCallback() {
-    this._radioChildren = null;
+    if (!this._childListObserver) {
+      // Callback function to execute when mutations are observed
+      var callback = function(mutationsList, observer) {
+        console.log("Got mutation");
+        for(var mutation of mutationsList) {
+          console.log(mutationsList);
+        }
+      };
+
+      // Create an observer instance linked to the callback function
+      this._childListObserver = new MutationObserver(callback);
+
+      // Start observing the target node for configured mutations
+      this._childListObserver.observe(this, { childList: true });
+    }
+
+    this._connecting = true;
 
     if (this.getAttribute("disabled") == "true")
       this.disabled = true;
 
     var children = this._getRadioChildren();
     var length = children.length;
     for (var i = 0; i < length; i++) {
       if (children[i].getAttribute("selected") == "true") {
         this.selectedIndex = i;
+        this._connecting = false;
         return;
       }
     }
 
     var value = this.value;
     if (value)
       this.value = value;
     else
       this.selectedIndex = 0;
+    this._connecting = false;
   }
 
   set value(val) {
     this.setAttribute("value", val);
     var children = this._getRadioChildren();
     for (var i = 0; i < children.length; i++) {
       if (String(children[i].value) == String(val)) {
         this.selectedItem = children[i];
@@ -309,25 +328,30 @@ class MozRadiogroup extends MozBaseContr
   _getRadioChildren() {
     if (this._radioChildren)
       return this._radioChildren;
 
     var radioChildren = [];
     var doc = this.ownerDocument;
 
     if (this.hasChildNodes()) {
+
+      // return this.querySelectorAll("radio");
       // Don't store the collected child nodes immediately,
       // collecting the child nodes could trigger constructors
       // which would blow away our list.
-
-      var iterator = doc.createTreeWalker(this,
-        NodeFilter.SHOW_ELEMENT,
-        this._filterRadioGroup);
-      while (iterator.nextNode())
-        radioChildren.push(iterator.currentNode);
+      // var d = Date.now();
+      // var iterator = doc.createTreeWalker(this,
+      //   NodeFilter.SHOW_ELEMENT,
+      //   this._filterRadioGroup);
+      // while (iterator.nextNode())
+      //   radioChildren.push(iterator.currentNode);
+      radioChildren = [...this.querySelectorAll("radio")];
+      // console.log(this, radioChildren.length, Date.now() - d);
+      // console.trace();
       return this._radioChildren = radioChildren;
     }
 
     // We don't have child nodes.
     const XUL_NS = "http://www.mozilla.org/keymaster/" +
       "gatekeeper/there.is.only.xul";
     var elems = doc.getElementsByAttribute("group", this.id);
     for (var i = 0; i < elems.length; i++) {
diff --git a/toolkit/content/widgets/radio.xml b/toolkit/content/widgets/radio.xml
--- a/toolkit/content/widgets/radio.xml
+++ b/toolkit/content/widgets/radio.xml
@@ -19,18 +19,21 @@
       </xul:hbox>
     </content>
 
     <implementation implements="nsIDOMXULSelectControlItemElement">
       <constructor>
         <![CDATA[
           // Just clear out the parent's cached list of radio children
           var control = this.control;
-          if (control)
+          if (control && !control._connectingd) {
+
+          //console.log("CALLING RADIO CONSTRUCTOR AND CLEATING OUT LIST", control);
             control._radioChildren = null;
+          }
         ]]>
       </constructor>
       <destructor>
         <![CDATA[
           if (!this.control)
             return;
 
           var radioList = this.control._radioChildren;
