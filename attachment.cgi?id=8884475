# HG changeset patch
# Parent  3bc57a243c8cef34660358431e9f7f4dde566b2e

diff --git a/browser/components/preferences/in-content-new/advanced.js b/browser/components/preferences/in-content-new/advanced.js
--- a/browser/components/preferences/in-content-new/advanced.js
+++ b/browser/components/preferences/in-content-new/advanced.js
@@ -5,16 +5,36 @@
 /* import-globals-from preferences.js */
 /* import-globals-from ../../../base/content/aboutDialog-appUpdater.js */
 
 // Load DownloadUtils module for convertByteUnits
 Components.utils.import("resource://gre/modules/DownloadUtils.jsm");
 Components.utils.import("resource://gre/modules/LoadContextInfo.jsm");
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 
+window.addEventListener("DOMContentLoaded", function() {
+  Preferences.addAll([
+    { id: "browser.preferences.advanced.selectedTabIndex", type: "int" },
+
+    // Update tab
+#ifdef MOZ_UPDATER
+    { id: "app.update.enabled", type: "bool" },
+    { id: "app.update.auto", type: "bool" },
+
+    { id: "app.update.disable_button.showUpdateHistory", type: "bool" },
+
+#ifdef MOZ_MAINTENANCE_SERVICE
+    { id: "app.update.service.enabled", type: "bool" },
+#endif
+#endif
+
+    { id: "browser.search.update", type: "bool" },
+  ]);
+}, { once: true, capture: true });
+
 var gAdvancedPane = {
   _inited: false,
 
   init() {
     function setEventListener(aId, aEventType, aCallback) {
       document.getElementById(aId)
               .addEventListener(aEventType, aCallback.bind(gAdvancedPane));
     }
@@ -114,18 +134,18 @@ var gAdvancedPane = {
    * Element           pref  value  locked  disabled
    * radiogroup        i     t/f    f       false
    *                   i     t/f    *t*     *true*
    *                   ii    t/f    f       false
    *                   ii    t/f    *t*     *true*
    */
   updateReadPrefs() {
     if (AppConstants.MOZ_UPDATER) {
-      var enabledPref = document.getElementById("app.update.enabled");
-      var autoPref = document.getElementById("app.update.auto");
+      var enabledPref = Preferences.get("app.update.enabled");
+      var autoPref = Preferences.get("app.update.auto");
       var radiogroup = document.getElementById("updateRadioGroup");
 
       if (!enabledPref.value)   // Don't care for autoPref.value in this case.
         radiogroup.value = "manual";    // 3. Never check for updates.
       else if (autoPref.value)  // enabledPref.value && autoPref.value
         radiogroup.value = "auto";      // 1. Automatically install updates
       else                      // enabledPref.value && !autoPref.value
         radiogroup.value = "checkOnly"; // 2. Check, but let me choose
@@ -159,18 +179,18 @@ var gAdvancedPane = {
     }
   },
 
   /**
    * Sets the pref values based on the selected item of the radiogroup.
    */
   updateWritePrefs() {
     if (AppConstants.MOZ_UPDATER) {
-      var enabledPref = document.getElementById("app.update.enabled");
-      var autoPref = document.getElementById("app.update.auto");
+      var enabledPref = Preferences.get("app.update.enabled");
+      var autoPref = Preferences.get("app.update.auto");
       var radiogroup = document.getElementById("updateRadioGroup");
       switch (radiogroup.value) {
         case "auto":      // 1. Automatically install updates for Desktop only
           enabledPref.value = true;
           autoPref.value = true;
           break;
         case "checkOnly": // 2. Check, but let me choose
           enabledPref.value = true;
diff --git a/browser/components/preferences/in-content-new/advanced.xhtml b/browser/components/preferences/in-content-new/advanced.xhtml
--- a/browser/components/preferences/in-content-new/advanced.xhtml
+++ b/browser/components/preferences/in-content-new/advanced.xhtml
@@ -6,46 +6,16 @@
 
 #ifdef MOZ_UPDATER
   <html:script  src="chrome://browser/content/aboutDialog-appUpdater.js"></html:script>
 #endif
 
 <html:script 
         src="chrome://browser/content/preferences/in-content-new/advanced.js"></html:script>
 
-<preferences id="advancedPreferences" hidden="true" data-category="paneAdvanced">
-  <preference id="browser.preferences.advanced.selectedTabIndex"
-              name="browser.preferences.advanced.selectedTabIndex"
-              type="int"/>
-
-<!-- Update tab -->
-#ifdef MOZ_UPDATER
-  <preference id="app.update.enabled"
-              name="app.update.enabled"
-              type="bool"/>
-  <preference id="app.update.auto"
-              name="app.update.auto"
-              type="bool"/>
-
-  <preference id="app.update.disable_button.showUpdateHistory"
-              name="app.update.disable_button.showUpdateHistory"
-              type="bool"/>
-
-#ifdef MOZ_MAINTENANCE_SERVICE
-  <preference id="app.update.service.enabled"
-              name="app.update.service.enabled"
-              type="bool"/>
-#endif
-#endif
-
-  <preference id="browser.search.update"
-              name="browser.search.update"
-              type="bool"/>
-</preferences>
-
 #ifdef HAVE_SHELL_SERVICE
   <stringbundle id="bundleShell" src="chrome://browser/locale/shellservice.properties"/>
   <stringbundle id="bundleBrand" src="chrome://branding/locale/brand.properties"/>
 #endif
 
 <hbox id="header-advanced"
       class="header"
       hidden="true"
diff --git a/browser/components/preferences/in-content-new/applications.js b/browser/components/preferences/in-content-new/applications.js
--- a/browser/components/preferences/in-content-new/applications.js
+++ b/browser/components/preferences/in-content-new/applications.js
@@ -73,16 +73,39 @@ const kActionUsePlugin = 5;
 const ICON_URL_APP = AppConstants.platform == "linux" ?
                      "moz-icon://dummy.exe?size=16" :
                      "chrome://browser/skin/preferences/application.png";
 
 // For CSS. Can be one of "ask", "save", "plugin" or "feed". If absent, the icon URL
 // was set by us to a custom handler icon and CSS should not try to override it.
 const APP_ICON_ATTR_NAME = "appHandlerIcon";
 
+// Preferences object
+
+window.addEventListener("DOMContentLoaded", function() {
+  Preferences.addAll([
+    { id: "browser.feeds.handler", type: "string" },
+    { id: "browser.feeds.handler.default", type: "string" },
+    { id: "browser.feeds.handlers.application", type: "file" },
+    { id: "browser.feeds.handlers.webservice", type: "string" },
+
+    { id: "browser.videoFeeds.handler", type: "string" },
+    { id: "browser.videoFeeds.handler.default", type: "string" },
+    { id: "browser.videoFeeds.handlers.application", type: "file" },
+    { id: "browser.videoFeeds.handlers.webservice", type: "string" },
+
+    { id: "browser.audioFeeds.handler", type: "string" },
+    { id: "browser.audioFeeds.handler.default", type: "string" },
+    { id: "browser.audioFeeds.handlers.application", type: "file" },
+    { id: "browser.audioFeeds.handlers.webservice", type: "string" },
+
+    { id: "pref.downloads.disable_button.edit_actions", type: "bool" },
+  ]);
+}, { once: true, capture: true });
+
 // Utilities
 
 function getFileDisplayName(file) {
   if (AppConstants.platform == "win") {
     if (file instanceof Ci.nsILocalFileWin) {
       try {
         return file.getVersionInfoField("FileDescription");
       } catch (e) {}
@@ -474,46 +497,46 @@ FeedHandlerInfo.prototype = {
 
   // nsIHandlerInfo
 
   get description() {
     return this.element("bundlePreferences").getString(this._appPrefLabel);
   },
 
   get preferredApplicationHandler() {
-    switch (this.element(this._prefSelectedReader).value) {
+    switch (Preferences.get(this._prefSelectedReader).value) {
       case "client":
-        var file = this.element(this._prefSelectedApp).value;
+        var file = Preferences.get(this._prefSelectedApp).value;
         if (file)
           return getLocalHandlerApp(file);
 
         return null;
 
       case "web":
-        var uri = this.element(this._prefSelectedWeb).value;
+        var uri = Preferences.get(this._prefSelectedWeb).value;
         if (!uri)
           return null;
         return this._converterSvc.getWebContentHandlerByURI(this.type, uri);
 
       case "bookmarks":
       default:
         // When the pref is set to bookmarks, we handle feeds internally,
         // we don't forward them to a local or web handler app, so there is
         // no preferred handler.
         return null;
     }
   },
 
   set preferredApplicationHandler(aNewValue) {
     if (aNewValue instanceof Ci.nsILocalHandlerApp) {
-      this.element(this._prefSelectedApp).value = aNewValue.executable;
-      this.element(this._prefSelectedReader).value = "client";
+      Preferences.get(this._prefSelectedApp).value = aNewValue.executable;
+      Preferences.get(this._prefSelectedReader).value = "client";
     } else if (aNewValue instanceof Ci.nsIWebContentHandlerInfo) {
-      this.element(this._prefSelectedWeb).value = aNewValue.uri;
-      this.element(this._prefSelectedReader).value = "web";
+      Preferences.get(this._prefSelectedWeb).value = aNewValue.uri;
+      Preferences.get(this._prefSelectedReader).value = "web";
       // Make the web handler be the new "auto handler" for feeds.
       // Note: we don't have to unregister the auto handler when the user picks
       // a non-web handler (local app, Live Bookmarks, etc.) because the service
       // only uses the "auto handler" when the selected reader is a web handler.
       // We also don't have to unregister it when the user turns on "always ask"
       // (i.e. preview in browser), since that also overrides the auto handler.
       this._converterSvc.setAutoHandler(this.type, aNewValue);
     }
@@ -563,17 +586,17 @@ FeedHandlerInfo.prototype = {
     };
 
     // Add the selected local app if it's different from the OS default handler.
     // Unlike for other types, we can store only one local app at a time for the
     // feed type, since we store it in a preference that historically stores
     // only a single path.  But we display all the local apps the user chooses
     // while the prefpane is open, only dropping the list when the user closes
     // the prefpane, for maximum usability and consistency with other types.
-    var preferredAppFile = this.element(this._prefSelectedApp).value;
+    var preferredAppFile = Preferences.get(this._prefSelectedApp).value;
     if (preferredAppFile) {
       let preferredApp = getLocalHandlerApp(preferredAppFile);
       let defaultApp = this._defaultApplicationHandler;
       if (!defaultApp || !defaultApp.equals(preferredApp))
         this._possibleApplicationHandlers.appendElement(preferredApp);
     }
 
     // Add the registered web handlers.  There can be any number of these.
@@ -631,17 +654,17 @@ FeedHandlerInfo.prototype = {
       return this._defaultApplicationHandler.name;
 
     // Should we instead return null?
     return "";
   },
 
   // What to do with content of this type.
   get preferredAction() {
-    switch (this.element(this._prefSelectedAction).value) {
+    switch (Preferences.get(this._prefSelectedAction).value) {
 
       case "bookmarks":
         return Ci.nsIHandlerInfo.handleInternally;
 
       case "reader": {
         let preferredApp = this.preferredApplicationHandler;
         let defaultApp = this._defaultApplicationHandler;
 
@@ -669,41 +692,41 @@ FeedHandlerInfo.prototype = {
         return Ci.nsIHandlerInfo.handleInternally;
     }
   },
 
   set preferredAction(aNewValue) {
     switch (aNewValue) {
 
       case Ci.nsIHandlerInfo.handleInternally:
-        this.element(this._prefSelectedReader).value = "bookmarks";
+        Preferences.get(this._prefSelectedReader).value = "bookmarks";
         break;
 
       case Ci.nsIHandlerInfo.useHelperApp:
-        this.element(this._prefSelectedAction).value = "reader";
+        Preferences.get(this._prefSelectedAction).value = "reader";
         // The controller has already set preferredApplicationHandler
         // to the new helper app.
         break;
 
       case Ci.nsIHandlerInfo.useSystemDefault:
-        this.element(this._prefSelectedAction).value = "reader";
+        Preferences.get(this._prefSelectedAction).value = "reader";
         this.preferredApplicationHandler = this._defaultApplicationHandler;
         break;
     }
   },
 
   get alwaysAskBeforeHandling() {
-    return this.element(this._prefSelectedAction).value == "ask";
+    return Preferences.get(this._prefSelectedAction).value == "ask";
   },
 
   set alwaysAskBeforeHandling(aNewValue) {
     if (aNewValue == true)
-      this.element(this._prefSelectedAction).value = "ask";
+      Preferences.get(this._prefSelectedAction).value = "ask";
     else
-      this.element(this._prefSelectedAction).value = "reader";
+      Preferences.get(this._prefSelectedAction).value = "reader";
   },
 
   // Whether or not we are currently storing the action selected by the user.
   // We use this to suppress notification-triggered updates to the list when
   // we make changes that may spawn such updates, specifically when we change
   // the action for the feed type, which results in feed preference updates,
   // which spawn "pref changed" notifications that would otherwise cause us
   // to rebuild the view unnecessarily.
@@ -907,17 +930,17 @@ var gApplicationsPane = {
     setEventListener("focusSearch1", "command", gApplicationsPane.focusFilterBox);
     setEventListener("focusSearch2", "command", gApplicationsPane.focusFilterBox);
     setEventListener("filter", "command", gApplicationsPane.filter);
     setEventListener("handlersView", "select",
       gApplicationsPane.onSelectionChanged);
     setEventListener("typeColumn", "click", gApplicationsPane.sort);
     setEventListener("actionColumn", "click", gApplicationsPane.sort);
     setEventListener("chooseFolder", "command", gApplicationsPane.chooseFolder);
-    setEventListener("browser.download.dir", "change", gApplicationsPane.displayDownloadDirPref);
+    Preferences.get("browser.download.dir").on("change", gApplicationsPane.displayDownloadDirPref);
 
     // Listen for window unload so we can remove our preference observers.
     window.addEventListener("unload", this);
 
     // Figure out how we should be sorting the list.  We persist sort settings
     // across sessions, so we can't assume the default sort column/direction.
     // XXX should we be using the XUL sort service instead?
     if (document.getElementById("actionColumn").hasAttribute("sortDirection")) {
@@ -1931,17 +1954,17 @@ var gApplicationsPane = {
 
   /**
    * Enables/disables the folder field and Browse button based on whether a
    * default download directory is being used.
    */
   readUseDownloadDir() {
     var downloadFolder = document.getElementById("downloadFolder");
     var chooseFolder = document.getElementById("chooseFolder");
-    var preference = document.getElementById("browser.download.useDownloadDir");
+    var preference = Preferences.get("browser.download.useDownloadDir");
     downloadFolder.disabled = !preference.value || preference.locked;
     chooseFolder.disabled = !preference.value || preference.locked;
 
     // don't override the preference's value in UI
     return undefined;
   },
 
   /**
@@ -1950,17 +1973,17 @@ var gApplicationsPane = {
    * response to the choice, if one is made.
    */
   chooseFolder() {
     return this.chooseFolderTask().catch(Components.utils.reportError);
   },
   async chooseFolderTask() {
     let bundlePreferences = document.getElementById("bundlePreferences");
     let title = bundlePreferences.getString("chooseDownloadFolderTitle");
-    let folderListPref = document.getElementById("browser.download.folderList");
+    let folderListPref = Preferences.get("browser.download.folderList");
     let currentDirPref = await this._indexToFolder(folderListPref.value);
     let defDownloads = await this._indexToFolder(1);
     let fp = Components.classes["@mozilla.org/filepicker;1"].
              createInstance(Components.interfaces.nsIFilePicker);
 
     fp.init(window, title, Components.interfaces.nsIFilePicker.modeGetFolder);
     fp.appendFilters(Components.interfaces.nsIFilePicker.filterAll);
     // First try to open what's currently configured
@@ -1974,17 +1997,17 @@ var gApplicationsPane = {
       fp.displayDirectory = await this._indexToFolder(0);
     }
 
     let result = await new Promise(resolve => fp.open(resolve));
     if (result != Components.interfaces.nsIFilePicker.returnOK) {
       return;
     }
 
-    let downloadDirPref = document.getElementById("browser.download.dir");
+    let downloadDirPref = Preferences.get("browser.download.dir");
     downloadDirPref.value = fp.file;
     folderListPref.value = await this._folderToIndex(fp.file);
     // Note, the real prefs will not be updated yet, so dnld manager's
     // userDownloadsDirectory may not return the right folder after
     // this code executes. displayDownloadDirPref will be called on
     // the assignment above to update the UI.
   },
 
@@ -1995,20 +2018,20 @@ var gApplicationsPane = {
   displayDownloadDirPref() {
     this.displayDownloadDirPrefTask().catch(Components.utils.reportError);
 
     // don't override the preference's value in UI
     return undefined;
   },
 
   async displayDownloadDirPrefTask() {
-    var folderListPref = document.getElementById("browser.download.folderList");
+    var folderListPref = Preferences.get("browser.download.folderList");
     var bundlePreferences = document.getElementById("bundlePreferences");
     var downloadFolder = document.getElementById("downloadFolder");
-    var currentDirPref = document.getElementById("browser.download.dir");
+    var currentDirPref = Preferences.get("browser.download.dir");
 
     // Used in defining the correct path to the folder icon.
     var ios = Components.classes["@mozilla.org/network/io-service;1"]
                         .getService(Components.interfaces.nsIIOService);
     var fph = ios.getProtocolHandler("file")
                  .QueryInterface(Components.interfaces.nsIFileProtocolHandler);
     var iconUrlSpec;
 
@@ -2089,13 +2112,13 @@ var gApplicationsPane = {
    */
   async _indexToFolder(aIndex) {
     switch (aIndex) {
       case 0:
         return await this._getDownloadsFolder("Desktop");
       case 1:
         return await this._getDownloadsFolder("Downloads");
     }
-    var currentDirPref = document.getElementById("browser.download.dir");
+    var currentDirPref = Preferences.get("browser.download.dir");
     return currentDirPref.value;
   }
 
 };
diff --git a/browser/components/preferences/in-content-new/applications.xhtml b/browser/components/preferences/in-content-new/applications.xhtml
--- a/browser/components/preferences/in-content-new/applications.xhtml
+++ b/browser/components/preferences/in-content-new/applications.xhtml
@@ -2,61 +2,16 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <!-- Applications panel -->
 
 <html:script 
         src="chrome://browser/content/preferences/in-content-new/applications.js"></html:script>
 
-<preferences id="feedsPreferences" hidden="true" data-category="paneApplications">
-  <preference id="browser.feeds.handler"
-              name="browser.feeds.handler"
-              type="string"/>
-  <preference id="browser.feeds.handler.default"
-              name="browser.feeds.handler.default"
-              type="string"/>
-  <preference id="browser.feeds.handlers.application"
-              name="browser.feeds.handlers.application"
-              type="file"/>
-  <preference id="browser.feeds.handlers.webservice"
-              name="browser.feeds.handlers.webservice"
-              type="string"/>
-
-  <preference id="browser.videoFeeds.handler"
-              name="browser.videoFeeds.handler"
-              type="string"/>
-  <preference id="browser.videoFeeds.handler.default"
-              name="browser.videoFeeds.handler.default"
-              type="string"/>
-  <preference id="browser.videoFeeds.handlers.application"
-              name="browser.videoFeeds.handlers.application"
-              type="file"/>
-  <preference id="browser.videoFeeds.handlers.webservice"
-              name="browser.videoFeeds.handlers.webservice"
-              type="string"/>
-
-  <preference id="browser.audioFeeds.handler"
-              name="browser.audioFeeds.handler"
-              type="string"/>
-  <preference id="browser.audioFeeds.handler.default"
-              name="browser.audioFeeds.handler.default"
-              type="string"/>
-  <preference id="browser.audioFeeds.handlers.application"
-              name="browser.audioFeeds.handlers.application"
-              type="file"/>
-  <preference id="browser.audioFeeds.handlers.webservice"
-              name="browser.audioFeeds.handlers.webservice"
-              type="string"/>
-
-  <preference id="pref.downloads.disable_button.edit_actions"
-              name="pref.downloads.disable_button.edit_actions"
-              type="bool"/>
-</preferences>
-
 <keyset data-category="paneApplications">
   <!-- Ctrl+f/k focus the search box in the Applications pane.
        These <key>s have oncommand attributes because of bug 371900. -->
   <key key="&focusSearch1.key;" modifiers="accel" id="focusSearch1" oncommand=";"/>
   <key key="&focusSearch2.key;" modifiers="accel" id="focusSearch2" oncommand=";"/>
 </keyset>
 
 <hbox id="header-applications"
diff --git a/browser/components/preferences/in-content-new/containers.xhtml b/browser/components/preferences/in-content-new/containers.xhtml
--- a/browser/components/preferences/in-content-new/containers.xhtml
+++ b/browser/components/preferences/in-content-new/containers.xhtml
@@ -2,24 +2,16 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <!-- Containers panel -->
 
 <html:script 
         src="chrome://browser/content/preferences/in-content-new/containers.js"></html:script>
 
-<preferences id="containerPreferences" hidden="true" data-category="paneContainer">
-  <!-- Containers -->
-  <preference id="privacy.userContext.enabled"
-              name="privacy.userContext.enabled"
-              type="bool"/>
-
-</preferences>
-
 <hbox hidden="true"
       class="container-header-links"
       data-category="paneContainers">
   <label class="text-link" id="backContainersLink">&backLink.label;</label>
 </hbox>
 
 <hbox id="header-containers"
       class="header"
diff --git a/browser/components/preferences/in-content-new/jar.mn b/browser/components/preferences/in-content-new/jar.mn
--- a/browser/components/preferences/in-content-new/jar.mn
+++ b/browser/components/preferences/in-content-new/jar.mn
@@ -2,15 +2,15 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 browser.jar:
    content/browser/preferences/in-content-new/preferences.js
 *  content/browser/preferences/in-content-new/preferences.xhtml
    content/browser/preferences/in-content-new/subdialogs.js
 
-   content/browser/preferences/in-content-new/main.js
-   content/browser/preferences/in-content-new/privacy.js
+*  content/browser/preferences/in-content-new/main.js
+*  content/browser/preferences/in-content-new/privacy.js
    content/browser/preferences/in-content-new/containers.js
-   content/browser/preferences/in-content-new/advanced.js
+*  content/browser/preferences/in-content-new/advanced.js
    content/browser/preferences/in-content-new/applications.js
    content/browser/preferences/in-content-new/sync.js
    content/browser/preferences/in-content-new/findInPage.js
diff --git a/browser/components/preferences/in-content-new/main.js b/browser/components/preferences/in-content-new/main.js
--- a/browser/components/preferences/in-content-new/main.js
+++ b/browser/components/preferences/in-content-new/main.js
@@ -22,16 +22,124 @@ if (AppConstants.E10S_TESTING_ONLY) {
 XPCOMUtils.defineLazyModuleGetter(this, "PlacesUtils",
                                   "resource://gre/modules/PlacesUtils.jsm");
 
 if (AppConstants.MOZ_DEV_EDITION) {
   XPCOMUtils.defineLazyModuleGetter(this, "fxAccounts",
                                     "resource://gre/modules/FxAccounts.jsm");
 }
 
+// Instantiate preferences after DOM content is loaded but before the pane
+// is initialized, so the DOM elements are available to the Preference objects,
+// and the Preference objects are available to the pane initializer.
+window.addEventListener("DOMContentLoaded", function() {
+  Preferences.addAll([
+#ifdef E10S_TESTING_ONLY
+    { id: "browser.tabs.remote.autostart", type: "bool" },
+    { id: "e10sTempPref", name: "browser.tabs.remote.autostart.2", type: "bool" },
+    { id: "e10sForceEnable", name: "browser.tabs.remote.force-enable", type: "bool" },
+#endif
+
+    /* Startup */
+    { id: "browser.startup.page", type: "int" },
+    { id: "browser.startup.homepage", type: "wstring" },
+
+#ifdef HAVE_SHELL_SERVICE
+    { id: "browser.shell.checkDefaultBrowser", type: "bool" },
+    { id: "pref.general.disable_button.default_browser", type: "bool" },
+#endif
+
+    { id: "pref.browser.homepage.disable_button.current_page", type: "bool" },
+    { id: "pref.browser.homepage.disable_button.bookmark_page", type: "bool" },
+    { id: "pref.browser.homepage.disable_button.restore_default", type: "bool" },
+    { id: "browser.privatebrowsing.autostart", type: "bool" },
+
+    /* Search Engine */
+    { id: "browser.search.suggest.enabled", type: "bool" },
+    { id: "browser.urlbar.suggest.searches", type: "bool" },
+    { id: "browser.search.hiddenOneOffs", type: "unichar" },
+
+    /* Downloads */
+    { id: "browser.download.useDownloadDir", type: "bool" },
+    { id: "browser.download.folderList", type: "int" },
+    { id: "browser.download.dir", type: "file" },
+
+    /* Tab preferences
+    Preferences:
+
+    browser.link.open_newwindow
+        1 opens such links in the most recent window or tab,
+        2 opens such links in a new window,
+        3 opens such links in a new tab
+    browser.tabs.loadInBackground
+    - true if display should switch to a new tab which has been opened from a
+      link, false if display shouldn't switch
+    browser.tabs.warnOnClose
+    - true if when closing a window with multiple tabs the user is warned and
+      allowed to cancel the action, false to just close the window
+    browser.tabs.warnOnOpen
+    - true if the user should be warned if he attempts to open a lot of tabs at
+      once (e.g. a large folder of bookmarks), false otherwise
+    browser.taskbar.previews.enable
+    - true if tabs are to be shown in the Windows 7 taskbar
+    */
+
+    { id: "browser.link.open_newwindow", type: "int" },
+    { id: "browser.tabs.loadInBackground", type: "bool", inverted: true },
+    { id: "browser.tabs.warnOnClose", type: "bool" },
+    { id: "browser.tabs.warnOnOpen", type: "bool" },
+    { id: "browser.sessionstore.restore_on_demand", type: "bool" },
+#ifdef XP_WIN
+    { id: "browser.taskbar.previews.enable", type: "bool" },
+#endif
+    { id: "browser.ctrlTab.previews", type: "bool" },
+
+    /* Fonts */
+    { id: "font.language.group", type: "wstring" },
+
+    /* Languages */
+    { id: "browser.translation.detectLanguage", type: "bool" },
+
+    /* General tab */
+
+    /* Accessibility
+     * accessibility.browsewithcaret
+       - true enables keyboard navigation and selection within web pages using a
+         visible caret, false uses normal keyboard navigation with no caret
+     * accessibility.typeaheadfind
+       - when set to true, typing outside text areas and input boxes will
+         automatically start searching for what's typed within the current
+         document; when set to false, no search action happens */
+    { id: "accessibility.browsewithcaret", type: "bool" },
+    { id: "accessibility.typeaheadfind", type: "bool" },
+    { id: "accessibility.blockautorefresh", type: "bool" },
+#ifdef XP_WIN
+    { id: "ui.osk.enabled", type: "bool" },
+#endif
+
+    /* Browsing
+     * general.autoScroll
+       - when set to true, clicking the scroll wheel on the mouse activates a
+         mouse mode where moving the mouse down scrolls the document downward with
+         speed correlated with the distance of the cursor from the original
+         position at which the click occurred (and likewise with movement upward);
+         if false, this behavior is disabled
+     * general.smoothScroll
+       - set to true to enable finer page scrolling than line-by-line on page-up,
+         page-down, and other such page movements */
+    { id: "general.autoScroll", type: "bool" },
+    { id: "general.smoothScroll", type: "bool" },
+    { id: "layout.spellcheckDefault", type: "int" },
+    { id: "toolkit.telemetry.enabled", type: "bool" },
+    { id: "browser.preferences.defaultPerformanceSettings.enabled", type: "bool" },
+    { id: "dom.ipc.processCount", type: "int" },
+    { id: "layers.acceleration.disabled", type: "bool", inverted: true },
+  ]);
+}, { once: true, capture: true });
+
 const ENGINE_FLAVOR = "text/x-moz-search-engine";
 
 var gEngineView = null;
 
 var gMainPane = {
   /**
    * Initialize autocomplete to ensure prefs are in sync.
    */
@@ -104,27 +212,27 @@ var gMainPane = {
     Services.obs.addObserver(this, "browser-search-engine-modified");
     window.addEventListener("unload", () => {
       Services.obs.removeObserver(this, "browser-search-engine-modified");
     });
 
     this._initAutocomplete();
 
     let suggestsPref =
-      document.getElementById("browser.search.suggest.enabled");
-    suggestsPref.addEventListener("change", () => {
+      Preferences.get("browser.search.suggest.enabled");
+    suggestsPref.on("change", () => {
       this.updateSuggestsCheckbox();
     });
     this.updateSuggestsCheckbox();
 
     this.updateDefaultPerformanceSettingsPref();
 
     let defaultPerformancePref =
-      document.getElementById("browser.preferences.defaultPerformanceSettings.enabled");
-    defaultPerformancePref.addEventListener("change", () => {
+      Preferences.get("browser.preferences.defaultPerformanceSettings.enabled");
+    defaultPerformancePref.on("change", () => {
       this.updatePerformanceSettingsBox();
     });
     this.updatePerformanceSettingsBox();
 
     // set up the "use current page" label-changing listener
     this._updateUseCurrentButton();
     window.addEventListener("focus", this._updateUseCurrentButton.bind(this));
 
@@ -145,17 +253,17 @@ var gMainPane = {
     // &brandShortName;" warnings provide options for not showing these
     // warnings again. When the user disabled them, we provide checkboxes to
     // re-enable the warnings.
     if (!TransientPrefs.prefShouldBeVisible("browser.tabs.warnOnClose"))
       document.getElementById("warnCloseMultiple").hidden = true;
     if (!TransientPrefs.prefShouldBeVisible("browser.tabs.warnOnOpen"))
       document.getElementById("warnOpenMany").hidden = true;
 
-    setEventListener("browser.privatebrowsing.autostart", "change",
+    Preferences.get("browser.privatebrowsing.autostart").on("change",
                      gMainPane.updateBrowserStartupLastSession);
     if (AppConstants.HAVE_SHELL_SERVICE) {
       setEventListener("setDefaultButton", "command",
                        gMainPane.setDefaultBrowser);
     }
     setEventListener("useCurrent", "command",
                      gMainPane.setHomePageToCurrent);
     setEventListener("useBookmark", "command",
@@ -163,23 +271,23 @@ var gMainPane = {
     setEventListener("restoreDefaultHomePage", "command",
                      gMainPane.restoreDefaultHomePage);
     setEventListener("chooseLanguage", "command",
       gMainPane.showLanguages);
     setEventListener("translationAttributionImage", "click",
       gMainPane.openTranslationProviderAttribution);
     setEventListener("translateButton", "command",
       gMainPane.showTranslationExceptions);
-    setEventListener("font.language.group", "change",
+    Preferences.get("font.language.group").on("change",
       gMainPane._rebuildFonts);
     setEventListener("advancedFonts", "command",
       gMainPane.configureFonts);
     setEventListener("colors", "command",
       gMainPane.configureColors);
-    setEventListener("layers.acceleration.disabled", "change",
+    Preferences.get("layers.acceleration.disabled").on("change",
       gMainPane.updateHardwareAcceleration);
 
     // Initializes the fonts dropdowns displayed in this pane.
     this._rebuildFonts();
 
     this.updateOnScreenKeyboardVisibility();
 
     // Show translation preferences if we may:
@@ -194,19 +302,19 @@ var gMainPane = {
       }
     }
 
     if (AppConstants.E10S_TESTING_ONLY) {
       setEventListener("e10sAutoStart", "command",
                        gMainPane.enableE10SChange);
       let e10sCheckbox = document.getElementById("e10sAutoStart");
 
-      let e10sPref = document.getElementById("browser.tabs.remote.autostart");
-      let e10sTempPref = document.getElementById("e10sTempPref");
-      let e10sForceEnable = document.getElementById("e10sForceEnable");
+      let e10sPref = Preferences.get("browser.tabs.remote.autostart");
+      let e10sTempPref = Preferences.get("e10sTempPref");
+      let e10sForceEnable = Preferences.get("e10sForceEnable");
 
       let preffedOn = e10sPref.value || e10sTempPref.value || e10sForceEnable.value;
 
       if (preffedOn) {
         // The checkbox is checked if e10s is preffed on and enabled.
         e10sCheckbox.checked = Services.appinfo.browserTabsRemoteAutostart;
 
         // but if it's force disabled, then the checkbox is disabled.
@@ -250,18 +358,18 @@ var gMainPane = {
     }
 
     return e10sEnabled;
   },
 
   enableE10SChange() {
     if (AppConstants.E10S_TESTING_ONLY) {
       let e10sCheckbox = document.getElementById("e10sAutoStart");
-      let e10sPref = document.getElementById("browser.tabs.remote.autostart");
-      let e10sTempPref = document.getElementById("e10sTempPref");
+      let e10sPref = Preferences.get("browser.tabs.remote.autostart");
+      let e10sTempPref = Preferences.get("e10sTempPref");
 
       let prefsToChange;
       if (e10sCheckbox.checked) {
         // Enabling e10s autostart
         prefsToChange = [e10sPref];
       } else {
         // Disabling e10s autostart
         prefsToChange = [e10sPref];
@@ -372,17 +480,17 @@ var gMainPane = {
    *     3: windows and tabs from the last session (a.k.a. session restore)
    *
    *   The deprecated option is not exposed in UI; however, if the user has it
    *   selected and doesn't change the UI for this preference, the deprecated
    *   option is preserved.
    */
 
   syncFromHomePref() {
-    let homePref = document.getElementById("browser.startup.homepage");
+    let homePref = Preferences.get("browser.startup.homepage");
 
     // If the pref is set to about:home or about:newtab, set the value to ""
     // to show the placeholder text (about:home title) rather than
     // exposing those URLs to users.
     let defaultBranch = Services.prefs.getDefaultBranch("");
     let defaultValue = defaultBranch.getComplexValue("browser.startup.homepage",
                                                      Ci.nsIPrefLocalizedString).data;
     let currentValue = homePref.value.toLowerCase();
@@ -411,17 +519,17 @@ var gMainPane = {
   },
 
   /**
    * Sets the home page to the current displayed page (or frontmost tab, if the
    * most recent browser window contains multiple tabs), updating preference
    * window UI to reflect this.
    */
   setHomePageToCurrent() {
-    let homePage = document.getElementById("browser.startup.homepage");
+    let homePage = Preferences.get("browser.startup.homepage");
     let tabs = this._getTabsForHomePage();
     function getTabURI(t) {
       return t.linkedBrowser.currentURI.spec;
     }
 
     // FIXME Bug 244192: using dangerous "|" joiner!
     if (tabs.length)
       homePage.value = tabs.map(getTabURI).join("|");
@@ -438,17 +546,17 @@ var gMainPane = {
                     "resizable=yes, modal=yes", rv,
                     this._setHomePageToBookmarkClosed.bind(this, rv));
   },
 
   _setHomePageToBookmarkClosed(rv, aEvent) {
     if (aEvent.detail.button != "accept")
       return;
     if (rv.urls && rv.names) {
-      var homePage = document.getElementById("browser.startup.homepage");
+      var homePage = Preferences.get("browser.startup.homepage");
 
       // XXX still using dangerous "|" joiner!
       homePage.value = rv.urls.join("|");
     }
   },
 
   /**
    * Switches the "Use Current Page" button between its singular and plural
@@ -462,17 +570,17 @@ var gMainPane = {
 
     if (tabs.length > 1)
       useCurrent.label = useCurrent.getAttribute("label2");
     else
       useCurrent.label = useCurrent.getAttribute("label1");
 
     // In this case, the button's disabled state is set by preferences.xml.
     let prefName = "pref.browser.homepage.disable_button.current_page";
-    if (document.getElementById(prefName).locked)
+    if (Preferences.get(prefName).locked)
       return;
 
     useCurrent.disabled = !tabs.length
   },
 
   _getTabsForHomePage() {
     var win;
     var tabs = [];
@@ -499,38 +607,38 @@ var gMainPane = {
   isNotAboutPreferences(aElement, aIndex, aArray) {
     return !aElement.linkedBrowser.currentURI.spec.startsWith("about:preferences");
   },
 
   /**
    * Restores the default home page as the user's home page.
    */
   restoreDefaultHomePage() {
-    var homePage = document.getElementById("browser.startup.homepage");
+    var homePage = Preferences.get("browser.startup.homepage");
     homePage.value = homePage.defaultValue;
   },
 
   /**
    * Utility function to enable/disable the button specified by aButtonID based
    * on the value of the Boolean preference specified by aPreferenceID.
    */
   updateButtons(aButtonID, aPreferenceID) {
     var button = document.getElementById(aButtonID);
-    var preference = document.getElementById(aPreferenceID);
+    var preference = Preferences.get(aPreferenceID);
     button.disabled = preference.value != true;
     return undefined;
   },
 
   /**
    * Hide/show the "Show my windows and tabs from last time" option based
    * on the value of the browser.privatebrowsing.autostart pref.
    */
   updateBrowserStartupLastSession() {
-    let pbAutoStartPref = document.getElementById("browser.privatebrowsing.autostart");
-    let startupPref = document.getElementById("browser.startup.page");
+    let pbAutoStartPref = Preferences.get("browser.privatebrowsing.autostart");
+    let startupPref = Preferences.get("browser.startup.page");
     let menu = document.getElementById("browserStartupPage");
     let option = document.getElementById("browserStartupLastSession");
     if (pbAutoStartPref.value) {
       option.setAttribute("disabled", "true");
       if (option.selected) {
         menu.selectedItem = document.getElementById("browserStartupHomePage");
       }
     } else {
@@ -565,17 +673,17 @@ var gMainPane = {
    */
 
   /**
    * Determines where a link which opens a new window will open.
    *
    * @returns |true| if such links should be opened in new tabs
    */
   readLinkTarget() {
-    var openNewWindow = document.getElementById("browser.link.open_newwindow");
+    var openNewWindow = Preferences.get("browser.link.open_newwindow");
     return openNewWindow.value != 2;
   },
 
   /**
    * Determines where a link which opens a new window will open.
    *
    * @returns 2 if such links should be opened in new windows,
    *          3 if such links should be opened in new tabs
@@ -613,17 +721,17 @@ var gMainPane = {
     }
   },
 
   /**
    * Set browser as the operating system default browser.
    */
   setDefaultBrowser() {
     if (AppConstants.HAVE_SHELL_SERVICE) {
-      let alwaysCheckPref = document.getElementById("browser.shell.checkDefaultBrowser");
+      let alwaysCheckPref = Preferences.get("browser.shell.checkDefaultBrowser");
       alwaysCheckPref.value = true;
 
       let shellSvc = getShellService();
       if (!shellSvc)
         return;
       try {
         shellSvc.setDefaultBrowser(true, false);
       } catch (ex) {
@@ -692,74 +800,68 @@ var gMainPane = {
   },
 
   // FONTS
 
   /**
    * Populates the default font list in UI.
    */
   _rebuildFonts() {
-    var preferences = document.getElementById("mainPreferences");
-    // Ensure preferences are "visible" to ensure bindings work.
-    preferences.hidden = false;
-    // Force flush:
-    preferences.clientHeight;
-    var langGroupPref = document.getElementById("font.language.group");
+    var langGroupPref = Preferences.get("font.language.group");
     this._selectDefaultLanguageGroup(langGroupPref.value,
                                      this._readDefaultFontTypeForLanguage(langGroupPref.value) == "serif");
   },
 
   /**
    * Returns the type of the current default font for the language denoted by
    * aLanguageGroup.
    */
   _readDefaultFontTypeForLanguage(aLanguageGroup) {
     const kDefaultFontType = "font.default.%LANG%";
     var defaultFontTypePref = kDefaultFontType.replace(/%LANG%/, aLanguageGroup);
-    var preference = document.getElementById(defaultFontTypePref);
+    var preference = Preferences.get(defaultFontTypePref);
     if (!preference) {
-      preference = document.createElement("preference");
-      preference.id = defaultFontTypePref;
-      preference.setAttribute("name", defaultFontTypePref);
-      preference.setAttribute("type", "string");
-      preference.setAttribute("onchange", "gMainPane._rebuildFonts();");
-      document.getElementById("mainPreferences").appendChild(preference);
+      preference = Preferences.add({
+        id: defaultFontTypePref,
+        name: defaultFontTypePref,
+        type: "string",
+      });
+      preference.on("change", gMainPane._rebuildFonts.bind(gMainPane));
     }
     return preference.value;
   },
 
   _selectDefaultLanguageGroup(aLanguageGroup, aIsSerif) {
     const kFontNameFmtSerif         = "font.name.serif.%LANG%";
     const kFontNameFmtSansSerif     = "font.name.sans-serif.%LANG%";
     const kFontNameListFmtSerif     = "font.name-list.serif.%LANG%";
     const kFontNameListFmtSansSerif = "font.name-list.sans-serif.%LANG%";
     const kFontSizeFmtVariable      = "font.size.variable.%LANG%";
 
-    var preferences = document.getElementById("mainPreferences");
     var prefs = [{ format: aIsSerif ? kFontNameFmtSerif : kFontNameFmtSansSerif,
                    type: "fontname",
                    element: "defaultFont",
                    fonttype: aIsSerif ? "serif" : "sans-serif" },
                  { format: aIsSerif ? kFontNameListFmtSerif : kFontNameListFmtSansSerif,
                    type: "unichar",
                    element: null,
                    fonttype: aIsSerif ? "serif" : "sans-serif" },
                  { format: kFontSizeFmtVariable,
                    type: "int",
                    element: "defaultFontSize",
                    fonttype: null }];
     for (var i = 0; i < prefs.length; ++i) {
-      var preference = document.getElementById(prefs[i].format.replace(/%LANG%/, aLanguageGroup));
+      var preference = Preferences.get(prefs[i].format.replace(/%LANG%/, aLanguageGroup));
       if (!preference) {
-        preference = document.createElement("preference");
         var name = prefs[i].format.replace(/%LANG%/, aLanguageGroup);
-        preference.id = name;
-        preference.setAttribute("name", name);
-        preference.setAttribute("type", prefs[i].type);
-        preferences.appendChild(preference);
+        preference = Preferences.add({
+          id: name,
+          name: name,
+          type: prefs[i].type,
+        });
       }
 
       if (!prefs[i].element)
         continue;
 
       var element = document.getElementById(prefs[i].element);
       if (element) {
         element.setAttribute("preference", preference.id);
@@ -785,17 +887,17 @@ var gMainPane = {
    *
    * layout.spellcheckDefault
    * - an integer:
    *     0  disables spellchecking
    *     1  enables spellchecking, but only for multiline text fields
    *     2  enables spellchecking for all text fields
    */
   readCheckSpelling() {
-    var pref = document.getElementById("layout.spellcheckDefault");
+    var pref = Preferences.get("layout.spellcheckDefault");
     this._storedSpellCheck = pref.value;
 
     return (pref.value != 0);
   },
 
   /**
    * Returns the value of the spellchecking preference represented by UI,
    * preserving the preference's "hidden" value if the preference is
@@ -809,63 +911,63 @@ var gMainPane = {
       }
       return 1;
     }
     return 0;
   },
 
   updateSuggestsCheckbox() {
     let suggestsPref =
-      document.getElementById("browser.search.suggest.enabled");
+      Preferences.get("browser.search.suggest.enabled");
     let permanentPB =
       Services.prefs.getBoolPref("browser.privatebrowsing.autostart");
     let urlbarSuggests = document.getElementById("urlBarSuggestion");
     urlbarSuggests.disabled = !suggestsPref.value || permanentPB;
 
     let urlbarSuggestsPref =
-      document.getElementById("browser.urlbar.suggest.searches");
+      Preferences.get("browser.urlbar.suggest.searches");
     urlbarSuggests.checked = urlbarSuggestsPref.value;
     if (urlbarSuggests.disabled) {
       urlbarSuggests.checked = false;
     }
 
     let permanentPBLabel =
       document.getElementById("urlBarSuggestionPermanentPBLabel");
     permanentPBLabel.hidden = urlbarSuggests.hidden || !permanentPB;
   },
 
   updateDefaultPerformanceSettingsPref() {
     let defaultPerformancePref =
-      document.getElementById("browser.preferences.defaultPerformanceSettings.enabled");
-    let processCountPref = document.getElementById("dom.ipc.processCount");
-    let accelerationPref = document.getElementById("layers.acceleration.disabled");
+      Preferences.get("browser.preferences.defaultPerformanceSettings.enabled");
+    let processCountPref = Preferences.get("dom.ipc.processCount");
+    let accelerationPref = Preferences.get("layers.acceleration.disabled");
     if (processCountPref.value != processCountPref.defaultValue ||
         accelerationPref.value != accelerationPref.defaultValue) {
       defaultPerformancePref.value = false;
     }
   },
 
   updatePerformanceSettingsBox() {
     let defaultPerformancePref =
-      document.getElementById("browser.preferences.defaultPerformanceSettings.enabled");
+      Preferences.get("browser.preferences.defaultPerformanceSettings.enabled");
     let performanceSettings = document.getElementById("performanceSettings");
     if (defaultPerformancePref.value) {
-      let processCountPref = document.getElementById("dom.ipc.processCount");
-      let accelerationPref = document.getElementById("layers.acceleration.disabled");
+      let processCountPref = Preferences.get("dom.ipc.processCount");
+      let accelerationPref = Preferences.get("layers.acceleration.disabled");
       processCountPref.value = processCountPref.defaultValue;
       accelerationPref.value = accelerationPref.defaultValue;
       performanceSettings.hidden = true;
     } else {
       performanceSettings.hidden = false;
     }
   },
 
   buildContentProcessCountMenuList() {
     if (gMainPane.isE10SEnabled()) {
-      let processCountPref = document.getElementById("dom.ipc.processCount");
+      let processCountPref = Preferences.get("dom.ipc.processCount");
       let bundlePreferences = document.getElementById("bundlePreferences");
       let label = bundlePreferences.getFormattedString("defaultContentProcessCount",
         [processCountPref.defaultValue]);
       let contentProcessCount =
         document.querySelector(`#contentProcessCount > menupopup >
                                 menuitem[value="${processCountPref.defaultValue}"]`);
       contentProcessCount.label = label;
 
@@ -1103,17 +1205,17 @@ var gMainPane = {
   },
 
   saveOneClickEnginesList() {
     let hiddenList = [];
     for (let engine of gEngineView._engineStore.engines) {
       if (!engine.shown)
         hiddenList.push(engine.name);
     }
-    document.getElementById("browser.search.hiddenOneOffs").value =
+    Preferences.get("browser.search.hiddenOneOffs").value =
       hiddenList.join(",");
   },
 
   setDefaultEngine() {
     Services.search.currentEngine =
       document.getElementById("defaultEngine").selectedItem.engine;
   }
 };
@@ -1126,17 +1228,17 @@ function onDragEngineStart(event) {
   if (selectedIndex >= 0 && !gEngineView.isCheckBox(row.value, col.value)) {
     event.dataTransfer.setData(ENGINE_FLAVOR, selectedIndex.toString());
     event.dataTransfer.effectAllowed = "move";
   }
 }
 
 
 function EngineStore() {
-  let pref = document.getElementById("browser.search.hiddenOneOffs").value;
+  let pref = Preferences.get("browser.search.hiddenOneOffs").value;
   this.hiddenList = pref ? pref.split(",") : [];
 
   this._engines = Services.search.getVisibleEngines().map(this._cloneEngine, this);
   this._defaultEngines = Services.search.getDefaultEngines().map(this._cloneEngine, this);
 
   // check if we need to disable the restore defaults button
   var someHidden = this._defaultEngines.some(e => e.hidden);
   gMainPane.showRestoreDefaults(someHidden);
diff --git a/browser/components/preferences/in-content-new/main.xhtml b/browser/components/preferences/in-content-new/main.xhtml
--- a/browser/components/preferences/in-content-new/main.xhtml
+++ b/browser/components/preferences/in-content-new/main.xhtml
@@ -9,203 +9,16 @@
 
 <html:script 
         src="chrome://mozapps/content/preferences/fontbuilder.js"></html:script>
 
 <stringbundle id="engineManagerBundle" src="chrome://browser/locale/engineManager.properties"/>
 
 <stringbundle id="bundlePreferences" src="chrome://browser/locale/preferences.properties"/>
 
-<preferences id="mainPreferences" hidden="true" data-category="paneGeneral">
-
-#ifdef E10S_TESTING_ONLY
-    <preference id="browser.tabs.remote.autostart"
-                name="browser.tabs.remote.autostart"
-                type="bool"/>
-    <preference id="e10sTempPref"
-                name="browser.tabs.remote.autostart.2"
-                type="bool"/>
-    <preference id="e10sForceEnable"
-                name="browser.tabs.remote.force-enable"
-                type="bool"/>
-#endif
-
-    <!-- Startup -->
-    <preference id="browser.startup.page"
-                name="browser.startup.page"
-                type="int"/>
-    <preference id="browser.startup.homepage"
-                name="browser.startup.homepage"
-                type="wstring"/>
-
-#ifdef HAVE_SHELL_SERVICE
-    <preference id="browser.shell.checkDefaultBrowser"
-                name="browser.shell.checkDefaultBrowser"
-                type="bool"/>
-
-    <preference id="pref.general.disable_button.default_browser"
-                name="pref.general.disable_button.default_browser"
-                type="bool"/>
-#endif
-
-    <preference id="pref.browser.homepage.disable_button.current_page"
-                name="pref.browser.homepage.disable_button.current_page"
-                type="bool"/>
-    <preference id="pref.browser.homepage.disable_button.bookmark_page"
-                name="pref.browser.homepage.disable_button.bookmark_page"
-                type="bool"/>
-    <preference id="pref.browser.homepage.disable_button.restore_default"
-                name="pref.browser.homepage.disable_button.restore_default"
-                type="bool"/>
-
-    <preference id="browser.privatebrowsing.autostart"
-                name="browser.privatebrowsing.autostart"
-                type="bool"/>
-
-    <!-- Search Engine -->
-    <preference id="browser.search.suggest.enabled"
-                  name="browser.search.suggest.enabled"
-                  type="bool"/>
-
-    <preference id="browser.urlbar.suggest.searches"
-                name="browser.urlbar.suggest.searches"
-                type="bool"/>
-
-    <preference id="browser.search.hiddenOneOffs"
-                name="browser.search.hiddenOneOffs"
-                type="unichar"/>
-
-    <!-- Downloads -->
-    <preference id="browser.download.useDownloadDir"
-                name="browser.download.useDownloadDir"
-                type="bool"/>
-
-    <preference id="browser.download.folderList"
-                name="browser.download.folderList"
-                type="int"/>
-    <preference id="browser.download.dir"
-                name="browser.download.dir"
-                type="file"/>
-    <!-- Tab preferences
-    Preferences:
-
-    browser.link.open_newwindow
-        1 opens such links in the most recent window or tab,
-        2 opens such links in a new window,
-        3 opens such links in a new tab
-    browser.tabs.loadInBackground
-    - true if display should switch to a new tab which has been opened from a
-      link, false if display shouldn't switch
-    browser.tabs.warnOnClose
-    - true if when closing a window with multiple tabs the user is warned and
-      allowed to cancel the action, false to just close the window
-    browser.tabs.warnOnOpen
-    - true if the user should be warned if he attempts to open a lot of tabs at
-      once (e.g. a large folder of bookmarks), false otherwise
-    browser.taskbar.previews.enable
-    - true if tabs are to be shown in the Windows 7 taskbar
-    -->
-
-    <preference id="browser.link.open_newwindow"
-                name="browser.link.open_newwindow"
-                type="int"/>
-    <preference id="browser.tabs.loadInBackground"
-                name="browser.tabs.loadInBackground"
-                type="bool"
-                inverted="true"/>
-    <preference id="browser.tabs.warnOnClose"
-                name="browser.tabs.warnOnClose"
-                type="bool"/>
-    <preference id="browser.tabs.warnOnOpen"
-                name="browser.tabs.warnOnOpen"
-                type="bool"/>
-    <preference id="browser.sessionstore.restore_on_demand"
-                name="browser.sessionstore.restore_on_demand"
-                type="bool"/>
-#ifdef XP_WIN
-    <preference id="browser.taskbar.previews.enable"
-                name="browser.taskbar.previews.enable"
-                type="bool"/>
-#endif
-    <preference id="browser.ctrlTab.previews"
-                name="browser.ctrlTab.previews"
-                type="bool"/>
-
-  <!-- Fonts -->
-  <preference id="font.language.group"
-              name="font.language.group"
-              type="wstring"/>
-
-  <!-- Languages -->
-  <preference id="browser.translation.detectLanguage"
-              name="browser.translation.detectLanguage"
-              type="bool"/>
-
-  <!-- General tab -->
-
-  <!-- Accessibility
-   * accessibility.browsewithcaret
-     - true enables keyboard navigation and selection within web pages using a
-       visible caret, false uses normal keyboard navigation with no caret
-   * accessibility.typeaheadfind
-     - when set to true, typing outside text areas and input boxes will
-       automatically start searching for what's typed within the current
-       document; when set to false, no search action happens -->
-  <preference id="accessibility.browsewithcaret"
-              name="accessibility.browsewithcaret"
-              type="bool"/>
-  <preference id="accessibility.typeaheadfind"
-              name="accessibility.typeaheadfind"
-              type="bool"/>
-  <preference id="accessibility.blockautorefresh"
-              name="accessibility.blockautorefresh"
-              type="bool"/>
-#ifdef XP_WIN
-  <preference id="ui.osk.enabled"
-              name="ui.osk.enabled"
-              type="bool"/>
-#endif
-  <!-- Browsing
-   * general.autoScroll
-     - when set to true, clicking the scroll wheel on the mouse activates a
-       mouse mode where moving the mouse down scrolls the document downward with
-       speed correlated with the distance of the cursor from the original
-       position at which the click occurred (and likewise with movement upward);
-       if false, this behavior is disabled
-   * general.smoothScroll
-     - set to true to enable finer page scrolling than line-by-line on page-up,
-       page-down, and other such page movements -->
-  <preference id="general.autoScroll"
-              name="general.autoScroll"
-              type="bool"/>
-  <preference id="general.smoothScroll"
-              name="general.smoothScroll"
-              type="bool"/>
-  <preference id="layout.spellcheckDefault"
-              name="layout.spellcheckDefault"
-              type="int"/>
-
-  <preference id="toolkit.telemetry.enabled"
-              name="toolkit.telemetry.enabled"
-              type="bool"/>
-
-  <preference id="browser.preferences.defaultPerformanceSettings.enabled"
-              name="browser.preferences.defaultPerformanceSettings.enabled"
-              type="bool"/>
-
-  <preference id="dom.ipc.processCount"
-              name="dom.ipc.processCount"
-              type="int"/>
-
-  <preference id="layers.acceleration.disabled"
-              name="layers.acceleration.disabled"
-              type="bool"
-              inverted="true"/>
-</preferences>
-
 <hbox id="header-general"
       class="header"
       hidden="true"
       data-category="paneGeneral">
   <label class="header-name" flex="1">&paneGeneral.title;</label>
 </hbox>
 
 <!-- Startup -->
diff --git a/browser/components/preferences/in-content-new/preferences.js b/browser/components/preferences/in-content-new/preferences.js
--- a/browser/components/preferences/in-content-new/preferences.js
+++ b/browser/components/preferences/in-content-new/preferences.js
@@ -18,16 +18,17 @@
 var Cc = Components.classes;
 var Ci = Components.interfaces;
 var Cu = Components.utils;
 var Cr = Components.results;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/AppConstants.jsm");
+Cu.import("resource://gre/modules/EventEmitter.jsm");
 
 var gLastHash = "";
 
 var gCategoryInits = new Map();
 function init_category_if_required(category) {
   let categoryInfo = gCategoryInits.get(category);
   if (!categoryInfo) {
     throw "Unknown in-content prefs category! Can't init " + category;
@@ -85,16 +86,22 @@ function init_all() {
     "cancelable": true
   });
   document.dispatchEvent(initFinished);
 
   let helpButton = document.querySelector(".help-button");
   let helpUrl = Services.urlFormatter.formatURLPref("app.support.baseURL") + "preferences";
   helpButton.setAttribute("href", helpUrl);
 
+  let mainPrefPane = document.getElementById("mainPrefPane");
+  mainPrefPane.addEventListener("command", MainPrefPane.onCommand.bind(MainPrefPane));
+  mainPrefPane.addEventListener("select", MainPrefPane.onSelect.bind(MainPrefPane));
+  mainPrefPane.addEventListener("change", MainPrefPane.onChange.bind(MainPrefPane));
+  mainPrefPane.addEventListener("input", MainPrefPane.onInput.bind(MainPrefPane));
+
   // Wait until initialization of all preferences are complete before
   // notifying observers that the UI is now ready.
   Services.obs.notifyObservers(window, "advanced-pane-loaded");
 }
 
 // Make the space above the categories list shrink on low window heights
 function init_dynamic_padding() {
   let categories = document.getElementById("categories");
@@ -243,24 +250,16 @@ function search(aQuery, aAttribute, aSub
     let attributeValue = element.getAttribute(aAttribute);
     if (attributeValue == aQuery)
       element.removeAttribute("disabled");
     else
       element.setAttribute("disabled", true);
   }
 }
 
-function helpButtonCommand() {
-  let pane = history.state;
-  let categories = document.getElementById("categories");
-  let helpTopic = categories.querySelector(".category[value=" + pane + "]")
-                            .getAttribute("helpTopic");
-  openHelpLink(helpTopic);
-}
-
 function friendlyPrefCategoryNameToInternalName(aName) {
   if (aName.startsWith("pane"))
     return aName;
   return "pane" + aName.substring(0, 1).toUpperCase() + aName.substr(1);
 }
 
 // This function is duplicated inside of utilityOverlay.js's openPreferences.
 function internalPrefCategoryNameToFriendlyName(aName) {
@@ -339,8 +338,547 @@ function confirmRestartPrompt(aRestartTo
     Services.obs.notifyObservers(cancelQuit, "quit-application-requested",
                                   "restart");
     if (cancelQuit.data) {
       buttonIndex = CONFIRM_RESTART_PROMPT_CANCEL;
     }
   }
   return buttonIndex;
 }
+
+// We attach this to the window object so tests have access to it.
+window.Preferences = {
+  all: {},
+
+  add(prefInfo) {
+    // TODO: throw an exception if a pref with the same ID already exists.
+    const pref = new Preference(prefInfo);
+    Preferences.all[pref.id] = pref;
+    pref.updateElements();
+    return pref;
+  },
+
+  addAll(prefInfos) {
+    for (const prefInfo of prefInfos) {
+      // TODO: throw an exception if a pref with the same ID already exists.
+      const pref = new Preference(prefInfo);
+      this.all[pref.id] = pref;
+      pref.updateElements();
+    }
+  },
+
+  get(id) {
+    return this.all[id] || null;
+  },
+
+  getAll() {
+    return Object.values(this.all);
+  },
+
+  rootBranch: Components.classes["@mozilla.org/preferences-service;1"]
+                        .getService(Components.interfaces.nsIPrefBranch),
+
+  rootBranchInternal: Components.classes["@mozilla.org/preferences-service;1"]
+                                .getService(Components.interfaces.nsIPrefBranchInternal),
+
+  defaultBranch: Components.classes["@mozilla.org/preferences-service;1"]
+                           .getService(Components.interfaces.nsIPrefService)
+                           .getDefaultBranch(""),
+
+  get type() {
+    return document.documentElement.type || "";
+  },
+
+  // TODO: remove this getter and the conditions that depend on it
+  // since instantApply is always true in this prefs implementation.
+  get instantApply() {
+    var doc = document.documentElement;
+    return this.type == "child" ? doc.instantApply
+                                : doc.instantApply || this.rootBranch.getBoolPref("browser.preferences.instantApply");
+  },
+};
+
+function Preference({ id, name, type, inverted }) {
+  EventEmitter.call(this);
+  this.on("change", this.onchange.bind(this));
+
+  this.id = id;
+  this._name = name || this.id;
+  this.type = type;
+  this.inverted = !!inverted;
+
+  // if the element has been inserted without the name attribute set,
+  // we have nothing to do here
+  // TODO: throw an exception in this case, which seems, erm, exceptional.
+  if (!this.name)
+    return;
+
+  // TODO: figure out why we get errors when making this a weak observer.
+  Preferences.rootBranchInternal.addObserver(this.name, this);
+  window.addEventListener("unload", this.destructor.bind(this), { once: true });
+
+  // TODO: remove the code below that only applies in non-instant apply mode,
+  // since instantApply is always true in this prefs implementation.
+
+  // In non-instant apply mode, we must try and use the last saved state
+  // from any previous opens of a child dialog instead of the value from
+  // preferences, to pick up any edits a user may have made.
+
+  var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
+              .getService(Components.interfaces.nsIScriptSecurityManager);
+  if (Preferences.type == "child" &&
+      !this.instantApply && window.opener &&
+      secMan.isSystemPrincipal(window.opener.document.nodePrincipal)) {
+    var pdoc = window.opener.document;
+
+    // Try to find a preference element for the same preference.
+    var preference = null;
+    var parentPreferences = pdoc.getElementsByTagName("preferences");
+    for (var k = 0; (k < parentPreferences.length && !preference); ++k) {
+      var parentPrefs = parentPreferences[k]
+                              .getElementsByAttribute("name", this.name);
+      for (var l = 0; (l < parentPrefs.length && !preference); ++l) {
+        if (parentPrefs[l].localName == "preference")
+          preference = parentPrefs[l];
+      }
+    }
+
+    // Don't use the value setter here, we don't want updateElements to be prematurely fired.
+    this._value = preference ? preference.value : this.valueFromPreferences;
+  } else
+    this._value = this.valueFromPreferences;
+}
+
+Preference.prototype = Object.create(EventEmitter.prototype);
+
+Object.assign(Preference.prototype, {
+  constructor: Preference,
+  destructor() {
+    Preferences.rootBranchInternal.removeObserver(this.name, this);
+  },
+
+  _value: null,
+  _disabled: false,
+
+  id: "",
+  readonly: false,
+  type: "",
+  inverted: false,
+
+  reset() {
+    // defer reset until preference update
+    this.value = undefined;
+  },
+
+  _useDefault: false,
+
+  // TODO: remove this, since it never gets changed.
+  batching: false,
+
+  _reportUnknownType() {
+    // TODO: instead of reporting an unknown type, throw an exception
+    // if a Preference object is instantiated with an unknown type.
+    var consoleService = Components.classes["@mozilla.org/consoleservice;1"]
+                                   .getService(Components.interfaces.nsIConsoleService);
+    var msg = "Preference with id='" + this.id + "' and name='" +
+              this.name + "' has unknown type '" + this.type + "'.";
+    consoleService.logStringMessage(msg);
+  },
+
+  setElementValue(aElement) {
+    if (this.locked)
+      aElement.disabled = true;
+
+    if (!this.isElementEditable(aElement))
+      return;
+
+    var rv = undefined;
+    if (aElement.hasAttribute("onsyncfrompreference")) {
+      // Value changed, synthesize an event
+      try {
+        var event = document.createEvent("Events");
+        event.initEvent("syncfrompreference", true, true);
+        var f = new Function("event",
+                             aElement.getAttribute("onsyncfrompreference"));
+        rv = f.call(aElement, event);
+      } catch (e) {
+        Components.utils.reportError(e);
+      }
+    }
+    var val = rv;
+    if (val === undefined)
+      val = this.instantApply ? this.valueFromPreferences : this.value;
+    // if the preference is marked for reset, show default value in UI
+    if (val === undefined)
+      val = this.defaultValue;
+
+    /**
+     * Initialize a UI element property with a value. Handles the case
+     * where an element has not yet had a XBL binding attached for it and
+     * the property setter does not yet exist by setting the same attribute
+     * on the XUL element using DOM apis and assuming the element's
+     * constructor or property getters appropriately handle this state.
+     */
+    function setValue(element, attribute, value) {
+      if (attribute in element)
+        element[attribute] = value;
+      else
+        element.setAttribute(attribute, value);
+    }
+    if (aElement.localName == "checkbox" ||
+        aElement.localName == "listitem")
+      setValue(aElement, "checked", val);
+    else if (aElement.localName == "colorpicker")
+      setValue(aElement, "color", val);
+    else if (aElement.localName == "textbox") {
+      // XXXmano Bug 303998: Avoid a caret placement issue if either the
+      // preference observer or its setter calls updateElements as a result
+      // of the input event handler.
+      if (aElement.value !== val)
+        setValue(aElement, "value", val);
+    } else
+      setValue(aElement, "value", val);
+  },
+
+  getElementValue(aElement) {
+    if (aElement.hasAttribute("onsynctopreference")) {
+      // Value changed, synthesize an event
+      try {
+        var event = document.createEvent("Events");
+        event.initEvent("synctopreference", true, true);
+        var f = new Function("event",
+                             aElement.getAttribute("onsynctopreference"));
+        var rv = f.call(aElement, event);
+        if (rv !== undefined)
+          return rv;
+      } catch (e) {
+        Components.utils.reportError(e);
+      }
+    }
+
+    /**
+     * Read the value of an attribute from an element, assuming the
+     * attribute is a property on the element's node API. If the property
+     * is not present in the API, then assume its value is contained in
+     * an attribute, as is the case before a binding has been attached.
+     */
+    function getValue(element, attribute) {
+      if (attribute in element)
+        return element[attribute];
+      return element.getAttribute(attribute);
+    }
+    if (aElement.localName == "checkbox" ||
+        aElement.localName == "listitem")
+      var value = getValue(aElement, "checked");
+    else if (aElement.localName == "colorpicker")
+      value = getValue(aElement, "color");
+    else
+      value = getValue(aElement, "value");
+
+    switch (this.type) {
+    case "int":
+      return parseInt(value, 10) || 0;
+    case "bool":
+      return typeof(value) == "boolean" ? value : value == "true";
+    }
+    return value;
+  },
+
+  isElementEditable(aElement) {
+    switch (aElement.localName) {
+    case "checkbox":
+    case "colorpicker":
+    case "radiogroup":
+    case "textbox":
+    case "listitem":
+    case "listbox":
+    case "menulist":
+      return true;
+    }
+    return aElement.getAttribute("preference-editable") == "true";
+  },
+
+  updateElements() {
+    if (!this.id)
+      return;
+
+    // This "change" event handler tracks changes made to preferences by
+    // sources other than the user in this window.
+    var elements = document.getElementsByAttribute("preference", this.id);
+    for (var i = 0; i < elements.length; ++i)
+      this.setElementValue(elements[i]);
+  },
+
+  onchange() {
+    this.updateElements();
+  },
+
+  observe(aSubject, aTopic, aData) {
+    this.value = this.valueFromPreferences;
+  },
+
+});
+
+// Assign getters via Object.defineProperties, since Object.assign invokes them
+// and assigns their return values rather than assigning the getters themselves.
+Object.defineProperties(Preference.prototype, {
+  // TODO: remove this getter and the conditions that depend on it
+  // since instantApply is always true in this prefs implementation.
+  instantApply: {
+    get: function() {
+      return Preferences.instantApply;
+    },
+  },
+
+  name: {
+    get: function() {
+      return this._name;
+    },
+    set: function (val) {
+      if (val == this.name)
+        return val;
+
+      Preferences.rootBranchInternal.removeObserver(this.name, this);
+      this._name = val;
+      Preferences.rootBranchInternal.addObserver(val, this);
+
+      return val;
+    },
+  },
+
+  value: {
+    get: function() {
+      return this._value;
+    },
+    set: function (val) {
+      if (this.value !== val) {
+        this._value = val;
+        if (this.instantApply)
+          this.valueFromPreferences = val;
+        this.emit("change");
+      }
+      return val;
+    },
+  },
+
+  locked: {
+    get: function() {
+      return Preferences.rootBranch.prefIsLocked(this.name);
+    },
+  },
+
+  disabled: {
+    get: function() {
+      return this._disabled;
+    },
+    set: function (val) {
+      this._disabled = !!val;
+
+      if (!this.id)
+        return val;
+
+      var elements = document.getElementsByAttribute("preference", this.id);
+      for (var i = 0; i < elements.length; ++i) {
+        elements[i].disabled = val;
+
+        var labels = document.getElementsByAttribute("control", elements[i].id);
+        for (var j = 0; j < labels.length; ++j)
+          labels[j].disabled = val;
+      }
+
+      return val;
+    },
+  },
+
+  defaultValue: {
+    get: function() {
+      this._useDefault = true;
+      var val = this.valueFromPreferences;
+      this._useDefault = false;
+      return val;
+    },
+  },
+
+  _branch: {
+    get: function() {
+      return this._useDefault ? Preferences.defaultBranch : Preferences.rootBranch;
+    },
+  },
+
+  valueFromPreferences: {
+    get: function() {
+      try {
+        // Force a resync of value with preferences.
+        switch (this.type) {
+        case "int":
+          return this._branch.getIntPref(this.name);
+        case "bool":
+          var val = this._branch.getBoolPref(this.name);
+          return this.inverted ? !val : val;
+        case "wstring":
+          return this._branch
+                     .getComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString)
+                     .data;
+        case "string":
+        case "unichar":
+          return this._branch.getStringPref(this.name);
+        case "fontname":
+          var family = this._branch.getStringPref(this.name);
+          var fontEnumerator = Components.classes["@mozilla.org/gfx/fontenumerator;1"]
+                                         .createInstance(Components.interfaces.nsIFontEnumerator);
+          return fontEnumerator.getStandardFamilyName(family);
+        case "file":
+          var f = this._branch
+                      .getComplexValue(this.name, Components.interfaces.nsILocalFile);
+          return f;
+        default:
+          this._reportUnknownType();
+        }
+      } catch (e) { }
+      return null;
+    },
+
+    set: function (val) {
+      // Exit early if nothing to do.
+      if (this.readonly || this.valueFromPreferences == val)
+        return val;
+
+      // The special value undefined means 'reset preference to default'.
+      if (val === undefined) {
+        Preferences.rootBranch.clearUserPref(this.name);
+        return val;
+      }
+
+      // Force a resync of preferences with value.
+      switch (this.type) {
+      case "int":
+        Preferences.rootBranch.setIntPref(this.name, val);
+        break;
+      case "bool":
+        Preferences.rootBranch.setBoolPref(this.name, this.inverted ? !val : val);
+        break;
+      case "wstring":
+        var pls = Components.classes["@mozilla.org/pref-localizedstring;1"]
+                            .createInstance(Components.interfaces.nsIPrefLocalizedString);
+        pls.data = val;
+        Preferences.rootBranch
+            .setComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString, pls);
+        break;
+      case "string":
+      case "unichar":
+      case "fontname":
+        Preferences.rootBranch.setStringPref(this.name, val);
+        break;
+      case "file":
+        var lf;
+        if (typeof(val) == "string") {
+          lf = Components.classes["@mozilla.org/file/local;1"]
+                         .createInstance(Components.interfaces.nsILocalFile);
+          lf.persistentDescriptor = val;
+          if (!lf.exists())
+            lf.initWithPath(val);
+        } else
+          lf = val.QueryInterface(Components.interfaces.nsILocalFile);
+        Preferences.rootBranch
+            .setComplexValue(this.name, Components.interfaces.nsILocalFile, lf);
+        break;
+      default:
+        this._reportUnknownType();
+      }
+      if (!this.batching) {
+        var psvc = Components.classes["@mozilla.org/preferences-service;1"]
+                             .getService(Components.interfaces.nsIPrefService);
+        psvc.savePrefFile(null);
+      }
+      return val;
+    },
+  },
+
+});
+
+const MainPrefPane = {
+  getPreferenceElement(aStartElement) {
+    var temp = aStartElement;
+    while (temp && temp.nodeType == Node.ELEMENT_NODE &&
+           !temp.hasAttribute("preference"))
+      temp = temp.parentNode;
+    return temp && temp.nodeType == Node.ELEMENT_NODE ?
+           temp : aStartElement;
+  },
+
+  get DeferredTask() {
+    let module = {};
+    Components.utils.import("resource://gre/modules/DeferredTask.jsm", module);
+    Object.defineProperty(this, "DeferredTask", {
+      configurable: true,
+      enumerable: true,
+      writable: true,
+      value: module.DeferredTask
+    });
+    return module.DeferredTask;
+  },
+
+  _deferredValueUpdate(aElement) {
+    delete aElement._deferredValueUpdateTask;
+    let prefID = aElement.getAttribute("preference");
+    let preference = window.Preferences.get(prefID);
+    let prefVal = preference.getElementValue(aElement);
+    preference.value = prefVal;
+    this._deferredValueUpdateElements.delete(aElement);
+  },
+
+  _deferredValueUpdateElements: new Set(),
+
+  _finalizeDeferredElements() {
+    for (let el of this._deferredValueUpdateElements) {
+      if (el._deferredValueUpdateTask) {
+        el._deferredValueUpdateTask.finalize();
+      }
+    }
+  },
+
+  userChangedValue(aElement) {
+    let element = this.getPreferenceElement(aElement);
+    if (element.hasAttribute("preference")) {
+      if (element.getAttribute("delayprefsave") != "true") {
+        var preference = Preferences.get(element.getAttribute("preference"));
+        var prefVal = preference.getElementValue(element);
+        preference.value = prefVal;
+      } else {
+        if (!element._deferredValueUpdateTask) {
+          element._deferredValueUpdateTask = new this.DeferredTask(this._deferredValueUpdate.bind(this, element), 1000);
+          this._deferredValueUpdateElements.add(element);
+        } else {
+          // Each time the preference is changed, restart the delay.
+          element._deferredValueUpdateTask.disarm();
+        }
+        element._deferredValueUpdateTask.arm();
+      }
+    }
+  },
+
+  onCommand(event) {
+    // This "command" event handler tracks changes made to preferences by
+    // the user in this window.
+    if (event.sourceEvent)
+      event = event.sourceEvent;
+    this.userChangedValue(event.target);
+  },
+
+  onSelect(event) {
+    // This "select" event handler tracks changes made to colorpicker
+    // preferences by the user in this window.
+    if (event.target.localName == "colorpicker")
+      this.userChangedValue(event.target);
+  },
+
+  onChange(event) {
+    // This "change" event handler tracks changes made to preferences by
+    // the user in this window.
+    this.userChangedValue(event.target);
+  },
+
+  onInput(event) {
+    // This "input" event handler tracks changes made to preferences by
+    // the user in this window.
+    this.userChangedValue(event.target);
+  },
+};
diff --git a/browser/components/preferences/in-content-new/preferences.xhtml b/browser/components/preferences/in-content-new/preferences.xhtml
--- a/browser/components/preferences/in-content-new/preferences.xhtml
+++ b/browser/components/preferences/in-content-new/preferences.xhtml
@@ -200,25 +200,25 @@
 
     <html:a class="help-button" target="_blank" aria-label="&helpButton2.label;">&helpButton2.label;</html:a>
 
     <vbox class="main-content" flex="1">
       <hbox pack="end">
         <textbox type="search" id="searchInput" placeholder="&searchInput.label;" hidden="true"
                  clickSelectsAll="true"/>
       </hbox>
-      <prefpane id="mainPrefPane">
+      <vbox id="mainPrefPane">
 #include searchResults.xhtml
 #include main.xhtml
 #include privacy.xhtml
 #include containers.xhtml
 #include advanced.xhtml
 #include applications.xhtml
 #include sync.xhtml
-      </prefpane>
+      </vbox>
     </vbox>
   </hbox>
 
   <stack id="dialogStack" hidden="true"/>
   <vbox id="dialogTemplate" class="dialogOverlay" align="center" pack="center" topmost="true" hidden="true">
     <groupbox class="dialogBox"
               orient="vertical"
               pack="end"
diff --git a/browser/components/preferences/in-content-new/privacy.js b/browser/components/preferences/in-content-new/privacy.js
--- a/browser/components/preferences/in-content-new/privacy.js
+++ b/browser/components/preferences/in-content-new/privacy.js
@@ -28,16 +28,107 @@ XPCOMUtils.defineLazyGetter(this, "Alert
     // This will throw if manualDoNotDisturb isn't implemented.
     alertsService.manualDoNotDisturb;
     return alertsService;
   } catch (ex) {
     return undefined;
   }
 });
 
+window.addEventListener("DOMContentLoaded", function() {
+  Preferences.addAll([
+    { id: "privacy.userContext.enabled", type: "bool" },
+
+    // Tracking
+    { id: "privacy.trackingprotection.enabled", type: "bool" },
+    { id: "privacy.trackingprotection.pbmode.enabled", type: "bool" },
+
+    // Button prefs
+    { id: "pref.privacy.disable_button.cookie_exceptions", type: "bool" },
+    { id: "pref.privacy.disable_button.view_cookies", type: "bool" },
+    { id: "pref.privacy.disable_button.change_blocklist", type: "bool" },
+    { id: "pref.privacy.disable_button.tracking_protection_exceptions", type: "bool" },
+
+    // Location Bar
+    { id: "browser.urlbar.autocomplete.enabled", type: "bool" },
+    { id: "browser.urlbar.suggest.bookmark", type: "bool" },
+    { id: "browser.urlbar.suggest.history", type: "bool" },
+    { id: "browser.urlbar.suggest.openpage", type: "bool" },
+
+    // History
+    { id: "places.history.enabled", type: "bool" },
+    { id: "browser.formfill.enable", type: "bool" },
+    { id: "privacy.history.custom", type: "bool" },
+    // Cookies
+    { id: "network.cookie.cookieBehavior", type: "int" },
+    { id: "network.cookie.lifetimePolicy", type: "int" },
+    { id: "network.cookie.blockFutureCookies", type: "bool" },
+    // Clear Private Data
+    { id: "privacy.sanitize.sanitizeOnShutdown", type: "bool" },
+    { id: "privacy.sanitize.timeSpan", type: "int" },
+    // Private Browsing
+    { id: "browser.privatebrowsing.autostart", type: "bool" },
+    // Do not track
+    { id: "privacy.donottrackheader.enabled", type: "bool" },
+
+    // DRM content
+    { id: "media.eme.enabled", type: "bool" },
+
+    // Popups
+    { id: "dom.disable_open_during_load", type: "bool" },
+    // Passwords
+    { id: "signon.rememberSignons", type: "bool" },
+
+    // Buttons
+    { id: "pref.privacy.disable_button.view_passwords", type: "bool" },
+    { id: "pref.privacy.disable_button.view_passwords_exceptions", type: "bool" },
+
+    /* Certificates tab
+     * security.default_personal_cert
+     *   - a string:
+     *       "Select Automatically"   select a certificate automatically when a site
+     *                                requests one
+     *       "Ask Every Time"         present a dialog to the user so he can select
+     *                                the certificate to use on a site which
+     *                                requests one
+     */
+    { id: "security.default_personal_cert", type: "string" },
+
+    { id: "security.disable_button.openCertManager", type: "bool" },
+
+    { id: "security.disable_button.openDeviceManager", type: "bool" },
+
+    { id: "security.OCSP.enabled", type: "int" },
+
+    // Add-ons, malware, phishing
+    { id: "xpinstall.whitelist.required", type: "bool" },
+
+    { id: "browser.safebrowsing.malware.enabled", type: "bool" },
+    { id: "browser.safebrowsing.phishing.enabled", type: "bool" },
+
+    { id: "browser.safebrowsing.downloads.enabled", type: "bool" },
+
+    { id: "urlclassifier.malwareTable", type: "string" },
+
+    { id: "browser.safebrowsing.downloads.remote.block_potentially_unwanted", type: "bool" },
+    { id: "browser.safebrowsing.downloads.remote.block_uncommon", type: "bool" },
+
+    // Network tab
+    { id: "browser.cache.disk.capacity", type: "int" },
+    { id: "browser.offline-apps.notify", type: "bool" },
+
+    { id: "browser.cache.disk.smart_size.enabled", type: "bool", inverted: "true" },
+
+    // Data Choices tab
+#ifdef MOZ_CRASHREPORTER
+    { id: "browser.crashReports.unsubmittedCheck.autoSubmit", type: "bool" },
+#endif
+  ]);
+}, { once: true, capture: true });
+
 var gPrivacyPane = {
   _pane: null,
 
   /**
    * Whether the use has selected the auto-start private browsing mode in the UI.
    */
   _autoStartPrivateBrowsing: false,
 
@@ -163,19 +254,19 @@ var gPrivacyPane = {
     this.updateHistoryModePane();
     this.updatePrivacyMicroControls();
     this.initAutoStartPrivateBrowsingReverter();
     this._initTrackingProtection();
     this._initTrackingProtectionPBM();
     this._initAutocomplete();
     this._initBrowserContainers();
 
-    setEventListener("privacy.sanitize.sanitizeOnShutdown", "change",
+    Preferences.get("privacy.sanitize.sanitizeOnShutdown").on("change",
                      gPrivacyPane._updateSanitizeSettingsButton);
-    setEventListener("browser.privatebrowsing.autostart", "change",
+    Preferences.get("browser.privatebrowsing.autostart").on("change",
                      gPrivacyPane.updatePrivacyMicroControls);
     setEventListener("historyMode", "command", function() {
       gPrivacyPane.updateHistoryModePane();
       gPrivacyPane.updateHistoryModePrefs();
       gPrivacyPane.updatePrivacyMicroControls();
       gPrivacyPane.updateAutostart();
     });
     setEventListener("historyRememberClear", "click", function() {
@@ -367,36 +458,36 @@ var gPrivacyPane = {
   },
 
   // TRACKING PROTECTION MODE
 
   /**
    * Selects the right item of the Tracking Protection radiogroup.
    */
   trackingProtectionReadPrefs() {
-    let enabledPref = document.getElementById("privacy.trackingprotection.enabled");
-    let pbmPref = document.getElementById("privacy.trackingprotection.pbmode.enabled");
+    let enabledPref = Preferences.get("privacy.trackingprotection.enabled");
+    let pbmPref = Preferences.get("privacy.trackingprotection.pbmode.enabled");
     let radiogroup = document.getElementById("trackingProtectionRadioGroup");
 
     // Global enable takes precedence over enabled in Private Browsing.
     if (enabledPref.value) {
       radiogroup.value = "always";
     } else if (pbmPref.value) {
       radiogroup.value = "private";
     } else {
       radiogroup.value = "never";
     }
   },
 
   /**
    * Sets the pref values based on the selected item of the radiogroup.
    */
   trackingProtectionWritePrefs() {
-    let enabledPref = document.getElementById("privacy.trackingprotection.enabled");
-    let pbmPref = document.getElementById("privacy.trackingprotection.pbmode.enabled");
+    let enabledPref = Preferences.get("privacy.trackingprotection.enabled");
+    let pbmPref = Preferences.get("privacy.trackingprotection.pbmode.enabled");
     let radiogroup = document.getElementById("trackingProtectionRadioGroup");
 
     switch (radiogroup.value) {
       case "always":
         enabledPref.value = true;
         pbmPref.value = true;
         break;
       case "private":
@@ -452,28 +543,28 @@ var gPrivacyPane = {
    * Check whether preferences values are set to keep history
    *
    * @param aPrefs an array of pref names to check for
    * @returns boolean true if all of the prefs are set to keep history,
    *                  false otherwise
    */
   _checkHistoryValues(aPrefs) {
     for (let pref of Object.keys(aPrefs)) {
-      if (document.getElementById(pref).value != aPrefs[pref])
+      if (Preferences.get(pref).value != aPrefs[pref])
         return false;
     }
     return true;
   },
 
   /**
    * Initialize the history mode menulist based on the privacy preferences
    */
   initializeHistoryMode() {
     let mode;
-    let getVal = aPref => document.getElementById(aPref).value;
+    let getVal = aPref => Preferences.get(aPref).value;
 
     if (getVal("privacy.history.custom"))
       mode = "custom";
     else if (this._checkHistoryValues(this.prefsForKeepingHistory)) {
       if (getVal("browser.privatebrowsing.autostart"))
         mode = "dontremember";
       else
         mode = "remember";
@@ -495,43 +586,43 @@ var gPrivacyPane = {
     case "dontremember":
       selectedIndex = 1;
       break;
     case "custom":
       selectedIndex = 2;
       break;
     }
     document.getElementById("historyPane").selectedIndex = selectedIndex;
-    document.getElementById("privacy.history.custom").value = selectedIndex == 2;
+    Preferences.get("privacy.history.custom").value = selectedIndex == 2;
   },
 
   /**
    * Update the private browsing auto-start pref and the history mode
    * micro-management prefs based on the history mode menulist
    */
   updateHistoryModePrefs() {
-    let pref = document.getElementById("browser.privatebrowsing.autostart");
+    let pref = Preferences.get("browser.privatebrowsing.autostart");
     switch (document.getElementById("historyMode").value) {
     case "remember":
       if (pref.value)
         pref.value = false;
 
       // select the remember history option if needed
-      document.getElementById("places.history.enabled").value = true;
+      Preferences.get("places.history.enabled").value = true;
 
       // select the remember forms history option
-      document.getElementById("browser.formfill.enable").value = true;
+      Preferences.get("browser.formfill.enable").value = true;
 
       // select the allow cookies option
-      document.getElementById("network.cookie.cookieBehavior").value = 0;
+      Preferences.get("network.cookie.cookieBehavior").value = 0;
       // select the cookie lifetime policy option
-      document.getElementById("network.cookie.lifetimePolicy").value = 0;
+      Preferences.get("network.cookie.lifetimePolicy").value = 0;
 
       // select the clear on close option
-      document.getElementById("privacy.sanitize.sanitizeOnShutdown").value = false;
+      Preferences.get("privacy.sanitize.sanitizeOnShutdown").value = false;
       break;
     case "dontremember":
       if (!pref.value)
         pref.value = true;
       break;
     }
   },
 
@@ -549,39 +640,39 @@ var gPrivacyPane = {
         if (!preferenceId) {
           let dependentControlId = control.getAttribute("control");
           if (dependentControlId) {
             let dependentControl = document.getElementById(dependentControlId);
             preferenceId = dependentControl.getAttribute("preference");
           }
         }
 
-        let preference = preferenceId ? document.getElementById(preferenceId) : {};
+        let preference = preferenceId ? Preferences.get(preferenceId) : {};
         control.disabled = disabled || preference.locked;
       });
 
       // adjust the cookie controls status
       this.readAcceptCookies();
-      let lifetimePolicy = document.getElementById("network.cookie.lifetimePolicy").value;
+      let lifetimePolicy = Preferences.get("network.cookie.lifetimePolicy").value;
       if (lifetimePolicy != Ci.nsICookieService.ACCEPT_NORMALLY &&
           lifetimePolicy != Ci.nsICookieService.ACCEPT_SESSION &&
           lifetimePolicy != Ci.nsICookieService.ACCEPT_FOR_N_DAYS) {
         lifetimePolicy = Ci.nsICookieService.ACCEPT_NORMALLY;
       }
       document.getElementById("keepCookiesUntil").value = disabled ? 2 : lifetimePolicy;
 
       // adjust the checked state of the sanitizeOnShutdown checkbox
       document.getElementById("alwaysClear").checked = disabled ? false :
-        document.getElementById("privacy.sanitize.sanitizeOnShutdown").value;
+        Preferences.get("privacy.sanitize.sanitizeOnShutdown").value;
 
       // adjust the checked state of the remember history checkboxes
       document.getElementById("rememberHistory").checked = disabled ? false :
-        document.getElementById("places.history.enabled").value;
+        Preferences.get("places.history.enabled").value;
       document.getElementById("rememberForms").checked = disabled ? false :
-        document.getElementById("browser.formfill.enable").value;
+        Preferences.get("browser.formfill.enable").value;
 
       if (!disabled) {
         // adjust the Settings button for sanitizeOnShutdown
         this._updateSanitizeSettingsButton();
       }
     }
   },
 
@@ -597,17 +688,17 @@ var gPrivacyPane = {
     this._lastCheckState = autoStart.hasAttribute("checked");
   },
 
   _lastMode: null,
   _lastCheckState: null,
   updateAutostart() {
       let mode = document.getElementById("historyMode");
       let autoStart = document.getElementById("privateBrowsingAutoStart");
-      let pref = document.getElementById("browser.privatebrowsing.autostart");
+      let pref = Preferences.get("browser.privatebrowsing.autostart");
       if ((mode.value == "custom" && this._lastCheckState == autoStart.checked) ||
           (mode.value == "remember" && !this._lastCheckState) ||
           (mode.value == "dontremember" && this._lastCheckState)) {
           // These are all no-op changes, so we don't need to prompt.
           this._lastMode = mode.selectedIndex;
           this._lastCheckState = autoStart.hasAttribute("checked");
           return;
       }
@@ -716,17 +807,17 @@ var gPrivacyPane = {
    */
 
   /**
    * Reads the network.cookie.cookieBehavior preference value and
    * enables/disables the rest of the cookie UI accordingly, returning true
    * if cookies are enabled.
    */
   readAcceptCookies() {
-    var pref = document.getElementById("network.cookie.cookieBehavior");
+    var pref = Preferences.get("network.cookie.cookieBehavior");
     var acceptThirdPartyLabel = document.getElementById("acceptThirdPartyLabel");
     var acceptThirdPartyMenu = document.getElementById("acceptThirdPartyMenu");
     var keepUntil = document.getElementById("keepUntil");
     var menu = document.getElementById("keepCookiesUntil");
 
     // enable the rest of the UI for anything other than "disable all cookies"
     var acceptCookies = (pref.value != 2);
 
@@ -750,17 +841,17 @@ var gPrivacyPane = {
 
     return accept.checked ? 0 : 2;
   },
 
   /**
    * Converts between network.cookie.cookieBehavior and the third-party cookie UI
    */
   readAcceptThirdPartyCookies() {
-    var pref = document.getElementById("network.cookie.cookieBehavior");
+    var pref = Preferences.get("network.cookie.cookieBehavior");
     switch (pref.value) {
       case 0:
         return "always";
       case 1:
         return "never";
       case 2:
         return "never";
       case 3:
@@ -848,17 +939,17 @@ var gPrivacyPane = {
   },
 
   /**
    * Enables or disables the "Settings..." button depending
    * on the privacy.sanitize.sanitizeOnShutdown preference value
    */
   _updateSanitizeSettingsButton() {
     var settingsButton = document.getElementById("clearDataSettings");
-    var sanitizeOnShutdownPref = document.getElementById("privacy.sanitize.sanitizeOnShutdown");
+    var sanitizeOnShutdownPref = Preferences.get("privacy.sanitize.sanitizeOnShutdown");
 
     settingsButton.disabled = !sanitizeOnShutdownPref.value;
    },
 
   // CONTAINERS
 
   /*
    * preferences:
@@ -866,17 +957,17 @@ var gPrivacyPane = {
    * privacy.userContext.enabled
    * - true if containers is enabled
    */
 
    /**
     * Enables/disables the Settings button used to configure containers
     */
    readBrowserContainersCheckbox() {
-     var pref = document.getElementById("privacy.userContext.enabled");
+     var pref = Preferences.get("privacy.userContext.enabled");
      var settings = document.getElementById("browserContainersSettings");
 
      settings.disabled = !pref.value;
    },
 
    toggleDoNotDisturbNotifications(event) {
      AlertsServiceDND.manualDoNotDisturb = event.target.checked;
    },
@@ -923,17 +1014,17 @@ var gPrivacyPane = {
    // UTILITY FUNCTIONS
 
   /**
    * Utility function to enable/disable the button specified by aButtonID based
    * on the value of the Boolean preference specified by aPreferenceID.
    */
   updateButtons(aButtonID, aPreferenceID) {
     var button = document.getElementById(aButtonID);
-    var preference = document.getElementById(aPreferenceID);
+    var preference = Preferences.get(aPreferenceID);
     button.disabled = preference.value != true;
     return undefined;
   },
 
   // BEGIN UI CODE
 
   /*
    * Preferences:
@@ -1043,17 +1134,17 @@ var gPrivacyPane = {
   },
 
   /**
    * Enables/disables the Exceptions button used to configure sites where
    * passwords are never saved. When browser is set to start in Private
    * Browsing mode, the "Remember passwords" UI is useless, so we disable it.
    */
   readSavePasswords() {
-    var pref = document.getElementById("signon.rememberSignons");
+    var pref = Preferences.get("signon.rememberSignons");
     var excepts = document.getElementById("passwordExceptions");
 
     if (PrivateBrowsingUtils.permanentPrivateBrowsing) {
       document.getElementById("savePasswords").disabled = true;
       excepts.disabled = true;
       return false;
     }
     excepts.disabled = !pref.value;
@@ -1061,38 +1152,38 @@ var gPrivacyPane = {
     return undefined;
   },
 
   /**
    * Enables/disables the add-ons Exceptions button depending on whether
    * or not add-on installation warnings are displayed.
    */
   readWarnAddonInstall() {
-    var warn = document.getElementById("xpinstall.whitelist.required");
+    var warn = Preferences.get("xpinstall.whitelist.required");
     var exceptions = document.getElementById("addonExceptions");
 
     exceptions.disabled = !warn.value;
 
     // don't override the preference value
     return undefined;
   },
 
   _initSafeBrowsing() {
     let enableSafeBrowsing = document.getElementById("enableSafeBrowsing");
     let blockDownloads = document.getElementById("blockDownloads");
     let blockUncommonUnwanted = document.getElementById("blockUncommonUnwanted");
 
-    let safeBrowsingPhishingPref = document.getElementById("browser.safebrowsing.phishing.enabled");
-    let safeBrowsingMalwarePref = document.getElementById("browser.safebrowsing.malware.enabled");
+    let safeBrowsingPhishingPref = Preferences.get("browser.safebrowsing.phishing.enabled");
+    let safeBrowsingMalwarePref = Preferences.get("browser.safebrowsing.malware.enabled");
 
-    let blockDownloadsPref = document.getElementById("browser.safebrowsing.downloads.enabled");
-    let malwareTable = document.getElementById("urlclassifier.malwareTable");
+    let blockDownloadsPref = Preferences.get("browser.safebrowsing.downloads.enabled");
+    let malwareTable = Preferences.get("urlclassifier.malwareTable");
 
-    let blockUnwantedPref = document.getElementById("browser.safebrowsing.downloads.remote.block_potentially_unwanted");
-    let blockUncommonPref = document.getElementById("browser.safebrowsing.downloads.remote.block_uncommon");
+    let blockUnwantedPref = Preferences.get("browser.safebrowsing.downloads.remote.block_potentially_unwanted");
+    let blockUncommonPref = Preferences.get("browser.safebrowsing.downloads.remote.block_uncommon");
 
     enableSafeBrowsing.addEventListener("command", function() {
       safeBrowsingPhishingPref.value = enableSafeBrowsing.checked;
       safeBrowsingMalwarePref.value = enableSafeBrowsing.checked;
 
       if (enableSafeBrowsing.checked) {
         blockDownloads.removeAttribute("disabled");
         if (blockDownloads.checked) {
@@ -1185,17 +1276,17 @@ var gPrivacyPane = {
    * values for "security.OCSP.enabled" are:
    * 0: fetching is disabled
    * 1: fetch for all certificates
    * 2: fetch only for EV certificates
    * Hence, if "security.OCSP.enabled" is non-zero, the checkbox should be
    * checked. Otherwise, it should be unchecked.
    */
   readEnableOCSP() {
-    var preference = document.getElementById("security.OCSP.enabled");
+    var preference = Preferences.get("security.OCSP.enabled");
     // This is the case if the preference is the default value.
     if (preference.value === undefined) {
       return true;
     }
     return preference.value != 0;
   },
 
   /**
@@ -1336,47 +1427,47 @@ var gPrivacyPane = {
     document.getElementById("useCacheBefore").disabled = smartSizeEnabled;
     document.getElementById("cacheSize").disabled = smartSizeEnabled;
     document.getElementById("useCacheAfter").disabled = smartSizeEnabled;
   },
 
   readSmartSizeEnabled() {
     // The smart_size.enabled preference element is inverted="true", so its
     // value is the opposite of the actual pref value
-    var disabled = document.getElementById("browser.cache.disk.smart_size.enabled").value;
+    var disabled = Preferences.get("browser.cache.disk.smart_size.enabled").value;
     this.updateCacheSizeUI(!disabled);
   },
 
   /**
    * Converts the cache size from units of KB to units of MB and stores it in
    * the textbox element.
    *
    * Preferences:
    *
    * browser.cache.disk.capacity
    * - the size of the browser cache in KB
    * - Only used if browser.cache.disk.smart_size.enabled is disabled
    */
   updateCacheSizeInputField() {
     let cacheSizeElem = document.getElementById("cacheSize");
-    let cachePref = document.getElementById("browser.cache.disk.capacity");
+    let cachePref = Preferences.get("browser.cache.disk.capacity");
     cacheSizeElem.value = cachePref.value / 1024;
     if (cachePref.locked)
       cacheSizeElem.disabled = true;
   },
 
   /**
    * Updates the cache size preference once user enters a new value.
    * We intentionally do not set preference="browser.cache.disk.capacity"
    * onto the textbox directly, as that would update the pref at each keypress
    * not only after the final value is entered.
    */
   updateCacheSizePref() {
     let cacheSizeElem = document.getElementById("cacheSize");
-    let cachePref = document.getElementById("browser.cache.disk.capacity");
+    let cachePref = Preferences.get("browser.cache.disk.capacity");
     // Converts the cache size as specified in UI (in MB) to KB.
     let intValue = parseInt(cacheSizeElem.value, 10);
     cachePref.value = isNaN(intValue) ? 0 : intValue * 1024;
   },
 
   clearSiteData() {
     let flags =
       Services.prompt.BUTTON_TITLE_IS_STRING * Services.prompt.BUTTON_POS_0 +
@@ -1508,17 +1599,17 @@ var gPrivacyPane = {
         Components.classes["@mozilla.org/netwerk/cache-storage-service;1"]
                   .getService(Components.interfaces.nsICacheStorageService);
       var storage = cacheService.appCacheStorage(LoadContextInfo.default, null);
       storage.asyncVisitStorage(visitor, false);
     } catch (e) {}
   },
 
   readOfflineNotify() {
-    var pref = document.getElementById("browser.offline-apps.notify");
+    var pref = Preferences.get("browser.offline-apps.notify");
     var button = document.getElementById("offlineNotifyExceptions");
     button.disabled = !pref.value;
     return pref.value;
   },
 
   // XXX: duplicated in browser.js
   _getOfflineAppUsage(perm, groups) {
     let cacheService = Cc["@mozilla.org/network/application-cache-service;1"].
diff --git a/browser/components/preferences/in-content-new/privacy.xhtml b/browser/components/preferences/in-content-new/privacy.xhtml
--- a/browser/components/preferences/in-content-new/privacy.xhtml
+++ b/browser/components/preferences/in-content-new/privacy.xhtml
@@ -2,182 +2,16 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <!-- Privacy panel -->
 
 <html:script 
         src="chrome://browser/content/preferences/in-content-new/privacy.js"></html:script>
 
-<preferences id="privacyPreferences" hidden="true" data-category="panePrivacy">
-
-  <!-- Tracking -->
-  <preference id="privacy.trackingprotection.enabled"
-              name="privacy.trackingprotection.enabled"
-              type="bool"/>
-  <preference id="privacy.trackingprotection.pbmode.enabled"
-              name="privacy.trackingprotection.pbmode.enabled"
-              type="bool"/>
-
-  <!-- XXX button prefs -->
-  <preference id="pref.privacy.disable_button.cookie_exceptions"
-              name="pref.privacy.disable_button.cookie_exceptions"
-              type="bool"/>
-  <preference id="pref.privacy.disable_button.view_cookies"
-              name="pref.privacy.disable_button.view_cookies"
-              type="bool"/>
-  <preference id="pref.privacy.disable_button.change_blocklist"
-              name="pref.privacy.disable_button.change_blocklist"
-              type="bool"/>
-  <preference id="pref.privacy.disable_button.tracking_protection_exceptions"
-              name="pref.privacy.disable_button.tracking_protection_exceptions"
-              type="bool"/>
-
-  <!-- Location Bar -->
-  <preference id="browser.urlbar.autocomplete.enabled"
-              name="browser.urlbar.autocomplete.enabled"
-              type="bool"/>
-  <preference id="browser.urlbar.suggest.bookmark"
-              name="browser.urlbar.suggest.bookmark"
-              type="bool"/>
-  <preference id="browser.urlbar.suggest.history"
-              name="browser.urlbar.suggest.history"
-              type="bool"/>
-  <preference id="browser.urlbar.suggest.openpage"
-              name="browser.urlbar.suggest.openpage"
-              type="bool"/>
-
-  <!-- History -->
-  <preference id="places.history.enabled"
-              name="places.history.enabled"
-              type="bool"/>
-  <preference id="browser.formfill.enable"
-              name="browser.formfill.enable"
-              type="bool"/>
-  <preference id="privacy.history.custom"
-              name="privacy.history.custom"
-              type="bool"/>
-  <!-- Cookies -->
-  <preference id="network.cookie.cookieBehavior"
-              name="network.cookie.cookieBehavior"
-              type="int"/>
-  <preference id="network.cookie.lifetimePolicy"
-              name="network.cookie.lifetimePolicy"
-              type="int"/>
-  <preference id="network.cookie.blockFutureCookies"
-              name="network.cookie.blockFutureCookies"
-              type="bool"/>
-  <!-- Clear Private Data -->
-  <preference id="privacy.sanitize.sanitizeOnShutdown"
-              name="privacy.sanitize.sanitizeOnShutdown"
-              type="bool"/>
-  <preference id="privacy.sanitize.timeSpan"
-              name="privacy.sanitize.timeSpan"
-              type="int"/>
-  <!-- Private Browsing -->
-  <preference id="browser.privatebrowsing.autostart"
-              name="browser.privatebrowsing.autostart"
-              type="bool"/>
-  <!-- Do not track -->
-  <preference id="privacy.donottrackheader.enabled"
-              name="privacy.donottrackheader.enabled"
-              type="bool"/>
-  <!-- DRM content -->
-  <preference id="media.eme.enabled"
-              name="media.eme.enabled"
-              type="bool"/>
-
-  <!-- Popups -->
-  <preference id="dom.disable_open_during_load"
-              name="dom.disable_open_during_load"
-              type="bool"/>
-  <!-- Passwords -->
-  <preference id="signon.rememberSignons" name="signon.rememberSignons" type="bool"/>
-
-  <!-- XXX buttons -->
-  <preference id="pref.privacy.disable_button.view_passwords"
-              name="pref.privacy.disable_button.view_passwords"
-              type="bool"/>
-  <preference id="pref.privacy.disable_button.view_passwords_exceptions"
-              name="pref.privacy.disable_button.view_passwords_exceptions"
-              type="bool"/>
-
-  <!-- Certificates tab
-   * security.default_personal_cert
-     - a string:
-         "Select Automatically"   select a certificate automatically when a site
-                                  requests one
-         "Ask Every Time"         present a dialog to the user so he can select
-                                  the certificate to use on a site which
-                                  requests one -->
-  <preference id="security.default_personal_cert"
-              name="security.default_personal_cert"
-              type="string"/>
-
-  <preference id="security.disable_button.openCertManager"
-              name="security.disable_button.openCertManager"
-              type="bool"/>
-
-  <preference id="security.disable_button.openDeviceManager"
-              name="security.disable_button.openDeviceManager"
-              type="bool"/>
-
-  <preference id="security.OCSP.enabled"
-              name="security.OCSP.enabled"
-              type="int"/>
-
-  <!-- Add-ons, malware, phishing -->
-  <preference id="xpinstall.whitelist.required"
-              name="xpinstall.whitelist.required"
-              type="bool"/>
-
-  <preference id="browser.safebrowsing.malware.enabled"
-              name="browser.safebrowsing.malware.enabled"
-              type="bool"/>
-  <preference id="browser.safebrowsing.phishing.enabled"
-              name="browser.safebrowsing.phishing.enabled"
-              type="bool"/>
-
-  <preference id="browser.safebrowsing.downloads.enabled"
-              name="browser.safebrowsing.downloads.enabled"
-              type="bool"/>
-
-  <preference id="urlclassifier.malwareTable"
-              name="urlclassifier.malwareTable"
-              type="string"/>
-
-  <preference id="browser.safebrowsing.downloads.remote.block_potentially_unwanted"
-              name="browser.safebrowsing.downloads.remote.block_potentially_unwanted"
-              type="bool"/>
-  <preference id="browser.safebrowsing.downloads.remote.block_uncommon"
-              name="browser.safebrowsing.downloads.remote.block_uncommon"
-              type="bool"/>
-
-  <!-- Network tab -->
-  <preference id="browser.cache.disk.capacity"
-              name="browser.cache.disk.capacity"
-              type="int"/>
-  <preference id="browser.offline-apps.notify"
-              name="browser.offline-apps.notify"
-              type="bool"/>
-
-  <preference id="browser.cache.disk.smart_size.enabled"
-              name="browser.cache.disk.smart_size.enabled"
-              inverted="true"
-              type="bool"/>
-
-  <!-- Data Choices tab -->
-#ifdef MOZ_CRASHREPORTER
-  <preference id="browser.crashReports.unsubmittedCheck.autoSubmit"
-              name="browser.crashReports.unsubmittedCheck.autoSubmit"
-              type="bool"/>
-#endif
-
-</preferences>
-
 <stringbundle id="bundlePreferences" src="chrome://browser/locale/preferences/preferences.properties"/>
 <stringbundle id="signonBundle" src="chrome://passwordmgr/locale/passwordmgr.properties"/>
 
 <hbox id="header-privacy"
       class="header"
       hidden="true"
       data-category="panePrivacy">
   <label class="header-name" flex="1">&panePrivacySecurity.title;</label>
diff --git a/browser/components/preferences/in-content-new/sync.js b/browser/components/preferences/in-content-new/sync.js
--- a/browser/components/preferences/in-content-new/sync.js
+++ b/browser/components/preferences/in-content-new/sync.js
@@ -20,20 +20,28 @@ const FXA_PAGE_LOGGED_IN = 1;
 // Indexes into the "login status" deck.
 // We are in a successful verified state - everything should work!
 const FXA_LOGIN_VERIFIED = 0;
 // We have logged in to an unverified account.
 const FXA_LOGIN_UNVERIFIED = 1;
 // We are logged in locally, but the server rejected our credentials.
 const FXA_LOGIN_FAILED = 2;
 
+window.addEventListener("DOMContentLoaded", function() {
+  Preferences.addAll([
+    { id: "engine.addons", name: "services.sync.engine.addons", type: "bool" },
+    { id: "engine.bookmarks", name: "services.sync.engine.bookmarks", type: "bool" },
+    { id: "engine.history", name: "services.sync.engine.history", type: "bool" },
+    { id: "engine.tabs", name: "services.sync.engine.tabs", type: "bool" },
+    { id: "engine.prefs", name: "services.sync.engine.prefs", type: "bool" },
+    { id: "engine.passwords", name: "services.sync.engine.passwords", type: "bool" },
+  ]);
+}, { once: true, capture: true });
+
 var gSyncPane = {
-  prefArray: ["engine.bookmarks", "engine.passwords", "engine.prefs",
-              "engine.tabs", "engine.history"],
-
   get page() {
     return document.getElementById("weavePrefsDeck").selectedIndex;
   },
 
   set page(val) {
     document.getElementById("weavePrefsDeck").selectedIndex = val;
   },
 
diff --git a/browser/components/preferences/in-content-new/sync.xhtml b/browser/components/preferences/in-content-new/sync.xhtml
old mode 100755
new mode 100644
--- a/browser/components/preferences/in-content-new/sync.xhtml
+++ b/browser/components/preferences/in-content-new/sync.xhtml
@@ -1,35 +1,14 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <!-- Sync panel -->
 
-<preferences id="syncEnginePrefs" hidden="true" data-category="paneSync">
-  <preference id="engine.addons"
-              name="services.sync.engine.addons"
-              type="bool"/>
-  <preference id="engine.bookmarks"
-              name="services.sync.engine.bookmarks"
-              type="bool"/>
-  <preference id="engine.history"
-              name="services.sync.engine.history"
-              type="bool"/>
-  <preference id="engine.tabs"
-              name="services.sync.engine.tabs"
-              type="bool"/>
-  <preference id="engine.prefs"
-              name="services.sync.engine.prefs"
-              type="bool"/>
-  <preference id="engine.passwords"
-              name="services.sync.engine.passwords"
-              type="bool"/>
-</preferences>
-
 <html:script 
         src="chrome://browser/content/preferences/in-content-new/sync.js"></html:script>
 
 <hbox id="header-sync"
       class="header"
       hidden="true"
       data-category="paneSync">
   <label class="header-name" flex="1">&paneSync1.title;</label>
diff --git a/browser/components/preferences/in-content-new/tests/browser_basic_rebuild_fonts_test.js b/browser/components/preferences/in-content-new/tests/browser_basic_rebuild_fonts_test.js
--- a/browser/components/preferences/in-content-new/tests/browser_basic_rebuild_fonts_test.js
+++ b/browser/components/preferences/in-content-new/tests/browser_basic_rebuild_fonts_test.js
@@ -2,18 +2,19 @@ Services.prefs.setBoolPref("browser.pref
 
 registerCleanupFunction(function() {
   Services.prefs.clearUserPref("browser.preferences.instantApply");
 });
 
 add_task(async function() {
   await openPreferencesViaOpenPreferencesAPI("paneGeneral", {leaveOpen: true});
   let doc = gBrowser.contentDocument;
+  let contentWindow = gBrowser.contentWindow;
   var langGroup = Services.prefs.getComplexValue("font.language.group", Ci.nsIPrefLocalizedString).data
-  is(doc.getElementById("font.language.group").value, langGroup,
+  is(contentWindow.Preferences.get("font.language.group").value, langGroup,
      "Language group should be set correctly.");
 
   let defaultFontType = Services.prefs.getCharPref("font.default." + langGroup);
   let fontFamily = Services.prefs.getCharPref("font.name." + defaultFontType + "." + langGroup);
   let fontFamilyField = doc.getElementById("defaultFont");
   is(fontFamilyField.value, fontFamily, "Font family should be set correctly.");
 
   let defaultFontSize = Services.prefs.getIntPref("font.size.variable." + langGroup);
diff --git a/browser/components/preferences/in-content-new/tests/browser_sanitizeOnShutdown_prefLocked.js b/browser/components/preferences/in-content-new/tests/browser_sanitizeOnShutdown_prefLocked.js
--- a/browser/components/preferences/in-content-new/tests/browser_sanitizeOnShutdown_prefLocked.js
+++ b/browser/components/preferences/in-content-new/tests/browser_sanitizeOnShutdown_prefLocked.js
@@ -8,17 +8,17 @@ function switchToCustomHistoryMode(doc) 
 }
 
 function testPrefStateMatchesLockedState() {
   let win = gBrowser.contentWindow;
   let doc = win.document;
   switchToCustomHistoryMode(doc);
 
   let checkbox = doc.getElementById("alwaysClear");
-  let preference = doc.getElementById("privacy.sanitize.sanitizeOnShutdown");
+  let preference = win.Preferences.get("privacy.sanitize.sanitizeOnShutdown");
   is(checkbox.disabled, preference.locked, "Always Clear checkbox should be enabled when preference is not locked.");
 
   Services.prefs.clearUserPref("privacy.history.custom");
   gBrowser.removeCurrentTab();
 }
 
 add_task(function setup() {
   registerCleanupFunction(function resetPreferences() {
diff --git a/browser/components/preferences/in-content-new/tests/head.js b/browser/components/preferences/in-content-new/tests/head.js
--- a/browser/components/preferences/in-content-new/tests/head.js
+++ b/browser/components/preferences/in-content-new/tests/head.js
@@ -25,22 +25,22 @@ function is_hidden(aElement) {
   if (aElement.parentNode != aElement.ownerDocument)
     return is_hidden(aElement.parentNode);
 
   return false;
 }
 
 function is_element_visible(aElement, aMsg) {
   isnot(aElement, null, "Element should not be null, when checking visibility");
-  ok(!is_hidden(aElement), aMsg);
+  ok(!is_hidden(aElement), `<${aElement.tagName} id="${aElement.id}"> ${aMsg}`);
 }
 
 function is_element_hidden(aElement, aMsg) {
   isnot(aElement, null, "Element should not be null, when checking visibility");
-  ok(is_hidden(aElement), aMsg);
+  ok(is_hidden(aElement), `<${aElement.tagName} id="${aElement.id}"> ${aMsg}`);
 }
 
 function open_preferences(aCallback) {
   gBrowser.selectedTab = BrowserTestUtils.addTab(gBrowser, "about:preferences");
   let newTabBrowser = gBrowser.getBrowserForTab(gBrowser.selectedTab);
   newTabBrowser.addEventListener("Initialized", function() {
     aCallback(gBrowser.contentWindow);
   }, {capture: true, once: true});
diff --git a/browser/components/preferences/in-content-new/tests/privacypane_tests_perwindow.js b/browser/components/preferences/in-content-new/tests/privacypane_tests_perwindow.js
--- a/browser/components/preferences/in-content-new/tests/privacypane_tests_perwindow.js
+++ b/browser/components/preferences/in-content-new/tests/privacypane_tests_perwindow.js
@@ -306,23 +306,23 @@ function test_locbar_suggestion_retentio
     is(Services.prefs.getBoolPref("browser.urlbar.autocomplete.enabled"), autocomplete,
        "browser.urlbar.autocomplete.enabled pref should be " + autocomplete);
   };
 }
 
 const gPrefCache = new Map();
 
 function cache_preferences(win) {
-  let prefs = win.document.querySelectorAll("#privacyPreferences > preference");
+  let prefs = win.Preferences.getAll();
   for (let pref of prefs)
     gPrefCache.set(pref.name, pref.value);
 }
 
 function reset_preferences(win) {
-  let prefs = win.document.querySelectorAll("#privacyPreferences > preference");
+  let prefs = win.Preferences.getAll();
   for (let pref of prefs)
     pref.value = gPrefCache.get(pref.name);
 }
 
 function run_test_subset(subset) {
   info("subset: " + Array.from(subset, x => x.name).join(",") + "\n");
   SpecialPowers.pushPrefEnv({"set": [["browser.preferences.instantApply", true]]});
 
diff --git a/browser/themes/linux/preferences/preferences.css b/browser/themes/linux/preferences/preferences.css
--- a/browser/themes/linux/preferences/preferences.css
+++ b/browser/themes/linux/preferences/preferences.css
@@ -1,15 +1,20 @@
 /*
 # -*- Mode: Java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
 
+/* Main Pref Pane */
+#mainPrefPane {
+  padding: 8px;
+}
+
 /* General Pane */
 #useFirefoxSync,
 #getStarted {
   font-size: 90%;
 }
 
 #isNotDefaultLabel {
   font-weight: bold;
diff --git a/browser/themes/osx/preferences/preferences.css b/browser/themes/osx/preferences/preferences.css
--- a/browser/themes/osx/preferences/preferences.css
+++ b/browser/themes/osx/preferences/preferences.css
@@ -10,30 +10,33 @@
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 @namespace html url("http://www.w3.org/1999/xhtml");
 
 .windowDialog {
   padding: 12px;
   font: -moz-dialog;
 }
 
-/* ----- APPLICATIONS PREFPANE ----- */
 description {
   font: small-caption;
   font-weight: normal;
   line-height: 1.3em;
   margin-bottom: 4px !important;
 }
 
-prefpane .groupbox-body {
+#mainPrefPane {
+  padding: 12px 12px 0 12px;
+}
+
+#mainPrefPane .groupbox-body {
   -moz-appearance: none;
   padding: 8px 4px 4px 4px;
 }
 
-prefpane .groupbox-title {
+#mainPrefPane .groupbox-title {
   background: url("chrome://global/skin/50pct_transparent_grey.png") repeat-x bottom left;
   margin-bottom: 4px;
 }
 
 tabpanels {
   padding: 20px 7px 7px;
 }
 
diff --git a/browser/themes/windows/preferences/preferences.css b/browser/themes/windows/preferences/preferences.css
--- a/browser/themes/windows/preferences/preferences.css
+++ b/browser/themes/windows/preferences/preferences.css
@@ -1,15 +1,23 @@
 /*
 # -*- Mode: Java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
 
+/* Main Pref Pane */
+#mainPrefPane {
+  padding-top: 8px;
+  padding-bottom: 10px;
+  padding-inline-start: 8px;
+  padding-inline-end: 10px;
+}
+
 /* General Pane */
 
 #useFirefoxSync,
 #getStarted {
   font-size: 90%;
 }
 
 #isNotDefaultLabel {
diff --git a/toolkit/mozapps/preferences/fontbuilder.js b/toolkit/mozapps/preferences/fontbuilder.js
--- a/toolkit/mozapps/preferences/fontbuilder.js
+++ b/toolkit/mozapps/preferences/fontbuilder.js
@@ -86,17 +86,20 @@ var FontBuilder = {
     aMenuList.appendChild(popup);
   },
 
   readFontSelection(aElement) {
     // Determine the appropriate value to select, for the following cases:
     // - there is no setting
     // - the font selected by the user is no longer present (e.g. deleted from
     //   fonts folder)
-    let preference = document.getElementById(aElement.getAttribute("preference"));
+    // TODO: stop getting preference element once we've converted fonts.xul
+    // from XBL <preference> elements to JS Preference objects.
+    let preference = document.getElementById(aElement.getAttribute("preference")) ||
+                     Preferences.get(aElement.getAttribute("preference"));
     if (preference.value) {
       let fontItems = aElement.getElementsByAttribute("value", preference.value);
 
       // There is a setting that actually is in the list. Respect it.
       if (fontItems.length)
         return undefined;
     }
 
