# HG changeset patch
# Parent 08be3008650fbeb88777dea3e6034622196dc949
# User Brian Grinstead <bgrinstead@mozilla.com>
972404 Shift right click element

diff --git a/browser/devtools/framework/toolbox-process-window.js b/browser/devtools/framework/toolbox-process-window.js
--- a/browser/devtools/framework/toolbox-process-window.js
+++ b/browser/devtools/framework/toolbox-process-window.js
@@ -79,26 +79,32 @@ function openToolbox(form) {
     } catch(e) {}
 
     try {
       // But if we are testing, then it should always open the debugger panel.
       selectedTool = Services.prefs.getCharPref("devtools.browsertoolbox.panel");
     } catch(e) {}
 
     let options = { customIframe: frame };
+    let lastSelectedTool = "jsdebugger";
+    try {
+      lastSelectedTool = Services.prefs.getCharPref("devtools.toolbox.selectedTool");
+    } catch(e) {}
+
     gDevTools.showToolbox(target,
-                          selectedTool,
+                          lastSelectedTool,
                           devtools.Toolbox.HostType.CUSTOM,
-                          options)
-             .then(onNewToolbox);
+                          options).then(toolbox=> {
+      gToolbox = toolbox;
+      return toolbox.initInspector();
+   }).then(onNewToolbox);
   });
 }
 
 function onNewToolbox(toolbox) {
-   gToolbox = toolbox;
    bindToolboxHandlers();
    raise();
 }
 
 function bindToolboxHandlers() {
   gToolbox.once("destroyed", quitApp);
   window.addEventListener("unload", onUnload);
 
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -83,17 +83,16 @@ const ToolboxButtons = [
  *        Type of host that will host the toolbox (e.g. sidebar, window)
  * @param {object} hostOptions
  *        Options for host specifically
  */
 function Toolbox(target, selectedTool, hostType, hostOptions) {
   this._target = target;
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
-
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
@@ -1473,16 +1472,23 @@ Toolbox.prototype = {
    * Returns a promise that resolves when the fronts are initialized
    */
   initInspector: function() {
     if (!this._initInspector) {
       this._initInspector = Task.spawn(function*() {
         this._inspector = InspectorFront(this._target.client, this._target.form);
         this._walker = yield this._inspector.getWalker();
         this._selection = new Selection(this._walker);
+        this._walker.on("browser-toolbox-inspect-shortcut", () => {
+          this.selectTool("inspector").then(() => {
+            this._walker.findInspectingNode().then(nodeFront => {
+              this._selection.setNodeFront(nodeFront, "browser-context-menu");
+            });
+          });
+        });
 
         if (this.highlighterUtils.isRemoteHighlightable()) {
           this.walker.on("highlighter-ready", this._highlighterReady);
           this.walker.on("highlighter-hide", this._highlighterHidden);
 
           let autohide = !gDevTools.testing;
           this._highlighter = yield this._inspector.getHighlighter(autohide);
         }
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -117,16 +117,27 @@ InspectorPanel.prototype = {
   },
 
   _deferredOpen: function(defaultSelection) {
     let deferred = promise.defer();
 
     this.onNewRoot = this.onNewRoot.bind(this);
     this.walker.on("new-root", this.onNewRoot);
 
+    // XXX: clean this up.
+    // this.onInspectShortcut = this.onInspectShortcut.bind(this);
+    // this.walker.on("browser-toolbox-inspect-shortcut", this.onInspectShortcut);
+
+
+    this.walker.on("browser-toolbox-inspect-shortcut", () => {
+      this.walker.findInspectingNode().then(nodeFront => {
+        this.selection.setNodeFront(nodeFront, "browser-context-menu");
+      });
+    });
+
     this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
     this.lastNodemenuItem = this.nodemenu.lastChild;
     this._setupNodeMenu = this._setupNodeMenu.bind(this);
     this._resetNodeMenu = this._resetNodeMenu.bind(this);
     this.nodemenu.addEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.addEventListener("popuphiding", this._resetNodeMenu, true);
 
     this.onNewSelection = this.onNewSelection.bind(this);
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -252,17 +252,18 @@ let HighlighterActor = exports.Highlight
    * - On a firefox desktop content page: tabActor is a BrowserTabActor from
    *   which the browser property will give us a target we can use to listen to
    *   events, even in nested iframes.
    * - On B2G: tabActor is a ContentActor which doesn't have a browser but
    *   since it overrides BrowserTabActor, it does get a browser property
    *   anyway, which points to its window object.
    * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
    *   the RootActor, in which case, the window property can be used to listen
-   *   to events
+   *   to events.
+   * - XXX: When inspecting the main process in the Web IDE, the RootActor is also used
    */
   _getPickerListenerTarget: function() {
     let actor = this._tabActor;
     return actor.isRootActor ? actor.window : actor.chromeEventHandler;
   },
 
   _startPickerListeners: function() {
     let target = this._getPickerListenerTarget();
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1108,16 +1108,19 @@ let traversalMethod = {
  */
 var WalkerActor = protocol.ActorClass({
   typeName: "domwalker",
 
   events: {
     "new-mutations" : {
       type: "newMutations"
     },
+    "browser-toolbox-inspect-shortcut" : {
+      type: "browserToolboxInspectShortcut"
+    },
     "picker-node-picked" : {
       type: "pickerNodePicked",
       node: Arg(0, "disconnectedNode")
     },
     "picker-node-hovered" : {
       type: "pickerNodeHovered",
       node: Arg(0, "disconnectedNode")
     },
@@ -3070,16 +3073,78 @@ var AttributeModificationList = Class({
  * Server side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorActor = exports.InspectorActor = protocol.ActorClass({
   typeName: "inspector",
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
+    this._startPickerListeners();
+  },
+
+  destroy: function() {
+    this._stopPickerListeners();
+    protocol.Actor.prototype.destroy.call(this);
+  },
+
+  /**
+   * Get the target for the Browser Toolbox.
+   * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
+   *   the RootActor, in which case, the window property can be used to listen
+   *   to events
+   */
+  _getBrowserToolboxListenerTarget: function() {
+    // Only return if this is an instance started by the Browser Toolbox,
+    // since we don't want the special handler for a normal toolbox.
+    if (this.tabActor.isRootActor) {
+      return this.tabActor.window;
+    }
+  },
+
+  _startPickerListeners: function() {
+    let target = this._getBrowserToolboxListenerTarget();
+    this._onContextMenu = this._onContextMenu.bind(this);
+    this._onMouseDown = this._onMouseDown.bind(this);
+    if (target) {
+      target.addEventListener("mousedown", this._onMouseDown, true);
+      target.addEventListener("contextmenu", this._onContextMenu, true);
+    }
+  },
+
+  _stopPickerListeners: function() {
+    let target = this._getBrowserToolboxListenerTarget();
+    if (target) {
+      target.removeEventListener("mousedown", this._onMouseDown, true);
+      target.removeEventListener("contextmenu", this._onContextMenu, true);
+    }
+  },
+
+  // On a shift right click when the browser toolbox is opened, don't
+  // allow clicks to perform actions (like shift right click on the
+  // Most Visited button)
+  _onMouseDown: function(event) {
+    if (event.shiftKey && event.which === 3) {
+      event.preventDefault();
+      event.stopPropagation();
+    }
+  },
+
+  // On a shift right click when the browser toolbox is opened, select
+  // the element in the browser inspector and prevent the context menu
+  _onContextMenu: function(event) {
+    if (event.shiftKey && event.which === 3) {
+      exports.setInspectingNode(event.originalTarget, true);
+      event.preventDefault();
+      event.stopPropagation();
+      this.getWalker().then(walker => {
+        console.log("Fetched walker", walker);
+        events.emit(this.walker, "browser-toolbox-inspect-shortcut");
+      });
+    }
   },
 
   get window() this.tabActor.window,
 
   getWalker: method(function(options={}) {
     if (this._walkerPromise) {
       return this._walkerPromise;
     }
