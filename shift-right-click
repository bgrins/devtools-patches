# HG changeset patch
# Parent e54edf3b633c08bbb908e5c4823f4f5fe50e22d0
# User Brian Grinstead <bgrinstead@mozilla.com>
972404 Shift right click element

diff --git a/browser/devtools/framework/ToolboxProcess.jsm b/browser/devtools/framework/ToolboxProcess.jsm
--- a/browser/devtools/framework/ToolboxProcess.jsm
+++ b/browser/devtools/framework/ToolboxProcess.jsm
@@ -194,17 +194,17 @@ BrowserToolboxProcess.prototype = {
     let xulURI = DBG_XUL;
 
     if (this._options.addonID) {
       xulURI += "?addonID=" + this._options.addonID;
     }
 
     dumpn("Running chrome debugging process.");
     let args = ["-no-remote", "-foreground", "-profile", this._dbgProfilePath, "-chrome", xulURI];
-
+dumpn(args);
     process.runwAsync(args, args.length, { observe: () => this.close() });
 
     this._telemetry.toolOpened("jsbrowserdebugger");
 
     dumpn("Chrome toolbox is now running...");
     this.emit("run", this);
   },
 
diff --git a/browser/devtools/framework/toolbox-process-window.js b/browser/devtools/framework/toolbox-process-window.js
--- a/browser/devtools/framework/toolbox-process-window.js
+++ b/browser/devtools/framework/toolbox-process-window.js
@@ -70,21 +70,27 @@ function openToolbox(form) {
   let options = {
     form: form,
     client: gClient,
     chrome: true
   };
   devtools.TargetFactory.forRemoteTab(options).then(target => {
     let frame = document.getElementById("toolbox-iframe");
     let options = { customIframe: frame };
+    let lastSelectedTool = "jsdebugger";
+    try {
+      lastSelectedTool = Services.prefs.getCharPref("devtools.toolbox.selectedTool");
+    } catch(e) {}
     gDevTools.showToolbox(target,
-                          "jsdebugger",
+                          lastSelectedTool,
                           devtools.Toolbox.HostType.CUSTOM,
-                          options)
-             .then(onNewToolbox);
+                          options).then(toolbox=> {
+                            console.log("toolbox?", toolbox)
+                          return toolbox.initInpsector();
+                         }).then(onNewToolbox);
   });
 }
 
 function onNewToolbox(toolbox) {
    gToolbox = toolbox;
    bindToolboxHandlers();
    raise();
 }
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -41,16 +41,17 @@ loader.lazyGetter(this, "toolboxStrings"
       Services.console.logStringMessage("Error reading '" + name + "'");
       return null;
     }
   };
 });
 
 loader.lazyGetter(this, "Selection", () => require("devtools/framework/selection").Selection);
 loader.lazyGetter(this, "InspectorFront", () => require("devtools/server/actors/inspector").InspectorFront);
+loader.lazyGetter(this, "Inspector", () => require("devtools/server/actors/inspector"));
 
 // White-list buttons that can be toggled to prevent adding prefs for
 // addons that have manually inserted toolbarbuttons into DOM.
 // (By default, supported target is only local tab)
 const ToolboxButtons = [
   { id: "command-button-pick",
     isTargetSupported: target => !target.isAddon },
   { id: "command-button-frames",
@@ -81,17 +82,16 @@ const ToolboxButtons = [
  *        Type of host that will host the toolbox (e.g. sidebar, window)
  * @param {object} hostOptions
  *        Options for host specifically
  */
 function Toolbox(target, selectedTool, hostType, hostOptions) {
   this._target = target;
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
-
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
@@ -1405,16 +1405,26 @@ Toolbox.prototype = {
    * Returns a promise that resolves when the fronts are initialized
    */
   initInspector: function() {
     if (!this._initInspector) {
       this._initInspector = Task.spawn(function*() {
         this._inspector = InspectorFront(this._target.client, this._target.form);
         this._walker = yield this._inspector.getWalker();
         this._selection = new Selection(this._walker);
+        this._walker.on("browser-toolbox-inspect-shortcut", () => {
+          console.log("Receieved foo");
+          this.loadTool("inspector").then(() => {
+            this._walker.findInspectingNode().then(nodeFront => {
+            console.log("Receieved nodeFront", nodeFront);
+              this._selection.setNodeFront(nodeFront, "browser-context-menu");
+            });
+          });
+        });
+
 
         if (this.highlighterUtils.isRemoteHighlightable()) {
           this.walker.on("highlighter-ready", this._highlighterReady);
           this.walker.on("highlighter-hide", this._highlighterHidden);
 
           let autohide = !gDevTools.testing;
           this._highlighter = yield this._inspector.getHighlighter(autohide);
         }
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -106,16 +106,30 @@ InspectorPanel.prototype = {
     return this._target.client.traits.urlToImageDataResolver;
   },
 
   _deferredOpen: function(defaultSelection) {
     let deferred = promise.defer();
 
     this.onNewRoot = this.onNewRoot.bind(this);
     this.walker.on("new-root", this.onNewRoot);
+    console.log("Listening for foo on walker");
+
+    // XXX: clean this up.
+    // this.onInspectShortcut = this.onInspectShortcut.bind(this);
+    // this.walker.on("browser-toolbox-inspect-shortcut", this.onInspectShortcut);
+
+
+    this.walker.on("browser-toolbox-inspect-shortcut", () => {
+      console.log("Receieved foo");
+      this.walker.findInspectingNode().then(nodeFront => {
+      console.log("Receieved nodeFront", nodeFront);
+        this.selection.setNodeFront(nodeFront, "browser-context-menu");
+      });
+    });
 
     this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
     this.lastNodemenuItem = this.nodemenu.lastChild;
     this._setupNodeMenu = this._setupNodeMenu.bind(this);
     this._resetNodeMenu = this._resetNodeMenu.bind(this);
     this.nodemenu.addEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.addEventListener("popuphiding", this._resetNodeMenu, true);
 
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -1116,16 +1116,19 @@ let traversalMethod = {
  */
 var WalkerActor = protocol.ActorClass({
   typeName: "domwalker",
 
   events: {
     "new-mutations" : {
       type: "newMutations"
     },
+    "browser-toolbox-inspect-shortcut" : {
+      type: "browserToolboxInspectShortcut"
+    },
     "picker-node-picked" : {
       type: "pickerNodePicked",
       node: Arg(0, "disconnectedNode")
     },
     "picker-node-hovered" : {
       type: "pickerNodeHovered",
       node: Arg(0, "disconnectedNode")
     },
@@ -2873,16 +2876,67 @@ var AttributeModificationList = Class({
  * Server side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorActor = exports.InspectorActor = protocol.ActorClass({
   typeName: "inspector",
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
+    this._startPickerListeners();
+  },
+
+  // destroy: function() {
+  //   this._stopPickerListeners();
+  //   protocol.Actor.prototype.destroy.call(this);
+  // },
+
+  /**
+   * Get the right target for listening to mouse events while in pick mode.
+   * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
+   *   the RootActor, in which case, the window property can be used to listen
+   *   to events
+   */
+  _getBrowserToolboxListenerTarget: function() {
+    let actor = this.tabActor;
+
+    // Only return if this is an instance started by the Browser Toolbox,
+    // since we don't want the special handler for a normal toolbox.
+    if (actor.isRootActor) {
+      return actor.window;
+    }
+  },
+
+  _startPickerListeners: function() {
+    let target = this._getBrowserToolboxListenerTarget();
+    this._onClick = this._onClick.bind(this);
+    if (target) {
+      target.addEventListener("mousedown", this._onClick, true);
+    }
+  },
+
+  _stopPickerListeners: function() {
+    let target = this._getBrowserToolboxListenerTarget();
+    if (target) {
+      target.removeEventListener("mousedown", this._onClick, true);
+    }
+  },
+
+  _onClick: function(event) {
+    if (event.shiftKey && event.which === 3) {
+      console.log("Shift right click handled", event.originalTarget, this);
+      exports.setInspectingNode(event.originalTarget, true);
+      event.preventDefault();
+      event.stopPropagation();
+      // XXX: stop context menu from showing up
+      this.getWalker().then(walker => {
+        console.log("Fetched walker", walker);
+        events.emit(this.walker, "browser-toolbox-inspect-shortcut");
+      });
+    }
   },
 
   get window() this.tabActor.window,
 
   getWalker: method(function(options={}) {
     if (this._walkerPromise) {
       return this._walkerPromise;
     }
