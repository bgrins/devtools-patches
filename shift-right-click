# HG changeset patch
# Parent 19d789a42fbcc127a04a92083a59c01a370ff101
# User Brian Grinstead <bgrinstead@mozilla.com>
972404 Shift right click element

diff --git a/browser/devtools/framework/ToolboxProcess.jsm b/browser/devtools/framework/ToolboxProcess.jsm
--- a/browser/devtools/framework/ToolboxProcess.jsm
+++ b/browser/devtools/framework/ToolboxProcess.jsm
@@ -194,17 +194,17 @@ BrowserToolboxProcess.prototype = {
     let xulURI = DBG_XUL;
 
     if (this._options.addonID) {
       xulURI += "?addonID=" + this._options.addonID;
     }
 
     dumpn("Running chrome debugging process.");
     let args = ["-no-remote", "-foreground", "-profile", this._dbgProfilePath, "-chrome", xulURI];
-
+dumpn(args);
     process.runwAsync(args, args.length, { observe: () => this.close() });
 
     this._telemetry.toolOpened("jsbrowserdebugger");
 
     dumpn("Chrome toolbox is now running...");
     this.emit("run", this);
   },
 
diff --git a/browser/devtools/framework/toolbox-process-window.js b/browser/devtools/framework/toolbox-process-window.js
--- a/browser/devtools/framework/toolbox-process-window.js
+++ b/browser/devtools/framework/toolbox-process-window.js
@@ -54,16 +54,28 @@ function setPrefDefaults() {
   Services.prefs.setBoolPref("devtools.inspector.showUserAgentStyles", true);
   Services.prefs.setBoolPref("devtools.profiler.ui.show-platform-data", true);
 }
 
 window.addEventListener("load", function() {
   let cmdClose = document.getElementById("toolbox-cmd-close");
   cmdClose.addEventListener("command", onCloseCommand);
   setPrefDefaults();
+
+  let inspector = devtools.require("devtools/server/actors/inspector");
+  dump("BT Received inspector ****");
+  inspector.setShiftRightClickListener((node) => {
+    gToolbox.selectTool("inspector").then(() => {
+
+    });
+    // dump("RECEIVED NODE!!!", node);
+    // inspector.walker.findInspectingNode().then(nodeFront => {
+    //   inspector.selection.setNodeFront(nodeFront, "browser-context-menu");
+    // });
+  });
   connect();
 });
 
 function onCloseCommand(event) {
   window.close();
 }
 
 function openToolbox(form) {
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -41,16 +41,17 @@ loader.lazyGetter(this, "toolboxStrings"
       Services.console.logStringMessage("Error reading '" + name + "'");
       return null;
     }
   };
 });
 
 loader.lazyGetter(this, "Selection", () => require("devtools/framework/selection").Selection);
 loader.lazyGetter(this, "InspectorFront", () => require("devtools/server/actors/inspector").InspectorFront);
+loader.lazyGetter(this, "Inspector", () => require("devtools/server/actors/inspector"));
 
 // White-list buttons that can be toggled to prevent adding prefs for
 // addons that have manually inserted toolbarbuttons into DOM.
 // (By default, supported target is only local tab)
 const ToolboxButtons = [
   { id: "command-button-pick",
     isTargetSupported: target => !target.isAddon },
   { id: "command-button-frames",
@@ -81,17 +82,26 @@ const ToolboxButtons = [
  *        Type of host that will host the toolbox (e.g. sidebar, window)
  * @param {object} hostOptions
  *        Options for host specifically
  */
 function Toolbox(target, selectedTool, hostType, hostOptions) {
   this._target = target;
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
-
+console.log("Toolbox - setShiftRightClickListener", Inspector.setShiftRightClickListener);
+Inspector.setShiftRightClickListener(() => {
+  console.log("WEEEEE");
+  this.selectTool("inspector").then(inspector => {
+  console.log("WEEEEE2", inspector);
+    inspector.walker.findInspectingNode().then(nodeFront => {
+      inspector.selection.setNodeFront(nodeFront, "browser-context-menu");
+    });
+  });
+});
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
   this.highlighterUtils = getHighlighterUtils(this);
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -175,21 +175,32 @@ exports.setValueSummaryLength = function
 
 // When the user selects a node to inspect in e10s, the parent process
 // has a CPOW that wraps the node being inspected.  It uses the
 // message manager to send this node to the child, which stores the
 // node in gInspectingNode. Then a findInspectingNode request is sent
 // over the remote debugging protocol, and gInspectingNode is returned
 // to the parent as a NodeFront.
 var gInspectingNode = null;
+var shiftRightClickListener = null;
+exports.setShiftRightClickListener = function(cb) {
+  console.log("SETTING LISTENER", cb);
+  shiftRightClickListener = cb;
+};
+
 
 // We expect this function to be called from the child.js frame script
 // when it receives the node to be inspected over the message manager.
-exports.setInspectingNode = function(val) {
+exports.setInspectingNode = function(val, fireEvent) {
   gInspectingNode = val;
+  console.log("OK?",fireEvent, shiftRightClickListener);
+  if (fireEvent && shiftRightClickListener) {
+    console.log("FIring listener");
+    shiftRightClickListener();
+  }
 };
 
 /**
  * Server side of the node actor.
  */
 var NodeActor = exports.NodeActor = protocol.ActorClass({
   typeName: "domnode",
 
@@ -2873,16 +2884,74 @@ var AttributeModificationList = Class({
  * Server side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorActor = exports.InspectorActor = protocol.ActorClass({
   typeName: "inspector",
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
     this.tabActor = tabActor;
+    this._startPickerListeners();
+  },
+
+  // destroy: function() {
+  //   this._stopPickerListeners();
+  //   protocol.Actor.prototype.destroy.call(this);
+  // },
+
+  /**
+   * Get the right target for listening to mouse events while in pick mode.
+   * - When using the Browser Toolbox (to inspect firefox desktop): tabActor is
+   *   the RootActor, in which case, the window property can be used to listen
+   *   to events
+   */
+  _getBrowserToolboxListenerTarget: function() {
+    let actor = this.tabActor;
+
+    // XXX: Only return for browser toolbox
+    return actor.isRootActor ? actor.window : actor.chromeEventHandler;
+
+    if (actor.isRootActor) {
+      return actor.window;
+    }
+  },
+
+  _startPickerListeners: function() {
+    let target = this._getBrowserToolboxListenerTarget();
+    this._onClick = this._onClick.bind(this);
+    if (target) {
+      target.addEventListener("click", this._onClick, true);
+    }
+  },
+
+  _stopPickerListeners: function() {
+    let target = this._getBrowserToolboxListenerTarget();
+    if (target) {
+      target.removeEventListener("click", this._onClick, true);
+    }
+  },
+
+  _onClick: function(event) {
+    console.log("EVENT HANDLED!");
+    if (event.shiftKey && event.which === 3) {
+      console.log("Received inspector", event.originalTarget, this);
+      exports.setInspectingNode(event.originalTarget, true);
+
+      // this.getWalker().then(walker => {
+      //   console.log("FETCHING WALKER ", walker, walker.findInspectingNode());
+      //   let nodeFront = walker.findInspectingNode();
+      //   console.log("FETCHING WALKER ", walker, nodeFront);
+      //   this.selection.setNodeFront(nodeFront, "browser-context-menu");
+      //   // walker.findInspectingNode().then(nodeFront => {
+      //   //   console.log("Walker received", nodeFront);
+      //   //   this.selection.setNodeFront(nodeFront, "browser-context-menu");
+      //   // });
+      // });
+
+    }
   },
 
   get window() this.tabActor.window,
 
   getWalker: method(function(options={}) {
     if (this._walkerPromise) {
       return this._walkerPromise;
     }
