# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  6b8ff7012009f272e84281a1643415f0d6b146ff
Bug 1269763 - Convert instances of toolbox.frame.contentWindow to toolbox.win;r=jdescottes

diff --git a/devtools/client/framework/test/browser_toolbox_toggle.js b/devtools/client/framework/test/browser_toolbox_toggle.js
--- a/devtools/client/framework/test/browser_toolbox_toggle.js
+++ b/devtools/client/framework/test/browser_toolbox_toggle.js
@@ -66,17 +66,17 @@ function* testToggleDetachedToolbox(tab,
 
   info("change the toolbox hostType to WINDOW");
 
   yield toolbox.switchHost(Toolbox.HostType.WINDOW);
   is(toolbox.hostType, Toolbox.HostType.WINDOW,
     "Toolbox opened on separate window");
 
   info("Wait for focus on the toolbox window");
-  yield new Promise(res => waitForFocus(res, toolbox.frame.contentWindow));
+  yield new Promise(res => waitForFocus(res, toolbox.win));
 
   info("Focus main window to put the toolbox window in the background");
 
   let onMainWindowFocus = once(window, "focus");
   window.focus();
   yield onMainWindowFocus;
   ok(true, "Main window focused");
 
diff --git a/devtools/client/framework/test/shared-head.js b/devtools/client/framework/test/shared-head.js
--- a/devtools/client/framework/test/shared-head.js
+++ b/devtools/client/framework/test/shared-head.js
@@ -280,18 +280,17 @@ var openToolboxForTab = Task.async(funct
       return toolbox;
     }
   }
 
   // If not, load it now.
   toolbox = yield gDevTools.showToolbox(target, toolId, hostType);
 
   // Make sure that the toolbox frame is focused.
-  yield new Promise(resolve => waitForFocus(resolve,
-    toolbox.frame.contentWindow));
+  yield new Promise(resolve => waitForFocus(resolve, toolbox.win));
 
   info("Toolbox opened and focused");
 
   return toolbox;
 });
 
 /**
  * Add a new tab and open the toolbox in it.
diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -275,17 +275,17 @@ Toolbox.prototype = {
   get frame() {
     return this._host.frame;
   },
 
   /**
    * Shortcut to the window containing the toolbox UI
    */
   get win() {
-    return this.doc.defaultView;
+    return this.frame.contentWindow;
   },
 
   /**
    * Shortcut to the document containing the toolbox UI
    */
   get doc() {
     return this.frame.contentDocument;
   },
@@ -709,17 +709,17 @@ Toolbox.prototype = {
    * @param {number} zoomValue
    *        Zoom level e.g. 1.2
    */
   setZoom: function(zoomValue) {
     // cap zoom value
     zoomValue = Math.max(zoomValue, MIN_ZOOM);
     zoomValue = Math.min(zoomValue, MAX_ZOOM);
 
-    let docShell = this.frame.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+    let docShell = this.win.QueryInterface(Ci.nsIInterfaceRequestor)
       .getInterface(Ci.nsIWebNavigation)
       .QueryInterface(Ci.nsIDocShell);
     let contViewer = docShell.contentViewer;
 
     contViewer.fullZoom = zoomValue;
 
     Services.prefs.setCharPref(ZOOM_PREF, zoomValue);
   },
@@ -1810,17 +1810,17 @@ Toolbox.prototype = {
     return newHost.create().then(iframe => {
       // change toolbox document's parent to the new host
       iframe.QueryInterface(Ci.nsIFrameLoaderOwner);
       iframe.swapFrameLoaders(this.frame);
 
       // See bug 1022726, most probably because of swapFrameLoaders we need to
       // first focus the window here, and then once again further below to make
       // sure focus actually happens.
-      this.frame.contentWindow.focus();
+      this.win.focus();
 
       this._host.off("window-closed", this.destroy);
       this.destroyHost();
 
       let prevHostType = this._host.type;
       this._host = newHost;
 
       if (this.hostType != Toolbox.HostType.CUSTOM) {
@@ -1828,17 +1828,17 @@ Toolbox.prototype = {
         Services.prefs.setCharPref(this._prefs.PREVIOUS_HOST, prevHostType);
       }
 
       this._buildDockButtons();
       this._addKeysToWindow();
 
       // Focus the contentWindow to make sure keyboard shortcuts work straight
       // away.
-      this.frame.contentWindow.focus();
+      this.win.focus();
 
       this.emit("host-changed");
     });
   },
 
   /**
    * Return if the tool is available as a tab (i.e. if it's checked
    * in the options panel). This is different from Toolbox.getPanel -
@@ -2166,18 +2166,17 @@ Toolbox.prototype = {
    * For displaying the promotional Doorhanger on first opening of
    * the developer tools, promoting the Developer Edition.
    */
   _showDevEditionPromo: function() {
     // Do not display in browser toolbox
     if (this.target.chrome) {
       return;
     }
-    let window = this.frame.contentWindow;
-    showDoorhanger({ window, type: "deveditionpromo" });
+    showDoorhanger({ window: this.win, type: "deveditionpromo" });
   },
 
   /**
    * Enable / disable necessary textbox menu items using globalOverlay.js.
    */
   _updateTextboxMenuItems: function() {
     let window = this.win;
     ["cmd_undo", "cmd_delete", "cmd_cut",
@@ -2264,17 +2263,17 @@ Toolbox.prototype = {
       recordings.push(recording);
     }
   }),
 
   /**
    * Returns gViewSourceUtils for viewing source.
    */
   get gViewSourceUtils() {
-    return this.frame.contentWindow.gViewSourceUtils;
+    return this.win.gViewSourceUtils;
   },
 
   /**
    * Opens source in style editor. Falls back to plain "view-source:".
    * @see devtools/client/shared/source-utils.js
    */
   viewSourceInStyleEditor: function(sourceURL, sourceLine) {
     return viewSource.viewSourceInStyleEditor(this, sourceURL, sourceLine);
diff --git a/devtools/client/responsivedesign/test/head.js b/devtools/client/responsivedesign/test/head.js
--- a/devtools/client/responsivedesign/test/head.js
+++ b/devtools/client/responsivedesign/test/head.js
@@ -123,18 +123,17 @@ var closeToolbox = Task.async(function*(
 /**
  * Wait for the toolbox frame to receive focus after it loads
  * @param {Toolbox} toolbox
  * @return a promise that resolves when focus has been received
  */
 function waitForToolboxFrameFocus(toolbox) {
   info("Making sure that the toolbox's frame is focused");
   let def = promise.defer();
-  let win = toolbox.frame.contentWindow;
-  waitForFocus(def.resolve, win);
+  waitForFocus(def.resolve, toolbox.win);
   return def.promise;
 }
 
 /**
  * Open the toolbox, with the inspector tool visible, and the sidebar that
  * corresponds to the given id selected
  * @return a promise that resolves when the inspector is ready and the sidebar
  * view is visible and ready
diff --git a/devtools/client/storage/test/head.js b/devtools/client/storage/test/head.js
--- a/devtools/client/storage/test/head.js
+++ b/devtools/client/storage/test/head.js
@@ -161,18 +161,17 @@ var openStoragePanel = Task.async(functi
  *
  * @param toolbox {Toolbox}
  *
  * @return a promise that resolves when focus has been received
  */
 function waitForToolboxFrameFocus(toolbox) {
   info("Making sure that the toolbox's frame is focused");
   let def = promise.defer();
-  let win = toolbox.frame.contentWindow;
-  waitForFocus(def.resolve, win);
+  waitForFocus(def.resolve, toolbox.win);
   return def.promise;
 }
 
 /**
  * Forces GC, CC and Shrinking GC to get rid of disconnected docshells and
  * windows.
  */
 function forceCollections() {
diff --git a/devtools/client/webconsole/test/browser_webconsole_split.js b/devtools/client/webconsole/test/browser_webconsole_split.js
--- a/devtools/client/webconsole/test/browser_webconsole_split.js
+++ b/devtools/client/webconsole/test/browser_webconsole_split.js
@@ -36,17 +36,17 @@ function test() {
     info("About to check that panel responds to ESCAPE keyboard shortcut");
 
     toolbox.once("split-console", () => {
       ok(true, "Split console has been triggered via ESCAPE keypress");
       checkAllTools();
     });
 
     // Closes split console.
-    EventUtils.sendKey("ESCAPE", toolbox.frame.contentWindow);
+    EventUtils.sendKey("ESCAPE", toolbox.win);
   }
 
   function checkAllTools() {
     info("About to check split console with each panel individually.");
 
     Task.spawn(function*() {
       yield openAndCheckPanel("jsdebugger");
       yield openAndCheckPanel("inspector");
diff --git a/devtools/client/webconsole/test/browser_webconsole_split_escape_key.js b/devtools/client/webconsole/test/browser_webconsole_split_escape_key.js
--- a/devtools/client/webconsole/test/browser_webconsole_split_escape_key.js
+++ b/devtools/client/webconsole/test/browser_webconsole_split_escape_key.js
@@ -44,40 +44,40 @@ function test() {
 
   function testCreateSplitConsoleAfterEscape() {
     let result = toolbox.once("webconsole-ready", () => {
       hud = toolbox.getPanel("webconsole").hud;
       jsterm = hud.jsterm;
       ok(toolbox.splitConsole, "Split console is created.");
     });
 
-    let contentWindow = toolbox.frame.contentWindow;
+    let contentWindow = toolbox.win;
     contentWindow.focus();
     EventUtils.sendKey("ESCAPE", contentWindow);
 
     return result;
   }
 
   function testHideSplitConsoleAfterEscape() {
     let result = toolbox.once("split-console", () => {
       ok(!toolbox.splitConsole, "Split console is hidden.");
     });
-    EventUtils.sendKey("ESCAPE", toolbox.frame.contentWindow);
+    EventUtils.sendKey("ESCAPE", toolbox.win);
 
     return result;
   }
 
   function testHideVariablesViewAfterEscape() {
     let result = jsterm.once("sidebar-closed", () => {
       ok(!hud.ui.jsterm.sidebar,
         "Variables view is hidden.");
       ok(toolbox.splitConsole,
         "Split console is open after hiding the variables view.");
     });
-    EventUtils.sendKey("ESCAPE", toolbox.frame.contentWindow);
+    EventUtils.sendKey("ESCAPE", toolbox.win);
 
     return result;
   }
 
   function testHideAutoCompletePopupAfterEscape() {
     let deferred = promise.defer();
     let popup = jsterm.autocompletePopup;
 
@@ -86,17 +86,17 @@ function test() {
       ok(!popup.isOpen,
         "Auto complete popup is hidden.");
       ok(toolbox.splitConsole,
         "Split console is open after hiding the autocomplete popup.");
 
       deferred.resolve();
     }, false);
 
-    EventUtils.sendKey("ESCAPE", toolbox.frame.contentWindow);
+    EventUtils.sendKey("ESCAPE", toolbox.win);
 
     return deferred.promise;
   }
 
   function testCancelPropertyEditorAfterEscape() {
     EventUtils.sendKey("ESCAPE", variablesView.window);
     ok(hud.ui.jsterm.sidebar,
       "Variables view is open after canceling property editor.");
diff --git a/devtools/client/webconsole/test/browser_webconsole_split_persist.js b/devtools/client/webconsole/test/browser_webconsole_split_persist.js
--- a/devtools/client/webconsole/test/browser_webconsole_split_persist.js
+++ b/devtools/client/webconsole/test/browser_webconsole_split_persist.js
@@ -99,17 +99,17 @@ function test() {
 
   function isCommandButtonChecked() {
     return toolbox.doc.querySelector("#command-button-splitconsole")
       .hasAttribute("checked");
   }
 
   function toggleSplitConsoleWithEscape() {
     let onceSplitConsole = toolbox.once("split-console");
-    let contentWindow = toolbox.frame.contentWindow;
+    let contentWindow = toolbox.win;
     contentWindow.focus();
     EventUtils.sendKey("ESCAPE", contentWindow);
     return onceSplitConsole;
   }
 
   function finish() {
     toolbox = TEST_URI = null;
     Services.prefs.clearUserPref("devtools.toolbox.splitconsoleEnabled");
