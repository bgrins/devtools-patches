# HG changeset patch
# Parent f9e0bffd3ecae7777a74b8c2a9d9852c99b7c525
# User Brian Grinstead <bgrinstead@mozilla.com>
Bug 1029511 - Source Editor: Add ability to toggle autocomplete option;r=vporof

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1431,16 +1431,17 @@ pref("devtools.eyedropper.zoom", 6);
 // - keymap: which keymap to use (can be 'default', 'emacs' or 'vim')
 // - autoclosebrackets: whether to permit automatic bracket/quote closing.
 // - detectindentation: whether to detect the indentation from the file
 pref("devtools.editor.tabsize", 2);
 pref("devtools.editor.expandtab", true);
 pref("devtools.editor.keymap", "default");
 pref("devtools.editor.autoclosebrackets", true);
 pref("devtools.editor.detectindentation", true);
+pref("devtools.editor.autocomplete", true);
 
 // Enable the Font Inspector
 pref("devtools.fontinspector.enabled", true);
 
 // Pref to store the browser version at the time of a telemetry ping for an
 // opened developer tool. This allows us to ping telemetry just once per browser
 // version for each user.
 pref("devtools.telemetry.tools.opened.version", "{}");
diff --git a/browser/devtools/sourceeditor/autocomplete.js b/browser/devtools/sourceeditor/autocomplete.js
--- a/browser/devtools/sourceeditor/autocomplete.js
+++ b/browser/devtools/sourceeditor/autocomplete.js
@@ -11,18 +11,21 @@ const CM_TERN_SCRIPTS = [
   "chrome://browser/content/devtools/codemirror/show-hint.js"
 ];
 
 const privates = new WeakMap();
 
 /**
  * Prepares an editor instance for autocompletion.
  */
-function setupAutoCompletion(ctx, options) {
+function initializeAutoCompletion(ctx, options = {}) {
   let { cm, ed, Editor } = ctx;
+  if (privates.has(ed)) {
+    return;
+  }
 
   let win = ed.container.contentWindow.wrappedJSObject;
   let { CodeMirror, document } = win;
 
   let completer = null;
   let autocompleteKey = "Ctrl-" +
                         Editor.keyFor("autocompletion", { noaccel: true });
   if (ed.config.mode == Editor.modes.js) {
@@ -54,38 +57,50 @@ function setupAutoCompletion(ctx, option
           docLink.className = "theme-link";
           docLink.setAttribute("target", "_blank");
           tip.appendChild(docLink);
         }
 
         return tip;
       }
     });
-    cm.on("cursorActivity", (cm) => {
-      cm.tern.updateArgHints(cm);
-    });
 
     let keyMap = {};
+    let updateArgHintsCallback = cm.tern.updateArgHints.bind(cm.tern, cm);
+    cm.on("cursorActivity", updateArgHintsCallback);
 
     keyMap[autocompleteKey] = (cm) => {
       cm.tern.getHint(cm, (data) => {
         CodeMirror.on(data, "shown", () => ed.emit("before-suggest"));
         CodeMirror.on(data, "close", () => ed.emit("after-suggest"));
         CodeMirror.on(data, "select", () => ed.emit("suggestion-entered"));
         CodeMirror.showHint(cm, (cm, cb) => cb(data), { async: true });
       });
     };
 
     keyMap[Editor.keyFor("showInformation", { noaccel: true })] = (cm) => {
       cm.tern.showType(cm, null, () => {
         ed.emit("show-information");
       });
     };
+    cm.addKeyMap(keyMap);
 
-    cm.addKeyMap(keyMap);
+    let destroyTern = function() {
+      ed.off("destroy", destroyTern);
+      cm.off("cursorActivity", updateArgHintsCallback);
+      cm.removeKeyMap(keyMap);
+      win.tern = cm.tern = null;
+      privates.delete(ed);
+    };
+
+    ed.on("destroy", destroyTern);
+
+    privates.set(ed, {
+      destroy: destroyTern
+    });
 
     // TODO: Integrate tern autocompletion with this autocomplete API.
     return;
   } else if (ed.config.mode == Editor.modes.css) {
     completer = new cssAutoCompleter({walker: options.walker});
   }
 
   let popup = new AutocompletePopup(win.parent.document, {
@@ -121,38 +136,63 @@ function setupAutoCompletion(ctx, option
         // This event is used in tests
         ed.emit("popup-hidden");
         return;
       }
 
       return CodeMirror.Pass;
     }
   };
-  keyMap[autocompleteKey] = cm => autoComplete(ctx);
+  let autoCompleteCallback = autoComplete.bind(null, ctx);
+  let keypressCallback = onEditorKeypress.bind(null, ctx);
+  keyMap[autocompleteKey] = autoCompleteCallback;
   cm.addKeyMap(keyMap);
 
-  cm.on("keydown", (cm, e) => onEditorKeypress(ctx, e));
-  ed.on("change", () => autoComplete(ctx));
-  ed.on("destroy", () => {
-    cm.off("keydown", (cm, e) => onEditorKeypress(ctx, e));
-    ed.off("change", () => autoComplete(ctx));
-    popup.destroy();
-    popup = null;
-    completer = null;
-  });
+  cm.on("keydown", keypressCallback);
+  ed.on("change", autoCompleteCallback);
+  ed.on("destroy", destroy);
+
+  function destroy() {
+    ed.off("destroy", destroy);
+    cm.off("keydown", keypressCallback);
+    ed.off("change", autoCompleteCallback);
+    cm.removeKeyMap(keyMap);
+    try {
+      // Catch 'document.commandDispatcher is undefined'
+      // in browser_editor_autocomplete_basic.js.
+      popup.destroy();
+    } catch(e) { }
+    keyMap = popup = completer = null;
+    privates.delete(ed);
+  }
 
   privates.set(ed, {
     popup: popup,
     completer: completer,
+    keyMap: keyMap,
+    destroy: destroy,
     insertingSuggestion: false,
     suggestionInsertedOnce: false
   });
 }
 
 /**
+ * Destroy autocompletion on an editor instance.
+ */
+function destroyAutoCompletion(ctx) {
+  let { ed } = ctx;
+  if (!privates.has(ed)) {
+    return;
+  }
+
+  let {destroy} = privates.get(ed);
+  destroy();
+}
+
+/**
  * Provides suggestions to autocomplete the current token/word being typed.
  */
 function autoComplete({ ed, cm }) {
   let private = privates.get(ed);
   let { completer, popup } = private;
   if (!completer || private.insertingSuggestion || private.doNotAutocomplete) {
     private.insertingSuggestion = false;
     return;
@@ -221,17 +261,17 @@ function cycleSuggestions(ed, reverse) {
   // This event is used in tests.
   ed.emit("suggestion-entered");
 }
 
 /**
  * onkeydown handler for the editor instance to prevent autocompleting on some
  * keypresses.
  */
-function onEditorKeypress({ ed, Editor }, event) {
+function onEditorKeypress({ ed, Editor }, cm, event) {
   let private = privates.get(ed);
 
   // Do not try to autocomplete with multiple selections.
   if (ed.hasMultipleSelections()) {
     private.doNotAutocomplete = true;
     private.popup.hidePopup();
     return;
   }
@@ -278,28 +318,32 @@ function onEditorKeypress({ ed, Editor }
       private.doNotAutocomplete = false;
   }
 }
 
 /**
  * Returns the private popup. This method is used by tests to test the feature.
  */
 function getPopup({ ed }) {
-  return privates.get(ed).popup;
+  if (privates.has(ed))
+    return privates.get(ed).popup;
+
+  return null;
 }
 
 /**
  * Returns contextual information about the token covered by the caret if the
  * implementation of completer supports it.
  */
 function getInfoAt({ ed }, caret) {
   let completer = privates.get(ed).completer;
   if (completer && completer.getInfoAt)
     return completer.getInfoAt(ed.getText(), caret);
 
   return null;
 }
 
 // Export functions
 
-module.exports.setupAutoCompletion = setupAutoCompletion;
+module.exports.initializeAutoCompletion = initializeAutoCompletion;
+module.exports.destroyAutoCompletion = destroyAutoCompletion;
 module.exports.getAutocompletionPopup = getPopup;
 module.exports.getInfoAt = getInfoAt;
diff --git a/browser/devtools/sourceeditor/editor.js b/browser/devtools/sourceeditor/editor.js
--- a/browser/devtools/sourceeditor/editor.js
+++ b/browser/devtools/sourceeditor/editor.js
@@ -7,16 +7,17 @@
 "use strict";
 
 const { Cu, Cc, Ci, components } = require("chrome");
 
 const TAB_SIZE    = "devtools.editor.tabsize";
 const EXPAND_TAB  = "devtools.editor.expandtab";
 const KEYMAP      = "devtools.editor.keymap";
 const AUTO_CLOSE  = "devtools.editor.autoclosebrackets";
+const AUTOCOMPLETE  = "devtools.editor.autocomplete";
 const DETECT_INDENT = "devtools.editor.detectindentation";
 const DETECT_INDENT_MAX_LINES = 500;
 const L10N_BUNDLE = "chrome://browser/locale/devtools/sourceeditor.properties";
 const XUL_NS      = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 // Maximum allowed margin (in number of lines) from top or bottom of the editor
 // while shifting to a line which was initially out of view.
 const MAX_VERTICAL_OFFSET = 3;
@@ -93,19 +94,17 @@ const CM_MAPPING = [
   "getSelection",
   "replaceSelection",
   "extendSelection",
   "undo",
   "redo",
   "clearHistory",
   "openDialog",
   "refresh",
-  "getScrollInfo",
-  "getOption",
-  "setOption"
+  "getScrollInfo"
 ];
 
 const { cssProperties, cssValues, cssColors } = getCSSKeywords();
 
 const editors = new WeakMap();
 
 Editor.modes = {
   text: { name: "text" },
@@ -355,20 +354,27 @@ Editor.prototype = {
       throw new Error("Can't load a script until the editor is loaded.")
     }
     let win = this.container.contentWindow.wrappedJSObject;
     Services.scriptloader.loadSubScript(url, win, "utf8");
   },
 
   /**
    * Changes the value of a currently used highlighting mode.
-   * See Editor.modes for the list of all suppoert modes.
+   * See Editor.modes for the list of all supported modes.
    */
   setMode: function (value) {
     this.setOption("mode", value);
+
+    // If autocomplete was set up and the mode is changing, then
+    // turn it off and back on again so the proper mode can be used.
+    if (this.config.autocomplete) {
+      this.setOption("autocomplete", false);
+      this.setOption("autocomplete", true);
+    }
   },
 
   /**
    * Returns text from the text area. If line argument is provided
    * the method returns only that line.
    */
   getText: function (line) {
     let cm = editors.get(this);
@@ -861,25 +867,63 @@ Editor.prototype = {
    */
   setFontSize: function (size) {
     let cm = editors.get(this);
     cm.getWrapperElement().style.fontSize = parseInt(size, 10) + "px";
     cm.refresh();
   },
 
   /**
+   * Sets an option for the editor.  For most options it just defers to
+   * CodeMirror.setOption, but certain ones are maintained within the editor
+   * instance.
+   */
+  setOption: function(o, v) {
+    let cm = editors.get(this);
+    if (o === "autocomplete") {
+      this.config.autocomplete = v;
+      this.setupAutoCompletion();
+    } else {
+      cm.setOption(o, v);
+    }
+  },
+
+  /**
+   * Gets an option for the editor.  For most options it just defers to
+   * CodeMirror.getOption, but certain ones are maintained within the editor
+   * instance.
+   */
+  getOption: function(o) {
+    let cm = editors.get(this);
+    if (o === "autocomplete") {
+      return this.config.autocomplete;
+    } else {
+      return cm.getOption(o);
+    }
+  },
+
+  /**
    * Sets up autocompletion for the editor. Lazily imports the required
    * dependencies because they vary by editor mode.
+   *
+   * Autocompletion is special, because we don't want to automatically use
+   * it just because it is preffed on (it still needs to be requested by the
+   * editor), but we do want to always disable it if it is preffed off.
    */
   setupAutoCompletion: function (options = {}) {
-    if (this.config.autocomplete) {
+    // The autocomplete module will overwrite this.initializeAutoCompletion
+    // with a mode specific autocompletion handler.
+    if (!this.initializeAutoCompletion) {
       this.extend(require("./autocomplete"));
-      // The autocomplete module will overwrite this.setupAutoCompletion with
-      // a mode specific autocompletion handler.
-      this.setupAutoCompletion(options);
+    }
+
+    if (this.config.autocomplete && Services.prefs.getBoolPref(AUTOCOMPLETE)) {
+      this.initializeAutoCompletion(options);
+    } else {
+      this.destroyAutoCompletion();
     }
   },
 
   /**
    * Extends an instance of the Editor object with additional
    * functions. Each function will be called with context as
    * the first argument. Context is a {ed, cm} object where
    * 'ed' is an instance of the Editor object and 'cm' is an
diff --git a/browser/devtools/sourceeditor/test/browser.ini b/browser/devtools/sourceeditor/test/browser.ini
--- a/browser/devtools/sourceeditor/test/browser.ini
+++ b/browser/devtools/sourceeditor/test/browser.ini
@@ -15,16 +15,18 @@ support-files =
   cm_vim_test.js
   codemirror.html
   css_statemachine_testcases.css
   css_statemachine_tests.json
   css_autocompletion_tests.json
   vimemacs.html
   head.js
 
+[browser_editor_autocomplete_basic.js]
+[browser_editor_autocomplete_js.js]
 [browser_editor_basic.js]
 [browser_editor_cursor.js]
 [browser_editor_goto_line.js]
 [browser_editor_history.js]
 [browser_editor_markers.js]
 [browser_editor_movelines.js]
 [browser_editor_addons.js]
 [browser_codemirror.js]
diff --git a/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_basic.js
@@ -0,0 +1,62 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const AUTOCOMPLETION_PREF = "devtools.editor.autocomplete";
+
+// Test to make sure that different autocompletion modes can be created,
+// switched, and destroyed.  This doesn't test the actual autocompletion
+// popups, only their integration with the editor.
+function test() {
+  waitForExplicitFinish();
+  setup((ed, win) => {
+    let edWin = ed.container.contentWindow.wrappedJSObject;
+    testJS(ed, edWin);
+    testCSS(ed, edWin);
+    testPref(ed, edWin);
+    teardown(ed, win);
+  });
+}
+
+function testJS(ed, win) {
+  ok (!ed.getOption("autocomplete"), "Autocompletion is not set");
+  ok (!win.tern, "Tern is not defined on the window");
+
+  ed.setMode(Editor.modes.js);
+  ed.setOption("autocomplete", true);
+
+  ok (ed.getOption("autocomplete"), "Autocompletion is set");
+  ok (win.tern, "Tern is defined on the window");
+}
+
+function testCSS(ed, win) {
+  ok (ed.getOption("autocomplete"), "Autocompletion is set");
+  ok (win.tern, "Tern is currently defined on the window");
+
+  ed.setMode(Editor.modes.css);
+  ed.setOption("autocomplete", true);
+
+  ok (ed.getOption("autocomplete"), "Autocompletion is still set");
+  ok (!win.tern, "Tern is no longer defined on the window");
+}
+
+function testPref(ed, win) {
+
+  ed.setMode(Editor.modes.js);
+  ed.setOption("autocomplete", true);
+
+  ok (ed.getOption("autocomplete"), "Autocompletion is set");
+  ok (win.tern, "Tern is defined on the window");
+
+  info ("Preffing autocompletion off");
+  Services.prefs.setBoolPref(AUTOCOMPLETION_PREF, false);
+
+  ed.setupAutoCompletion();
+
+  ok (ed.getOption("autocomplete"), "Autocompletion is still set");
+  ok (!win.tern, "Tern is no longer defined on the window");
+
+  Services.prefs.clearUserPref(AUTOCOMPLETION_PREF);
+}
diff --git a/browser/devtools/sourceeditor/test/browser_editor_autocomplete_js.js b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_js.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_editor_autocomplete_js.js
@@ -0,0 +1,44 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test to make sure that JS autocompletion is opening popups.
+function test() {
+  waitForExplicitFinish();
+  setup((ed, win) => {
+    let edWin = ed.container.contentWindow.wrappedJSObject;
+    testJS(ed, edWin).then(() => {
+      teardown(ed, win);
+    });
+  });
+}
+
+function testJS(ed, win) {
+  ok (!ed.getOption("autocomplete"), "Autocompletion is not set");
+  ok (!win.tern, "Tern is not defined on the window");
+
+  ed.setMode(Editor.modes.js);
+  ed.setOption("autocomplete", true);
+
+  ok (ed.getOption("autocomplete"), "Autocompletion is set");
+  ok (win.tern, "Tern is defined on the window");
+
+  ed.focus();
+  ed.setText("document.");
+  ed.setCursor({line: 0, ch: 9});
+
+  let waitForSuggestion = promise.defer();
+
+  ed.on("before-suggest", () => {
+    info("before-suggest has been triggered");
+    EventUtils.synthesizeKey("VK_ESCAPE", { }, win);
+    waitForSuggestion.resolve();
+  });
+
+  let autocompleteKey = Editor.keyFor("autocompletion", { noaccel: true }).toUpperCase();
+  EventUtils.synthesizeKey("VK_" + autocompleteKey, { ctrlKey: true }, win);
+
+  return waitForSuggestion.promise;
+}
diff --git a/browser/devtools/sourceeditor/test/head.js b/browser/devtools/sourceeditor/test/head.js
--- a/browser/devtools/sourceeditor/test/head.js
+++ b/browser/devtools/sourceeditor/test/head.js
@@ -2,16 +2,17 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 const { require } = devtools;
 const Editor  = require("devtools/sourceeditor/editor");
+const {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 
 gDevTools.testing = true;
 SimpleTest.registerCleanupFunction(() => {
   gDevTools.testing = false;
 });
 
 function setup(cb) {
   const opt = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
diff --git a/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js b/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js
--- a/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js
+++ b/browser/devtools/styleeditor/test/browser_styleeditor_autocomplete.js
@@ -185,17 +185,19 @@ function testAutocompletionDisabled() {
   addTabAndOpenStyleEditors(1, testEditorAddedDisabled);
 
   content.location = TESTCASE_URI;
 }
 
 function testEditorAddedDisabled(panel) {
   info("Editor added, getting the source editor and starting tests");
   panel.UI.editors[0].getSourceEditor().then(editor => {
-    ok(!editor.sourceEditor.getAutocompletionPopup,
+    is(editor.sourceEditor.getOption("autocomplete"), false,
+       "Autocompletion option does not exist");
+    ok(!editor.sourceEditor.getAutocompletionPopup(),
        "Autocompletion popup does not exist");
     cleanup();
   });
 }
 
 function cleanup() {
   Services.prefs.clearUserPref(AUTOCOMPLETION_PREF);
   gEditor = null;
