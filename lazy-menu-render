# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  44785baf68ee494b54d8f077958dacd8db5a7d6b

diff --git a/toolkit/content/widgets/menu.js b/toolkit/content/widgets/menu.js
--- a/toolkit/content/widgets/menu.js
+++ b/toolkit/content/widgets/menu.js
@@ -154,74 +154,98 @@ class MozMenuCaption extends MozMenuBase
       <label class="menu-iconic-highlightable-text" crop="right" role="none"></label>
     `));
     this.initializeAttributeInheritance();
   }
 }
 
 customElements.define("menucaption", MozMenuCaption);
 
+// In general, don't render menus inside menupopups until they are going to be visible:
+window.addEventListener("popupshowing", (e) => {
+  if (e.originalTarget.ownerDocument != document) {
+    return;
+  }
+  for (let menu of e.originalTarget.querySelectorAll("menu")) {
+    menu.render();
+  }
+}, { capture: true });
+
+
+let isHiddenWindow = window.location.href == "chrome://browser/content/hiddenWindow.xul";
+// let numMenus1 = 0;
+// let numMenus2 = 0;
+// let numMenus3 = 0;
+// let numMenus4 = 0;
+// window.addEventListener("DOMContentLoaded", (e) => {
+//   if (document == e.target) {
+//     console.log(`${numMenus1},${numMenus2},${numMenus3},${numMenus4} created`, document.documentURI);
+//   }
+// });
+
 class MozMenu extends MozMenuBaseMixin(MozElementMixin(XULMenuElement)) {
   static get inheritedAttributes() {
     return {
       ".menubar-text": "value=label,accesskey,crop",
       ".menu-iconic-text": "value=label,accesskey,crop,highlightable",
       ".menu-text": "value=label,accesskey,crop,highlightable",
       ".menu-iconic-highlightable-text": "text=label,crop,accesskey,highlightable",
       ".menubar-left": "src=image",
       ".menu-iconic-icon": "src=image",
       ".menu-iconic-accel": "value=acceltext",
       ".menu-right": "_moz-menuactive,disabled",
       ".menu-accel": "value=acceltext",
     };
   }
 
   get isInMenubar() {
-    return this.closest("menubar");
+    return this.matches("menubar > menu");
+  }
+
+  get isInMenupopup() {
+    return this.matches("menupopup menu");
   }
 
   get isIconic() {
     return this.classList.contains("menu-iconic");
   }
 
-  connectedCallback() {
-    if (this.delayConnectedCallback()) {
-      return;
-    }
-
+  render() {
     // There are 4 types of menus: (1) inside a menubar, (2) inside a menubar + iconic,
     // (3) Outside a menubar, and (4) Outside a menubar + iconic.
     // To make this as simple as possible, we don't support menus being changed from one
     // of these types to another after the initial DOM connection. It'd be possible to make
     // this work by keeping track of the markup we prepend and then removing / re-prepending
     // during a change, but it's not a feature we use anywhere currently.
-    if (this.connectedOnce) {
+    if (this.renderedOnce) {
       return;
     }
-    this.connectedOnce = true;
+    this.renderedOnce = true;
 
     let {isInMenubar, isIconic} = this;
     let frag = null;
     // Add role="none" on all DOM, since XULMenuAccessible handles accessibility here.
     if (isInMenubar && isIconic) {
       if (!MozMenu.menubarIconicFrag) {
         MozMenu.menubarIconicFrag = MozXULElement.parseXULToFragment(`
           <image class="menubar-left" role="none"/>
           <label class="menubar-text" crop="right" role="none"/>
         `);
       }
       frag = MozMenu.menubarIconicFrag;
+      // numMenus1++;
     }
     if (isInMenubar && !isIconic) {
       if (!MozMenu.menubarFrag) {
         MozMenu.menubarFrag = MozXULElement.parseXULToFragment(`
         <label class="menubar-text" crop="right" role="none"/>
       `);
       }
       frag = MozMenu.menubarFrag;
+      // numMenus2++;
     }
     if (!isInMenubar && isIconic) {
       if (!MozMenu.normalIconicFrag) {
         MozMenu.normalIconicFrag = MozXULElement.parseXULToFragment(`
         <hbox class="menu-iconic-left" align="center" pack="center" role="none">
           <image class="menu-iconic-icon" role="none"/>
         </hbox>
         <label class="menu-iconic-text" flex="1" crop="right" role="none"/>
@@ -230,32 +254,49 @@ class MozMenu extends MozMenuBaseMixin(M
           <label class="menu-iconic-accel" role="none"/>
         </hbox>
         <hbox align="center" class="menu-right" role="none">
           <image role="none"/>
         </hbox>
       `);
       }
       frag = MozMenu.normalIconicFrag;
+      // numMenus3++;
     }
     if (!isInMenubar && !isIconic) {
       if (!MozMenu.normalFrag) {
         MozMenu.normalFrag = MozXULElement.parseXULToFragment(`
         <label class="menu-text" crop="right" role="none"/>
         <hbox class="menu-accel-container" anonid="accel" role="none">
           <label class="menu-accel" role="none"/>
         </hbox>
         <hbox align="center" class="menu-right" role="none">
           <image role="none"/>
         </hbox>
       `);
       }
       frag = MozMenu.normalFrag;
+      // numMenus4++;
     }
 
     // There will be a <menupopup /> already. Don't clear it out, just put our markup before it.
     this.prepend(document.importNode(frag, true));
     this.initializeAttributeInheritance();
   }
+
+  connectedCallback() {
+    // On OSX we will have a bunch of menus in the hidden window. They get converted
+    // into native menus based on the host attributes, so the inner DOM doesn't need
+    // to be created.
+    // Also if we are in a hidden menupopup then don't render until it's opened.
+    if (isHiddenWindow || this.isInMenupopup) {
+      return;
+    }
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    this.render();
+  }
 }
 
 customElements.define("menu", MozMenu);
 }
