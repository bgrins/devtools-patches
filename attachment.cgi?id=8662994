# HG changeset patch
# User Neil Deakin <neil@mozilla.com>
# Parent  364ffba41f29b232f8f2d1c846165383fdac8482

diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -849,16 +849,17 @@ GK_ATOM(onpairingaborted, "onpairingabor
 GK_ATOM(onpairingconfirmationreq, "onpairingconfirmationreq")
 GK_ATOM(onpairingconsentreq, "onpairingconsentreq")
 GK_ATOM(onpaste, "onpaste")
 GK_ATOM(onpendingchange, "onpendingchange")
 GK_ATOM(onpichange, "onpichange")
 GK_ATOM(onpicture, "onpicture")
 GK_ATOM(onpopuphidden, "onpopuphidden")
 GK_ATOM(onpopuphiding, "onpopuphiding")
+GK_ATOM(onpopuppositioned, "onpopuppositioned")
 GK_ATOM(onpopupshowing, "onpopupshowing")
 GK_ATOM(onpopupshown, "onpopupshown")
 GK_ATOM(onposter, "onposter")
 GK_ATOM(onpreviewstatechange, "onpreviewstatechange")
 GK_ATOM(onpullphonebookreq, "onpullphonebookreq")
 GK_ATOM(onpullvcardentryreq, "onpullvcardentryreq")
 GK_ATOM(onpullvcardlistingreq, "onpullvcardlistingreq")
 GK_ATOM(onpush, "onpush")
diff --git a/dom/events/EventNameList.h b/dom/events/EventNameList.h
--- a/dom/events/EventNameList.h
+++ b/dom/events/EventNameList.h
@@ -706,16 +706,20 @@ NON_IDL_EVENT(close,
 NON_IDL_EVENT(popupshowing,
               eXULPopupShowing,
               EventNameType_XUL,
               eBasicEventClass)
 NON_IDL_EVENT(popupshown,
               eXULPopupShown,
               EventNameType_XUL,
               eBasicEventClass)
+NON_IDL_EVENT(popuppositioned,
+              eXULPopupPositioned,
+              EventNameType_XUL,
+              eBasicEventClass)
 NON_IDL_EVENT(popuphiding,
               eXULPopupHiding,
               EventNameType_XUL,
               eBasicEventClass)
 NON_IDL_EVENT(popuphidden,
               eXULPopupHidden,
               EventNameType_XUL,
               eBasicEventClass)
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -470,17 +470,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
   if (sizeChanged) {
     SetBounds(aState, nsRect(0, 0, prefSize.width, prefSize.height), false);
     mPrefSize = prefSize;
   }
 
   bool needCallback = false;
 
   if (shouldPosition) {
-    SetPopupPosition(aAnchor, false, aSizedToPopup);
+    SetPopupPosition(aAnchor, false, aSizedToPopup, false);
     needCallback = true;
   }
 
   nsRect bounds(GetRect());
   Layout(aState);
 
   // if the width or height changed, readjust the popup position. This is a
   // special case for tooltips where the preferred height doesn't include the
@@ -488,17 +488,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
   // This is bug 228673 which doesn't have a simple fix.
   if (!aParentMenu) {
     nsSize newsize = GetSize();
     if (newsize.width > bounds.width || newsize.height > bounds.height) {
       // the size after layout was larger than the preferred size,
       // so set the preferred size accordingly
       mPrefSize = newsize;
       if (isOpen) {
-        SetPopupPosition(aAnchor, false, aSizedToPopup);
+        SetPopupPosition(aAnchor, false, aSizedToPopup, false);
         needCallback = true;
       }
     }
   }
 
   nsPresContext* pc = PresContext();
   nsView* view = GetView();
 
@@ -550,17 +550,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
     pc->PresShell()->PostReflowCallback(this);
     mReflowCallbackData.MarkPosted(aAnchor, aSizedToPopup);
   }
 }
 
 bool
 nsMenuPopupFrame::ReflowFinished()
 {
-  SetPopupPosition(mReflowCallbackData.mAnchor, false, mReflowCallbackData.mSizedToPopup);
+  SetPopupPosition(mReflowCallbackData.mAnchor, false, mReflowCallbackData.mSizedToPopup, false);
 
   mReflowCallbackData.Clear();
 
   return false;
 }
 
 void
 nsMenuPopupFrame::ReflowCallbackCanceled()
@@ -1217,17 +1217,17 @@ nsMenuPopupFrame::FlipOrResize(nscoord& 
   // smaller than the calculated popup size, just use the original size instead.
   if (popupSize <= 0 || aSize < popupSize) {
     popupSize = aSize;
   }
   return std::min(popupSize, aScreenEnd - aScreenPoint);
 }
 
 nsresult
-nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame, bool aIsMove, bool aSizedToPopup)
+nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame, bool aIsMove, bool aSizedToPopup, bool aNotify)
 {
   if (!mShouldAutoPosition)
     return NS_OK;
 
   // If this is due to a move, return early if the popup hasn't been laid out
   // yet. On Windows, this can happen when using a drag popup before it opens.
   if (aIsMove && (mPrefSize.width == -1 || mPrefSize.height == -1)) {
     return NS_OK;
@@ -1508,16 +1508,20 @@ nsMenuPopupFrame::SetPopupPosition(nsIFr
   nsBoxFrame::SetPosition(viewPoint - GetParent()->GetOffsetTo(rootFrame));
 
   if (aSizedToPopup) {
     nsBoxLayoutState state(PresContext());
     // XXXndeakin can parentSize.width still extend outside?
     SetBounds(state, mRect);
   }
 
+  if (aNotify) {
+    nsXULPopupPositionedEvent::Dispatch(mContent, false, false, false);
+  }
+
   return NS_OK;
 }
 
 /* virtual */ nsMenuFrame*
 nsMenuPopupFrame::GetCurrentMenuItem()
 {
   return mCurrentMenu;
 }
@@ -2185,17 +2189,17 @@ nsMenuPopupFrame::MoveTo(int32_t aLeft, 
   }
 
   nsPresContext* presContext = PresContext();
   mAnchorType = aLeft == -1 || aTop == -1 ?
                 MenuPopupAnchorType_Node : MenuPopupAnchorType_Point;
   mScreenRect.x = aLeft - presContext->AppUnitsToIntCSSPixels(margin.left);
   mScreenRect.y = aTop - presContext->AppUnitsToIntCSSPixels(margin.top);
 
-  SetPopupPosition(nullptr, true, false);
+  SetPopupPosition(nullptr, true, false, true);
 
   nsCOMPtr<nsIContent> popup = mContent;
   if (aUpdateAttrs && (popup->HasAttr(kNameSpaceID_None, nsGkAtoms::left) ||
                        popup->HasAttr(kNameSpaceID_None, nsGkAtoms::top)))
   {
     nsAutoString left, top;
     left.AppendInt(aLeft);
     top.AppendInt(aTop);
@@ -2214,17 +2218,17 @@ nsMenuPopupFrame::MoveToAnchor(nsIConten
 
   nsPopupState oldstate = mPopupState;
   InitializePopup(aAnchorContent, mTriggerContent, aPosition,
                   aXPos, aYPos, MenuPopupAnchorType_Node, aAttributesOverride);
   // InitializePopup changed the state so reset it.
   mPopupState = oldstate;
 
   // Pass false here so that flipping and adjusting to fit on the screen happen.
-  SetPopupPosition(nullptr, false, false);
+  SetPopupPosition(nullptr, false, false, true);
 }
 
 bool
 nsMenuPopupFrame::GetAutoPosition()
 {
   return mShouldAutoPosition;
 }
 
diff --git a/layout/xul/nsMenuPopupFrame.h b/layout/xul/nsMenuPopupFrame.h
--- a/layout/xul/nsMenuPopupFrame.h
+++ b/layout/xul/nsMenuPopupFrame.h
@@ -242,18 +242,20 @@ public:
                    nsIFrame* aAnchor, bool aSizedToPopup);
 
   nsView* GetRootViewForPopup(nsIFrame* aStartFrame);
 
   // Set the position of the popup either relative to the anchor aAnchorFrame
   // (or the frame for mAnchorContent if aAnchorFrame is null), anchored at a
   // rectangle, or at a specific point if a screen position is set. The popup
   // will be adjusted so that it is on screen. If aIsMove is true, then the
-  // popup is being moved, and should not be flipped.
-  nsresult SetPopupPosition(nsIFrame* aAnchorFrame, bool aIsMove, bool aSizedToPopup);
+  // popup is being moved, and should not be flipped. If aNotify is true, then
+  // a popuppositioned event is sent.
+  nsresult SetPopupPosition(nsIFrame* aAnchorFrame, bool aIsMove,
+                            bool aSizedToPopup, bool aNotify);
 
   bool HasGeneratedChildren() { return mGeneratedChildren; }
   void SetGeneratedChildren() { mGeneratedChildren = true; }
 
   // called when the Enter key is pressed while the popup is open. This will
   // just pass the call down to the current menu, if any. If a current menu
   // should be opened as a result, this method should return the frame for
   // that menu, or null if no menu should be opened. Also, calling Enter will
diff --git a/layout/xul/nsXULPopupManager.cpp b/layout/xul/nsXULPopupManager.cpp
--- a/layout/xul/nsXULPopupManager.cpp
+++ b/layout/xul/nsXULPopupManager.cpp
@@ -423,17 +423,17 @@ nsXULPopupManager::AdjustPopupsOnWindowC
         }
       }
     }
 
     item = item->GetParent();
   }
 
   for (int32_t l = list.Length() - 1; l >= 0; l--) {
-    list[l]->SetPopupPosition(nullptr, true, false);
+    list[l]->SetPopupPosition(nullptr, true, false, true);
   }
 }
 
 void nsXULPopupManager::AdjustPopupsOnWindowChange(nsIPresShell* aPresShell)
 {
   if (aPresShell->GetDocument()) {
     AdjustPopupsOnWindowChange(aPresShell->GetDocument()->GetWindow());
   }
@@ -478,17 +478,17 @@ nsXULPopupManager::PopupMoved(nsIFrame* 
   }
 
   // Update the popup's position using SetPopupPosition if the popup is
   // anchored and at the parent level as these maintain their position
   // relative to the parent window. Otherwise, just update the popup to
   // the specified screen coordinates.
   if (menuPopupFrame->IsAnchored() &&
       menuPopupFrame->PopupLevel() == ePopupLevelParent) {
-    menuPopupFrame->SetPopupPosition(nullptr, true, false);
+    menuPopupFrame->SetPopupPosition(nullptr, true, false, true);
   }
   else {
     nsPresContext* presContext = menuPopupFrame->PresContext();
     aPnt.x = presContext->DevPixelsToIntCSSPixels(aPnt.x);
     aPnt.y = presContext->DevPixelsToIntCSSPixels(aPnt.y);
     menuPopupFrame->MoveTo(aPnt.x, aPnt.y, false);
   }
 }
@@ -1416,17 +1416,21 @@ nsXULPopupManager::FirePopupShowingEvent
   if (popupFrame) {
     // if the event was cancelled, don't open the popup, reset its state back
     // to closed and clear its trigger content.
     if (status == nsEventStatus_eConsumeNoDefault) {
       popupFrame->SetPopupState(ePopupClosed);
       popupFrame->ClearTriggerContent();
     }
     else {
-      ShowPopupCallback(aPopup, popupFrame, aIsContextMenu, aSelectFirstItem);
+      // Now check if we need to fire the popuppositioned event. If not, call
+      // ShowPopupCallback directly.
+      if (!nsXULPopupPositionedEvent::Dispatch(aPopup, aIsContextMenu, aSelectFirstItem, true)) {
+        ShowPopupCallback(aPopup, popupFrame, aIsContextMenu, aSelectFirstItem);
+      }
     }
   }
 }
 
 void
 nsXULPopupManager::FirePopupHidingEvent(nsIContent* aPopup,
                                         nsIContent* aNextPopup,
                                         nsIContent* aLastPopup,
@@ -2617,16 +2621,62 @@ nsXULPopupHidingEvent::Run()
                                  context, mPopupType, mDeselectMenu, mIsRollup);
       }
     }
   }
 
   return NS_OK;
 }
 
+bool
+nsXULPopupPositionedEvent::Dispatch(nsIContent *aPopup,
+                                    bool aIsContextMenu,
+                                    bool aSelectFirstItem,
+                                    bool aIsOpening)
+{
+  // The popuppositioned event only fires on arrow panels for now.
+  if (aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
+                          nsGkAtoms::arrow, eCaseMatters)) {
+    nsCOMPtr<nsIRunnable> event =
+      new nsXULPopupPositionedEvent(aPopup, aIsContextMenu, aSelectFirstItem, aIsOpening);
+    NS_DispatchToCurrentThread(event);
+
+    return true;
+  }
+
+  return false;
+}
+
+NS_IMETHODIMP
+nsXULPopupPositionedEvent::Run()
+{
+  nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
+  if (pm) {
+    nsMenuPopupFrame* popupFrame = do_QueryFrame(mPopup->GetPrimaryFrame());
+    if (popupFrame) {
+      nsEventStatus status = nsEventStatus_eIgnore;
+      WidgetMouseEvent event(true, eXULPopupPositioned, nullptr,
+                             WidgetMouseEvent::eReal);
+      EventDispatcher::Dispatch(mPopup, popupFrame->PresContext(),
+                                &event, nullptr, &status);
+
+      // If aIsOpening is true, then this position is caused because the popup is
+      // being opened, so continue opening it.
+      if (mIsOpening) {
+        nsMenuPopupFrame* popupFrame = do_QueryFrame(mPopup->GetPrimaryFrame());
+        if (popupFrame) {
+          pm->ShowPopupCallback(mPopup, popupFrame, mIsContextMenu, mSelectFirstItem);
+        }
+      }
+    }
+  }
+
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsXULMenuCommandEvent::Run()
 {
   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
   if (!pm)
     return NS_OK;
 
   // The order of the nsViewManager and nsIPresShell COM pointers is
diff --git a/layout/xul/nsXULPopupManager.h b/layout/xul/nsXULPopupManager.h
--- a/layout/xul/nsXULPopupManager.h
+++ b/layout/xul/nsXULPopupManager.h
@@ -231,16 +231,46 @@ private:
   nsCOMPtr<nsIContent> mPopup;
   nsCOMPtr<nsIContent> mNextPopup;
   nsCOMPtr<nsIContent> mLastPopup;
   nsPopupType mPopupType;
   bool mDeselectMenu;
   bool mIsRollup;
 };
 
+// this class is used for dispatching popuppositioned events asynchronously.
+class nsXULPopupPositionedEvent : public nsRunnable
+{
+public:
+  nsXULPopupPositionedEvent(nsIContent *aPopup,
+                            bool aIsContextMenu,
+                            bool aSelectFirstItem,
+                            bool aIsOpening)
+    : mPopup(aPopup),
+      mIsContextMenu(aIsContextMenu),
+      mSelectFirstItem(aSelectFirstItem),
+      mIsOpening(aIsOpening)
+  {
+    NS_ASSERTION(aPopup, "null popup supplied to nsXULPopupShowingEvent constructor");
+  }
+
+  NS_IMETHOD Run() override;
+
+  static bool Dispatch(nsIContent *aPopup,
+                       bool aIsContextMenu,
+                       bool aSelectFirstItem,
+                       bool aIsOpening);
+
+private:
+  nsCOMPtr<nsIContent> mPopup;
+  bool mIsContextMenu;
+  bool mSelectFirstItem;
+  bool mIsOpening;
+};
+
 // this class is used for dispatching menu command events asynchronously.
 class nsXULMenuCommandEvent : public nsRunnable
 {
 public:
   nsXULMenuCommandEvent(nsIContent *aMenu,
                         bool aIsTrusted,
                         bool aShift,
                         bool aControl,
@@ -281,16 +311,17 @@ class nsXULPopupManager final : public n
                                 public nsIRollupListener,
                                 public nsITimerCallback,
                                 public nsIObserver
 {
 
 public:
   friend class nsXULPopupShowingEvent;
   friend class nsXULPopupHidingEvent;
+  friend class nsXULPopupPositionedEvent;
   friend class nsXULMenuCommandEvent;
   friend class TransitionEnder;
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSIDOMEVENTLISTENER
 
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -352,67 +352,57 @@
     <implementation>
       <field name="_fadeTimer">null</field>
       <method name="sizeTo">
         <parameter name="aWidth"/>
         <parameter name="aHeight"/>
         <body>
         <![CDATA[
           this.popupBoxObject.sizeTo(aWidth, aHeight);
-          if (this.state == "open")
-            this.adjustArrowPosition();
         ]]>
         </body>
       </method>
       <method name="moveTo">
         <parameter name="aLeft"/>
         <parameter name="aTop"/>
         <body>
         <![CDATA[
           this.popupBoxObject.moveTo(aLeft, aTop);
-          if (this.state == "open")
-            this.adjustArrowPosition();
         ]]>
         </body>
       </method>
       <method name="moveToAnchor">
         <parameter name="aAnchorElement"/>
         <parameter name="aPosition"/>
         <parameter name="aX"/>
         <parameter name="aY"/>
         <parameter name="aAttributesOverride"/>
         <body>
         <![CDATA[
           this.popupBoxObject.moveToAnchor(aAnchorElement, aPosition, aX, aY, aAttributesOverride);
-          if (this.state == "open")
-            this.adjustArrowPosition();
         ]]>
         </body>
       </method>
       <method name="adjustArrowPosition">
         <body>
         <![CDATA[
         var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
-
         var anchor = this.anchorNode;
         if (!anchor) {
-          arrow.hidden = true;
           return;
         }
 
         var container = document.getAnonymousElementByAttribute(this, "anonid", "container");
         var arrowbox = document.getAnonymousElementByAttribute(this, "anonid", "arrowbox");
 
         var position = this.alignmentPosition;
         var offset = this.alignmentOffset;
 
         this.setAttribute("arrowposition", position);
 
-        // if this panel has a "sliding" arrow, we may have previously set margins...
-        arrowbox.style.removeProperty("transform");
         if (position.indexOf("start_") == 0 || position.indexOf("end_") == 0) {
           container.orient = "horizontal";
           arrowbox.orient = "vertical";
           if (position.indexOf("_after") > 0) {
             arrowbox.pack = "end";
           } else {
             arrowbox.pack = "start";
           }
@@ -444,26 +434,30 @@
             container.dir = "reverse";
             this.setAttribute("side", "bottom");
           }
           else {
             container.dir = "";
             this.setAttribute("side", "top");
           }
         }
-
-        arrow.hidden = false;
         ]]>
         </body>
       </method>
     </implementation>
     <handlers>
       <handler event="popupshowing" phase="target">
       <![CDATA[
+        var arrow = document.getAnonymousElementByAttribute(this, "anonid", "arrow");
+        arrow.hidden = this.anchorNode == null;
+        document.getAnonymousElementByAttribute(this, "anonid", "arrowbox")
+                .style.removeProperty("transform");
+
         this.adjustArrowPosition();
+
         if (this.getAttribute("animate") != "false") {
           this.setAttribute("animate", "open");
         }
 
         // set fading
         var fade = this.getAttribute("fade");
         var fadeDelay = (fade == "fast") ? 1 : fade == "slow" ? 4000 : 0;
         if (fadeDelay) {
@@ -488,16 +482,19 @@
         this.setAttribute("panelopen", "true");
       </handler>
       <handler event="popuphidden" phase="target">
         this.removeAttribute("panelopen");
         if (this.getAttribute("animate") != "false") {
           this.removeAttribute("animate");
         }
       </handler>
+      <handler event="popuppositioned" phase="target">
+        this.adjustArrowPosition();
+      </handler>
     </handlers>
   </binding>
 
   <binding id="tooltip" role="xul:tooltip"
            extends="chrome://global/content/bindings/popup.xml#popup-base">
     <content>
       <children>
         <xul:label class="tooltip-label" xbl:inherits="xbl:text=label" flex="1"/>
diff --git a/widget/EventMessageList.h b/widget/EventMessageList.h
--- a/widget/EventMessageList.h
+++ b/widget/EventMessageList.h
@@ -121,16 +121,17 @@ NS_EVENT_MESSAGE(eDragEnd)
 NS_EVENT_MESSAGE(eDragStart)
 NS_EVENT_MESSAGE(eDrop)
 NS_EVENT_MESSAGE(eDragLeave)
 NS_EVENT_MESSAGE_FIRST_LAST(eDragDropEvent, eDragEnter, eDragLeave)
 
 // XUL specific events
 NS_EVENT_MESSAGE(eXULPopupShowing)
 NS_EVENT_MESSAGE(eXULPopupShown)
+NS_EVENT_MESSAGE(eXULPopupPositioned)
 NS_EVENT_MESSAGE(eXULPopupHiding)
 NS_EVENT_MESSAGE(eXULPopupHidden)
 NS_EVENT_MESSAGE(eXULBroadcast)
 NS_EVENT_MESSAGE(eXULCommandUpdate)
 
 // Legacy mouse scroll (wheel) events
 NS_EVENT_MESSAGE(eLegacyMouseLineOrPageScroll)
 NS_EVENT_MESSAGE(eLegacyMousePixelScroll)
