# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5308e44ca2cd98ab20391ce2e344e79f61239e5a

diff --git a/devtools/client/framework/selection.js b/devtools/client/framework/selection.js
--- a/devtools/client/framework/selection.js
+++ b/devtools/client/framework/selection.js
@@ -115,19 +115,20 @@ Selection.prototype = {
     }
   },
 
   setNodeFront: function (value, reason = "unknown") {
     this.reason = reason;
 
     // If an inlineTextChild text node is being set, then set it's parent instead.
     let parentNode = value && value.parentNode();
-    if (value && parentNode && parentNode.inlineTextChild === value) {
-      value = parentNode;
-    }
+    // if (value && parentNode && parentNode.inlineTextChild === value) {
+    //   value = parentNode;
+    // }
+    console.log("Setting node front", value, reason);
 
     this._nodeFront = value;
     this.emit("new-node-front", value, this.reason);
   },
 
   get documentFront() {
     return this._walker.document(this._nodeFront);
   },
diff --git a/devtools/client/inspector/markup/markup.js b/devtools/client/inspector/markup/markup.js
--- a/devtools/client/inspector/markup/markup.js
+++ b/devtools/client/inspector/markup/markup.js
@@ -62,16 +62,19 @@ const ATTR_COLLAPSE_LENGTH_PREF = "devto
  * @param  {iframe} frame
  *         An iframe in which the caller has kindly loaded markup.xhtml.
  */
 function MarkupView(inspector, frame, controllerWindow) {
   this.inspector = inspector;
   this.walker = this.inspector.walker;
   this._frame = frame;
   this.win = this._frame.contentWindow;
+  this.win.setInterval(() => {
+    console.log("Walker node for: server1.conn1.child1/domnode53", this.walker.get("server1.conn1.child1/domnode53"));
+  }, 2000)
   this.doc = this._frame.contentDocument;
   this._elt = this.doc.querySelector("#root");
 
   this.maxChildren = Services.prefs.getIntPref("devtools.markup.pagesize",
                                                DEFAULT_MAX_CHILDREN);
 
   this.collapseAttributes =
     Services.prefs.getBoolPref(ATTR_COLLAPSE_ENABLED_PREF);
@@ -945,20 +948,22 @@ MarkupView.prototype = {
    *         Whether the newly imported node should be flashed
    * @return {MarkupContainer} The MarkupContainer object for this element.
    */
   importNode: function (node, flashNode) {
     if (!node) {
       return null;
     }
 
-    if (this._containers.has(node)) {
+    if (this._containers.has(node) && node.nodeType) {
       return this.getContainer(node);
     }
 
+    console.log("Importing node for first time", node, node.nodeType);
+    console.trace();
     let container;
     let {nodeType, isPseudoElement} = node;
     if (node === this.walker.rootNode) {
       container = new RootContainer(this, node);
       this._elt.appendChild(container.elt);
       this._rootNode = node;
     } else if (nodeType == nodeConstants.ELEMENT_NODE && !isPseudoElement) {
       container = new MarkupElementContainer(this, node, this.inspector);
diff --git a/devtools/server/actors/highlighters.js b/devtools/server/actors/highlighters.js
--- a/devtools/server/actors/highlighters.js
+++ b/devtools/server/actors/highlighters.js
@@ -378,16 +378,18 @@ exports.HighlighterActor = protocol.Acto
     return pickResults;
   },
 
   _findAndAttachElement: function (event) {
     // originalTarget allows access to the "real" element before any retargeting
     // is applied, such as in the case of XBL anonymous elements.  See also
     // https://developer.mozilla.org/docs/XBL/XBL_1.0_Reference/Anonymous_Content#Event_Flow_and_Targeting
     let node = event.originalTarget || event.target;
+
+    console.log("_findAndAttachElement", event.originalTarget, event.target)
     return this._walker.attachElement(node);
   },
 
   _startPickerListeners: function () {
     let target = this._highlighterEnv.pageListenerTarget;
     target.addEventListener("mousemove", this._onHovered, true);
     target.addEventListener("click", this._onPick, true);
     target.addEventListener("mousedown", this._preventContentEvent, true);
diff --git a/devtools/server/actors/inspector.js b/devtools/server/actors/inspector.js
--- a/devtools/server/actors/inspector.js
+++ b/devtools/server/actors/inspector.js
@@ -245,16 +245,20 @@ var NodeActor = exports.NodeActor = prot
   form: function (detail) {
     if (detail === "actorid") {
       return this.actorID;
     }
 
     let parentNode = this.walker.parentNode(this);
     let inlineTextChild = this.walker.inlineTextChild(this);
 
+    if (parentNode && parentNode.actorID === "server1.conn1.child1/domnode53") {
+          console.log("Fetching form for: ", this.actorID, this.rawNode.nodeType, parentNode && parentNode.actorID, parentNode, parentNode && this.walker.parentNode(parentNode));
+
+    }
     let form = {
       actor: this.actorID,
       baseURI: this.rawNode.baseURI,
       parent: parentNode ? parentNode.actorID : undefined,
       nodeType: this.rawNode.nodeType,
       namespaceURI: this.rawNode.namespaceURI,
       nodeName: this.rawNode.nodeName,
       nodeValue: this.rawNode.nodeValue,
@@ -1039,23 +1043,24 @@ var WalkerActor = protocol.ActorClassWit
     return this._refMap.get(rawNode);
   },
 
   _ref: function (node) {
     let actor = this.getNode(node);
     if (actor) {
       return actor;
     }
-
     actor = new NodeActor(this, node);
 
     // Add the node actor as a child of this walker actor, assigning
     // it an actorID.
     this.manage(actor);
     this._refMap.set(node, actor);
+    console.log("Creating a new actor", this, node, actor, actor.actorID);
+    console.trace();
 
     if (node.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE) {
       actor.watchDocument(this.onMutations);
     }
     return actor;
   },
 
   _onReflows: function (reflows) {
@@ -1136,16 +1141,17 @@ var WalkerActor = protocol.ActorClassWit
       if (!(node instanceof NodeActor)) {
         // If an anonymous node was passed in and we aren't supposed to know
         // about it, then consult with the document walker as the source of
         // truth about which elements exist.
         if (!this.showAllAnonymousContent && isAnonymous(node)) {
           node = this.getDocumentWalker(node).currentNode;
         }
 
+        console.log("")
         node = this._ref(node);
       }
 
       this.ensurePathToRoot(node, newParents);
       // If nodes may be an array of raw nodes, we're sure to only have
       // NodeActors with the following array.
       nodeActors.push(node);
     }
@@ -1237,16 +1243,17 @@ var WalkerActor = protocol.ActorClassWit
   inlineTextChild: function (node) {
     // Quick checks to prevent creating a new walker if possible.
     if (node.isBeforePseudoElement ||
         node.isAfterPseudoElement ||
         node.rawNode.nodeType != Ci.nsIDOMNode.ELEMENT_NODE ||
         node.rawNode.children.length > 0) {
       return undefined;
     }
+    return undefined;
 
     let docWalker = this.getDocumentWalker(node.rawNode);
     let firstChild = docWalker.firstChild();
 
     // Bail out if:
     // - more than one child
     // - unique child is not a text node
     // - unique child is a text node, but is too long to be inlined
@@ -1334,19 +1341,21 @@ var WalkerActor = protocol.ActorClassWit
     if (!node) {
       return newParents;
     }
     let walker = this.getDocumentWalker(node.rawNode);
     let cur;
     while ((cur = walker.parentNode())) {
       let parent = this.getNode(cur);
       if (!parent) {
+      console.log("CURR - No exist", node.rawNode);
         // This parent didn't exist, so hasn't been seen by the client yet.
         newParents.add(this._ref(cur));
       } else {
+      console.log("CURR - Yes exist", parent, this.getNode(walker.parentNode()));
         // This parent did exist, so the client knows about it.
         return newParents;
       }
     }
     return newParents;
   },
 
   /**
diff --git a/devtools/shared/fronts/inspector.js b/devtools/shared/fronts/inspector.js
--- a/devtools/shared/fronts/inspector.js
+++ b/devtools/shared/fronts/inspector.js
@@ -390,16 +390,17 @@ const NodeFront = FrontClassWithSpec(nod
     }
     if (this._next) {
       this._next._prev = this._prev;
     }
     this._next = null;
     this._prev = null;
     this._parent = parent;
     if (!parent) {
+      console.log("Disconnected subtree");
       // Subtree is disconnected, we're done
       return;
     }
     this._next = parent._child;
     if (this._next) {
       this._next._prev = this;
     }
     parent._child = this;
@@ -557,17 +558,21 @@ const WalkerFront = FrontClassWithSpec(w
    * with a real form by the end of the deserialization.
    */
   ensureParentFront: function (id) {
     let front = this.get(id);
     if (front) {
       return front;
     }
 
-    return types.getType("domnode").read({ actor: id }, this, "standin");
+    console.log("ID", id);
+
+   var ret = types.getType("domnode").read({ actor: id }, this, "standin");
+   console.log("returning?", this.get(id));
+   return ret;
   },
 
   /**
    * See the documentation for WalkerActor.prototype.retainNode for
    * information on retained nodes.
    *
    * From the client's perspective, `retainNode` can fail if the node in
    * question is removed from the ownership tree before the `retainNode`
@@ -581,16 +586,17 @@ const WalkerFront = FrontClassWithSpec(w
    * will stay in a consistent state.
    *
    * Because the protocol guarantees that requests will be processed and
    * responses received in the order they were sent, we get the right
    * semantics by setting our local retained flag on the node only AFTER
    * a SUCCESSFUL retainNode call.
    */
   retainNode: custom(function (node) {
+    console.log("Retaining node", node);
     return this._retainNode(node).then(() => {
       node.retained = true;
     });
   }, {
     impl: "_retainNode",
   }),
 
   unretainNode: custom(function (node) {
@@ -720,16 +726,17 @@ const WalkerFront = FrontClassWithSpec(w
       resultsLength: nodeList.length,
       resultsIndex: searchData.index,
     };
   }), {
     impl: "_search"
   }),
 
   _releaseFront: function (node, force) {
+    console.log("Releasing front", node, force);
     if (node.retained && !force) {
       node.reparent(null);
       this._retainedOrphans.add(node);
       return;
     }
 
     if (node.retained) {
       // Forcing a removal.
