# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  5e72c3c8582ce72bbf386375f054c881a333480b

diff --git a/browser/base/content/browser-fullZoom.js b/browser/base/content/browser-fullZoom.js
--- a/browser/base/content/browser-fullZoom.js
+++ b/browser/base/content/browser-fullZoom.js
@@ -341,17 +341,17 @@ var FullZoom = {
     if (!this.siteSpecific || gInPrintPreviewMode) {
       this._executeSoon(aCallback);
       return;
     }
 
     // The browser is sometimes half-destroyed because this method is called
     // by content pref service callbacks, which themselves can be called at any
     // time, even after browsers are closed.
-    if (!aBrowser.parentNode || aBrowser.isSyntheticDocument) {
+    if (!aBrowser.mInitialized || aBrowser.isSyntheticDocument) {
       this._executeSoon(aCallback);
       return;
     }
 
     if (aValue !== undefined) {
       ZoomManager.setZoomForBrowser(aBrowser, this._ensureValid(aValue));
       this._ignorePendingZoomAccesses(aBrowser);
       this._executeSoon(aCallback);
@@ -530,19 +530,19 @@ var FullZoom = {
 
   /**
    * Asynchronously broadcasts "browser-fullZoom:location-change" so that
    * listeners can be notified when the zoom levels on those pages change.
    * The notification is always asynchronous so that observers are guaranteed a
    * consistent behavior.
    */
   _notifyOnLocationChange: function FullZoom__notifyOnLocationChange(browser) {
-    this._executeSoon(function() {
-      Services.obs.notifyObservers(browser, "browser-fullZoom:location-change");
-    });
+    // this._executeSoon(function() {
+    //   Services.obs.notifyObservers(browser, "browser-fullZoom:location-change");
+    // });
   },
 
   _executeSoon: function FullZoom__executeSoon(callback) {
     if (!callback)
       return;
     Services.tm.dispatchToMainThread(callback);
   },
 };
diff --git a/toolkit/components/contentprefs/ContentPrefService2.js b/toolkit/components/contentprefs/ContentPrefService2.js
--- a/toolkit/components/contentprefs/ContentPrefService2.js
+++ b/toolkit/components/contentprefs/ContentPrefService2.js
@@ -180,24 +180,26 @@ ContentPrefService2.prototype = {
       onRow: row => {
         let grp = row.getResultByName("grp");
         let val = row.getResultByName("value");
         this._cache.set(grp, name, val);
         if (!pbPrefs.has(grp, name))
           cbHandleResult(callback, new ContentPref(grp, name, val));
       },
       onDone: (reason, ok, gotRow) => {
+        console.log("Got onDone for content prefs", ok, reason);
         if (ok) {
           for (let [pbGroup, pbName, pbVal] of pbPrefs) {
             cbHandleResult(callback, new ContentPref(pbGroup, pbName, pbVal));
           }
         }
         cbHandleCompletion(callback, reason);
       },
       onError: nsresult => {
+        console.log("Got onerror for content prefs", nsresult);
         cbHandleError(callback, nsresult);
       },
     });
   },
 
   getByDomainAndName: function CPS2_getByDomainAndName(group, name, context,
                                                        callback) {
     checkGroupArg(group);
diff --git a/toolkit/content/widgets/browser-custom-element.js b/toolkit/content/widgets/browser-custom-element.js
--- a/toolkit/content/widgets/browser-custom-element.js
+++ b/toolkit/content/widgets/browser-custom-element.js
@@ -6,16 +6,17 @@
 
 // This is loaded into all XUL windows. Wrap in a block to prevent
 // leaking to window scope.
 {
 
 const elementsToDestroyOnUnload = new Set();
 
 window.addEventListener("unload", () => {
+  console.log("Destroying on unload: ", elementsToDestroyOnUnload.size, window.location.toString());
   for (let element of elementsToDestroyOnUnload.values()) {
     element.destroy();
   }
   elementsToDestroyOnUnload.clear();
 }, { mozSystemGroup: true, once: true });
 
 class MozBrowser extends MozElementMixin(XULFrameElement) {
   static get observedAttributes() {
@@ -661,16 +662,17 @@ class MozBrowser extends MozElementMixin
     }
     return this.markupDocumentViewer.textZoom;
   }
 
   get isSyntheticDocument() {
     if (this.isRemoteBrowser) {
       return this._isSyntheticDocument;
     }
+    console.trace(this.outerHTML);
     return this.contentDocument.mozSyntheticDocument;
   }
 
   get hasContentOpener() {
     if (this.isRemoteBrowser) {
       return this.frameLoader.tabParent.hasContentOpener;
     }
     return !!this.contentWindow.opener;
