# HG changeset patch
# User Jan Odvarko <odvarko@gmail.com>
# Date 1462448571 -7200
#      Thu May 05 13:42:51 2016 +0200
# Node ID 05af6e2efaf539672aa846c88ca2225a8c8864b4
# Parent  2f9351bae69d056e4615d21dda6bf42fec5d16b7
Bug 1266419 - Use HTML API for frames menu; r=bgrins

diff --git a/devtools/client/framework/toolbox.js b/devtools/client/framework/toolbox.js
--- a/devtools/client/framework/toolbox.js
+++ b/devtools/client/framework/toolbox.js
@@ -21,16 +21,18 @@ var promise = require("promise");
 var Services = require("Services");
 var {Task} = require("resource://gre/modules/Task.jsm");
 var {gDevTools} = require("devtools/client/framework/devtools");
 var EventEmitter = require("devtools/shared/event-emitter");
 var Telemetry = require("devtools/client/shared/telemetry");
 var HUDService = require("devtools/client/webconsole/hudservice");
 var viewSource = require("devtools/client/shared/view-source");
 var { attachThread, detachThread } = require("./attach-thread");
+const Menu = require("devtools/client/framework/menu");
+const MenuItem = require("devtools/client/framework/menu-item");
 
 Cu.import("resource://devtools/client/scratchpad/scratchpad-manager.jsm");
 Cu.import("resource://devtools/client/shared/DOMHelpers.jsm");
 
 loader.lazyGetter(this, "toolboxStrings", () => {
   const properties = "chrome://devtools/locale/toolbox.properties";
   const bundle = Services.strings.createBundle(properties);
   return (name, ...args) => {
@@ -115,16 +117,20 @@ const ToolboxButtons = exports.ToolboxBu
 function Toolbox(target, selectedTool, hostType, hostOptions) {
   this._target = target;
   this._toolPanels = new Map();
   this._telemetry = new Telemetry();
 
   this._initInspector = null;
   this._inspector = null;
 
+  // Map of frames (id => frame-info) and currently selected frame id.
+  this.frameMap = new Map();
+  this.selectedFrameId = null;
+
   this._toolRegistered = this._toolRegistered.bind(this);
   this._toolUnregistered = this._toolUnregistered.bind(this);
   this._refreshHostTitle = this._refreshHostTitle.bind(this);
   this._toggleAutohide = this._toggleAutohide.bind(this);
   this.selectFrame = this.selectFrame.bind(this);
   this._updateFrames = this._updateFrames.bind(this);
   this._splitConsoleOnKeypress = this._splitConsoleOnKeypress.bind(this);
   this.destroy = this.destroy.bind(this);
@@ -390,17 +396,17 @@ Toolbox.prototype = {
       let framesPromise = this._listFrames();
 
       this.closeButton = this.doc.getElementById("toolbox-close");
       this.closeButton.addEventListener("command", this.destroy, true);
 
       gDevTools.on("pref-changed", this._prefChanged);
 
       let framesMenu = this.doc.getElementById("command-button-frames");
-      framesMenu.addEventListener("command", this.selectFrame, true);
+      framesMenu.addEventListener("click", this.selectFrame, true);
 
       let noautohideMenu = this.doc.getElementById("command-button-noautohide");
       noautohideMenu.addEventListener("command", this._toggleAutohide, true);
 
       this.textboxContextMenuPopup =
         this.doc.getElementById("toolbox-textbox-context-popup");
       this.textboxContextMenuPopup.addEventListener("popupshowing",
         this._updateTextboxMenuItems, true);
@@ -1663,89 +1669,119 @@ Toolbox.prototype = {
       to: this._target.form.actor,
       type: "listFrames"
     };
     return this._target.client.request(packet, resp => {
       this._updateFrames(null, { frames: resp.frames });
     });
   },
 
-  selectFrame: function(event) {
-    let windowId = event.target.getAttribute("data-window-id");
+  /**
+   * Show a drop down menu that allows the user to switch frames.
+   */
+  selectFrame: function (event) {
+    let menu = new Menu();
+
+    // Generate list of menu items from the list of frames.
+    this.frameMap.forEach(frame => {
+      // A frame is checked if it's the selected one. If there is no
+      // selection the top level frame is checked by default.
+      let checked = this.selectedFrameId ?
+        frame.id == this.selectedFrameId : !frame.parentID;
+
+      // Create menu item.
+      menu.append(new MenuItem({
+        id: "frame-id-" + frame.id,
+        label: frame.url,
+        type: "radio",
+        checked: checked,
+        click: () => {
+          this.onSelectFrame(frame.id);
+        }
+      }));
+    });
+
+    // Show a drop down menu with frames.
+    // XXX Missing menu API for specifying target (anchor)
+    // and relative position to it. See also:
+    // https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Method/openPopup
+    let rect = event.target.getBoundingClientRect();
+    let screenX = event.target.ownerDocument.defaultView.mozInnerScreenX;
+    let screenY = event.target.ownerDocument.defaultView.mozInnerScreenY;
+    menu.popup(rect.left + screenX, rect.bottom + screenY, this);
+  },
+
+  /**
+   * Select a frame by sending 'switchToFrame' packet to the backend.
+   */
+  onSelectFrame: function (frameId) {
+    // Send packet to the backend to select specified frame and
+    // wait for 'frameUpdate' event packet to update the UI.
     let packet = {
       to: this._target.form.actor,
       type: "switchToFrame",
-      windowId: windowId
+      windowId: frameId
     };
     this._target.client.request(packet);
-    // Wait for frameUpdate event to update the UI
   },
 
-  _updateFrames: function(event, data) {
+  /**
+   * A handler for 'frameUpdate' packets received from the backend.
+   * Following properties might be set on the packet:
+   *
+   * destroyAll {Boolean} : All frames have been destroyed.
+   * selected {Number}: A frame has beend selected
+   * frames {Array}: list of frames. Every frame can have:
+   *                 id {Number}: frame ID
+   *                 url {String}: frame URL
+   *                 title {String}: frame title
+   *                 destroy {Boolean}: Set to true if destroyed
+   *                 parentID {Number}: ID of the parent frame (not set
+   *                                    for top level window)
+   */
+  _updateFrames: function (event, data) {
     if (!Services.prefs.getBoolPref("devtools.command-button-frames.enabled")) {
       return;
     }
 
     // We may receive this event before the toolbox is ready.
     if (!this.isReady) {
       return;
     }
 
-    let menu = this.doc.getElementById("command-button-frames");
+    // Store (synchronize) data about all existing frames on the backend
+    if (data.destroyAll) {
+      this.frameMap.clear();
+    } else if (data.selected) {
+      this.selectedFrameId = data.selected;
+    } else if (data.frames) {
+      data.frames.forEach(frame => {
+        if (frame.destroy) {
+          this.frameMap.delete(frame.id);
+        } else {
+          this.frameMap.set(frame.id, frame);
+        }
+      });
+    }
 
-    if (data.destroyAll) {
-      let menupopup = menu.firstChild;
-      while (menupopup.firstChild) {
-        menupopup.firstChild.remove();
-      }
-      return;
-    } else if (data.selected) {
-      let item = menu.querySelector("menuitem[data-window-id=\"" + data.selected + "\"]");
-      if (!item) {
-        return;
-      }
-      // Toggle the toolbarbutton if we selected a non top-level frame
-      if (item.hasAttribute("data-parent-id")) {
-        menu.setAttribute("checked", "true");
-      } else {
-        menu.removeAttribute("checked");
-      }
-      // Uncheck the previously selected frame
-      let selected = menu.querySelector("menuitem[checked=true]");
-      if (selected) {
-        selected.removeAttribute("checked");
-      }
-      // Check the new one
-      item.setAttribute("checked", "true");
-    } else if (data.frames) {
-      data.frames.forEach(win => {
-        let item = menu.querySelector("menuitem[data-window-id=\"" + win.id + "\"]");
-        if (win.destroy) {
-          if (item) {
-            item.remove();
-          }
-          return;
-        }
-        if (!item) {
-          item = this.doc.createElement("menuitem");
-          item.setAttribute("type", "radio");
-          item.setAttribute("data-window-id", win.id);
-          if (win.parentID) {
-            item.setAttribute("data-parent-id", win.parentID);
-          }
-          // If we register a root docshell and we don't have any selected,
-          // consider it as the currently targeted one.
-          if (!win.parentID && !menu.querySelector("menuitem[checked=true]")) {
-            item.setAttribute("checked", "true");
-            menu.removeAttribute("checked");
-          }
-          menu.firstChild.appendChild(item);
-        }
-        item.setAttribute("label", win.url);
-      });
+    // Check out whether top frame is currently selected.
+    // Note that only child frame has parentID.
+    let topFrameSelected = true;
+    if (this.selectedFrameId) {
+      let frame = this.frameMap.get(this.selectedFrameId);
+      topFrameSelected = !frame.parentID;
+    }
+
+    // If non-top level frame is selected the toolbar button is
+    // marked as 'checked' indicating that a child frame is active.
+    let button = this.doc.getElementById("command-button-frames");
+    if (topFrameSelected) {
+      button.removeAttribute("checked");
+    } else {
+      button.setAttribute("checked", "true");
     }
   },
 
   /**
    * Create a host object based on the given host type.
    *
    * Warning: some hosts require that the toolbox target provides a reference to
    * the attached tab. Not all Targets have a tab property - make sure you
diff --git a/devtools/client/framework/toolbox.xul b/devtools/client/framework/toolbox.xul
--- a/devtools/client/framework/toolbox.xul
+++ b/devtools/client/framework/toolbox.xul
@@ -114,20 +114,17 @@
   <notificationbox id="toolbox-notificationbox" flex="1">
     <toolbar class="devtools-tabbar">
       <hbox id="toolbox-picker-container" />
       <hbox id="toolbox-tabs" flex="1" role="tablist" />
       <hbox id="toolbox-buttons" pack="end">
         <toolbarbutton id="command-button-frames"
                        class="command-button command-button-invertable devtools-toolbarbutton"
                        tooltiptext="&toolboxFramesTooltip;"
-                       type="menu"
-                       hidden="true">
-          <menupopup position="bottomright topright"></menupopup>
-        </toolbarbutton>
+                       hidden="true" />
         <toolbarbutton id="command-button-noautohide"
                        class="command-button command-button-invertable"
                        tooltiptext="&toolboxNoAutoHideTooltip;"
                        hidden="true" />
       </hbox>
       <vbox id="toolbox-controls-separator" class="devtools-separator"/>
       <hbox id="toolbox-option-container"/>
       <hbox id="toolbox-controls">
