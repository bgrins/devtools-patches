# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  a2218cfa23566a401f73d2ed37aab104711a9a3f
asdf

diff --git a/browser/devtools/shared/widgets/SideMenuWidget.jsm b/browser/devtools/shared/widgets/SideMenuWidget.jsm
--- a/browser/devtools/shared/widgets/SideMenuWidget.jsm
+++ b/browser/devtools/shared/widgets/SideMenuWidget.jsm
@@ -103,26 +103,26 @@ SideMenuWidget.prototype = {
    *          - checkboxState: the checked state of the checkbox, if shown
    *          - checkboxTooltip: the tooltip text for the checkbox, if shown
    * @return nsIDOMNode
    *         The element associated with the displayed item.
    */
   insertItemAt: function(aIndex, aContents, aAttachment={}) {
     // Maintaining scroll position at the bottom when a new item is inserted
     // depends on several factors (the order of testing is important to avoid
-    // needlessly expensive operations that may cause reflows):
+    // needlessly expensive operations):
     let maintainScrollAtBottom =
       // 1. The behavior should be enabled,
       this.autoscrollWithAppendedItems &&
       // 2. There shouldn't currently be any selected item in the list.
       !this._selectedItem &&
       // 3. The new item should be appended at the end of the list.
       (aIndex < 0 || aIndex >= this._orderedMenuElementsArray.length) &&
       // 4. We aren't waiting for a scroll to happen.
-      (!this._scrollToBottomTask || !this._scrollToBottomTask.isArmed) &&
+      !this._scrollToBottomTask || !this._scrollToBottomTask.isArmed &&
       // 5. The list should already be scrolled at the bottom.
       this.isScrolledToBottom();
 
     let group = this._getMenuGroupForName(aAttachment.group);
     let item = this._getMenuItemForGroup(group, aContents, aAttachment);
     let element = item.insertSelfAt(aIndex);
 
     if (maintainScrollAtBottom) {
@@ -135,17 +135,28 @@ SideMenuWidget.prototype = {
   /**
    * Checks to see if the list is scrolled all the way to the bottom.
    * Uses getBoundsWithoutFlushing to limit the performance impact
    * of this function.
    *
    * @return bool
    */
   isScrolledToBottom: function() {
-    return this._list.scrollTop + this._list.clientHeight >= this._list.scrollHeight;
+    if (this._list.lastElementChild) {
+      // console.log(lastRequest);
+      let domUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                .getInterface(Ci.nsIDOMWindowUtils);
+      let childRect = domUtils.getBoundsWithoutFlushing(this._list.lastElementChild);
+      let listRect = domUtils.getBoundsWithoutFlushing(this._list);
+
+      // Cheap way to check if it's scrolled all the way to the bottom.
+      return (childRect.height + childRect.top) <= listRect.bottom;
+    }
+
+    return false;
   },
 
   /**
    * Scroll the list to the bottom after a timeout.
    * If the user scrolls in the meantime, cancel this operation.
    */
   scrollToBottom: function() {
     // Lazily attach this functionality to the object, so it won't get
